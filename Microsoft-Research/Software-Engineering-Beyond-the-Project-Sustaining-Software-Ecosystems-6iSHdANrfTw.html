<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Software Engineering Beyond the Project  - Sustaining Software Ecosystems | Coder Coacher - Coaching Coders</title><meta content="Software Engineering Beyond the Project  - Sustaining Software Ecosystems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Software Engineering Beyond the Project  - Sustaining Software Ecosystems</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6iSHdANrfTw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so I'd like to introduce Yvonne Dietrich
she is a visiting researcher visiting
the vibe group for another six weeks
working with me Andrew bagel on the
studying one Microsoft and Yvonne is a
professor at IIT university of
copenhagen in denmark and she does a lot
of work in qualitative empirical studies
of software development and software
engineering and she has worked in the
past university of hamburg she's also
been at iit madras I our team on d I'm
in the last couple years in India doing
a lot of distributed globally
distributed software development studies
and I really the first time I heard of
Yvonne she had been talking about her
dissertation work where she had software
developers go to group therapy to learn
how to talk to each other properly and
that's just seemed so incredibly awesome
and I just want everybody to do that so
everyone's dysfunctional everybody could
use some therapy but now we're going to
have some she's going to talk today
about some software engineering
ecosystem work that she's done in the
last year or so their last couple years
at in her job as professor so Yvonne
okay thank you very much and thank you
for inviting me here it's a pleasure to
meet all the people he had microsoft
research and I'm yes and I'm actually
this is this is a piece of research that
has been going on that i would like to
present to you today has been going on
for a while so and it's called self
engineering beyond the project and well
somehow we all when we talk about self
engineering we all take for granted
software engineering takes place in
projects wouldn't you say so so that's
what we're teaching that was what
spears's but we are we're teaching what
we are planning for what the methods are
attributing so what is the project
well these are a number of definitions
we don't have to go read them kind of
when it comes when it burns down there
is a number of characteristics of a
project so a project has a predefined
outcome a goal even if it's not exactly
specified there is some idea that there
should be a product afterwards it's
normally said to have a beginning and an
end it has limited researchers there is
not kind of there's a limited number of
people working at it for a limited time
and it's consists a number of tasks and
activities so that is that in the
definitions that the software
engineering community provides for what
a project is so but what if that is not
the case what if software development
takes place in a different way and what
does that mean for self engineering so
that is what I would like to talk about
today and I will start with some very
very long oat research where I started
to get my doubts about our perception of
what the discipline is about then I will
repeat the main part of the talk we're
looking into software products and that
is probably very relevant for Microsoft
because Microsoft is working with
software products that's more or less
what you're doing and on in a way what
does that mean then afterwards for
software engineering what are the
questions if if the protea product the
project is maybe not the the main entity
of the activities or the main way of
organizing the activities we are
supporting what does that done mean for
software engineering as a discipline
what are the open questions here so I
will start with some beginning doubts
and that was in the late 90s when I
started to do research at making
Institute of Technology after my PhD
we were actually starting to work with
government and as I came in as a
software engineering researcher I
thought okay I would like to talk to the
engineers and to the designers so we
talked with people from a one-stop shop
and that was in a time where in Sweden
the municipality administration got
reorganized into so that you have a
one-stop shop where where citizens go
and and about ninety-five percent of all
the issues we're taking care for them
and it was in this reorganization that
we asked and we asked the head of the
one-stop shop of a small municipality in
seven Sweden and she said well the
designer is that's us I thought kind of
like took me it took me a bit of a time
to understand and to appreciate that
statement because I thought kind of the
designers that's where the computer
scientists that's the technicians that's
the people who are actually doing the
things the stuff so but if you started
to look at the development of Technology
from a youth context perspective you
suddenly had the technology was only
part of what was there to design so we
had we started to call these people than
local designers these are the one stop
shop people at service work we're part
of that so they on the one hand they
develop software together with different
developers they hired and their own IT
people on the other hand they kind of
discussed with the back office people
about what a service provision and of
course by introducing computers into
service provision you have the citizens
coming in and do you have to negotiate
what does it mean to provide municipal
services now partly online so if you
look at that then you have different
things that I get designed and you have
different foci of the design and of
course not all the design is about
knology in the narrow sense but it might
be technology and use how we are
actually deploying technology to provide
better services how does the services
change for that and one of the things
that came about when you look at at the
software development from this work
infrastructure perspective you had not
no clear defined for projects but you
had a diversity of interlaced practices
of design and use so you had projects
where people were developing specialized
software you had products that were
customized configured for the specific
context you had the development of a
internet which was both content
development and technology development
and all that were kind of going on at
the same time so i started i also
thought kind of okay well but there's
some software engineers and if you hear
a municipal administrators talking about
software engineering i have seldom heard
people being that purgatory about
software engineers as they are the main
providers are actually providing
software for the whole government so
they have a whole much bigger picture
and a small municipalities are not in
their focus so they were kind of not
very not like very much but then I saw
kind of like well but you must have some
people with whom you're like to work as
software engineers and they pointed me
to a five-person company selling off the
shelf booking system they had said in a
very strange place very nearly a village
from an American perspective in southern
Sweden in the woods of these five people
actually two were developing the basis
of basic software the two and two others
were customizing the software for the
specific municipalities but they have
customers all over the place though had
they had they have over 300
customers that means municipalities
using their software in suffern suite in
ho Scandinavia Finland Sweden Denmark
and Norway so and we look like their
development practice and at that point
in time the HR manifesto was not out yet
but so we call this what we saw HR
practices so they themselves they said
are we doing it and we kind of me know
that we are not doing the software
engineering way of things but we
actually getting things done and we
don't we managed to get our report line
at the time that we use on report
support we get that down so we looked at
how they actually develop software and
they had they released 20 they had 20
releases pay per year most of these
releases were very small upgrades about
once or twice a year they had a bigger
release whether you actually had to
change the bait database so the database
scheme so they had kind of bigger
installation scripts under underneath so
and that was the first time I saw kind
of like where's the project did they
have been doing that for 10 years at
that point in time 10 15 years and they
were kind of like continuously
supporting the software and continuously
releasing the software they were happy
with it they enjoyed actually new
challenges now and done so they were
moving from a very old fashioned
database to an an SQL database they were
moving from they are moving actually
with that the M David moving to Java so
it was not high end technology they were
happy with it their customers were happy
with it their users were happy so so
this is somehow a different way of
developing software than what I expected
to see in this situation
and that was also the first time I
studied the practice of the development
of a product and then over the time I
did more empirical research and I saw
the same pattern again and again and
again and that is what I want to talk
about today and the implications of that
to define software products software
products are programs that are developed
to be used by more than one user and/or
customer and often need to be configured
and customized for the specific use
context i distinguish between
configuration and customization
configuration is through predefined
interfaces like for example the
definition of filters for email readers
appliance customization is when you
actually start to mess around with the
code in many cases you can do both they
are used over an extended span of time
and they are continuously updated to
match the evolving needs of a market so
that's that is our definition for that
these are examples for example yeah
Microsoft Word is a product you can
actually configure it permanently change
its behavior through a configuration
interface but you also can can go down
to the programming language to macros
and exchange the mattress so you can
actually develop your own word over the
time I did research with several
companies and I will talk about these
four products for four cases in more
death so we'll come back to them again
I'm using a similar figure as for the
diversification of the design in the
u.s. context or from the perspective of
the u.s. context to look at this what we
started to call ecosystems and this one
is a one of the things that we are
talking about this is a dynamics nav at
that point in time they were a few year
before the research they were acquired
by microsoft what I'm describing here is
the boxes are organizations or companies
the people in there there are groups of
developers or users so there's
stakeholders the arrows mean cooperation
around the design of some kind and yam
and here you have multiple organizations
so that's the notation mmm how I did the
research the thing is that I actually
recognized this common pattern after
after a number of research projects with
these these software product companies
so I've we've done a lot of research
mainly together with PhD students on the
individual projects but they all focused
on different areas so how do you done
kind of you know that there is something
that has something in common but how we
do you actually make that accountable in
a scientific way so I went back and did
interviews with these with the with the
partners and with the people in the
companies we did the research with so it
is a an interview study it's based on
three interviews / company and its with
open coding actual coding that's how I
derived the themes that I come to talk
about and it's based on and triangulated
with previous ethnographical old field
work and long-term contact so one of the
companies is
actually people that I know for for 20
years they are friends and they run a
company on developing a software product
the triangulating fieldwork is
documented in a number of articles I
don't have them put put them up for for
reading now if you are interested I can
provide the slides and and you can
follow up on some of the themes however
that is the documentation of the
underlying empirical work I base de d
interview study on so the first product
I would like to talk about and I talk
you through that I with a bit more
detail because on we are you will see
that that makes it also easier than to
to follow the analysis because it's
pulling out the commonalities between
these ecosystems that is UI q UI q is a
daughter of symbian at the Symbian
company you might know that symbian OS
was founded as to come to counter
microsoft phone initiatives as a joint
venture by siemens motorola ericsson
they were founded actually in play King
and that was that is at close to the
University I was working at that time
and we did research for them we did the
research focusing on interaction design
and user experience with the interaction
design group in this company so you IQ
was then at some point in time symbian
was split up into symbian OS and the UI
framework on top of the operating system
so the symbian OS was moved to to London
also to have more people be able to hire
more people and but uiq was stayed in in
flaking em
and yeah what they did they did a user
interface framework they did that
develop that in parallel with specific
applications for the customers that were
also the owners of the company and that
is interesting because you all know
Nokia was spying out the others and made
symbian and uiq the the software open
source and that killed the company so
you could think about it as an ecosystem
because actually if you change it too
much you might actually destroy it they
developed this software they have their
their product their framework they
developed in parallel with the
applications based on it they develop
that these applications by then branded
and and kind of further purified by the
customers and owners and then there's
the usage there and you have on the
other hand you had third-party
developers and who also where they were
not so prominent in the as as users and
customers and that was maybe one of the
errors that the management it here on
the other side they cooperated tightly
with symbian because the user interface
framework was depending on functionality
from the operating system the next the
second here is is innovation division is
developing an ERP systems ERP systems
traditionally came with their own
proprietary database and their own
proprietary language and development
environment that is still the data store
the case for innovation at the time of
the interview they were actually slowly
moving the technology stack implementing
as the database and implementation of
the proprietor language and the the
runtime system over to Microsoft
knology for that that was in the
beginning of the interview I wasn't
really aware of it but for that they
actually had to communicate and drive
requirements into the microsoft
organization and that they didn't
discuss very much about it so for that
they were too much pains these ERP
systems I said that there's these
frameworks and proprietor languages
databases ran time systems that is done
by other day they distinguish between
two groups of developers framework
developers and application developers
and the framework developers they are
responsible for this back-end side of it
and there they say there's different
kinds of developers there's a different
types of developers so these are people
who are kind of really interested in
compiler construction performance very
hard technical stuff application
developers are have often a business
background and they are they have they
know about the domain and that is the
administration of all the data in a
company so the idea is of an ERP system
is that you run your whole bookkeeping
administration accounts human research
through the application opposite to
other yippee systems the idea here was
not as the division and acceptor 30
readings targeting smaller companies
than for example essay p who is the high
end product in the market and that meant
also that they said ok we are providing
a basic functionality but they are
opened very quickly for partners to not
only configure the software but to
actually customize the code so the erp
systems are shipped together with the
development environment for for these
people to actually program
these customizations can be changes in
the business rules but they can also be
so-called verticals that means they are
developing a whole new module for
example a module for a specific business
area we had one partner they were
developing for a small airplane carrier
they developed the whole module about
what is the flight and what our seats
and tickets and and pilots and and
attendees so so this means that you do
is vertical so you have changes in the
database you do a piece of program that
has some interaction with the base
program and then you do the interface on
top of that and of course for that they
are communicating very tightly with the
customers here
the next thing is also that they are
they were also fun they are company
doing erotic simulation for that's
actually the nicest pictures in my
slideshow what they're doing it they're
simulating water flow and they have
one-dimensional two-dimensional and
three-dimensional simulation entrance
and they combine them sometimes this is
Canberra in Australia and you see kind
of a river here as it's not exactly
under the blue line but so so what do
you do is your abstracting the
topography of a water system you
identify sections for the model when you
use these sections and you define how
the how the riverbed looks like you have
rain water runoff system models there
and based on that then you run
simulations simulations for example
saying okay if you have a heavy rainfall
how will the water in the river behave
when will it flat things like that so
you can also simulate for example what
happens if a damn it breaks the company
is one of three or four what what
leading companies and that techniques
they have been doing they have been
modeling the Nile system for example
they there's that's also one of the
things I learned the reason why the the
Egypt Egypt has a big military they are
so much depending on the knives so they
have to be able to protect their water
sources so that is one of the
motivations for them anyway wait
yeah we have two should have doubled
that slide so at the time of the
interview they were reorganizing the
organization previously the the
simulation engines were maintained and
developed by departments focusing on
certain modeling tasks so the main
business as the main business they
regarded consultancy for governments and
for four other actors about impacts of
constructions on the behavior of the
water oceans on the behavior of oceans
or rivers so they had the the engines
and the software maintained close to
these consultancy groups they recognized
that was not on the long run this was
not actually a way a sustainable way for
the software part of it so and they
wanted to sell the software more
independently than the than before so
they started to develop the software in
an own unit but of course these people
in this software development unit they
were tightly interacting with the people
using this software for the specific
consultancy consultancies on the other
hand they were developing not only that
they the people here were configuring
configuring or kind of defining the
simulation models that were run by the
systems they were also when you found a
kind of element assimilation element
that was not yet supported by the system
these people were had all hot rollick
engineering education they might have
had a PhD and in applied mathematics so
they all could program so they actually
all added to the code base which was
also an issue because
meant that the code base develop pretty
sometimes pretty in a pretty
uncontrolled way so however these people
in the city in the in the when we kind
of did the research with them they
started to develop another set of
customers where you had kind of
permanent simulation of water systems in
order to to to manage the water system
at the same time so they would actually
content continuously say okay if we have
so many rain then we might actually have
a flooding in two days in in the city so
that means how can we can we prevent
that and how can we work with that in
the head of time so they wear that was
the water management solutions where you
did not only ship a report to the
customer but you ship the whole system
operational system to the customer and
of course there were other users who use
the software as well
the last system is a very different
system that is a system administration
tool here it is a again a very small
company who on one hand did system
administration for governmental
organizations in Germany so they had
their specific customers and and they
kind of what they in order to do the
system administration they had to need
to have a automatic distribution and
installation tool for software in the
local area network there are industries
solutions for that I'm counting on that
some of one of these the solutions might
actually be produced here however they
are very expensive they don't work for
small organizations so they developed
under nenda thought okay well kind of
let's do it ourselves so developed an
open source product that they together
with the customer day they further
developed that however as it was an open
source of course other people can use it
here again we have the basic software
but to run the software you need
installation scripts of four specific
programs on specific operating systems
and specific hardware and these
installation scripts they were of course
done by them but they were also done and
shared by the open source community on
the other side with this tool they ship
the UNIX kernel so every time the UNIX
kernel changed they had to change and
also every time the operating systems
change they had to change so one of the
big projects was to make this system
able to handle windows vista because
that obviously worked very differently
from the previous windows
versions so yes so now kind of why did I
talk you all through this kind of
different cases and different examples
and what can we learn about them one of
the main things is that if you look at
the series of ecosystems in none of the
ecosystems there was the development
took place in one place so there was
what so the the final design the thing
that was running here at 50 user that
was based on on one hand the direct
communication with the people installing
that system here but that again was
based on some other software and
sometimes the chain here like in an
efficient chain this was actually much
longer and each of these stages added to
factor the final software that means you
have to think about an interlaced system
or kind of related system communicated
system of different design
constituencies what happens here with
the on the youth side is depending on on
processes and design decisions taken far
away far away from the user so it's also
difficult to influence this so I'm also
into youth oriented design and
development of software so a lot of the
usability methods that we are actually
teaching they kind of take for granted
that the divorce system so the software
engineer then developing the software
has actually is in charge of the design
but that might not be the case in all
places for that reason one of the things
that was identified as most problematic
was to communicate
with the user and with the user
community so and all the companies did
extra work to to be in touch with their
their user organization so here in
inhibition they had big conferences
worldwide conferences where they invited
users partners introduced new features
discuss new features with them here in
the in the they had the same thing they
had companies conferences user
conferences where they also try to
identify new features that are new
directions to go to him uiq had their
own user group because well that they
had where they did long term studies of
the usage of certain applications and
features in the phone so with other
words with other words the the as it is
not clear who exactly is the user and
you're not cooperating with the user you
have to as there's a different way of
interacting with your user community
yeah clarifying question when you talk
about users in this context does each
group
talk about the user one step down the
line like the framework developers users
of the application developers not the
customers like is it that kind of user
or does everybody realized the end
customer who actually pays money it's
the user everybody is pretty aware that
the end customer is the main user and
these are the people who are paying the
show so all of them are kind of getting
into into this here what what comes from
from a usability point of view here here
is as the usability work at this product
development has to take that into
account that you're not actually
developing for a specific user but
you're developing for a whole group of
users so and I think that actually a
Microsoft had the most advanced system
in place here but also uiq was not not
that bad are they also very very good
the other thing is from a from a
software engineering point of view you
have actually a situation where you have
a use before you have a design so
there's people using the software and
who are acquainted with the software who
actually know what the software can do
for them so you have also a different
level of interaction with to use the
unit developing from scratch
from a product point of view and that
might be more interesting also from from
from a technical side here you have you
need technologies that supports both the
evolution and the difference of the
design so the design is deferred to the
youth context and you can say like okay
well what does that mean what we have we
have a lot of of technologies that
supports and kind of the rationalization
or generalization of design we have
aspect oriented development we have
traits we have model driven development
things like that however all these kind
of technologies are focusing normally on
having software engineers as users
however if you do it like that you don't
have necessarily software engineers as
users in these ecosystems you might have
software engineers as users you might
have business people as users you might
even have people who have no software
education and no technical education as
somebody who's actually configuring the
software so with other words the
challenge here is to to make these
technologies to lift them up to the user
level to a domain expert level and yeah
the other thing is that when you when
you kind of combine evolution and the
difference of design especially if you
have to allow the user to change your
code your source code or the source code
of the application then you get problems
with the upgrade because you have a
two-dimensional evolution of the
software so when that is still an
unresolved issue because you dude the
techniques that we have for that they
work when you can anticipate at exactly
which kind of places you will have a
change but they don't work when you
cannot
predict which kind of places would
change a colleague of mine was into
programming languages in the beginning
of the the the some of the research
underlying it he said what kind of we
have also office they just have to use
our technologies in the anti two years
later he wrote an article together with
one of the PhD students detailing how
all the technologies from the from the
scientific community for for short and
supporting for example erp
customizations in this respect what you
also have is the end-user development
interface that is here for customization
and configuration that is only one of
the technical interfaces pc between the
design constituencies so also the
interface here for example in between on
one hand you IQ and symbian and upward
here somehow ad interface versus an API
this was also an API so the the
Interfaith the interfaces between the
technical interfaces they are separating
and preaching between different design
constituencies and these interfaces are
contested because you want to do the
development here sometimes they kind of
reported about that they didn't have the
resources to develop a specific feature
these guys wanted it so they developed
it themselves because they also had and
at some point in time they were saying
well kind of but anyhow we have this bit
of code here that every time something
you change do you change something here
and that is rather frequent we have to
change with it so this actually should
be maintained here so they act they
shipped code between companies and they
did the same here between uiq and
Symbian so with other words
these interfaces have to be carefully
also maintained over time a last thing
is as this and as you have this multiple
level evaluation on all the company
older companies worked so you saw kind
of they should have a high level of
architectural documentation they didn't
they worked what with what we called a
walking architecture that means people
who had the architecture in the head and
walked around and they were and we
discussed with them why why don't you
just write it down why don't you
distribute it why don't you have a
website explaining your architecture
especially with these big ones where you
had a huge number of people developing
the software division at that point in
time there were about 200 people
developing the software and they said
well kind of if we as one of the noke
the PhD student working with the
architecture in the project she did a
interview with a number of randomly
selected but she went to a fair to the
decebet in in germany and kind of talk
to people and had a number of different
did interviews there and she what came
out of it is that one of the reasons why
the architects were reluctant to put
down the description of the architecture
is that then the developers would use
the ID texture without consulting them
and that meant that they wouldn't get an
update about what by critical aspects in
the software so they used in a way
somehow as they used in as we call that
in the in the article good architectural
reasons for a bad architectural
documentation you had a question yes
interesting I was thinking about the way
that you talked about the interfaces
between each group
in that
when we learn in school how to revolve
your AP is you think object-oriented
programming make a subclass or you make
an interface and then you just add
interfaces for an extra functionality
but you try not to believe opens now but
the notion of being able to sort of
change the boundary where the
functionality is at all like the API oh
it's here well actually it needs to be
pushed further up this way this one
needs to be pushback it's almost like
web design in that give to decide
whether to put things in the client the
mid-tier or the backend server and the
division sort of changes as your
performance characteristics change and
are there sort of established I guess I
don't want to say formal ways to talk
about that kind of architectural
evolution or is it just a negotiation
between parties which is kind of as I
haven't encountered any formal way of of
this kind of negotiation on a Nike
texture level but in the indie in the
cases it was a negotiation and it is
stolen negotiation so if nav they had to
say like okay does the database that's
the sequel database does it do what we
wanted to do or do we have to do some
add-ons or are they doing add-ons for us
or or do we keep our proprietary
database so this it's in a way somehow
it's it's not theirs there's a problem
and there's many solutions that went
that's why you call it design also the
negotiation rather leaves a big problem
where the customers don't have
it's not there's much more
organizational friction between
customers negotiating with vision and
division negotiating with the rest of
Microsoft that at least division was
owned by microsoft so they could at
least call them up on the phone and
actually find out their email addresses
whereas the customers can't and so like
their power to move the boundary isn't
as they don't have as much power we kind
of the yes and no but they are no guilty
about something else here the they are
the negotiate a all friendly relation
because in a way somehow these people
are earning money by doing special
features so if now Microsoft gets
interested in implementing the special
feature in their own software than they
are losing a losing business here so
with other words you have a negotiation
of a different kind of the boundary on
that side yeah so sometimes sometimes
and some kind of sometimes sometimes
actually I think the vision I did not I
don't know whether they did that after
they were acquired by microsoft but I
know it from before that they actually
bought sometimes they bought software
from the partners to make it part of
their main application so and that was
also so what's very interesting when we
did interviews Aires with these people
they kind of also try to make that was
in this in the in the time when when
they changed the proprietary database to
the sequel and with the sequel database
you couldn't do certain things as a
partner so they had a proprietary
database at a very smart indexing system
so you can could do very quick searches
and reports so so they were kind of
trying to lobby through us to get back
to the deed proprietary database so that
was so so if what i want to say whether
it is is that these are negotiation
points of who is doing what in this
context and the same here somehow what
can an internal IT department do or
smart super user and when do you ask a
consultant's consultancies they are
taking I don't know what the consultants
in in the u.s. at is taking but I think
it's in about thousand danish crowns
which is 150 hundred sixty two hundred
dollars so it's quite an amount of money
also so so there is also there is a
competition between these guys on the
one hand they have the same kind of
interest what's microsoft on the other
hand they are competing for the users of
40 customers here and they are somehow
taking each other's customers because
its introduction of new IP system is
normally related to a high friction in
the organization so after their first
implementation many companies tend to
switch their their their consultants so
there's also kind of theirs it's not
that you'e corporate around the design
doesn't always mean that you're nice to
each other so but with with other words
when we were discussing this kind of
multi-layer development I think there's
also another point that we don't really
in the programming technology we don't
have concepts to for this multi-level
development or what we have concepts but
they are normal they are often not
working for this real world application
contexts the last one is the process and
that was actually surprised it was
pretty I knew that there was kind of
this continuous development but when i
started to delay interviews all of them
said well yes yes we have the the one of
them corded the heartbeat of the product
that's is where new features are
released
so and that was kind of like a steady
pace and it was kind of characteristics
for the characteristic for each of the
products so they had a heartbeat from
half half a year so every half year they
had a new release with new features
things like that they were also three
developers working on it so it was not a
big thing the company the appeal systems
they had at that point in time a
three-year release cycle and they are
they were about to bring it down they
tried to bring it down I think they are
down now with one year so so however
whatsoever the characteristic heartbeat
of the product was there was one cycle
that was quicker and that was back
fixing or small features patches that
was about one-tenth of the time so if
you had a half a year release cycle then
the patches were every every week every
two when you have three years release
cycle the patches the the bug fixes were
every 2-3 months so you had kind of it
was kind of like a the devil kind of a
relationship but we didn't put numerics
on it so that that was but then there
was another cycle which we actually
discovered in which I discovered in the
interviews and that was because you had
these new features and the features were
not anticipated in beginning so often
the technical design the architecture
did not actually support these features
so over time we did the technical design
got worse so so in a regular base they
had to renew the technical design and
that was normally across several of the
heartbeat releases so when the vision
was replacing the technology stack with
Microsoft technologies
they couldn't put just a three-year
release just on changing the technology
because then they wouldn't have been
able to sell anything anymore so what
they did is actually they they sliced in
the transfer to the Microsoft stack in
over several of the releases the here
the smallest the open source that was
every two years or every every 3-4 years
they had to redo for example their data
structure because the new operating
systems had the boiled new features new
operating systems or that is was was
kind of got into the way okay so Saudi
with other words also there's different
drivers for different development cycles
so they roughly we had this this
research and maintenance and
categorization of maintenance they
roughly correspond to the three
maintenance categories back fixing new
feature a a corrective complimentary and
proactive maintenance how to organize
such a process is contested so there
were a lot of discussion Microsoft had
different organizations depending on the
kind of release when it was a feature
heavy release they had feature teams if
it was like a bag and heavy release or a
front application heavy release they had
they put the framework changes in the
beginning and then kind of did as you
get them out of the way get them done
and then focus on the application level
uiq was was expended they were
experimenting with feature teams module
oriented teams they were experimenting
with split
maintenance from development so and as I
said uiq the simulation software this
company was reorganizing in order to be
able to focus more on the software and
and not so much on the on the on the
application so what was one of the
points was that you had to keep track
and what happened with in the other
design constituencies because what
happened to hear in the partner space
will tell you something about what is
new features here on the other hand what
happens yet Microsoft will kind of tell
you whether you get into problems in the
future so you had to actually keep track
with with these things so what are
projects done in this context and you
could say a release is a project but the
release is not a project because it's
it's not from scratch and also it's not
as closed in these companies what they
did organized as project sometimes was
these changes in the technological base
so they had a project going on in
parallel to their evolution
restructuring that main data structure
or reworking the main data structure in
the simulation software when they
actually moved moved to Colonel one of
the computational kernels from a Fortran
program to I think that they used C
sharp in the end that was kind of the
whole restructuring a rework of the
colonel that was a project so what you
have is that the project is kind of a
temporary closure that you do to do
certain kind of technological as a tool
to have peace and quiet to do a piece of
design in a good way so that it's by far
not the only not the main way of
organizing here so yeah that's kind of
coming back
as a summing up the results there is no
single project but an interlace of
development activities requirements are
moving so even during the release
requirements are moving all the time
they cannot be regarded as fixed but are
a subject to multi-level level feedback
cycles that you do not control as an
organization there is no one process by
the continuous development with several
rhythms overlaying each other so it's
more than HR development in that respect
software is not necessary developed
before it is used so it's sometimes used
before it's developed that means new
solution have to take social and
technical heritage into account
architectural knowledge and knowledge
management needs to support continuous
evolution and that means also if we knew
if we want to have architects in this
context to architectural diagrams we
have to actually support them with
keeping up-to-date with problems in the
problems in the code base so they can
actually continues continue continuing
to develop continuing developing their
architectural dead there I detection and
there is no blank slate never that is
confirming some thing that Lucy
settlement said in another context that
we cannot design as as if we come from
nowhere we always have to in this
context especially specifically we are
always facing our technical design on
something that is already there and we
have to to take that heritage into
account and that is what does that now
mean for software engineering many
software engineering methods and tools
are based on the notion of a project and
we might have to reconsider that we need
to cope with interlace of heterogeneous
development and use activities and how
we actually make
of the possible possible bility of
getting feedback about needs and wishes
and and how things are used in the
continuous development cycle and that
means also we should actually start to
support design collaboration along the
chain of design not only within a
project but along this chain of of
design constituencies from a youth site
we have to think about from coming from
ease of use to ease of design most most
of these applications can be configured
by this by the end user and end users
are willing and able to do that they
need good user interfaces for that or
good designer interfaces for that and
that requires that we actually think
about when we design a software product
we should not think about designing the
functionality but we should think about
designing environment for somebody else
to design and for that we have academic
tools and languages that are solving
some of these problems or providing us
with tools for that however they need to
develop to fit the reality of software
product ecosystems and that means we
cannot ask for example people at the
partners to to use formal methods as
former methods if we want to have formal
methods on that level we media to make
it more usable and we need also to to to
allow as we need to get a better
understanding of the requirements for
such tools and languages and especially
what does it mean to open as a tool to
use them to provide end-user development
interfaces for for non professional
developers
yes and thatÃ­s the last slide and the
question in a way but Andy and I were
doing the last two weeks we're talking
to people here in Microsoft and
understanding the reorganization and one
of the reiterating things that came
about is work enough when we're
deploying things on the cloud things get
different but what what gets different
well we it's not different that we have
users and it's not different that we
have software products that are
configured and that we are depending on
other products so however it seems one
of the things that I would say is a
hypothesis that the process is
development processes and the deployment
processes but there the notion of the
release starts to disappear yes it's
going towards continuous deployment what
does that mean for the cooperation with
the other actors in the ecosystem
especially the users and how can we
support this continuous evolution on
multiple levels because just because I'm
I'm kind of changing DD the operating
system does not mean that I changed ed
services based on it or does it that I
stop changing the services based on it
so we have even more challenging
dynamics in these ecosystems so thank
you
so what's been surprising as one of the
things is that if you have this even
more challenging dynamics as a disc that
you that operating systems don't take
three years but one year releases
funnier rhythms it becomes much more
important I think to to to have an
understanding about what are the
features somebody else has to deliver so
that I can deliver my feature here and
so there's there's in a way that I think
the tendencies that I described here and
that's good you could say is based on
all technology they get more extreme in
that respect so you have to be much more
knowledgeable about what what the
operating system is is doing in order to
build a cloud based on it in order to
order what what the server windows
servers are doing in order to base the
cloud on it in order to be able to
deploy software based on it so you and
so that is that is so so a lot of things
I would say are the same or I kind of
see it again with these kind of did the
challenge of kind of you have a
requirement you want to do certain
things but that means that you are
depending on somebody else to do certain
things and and how to negotiate this but
in a way somehow in a more fast-moving
environment this is in a way even more
important
so what you talked about which is
layouts a model there
intimately
and what problem
program managers and product managers
yeah but that is that is one of the
things because that is what we have been
taught in the university that you have
your requirements and you fix them and
then you develop your software and
everything else is a defense a is a
problem or is a defect you haven't done
your requirements right if they change
so that is that is what we have been
full fed up with other work what we have
been fed to kind of like that's what our
professor said to us so you have too
much more except that you're in a moving
environment and it that you cannot have
this closure for for the the 6 month
that your development takes so you have
to actually instead of having all these
these techniques and and notations to
actually box your project you have to
think about how do I communicate how do
I keep track with the users so so so
dddd the and and for that we need to
develop techniques and tools and
concepts because we don't as we have a
lot of of software product developers
who are obviously successful and they
all do stuff that we don't teach at the
universities they do use their
communities as a day they run user
communities they run they have have
conferences for their users and for
their partners they have had so day they
have pilot users and work with them so
all these kind of things we don't teach
so we should actually start teaching it
and we should start developing and and
abstracting concepts and methods for
that sorry software development keeps
getting faster or
deployment your cadence for deployment
you would like to be able to deploy
daily that works for things like
snapchat which at this point you know
I'm sure the first version of snapchat
took them all of the week to build and
then they get four billion dollars for
doing that I forget which one they were
but what happens two pieces of
technology that are complex that are
hard to build that you can't build in a
week like you know getting a Windows
kernel right you know that's taking
obviously years and even just to try to
build like let's say some new feature
it's right even in the open source world
where they go faster is really kind of a
challenge I mean it's hard to do that
mm-hmm so if you have such a fast
cadence does that mean that you can only
have the fast cadence for the simple
stuff and what happens to the complex
stuff if your market changes every month
and you're not done yet how's the day uh
I don't have an answer so that's a good
question i think that is that is one of
the ditch of course in a way when you
add people to to fasten the project you
also add overhead so and it's at a
certain point of time adding people
doesn't help you actually open source
india gifts gives an indication about
how software engineering could scale
because they manage to scale other they
managed to have a lot of developers
doing some kind of coordinated things to
one piece of software even if they have
a parliament and whether they have
governance structures both organization
otherwise and and tool wise so there is
some kind of possibility but it means
also as if you start from scratch with
developing something there there will be
somehow an initial investment and and
maybe maybe we are lucky that we don't
have to develop all operating systems
from scratch
and somehow for the devices that that we
had the new devices we actually know how
to develop soft operating system so we
have kind of experience we can they take
that experience and and and continue
based on it so I kind of I don't have an
answer so but but you might be might
look into the open source communities to
see how how this can be done the other
thing is that you that it was still for
some more complex software we will still
have as a really fundamental changes
will take time as a new concept for
operating systems that might take time
alright okay thanks very much thank you
and yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>