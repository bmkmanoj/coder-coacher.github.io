<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Brief History of Type (and some creepy crawlies) | Coder Coacher - Coaching Coders</title><meta content="A Brief History of Type (and some creepy crawlies) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Brief History of Type (and some creepy crawlies)</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/scC_0Udvn_c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so here's some of the spinning of
answers and it would be rather difficult
to summarize this in a short amount of
time I'm not going to attempt it instead
I tried to organize it into major groups
and in fact the the second major group
the the ml / polymorphism / parama
tricity etc I think other people have
talked about so I'm going to concentrate
on the first part of the story the part
that I know better about object
encodings and the first paper that
people remember in this area is probably
this one of semantics of multiple
inheritance from 1984 where the idea was
there are all these different object
oriented languages and and they have all
these different features how can we
understand them oh but we have lambda
calculus and that's nice and and it
provides a simple unifying framework so
can we use lambda calculus to explain
the ideas in object oriented languages
well no not quite because something
crucial is missing and that is subtyping
so so the technical innovation of this
paper was to add subtyping to a lambda
calculus context and and then to show
how to how to define objects using
recursion and and record types to model
many not all of the fundamental features
of object-oriented programming
quickly after that came another very
influential paper that we've seen
mentioned a couple of times on
understanding types data abstraction and
polymorphism with peter wagner which
surveyed a lot of ideas from types but
but introduced in particular the idea of
combining subtyping with polymorphism in
the style of system f and introduced the
term bounded quantification there's one
little technical point that's worth
making this paper introduced bounded
quantification in one of its forms in
its simpler form which later came to be
called the the kernel fun variant
because fun was the name of the language
in the paper and the the more
complicated form that a lot of people
had fun studying was actually introduced
later by members of the audience I and
it looks like this so the difference is
whether you get to have a subtype on the
left-hand side of the arrow in addition
to the one that you get on the right
hand side of the arrow up there and not
to be left out of the fun Luca also
contributed to this investigation of
system f sub in particular this paper
laid out in a very beautiful way a lot
of things that were known about the meta
theory of the system and a bunch of
things that were new about its
equational theory but objects are not
only about bounded quantification a lot
of other things went into these models
so so one was the notion of records and
when you mix records with polymorphism
and you want to be able to update them
and you think that functional
programming is good and you don't want
nasty reference cells in your formalism
then you discover that the the
manipulations that you need to do on
records and the typing involved is
rather tricky so so this was really an
attempt to to break down records into
into their constituent part
and to have a theory of those particles
and this again was a very influential
starting point for many other papers by
other people that that spun variations
another crucial element of the story was
recursive types and and again Lucas
started a kind of cottage industry of
decision procedures for subtyping for
various notions of combinations of type
systems with recursive types and that
story indeed continues today people are
still trying to figure it out and a lot
of these ideas were brought together in
the quest language which again we've
heard mentioned in this in this paper
type full programming and quest was I
was is a language bringing together
subtyping higher-order polymorphisms so
f Omega sub is the name of that system I
again a cottage industry in its own
right with records and and recursive
types and not only the syntax but the
semantics of that system are very
interesting and so again members of the
audience contributed to this paper on a
semantic basis for quest which proposed
a partial equivalence relation model for
all of these features together but the
end of the story is interesting so so
all of this the purpose was object
encodings in lambda calculus and and it
led to the flowering of a very active
area I named by Kim the fool community
foundations of object oriented languages
and at a lot of work on on how to kind
of crammed the ideas and concepts of of
objects into a lambda calculus setting
and there were various frustrations
along the way you could you could get it
to almost work but then it wouldn't
perform quite the way that you expected
or would have space leaks or or
something wouldn't be quite right and at
some point Luca together with Martine
decided that all of the stuff about
types that had been figured out was
great and on to some degree canonical
but maybe the lambda calculus part was a
mistake so so the idea that they
proposed and developed in a series of
papers later collected in this book was
let's set aside lambda calculus and and
try to view the fundamental mechanisms
of object-oriented programming as
primitives in their own right and take
that as the basis for a calculus or
indeed a family of calculate that they
called object calculate I carrying over
all of the insights from from all of the
work on types that had been done at that
point over a dozen years or more I've
heard it said that if you want to do a
great job in research you should write
the first paper in an area the best
paper in an area or the last paper in an
area and I think it's rather unusual
that somebody writes both the first
paper and the last paper in an area so
so this is oversimplifying a bit but you
could say that that Luca in his paper in
1984 opened the area of object encodings
and in his book in 1980s in 1996 with
Martine closed the area of object
encodings because there have been a few
papers on it since but but really people
gave up at that point and said oh yes we
should have primitive object calculate
and I have an idea for another one so so
then there came of the flowering of
another whole area which falls off the
bottom right-hand side with systems like
featherweight Java and the new object
calculus that's at the core of Scala and
many other systems
that are used to this day to to
formalize and mathematics ideas in the
object-oriented programming world of
course not only core calculate but a
great number of language designs and and
ideas that went into language designs
also came out of this effort so so this
was really a although in some sense the
cloud collapse to a point before it had
another Big Bang the the ripples of it
are still expanding and still
influencing language designs and theory
to this day so this is an intermission
for a moment and a chance for a short
restful vacation on the logos Island and
now I'm going to switch tracks and jump
to a little bit later point in Lucas
career and my own where he together with
Andy Gordon were working on the ambient
calculus a foundational calculus not
originally typed for for mobile
computation in graph structured things
and what I'd like to tell you about is a
follow-on system that I and a couple of
students have been playing with over the
last few years called the spider
calculus which attempts to tell a
similar story where the world in which
the computational agents live and the
world that they create by their actions
is not a graph is not a tree but instead
of graph so this is the spider calculus
the story begins as many stories do with
the PI calculus the PI calculus if you
think about it as in terms of the
environment in which processes live it's
a rather unstructured system so it's a
you can think of it as a core calculus
for computing in soup where where the
computational elements are
our molecules that drift around in the
soup and perhaps meet and interact but
where the where the soup itself has no
kind of distinguished structure or a
notion of place it's just Brownian
motion I making things interact and and
the innovation of the ambient calculus
was to put some structure on the
environment to say no there are there
are places in the world where things
happen and things don't and actions
don't happen at a distance if you want
to have an effect on something that's
distant you go there and then you have
the effect so in some sense what we're
trying to do here is to fill in the
analogy so what is two graphs as ambient
is the trees and as pie is to soup and
our answer is the spider calculus which
I will show you next okay so beginning
with my calculus so so PI calculus comes
to us from Robin milner Milner's
original presentations of the pie
calculus had pictures like this one
which involved real physical
distribution but when it came to the
formalization of those pictures the the
physicality of the distribution was
replaced by a linguistic notion that
there was just scope so the ability to
communicate was was modeled by sharing
names which which could then be used to
perform actions that would affect other
processes that also knew those names so
here is the syntax of the pie calculus
if you care this is the synchronous
choice free variant of the by calculus
but it doesn't matter too much so the PI
calculus looks like this it has if you
like to syntactic categories these are
the processes and these are the actions
that processes can do and I'm splitting
it out because because the processes are
going to be very much the same for the
other systems that I described while the
actions are going to be quite different
so the processes of the pie calculus
are nil which is a process that doesn't
do anything to processes in parallel
which either leave their actions an
arbitrary number of copies of a process
running in parallel called replication
of P and in some ways the most
interesting name creation so this is
pronounced new n P and you can think of
the semantics of this for those very few
of you that don't know this perfectly
well already you can think of the
semantics of new as create a name and
call it in bind it to the to the
variable n in the local scope p and make
sure that this name is fresh for
everything else in the world so this is
a name that has never been used before
by anybody okay and then finally we have
actions so m dot P is a process that
performs action em until action em can
be performed so until the resources to
do a more available nothing happens when
those resources become available this
process may do the action and when the
action is finished it continues as P so
P is the continuation of the action and
in the pi calculus the actions are send
so send a channel on a channel or
receive from a channel the name of
another channel and of course it's the
the fact that there's an end both here
and here that gives the PI calculus it's
great if somewhat incestuous power
so again the the computational world
looks like soup and it can all be
formalized with linear syntax and
structural congruence and all that kind
of stuff but for this talk pictures will
suffice so you can think of a process as
a whole bunch of little fragments of
process running in parallel doing what
they're doing as fast as they can and
and if there happened to be in the soup
two processes that one that wants to
send and one that wants to receive on
the very same channel then they can
interact and what happens is the
continuation of the sender is released
into the soup as is the continuation of
the receiver but that continuation is in
that continuation the bound variable X
is substituted with the with the
argument with the with the message
contents m ok so I think all of that is
review for most people um and what can
you do with the pie calculus where are
lots and lots of things you can in
particular encode a great variety of
common data structures and programming
idioms numbers arithmetic lists
everything else you want a wide variety
of data structures including many styles
of concurrency but in particular also
including functional programming so the
lambda calculus easily encodes in the
pie calculus okay so so much for pie
calculus what about ambien calculus I
the ambient calculus has a slightly
different notion of computational world
so it was invented as a response to the
invention of the internet and the web
and and the observation was but the
internet is structured so you have you
have computers within local area
networks within wide area networks
within
the whole internet and so on and the
model of this was called an ambient so
an ambient consists of a name so it's a
the box is the same and it's got a soup
inside but it has a name so and inside
of the soup are both processes running
and sub ambience with names and sub
soups containing processes and sub sub
ambience and so on all the way down as
as deep as you want to go the syntax of
these processes is almost the same plus
a few things as what we had before so we
have nil parallel composition
replication name binding actions and one
more which says that in the soup some of
the things can be named locations named
ambience with with processes inside of
them and then the interesting part or
the the other interesting part is the
actions where instead of communicating
on channels we do things with locations
we can go into them go out of them and
open them and let's see those in detail
okay so here's in so if we have an
ambient in with inside of it so I'm
alighting as I did before the other
stuff that's in the soup inside of n I
with but one of the processes running in
n wants to do in m and M some ambient
named M is a sibling of ambient n where
this where this process lives if that's
the case then end goes inside of him and
the continuation p is released ok so
that was in out is the converse so if we
have n with a with a contained process
em p and its context is M so if it's
within if it's a sub ambient of an
ambient named M then it can go out and
again the continuation p is released and
of course if you're seeing this for the
first time you might be thinking to
yourself well we could go out of any
ambient not just one named em so why
bother have why bother saying out my not
just out and and yes there are many
variants and you can spin stories about
each one the thing that's interesting
about this one is this n cannot move out
of the ambient that it's in unless it
knows its name and if its name is
private maybe not knowable buy it then
it can't get out at all so so this gives
some control that one wouldn't have if
if that M were not there okay and then
finally open the in some sense craziest
rule says if there's a sibling of the
open process named M we just dissolve
its boundary and and allow its contents
to float up into the containing soup
okay so this was ambient calculus and
again there are many examples of things
that can be encoded in the ambien
calculus including as before a bunch of
common concurrency primitives more
interestingly or more specifically a
bunch of structures found in networks
like firewalls and the ability to
migrate things in a controlled way from
one place to the other data structures
yes of course Turing machines yes lambda
calculus and PI calculus well maybe so
so there there's an interesting little
technical story that we don't have time
for but but the state of knowledge the
state of agreed knowledge seems to be
that that you have to add a few more
primitives to to make these encoding
swear
work but as I was thinking about it in
the last couple of days I realized that
I didn't really believe it and I think
at least my calculus and therefore
lambda calculus can be encoded without
using anything but the primitives that
we've seen so stay tuned but there's one
thing that I want to point out about the
ambien calculus which is so if if this
was the motivating picture and this is
the internet take a look at for example
this part here this network is not tree
structured and Luca drew this picture
his very self so so the the tree
structure that that was I embodied in
the ambient calculus was in some sense
already a an abstraction of its own
motivating picture and this really
raises a question of well what if we did
want to take things like that seriously
what if we wanted to acknowledge that
the internet and lots of other
interesting computing places our graph
structured what would we have to do and
could we have an ambient like system
that would adequately address that
setting so this is an attempt to answer
that question very preliminary and and
unfinished but I offer it for your
amusement and how much time is left my
team thank you ok so the spider calculus
as I said is a calculus of computing in
graphs so what kind of graphs there are
lots of kinds of graphs for today let's
talk about edge labeled directed graphs
so so the processes are going to live at
the nodes their local environment is
going to be the edges going out from the
node that they live at and those edges
need not have distinct names they're
going to be many edges from the same
node with the same name those edges can
loop back to the same node etc and and
as in ambient calculus the the game is
going to be
to design primitives that operate only
by local manipulation of the graph
structure before i start i should say
what r by benchmarks what is going to
count as success for this system so so
first of all any calculus for computing
with graphs should be able to build
graphs in particular should be able to
build any arbitrary structure for any
arbitrary directed graph should be
compila belen to a spider that builds it
so that will be my first benchmark and
then after that i'll want of course some
of the same kind of power that we saw in
ambient calculus my calculus etc so i
want numbers arithmetic and so on l want
encoding zuv lambda and pi calculus i
would love to have an encoding of
ambient calculus but that is at this
point an open question so I leave that
for you to think about if you like for
the moment here is the syntax of the
spider calculus the level of processes
is exactly the same as the PI calculus
and the same as ambien calculus except
that we don't need the the named
ambience because we're not putting we're
not putting structure within nodes we're
putting structure around nodes by the
edges that are incident on them and the
set of primitives is like this so it's a
little bit bigger than ambient and pi
we've gone from two to three to six but
still pretty small it fits on a slide in
a big font and and let me show you the
semantics of each of these primitives by
means of pictures so beginning with
create so here is a node and running at
that node is a process that wants to do
a create em action maybe there are some
other processes running at this node
that's okay but this is the one that
we're focusing on and this node has some
links to other nodes which I'm not
worried about at the moment they're
going to be invariant under this
reduction so when we do create em what
happens is we
create a new node it doesn't need a name
because all we need to know locally is
that we can get to it by an edge named m
ok so for P the new node is named em
because m is its access to the node so
this is very similar to in the pi
calculus where we don't name processes
we name the channels that we use to
communicate with those processes and we
don't really care what what they might
or might not be named we just care how
we get to them okay so that's create
here's copy you could probably guess
what it does but here it is in pictures
so copy em as n takes an edge labeled m
and makes another version of it and
labels it in m and n are both
pre-existing names although of course we
have the name binding inherited from my
calculus so we're free to make up names
as much as we want to use for things
like create and copy here's reverse
again you can probably guess it takes an
edge named m and swaps its direction
releasing the continuation p back into
the soup as it does ok that's quite a
few primitives already that was enough
for the ambien calculus so we should
stop and program a little bit so here's
another one that we might like to have
we might like to be able to create a
node and a way to get back from it so so
create both is going to create both M is
going to build a new node with links in
both directions both label them and of
course we don't need to have that as a
primitive because it's easy to encode we
just create em that creates the first
link and the new node then copy em as m
and then reverse em so take one of them
non deterministically and reverse its
direction and that gives us this
no ah hang on George as usual is one
step ahead let's look at one more
primitive rename so so rename says I
have a H nem what if I want it to be
called something different let's rename
it in okay so using that we can
re-examine the finger exercise and and
take note of George's complaint so
here's the problem what if there's
already an edge named M going out from
this node well we might get what we want
because we create NM a new node with a
link named m and then we and then we
copy it and then we reverse it so we
might get what we want or we might get
what we don't want which is we create
the new node call them we copy the edge
and then we reverse this one which is
also called in you might have copied the
wrong one as well indeed yeah this this
encoding has multiple problems so is not
do that let's instead do this let's use
rename so this is a kind of common idiom
so we create a fresh name z we then
create a new node with a link to it
called zid ok now this is useful because
nobody else knows that name so there's
no possibility of confusion now we copy
that reverse one copy now use the link
that's remaining still called said to go
there and rename the other one to rename
the the reversed 12 m now we go back
across em to the original load and
rename said to him
okay I'm not certain this is the
simplest encoding but I think it works
what you go and then the name uh yeah
maybe so maybe so okay so let's do
another little exercise this one is
easier suppose we wanted to delete
primitive that that just removes the
name em I'm sorry I should have deleted
it there that's a bug on the slide do we
need to add that as a primitive well no
of course we don't all we have to do is
create a fresh name rename em sorry 22
that name and then forget about that
name okay so it's still there in some
sense but it doesn't matter it will
never have any effect on anything okay
another reduction two more to go this
one is simple so go is the primitive
that moves a process that that creates
that spins up some activity at for
example a newly created node oh I use it
on the previous slide didn't i sorry
about that anyway here it is and so the
continuation gets released in the new
soup and using that we can show one more
example which is how do we build an
encoding of the number three so here's
here's how you create three rats not
like that okay that was surprising but
here we go okay so you so you create an
edge name successor go there create
another one go there create another one
and then finally create an edge name 0
okay so so this is a process that
creates a simple bit of graph structure
and now the question in a moment is
going to be can we can we go further can
we
create arbitrary graph structure and
then can we do arithmetic so to do that
we're going to need one more primitive
it's called throw and this is the one
that does that supports more interesting
manipulation of graph structure so if
you think about it with only the
primitives we have so far you could
never build a loop larger than 1 because
all we have is create copy and then
reverse so you can get an edge back but
you can never make a larger loop if you
want larger loops you can get them by
throw so what throw does is it pushes
the our end of of some edge along
another edge okay so let's look at our
benchmarks so can we create arbitrary
graph structure so we start with a
process at one node and now suppose that
we want to well let's just look at how
to create a pretty interesting graph so
the first thing we do is we do a bunch
of create boats to create a spanning
tree that for that for a that forms a
skeleton for the graph that we want to
create then if the graph that we're
creating is not tree structured we walk
down sorry we create some links at the
root and I sorry we create some links
pointing to the the place that we want
them to go so for example this is Z link
we would create it here pointing there
and then throw its back end down to
there so you so you create links and
then sort of throw them around the graph
to get them to get the back end where
you want them you you walk down to here
sorry you walk down to here create the
link and then throw it back to they're
bound to there down to there so you have
to go to a place where you can access
the the thing that you want it to point
to
okay now we can rename some of the edges
to whatever we like for example we could
have two x's going out of this node and
without creating confusion and then the
final step is to to use a new binder to
remove the temporary edges that we don't
need anymore okay so this is an
illustration of how to build a some
slightly complicated particular graph
and there's the most of the whole thing
that does it okay what about arithmetic
so moving quickly now can we implement
predecessor can we implement a process
that does this so so given a number
representation like we saw before it
will create another another link so the
original process is linked via an edge
named X to a number we would like an
edge named y pointing to the predecessor
of that number and this is the process
that does it so we let's not bother
going into the details but but we do
some copying reversing and then we in
parallel do something involving
successor and something else involving 0
notice that the thing involving 0 is
actually a no-op so we rename 0 to 0 but
it's a no op that can only proceed if
there is an edge name 0 okay so so this
parallel composition actually amounts to
a choice because only one side can go
okay and now there's really no time for
telling you details of this but just to
to give you a visual sense to encode the
PI calculus we put all of the processes
in one node with links to other nodes
one for each Channel now when you want
to communicate on a channel you go to
the node where the channel q is and wait
until you meet up with a communication
partner that that has also arrived there
and then move back to the main node to
continue processing and then for the
lambda calculus it's even a bit trickier
but here we encode each lambda
expression as a node that when executed
creates a new node representing the
running body with with links to other
nodes representing the free variables
and details of this you can find written
down someplace okay so a number of
questions come to mind I already
mentioned this one can spiders encode
ambience I don't know another one that
we've thought about quite a bit is are
there other interesting sets of
primitives could you for example have
something like analogous to open we
called it merge that squashes two nodes
together and you can and it I changes
the system a little bit or could you sub
set and and what expressive power would
you have left of course in order to show
that we've really done something we
would want a theory of contextual
equivalence that would justify some of
the encoding that I've tried to hand
wave for you and we have some very
preliminary steps toward that but it
needs more work and then finally our
spider is useful for anything and and
I've left this question for last because
in some sense for present purposes I
don't care the the point of the exercise
was was curiosity and fun and a sense of
play and and just trying to answer the
question of
ambience are cool for trees what would
be similarly cool for graphs so I leave
you with that offering and with that
question maybe they're useful for
something I don't know and close with
again a happy birthday Thank You Luca</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>