<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Approximating the Nash Social Welfare with Indivisible Items | Coder Coacher - Coaching Coders</title><meta content="Approximating the Nash Social Welfare with Indivisible Items - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Approximating the Nash Social Welfare with Indivisible Items</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tGsL48Zi5_w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
so welcome everyone it's my pleasure to
introduce vassilis god Silas
this is a postdoc in Berkeley currently
and he will be a faculty at Drexel soon
and Wesley has done some really
interesting work in either in game
theory and in particular how to allocate
goods to agents in a fair manner so he
will talk about approximating Nash
social welfare which is one measure of
fairness so oh thank you everyone so I'm
going to talk about how to approximate
the Nash Social Welfare with indivisible
items so the goal here will be that we
have a set of indivisible items that we
want to allocate to a set of
participants and as Nick you mentioned
the national show welfare is a measure
of fairness we're going to try and
maximize fairness in some notion of
efficiency at the same time and this is
joint work with Richard Cole NYU so let
me dive right into the specifics of the
model so we want to distribute a
collection of items among a set of
agents and each agent we assume has
added the evaluation so let me define
this right away so we have a in this
case let's say we have these five items
and we have an agent I so the fact that
agent has added evaluations means that
we can represent his preferences using a
vector of just five numbers one for each
item let's say these are the numbers 15
2 4 5 and 3 in this case this means that
if we allocate the first item to the
agent his value for it would be 15 if on
the other hand we allocated item 2 to
the player his body would be to the the
part where additive makes more sense is
when you have more than one items when
the player is allocated two items two
and three let's say then his value is
the sum of these two which is where
additive comes from and you can imagine
if he gets one two three and four he's
value
eleven two three four and five his value
would be 14 you just sum up the
corresponding numbers and the important
thing that these numbers tell us is that
for example in this case if you had to
choose between giving this player this
one item or the bundle of items two
three four and five this says the player
actually prefers the first item right so
it tells us in a concise way what the
Preferences of the player player and
we're going to assume that this is the
case throughout the talk that the
valuations are additive so this is of
course more interesting when you have
more than one agents that are competing
for these items and you're trying to
find a way to distribute essentially
you're distributing value across the
players and we're going to be denoting
the set of agents by N and the set of
items by M and the items are indivisible
this means you cannot cut an item in
half or in a smaller pieces and give it
to more than one players and also that
for each agent we're going to be using a
variable X IJ which is either 0 1
because of the indivisibility which is
an indicator variable regarding whether
agent I will actually get item J or not
ok so formally this could be a matching
a sorry an assignment of the items since
I mentioned it so we're not going to be
talking about matching the items to
agents an agent can get more than one
items and for each agent I the valuation
of the player is going to be denoted
like this ok so it's just the sum over
all items of X IJ times V AJ whether the
player got the item times his value for
that item make sense I'm going really
slow but just to make sure this is the
fundamental setting so the question here
is overall this is this is your design
so you can choose over all these
possible ways of allocating the items
the agents the question is which one do
you want and we're going to be shooting
for fairness making sure that the
allocation of the items is fair and in
some case in some sense also efficient
and when people talk about efficiency in
the setting this first thing that comes
to mind is what is called the
utilitarian social welfare
that is I'm going to try to allocate the
items in a way that maximizes the sum of
the values of the players so the
aggregate happiness the aggregate value
the sum of the values which if you look
at this setting can you imagine what
that would be there are more than one
ways to do this maximize social welfare
here but this is one of them right so
this maximizes social world you can see
that the sum of the values would be
maximized in this way so clearly this is
extremely unfair right so one player
gets nothing the other player gets
everything so just maximizing this
utilitarian social welfare alone can be
really unfair as an outcome so our goal
will be to introduce fairness into this
and the standard way that people have
been approaching fairness is what is
called the egalitarian social welfare
and that is our goal in this case would
be to maximize overall allocations the
minimum value across all players so in
other words try to make the least happy
person as happy as possible and you
might have seen this this is a well
studied problem exactly the same thing
I've just just described the additive
valuations and this objective and it's
called the Santa Clause problem is one
way in which you might have heard of it
before and there's a long line of
results but in this general setting it
there's a still a big gap in terms of
the approximability of this problem but
even this objective can you figure out
what that would do in this allocation
that same instance as before if you try
to maximize the minimum exactly so it's
extreme in the other sense it gives all
the items to the hard to satisfy agent
and the other agent gets just one item
so in some sense this is an extreme
notion of fairness as trying to satisfy
maybe a person who's really hard to
satisfy and sacrificing efficiency our
goal here will be to find the balance
between the two and what we're going to
be trying maximize is a Nash social
welfare objective which is the geometric
mean of the values okay and before I
explain why this is a well motivated
objective let's see what it would do in
that same instance
let's start from the max-min allocation
that we had before so you can verify
easily that this is actually not
maximized in the geometric mean in the
following way if we get a seven-night
item 7 and we take it from agent 1 and
give it to agent to agent 2 doubles is
value whereas agent 1 doesn't have it's
it's still not losing as much so that
would be actually an improving change so
with this one so with this one and in
fact this is the product maximizing or
geometric mean maximizing allocation so
intuitively in this in these systems you
can see how it balances it tries to
distribute value in in a balanced way
but let me make it a bit more concrete
so this objective the Nash social
welfare objective satisfies some highly
desired properties one of them which I
think is really important especially in
this setting where there's there's no
payments it's just an allocation it
satisfies scale freeness that means that
the outcome does not depend on what
scale the Vij values are reported in
right so if i take for every player i
some parameter some positive value alpha
and multiply all the VA j's by the same
value this will not change the outcome
in any way right and this is very
important because usually when there's
monetary payments you can express the
values in the sense that this is the
value means how much would you be
willing to pay for this item but once
there's no values this means nothing
really that the scale might not
necessarily be have any specific meaning
so if I multiply all my values by a big
constant and that changes is out the
outcome this is a bit tricky this
there's no real reason why that should
happen and it's easy to verify also that
if you think about the previous two
objectives the utilitarian and the
egalitarian social welfare they both
heavily depend on the scale in what in
once in the utilitarian you would want
to scale up words in the egalitarian you
would want to scale down words whereas
in the product it doesn't matter and
this is a really information the real
information you're trying to get from
the participants is the relative
preferences across items then the scale
doesn't matter
so this is the objective that satisfies
this and that avoids this interpersonal
comparability of individuals preferences
this means numbers the scale of one
shouldn't be comparable to the other in
a particular way and the second good
thing is that it strikes a balance
between fairness and efficiency and you
can see it one way to see it is this
that this is the generalized mean and if
you take P going to minus infinity you
get max min if you take P equals 1 you
get the average the utilitarian social
welfare and for P equals 0 you actually
get the geometric mean so in some sense
it lies between these two extremes it
still tries to balance value but it's
not going to do it in an in a really
unbounded inefficient way and another
reason why it's this is interesting is
that the same objective has been
discovered by many different communities
it is the objective optimized by the
national solution it is the proportional
fairness objective in networking it's
also the competitive equilibrium for
equal incomes objective or the Fischer
market objective so in many different
communities economics networking and
others it this arises naturally and as
I'm going to be mentioning later
maximizing the product is equivalent to
maximizing the sum of the logs maybe
this sounds more intuitive you've seen
it somewhere ok so hopefully I've
convinced you that this is a an
interesting objective to understand and
optimize so let me formally define our
problem so let X star be the integral
allocation maximizing the Nash social
welfare our goal is going to be to
design an algorithm computing an
integral location X that satisfies this
the geometric mean of the optimal is
that more some raw factor of what we get
why what makes more sense the tumeric
mean are say the sum of dogs so you're
saying I mean if you get the geometric
mean approximation a multiplicative one
like this you're an additive also at the
same time for some look so it's a
stronger
the exams you get talk about leak but
approximation to some of lawns so I'm
not sure that there would be I mean in
yeah I think in some sense the log
transformation is a bit less intuitive
what happens and what what you should be
exerting this and in here essentially
you know that for example if you get
every player half the value that should
be getting they you get a half of
summation essentially I think that low
kind of messes things up but I'm not
sure what that the right thing would be
no I don't know why it would be wrong to
aim for log but this in some sense is
stronger yeah yeah but you don't want
that either way here it would be zero
okay but yeah that's at some point we
started thinking about the sum of the
logs because it's you know it's a
modular function so you we're thinking
like oh maybe I could do like a greedy
like allocation rule but it's it's messy
didn't seem like all the greedy type
approaches that we tried didn't seem to
make sense and that would only give a
multiplicative in it but maybe maybe
it's yeah so the best known algorithm
before work was a growing linearly with
a number of items when and wrote them
well yes and wrote them and Gwen that's
how it's very rotten and after our same
problem yes and the problem was very
same is shown to be a big heart after
after our talk at that song I'm I'm not
sure he's a student at CMU I'm not
trying
the name it's an archive the paper okay
so our main result is that we propose an
algorithm that achieves a small constant
approximation factor two point eight
eight nine which at least to us was a
bit surprising the direction you can do
that and yeah the talk is going to be
around how we achieve that approximation
how the problems that we had to face so
formally you can write this the problem
that we won't solve is exactly this one
right we want to maximize the geometric
mean subject to the valuations which are
additive and we don't want to over
allocate any item and the X edges are
between 0 and 1 and the first
observation is if you take a log of the
objective as I mentioned before you get
the problem of maximizing the sum of the
logs of the utilities which is convex so
it's getting better because the previous
one was 4 in this and if you relax the
integrality then what you actually get
is the Eisenberg ale program which has
been well studied and we can solve this
so the first reaction is great let's
solve this program and then try to round
it and get a good approximation
algorithm unfortunately this fails
miserably because the integral tea gap
of the of this program is unbounded and
let me give you an example it doesn't
it's an it's an easy example to consider
but just to get a sense of why this this
happens this is just an observation that
if you have these items M items and n
agents but every agent has a very very
strong preference let's imagine this V
being arbitrarily high a really really
strong preference for the first item
they need a fractional solution the
players can share the top item and that
that too but I just want to this is kind
of the reason I avoid this instance is
because it's kind of the product would
be 0 anyway so sure yeah the integral
the gap in that instance is kind of easy
to solve but you can imagine even if
these other items have some small value
it might be harder to figure out whether
you can actually achieve but yes even
just having one item would also give you
the
so yeah they can share it and get a
high-value share essentially the
high-value but in reality only one of
them so it's clear that there's no way
that I can actually get this to work so
what this shows is that there's no way
to prove using this as an upper bound
the fractional objective value as an
upper bound to prove a good
approximation zero like zero some non
zero yes and I want to check whether the
answer is zero or not do it right yes we
achieve a constant not good
no we're not going to use that program I
just want to say there is a matching of
course and to so much it but now we have
zero zero right yeah so can you go back
to the pre program actually this one
screen so you guys are just an even
dummy variables you can remove them
right yes yes it's just for convenience
so okay so what our solution is going to
revolve around and the intuition will
come from is the fact that in fact this
this program we're just looking at has a
very natural interpretation as a market
equilibrium and you don't need to know
exactly what I mean by that I'm going to
explain how this works you can imagine
if you take this instance that each
agent is allocated a budget of 1 $1 of
money that have no value beyond this
particular setting the goal is to spend
all this all of this money and there are
prices for each item there's a price PJ
I'm not going to at this point tell you
yet how we come up with these prices
these are the duals of the program but
let's say we have them so once I I give
these prices and you can imagine the
agents arriving one after the other
think of agent 1 arriving what are the
preferences he has a value of 15 for the
first item zero for everything
clearly he wants to spend his money in
the best way possible which is spending
it all on the on the first item right so
he can spend his $1 on this item and he
buys a third of that item then the
second player arrives and you can verify
that the value per price ratio is the
same for these two items for the players
so he's indifferent between these two
however he spends his money between the
two is is fine I'm going to
intentionally tiebreak upwards in this
case and have him spend his money
optimally again the way he would to get
the best you could get using that those
prices and by the second third of that
item and we continue the same way if the
third player arrives you can verify the
maximum bunk per buck items that ones
that have the best value per price ratio
are the are one three four and five
so again I will tie break upwards and
let him buy the remaining third of that
item conveniently when the last player
arrives he likes all these items equally
and the some of these prices are one so
you can buy them all and that's perfect
so that's market clearing so the very
nice thing about this is that what we
require is that every player's is
spending his money on his to buy his
best bundle given the prices all the
items are fully allocated and all the
players are spending all of their money
once you have these properties you know
just by showing you this you know that
this allocation maximizes the product
okay so the the issue and let me make
another point now so before I made the
point that the integrality gap of this
program is high now I'm going to less
formally try to convince you that apart
from so in that sense the the program
fails to give us a good upper bound
because it gives you high integral gap
but I'm going to argue here that somehow
it also doesn't give you a right a good
fractional solution to run from so if
you look at this one you know that since
the top player has no other alternative
he really only likes the first item he
will essentially get it if you want to
maximize the product he should be
getting that item but there's also
player 2 and player 3 that in this
fractional solution all you know about
them is that they're getting
a third of that item as well but if you
look at their preferences they're very
different with their absolutely
different with respect to their
preferences other than that first item
so knowing that they will not be getting
that first item you have no information
about how to distinguish how to run one
and how to run the other right so these
two are very different but in terms of
your fractional allocation they're the
same right so you can imagine if I make
this even more expensive that there will
be more and more information lost inside
this fractional location okay and based
on this intuition what we do so we start
from the Eisenberg ale program we moved
it to the market equilibrium
interpretation what we're going to do
now is to tweak the market equilibrium
interpretation to get a different
equilibrium that reveals more
information and helps us get a good
upper bound right we're not going to use
this we're going to use a different one
in order to do that the main trick that
we use is we apply a constraint on the
on how much spending can go into any
item and this is the spending restricted
outcome that we aim for this family
restore equilibrium allows at most one
dollar to be spent on any item right so
one players worth of budget is the most
that can be spent on any item in this
new equilibrium that I'm defining so in
this case this fractional solution that
we saw before violates this there are
three players spending one dollar so
there's a total of three dollars going
into this item so this is not allowed in
this new constraint that we introduced
so in order to get an equilibrium that
satisfies this additional constraint we
have to keep you can imagine that if I
disallowed player 2 or player 3 if they
arrived in the same order I this allowed
them to spend their money on one then
they wouldn't be able to spend the
prices all the other prices are too
little there there will be too much
demand for the other items so in order
to find this we actually keep increasing
the prices and we can discuss how we
figure out these new prices later on but
we come up with these new prices and you
can verify that these prices satisfied
the additional constraint plus most of
the ones we had before in particular
it's this is a new market equilibrium in
the following sense player 1 arrives
still his perfect preferred item is the
first one
right so he spends his money there that
means nobody else can spend on that item
anymore because there's one dollar of
spending going into it in this picture
so whatever no yes so the prices are can
be higher so in this case this is not
fully allocated right so there's a price
yes it's through a fractional occasion
so you're buying one tenth in this space
but the player still prefers one tenth
of item one than anything else but
nobody else no yes so I'm not yes yes so
this the rest of it will be unallocated
in the fractional solution but we only
use it as a guide we're not going to so
then the second player arrives he's
equally again interested in the first
and the second item so the restriction
that nobody spends more than one dollar
on either one it's not actually
restricting the optimization problem for
the buyers
yes I'm still clear exactly - the
players are still buying they're opening
a bundle and we have to allow them to be
able to do that while satisfying the
constraint exactly and you can verify
and this is what I'm verifying out that
in fact here I can combine their
preferences with the additional
constraint so player 2 arrives he is
indifferent between these two items and
now I will let him buy this one which
means nobody else can spend on item 2
either now thirdly arrives is
indifferent between those these items
I'm going to choose let's say this way
of him spending his money which means he
pays 2/3 gets all of this and 1/3 gets
half of this and the last player arrives
is interested in all these items and
there's a way again to spend his money
ok so to be more precise the constraint
that I want is if the price of the item
is higher than 1 the spending has to be
1 exactly if the price of the item is
less than 1 then I want it to be fully
allocated so the spending on it is
exactly the the price and what I
verified with this example again in this
new outcome is that every player again
buys his favorite bundle of items
all of his money but instead of the
items being fully allocated I have this
new constraint now that the spending
cannot be more than 1 which means maybe
some of them are not fully allocated ok
so this will be at the center of our
result we use this fraction of solution
this spending restricted outcome in
order to come up with an upper bound and
a rounding algorithm and the intuition
one thing that I want to mention
compared excuse me I'm not sure that is
right so up until like the answer to why
the exists is that we have an algorithm
for for computing it but I just a few
are a few hours ago I realized there is
also a complex program for computing
this solution and these this restriction
that I $1 but yeah it's a different
convex programs but yeah we didn't know
that so I'm going to come back to that
later
ok how to reach these prices but what I
wanted to notice here is that remember
these players I mentioned we had no
information about why the previous
fractional solution was not a good guide
for the rounding algorithm you can see
here that by applying this spending
constraint I forced these players to
spend on less demanded items I pushed
the demand to lower items and now you
see that player 2 and player 3 have
revealed much more about their
preferences than before now I can tell
them apart I can tell that player 2 once
item 2 player 3 once item 3 or 4 so as
we're going to show this helps us round
and get a good approximation okay so the
main contributions that we get are the
following first that the spending
restricted outcome what I just described
is computable in polynomial time in
order to do this we actually used some
algorithms that were known at
combinatorial algorithms that were known
for computing the solution of the
Heisenberg ayo program by Devin or at
all but apparently there are different
ways of doing it and now and the second
one is that the spending restricted
outcome implies a better upper bound for
the optimal solution and finally that
the spending or stricter outcome reveals
useful information for rounding which is
kind of more of an intuitive point that
I just made before that it implies a
bound word which has low which is which
approximates opt in a better way yeah I
mean we can actually prove we and we
have an upper bound that we can prove a
good approximation with whereas the
previous one there was no hope yes I'm
going to describe it yeah yeah but since
since we can prove it a constant factor
it's a good bound yeah so okay so first
of all when it comes to computing the
spending restricted outcome the issue is
that the spending constraint that I
applied I said there's the amount of
spending that can go into any item is at
most one the spending is neither the
primal nor the dual variable it's a
combination of the two so in fact where
we used to have the sum of the X I J's
being equal to one everything is fully
allocated we're now replacing it with
this the sum of the X I J's x pj is a is
the minimum of one n pj right so x IJ is
a primal pj is a dual so the thing is
that this constraint that we introduced
we didn't know how to write it as one
converse program anymore it was not
clear that we can just introduce this
constraint in here anymore so in order
to achieve this we use those communitary
algorithms that I mentioned before where
this constraint just fits in perfectly
and in fact we get a strongly polynomial
algorithm out of it which is still of
some value yes so for every item J you
know that the X IJ so this is the amount
of spending the sum over all agents X IJ
is how much the agent gets of that item
PJ is how much the price is so X IJ
times PJ is how much the agent spent on
that item so if you sum over all agents
it's the total spending on that item and
you want this to be at most to be the
minimum of one in the price
okay
so that's the first thing I'm going to
come back to this later on if you want
to discuss this but I guess the more
interesting thing just restating what
what we compute what I'm saying then the
outcome that we're trying to find can be
described in this way it's like the
constraint we introducing doesn't fit
with a known program that we're using
the Eisenberg gear program is all I'm
saying
so it's not clear how to compute it this
is the upper bound the upper bound will
not be using the objective of any
program ok yes so in order to get the
upper bound will be getting it in an
indirect way using this solution and
this is the next slide so if you look at
this instance the first yes so the first
thing I'm going to do some this is proof
by the upper bound is proof by picture a
bit but if you want I can just take it
so and figure everything out if you're
interested but the the question here is
we have this right so I mentioned that
the valuations the scale of the values
doesn't matter right so I can scale
upwards or downwards however I want so
for convenience in order to express our
upper bound I will scale everything so
that every every player's value for his
the item he's being allocated is equal
to the price right essentially I'm
multiplying by the inverse of this mbb
the maximum bang per buck ratio your
value divided by your price I'm
multiplying by this and we get this so
the essentially you get 10 which is as
much as you spend so you know that after
doing this you're either your value for
an item is either the price or less than
that it's the price if it's one of your
favorite items it's less than that if
it's not one of your favorite items so
right now after this multiplication the
scaling of the values I know that
everybody's value for an item is at most
the price of the item okay and I haven't
changed in itself well define them and
then the second thing we're doing is
we're saying here are the highly priced
items every
that has a price higher than one and the
low-priced items the ones I have priced
less than one roughly speaking just to
give you a sense of what we're doing to
get the upper bound we're going to argue
to show we're going to prove an upper
bound for the case that H is integral L
is fractional right we're going to
assume these items are divisible but H
the items in H the important ones are
indivisible and we're going to prove an
upper bound for that case okay so
partially relaxing the allocation space
and using this we're showing and this is
a tricky part this is why as I steal the
values so that we can express the upper
Bann as a function of the prices so what
we're showing is that the spending
restricted prices P bar the ones I just
computed in the spending restricted
outcome and the scaled valuations VI the
ones I just described having scaled in a
way the product of the values in the
optimal solution is at most the product
of the prices in H so in this case is at
most ten times four-thirds and I'm going
to explain why this is the case roughly
speaking the reason why this is the case
is the best thing you can do is allocate
the important items each one to a
distinct agent and then the best you can
hope to do for the for the other items
is give a value of one for everyone else
everyone who doesn't get an item from H
the best you can hope to do is give them
a value of one in which case you get
this product for the player from the
players that get an item in H and ones
from everyone else because everybody the
best you could ever do is give everyone
one because if you can think that that's
the easy case because then the sum of
the prices is n right actually this is
actually a good point this probably
helps if H is empty then the sum of the
prices is n the total spending right and
it's also the Sun the social welfare the
total value could ever get the maximum
value could get is that right and
yes so we so we steal the prices so that
your value essentially by the inverse of
your mbb ratio the maximum bunker by
creator so you make sure that the value
of everyone is equal to the price of the
item he's allocate yes yes so you have
so VI J prime is equal to right so V IJ
divided by the this ratio the max max of
over all J of V J V sorry J prime V IJ
prime over P J prime
all multiplied by the inverse right so
that means that all the items that
satisfy this that belong to that
actually maximize my ratio I'm going to
have a value for them equal to the price
for everything else I'm going to have a
value less than the price okay the only
reason we're doing it I mean it sounds
like but the only reason I'm doing it is
to be able to express the upper bound as
a function of the prices because we
don't know who'll get what what we know
is that's the best you could ever hope
for and then what I'm saying is that
okay so for the case that you mention if
the H is empty the sum of the prices is
n right it's the total spending how much
money everybody's spending so everyone
the best you could ever do is gave
everyone a value of one yes so just make
it even simpler to prove that this is
true I will go back to the values and
I'm going to increase all of them so
that everyone's value for every item is
equal to the price right so I'm if
anything I'm increasing the left hand
side they're making it harder for me to
prove it right so I'm increasing
everyone's price so that they're
identical
everyone's value sorry so that they're
identical they all value every item
equally so that's a harder thing to
prove the thing is and maybe that's
that's easier to grasp one that every
player is the same maximizing the
product is the same as maximizing the
minimum okay so we in this instance I
have now constructed you just want to
maximize the minimum and back to the
instance I was saying if if H is empty
the best you could get the best minimum
you could get is one that's why this is
easy if H is non-empty the best you can
get for these guys is one and for the
the guys who get the top items it's you
know the value they get from that top
item is that clear so essentially it's a
mixing we're saying all the items in H
we're going the best thing you could
ever do because they already get a value
higher than one right vo because we
might what's a product of the values the
value of the agents that get something
in H so if an agent gets something from
H his value is equal to the price and
everyone so essentially it's the values
are the prices in H times one one one
one for everyone who doesn't get an item
but that would make it worse why because
these guys are already well off the guys
who get an any any agent who gets an
item in H already has a value higher
than one so since you're trying to do
max min you shouldn't give him anything
else
so exactly this is a perfect question
because the best thing you could do so I
just argue that here we want to do max
min right so anyone who gets an item in
H gets a value one and gets a value
higher than one so he's fine these guys
are fine and they're so they're n minus
H people who do not get that and the sum
of the prices last thing to observe is
that the sum of the prices in L are also
n minus H do you see that because the
spending on the items in H is one fringe
item so the spending here which is equal
to the sum the prices is exactly n minus
H so what I just argued is everyone who
doesn't get an item in H there are more
at least n minus H such people and they
need to share this total value so the
best you could have ever hope for is
give them one each the maximize in
geometric mean yeah if they're identical
I mean it's it's just it's true
we see I don't know that I have a good
argument for it but wait what why
maximizing kind Maxima in the parkas
yeah because there's some asphyxia so
you have a set of values the sum the
social welfare is fixed right so you're
maximizing the sum the product of values
do you maximize in a minimum of values
that sum up to the same thing so the
best thing you could do is make them
you're maximizing the product of values
of a fixed sum so the best you could do
is balance them so they're equal that's
that's that's the argument so if you
have a fixed sum essentially you're
redistributing the same social welfares
I've bonded the social welfare I'm
saying social welfare is the sum of you
know the values of these prices and then
the question is how do I distribute it
to make the product maximize so the
product is maximized when they're all
equal yeah so this comes from exactly
this argument that the players who do
not get an item in H are at least n
minus H the sum of the prices here are
exactly n minus H so the best you could
hope for for these people is that they
get a value of 1 even if these items
were divisible right that's the best you
could ever hope for and that's where we
use integrality that the top items we
cannot divide so one player gets each so
that's where you get the product for the
items in each of them and that's the
upper bound so it's not to answer your
previous question it doesn't come from
the program directly it's kind of a
partial relaxation of using the solution
we get the solution actually we use it
in two ways first we use it to get the
upper bound and we use it for the
solution right for the fractional
solution or the rounding isolating
prices and you put it in the new convex
programming so we didn't you solve it
using a convex program we introduced
this constraint and define a new notion
of equilibrium which we explained how to
compute in a totally different way using
a combinatorial algorithm I haven't
discussed this but once we compute this
we use the prices as a signal of how to
define an upper bound
and then we also use the both the prices
in the allocation for the rounding
algorithm which is the next slide okay
so this is the upper bound this product
of the prices so roughly speaking if I
could design an algorithm that of course
matches these expensive items to
different people each two distinct
people and then the other things rounds
in a smooth way so the values well
distributed then maybe I could hope to
get a good approximation and this is
more or less what the algorithm does so
one thing I didn't mention is that you
can always make sure that this spending
graph this these edges they never
there's never a cycle in this in this
graph that's easy by just redistributing
it's essentially you can redistribute
the spending and make sure you're only
spending on the there's no cycle in this
thing it's not very important but I'm
going to be using the fact that there's
a that it this is going to be a forest
the solution is going to be a forest and
the way we do it is the way it we round
is we take every tree in this forest
choose an arbitrary agent and set it to
be the route and let's say this is agent
a and in this solution in this
fractional solution he's spending money
on some getting fractions of some of the
resources of the items and these
resources are also being competed for by
other agents and so on so you have this
alternating sequence and you get a tree
like this one and we're only going to be
rounding using these edges a player is
only two an agent is only likely to get
an item if there's if he's spending
something on that item in the fractional
solution in this fractional solution so
of course the first step of our rounding
of the spending restricted rounding
algorithm is to compute the spending
restricted outcome which we can discuss
later but once you have this you have
these graphs and the what is the first
easiest step of the rounding I just told
you that I'm only going to round using
these edges the Leafs write the item
leaves there's no other option so the
first thing is allocate the leaf items
upwards to their to the agents that that
are the only ones spending on them
that's easy we do that the second step
is to allocate the low-priced items and
here we've chosen buy low price because
that's that was a convenient number for
our rounding the ones I have priced less
than half so any item that has let price
less than half we're also going to
rounded up words to the parent agent and
that's where we use a tree we try to
make it consistent rounding always
upwards and in this case you look at all
the prices there's only one this year
that has price less than 1/2 we take it
and round it upwards right and then
after we're done with this step
everything that remains essentially we
kind of got rid of the less important
agent resource I didn't want to use I
because I use it as an index for the but
yeah the agents and Resources agents
right now yes but I did it before right
oh so it's the resources are allocated
then leaf the leaf items not the leaf
agents and then I allocate also the
low-priced items yes because you don't
care essentially it's a tiebreaking
issue right you have a set of mbb items
if you say you can just redistribute and
it's fine yeah
so so now I've gotten read those the
less important things and then and then
what's remaining is everything has a
price less at least half so everyone who
gets an item of the remaining ones
actually gets half you know gets a half
value right so that would be fine so if
I could if I could do a half value for
everyone that would be great
what we show is actually we cannot match
everyone but we can match most of the
people that are left and in order to do
this what is interesting is in this last
step I'm going to do a matching I'm
matching the remaining agents two items
each agent gets one of these items
because there is the important ones
nobody should be getting more than one
of those and you might ask how do you do
that I mean how do you match there are
many different ways to match and the
interesting thing is actually that last
step you can do it optimally because you
can just say VI of XP is the value of I
based on what the first couple of steps
the value she already has and then you
can just change the Vij through log of
VI XP the value she already has plus V
AJ and the maximum weight yeah and that
dummy items of value that much so an
run and maximum weight matching
algorithm so the thing is if you have
unit demand the problem is easy right
it's a maximum weight matching algorithm
but the problem becomes harder when you
want more than one items but in this
case at this point we only want to match
people so we can do it optimally and
what we prove is essentially that
everybody who gets an item in this face
is fine so we would if everybody got one
we'll definitely get it to approximation
because all they're really important
ones the ones in H go to a different
player each and everybody else we get a
value of 1/2 we cannot do that we cannot
make sure everybody gets one of these
items but we're showing that in this
matching there exists a matching where
even the ones who do not the ones who do
not get an item must have received
substantial enough value from the first
two steps so they're they're fine and
instead of a two approximation sorry and
this is the matching instead of two
approximation that's why we get a bit
although although with the tighter
analysis we now believe in mine a bit to
approximation here depended on your
choice of a but so you're saying that
doesn't matter yes yeah it doesn't
matter it's arbitrary essentially all we
want is to make sure that at the end
really you want the we end up having
some components at the end we want to
make sure that everyone there always
exists someone who receives value if he
doesn't get one of the items he must
have received value from his children
items so no matter what the ordering
there exists such person sorry no then I
mean the mysterious step is like the
second step right I don't see like if
you cannot get matched in the third step
like why would you say that he got a lot
of small items they always exist one
within each component yeah it was a long
bao XP nobody you're talking about the
proof right about how we can argue there
exists someone because we always round
upwards and we're saying essentially
it's because of again the scaling that
the sum of the prices is equal to the
number of players right if all the items
if I if I got all the items that I was
spending on then the prices of these
items would have been so the sum of the
prices are of the items that we were
spending on are at Lee
as much as the number of players in that
component right so that's that's the
argument if if for some reason someone
that doesn't get anything that means
that he must have been rounded something
before I mean it's not it's a delicate
argument but there always exists someone
that's the core of the okay and that's
yeah so really to summarize I mean the
idea is that you get this market
equilibrium we we apply this constraint
we compute this different market
equilibrium with which reveals more
information we use it in two ways we use
it in order to get this upper bound by
treating the highly priced items as
important and indivisible and then
allowing fractional relaxation on the
less important items and then the
rounding goes along the same lines that
it tries to keep uses the prices again
as a signal of keeping the the highly
priced items for the end for the
matching and trying to be unify and be
balanced in the weight it distributes
the non important items so we haven't
verified everything but we think with
the Titan Alice's a the answers to yes
yeah this was the first kind of rough
analysis that gave us this so let me
wrap up with one quick I a quick
discussion how we compute this so
because I think I actually like this
it's it's based on Neil's work and it's
kind of how we you can actually compute
the market equilibrium in a computer
toriel way and the nice thing is that if
you're given a vector of crisis P then
you can write you can have the following
network here you have a sink here all
the agents all the items and this source
I sorry as a source and a sink and then
the capacities of the edges from the
source to the agents are one equal to
the budget the capacities of the edges
from the items to the sink are the
prices the current price of the items
and then you have edges here if the item
is one of the favorite items the maximum
bang per buck items and what is and yeah
this is what the second bullet says that
IJ between agent I and J exists if and
only if item J is a maximum bang per
buck
item four H&amp;amp;I at the current prices and
if you could if you compute a max flow
in this network and it just so happens
that all these capacities are saturated
right you're using all these capacities
in full what does it mean that you're
fine everybody's spending all of their
budget on their favorite items and all
the items are fully allocated so that we
find the tricky thing is of course how
do you find the prices and it's very
delicate once you change the prices
you're really affecting this structure
over here you can change it dramatically
right so if you change the price the
prices you change the structure so how
this works is you start from low prices
we're essentially not all the the left
these edges over here not used to
capacity not everyone is spending the
and then you have over demanded items
here and then you gradually in parallel
increase some of the prices and the
reason why you do it in parallel by the
same multiplicative factor is to
maintain these edges here and you
gradually increase this in a very
careful way and that you have to make
sure this primal dual approach
eventually completes in a polynomial
number of steps and this is what
Nicollet i'll showed in their in their
paper how to actually do this in
polynomial time that there's a way of
doing this in polynomial time what what
is great about this comunitario
algorithm is if you think about it the
flow is spending what I just described
this maximum flow is essentially pushing
spending through from the source to the
sink so all we need to do for our
constraint although it wasn't easy to
introduce it into the complex program is
just is yeah instead of having the
prices here just have the minimum of the
price in one right so we just changed
this to capacity so it's introduced a
new capacity constraint which is at most
one so essentially the same approach
works by just introducing because they
fit perfectly these capacity constraints
that we have on the spending if the
spending is really the variable here in
the flow and this is this is how we
computed it but as I mentioned before
now there's also a convex program to
compute this
these things are some sort of
monotonically increasing yeah yeah you
have to make sure it said that's a
bigoted process otherwise ik I don't see
like how you can just put this little
thing has to make sure that you have to
go in Coronel make sure mmm the events
that take place you know because if you
increase maybe someone I was interested
in something else
okay so closing the answer is zero is a
census print if I can just calculate the
mass like a matching right instead of
matching my classroom so Montes box
which is just matching if they give the
value 0 1 0 yeah jobs like one of the
agents on one side items on the other to
check in with 0 not yeah yes I just for
me every nonzero value pair but it
doesn't need to be 0 right that's why
I'm saying if you have one item sure
it's gonna be 0 that's why my example
has more item subsides here it's low or
high right if you have missing no but we
know the matching polytope so
intuitively you should the the program
should be stronger than that you just
don't want to just check matching if
there is one you want to also have a
value on on solutions right but I'm
saying the current solution cannot even
detect 0 was is not 0 that you can do
easily right that's at first you can run
this as a first step to verify 0 should
do it I mean the first one right here
yeah I guess I mean you can just ya know
I mean you can run I said I mean this is
not an interesting the numbers the
prices are not unique for this new
casino by simple to zero actually
interesting in the PJs in their solution
that's like a hostage basically yeah and
the prices the prices are not unique
that give you this I don't know if your
programs like give a particular prices
but you can multiply all the ones in age
you know you can increase them further
you can possibly greater than still
doesn't change anything you know in some
cases for example in this this bidder
who only likes that item you could so
it's not really unique right so if you
increase the prices we're not using the
numbers of the prices right we're only
using which ones are bigger than one in
which are in aren't so otherwise it
doesn't really matter why is you
probably like it I just still don't get
like there's some your mama some or two
dimensions it can you formulate the
problem into like I don't know
particular scaling of values
we're expressing the upper bounds
now we're not proving it for a
particular scene if this feeling doesn't
matter we're just the thing is we
couldn't express express the upper bound
as a function of the players value don't
know what goes to whom so we're
expressing it as a function of the price
disassociation or the approximation
because we're still both opt and it
doesn't matter it simplifies right it
doesn't affect the approximation
so yeah the stealing is just a
convenient way to express the upper
bound in a 16 way so you're in your
algorithm did you show it only for this
case where the budgets are one and this
upper works are one yes
budgets are one different budgets I'm
not sure of this it's alright we thought
about it but it's not I'll give them
equal weights
what's the live in the budgets are equal
and this upper bound on the prices all
the budgets are one for each other this
one to finding finding this SR outcome
on the budgets have to be one and I'm
not I'm not sure about the algorithm in
the rounding I mean the capacity well
because the capacity constrain that we
have is essentially a but the budget the
computing the also being I mean but it's
may be different but maybe the upper
bones you need them to be I don't think
we use that yeah I mean we didn't look
into that because even if we could
compute that it wasn't useful for that
it seemed to be but I don't think there
was anything particularly specific three
equal budgets I mean it seemed to be
fitting nicely with one of the existed
it wasn't thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>