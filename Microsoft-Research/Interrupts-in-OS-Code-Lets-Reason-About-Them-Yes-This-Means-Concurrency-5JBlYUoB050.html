<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Interrupts in OS Code: Let's Reason About Them. Yes, This Means Concurrency | Coder Coacher - Coaching Coders</title><meta content="Interrupts in OS Code: Let's Reason About Them. Yes, This Means Concurrency - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Interrupts in OS Code: Let's Reason About Them. Yes, This Means Concurrency</b></h2><h5 class="post__date">2016-06-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5JBlYUoB050" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
welcome everyone this morning my name is
Royston leno and it's my pleasure to
introduce june and onyx from from well
what used to be called NICTA is now
called data 61 in Australia June has a
long experience in verifying various
kinds of systems for a four-round her
PhD time in France she worked at gemalto
on the verification of Java card sorts
of things and she's more famously been
part of the SEL for a verified project
which I see he's wearing that t-shirt
absolutely and there she's worked on on
see verification the like the seaside
going from them from the specs using
using Isabelle one thing that's very
important in this field is the the
maintenance of proofs and and verified
software which our community does not
know enough about and she's been
involved in at and in particular making
some measurements of of what what seems
to matter and how do how do proofs go
and what I mean what do you see in the
maintenance phase and she has many
distinct distinctions and one is the MIT
she called technology reviews TR 35
which is the what I was called young
innovators yes 35 of young boys yes
writing the 35 means less than 35 years
of age and and today she's going to talk
about projects going forward and in that
group so welcome cool thank you very
much for this very thorough introduction
so thank you everyone thank you for
hosting me here as well it's a pleasure
to be able to present a bit of the
recent work we've been working on and
also know a little bit more of the work
going on here so yeah I'm part of the
tour through the system group in what is
now called at a 61 so generally speaking
the twist where the system group is
aiming at providing high assurance OS
and by her surance we mean formal
mathematical proofs about correctness
and security properties the the work I'm
going to present now is a bit of a more
recent work that where we look at the
challenge of interrupts in OS code so
most of verified our operating system
including SEL for will run OS code with
interrupts off which means that the
execution is completely sequential here
we're looking at OS code that needs to
run with interrupts on for real-time
capabilities and this means that we need
some kind of concurrency reasoning in
there so more specifically we're
targeting a small real-time embedded OS
which is called the kronos that is
developed in our group in construction
with another company and it is mainly
commercially used in medical devices but
also we have a DARPA funded project
called hakam's where with several
partners here in the US we embedded into
a flying drone a flying quadcopter that
the research vehicle we're also working
with Boeing on the real helicopter
running that and what is common about
that is it's basically very constrained
how we're with no memory protection no
dual mode execution so the code is
tightly linked to the application code
yes I'm naive question how can you even
have West code that runs with interrupts
off how will that how will the machine
then interact with all the peripherals
so for instance here in SEL for you have
a very limited number of well identified
preemption point for the long running
operations but all the rest is very fast
code you don't spend much time in the
colonel so the colonel between a system
call and a
exit is there is very limited time
inside the colonel and so for the very
limited long running operations like
like deleting things then you would have
very specific branching point where you
can reason about them like with specific
specifications yeah when the when they
interrupt happens something else is
running the OS is not running is it what
is running at that way application code
is running so interrupts are on during
application code but as soon as you do a
system call you switch off in drops and
then when you exit the colonel then so
that's for a CL for and foremost of yeah
I verified OSS um yeah okay um so the so
the main thing here is we have very
constrained hardware and because of
ensuring very low latency we run with
interrupts on so it is interruptible OS
code including actually during the
scheduling operation so you don't switch
interrupts even when you do the
scheduling operations on the other hand
the concurrency is still quite limited
we're still on a single core machine so
we're not doing multi-core we have prowl
execution on different course and to be
precise the scheduling happening is also
a pre-emptive which complicates also the
interleaving between OS code application
code and interrupt code but I'll come
back to that in a bit more detail but
basically that's what we want to verify
an embedded OS that is interrupted all
single core with preemptive
multi-threaded scheduling all right so
that's for the target the approach that
will be using is actually a foundational
concurrency method that is conceptually
quite simple so because of concurrency
that we're having is quite limited but
on the other hand it is on shared
variable that are highly shared and not
locked when accessed we first don't need
a completely new complex formalism but
we went for a conceptually simple shared
viable reasoning
framework so we went for a weekly grease
on the other hand a week in Greece was
developed about 40 years ago for um
basically pen and paper proofs of
protocols like concurrency protocols or
compensate algorithms and from that to a
rating system there's still a gap and
plus a wiki Greece is quite well known
to be I have an explosion of
publications and so what we do is that
we combine that with first of all we're
gonna add a bit on the framework to be
able to limit the concurrency is having
what I said is that the concurrency is
still limited in our frameworks are we
going to instrument a wiki Greece to
model that but we're also going to use
modern theorem proving techniques in our
case Isabelle are using the theorem
prover either the hole for the proof to
be machine check but also for using a
lot of the automation from Isabelle to
discharge a lot of the obligation that a
wiki Greece would generate so in a
nutshell that's it so we want to verify
acronis using some kind of an extension
or adaptation of wheat degrees and with
the help of Isabelle hole for the proofs
just to be clear before studying when I
say prevent so we have done a formal
proof of a model of acronis so far so
compared to us here for so where we've
already you know like done the proof
down to the binary level at this stage
we're looking at the model level and but
we do it in a framework that will allow
to do refinement as the next step that's
what we're looking at now so that you
don't be disappointed at the end that
we're not having a proof at the binary
level yet okay so this talk first I'm
going to explain in a bit more detail
what we want to model how the
interleaving execution works in a
neuronal space system then I'll present
two of the main bodies of work that
we're doing first is how we model this
into living formally between the
application code scheduler the interrupt
handlers in a wiki Reese and secondly
how we do the proof of correctness using
a model so the model is to start with
quite generic and then we instantiate to
acronis and then we do a proof of
correctness of this
dling behavior of acronis which is quite
high level we keep we only model the
things that matter for the scheduling
behavior and the main property we're
proving for a Kronos is that the run is
task is always the highest priority
runnable task which is one of the main
property that acronis needs to ensure in
on the model sides I said we we adapted
a week agrees with a proof framework
around it one of them we called a weight
painting that I'll explain which is the
way we restrict the interleaving
possible in a week agrees and to do that
we have also an explicit model of the
API of the hardware that does taking an
interrupt returning for an intra
actually controlling this into living
under Isabel side we have a liberal of
proof framework but also some proof
engineering techniques that typically
would make a week agrees practical for
such a case study and and proof alright
so let's start with the inter living
execution so again Kronos is a small
embedded OS it's actually more like a
library because it runs as i said on
quite constrained hardware so it's more
like a library of api function and it
allows the application code to be
organisers task which are basically
reactive loops that perform specific
cohesive set of actions and the task can
call to the api for synchronization like
semaphores my texts and stuff like that
or just signals and the other big job of
the OS is to provide the scheduler so
that you provide a way to determine
which tasks should be running and that's
why one of the main property for the
correctness of it Kronos would be that
the scheduler does its job properly
which means that whatever the policy is
the scheduling policy in the van we're
looking at is based on property that's
why the property is that the highest
priority is running but whatever that is
the job of the scheduler is to ensure
that any given point in time the task
that is running is the one that should
be
according to the policy okay yep most of
us kind of exist before you started
verifying it or if you develop it as
part of China very um so the code for
acronis exists so it's not like a CL for
which we had a co-development between
the co-development of the code and the
proof so the code exists although we
they are many variants of it and some of
our engineers are involved in making
that code evolving and at the at this
point in time we're not doing
implementation verification which is
where in a CL for we had a lot of
interaction with the programmers to be
able to adapt the code for verification
to make verification easier or yeah so
it's it's quite possible so we're in
quite collaboration with the people
developing it so it's quite possible
that when we would reach the
implementation verification there would
be some choices that we would have to
negotiate with them if we could adapt
the code but it's true that for a CL for
it's quite known that it had been made
possible we could because we we didn't
have a static completely fixed code base
yeah there was not be happy if you to
sable interrupts for for all of them yes
exactly so so there is I mean in that
sense we tried we we model something
that is a realistic from a system point
of view on the other hand we haven't had
any or yet any verification push to
change anything to make I don't know
verification possible I mean obviously
yes if we would switch the interrupts
yes that would be one choice but that
was the challenge we wanted to talk over
it all right so yeah so typically tasks
um would be in three different kind of
states either you're the currently
running task only one within single core
then you could get blocked if for
instance you decide to wait on a signal
and once you unblock you come back to a
pool of runnable set so the pool of
runnable set is really what is important
is any
anytime this would be changed this is
where the scheduler should be called
because this means that at some point
you have added something here that could
be of higher priority than the currently
running task and so you should stop the
currently running task to Rhonda the one
that is higher here so by describing
what I just said this means that the
scheduling is pre-emptive so we don't
wait for the application to decide to
release the CPU but the scheduler can
decide at any given point in time that
there is highest priority running a
runnable available and therefore to stop
the current task I'm going to go into
the interleaving in a bit more detail
just in the next slide but so the last
thing that happens is the interrupts so
your your system would react to some
interrupts that I define a configuration
and so the programmer defined some
handlers one for each interrupt and
these handlers so again it's code
provided by the programmer and it can
call limited set of the API functions so
typically the handlers would do what i
would call local computation so you know
like some kind of copying buffers and
stuff like that from hardware to
software which we at the moment abstract
away from because it doesn't have any
influence on the scheduling but it can
do some operations that will influence
the scheduling in particular sending
signals so if there is some kind of
interrupts that should wake up or
unblock some of the tasks that are
waiting for that then it would call the
signal send API and that would
potentially unblock a task and therefore
would influence this the scheduling all
right so just a side note I'm the again
the variant of acronis that we're
targeting is running on an arm platform
the only thing that really matters for
our model is that it introduces a new
interesting things for the into livings
that interrupts can be nested so
interrupts can interrupts each other and
actually can only do so according to a
policy so an interrupt can interrupt
another interrupt that's a lot of
interrupts only if it has a high
priority
okay so this is just to say that we are
in a setting where most of the
interesting challenges are present so
how does it really look like in terms of
interleaving if we have to task a and B
the first interesting case that is the
just the simplest one is that in
application code an interrupt can happen
at any time so the hardware would stop
that execution switch to the interrupt
handler execute the handler and this is
where the handler might potentially do
an operation an API operation that would
unblock a task and therefore when we
finish the handler this is where the
execution should not come back to be
because this potentially have should
unblock maybe task a for instance so the
scheduler should be called so at the end
of the handler the scheduler should be
call which in this case is gone is
considered in a different execution
context so it's it's own execution
context here and then the scheduler just
checks the runner bowl set and would
pick the next task so in this case it
would preempt the running application
task so application code is
interruptible and it's also pre-emptive
all it could be stopped in its execution
here I represent then a function call so
I presented in Greenwich kind of
represents the OS code so at some point
the task can decide to call a function
of the API like locking a mutex or
taking a semaphore and acquiring
semaphore and the main difference here
is that interrupts are on while we do
that so in a cell for you would switch
interrupts off as you take the system
call and so that again goes to the
interrupt handler which may require the
scheduler to run the main difference
between application code being
interrupted and os could being
interrupted is that we would still go
back to the OS code to finish the APR
function and scheduler would only be
delayed at the end of the the OS code
execution and so there is a special
mechanism at the end of the handler that
checks did I interrupt application code
or else code if its application and go
back to the scheduler otherwise I go
back
the previous task and only at the end
there is a mechanism that checks that if
there was something requested the
scheduler requested then I would switch
to the scheduler just a particular case
of that an instantiation of that case is
during the scheduler interrupts our own
as well so while you're deciding which
one is next run you might have a handler
running as well so that's a specific
case of the other one so in both these
cases the OS code including scheduler is
interrupted but it's not pre-emptive all
you go back to the to the to finishing
the execution before switching to the
the scheduler yeah is your goal to
verify the green scheduler for any
golden the yellow and the blue yes so
the goal is that for for any so if we
model this we want to show that at egg
any given point in time where you reach
this yellow code you're the one that
should be running so basically you
didn't forget to call the scheduler when
you had to call it and the scheduler has
been able to execute in a way that when
it takes that decision you go back to
the task that was the highest in the
arbiter yes sorry yes correct so we
obstructive can be completely arbitrary
yes so the blue coat on so in the blue
code we only model if it calls an API
function so we model the blue code as
being doing anything arbitrary and
potentially changing the runabout the
signals to so the events all right but
otherwise yes we abstract away from
these things that are specific to the
application all right so this was like
the medical case oh yeah the thing that
I was just saying that interrupts can be
interrupted themselves so you also have
this this case here okay so this is what
we want to model how we modeled it is
what I'm going to present now so our
approach was to actually just consider a
concurrency setting where we would put
all the code in parallel although it
doesn't happen in parallel so we we put
in peril and then we instrumented in a
way that we restrict the interleaving to
where it actually happens
so to allow full concurrency we just use
a wiki Greece which just means that this
pile composition is the standard coppell
composition where if you're executing
one statement the next statement can be
anyone in the in the peril composition
and then restriction is what we call the
await painting and I'll come back to
that in a minute so first I'll I'll just
so how many of you are familiar with a
wiki Greece or should I yeah okay so
I'll just stop explains that wiki Greece
is the first and what simple extension
of whole logic for parallel programs so
yeah check of that statement okay yes a
lot of confusion right its opinion and I
agree with it was that it's an extension
of Floyd's original system right
parallel programs rather than for logic
okay so it's in it all right um well you
can't okay yeah all right that's okay
okay I'll think that in my notes and try
to change my description of it thanks
which I have everyone's so but basically
whole horse / boy logic allow you to
describe you know like previous
condition from a precondition for a
program that has a certain kind of
syntax and semantics and what a week
agrees would add is basically to
construct to that type of programs one
is the parallel composition which the
semantic I just described you just not
deterministically pick one of them and
execute its current instruction and for
the second construct its Anna wait
statement so the await statement is a
way to synchronize those parallel
programs and it just execute that
condition only when that boolean guard
is true so it's a way to synchronize so
to wait on something to be true to be
able to execute that that program so
there are two new construct and as we
know in Hologic you have a verification
condition generator and why it is more
complicated for which agrees it's simply
that whenever you had a program in whole
logic and then you will generate like
primitive state
that just infers what are the
intermediate assertions when you put
something in parallel you suddenly have
interference so you have to show that
anything that is in parallel doesn't
violate what is here so after you have
executed see one you have established p2
locally and at this stage if you put
something in parallel then you could
violate peachy when you start the next
instruction locally so what our wiki
grease on proposes is basically showing
first local correctness so as you would
do in normal whole logic but then you
show inference freedom which means that
you annotate fully you whole program and
then every statement in a parallel
program should be shown not to violate
any of the assertions that you have used
for your local correctness so that's why
you have the state explode like a
prefabrication explosion because
basically have a quadratic number of
verification condition to prove any to
requires a fully annotated program so in
our case we don't so we got to first
restrict that concurrency we don't have
full concurrence there are only some
points where it can happen and so this
is what we're gonna instrument now and
we also gonna use isabel then to
discharge a lot of the proof of Legation
that are just trivially contradictory
because you can't be at those two places
at the same time we actually use a
formalization an existing formalization
of a wiki grease in Isabel that has done
by Leo no prints and yet Oh in 2002 and
which is in the Isabel distribution
standard distribution so we just gonna
extend on that so as I said once once
you do that and you put the peril
composition then you have way too much
into leaving so what we want is to say
well actually the concurrency only
happen at the points where an interim
handler can start so when I'm executing
anywhere in code a I can't execute the
next instruction can't be something in
code be but it can it can be the first
instruction of one of the handlers and
when I put code here by the way I just
mean a model of the program that
represents that but I'm not at the
instruction level as I said okay so what
is this away p
think so in a wiki grease we don't
actually have a notion of tasks like
it's implicit we don't have them as
first citizen so we have to be able to
talk about what a task is so we
introduce a viable 84 the active task
and here task is both application tasks
but also the scheduler or the handler so
80 represents Who of those programs is
executing and then we wait paint all
most all the statement a white paint
just means that every program is guarded
by an instruction saying 8 equals me so
if I'm in code a I have this 8 equals a
and in eight equals B&amp;amp;B so you can see
here that this completely removes all
interleaving so I suddenly you have
sequential execution until I have an
explicit assignment of 18 so if suddenly
one of these instructions would be like
if you were incorporated scheduling you
could have one here that says 8 equals B
i release my I just want to switch to be
and then you would you so we explicitly
see where the interleaving happens um
and with a modified here the I variable
so so far not oh ok yes and so then we
provide so 80 should be only changed by
not the code it doesn't exist in the
code but by the OS functions that may
modify it including the scheduler so the
scheduler and the interrupt taking
interrupts okay so when you taking traps
when you return from interrupt or when
you do context switch that's all the
three cases where you would change the
80 and this is what i call you know like
a hardware api model so we now can
describe precisely what it is doing we
assume that the code would not the
application code would not change our
coldest context switching without going
through the OS api we could prove it if
we were not in a like in a setting like
a CL for where everything goes through
the colonel but because we don't have
any protection we have to assume it but
we can check that statically on the
application code and so apart from those
those instructions
everything else that would be sequential
and well of course we don't do that
manually like we have a command away
pain that does it for all of the code
and actually we don't have to assume
that we have only two or three I don't
have to basically hand-wave saying that
two is equal to n so we actually can
talk about anything so we have just a
construct that comes from the existing
formalization where we say we have n
tasks we have an application task
they're all in infinite loop and we were
given the code by the programmer this
could be including api functions and
then we wait painted so i showed that
for the application code which in the
application code yes you don't have any
switching and so now for the whole thing
so this is the application code that
I've just shown and for the scheduler
and the interrupt is almost similar
apart from the fact that you
encapsulated between taking the
interrupt and returning from the
interrupt and that's what I will present
now so if you note here the only thing
that is not a Wade painting would be
taking those interrupts this means that
this is the only place where the
interleaving will really happen
automatically with the a week agree so
we can risk or guarantee that everything
will be sequential apart from
potentially non deterministically
picking the instruction um so that's our
model of until leaving and now i'm going
to present what is I take and I return
this yeah I'm super puzzle dad yeah here
boo what was that called ah yes 18 where
is that what available going to be more
right here here uh I take in I return
let me modify the 90 can either turn yes
sir and in the scheduler scheduler
sometime that is a scheduler I'm going
to show it yeah so basically we provide
three ways of changing it i take i
return and a context switch in a
function that can be called by the
scheduler yeah and then all the await
paint just to remind you this just says
80 wait for 80 to be equal to H so one
of the valley
use of that variable special variable is
each task I yes then one of them is the
idea of the scheduler yes and one of
them I each handler correct yes okay and
so because you have for instance all the
code here if I have three instruction if
I'm executing care instruction I can't
suddenly switch to somewhere else in the
handler the only thing that can happen
is that I would switch to the top of one
of the handlers okay so I'll just
pretend I take and I returned just now
hopefully it's going to get a bit
clearer so yeah so the this model you
have to show how you take the scheduler
the return and the take I'll just show
the take and the return I can discuss
the scheduler separately if you want to
but just for time reasons i'll i'll just
show the two ones so i take is really
this non deterministic taking of an
interrupt so the first naive way of
seeing it is just a t equals H so at any
given point in time 80 can be switched
the only thing that we need to be
careful is that you they are ways of
switching off interrupts right so you
still need to be sure that the interop
is not masked so the application code
could switch off interrupts if they
wanted to and then you can't take the
intro so you still have in a way to
statement here that describes the fact
that in the hardware you can't take an
interrupt if its mass and so that so we
add a new viable which is e I inter
enabled interrupts and you can only do
the switching to the handler if this
handler is in the enable interrupts it
is in a weight segment but it's not the
general wait painting things that we
were doing it's much more permissive so
you can have that at the same time that
you're executing task a this can be true
at the same time it's because we have
nested interrupts actually the can
interrupt is a
more complicated Oh first of all yeah we
have also to remember while we update
the task what was the task so you put in
on a stack and it is a stack because you
could be nested again so you have to
remember what was the previous task okay
and the can interrupt I said was a
little bit more complicated I'll just
put the two first of all if you are a
handler that has been interrupted you
can't take that interrupt the game right
because you are the handler is being
interrupted so you can only take it if
you are enabled and you're not already
suspended waiting to finish and as I
said there's sometimes also in the
hardware some kind of policy that says
some interrupts can't interrupt others
so only if you can interrupt the
currently so this basically these two
aspects are really because of the nested
interrupts but you can ignore them if
you don't have nested interrupts so
that's it so that's how you model I take
and that's our representation of what we
understand the hard way is doing when
taking an interrupt and this is what
we've been discussing with the system's
guide to ensure that this is really what
would happened and then for the return
from interrupt as I said on the easy
case you basically just change 80 to
take the scheduling to take the
scheduler but as I said this is only one
case so if you remember I said well they
are two case if and this should be if
I'm in the OS code or application code
if I mean application code then I go
back to the scheduler if I'm 100 s code
I should just go back to the previous
task okay so I just popped the stack and
and go back to what the head of 80 was
ok and the way we decide our wii and
application code are win OS code the way
it is done in acronis is that every API
function that may change something for
the scheduler might change a cold call
some some you know context switching or
my influence the scheduling decisions
you switch off as i said the scheduler
so that when you come back to the from
the handler
you know that you have to go back to
West code and the way it is done is that
the scheduler is considered a bit like
an interrupt a software interrupt and so
you just disable it the same way you
would disable an interrupt okay so every
time you enter OS code you disable the
scheduler by putting it out of the
enable interrupts and then when you
return from an interrupt the only thing
that the handler will do instead of
calling the scheduler is saying I
request the scheduler so whenever you
have so you have an extra available that
is scheduler requested and only if the
scheduler is requested and the scheduler
is enabled meaning I'm in application
code then I would call the scheduler
straight away otherwise i will just go
back to the previous task and finish so
I'm not presenting the how we take that
but basically this is where you would
look at is a scheduler require has been
as a scheduler been requested which
means that OS code has been interrupted
but hasn't been handled yet and
therefore I would switch on the schedule
layer again here and switch to it to be
able to handle it okay so that's more or
less the mall until until living this is
the generic but i'll just show in a
minute how we what is specific to
Chronos but from a generic point of view
we have a an interleaving with do a wiki
grease persuade painting and a few api
function to enable and disable the
scheduler and take take and returned
from interrupt yes your language your
modeling language house what what does
it look like so the modeling at language
is basically the simple wire loop a wild
program programming language that i
should when i showed a wiki grease plus
parallel composition in a weight
statement so if your question is about
granularity checker and all that and
then you compile and somehow generation
isabel is that how it is so um the
language itself is already written in
Isabel I'm pretty sure that your your
next question is granularity or
something like our attention I've heard
so much about the SEL 14 yes and I I all
I know about is enter some Isabel thing
going on there I can't receive
concretely what Rama What's Wrong
development looks like what is the
syntax that the programmer is confronted
with okay so um maybe I'll take that
question at the end but basically in SEL
for you have the C program that is
translating to Isabel and then yes you
have a/c parser that takes the sea
program translate into a deep embedding
of interactive programs inside Isabel so
you have a formalization of your C
program inside Isabel and then you have
a high-level specification that is
basically a high-level functional
representation of what the program is
supposed to do and then you have a
refinement proof and then we have a
different story down to the binary what
i'm doing here is basically working at
this level i just assumed that i have a
high level while language the the
acronis code is written in Isabel is
written in C and eventually if we do
refer Minh what we want to do now is
we're going to translate that seemed too
easy Isabel using the same see parser
and then do some kind of refinement but
with the concurrency aspect that we have
to care about atomicity that's why I
thought your question was linked to that
because at the high level I just say I
have one instruction and this is what
happens and at the bottom I might have
10 instruction I need to show that it
refines properly with respect to
concurrency yeah is it an silhouette
animosity at lunch okay that sounds good
in translation sponsored contrasted code
base and the translation from cg Isabel
sparked a very interested in in a CR for
it used to be it's not anymore because
we go down to the binary so initially
the first big results for functional
correctness was from c2
up to abstract specification this
assumed both the translation and the
compiler correct now that we have
compilation down to binary the trusted
is reduced to translating the binary
into whole force using the chem bridge
translation which is much more
straightforward and which much less
possibility for misinterpretation yeah
I'm one of the good question the
programmer who writes the code yes he
the verifier call that programmers
writing in c in which any chronic I'm
bonkers physiol for yes so the the
interaction when the prover so speak is
at the level of the season tanks is that
correct yes uh yes so the preconditions
and postconditions are also added to
know um the if the first condition and
preconditions are written directly needs
ago inner oh I see so that when the
programmer the grammar writes code and
see yes and then he write specifications
Isabelle yes so he needs to he or she
needs to know that this piece of seafood
will be translated into such and such a
name yeah Isabelle so that he can refer
to it in as a bell well yeah I mean this
colors are standard okay there are a few
things that are so there was we with the
with the maintenance I don't know how
much we gonna do that but there was a
stage where we would actually start
writing in haskell and then writing in C
and then the Haskell was the
intermediate level between the sea and
the abstract specification the abstract
specification is really what describe
what the program is doing so it's it's
it's a little bit more detail than pre
and post you could consider it like how
they call it like full specification
like print post can be quite abstracted
away right so it's a full description at
the abstract level but yeah if you want
to verify a new function like that we
doing now right SEO for evolves and so
when you want to write a new function
you ready tab starts back in Isabel
ideally you would first write it in
Haskell and you would just check first
at the house call the design correspond
to your spec then you write it very
Optimizely in C translate into Isabel
enter your Fineman proof yo I lost now
or later sure yes it is it is not the
same kind of integrated model an
integrated development for verification
program that you would do for something
like Daphne where you write your specs
as a pre and post or things like from a
C or things like that where you write
your pre a new post or java stuff legs
as well print post in the program but in
that it's quite hard to write a full
abstract functional specification of a
system you usually write things per
function not for a full system so for
instance the really nice thing about
having an abstract spec is then you can
prove properties about it so the key
thing like what I'm doing now you
wouldn't like the property that I'm
going to express the environment would
be harder to just put as print post
inside your your directly at your sea
level and same thing for the security
properties about so far so I know I
agree with that yeah I was just trying
to get an understanding of what is the
programmers mental model so when I right
program C sharp when I'm not trying to
write any verified program yeah I have
to deal with the type checker of C sharp
right there's a mental model of what the
compiler is going to do when it
generates executable code yeah I'm
trying to figure out what is that mental
model when one is doing better fights
offered about men in your group what are
the kinds of tools that people use and
how the orchestrations okay i might take
that at the end because then i'll but
typically we have 22 teams working
together the colonel people &amp;amp; D
verification people some of them are in
between I did you both but typically we
would have Colonel people writing the
code and then verification people they
are adding the the talking to to these
guys to do the abstract specification
and then and then doing the proofs yeah
okay so I'll just um
finish that little bit so I said this is
quite January so now code a schedule so
the scheduler is really what we need to
describe now for any specific things
like a chrono so what is the scheduler
really doing for the handlers and the
application it is generic in what they
do for when its application specific but
when I call an API function this is
actually part of code a here ok so for
acronis what I have to do is that I have
to describe what those code are so i
just showed the scheduler and the
handler here so the handler for instance
we don't show again the local
computation but we show we have two main
variable the orange of importance for
the scheduling property the r which has
the run both sets that i described and
the e which are the events that are the
things that the that will change when
you call a signal right so handler would
raise an event to say i need to unblock
a task and so what the only thing we
model about handlers that they may
change the events and then they request
the scheduling ok and then they made you
local computation that we don't model
here what the scheduler is doing is very
clipping the next task so it uh it would
handle the event so it would update the
runner ball depending on what the events
where we save it before because this is
interruptible so you could have an
interrupt changing yeah that's at the
same time and then you call the
scheduling policy which is kept quite
generic here so this is what we'd so
we're not proving the scheduling policy
being or algorithm you correct but more
the interleaving and then you switch to
that task and again I'm not showing the
code a but what could a is doing is
either application tasks that are
obstructed away or potentially calling
an API function that will change this
that will request the scheduling like
yielding are actually same thing like
changing events ok so now I assume that
this is the model part how do I prove a
property about it what have proof so far
as I said we prove that the running task
is always the highest priority task
runnable task
so this is the English version how do we
translate that into our formalization so
if we remember that if I take the point
of view of one task running it means
that every time I'm in the orange code
here which means application is running
then if I would run the scheduler now it
would pick me meaning that there is
nothing that has happened in the
runnable task that would pick someone
else and that I haven't handled somehow
meaning that if I'm here and I'm not
supposed to be the one running it means
that there is a highest Rory task that
is prevented from running which is bad
for real time um okay so what we have in
a wiki Greece is a way to describe that
the post condition is reached um yes
that's not true they're running tests so
you couldn't there be in unless they're
and that's one less I'm in the system
call so that's what i mean by um so
you're right so when with the running
application task which we described as
when i'm in when user code is user code
is actually running outside of high
school so correct so you'll see in the
formulation that this is exactly what we
say um yeah the first thing is so so far
we have pre and post and we have
actually infinite loops so the post
condition is never reached we don't care
about the bus condition what we really
care about is an environment the
environment like see is a pal program
that is fully annotated so invite it's
just putting it in annotations but it
would be nicer to have a way to describe
the environment independently right but
that's the first thing we have done but
the other thing more importantly for
making this scale is the environment
would rely on many other smaller
environment about many of the data
structures that you're manipulating the
problem is that if so what you're really
proving is something like that the
problem is that this means that you have
to put all the correct annotations in
here to a be able to prove them to put
all of them and this doesn't really
scale and moreover maybe I needs I nine
but maybe I nine doesn't need any of the
other ones and so you would like to
prove I nine separately so that's the
first thing we've done is
ads ads actual syntax to be able to talk
about environment and then we add
support you assuming environment to be
able to prove them separately and so we
have this compositionality lemma where
we say that if you want to prove to
invariant and that one might not depend
on the other then you might prove I
prime separately and then you can put
all the assertions here that only talk
about or are needed for I prime and then
you can forget about those assertions
and then prove your actual big
environment just assuming that helper
environment there's a merge here that
just means that the the programs are the
same but you merge all the annotations
so that here you have actually all the
merge annotation but you didn't have to
write them by hand this is this is like
it is like a simple modest ponens kind
of rule but it's critical to the proof
itself and we'll see you how because we
had we talked about static sorry
prefabrication explosion right a lot of
publications and and then we want to use
Isabel simplify your automation to
discharge a lot of them but if those
preferably gatien's are very complicated
because you have all these dysfunctions
and you don't know which one you need to
which right then the simplifier would
explore too much state so it's quite
important to be able to decompose it
first before using automation so now
that we have that we can state the prop
the theorem that we've proved to them
that we've proved is this one is meaning
that under no precondition like true the
acronis system which is defined as this
fool interleaving of application code
scheduler and handler code preserve that
schedule invited at each assertion level
so at every single assertion then the
scheduler invite is true what the
scheduler invite means and now this
means that come back to your question
just now if a TD active that is a user
task so I'm not in the scheduler I'm not
in a handler code and I am in
application code so meaning i'm not in
OS code and i describe this by saying
the scheduler is enabled because i like
remember we
disable scheduler here and we're enable
here okay so when I have the scheduler
enabled then if I would run the
scheduling policy with the current II
and the currents are then it would pick
me meaning there hasn't been any chain
here that have been forgotten in half
and we'd pick someone else if we call it
here so yes so if you had a bar for the
interruption where's that uh returns of
the application yes it's never called
the scheduler yes um so how would this
property be violated or is that well the
property would be violated because the
handler would have changed tea and if
you had run the scheduler the a would
have unblocked the handler the handle
event just looks at me and says oh he
was meant to go to a and a should be now
and blood so I'm gonna unblock a so a
comes into our and so if i call the
scheduling policy on that new updated
set i would say that the current task is
a but the handler went back to be
because it didn't call the scheduler so
you would be in task be running but if
you would check what the scheduler would
have said it would have said a so that's
that's exactly the case right but if the
vote forgets to remove skin from me
either so that's okay so that's an
interesting point so this means that we
rely on the OS every OS api function to
disable scheduler and reenable scheduler
are wrapping around every API function
and this is this is something then that
when we do refinement we have to show
that every OS function indeed verify
that so in in the code a that I haven't
showed I said every API function looks
like this and looks like this means it
start by switching off scheduler then it
updates your are and then it renewable
scheduling if i do the refinement i can
show that this if some APR function
don't do that then the refinement will
not hold over the property would hold
does it make sense yeah
okay so how we proved it we use the
composition a little Emma as I said so
we have a bench of helpful Emma that we
prove separately as I said there are
about nine of them and just to give you
a flavor one of them for instance which
talked about the stack and say that when
i look at the stack the bottom of the
stack is always a user so these are the
kind of typical data structure in violet
you need but that you don't want to add
all the assertions for that into the
assertions really need about your big
environment for the scheduling so that's
why it's nice to be able to prove them
separately but then for all of them will
end up with this kind of lemma so either
proving the scheduler environment or
proving one of the helper environments
and that's where really the proof work
starts okay so you have them close
everything you have all your lemmas how
you prove that so this is the moment we
say oh that's a week increase work or
not so you run the VCG and this indeed
creates a quite large number of sub
goals and then we define a kind of
custom tactic that uses the simplifier
but adds a few specific lemmas that be
able to discharge the one basically the
one that are contradictory quite
trivially and your back down quickly to
30 goals which I don't want that you
really want to look at because these are
the ones where the interesting things
are and typically you would as remember
you have to put annotations for this to
go through right so typically then you
go back into a loop and you add
annotations that allow you to prove
those remaining sub goals and what we
actually do instead of proving in there
manually is that we add more things to
the tactic so that then the proof is
always in one step so in the end that's
what happened right you you do a few
iterations and then you end up putting
more in your tactic and then you have
zero sub goals where is the issue is
timing it takes about 90 second just to
generate the sub goals and then it takes
about an hour to wait for each
simplifier to just discharge all of them
easy just a little slow
um so I'll come back to that so it's
it's mainly the scale of it like 200
lines like a lot of the week egrets even
with the formalization in Isabel have
about 23 programs or even the parametric
program in another program parallel and
some of this one of them would have like
three lines or something like that okay
when you have to think we're at anything
going on there yes exactly so you just
generating all that yes it's quite slow
so we got a pretty engineering on border
great proof ensuring that is gonna join
that there's going to join soon for an
internship here that knows very well
Isabel internals and I know how to tweak
things and so he did three things the
first of all is deduplication so a lot
of those sub goals are actually quite
identical just because the either the
assertions is similar or the the the
instruction that is maybe modifying them
violating them is is identical as well
so you have a lot of duplication in sub
goals so the only thing he did is just
depleting that and not after generation
after generation could be done as well
but then you you don't target the
problem of the 90 seconds so actually
inside Isabel he just remember what the
proof has been the propagation generated
and he doesn't regenerate it if it's
similar okay so that's done two thousand
but he also noticed that somehow there
is some redundant computation for same
sub goals so vo week agrees vcg the
default one for the same sub-goal we try
the same tactic or same method
computation a few times and so he did
some memorization technique to be able
to remember what worked last time in the
same sub goal and just reapplied instead
of regenerating or we putting the
simplify on it and this went down to
about five seconds for generating which
is much more reasonable for proving and
but this only went down 25 to 30 minutes
to to generate those sub goals and and
each time I remember right it's an
interactive proof you're not into like
pressing a button waiting for the answer
and yeah does your peril wine language
does it have procedure calls no so we
don't have that and that's actually a
current working project where we are
adding this kind of framework of
parallel composition weight statement at
the formal c language i was talking
about so be able to have all the sea
feature a kind of language that is used
for a CEO for but with probable
composition but at this stage we don't
have that stupid um and so the last
thing that that Dan did was to have so
in Isabel when you prove a lamer you
have a way to sorry it so two dishes
assume it as an axiom and this is really
useful when you do a proof and you need
a helper lemma so you define your head
paloma you saw it and you continue and
this is really proof engineering
technique like because we handling like
either large proof of proof that takes a
long time we need this kind of technique
so insane SEL for we have a lot of this
kind of research on proof engineering
because we are in a typical case of
using Isabel we're going from that stage
when you change the proof and just going
back to where you were before might take
30 minutes and you don't want to do that
right so in this case is another example
of that but just inside the same lemma
and so he would do the same technique
but that's subgoal level so typically if
you have proved all the I don't know 900
previous sub goals and you just want to
change one assertion that is only for
one sub God you don't want to have to
execute the whole tactic again so it
does some proof skipping for all of that
it is unsafe like all the solid proof
but basically you switch it off once
you've done all your sessions you done
with your proof so once you've done all
the interaction you switch that off and
check that it runs properly and yeah and
so this goes down 25 to 30 seconds in
the worst case which makes now this
practical alright so running a bit later
that's more or less what I wanted to
talk about so we have modeled something
that is at the high level the behavior
of the
scheduler freed Kronos with a lot of
things that are quite generic that could
be applied with different policy or a
different platform or different OS even
and then we have one sensation of a
proof at this level the next steps are
in a few direction so as I said down to
code is obviously the first one like how
do you make sure that this is actually
what the scheduler is really doing when
we have the implementation of the
scheduler then how do we link to more
detailed API so we had an initial more
detailed API so here acronis API is just
described is in whether or not it
changes the runnable but then you might
want to do much more detailed API for
application code to be verified so what
does it mean to provide the user with
semaphore API function what does this
provide if you want to do a proof about
it then as I said we have some
assumptions on what the application code
made you or the handler may do so we
could check that statically on a
specific instantiation and the
application to code verification that's
what I i just mentioned if you want to
verify specific application on top of
acronis you would need that as a as a
foundation all right that went a bit
over what I was expecting but with a lot
of questions so yeah thank you more
questions yes why do you call your
organization data 61 umm Danah 61 is
emerged between nicta and one part of
csr oh that is a big research in science
science institute in australia the
common point between the two was
something related to data and 61 people
sir should check another like it's a
prime number no it's the area code for
the phone for Australian
Hector that it cites a prime exactl
number it's a hexagonal number yeah how
was it hexagonal it's a center yeah that
doesn't mathematical definition of it
yeah count the vertices in like the
train going that first this right nobody
corsica ex-cons well almost finished
centered so take the number of vertices
in concentric hexagons not overlapping
with the points then you get 1 times 1
plus 6 times a triangle number and 61 is
one of those whoa so one of their easily
creates a lot of discussions and this is
who sue for what you know what this is
gonna vote yeah Australian sounds like
Golden Gate Bridge it's Australia's yeah
some apples to its supposed to represent
a marble Australia mr. Smee Nia being
the dot yeah I see it oh yes it looks
like yeah doesn't get Francisco yes
thank you if you compare thee of course
you're just starting this now but if you
compare it in an effort to I mean effort
or another source lines maybe or a few
the scale change comparing it to Jesse L
40 is it say anymore well more much much
much lower sorry um so I CL for has been
going on okay if I if I stop if I stop a
sale for when we had only done see to
abstract it had been going on for four
and a half years with the team going
from seven to 12 people this has been
going on for a year and a half two years
including a lot of initial just figure
out what how to model things concurrency
baba and it involves mainly three people
so myself Cara Morgan who is a
concurrency professor and
curried Louise which is our proof
engineer that is both proof engineer and
involved a lot in the OS implementation
and then during the end now we have Dan
coming up on board and Christine Oh as
well but it's much much lower scale at
the moment yeah so but it's also less
assurance on the moment ready Saudi ever
since forgot how this would generalize
to other concurrent settings it seemed
like some of the model that's very
specific to especially hard we regress
so um so I think so we have for instance
another starting project about how to
extend the revocation that has been done
for sell for on a multi-core setting so
in this case concurrency would be fully
concurrent but kind of the general ideas
of how to be able to model a controlled
concurrency setting because for instance
in D the multi-core setting over CL for
it still so the OS people have been
working on showing that a big lock
around the colonel as opposed to single
fine grain locks inside the colonel has
not so much overhead because you spend
very little time in the kernel again
it's very fast and stuff and so this
means that you could have a lot of the
sequential proof that we had done that
could be ported still not exactly the
same kernel we have some complication
because of multi-core because the user
still runs concurrently so in that
setting you I mean the general ideas and
framework obviously a lot of the you
know return from interrupt and stuff
like that are very specific if you just
look at a single core whizzing drops I
think there's quite a bit of things that
could be reused but just tweaked like in
the way that if your return from
interrupt is slightly different or if
you have a different kind of policy or
if you're like the because it's quite
high level at the moment you're the way
you handle
function so I said that always functions
actually start by disabling in trouble
some of them very limited said don't
because they don't change the scheduling
behavior but that would have to be
checked so for instance when you do
refinement you would say oh I'm an EPF
ocean that doesn't disable interrupt but
on the other hand the refinement shows
that I'm not touching your are so that
would be fine yeah so when we showed it
so II Chronos has actually a very large
number of violence so we're just looking
at one vine and when we showed it to the
the main developers and inventor of
acronis that the company we're working
with breakaway they could see like all
kind of adaptations to the other
variants in our but if we tweak here if
we tweak there then we could apply to
another variance so yeah yes so it's
different version of boyfriend yeah you
think the you agree could apply to
application level or the concurrency or
it will it explode the ones so
application code multi clever rya excuse
the monocle so um so if we were to
choose to prove application code on a
single core like here but multi-threaded
what would be a little bit better is
that you would then usually manage the
sharing of data with locks and so an
adaptation would be more like rely
guarantee which is another like kind of
a success of a week agrees but that is
compositional we'd probably better at
application level because then you
actually own the data before changing it
whereas here the variables are just
changed without locking them and so
that's why you have you need a bit more
fine-grain things and it's very hard to
express this in real i guarantee you
could of course do it like real i
guarantee just comes down to wiki grease
but then you rely might just look like
if i'm at this program counter than this
is true if I mean this program content
is history so at the application level I
think this the general idea of the same
approach would work and actually that's
one of the things we would like to do
like application level what you want to
do is also having an idea of this is my
main environment
and it relies on the fact that i'm using
a semaphore or a lock to have a critical
section and so i would use the fact that
Oh Kronos provides me with a guarantee
that you know you have mutual exclusion
between insider a new tax but then to
show your main environment I think
something like real I guarantee would be
better yeah what cool</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>