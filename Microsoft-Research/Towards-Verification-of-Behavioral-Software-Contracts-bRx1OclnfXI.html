<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Towards Verification of Behavioral Software Contracts | Coder Coacher - Coaching Coders</title><meta content="Towards Verification of Behavioral Software Contracts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Towards Verification of Behavioral Software Contracts</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bRx1OclnfXI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay well then really happy to have
David Van Horn visit us today from
Northeastern David's been doing some
great work on adding contracts to racket
and verifying the behavior of these
contracts and he's going to tell us
about some of this today right Thanks
yeah so thanks for having me i will say
so that there are many reasons why it's
nice to be here about one of them is
that um my my mother has a software
company in Texas and she does records
management work so she's been a long I
mean she's been doing sequel server work
and stuff like that for like 20 years
and you know if I tell her I'm going to
give a pld I talk she's like oh that's
nice but then when I said I'm going to
Microsoft she was took a step back and
thought I was somebody special so so
thanks for that ok so I'm going to talk
about this work on trying to verify
behavioral software contracts its joint
work with Sam Tobin hawks tat at
Northeastern yeah I think so yeah this
is why you should not be friends with
your colleagues on facebook but uh
anyway so I'm just back from this DARPA
p I meeting in San Diego and the project
that we're working on has this this
thesis statement which is that language
mechanisms that capture design knowledge
can be leveraged to qualitatively
improve reasoning about programs and I
think that that's a thesis that's really
been supported by the work here and in
the with the rise group and so I'm
really happy to be here talking about
this because I think we have sort of
similar goals so I'm going to talk about
this thesis in the context of a
particular language mechanism which is
contracts and in a particular sort of
automated reasoning which is
verification so contracts give you away
of writing down specifications as part
of your program in the programming
language that you're programming in and
I want to be able to to verify those
things okay so the goal here is to have
some sort of automated modular
verification of higher-order programs
with contracts and right I know that
there's been a there's been a lot of
successful work here on verification of
programs with contracts of a slightly
different sort so I'm hoping I can tell
you a little bit about the sort of
higher-order bit here okay so I want to
start by telling this story and a
simplified setting where I'm not going
to talk about contracts but I'm going to
talk about types okay and then we'll
ramp it up to two contracts and I know
Francesco's seen this a lot of this talk
at uppsala so I've tried to add some
more details so that at least he gets
something out of it what's that Romans
used to say it every day you would
relate to the caves yeah yeah worry okay
so so I'm going to try to get across the
essential ideas here using the
simplified model of Plotkin's PCF
language and i'll talk about PCF not
because i actually care about PCF but
just because I can boil everything down
to to its essence here okay so let me
just give you some examples so you get
your footing with this language so
here's here is a a program up at the top
and I've just Illustrated the steps that
it takes to compute an answer so this is
integer division 10 / this conditional
expression so we're branching on whether
7 is 0 or not of course it's not so
we're going to pick three here and we
get 10 / three just three okay okay so
the point here is that we've got some
basic operations conditionals let's look
at another example
so here you'll notice that the thing
that ends up in the denominator position
is zero and so the point here is that
we've got errors in our language as well
so you can divide by 0 and get an error
here all right we also have functions in
this language so here is the 10 / x
function and it's being applied to
what's eventually going to be 3 so we
plug this in for X and get 10 / 3 again
and dr. Barry all right and not only do
we have functions / numbers but we also
have functions / functions so here is
the apply to three function it's taking
in as its argument the 10 / x function
and so we eventually get down to three
here all right okay so the way that I'm
going to approach this verification
problem is by doing a sort of symbolic
execution and the way that I'm going to
do it is by extending PCF to do symbolic
execution so i'm going to call this
language symbolic PCF or abbreviated as
the symbol PCF okay so here's the idea
with this this program this symbolic PCF
language so I want to be able to take a
PCF program and rip open and pull out a
piece of it okay so here's the apply to
three function and I want to be able to
abstract it to some symbolic thing and
so while I'm telling you this simplified
story with types the thing that I'm
going to abstract it to our types okay
so so this is a symbolic value in this
language it's really it's sort of a
black hole so it's an unknown value but
it what we do know is this specification
which is its type okay so it's a thing
that takes a natural to natural function
and it's going to produce a natural okay
and I want to be able to plug that back
in to my PCF program seal it up and now
i have a symbolic PCF program and i want
to be able to run that okay and as I'm
thinking about
the design of the semantics I wanted I'm
going to have this design principle in
mind which is sort of what is what are
the sets of programs that we're talking
about in this symbolic one okay so so if
we think about that symbolic thing I
want to what I'm really talking about is
all possible concretization zuv this so
I could I could have picked any value
that could be abstracted to that and
plug it in and now I'm back to just a
regular old PCF program and I want to be
able to run that and I want the
semantics to be sound in the following
sense that all of the concretization
czar approximated by my symbolic PCF
semantics ok all right so let's look at
something some examples here so this is
just the example we saw before and now
let's start abstracting parts of it so
what if I abstract the the numerator
here so I'm doing a some number / 3 here
all right so you just stare at this for
a minute and you figure out well it's
got to be it's some number over 3 that's
just some natural number all right so
the rule here is that we extend our
interpretation of primitive operations
to say that some symbolic natural number
over some number that's not 0 that just
gives you back a symbolic natural number
ok selected notation so you do writing
this transitions s relations and your
Delta is that
the transition relation yeah exactly and
I ask you've added an element to the
death of transition right so we're yeah
we're just doing reduction semantics and
this is our relation for interpreting
these things and I've written the
relation that relates these two things
here ok all right so here I've abstract
it in a different place namely the thing
that we branch on here ok so I'm doing
10 / well if this is 0 to an otherwise 3
but of course this represents all
possible natural numbers so it could
either be 0 or not 0 all right but
that's easy to model as well you just
take both right you come to a fork in
the road and you take it so here we get
10 / 2 and five on one branch and 10 /
33 on the other branch ok so the
relation here is just as straightforward
right if you're branching on a symbolic
natural number you take both branches ok
ok here's another example where I've
abstracted the thing that ends up in the
yep
enough to be praised it at all they are
side effects free yes of this language
so the language does have side effects
and that there are errors but ok so
let's think so this could be abstracting
an expression that causes an error and
so the way that I that I think about it
is if if this is some expression that
causes an error that's really that
expressions fault right it's not this
larger pro it's not the program I know
about that's at fault for that error so
I'm only going to be concerned with
errors that blame the thing I know about
I can I can make that a little more
precise later but that yeah but errors
are really the important thing that
we're going to be concerned about and in
these examples okay so yeah yeah so I so
one way to think about it is that these
these abstract values and so the value
there's no error for values of type not
only computations okay if the system
doesn't get cleared up let me know
because it's important yeah okay so this
is the thing that ends up in the
denominator position and so now we're
doing ten over some natural number and
so of course we could be we could get a
divide by zero error we could get some
natural number here okay and so the
point here is that there is an error
that's really the fault of this program
right and I don't care about the errors
of the things I don't know about I care
about the errors of the program I know
about and there is one here okay but the
relations simple so some number over a
symbolic natural number you either get
some natural number or a divide by zero
error here
okay so here's really the sort of first
interesting example right which is that
we've abstracted a function here okay so
i'm applying a function that takes
naturals and produces naturals and i'm
giving it the number seven okay so i
don't know what this function does but I
know that if it's given a natural number
it produces the natural number so it's
sort of obvious what this should reduce
to which is just a natural number right
it should just reduce to the the range
of this function here so the relation
here is is similarly straightforward
where if we're applying a symbolic
function that takes some inputs and it's
applied to some set of some values here
some arguments well then we just get
back a symbolic result that is
corresponds to the range of the function
ok and here you should think of you know
thinking about errors right it could be
that this function causes an error when
given seven but that would be that
functions fault ok it's not 7s fault and
I'll talk more about fault and who's to
blame later so you also have no
nomination is in effect so we don't we
don't really consider a non termination
so if this if this program doesn't
terminate that's fine I mean we're going
to give an answer that corresponds to
what happens if it did terminate yeah
yeah there's a precondition you have
because you should go
so if she's violated the 40s of the
color not yeah so so current house so in
this simplified setting there's no
there's no preconditions but we'll get
there in the type right so but that all
of those all of ya exactly so so we
assume everything is typed and so all of
those so if I had applied this to the
stream Fred right yeah yeah so the only
the only error that we have right now is
divided by zero and that we're going to
scale that up later ok ok so i can write
down this semantics this is in the red X
language that comes with rackets so
we've got this little domain-specific
language for writing down reduction
semantics and there's a problem so it's
it's nice it fits on the slide of course
the problem here is that it's unsound ok
so let me show you how it's unsound so
here here's another example where the
thing that I've obstructed is is a
higher-order function ok and this is
really the problematic case because the
rule that I showed you earlier just says
that if I apply a symbolic function to
some input than what I get back is the
symbolic value corresponding to the
range here so this is what it says I
should get here ok and right that's fine
so if we think about how to concretize
this right that's fine if we pick
something like the apply to three
function or the but if we pick the apply
to zero function things go wrong right
because here is here is just a
straightforward tcf program where I've
plugged in this thing for this unknown
component up here and what i get is
going to be 10 / 0 and i get some air
and you'll notice that that's not that's
not represented up here and also you
know who's to blame
for this error is really the program
that I knew about in the first place
right because I'm passing this 10 / x
function often to some unknown context
with the specification that it takes you
know that that this this function takes
natural numbers and gives you back
natural numbers but there are natural
numbers for which it causes an error
right so it's really this thing hasn't
lived up to its specification here all
right and the semantics didn't account
for it so first I'm going to revise the
semantics to to find this this kind of
error and then and then yeah if i have a
contract language then i can put
preconditions on this sort of thing and
avoid this error as well right so right
so getting back to the thesis of that
project right if we if we give
programmers the ability to write down
richer or specifications then we can do
a better job reasoning about it because
what if types are our specification
language here we're just stuck with that
this might this might divide by zero
okay at least amazing know types being
specification
yeah you can vary decidable yeah right
yeah so it's both it's it's more
difficult to reason about but you can
also do other you know more powerful
kinds of reasoning okay all right so
thinking about this example what I
really want to sort of focus on is what
happens to this function as it goes off
into this this black hole here okay so
at this call site you know this function
is really being sucked into this this
black hole here and what can happen now
that we're in this sort of unknown land
with this function and really so what
can happen here is anything so long as
you know we can do anything with this
function so long as we play by the rules
of the language and for now that means
playing by the rules of the type system
so you could apply this function to
seven or you could apply it to a tour
625 but if you apply 20 that's the
problematic input that's going to give
the the error here okay so it's obvious
from looking at this function that zero
is the input that you sort of looking
for to make this cause an error but of
course in general you want to consider
all possible natural numbers here all
right and it would take a while to
iterate through all of them but we have
a way of applying this function to all
of the natural numbers all at once which
is just apply it to the symbolic natural
number okay so in order to account for
this stuff that happens in these unknown
contexts where the only thing that we're
concerned about our what what are the
possible errors that could occur we
extend the semantics with with this
havoc relation okay and that the choice
of names here is is not accidental this
is sort of inspired by the havoc
function from Boogie where which is all
about sort of putting things in an
arbitrary heap context right in a
first-order language and here we're
talking about behavioral things where
it's all about put
these behavioral objects and in
arbitrary context that can explore the
behavior okay so when you apply a
symbolic function to some inputs we just
pick out the type corresponding to to
each input and I know and what havoc is
going to do is basically do everything
it can to this value at this type okay
and in particular so at this type the
thing that you can do with this function
is apply it to a symbolic natural number
okay so emerging from this now that we
have so we've extended the semantics
with this havoc relationship and so
every time that you supply a symbolic
function there's sort of two paths one
is the good path which is we just get
the the range right and there's which is
sort of the no errors occur when this
thing when this thing goes off to the
unknown context and the other path is
let's try to find all of the errors in
the in the not to not to not context
okay and it finds the divide by zero
because we applied it to an arbitrary
natural number and our semantics already
says that 10 over some natural numbers
an error okay so now we're back into a
you know a sound semantics and it only
got slightly larger we had to add this
we added this rule here okay
alright so we now have this soundness
property that says all of the
concretization zar approximated by
symbolic PCF semantics and it's got this
nice sort of verification condition it
implies which is that if your error free
and the symbolic semantics then for
anything that you can plug in your air
free for the original PCF semantics ok
so in other words you can verify the
program that you know about and you
could plug something in that has an
error in it but that it would be that
components fault all right yeah crisco I
didn't see how that was captured in
yours the statement of verification it
if you do plug in some value ok that you
can't have an error but that the blade
is on the imageable yeah so so really I
need to talk about contracts to get the
blame part the nailed down in detail I'm
sure that the details of the the blame
and the typesetting could be worked out
but they're definitely worked out for
the contract stuff yeah sure or
decomposition so difficult realization I
was expecting
so you're saying a little competition
approximated by PCF but this service
until you are not missing any PCF
problem you're not missing with lot
easier that's what you are saying yeah
okay yeah okay so that's so basically
the other way around okay yeah if you
start it if you started with a PCF
program and pulled out parts of it and
ran it you would have approximated the
original long enough yeah actually this
is missing no no no Christine is a
dieppa go be the tool you have a best
approximation for each PCF program I
don't know different things okay let's
reach let me state the priorities which
is the order your domains how you're the
problem so Sasha in in a minute yeah oh
I'll show you some of the details yeah
this would be respect to some water so
okay which is this yeah okay yeah so
just hold on to that programs
you'll essentially say this what PCF
pre-op is approximated but approximate
only sets yeah right now here on the
concrete you can take just sets we have
deputy said and all the possible
programs menu yeah this is Europe
essentially how you do your grammar now
I think idea for what is the order in
the abstract where you said it one
program proximate more and does not
seems the T of something you should not
ever let to structure I guess she
doesn't matter oh they're here because
know yourself wash I'll show you the
order okay alright so now let me let me
try to sort of redo this with a language
with behavioral contracts in it so we're
going to look at contract PCF which I'll
call CP CF and the language is extended
in the following way so to our set of
terms we've got two new forms so one is
a monitoring form which says that we've
got some contract here and we're going
to monitor monitor this expression with
that specification and if this
expression doesn't live up to its
contract then we blame okay and in this
simplified setting I'm going to not tell
you about how the blame is assigned but
i'll actually show that in this talk so
so what we'll get there but for now you
sort of don't need to worry about it
okay and now the language of contracts
is well it includes just arbitrary
expressions which encode predicates so
we can write down a predicate and say
that this expression must satisfy the
predicate and that's sort of the Eiffel
style contract system and then to extend
this to higher-order contracts because
there's no predicate that we can write
down for a higher order thing and hope
to be able to apply it and check it at
runtime we have a constructor for four
functions okay so this is a function
that takes inputs satisfying these
contracts and produces some output
satisfying this contract okay so you
build you build up contracts
higher-order contracts out of these
predicates okay so so here's a simple
example I want to check that seven is
positive so the way that you do the
check is you just apply the predicate if
the predicate holds you get the value
back otherwise you could blame okay so
we get seven here if you check that zero
is positive while you're going to get
blame here okay and now the crucial
thing is how you do the the higher order
monitoring higher order things so here
I've got some function where I've
omitted the body here and I want to I
wanted to have the specification that it
takes inputs that are prime and produces
in outputs that are even okay and I
can't just check that against this
function at this point in the program
alright so the way so the sort of
similar and flies and insight here is
that the thing that you do is you
produce a new function ok so you delay
the checks and produce a new function
that when it's applied is going to check
that its input was prime then it's going
to apply the original function that we
that we had here and after which it's
going to check that the result is even
so you've got these higher-order things
that you need to enforce and the way
that you enforce them is that you drive
them down to a lower level and delay
them okay so this is how contracts work
in and racket for example ok and now I'm
just going to sort of replay the same
story with the symbolic semantics for
the contract PCF language and this it's
the same idea where I want to be able to
rip out pieces of the program and
abstract them but not just to their type
but also to their type and some set of
contracts okay
transformation just said works out even
for higher-order functions yep
yep right yeah so so when you've got a
contract violation I mean when a
contract fails it's always sort of at
first order right it's yeah yeah and
then there so the the real contribution
of the thinner and fly ssin work was you
know how do you and how do you enforce
these which is the driving down and also
how do you account for who's to blame
because that gets more complicated yeah
okay so yeah so here I've just attached
some contract to this symbolic thing so
the symbolic values are our sets of
contracts or a type in a set of
contracts suppose this is driving
contracts down to the river it works it
depends on your contract language right
I mean if you're trying to stake
equivalences between functions and so on
this doesn't work yeah so there's some
there's yeah there's some question about
like what does it mean to be correct
with respect to some contract because
like let's say I have a program that I
say takes even numbers and produces odd
numbers but I never call it right so it
could be the function that always
returns for and if I said it always
produces a prime number well there's no
it never breaks because we never got
there so by delaying those checks you
can write you'll never get there if you
don't actually force that thing to
happen check yeah I mean it so it's a
runtime check yeah
production suppose yeah getting it down
right its clue you know you think of it
you're thinking of it is static check
right and but I'm going the the property
I'm and I'm going to sort of verify as
the runtime part of it so if I say that
if I verify that that this thing
satisfies this contract in my program
what I mean is that at runtime it never
produces something that's that's not
prime I know that unless you actually
you might not know that actually because
it might get delayed yeah but I so
that's true but I think our approach to
verifying these things is just to
actually run them but in this in this
sort of symbolic semantics is acceptance
the team is just approximating is this
complete semantics instead of the PCF
problems or the possible once invented
runs for other possible secessionist
right when any wants to prove this
safety say okay today I'm trapped when I
abstract my my time shall we do see what
it values such as plain as to
intimidation if I can prove it then by
sundas result I know there is no wrong
problem area if your mother is if you
can prove if in your private the
negatives is usually a completeness
somewhere and opposition okay so I've
been progress rotating question so what
about can you express that the function
is monotonic for instance or you want to
emphasize respond this is my point is
one that this might suit so my point is
it if you are interested in checking
safety properties then you can do this
by pushing the car tracks down learning
based model but if you want to check
properties the things like have to have
a program that is lambda F lambda G yeah
and I want my contract says I want F to
be extensively equivalent to G yeah or I
want F to be monotonic then these are
not properties of a single execution of
a program right and then you can't just
push the things down yeah so that's a
that's just something that the contract
language is not going to let you express
now you can express so I've shown just a
really simple contract language here and
I'll show some more of the bells and
whistles of what are actually in the
contract language so you can express
dependency so you can say I take F and G
and X and the result is that f of X is
equal to G of X and that will check it
for any particular X that you give it
but not for all X so you can express
things like that but yeah you can't
express properties that that can't be
enforced you know other than running the
program and checking those things yeah
you still have been completeness let's
go instead of a nice so somehow a
semi-competent somewhere so they are
things you
well as incompleteness is come up way
earlier yes it is is there's a kind of
incompleteness just in the contract
language right forgetting about static
analysis or anything you just can't you
can't write down the contract that
expresses those sorts of things like
that functions monotonic limitations
yeah yeah of course sure yeah okay so
here's here's a simple example right
where I'm checking that some natural
number is positive okay and so of course
you can get blame or it could be that it
was positive but there's there's an
important thing going on here so when we
check this this predicate against the
symbolic thing you'll notice that the
way that it reduces is we check the
predicate I mean we apply the predicate
but then in the case that it holds we've
added that predicate to the set of
contracts that this symbolic value
satisfies okay so when you get down to
the end here if that predicate holds
we've learned something about the thing
we were talking about here okay so the
the symbolic values remember the
contracts that they've satisfied all
right and then that's going to be
important sort of downstream where you
may check this again and if you remember
that this is a positive natural number
then of course you just get back a
positive natural number and there's no
blame here and there's nothing goes
wrong okay so the contracts influence
the computation and that's also true
here when we think about our primitive
operations so 10 / a positive natural
number we just extend this relation to
say that if you're doing 10 over
something that is positive that you're
just going to get back a natural number
here and not a possible / 0 so here I'm
saying yeah so that's sort of a short
coming of the relation that I wrote down
here I'm sure you could you could add
that to the relation I just didn't yeah
semester domain with your lab whatever
weight with types now you are refining
your
domain by ending essentially those
contracts right now as a matter of fact
your civic analysis gets more precise
because now you know that when it's both
so you cannot be 0 right so you get to
know precise so my question is that can
you get the constructively by just
taking a ticket to the abstract domains
to one of types and the one with boss
other things you know there are standard
ways nice with the potential for
creating a more precise domain so this
looks a lot as a reduced product maybe I
really don't know about that yeah yeah
you mean these basic blocks
automatically okay yeah I be this funny
so that's that's why you can get this
shot because its engine are getting more
precise analysis a precise reason yeah
you refine your domain good yeah
yeah I suspect that that might be the
case but I I don't know yeah okay and so
here's that here's that a higher-order
example that we saw earlier except the
difference is that I've attached a
contract to the to the 10 / x function
which says that it's got to be given a
positive number ok and now ok so the
first thing that happens is that we
drive down the contracts and now this
function goes off to this unknown
context and what happens here is
remember havoc gets to do whatever it
wants with that value but it always has
to play by the rules of the language
which in this case means that it's gotta
respect the contract so it takes this
function which we know consumes positive
numbers and it's going to apply it to a
positive natural number in which case
there's no error here right so the
important thing is what's not on the
slide which is there's no error and we
always get a natural number and so we
can verify that the 10 / positive x
function is can't be blamed all right
and that's the kind of the kind of thing
that we want to we want to verify in
this work all right and we have the same
soundness and and verification property
here and but now when we talk about
error free
symbolic see PCF programs right we're
not just talking about / 0 errors we're
talking about blame which is all about
arbitrary properties that that a
programmer wrote down okay so it's a
much richer sense of being error-free
here okay oops so now let me show you a
little bit more about the the details
okay so here's our semantics for the
symbolic PCF and it's basically just the
stuff that I've I've shown you before
we've got this Delta operation for
interpreting our primitives so the way
we do conditionals is we asked if fault
if the false predicate holds on the
value and if if false is in there we
take this branch so right and the
important thing is that this predicate
on an arbitrary boolean gives you back
both true and false in which case you'll
take both branches here the Delta is
also used here so this will include
things like if you if you add one to
some actual natural number you get n
plus 1 but if you add 1 to some unknown
natural number you just get back a
natural number so this so here's our
function application with a symbolic
function one thing i should say is we we
really do have dependent function
contracts here so this is saying this
we've got a function that takes an input
satisfying c1 and we produce something
that satisfies c2 with X being replaced
by the actual input here so this is how
you can express something like I always
I always you know I take in some natural
number and I give you back that number
squared something like that so we can
express that and what this is saying is
that we've got a set of contracts
attached to this function and what you
get back is some unknown thing that is
line by the set of range contracts here
with the input replacing the ex society
express this in yo concrete syntax tree
you had contracts that were here m4c
roc-roc I didn't see any binders there
yeah so I just didn't show that you but
yeah so so the real way that you would
express it is the the right hand side of
the arrow is a function a function to
contracts yeah yeah so yeah it's it's
you cannot you cannot terminate yeah so
we handle recursion just the easiest one
anymore I mean let's see so you could
just write that I mean the simplest
example is just so you so you so we have
a recursive binding so you can you can
say let X be X that's the simplest
nonterminating program in your contracts
of yours so your contracts yeah your
contracts can diverge and then there's
also the really interesting question of
what happens when there's an error in
your contract and for what I'm going to
show you that sort of swept under the
rug but there are there's work on
accounting for that and who's to blame
when a contract itself fails and all we
have to do is take that semantics and
write it down so we can handle that
straightforwardly okay and what else to
look at here okay and then here's here's
our havoc function and so it's indexed
by the type and all we do for base types
is just say that this doesn't produce
anything okay and but for function types
what we what we produce is the thing
that takes in this value and then
applies it to an unknown thing
corresponding to its input type and then
we run havoc at the output type on the
result of that okay so that's our that's
our havoc construction here okay let's
look at how contracts are monitored and
this will give you some more details
about how the blame stuff works okay so
monitor is the little monitor form that
I had in the concrete syntax earlier and
it's got these these labels on it okay
and and we've got this way of sort of
tracking tracking the blame and you'll
see it when we check so flat is a
predicate here so when we check a
predicate and if it fails we're going to
blame F and the way to interpret this is
that F broke the contract with g and the
H here is really about sort of the
origin of where these things came from
it's it's not very important but um and
really the important thing here is that
as far as the blame calculus goes is
that when you are checking when you're
monitoring a function the positions swap
ok so it's contravariant for functions
ok so the who's to blame switches as you
do a higher-order monitor ok what else
to look at ok so you'll notice here that
I've got this judgment that says that V
the way to read this is that V we can
prove that V satisfies see ok so we're
really parameterised by sum theorem
prover here and i should really say
theorem prover in quotes because so for
the simple system this is this is what
our theorem prover consists of is if a
value remember some set of contracts and
the contract that you're trying to prove
is in that set then you say it proved it
ok but this is I think a big opportunity
for so this is we're trying to monitor
some Val
you with a contract but if you can just
prove it then you can eliminate the the
monitor here so the way that we
eliminated is by remembering that you've
already satisfied it but you could plug
in a much more sophisticated theorem
prover here and everything would get
better okay right so here's the
remembering so we check a predicate and
we remember the Conte the predicate that
we were checking here okay right and
these other rules just have this side
condition that you weren't able to prove
it so you actually have to enforce it
okay so here's the soundness which says
that if if irri find Z Prime and II
reduces to some answer then there exists
some some other answer that that a
refines such that your your abstraction
gets there okay so i have to tell you a
little about this part and so the basic
things that this refinement judgment are
just that any a value of some type
refines an unknown value at that type
okay so contracts can refine values so
you can sort of arbitrarily add
contracts on the left here and if you
want to check some expression so that
the the monitors are the checks can
refine expressions here and say that we
can get some unknown thing that we know
satisfies this because we're going to
check it yeah and there are and there
are a few more things but not really
important here but that's sort of the
basics of the disordering here
ok so now let me tell you about how we
scale this up to a more realistic
language so symbolic racket so rackets a
list list dialect that's in development
at Northeastern and in other places so
we've got a rich a rich language a rich
language of contracts and we've
developed an interactive verification
environment so when I say a rich
language what I mean is that we've got
you know a real module system it's an
untyped language so which just makes the
problem harder we've got real data
structures lots of base types lots of
primitive operations the contract
language well we've got the blame that I
I sketched for you the dependent
functions we've got data structure
contracts you can do conjunction and
disjunction of contracts and you can
write recursive contracts and I'll tell
you I'll give you some of the details
there okay and the reason why we scale
this up is going back to the sort of
thesis of the of this project is that
you know this is a really rich
specification language and the idea is
that we should be able to reason better
about programs by having all of these
things so it was important for us to be
able to to really scale it up to a full
contract language what did we do for
negation so uh I think I think that we
handled the gate i can't remember
actually right now i I can't remember if
there's anything hard about negation or
not I I'd have to look yeah I don't I I
think I think I I think it's easy enough
that I thought it wasn't even worth
putting on the side but i can't i can't
recall so here's an example where we're
defining a contract for a list of
natural numbers okay so it's a recursive
contract which says that it's either
empty so it either satisfies the empty
predicate or it's a pair constructed out
of the the not predicate and a list
right this is the recursive thing here
all right and now we've got a module
here that's providing two things insert
and numbs and you'll notice there's no
definitions in this module so this is
how this the symbolic things get
introduced because insert and numbs are
going to be treated symbolically and
insert is a function that takes a
natural number and a sorted list and it
produces a sorted list okay and numbs is
just some arbitrary list of natural
numbers now the module that we're sort
of were interested in verifying is an
insertion sort module so it requires
this stuff which we don't have
definitions for so they get treated
symbolically it defines a fold sort of
usual fold left higher-order function
here which folds this function over a
list and some base value okay and then
so the way that you write insertion sort
is you just fold insert over the list
and the empty list as your base value
and we provide sort at this contract
which says you give me a list and i'll
give you back a sorted list okay so
we're not verifying you know some sort
of full correctness of this thing but
because it could give you back any
sorted list but but this is the kind of
contract that you might think about
writing down and then erase it because
it's going to be too expensive to
actually enforce it run time okay and so
what we can do is we can just type this
into our repple and say sort this
arbitrary list of numbers and what you
get back is a sorted list of numbers and
again what's important is what's not on
the slide all right there's no there's
no could or of empty errors there's no
applying something that's not a function
all right so there's no kind of runtime
type errors anything like that and also
we have this this added property here
that we know that the list is sorted
that we get back okay
can you harmonize your contract by
contract soup today give me a little
more faith through this contract so you
would have to so polymorphism is
difficult to enforce at runtime but
there's been work yeah so so there's
been work on it so I think one of the
one of the lessons here is that if you
could write down or reduction semantics
for the original language we think that
it's sort of straightforward to turn it
into the symbolic kind of thing so if
you can write down you know whatever
kind of runtime enforcement mechanism
you can write down so I could say define
contract just see another contract is a
durometer oh yeah it's okay so yeah so
in fact in the in the actual rocket
language contracts are just values in
the language so you can write you just
write that as a function yeah and we can
do that and you could also write down
things you could this could be a
dependent contract like one thing that
you might want to add to the
specification is that the result is
always a permutation of the input and
you could write that down our tools not
going to be up to the task of verifying
that part of the property it'll just
verify this this part and then you'd
have to leave in the runtime mechanism
for checking the permutation aspect of
it will be able to tell you there was
into verified this part of the
specification and so in some sense
because you can look at what are the
possible contract failures and so you
should be able to see that it never
fails with it being not a sorted list it
would only fail with the permutation
part okay so this is out of this oops
toilet paper and there's some more some
more details there if you're if you're
interested I want to tell you a little
bit about the verification environment
so we're able to verify programs like
this so this is a program that our
first-year students right it's the snake
game so this guy is running around on
the screen and trying to collect this
food at which point it grows and it dies
if it runs in the
any of the walls and it dies if it runs
into itself okay so it's it's an
interactive event driven game where
we're registering callback functions
here to this event loop we've it's
broken up into a bunch of modules we've
got some contracts on the things that
each of these modules provide okay and
if you wanted to verify this program the
steps that you would go through is okay
so we've got one module that's sort of
providing all of the image primitives
and it's really just requiring this
underlying library image library and
wrapping them with contracts okay so if
you wanted to and you'll notice that we
you know so we're writing this in in
racket and if you wanted to verify it
you would just change the language so
this is our verified by abstract
reduction language you comment out the
required to the the primitive library so
now this module exports a bunch of
things but doesn't define them so
they're going to be treated symbolically
and then you run it you run it and you
notice that there are no errors okay so
we can verify these contracts which are
are somewhat sophisticated right so a
position is is a pause in structure with
two non negative integers in it for
example and that a direction so we've
got these kind of ad hoc data
definitions things like the snake is a
non-empty list of positions and so on
and we can verify all of all of these
properties in this in this program right
and those those were the only changes we
had to make all right this source of you
show our seats
everything by some student or you wrote
that you very far so it's it mmm it
could have been written by some student
so the tool could I mean I think it
needs some work before it was unleashed
on on users in particular we don't give
we don't give great feedback when if so
one thing that we do a really bad job of
it like if you leave a print off or
something a parenthesis off or something
you've got some syntax error like you
get this awful awful error message okay
and you Sam and I have gotten really
good at interpreting what what went
wrong there and so I would never at this
point i wouldn't give this tool to
students to write seen texas okay yeah
how do you after you cannot post
something so how beautiful the message
I'll go pick so I should have had an
example but they're there they're
similar to the to the sort thing where
you just get at the bottom in this sort
of interaction window here you get a
list of possible results which could
include error results so you run your
thing and if you get some errors at the
bottom it'll tell you it'll tell you it
looks a lot like a contract violation in
the real rocket language so it says
trace a good time just curious are you
proposed to feedback to the user yeah so
so we have a vehicle right along good so
let's see so so one thing is so this
sort of immediate feedback is just the
list of possible results or printed down
here now another thing you can do is you
can add a keyword up here that says you
want to see the traces and at which
point it produces windows that look a
lot like my first slides with the those
diagrams and you can also do a different
tool for ticket an algebraic stepper so
you can step through the thing and watch
you know where it's splitting and and so
on so we actually have some decent tool
support for exploring the semantics here
how's this never come over three days
yeah so we're leveraging so all of those
things are we're really just leveraging
the the Redux toolkit for for our our
language here yeah
these different password are you
guarantee that it will terminate the
program terms yeah so that's a good
question so no because in particular you
could just you could write down a
program and not abstract anything and
just run it and and of course it may not
terminate so yeah so that's a good
question i think i'm going to come to
that let's see nicole how much how much
time do i have just talked about okay 12
okay all right so i think i'm going to
skip over most of the the formal details
of the of the sort of richer language
here and yeah i think you sort of get
the essence of it from the from the
example so let me just skip through this
yeah so this is really just three of us
i mean the bets on you guys okay if you
want to continue so i didn't you ok just
ya ok so then Jake we have introduced a
trick ok till 12 ok it's alright so let
me just try to then let me just try to
give you the highlights here so here's
our here's our scaled up language where
a program is really a set of modules and
some top-level expression and a module
is just you know a name a contract and a
value and this should also include that
this is an unknown value there's looks
like there's something missing here when
we've got a so module references are
sort of syntactically distinct and
they're labeled with where they occur so
this is a reference to some module
definition F and it occurs in some
module or top level called l okay we've
got lists in our language we've also got
pair contracts disjunction conjunction
and recursive contracts
these things are not so simple to handle
so so one thing that you'll get out of
this part of the talk is you know what
are the semantics of these of these
things so here's the way that programs
reduce is we've got some module context
which really just serves to resolve the
module references in our program
otherwise we've just got to just a step
relation here okay so here is our sort
of the obvious reductions okay so
function application remember we're in
an untyped setting now so you could
apply something that's not a procedure
and you get blame and here there's it's
slightly weird blame label here because
what you're saying is that this
expression broke the contract with the
language in some sense with which is a
runtime type error right because it
wasn't a procedure we have really two
judgments in this system so one is the
this value we can prove that this value
always satisfies this contract and we
also have a refuge refutes which says
that this value never satisfies this
contract and they're not just negations
of each other because you can note you
can have something that neither approves
nor refutes if it's if it's some unknown
value for example well it could be that
it satisfies a contract or it could be
that it doesn't oh okay so which you say
you never execute this contact you never
so it was the case you were staying
before you never going to evaluate this
one because it's just a super rich the
code general so what else are what was
the question okay stop surgery so I
think this
but you're doing here is that whatever
contract have some context and try to
see which is the outcome right so you
say okay either I prove it means for
every execution if you reach this point
then it proves it because I think you
gotta prioritize by no termination yeah
so these so these things are ya then you
have the one that says if we reach this
point all the times I reach this point
is force you mean suppose the team score
at x is 0 and then divided by X right
every single time it's for now then you
say I don't know yeah and then there is
a fourth case which is an average this
point can I show my dad so that's that's
handled at another level so these things
are only used when we reach a point so
so you sort of avoid making these
judgments if you never reach them yeah
yeah but yeah yeah so it's either I know
i satisfy it i know i don't satisfy it I
don't know either or I never get here
yeah okay and just to give you an
example I mean this is how like the the
the primitives are interpreted with
respect to this theorem provers so if we
know some value proves that it's a cons
a pair then then the way we interpret
the car right which is pulling out the
left component of the pair is we project
out the left component and you need this
/ you can't say that this is literally a
pair because it could be for example a
symbolic it could be a symbolic cons and
things like that so you need this sort
of projection helper meta function here
but if I know it's a cons I know I can
project out of it if I know it's not a
cons I know that it's just a blame if I
don't know either so I write it with
this ? then I I project and I blame okay
module references so there's really
three kinds of module references right
remember this is f this is a reference
to F occurring in the module labeled
here so this is a self reference and
notice that there's no check right so
we're referring to F and it's got some
contract but we don't check the contract
because you think of the contracts is
being established between module
boundaries so if you've got a self
reference you don't you don't check the
contract that's just the way that the
contract system works this is a
reference to F occurring in G so so we
take the contract on it and we check it
when you make that reference and this is
an external reference to something where
there's no that there's no definition
available so we check it against this
this abstract thing here now here's so
here's how the contracts are checked you
really need to have this distinction
between a flat contract and a
higher-order contract so a flat contract
is just a contract that I mean is like
predicate sore flat contracts there are
things that you can just check at that
at the point that you want to monitor
them okay so so if C is a flat contract
and for now okay so what's flat so a
predicate flat a pair of flat contracts
is flat a conjunction of flat contracts
is flat and so on so if it's flat and we
can prove it then you just eliminate it
and remember that you've satisfied it
yeah you just buy the previous slide
actually so the one where you at this
checking self references yeah here uh
and you would not literally check yeah
is that
oh yeah yeah that's why is that why does
that sound I mean if I have a module
that says I'm going to provide you the
positive integer and isn't the module is
f and implementation is that it's just
need to return f dot F n return 0
instead yeah so so what so what happens
is that you can I mean the way to think
about it is that internally to your own
module you don't have to you can break
your own contract and that's fine but as
soon as somebody else uses your module
there's going to be there's going to be
a contract boundary established at which
point this doesn't this isn't the case
anymore and it's going to be checked
here checked here and so you'll get when
GE called zep and tries to use as
supposedly positive integer that's
actually zero right and then you lame f
yeah so yeah yeah that's right so yeah
if F if F doesn't live up to its
contracted externally then it's going to
be blamed and internally it can do
whatever it would like right so you
could have you could you could for
example provide some function that says
you have to give me the input five and
then it recursively calls itself with
arguments that aren't five all the time
and that's fine so long as externally
you're always given five and likewise
with the with the returns and this is I
mean this is just a design choice that
comes from the way that the contracts
work in this language and you could make
a different design choice if you want it
and if you wanted to check that
contracts held within a module you would
just change this rule but there's no way
to to sort of break the the module level
contracts okay so this is when we can
prove that we can eliminate it this is
when we know that it fails so we blame
and this is when we don't know so we
have to enforce it so
so what this FC function does is it
compiles the contract into a predicate
so the way to think about a flat
contract is it can be compiled into a
predicate okay and this is the
compilation for it okay so if it's a
recursive contract you just move inside
I don't know that there's much that's
interesting here so if you have so flat
contracts are easy so if you have a
conjunction you just compile it to a
function that checks the first one and
then checks the second one all right so
this is just turning all of these things
into predicates if you've got a pair you
turn it into a function that asks if
it's a cons and if it is then it applies
the first contract to the car otherwise
that right end and then it applies the
second part of the contract to the
cutter that's the easy part here so so
the distinction between flat and
higher-order is that a higher order has
to be you know potentially partially
delayed okay so here is a dependent
function contract checked against a
value where that value is a procedure so
we just do the sort of ADA expansion
here the driving down the contracts and
we blame if it's not a procedure right
and this is all we sort of pushed all of
the work into Delta telling us whether
this thing is a procedure or not now you
can also have you know so a pair a pair
of contracts can be higher order if one
of the components is higher order so
this is how to deal with a sort of
composite higher order contracts so if
you've got a pair then you produce a new
pair that monitors both components and
if you can prove that this thing is is
actually a pair and blames if it can't
and so on so a conjunction of higher
order contracts is sort of straight
forward where you monitor
both contracts here disjunction is the
more interesting one so the the
disjunction of to higher order contracts
it's really it's not clear what the
semantics of that should be and who's to
blame when something goes wrong okay and
so what racket and other languages with
with these higher-order contracts do is
they make a restriction where they
basically say that you can make it a
disjunction of contracts but only one of
them gets to be higher order so you can
have a flat contract and a higher order
contract but they can't both be higher
order because they're really there's no
good answer for what to do in that case
so we make the assumption that the left
side is the flat one and the right side
is the higher order one and so we just
compile the flat one and and then
monitor the higher order 1 suppose this
is a jegging see it or D as being
suppose it had entire lower string
arrow-straight mm-hmm then why can't you
you know decompose it by saying I'm
going to test inch or string on my
argument yeah and depending on the one
that succeeds I'm going to remember what
should be the check that's done on the
outside when
yeah yeah so what happens in that case
uh so I think that that at that level
it's you can work it out but then when
these things get more higher order it
becomes it becomes more problematic I
can i'll have to dig up the details for
this because is so that yeah that's
that's one that's one aspect of it
there's there's more to it i'm just i
can't i can't recall the details right
now but again this has nothing to do
with sort of the symbolic stuff this is
all just about the design of this
contract language which are design
decisions that we didn't make right we
just wrote down the semantics of what
rocket actually does and it makes this
restriction where you can you can't do a
disjunction of higher-order things okay
and here is our applying you know
unknown functions and it's it's similar
to before where we're just getting the
the range and havoc in the other place
but here we have a sort of more
complicated havoc construction which has
to decompose pairs and apply functions
because both you know now we have new
kinds of behavioral values right you
have functions and also lists can
contain behavior because they can
contain functions okay and then the way
that you run a program is you have to
first so the important thing here is
that you do this sequencing where the
first thing you do is you take all of
the modules and you put them in a havoc
context because the module is providing
something and it doesn't really know
how it's going to be used so we have to
explore all of the behavior there and
this is just a ramped-up a statement of
the soundness theorem for this language
but it's it's the same as before
basically and then our corollary about
you know if you don't see blame you know
that you can no matter what you you plug
in that you can't blame the program you
know about so that's what this is really
saying here so if f is the name of a
program that we add that's concrete
meaning we know its definition if the
program doesn't reduce to a blame of
that module then there's no way to plug
something in so that f is blamed okay so
this is really being precise about who's
at fault and and really we're reasoning
about the program that we know about and
ignoring the programs we don't know
about okay all right so this was the
original goal right was an automated
modular verification of higher-order
programs with contracts and you know
I'll say that we've we've succeeded but
there's some caveats here all right so
one is that there's lots of room for
improvement and I think the biggest room
for improvement and it's something that
you know I think you guys probably know
a lot more than me about is how to do
this this part of the puzzle okay so you
know maybe you could plug in xiii here
and get some some interesting results
and it's all going to i mean as soon as
you do something better everything the
whole thing just gets better and it's
the there's a nice i predict that there
is a virtuous cycle that's going to
occur when you start doing a better job
about what fear improver you plug in
here because we have really just a
simple theorem prover that we wrote
ourselves and then the other question is
you know well is it really automated
because it's not decidable and you know
so if you think automated equals
decidable then you might think that
we've sort of we haven't really achieved
that okay so I was going to talk a
little bit more about how to make it
decidable I'll just I'll just step
through that real quick and then we'll
wrap up so the way the the way that
we're going to do it relies on work I've
done with with Matt might and more
recently with Ian Johnson and it was
really that the sort of Genesis for this
work was thinking about how do you do
program analysis in a modular way where
you know the sort of classic approach is
you write down some whole program
analysis and then you pull your hair out
thinking really hard about how to make
it modular and then you write it down
but Matt and I have this this sort of
turned the crank style approach to going
from say a reduction semantics to a
program analysis in a systematic way and
all of the stuff I've been showing you
is just a reduction semantics so so
we've sort of solved the modularity
problem up here and now we should be
able to just turn the crank and get out
a computable program analysis from it
and so typically this is applied to
whole program semantics because after
all what else is there right and we've
we've applied this to to racket in the
past and Android and JavaScript there's
a group at Harvard that's applying it to
an intermediate language for and
there's a group at Oxford that's applied
it to a Erlang so yeah so this stuff is
is fairly useful and easy to apply but
another nice thing is that we can take
the semantics that I've been talking
about and plug it into this pipeline and
what you get out as a sound and
computable modular program analyzer ok I
was going to tell you some more of the
details here but I'm just going to skip
this stuff I think the big point here is
that you we're really just writing down
interpreters and you iterate them to a
fixed point and you get this you know
these big graphs and
these state graphs and so on but they're
always finite but for me the big insight
here is just you know this is just an
interpreter and yeah I skipped a step I
skipped a step so so I've got this
machine semantics and it's set up in
such a way that that I the only the only
approximation that I'm going to do is
say that the that the heap is finite
okay and what that does is that sort of
collapses the whole state space down to
a finite space and just you do and then
you have us and then you have a sauce so
yeah and then you have to deal with the
base values as well so but so making the
heap finite is enough to make your
function space all the set of functions
that you can represent is now finite
which is sort of the piece I'm most
concerned about and then you have to do
some you have to have some abstract
domain for the base values like natural
numbers and strings and so on okay so so
the components are sorry let me back up
just a step so you've got this machine
and it's parameterised by functions that
that do push and bind so push is is like
a stack push but it's being threaded
through the heap here so our stacks are
always finite and binding is doing
variable bindings and that's also
threaded through the heap here so that
is also if you have supposed it
people at refraction how you're
obstructing so you have a so you have if
you have the Fibonacci function is then
you're gonna make so here let's let's
look at wide it so the way that we the
way we would do it is you would say
Fibonacci of some natural number
actually yeah it's an abstraction of the
event ok ok and now and so now you run
it ok ok and as your machine is running
it's going to have to allocate stuff
like every time it makes a recursive
call it's going to allocate something so
you know the recursion bottoms out at
some point because you run out of space
ok so here's here's a legit and in some
sense yeah yes so you are not so no its
sound that's the difference ok so i set
the point you should go a wedding what
is the wedding ah so ok you cannot just
talk n steps yeah yeah okay yeah this
would be on some so I said when you say
ok because if you're going to assume you
have 20 approximated in game so you
should have a wedding a try to see what
is ok so right so so push and bind are
going to yeah so we've got this this
finite heap and now the other the other
important thing is that the heap ok so
let's say you go to right into some
location in the heap and there's already
something there ok so what you do is you
just join them together so you take us
you have a heap maps two sets of things
and when you when you have a conflict
you just join them together and now
you've got a set of things there at
feature so you over the status of the
set of things you can put in there is
finite so they can't grow they can't
grow forever I can I can work out all of
the details for you ok but uh but the
the sort of important point is that when
you go to look something up in the heap
there's now a set of values there and
you just non determinate
non-deterministic Lee choose something
so you go from a deterministic infinite
state machine to a bounded
non deterministic machine okay and I'll
tell you all about all about the details
yeah so if you wanted to get an
interpreter interpreter out of it you're
pushing bind are just going to produce
fresh addresses and if you want an
abstract interpreter like if you want to
do something like zero CFA then you're
just going to choose like so push is
going to choose the label of the call
site and bind is going to choose the
variable name and so on okay and then
you just iterate these things because
you know that it's finite you just
iterate them to a fixed point and you
get things like this all right and the
big insight for me was that we're just
talking about interpreters okay I mean
they're there abstract interpreters but
they're just interpreters so you can
bring this stuff that you know about
interpreters to this to this problem
space so right it's just an interpreter
and one of the things so if the heap is
your sort of resource for precision
right and the way that you get these the
these splits in the graph is that you
you had you had two things sitting in
the same heap location so you've got
this finite resource which is the heap
and and you lose precision when multiple
things reside in the same heap location
but it's just it's just an interpreter
so let's i don't know let's write a
garbage collector all right and this is
the kind of thing that that I mean by
observing that it's just an interpreter
means that you can take stuff that you
know about interpreters and bring it
here and this is just one idea so write
a garbage collector and what happens is
that this thing you get a much tighter
characterization of your program here
because you're able to collect space
that that that wasn't reachable and then
when you go to write something and do it
later it's the one thing that's there
confused because I thought the point of
keeping multiple things in the in the
heat was true was not a news also somnos
right yeah so if you if you're just
going to blow away stuff that was there
previously yeah but it's but it's a
sound blowing away because you run your
garbage collector and it says I can't I
can't reach this in the future I mean
it's sound in the same way that garbage
collection sound right I know that I
know that this location isn't reachable
so so blow it away and then later if I
need to write something into into that
location that's fine and there just
won't be anything sitting there when you
go to write into it for the analyzing a
way yeah just say we're doing your nice
except by locating this says now I know
that this goes out of scope yeah I stay
clear it because you know this is there
but it's a rich porn I don't think you
said because maybe something located
inside a few senior and then distinct
escape you know does not escape so you
can just get ridden victories that you
do when you study ya know if analysis if
you get rid of the original notes to
make things smaller so another it was a
paper nacs
maybe they were using something nice
about the cake for Dave javascript
analysis okay just how they do some kind
of lazy propagation I don't have to look
at that so I know this stuff from Matt
Matt mites work on abstract garbage
collection yeah another insight is that
this thing is just a finite state
machine and you think okay so I'm
approximating this Turing complete
language with a finite state machine
which is a little bit like bringing a
knife to a gunfight and and you can
think about richer models here so one is
like why not use a pushdown automata and
that has the nice property that now in
your abstract space you're going to the
the stacks on your push down automata
match the stacks in your program so you
can do a really precise job of reasoning
about the stock here and you get a you
get I know it's light but you get a nice
nicer tighter approximation at the
program as well and then a sort of
natural thing that you might want to do
is to use both of them and there's a
technical problem that you've got to
solve here because if you've got to push
down automata and you want to crawl the
stack to do garbage collection that's
not something you can typically do with
the pushdown automata so what sort of
over the top is just the original finite
state approximation one is using garbage
collection the other is using a pushdown
approximation and now we'd like to
they're really kind of incomparable
and then you would like you would like
to use both of these techniques and Matt
and I have an ICF you paper on how to
combine this is this essentially you can
get the sounds we just
that's more precise than more yeah
because you have fewer sea ice and yeah
I think we should wrap up okay so let me
just let me wrap up and their other
there are other things that sort of
optimizations that you can that you can
start doing once you just start seeing
this as a interpreter like writing a
compiler rather than an interpreter and
it improves the performance so we get
better memory it the transitions are
faster and the overall analysis time is
dramatically improving here so this is
two to three orders of magnitude better
okay so it really can be automated just
by composing with this this stuff all
right so I showed you about our
verification environment I talk to you
know briefly about our sort of approach
to making these things computable and
fast and there's some papers the this
oops love paper this is the paper on
combining push down analysis and garbage
collection and this is the paper about
making these things fast that's just a
draft that's on archive these days so
thanks yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>