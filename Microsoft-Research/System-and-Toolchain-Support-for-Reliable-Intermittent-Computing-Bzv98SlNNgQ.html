<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>System and Toolchain Support for Reliable Intermittent Computing | Coder Coacher - Coaching Coders</title><meta content="System and Toolchain Support for Reliable Intermittent Computing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>System and Toolchain Support for Reliable Intermittent Computing</b></h2><h5 class="post__date">2016-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bzv98SlNNgQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
I'm tomball and it is my great pleasure
to welcome Brennan luchia back he was a
researcher microsoft research and now
he's an assistant professor at Carnegie
Mellon University he does amazingly cool
stuff with hardware and run times and
he's about to launch into outer space
via SpaceX some cool little circuits and
I guess we're going to hear a little bit
about what the challenge might be if you
want to put something in outer space
that doesn't have its own battery pack
welcome back yeah thanks for the
introduction stock won't be about space
entirely it's going to be about a
general problem that we run into in
space which is intermittently available
energy and energy harvesting so there's
a lot of a lot of different design
challenges that you run into when you're
trying to build devices that you want to
run off of energy that your borrowing
from your environment so I'll talk about
what the challenges are that I'm going
to talk about some system support that
we built for that that kind of dropped
last year and then I'll talk about some
stuff that we have going on right now
which is kind of the state of the art
and debugging devices that are doing
intermittent execution and energy
harvesting I'm from Carnegie Mellon
University the electrical computer
engineering department and the stuff I'm
talking about is what I've been doing in
my students have been doing together so
it's kind of big big happy family group
effort from there so probably need to
tell you guys too much the motivation
for this kind of work is that we have
little devices everywhere so your
medicine bottle isn't just a medicine
bottle anymore there's like a computer
in there that's telling you how many
times you've opened the lid and where
did that come from and where is it going
so you know if your medicine has been
somewhere that you don't want it to be
it or in the hands of someone that you
don't want it in their hands and these
devices are in the medical domain we can
put these devices into space and they
can do things like try and find
resources extraterrestrial e that we
want to mind and bring back to earth and
lots of other really cool stuff so
emerging devices are everywhere and a
lot of these especially if we're looking
at kind of medical applications we need
the devices to have high reliability in
particular things that are expensive or
dangerous need to be reliable and so for
the most part when we
build devices using little embedded
systems like this we are tied to a power
source like two double A batteries or
maybe you have to plug into a USB or
maybe you have some big chunky power
pack or something like that so this is
problematic because these devices you
can't put them everywhere they're not
tiny it's hard to put them say inside of
your body for medical applications and
if you're going to launch something into
space you probably want something more
sophisticated than for double a's that
you're going to go and shoot it into
space or if you want to you know monitor
volcano your double a's are just going
to catch on fire and go away so that
won't work so we're looking at the
result of kind of years of research on
something called energy harvesting and
energy harvesting is the technology that
effectively untether is the device so
here's how it works this is the basics
you have an antenna which is an energy
receiver you have a capacitor which is
an energy buffer it's just like a bucket
you're pouring electrons into and then
you have kind of the downstream
application hardware so this is a
computer could be a microcontroller you
can have sensors you can have a radio so
that you can send communications from
your device but the basic model of
operation is you have some energy source
over here like this big square antenna
that I have on the slide you have some
empty space this can be you know 20
meters 40 meters that kind of range it's
not you know infinite range if you're
especially for using this kind of like
an RFID reader antenna as your energy
source and then you have a target device
like this kind of janky breadboard
mock-up prototype that we built in my
lab that is implementing some
applications so the future what we hope
for is that someday you can cram one of
these things in your head and it can
help you to understand say you have
schizophrenia or say you have autism or
something this can help you understand
why you're behaving a certain way on a
certain day these kinds of applications
I mean these these are the exciting
applications doing things in especially
medicine that we can't do today because
you don't want to be cutting someone's
head open to replace batteries or to
power and that's literally how these
things work today is you'll have a power
pack and you need to charge it so this
is a big shift this would be a kind of
dramatic shift from the way things are
done today so there's a problem
the purposes or is this that is riddled
trade purposes this is effectively click
on a clip art this is some existing
medical procedure I think that thing in
the center is I think this is actually a
battery I'm pretty sure that's a coin
cell so I think this is a probe that
someone put in for a shed for a
short-term experiment now this is this
is a probe that's some computation
probably radio and I don't know about
this particular image because I just you
know this is from google but yeah we
don't know the provenance of this image
I was just curious yeah but in general
experiments like this and they're short
lived because you have to take them on
replace the battery that's it that's the
big problem here yeah so if we go to
this energy harvesting that I was just
describing about where we can take
energy from the environment we can use
radio waves you can we can use solar
energy and we can power of these devices
there's a caveat and that is that the
energy that we get is intermittently
available we don't always have energy
available if you're near a radio tower
then you have lots of energy you can
soak it up and fill your capacitor and
run your device but if you go far away
from your radio tower then suddenly you
don't have anything available your
device turns off even if you're near a
radio tower you charge up a capacitor
and then you start running your device
that drains the capacitor and when the
capacitor the capacitor is going to
drain much more quickly than it can
charge up so when you run your device
unless you're very careful in software
and that's actually an open problem how
to be careful in software you drain the
capacitor and so you essentially the
device just kills itself at the cadence
of the charge and discharge of the
capacitor I'm going to tell you more
about that but that should give you an
idea that these devices are inherently
unreliable this is an important point
they're inherently unreliable because
you don't have a continuous execution
model because the energy is intermittent
so this can i solve a pie and the switch
between you two passengers turkey if i
do have you and you do that but it's not
going to solve it's not going to
entirely solve the problem because then
you have two things that are going to be
charging and reliably and you have to
power the logic that switches between
them so okay what if we have three let's
have three capacitors now we can switch
between the three we may not have
charged in any of them that's adequate
to run our device and now we have to
have more sophisticated reasoning about
which one we're going to use so there
are yet we could we can try and
fine-tune the power system I think we
should attack the problem in software
and says what I'm going to talk about
today is actually how we can take this
on in software and there's a little bit
of hardware stuff
talk about later but primarily I'm going
to talk about how we can solve the
problems of the intermittent execution
model which I was just describing and
how we can think differently about
building systems and in particular
building software for these kinds of
systems I'm going to talk about some
systems support that we've built for
making intermittent executions reliable
and then I'm later going to talk about
some very recent work that we've been
doing on a hardware software platform
for debugging intermittent devices so
this is filling the gap the absence of a
tool chain for understanding
intermittently executing devices okay so
to give you a clear idea of exactly what
it looks like when we're running on
intermittent energy we have a plot here
the y-axis is the available energy and
we have time going across the bottom and
here we have a lightning bolt indicating
with some radio frequency energy being
transmitted over to our advice and so we
charge charge charge and then we hit the
Lifeline this is an important point in
the timeline of this device when you hit
that point turns on you start operating
the device can use sensors communicate
whatever and when we're operating you
see we precipitously drop off and the
amount of energy that we have the
capacitor is being drained very quickly
because maybe we're being naive about
how we're using the energy in the
software then we hit the deaf line we
run out of energy by the way the
lifeline it's around 2.4 volts for a lot
of microcontrollers 33 volts is a kind
of standard operating level for
microcontroller to point 4 volts just to
give you a concrete idea of what the
parameters are here is kind of what that
lifeline is and 1.8 volts as the death
line and so if we're looking at kind of
hundred micro a hundred micro watt
operation that should give you a
ballpark of the kinds of devices we can
support with this with this month with a
radiofrequency charging in particular so
we hit this deafblind crossover and then
we're not charging we're dead we're far
away from the radio antenna and we can't
get an energy a little while later maybe
we get some more energy we're charging
and then we hit the Lifeline again and
okay cool we can start operating again
this is a complicated plot because
there's a bunch of continuously varying
parameters we have energy level and we
have to find a way of measuring that
accurately and time is moving forward so
part of the work that we've done in
defining intermittent execution is
abstracting some of the details away the
way we abstract it is by noting that
here the computer shuts down and here
the computer reboots so really instead
of charging and discharging
all we need to see from the software's
perspective is that we have a sequence
of periods of reboot and computation the
red parts are when the device is turned
off the green part is when the device is
operating this is what we called the
internet an execution model and this is
stuff that we published appeal the eye
in 2015 the internet and execution model
says you compute for a while then you
drop out and then some arbitrary period
of time later you don't know how long
it's been you don't know what
environmental changes have happened
that's the intermittent part you turn
back on and you start computing again
and our goal is to make computations
that go longer than one green box that's
the hard part so just to look at what it
looks like to run a computation if we
have some code that looks like this you
want to append some things to a list we
have a main function at the top that's
going to append 10 things and we have
the append function which bumps a
pointer in your list and then puts a
character in the location that's pointed
to in the array so let's run this on
intermittent energy and just see what
happens we could maybe run for a couple
of loop iterations then we get a reboot
okay well we're going to start over then
and we're going to do one iteration
start a pending and we're going to get a
reboot we can do this all day and will
maybe make it you know as far as three
loop iterations or four depending on the
size of our capacitor and the amount of
energy we have but we're not going to be
really successful at doing any useful
computation if that's our model so we
noted that we can model intermittence as
a control flow problem so this is a
control flow graph and it maps to the
program that I just showed you and we
can add edges to the control flow graph
that essentially go back in time so
you're at some arbitrary point in the
program and according to an external
environmental condition it's not a
data-driven control flow edge but
instead it's a kind of environmental one
you go back in time and so these are
implicit control flow that's one thing
that's really hard about this there's
nothing in the code that says from here
you could go back to the beginning of
main the programmer has to reason from
each point in the program that they may
be able to go back in time this is hard
even if you're even if you're very
clever and you decide to use some kind
of check pointing system which I'll talk
about in a minute this problem doesn't
go away so intermittent a big challenge
to doing intermittent execution
successfully is dealing with the fact
that you can go back in time these
devices that I mentioned in written the
executing
you're harvesting devices typically have
a hybrid memory system so what do I mean
by hybrid the hybrid is between volatile
and non-volatile memory so a small
amount of volatile memory is typical
around 2k and then a larger amount of
byte addressable non-volatile memory is
typical and a lot of microcontrollers
these days are using something called F
RAM which has reasonably low access
latency and energy although it's still
much higher than SRAM or D Ram so we can
use the non-volatile memory a lot like
we use the normal RAM in the computer
and of course we can use the volatile
memory just like we would normally
except that the volatile memory has this
peculiar property which is that its
values disappear so if we want to span
periods of failure then we have to deal
with the fact that our memory gets
erased all the time and the non-volatile
memory doesn't disappear it keeps its
values this is straightforward but I'll
show you in a minute that that gets
problematic if we start using the
non-volatile memory just like ram and we
are also using some volatile memory like
rain so zooming out for a minute the big
idea is that the tools we have and the
mental models we have for building
software don't align with the internet
execution model and in fact something
that is correct when you have continuous
power gets really weird and sometimes
incorrect in unintuitive ways when you
do intermittent execution especially
when you start mixing together
non-volatile and volatile memory and so
I'm going to talk about a new category
of bugs which are related to
intermittence and the hybrid memory
system I thought this was really gross
comic which is why I included it okay so
I'm going to talk about intermittence
bugs now and you guys can stop me if you
have any questions along the way I'd be
happy to keep taking questions align the
first intermittence bug that I'm going
to talk about is an out of thin air
value that you can get and this shows up
ok so the setup here is we have the same
program we were looking at before now we
could say that there's a checkpoint at
the beginning of that loop and we can go
back to that checkpoint and now the
setup for the checkpoint is we're
capturing the volatile state of the
program and when we fail we're going to
reboot repopulate the volatile state
we're not going to do anything to the
rest of the non-volatile state because
it seems like we don't need to check
point that it's non-volatile we can just
keep that around
and so we'll go back to this checkpoint
at the beginning of that loop and will
execute forward again so if we do that
we can see that size and buff there in
grey that means there in the
non-volatile memory and they're
initialized to buff is an empty buffer
of characters and size is negative one
meeting we have nothing in the list
right now so if we run the program like
I showed you before we get through
incrementing size and then putting a
character in the buffer this is pretty
straightforward this is easy easy to
understand how the state gets
manipulated there and then we fail so we
were at this point let's say we hadn't
made it around this loop like I said
there was a checkpoint there so each
time we go around the loop we're going
to checkpoint and say okay we captured
that we did one two three loop
iterations but we died right at the end
so now we're going to restart we're on
loop iteration one again but that
non-volatile state doesn't get erased
when we turn the power off that's going
to stick around and so what we see is we
have an out of thin air value a gets
appended twice for the i equals 1
iteration it's a buffer state that you
never exist it's impossible in a
continuous execution we won't be able to
see this behavior in fact we can run
this out to its kind of natural
conclusion let's keep going around this
implicit loop it's still loop iteration
number one but if we just turn the power
off repeatedly like that we're going to
keep updating that buffer and eventually
we get the size to 11 that's a value we
could never see before we have this
array it has 11 days in it that's a
value we could never see before so we
can produce values in the execution of a
program that if you run on continuous
power you would never encounter and the
important thing about this is the
failure is dependent on the availability
of energy and the rate of charge and
discharge of the capacitor that should
be concerning because that means if I'm
using radiofrequency energy to charge my
device and the transmitter is here and
the device is here I can do this and
change what the software does that's a
system behavior you probably don't want
there's another kind of bud that we
encounter this is an atom icity in the
conventional sense of an atom icity
violation some things that should happen
all at the same time don't necessarily
happen all at the same time and you get
values that end up being weird in this
example program we want the increment of
size and the population of the buff
to be atomic with one another and we can
clearly see that if we kind of execute
up to the point where we're incrementing
sighs and then we have a failure and
then we restart will be incremented
sighs twice and we only put one
character into the buffer so now we have
this weird atomicity violation
manifesting as corruption of the state
you have the size equals one and you
have the first entry of the buffer is
unpopulated so Adam st violations are
another problem we run into we can get
memory corruption in the non-volatile
memory and remember we're using
checkpointing here we're preserving all
the volatile state in a checkpoint we're
going back and repopulating it okay
another another problem that we can run
into is if we have some high cost high
energy costs piece of code we could get
into a situation where we started a
checkpoint and try to run forward and
regardless of how hard we try we just
can't make it through the region of code
between the two checkpoints and this is
something that could vary in
environmental conditions rate of charges
the capacitor and the programmer has no
visibility into whether their program is
likely to or with what likelihood will
succeed and so this is problematic we
eventually you know end up in an
infinite loop and this program works
correctly if you plug your device in
that's that's one of the big problems
here is the programmer is probably going
to do most of their initial development
using continuous power and they'll say
ah my program works all I have to do is
foo and then high cost and then whatever
and in fact when you go over to the
intermittent power supply you're going
to see that this program doesn't
actually appear to do anything so I've
given you some evidence that these
devices are too unreliable to put inside
your body right next to your heart I
wouldn't want to do that and we need
better programming abstractions to make
these things reliable and I think we
need system support to go with the
programming abstractions to enforce some
reasonable guarantees on the behavior of
software that's running on
intermittently executing devices so we
came up with a couple and I'm going to
not go into a lot of details because
I've given some rendition of this talk
at Microsoft before so I'll skimp on
some of the details here but i'm going
to give you an overview of the kind of
system support that we have in mind to
make these devices more reliable
so in pldi 2015 we had a system called
Dino Dino as an acronym for death is not
an option and this takes if this
addresses the problem that I pointed out
before that checkpointing doesn't get us
out of this mire if you have
non-volatile memory in the system and
you have volatile memory in the system
you can end up with these problematic
inconsistent memory states where your
non-volatile memory has values in it
that you don't expect so if we take a
program like this one we can convert it
into a collection of tasks tasks are
demarcated by static boundaries in the
program and there may be and tests are
dynamically defined as you flow through
the statements in a program you may
traverse across a task boundary that
ends the previous task and it begins the
next task our system supports task
atomic semantics meaning that when we
start a task if it completes then it's
as though that task executed without
being interrupted by any power failures
so we eliminate the atomicity violation
problem and we eliminate the out of thin
air value problem as well the way that
it works is by selectively preserving
not just the volatile memory but also
grabbing pieces of the non-volatile
memory that through program analysis we
realize that we need to preserve
otherwise we'll end up producing those
funky memory states that I showed you
before another important thing is that
we eliminate these effective control
flow edges these implicit backward
control flow edges because we have these
task boundaries that have checkpoint
semantics with regard to control flow so
when we have a failure we go back in
time to not an arbitrary point in the
past where maybe a checkpoint was
collected or two main or something like
that but rather to a point in the
program that the program are statically
defined this is helpful because now we
can understand from if we look at the
program from a certain point in a
function there's a small set of points
backwards to which we could go on a
failure so we've eliminated this kind of
arbitrary implicit control flow problem
that we had before yep it seems like all
of the bugs are related to their very
similar to concurrency boats currents
related books
this has a feel of transactions in some
sense we miss available for a single
task yeah but transactions are really
hard so I had other other things that
people have solved in concurrency that
can be applied in this domain yeah this
is a great question so this is a lot
like concurrency and in fact in the
paper that I have cited here and you can
take a look at it we frame this problem
as not just the control flow model i
showed you before with implicit
backwards control flow edges but also as
preemption and it turns out that if you
have to preempt abul tasks that access
the same same state which is like a data
race then you have the penny can have
one of the problems that i showed you
before now with regard to the similarity
transactions I think you're right on the
money with that we want transactional
semantics we want tasks to be like
transactions there's a few differences
that make this this model maybe a little
weird but also really implementable one
of those is that we have kind of
statically bounded but dynamically
defined region so you can have this this
is kind of a weird thing transactions
are typically scoped with a beginning
and an end and each beginning has one
end in our case you could have an
initial boundary and then some
statements going forward and then a
branch and you could have a terminal
boundary on either side of the branched
and others for that given start task
boundary you have two potential end task
boundaries so that's just a kind of
mechanical difference from transactions
we do have some problems that
transactions also have like open nesting
and I oh and the fact that you have a
world that you're operating in and the
effects of that world whether it's
through other software modules or
through i/o interfaces it could make
your life more difficult for preserving
the item s if you have your tasks yeah
great question though I think we want a
lot of the same guarantees transactional
memory provides and so going forward
we've actually been looking at how we
can kind of take some of the big ideas
there and boil them down so we're
actually we're constrained in a way that
a lot of transactional systems aren't
and that is doing rollback is expensive
we need to consume memory to store a law
give everything that we've done and if
we encounter a conflict to some previous
failed incarnation of the same task that
we're trying to execute we need to go
and repopulate from that log or maybe
replay parts of the execution we have a
flavor of that here going forward though
we need to move away from that model so
that part of transactions i think is
similar now but should not be similar in
the future it's it's too expensive in
this domain you can't spend the energy
to go and repopulate the entire state of
memory based on after a failure based on
some log or something this is seems like
curriculum haunted very another
difference is that there is no such
thing as a local access as every single
memory access you do is in a transaction
where is it Tim system unit niche take
advantage of the fact that some of the
things you know are only give you rent
locally right there's no such thing as
local when and everything that can you
subject to car battery yeah that's a
shame point so something I'm not going
to talk about today but we could talk
about some other time is distinguishing
between volatile memory and non-volatile
memory and treating volatile memory more
like local memory and treating
non-volatile memory more like global
memory because you have this nice
property that when you fail you're
volatile you're volatile values all go
away so you don't have to worry about
partial results being preserved across a
failure like you do with non-volatile
memory so in a way that's sort of like
your local memory you nothing else can
mess with it now previous executions can
mess with it but you need to make sure
that you reinitialize it every time you
start a task and then run forward so if
you if you apply that programming
discipline to your volatile memory it
begins to look a little more like than
the local memory in transactional memory
systems cool cool so I'm not going to
dig into this in excruciating detail
because the examples pretty simple but
this figure shows how our system that I
just described with tasks and check
pointing and selective versioning if the
non-volatile memory eliminates bugs so
here's how it eliminates the out of thin
air value problem we capture the
checkpoint and this captures those
non-volatile memory locations and it
should be straightforward to see that if
we preserve those here and then fail
before we hit another task boundary when
we restart as
as we restore the values of buff and
size that we had before we can go
forward and we have a consistent state
of memory this is this should be pretty
straightforward so we're essentially
adding to the checkpoint is one way of
thinking about it it's important to
point out that prior work on this
overlooked the need to do this
versioning of non-volatile memory so
there are systems out there software
systems and hardware systems actually
there's a another paper and I'm not just
picking on mementos here there's work
called quick recall system called quick
recall that implemented volatile only
checkpointing in hardware even and if
you add non-volatile memory to the mix
which I think their devices even
probably assume it's problematic you get
the wrong result so i can pick on this
one because my co-author on the paper
that i'm talking about here is a
co-author on that paper too so he
happily welcomed the correction so the
the question though is which parts of
the non-volatile memory do we have to
capture in the checkpoint which parts do
we need aversion and we need to make
conservative assumptions because we want
to do the statically you wanted side in
advance we can't do any runtime
reasoning that's too expensive so if we
have a task battery we have to say which
parts of this program do we have to
capture well we can look at how data
flows so if we look at our control flow
graph we can see how data flows along
the control flow arcs in that graph and
we can see that on the implicit edges
that we added if there's no flow through
non-volatile data then we don't need to
capture that non-volatile data as part
of the checkpoint so you can see here
we're just assigning into this
non-volatile array we're putting I into
the bin I in that non-volatile ray and
so we don't need to preserve it because
when we restart we're going to go back
to the task boundary and we're going to
just blow all those things away it's it
seems this is straightforward that we
don't have to capture those however if
we if we change this program a little
bit and we say that we're going to be
incrementing each of the bins in this
non-volatile right now the story is
different now we do need to check point
that because we have a data flow around
the loop that's created by that implicit
control flow edge so if you store
something and then you restart you're
going to see the result of what you did
before you're going to see the
incremented value and you'll get wacky
values all over the place
so the key inside here is that we have
to version the data if we both read and
write the value that's something that we
can look for in the compiler and that's
actually what we implemented we look for
situations where we have both kinds of
operations and it's actually that's a
superset of what we need to look for
that was conservative we can trim it
down and we could have trimmed it down
that's what we did in our compiler
because it was easy to implement and it
works to keep things correct yeah more
precise will be upwards exposed uses
that was just those definitions
frightens you need to really see a data
flow around though you need to have a
use which is upwards exposed which means
there's a path to these from the
beginning of the task but some of those
are okay because if you have an upward
use a definition that right yeah yeah
yeahs a definition later yeah but I
think that produces that produces a data
flow around the illicit control thorac
run yeah right so if you do this so you
make it more precise than me right yes
we r ya working inserted weren't we're
saying we see both of these on the path
to a task boundary then then we would
preserve that in the novel maressa your
bush first thing I said it was also
going to take a shot at summarizing the
exact requirement doesn't really fit if
it is exactly I components we want that
in votes yeah so it's like I'm just
saying anything is idempotent is free
anything that is not let me put it oh
that's true that's true museum is a gem
quite a task boundary at a point that
defines all forward tasks to be added
home tasks in other words it encloses it
never it never cuts one of those edges
right then every check when it's true
but every one of these boundaries code
is free and the father you amount of
check when you do dragazine toward I'm
phones and once that's in and once
you're done we'll check by doing that
you have maybe there's another factor
and that is sometimes you don't want to
put a checkpoint or sometimes you want
to put more checkpoints both of which
could mess with that impotent the reason
you might want to do that is if you have
i oh and you want to for example put
task batteries tightly around io or if
you need several i/o operations to be
part of the same task because you know
you're correlating values to
sensors and if you collect one sensor
value now and 1 10 minutes from now then
it doesn't make any sense so subject to
those other constraints which by the way
are not edge cases they're very real in
this environment like this environment
is all about I oh it's your doing
sensing and your processing and you're
transmitting you you may be able to get
those item potent things but not always
yeah but it's a good observation yeah ok
so this example does reveal where we
work out of it reveals a fundamental
limitation of checkpointing and this
really sucks and this is something that
we're trying to get away from because
it's very expensive to implement this
what I was saying to you just a second
ago if we can't know in advance where we
might be accessing we need to capture
the whole thing and that's a huge drag
especially when your task boundaries
could be subject to external constraints
like the position of Io and your code
you could be really host I mean this is
a really contrived example we haven't a
you know million entry array and we're
choosing a random element of it that's
probably not what we're going to be
doing but you can imagine how this
manifests as control control flow
deciding which things you're going to be
accessing so my view is that in the
future check pointing is not a viable
solution for solving the intermittence
problem we need to do something else
that preserves state keeps it consistent
gives good guarantees but isn't
reloading values every time we restart
so we built the prototype this is sort
of an unremarkable prototype it's the
way that you would expect it to be if
you've done this kind of work before and
I know most of you have so we start with
the program you have to put these
annotations in our compiler does a
dataflow analysis and finds the
situation's we were just talking about
it links us to a runtime and then when
we get over there we have a runtime
library that compiler links it to and it
does checkpointing and it does the data
versioning stuff dynamically as we need
to as you cross task boundary that's the
implementation we evaluate on a bunch of
different benchmarks that we got from
kind of various places we have a MIDI
musical instrument interface we have
sensor logs some very stuff we
implemented for a custom breadboard
prototype and for the wisp 5 platform
which are two different radio frequency
energy harvesting devices and if we
don't use any support for these things
we have errors and the system the
systems don't work all of these
applications for
is the wrong result or they have a hard
stop failure that we can't recover from
because for example the histogram that
we were we were storing sensor log
readings into is corrupted one of the
bins got unlinked and so now what are we
going to do we have we have no way of
recovering the value so if we look at
one benchmark like an activity
recognition benchmark that takes
accelerometer readings and decides using
a nearest neighbor classifier whether
you're having a tremor which is kind of
a medical condition that we could
identify pretty easily this is a
wearable medical advice medical device
kind of application then we can see how
much air do we really get if we're
running at say ten centimeters or 20
centimeters pretty close to the to the
power source this is a radio frequency
power source and these distances are
fairly short because we wanted high
fidelity in the experiments without
having to do 26 gazillion measurements
as you go further away the variance
becomes higher in the measurement so
we've had anymore so we went out to 60
centimeters which is not kind of notably
far but we saw that even out there we
had edging toward ten percent error in
our measurements and that's pretty close
so if we want to use this device in a
real environment where say we have
instrumented rooms in a hospital with
RFID readers where we're going to be
going in and out of range say 10 to 20
meters of these things we're really
going to have to improve the fidelity of
this because the error seems to scale
maybe with diminishing a diminishing
trend toward higher error at higher
distance suppose that I have that exact
scenario where I'm in a hospital and one
question is are the errors uncorrelated
because you could imagine having two
devices for instance if the air is
aren't correlated if it's really a
particularly like a kind of a blip in
the air right a you know then the
probability that actually both devices
for instance have an error when I enter
a room goes down exponentially that's a
good idea I think we should probably do
that doing using the issue is going to
be but it depends on the correlation of
the air it depends on the like I'm kind
of asking about the error quarterly so I
don't know if there is a rural
I suspect part of me wants to say yes
because you'll have more errors if you
have more failures and so if you're
further away from a power supply you're
going to be dropping out more frequently
so that means that both systems are more
likely to be failing and so they're more
likely to have errors but then on the
other hand it's a function of the
software and so we don't know they might
not be in the same place they might be
just out of phase enough maybe this one
I mean it could also be a function of
the hardware maybe you use different
memory technology in one device than the
other try and be more robust an issue
that I see it implement this kind of
system is that you have a distributed
system now and if their computing the
same value they need to agree on which
value they computed or you need to build
your application in a restricted way so
that they can produce an arbitrary
stream of values and you know that
whatever the streams are that the two
devices compute you can put them
together and make something sensible
that your application cares about in
either case I think there's some
distributed systems coordination stuff I
mean you're not going to run paxos on
these things just because there's not
enough energy to you know take
checkpoints so good luck with paxos but
I think you would have to do some
coordination stuff they can communicate
they could actually communicate with one
another and that might be a one way out
of this cool so with our system sadhana
nowhere that's because we eliminated by
construction so the point here is that
we can compile programs differently and
get better reliability guarantees for
these inherently unreliable devices
that's the punchline we eliminate the
error because we'd compile the program
differently and put runtime support in
to prevent these things from happening
ok so now I'm going to switch sir just
something much as cost so because I
don't have in the slides but in the
application we were just looking at it's
hard to measure the overhead but it's
about 2x on 2x slow down on the baseline
implementation with the caveat that the
baseline implementation is incorrect so
it takes it takes about twice as long to
complete the computation and that's not
just because we add more cycles to each
loop but because if you arrive at a task
boundary and you're at you know your
buckets half full you have to do more
work and so you're more likely to fail
and then you have to go back to the
beginning of the task and spend a
quarter of your bucket to repopulate the
memory and then you can complete the
task that you were doing so it's not
just the additional work of /
ask overhead it's the additional work of
wasted work in failing in tasks that you
wouldn't have otherwise failed and so
that's why it's 2x that's why it's it to
me this is a surprisingly high overhead
number for kind of sparse checkpointing
because we're manually placing
checkpoints the checkpoints can be as
sparse as we want them to be so that's
why it's too XO is because we have not
just more work / task but because we
have more failed tasks so this is I'm
not sure my question is fully formed yet
but I'll try it so you you kind of made
this comment that checkpointing is where
you you guys want to move away from it
because you have this very concrete
example of accessing an array that's
billion a billion elements it seems like
that's a from your programming model is
very low level like your seat right and
so you you know you one thing you could
think about is a set of abstractions
where you still allowed to have
checkpointing but you've put the right
kind of kind of you know data structures
80 of whatever whatever those things are
that let people do certain class of
operations easily where you can still be
amenable to checkpoint so I part of the
question I guess to kind of come back
the question is how do you thought more
like about permanent abstractions that
help people do this type of work as
opposed to you yes maybe that's like
stealing the rest of the Thunder so I no
no it's not the rest of this talk is
actually a talk that I three months from
now I'll be giving that soccers okay um
but yeah the basic idea is that we can
we can do it's sort of like decomposing
decomposing checkpoints into the
individual memory locations that we want
to be accessing and if we force the
programmer to adhere to a discipline in
the way that they use their non-volatile
memory then we can eliminate the need
for checkpointing but still have item
potent task restart and so we can talk
more about this offline it's basically
roughly what you said except that we're
not using any kind of ATT abstraction
it's more of a kind of general you can
think of it like as a kind of key value
store abstraction and then working
forward from that you can do arbitrary
computation build up arbitrary data
structures yeah the task abstraction is
pretty similar though that's that's
roughly the same it's a little bit
different but it's roughly the same yeah
cool so if we wanted to bug these things
we have all these weird bugs we need to
change the game a little bit and I'll
show you why we need to change the game
a little bit debugging is a particularly
hard problem because the intermittent
behavior that we're seeing not only
causes conventional software is like
we're already fairly familiar with but
it also can lead to kind of the hardware
misbehaving in ways that are apparently
invisible and so both of these are
problematic I'm focusing on software
here but I wanted to mention that there
are also there's the possibility for the
hardware to go wonky too so debugging is
something we need to be paying a lot of
attention to going forward ok so i
showed you before how we can get
intermittence bugs and these can lead to
application errors like if we have 11
then this is obviously a problem we
don't want 11 entries in our 10 entry
buffer and we note that this failure
only manifests when we're running on
intermittently available energy when we
running under power so if we have the
radio frequency harvester pointed at
that device we're going to get this bug
manifesting when we have a reboot here
halfway through our loop and then we
start again and we executed and we
increment ok now we're at 11 now we have
this problem so we don't want this to
happen because this doesn't correspond
to any continuously powered execution
our group is approaching this set of
problems with that as a correctness
definition so when I say we're debugging
we're trying to move toward a more
correct program we want to permit
behaviors that are permitted in
continuously powered executions this is
a reasonable definition of correctness
that we're pushing towards so what do we
need to understand why this bug happens
and how we can fix it what we need is to
look at how the energy is changing like
on this curve that I showed you before
and what's going on in the program at
each of those points when the energy is
changing so here we have size
incrementally and buff incremented and
then we had a failure on that curve and
we saw when I showed you the example and
explained it we saw why that was
happening but if you're just writing an
application and one out of every ten
thousand executions fails good luck
figuring out that this what's happening
you have events a B and C on the
downward slope of your discharge curve
then you restart and you have a and B
again and that leaves you with a corrupt
state this is difficult to reason about
because we don't have any visibility
into the device we want to be able to
answer the question what was happening
when that weird thing happened and we
saw our application produce the wrong
value what was going on inside the
device so the problem with trying to
diagnose this type of failure is that
typically we're in this kind of cartoon
set up you attach a big chunky plastic
box to a power supply like a USB port
and you attach the other end to your
target device you have visibility into
your device this is great you can do
jtag debugging you can get all the logic
bugs out of your program but you're
providing power so your discharge curve
looks like this you're at full full
voltage the whole time this great out
part never happens you never see the the
bathtub of kind of you know discharging
and then recharging again so we'll never
get ten you can run it as many times as
you want to your you're only ever going
to see 10 so that's a real drag we can
see the failure behavior run on
intermittent energy but not be able to
look inside the device and use jtag or
use any kind of debugging console or we
can power the device and we can look at
all the registers and everything as the
things executing that doesn't help us
very much because we'll never see the
failure this is the problem that we have
this problem is called the energy
interference problem and no devices that
are on the market today or from research
solves this addresses this good couldn't
you just again taking the idea that this
is an instance of a concurrency related
bug use concurrence related tools in an
emulator so for instance I could imagine
is their outer either side use an
emulator so the emulator is the problem
here you'd have to be able to model the
behavior that is causing your bug in the
emulator we notice I mean you could just
defect on the other end okay fine but
it's a non-trivial mapping I accredit
but you could imagine maybe you could
say something like you know you remember
you know you have a maybe I can take
this on fine because i'm not sure i have
advanced my that's my question but
though but the point is that it seemed
like you could come up with a leader
leaving for instance of an execution of
a concurrent execution that gives you a
value of 11 for your se but if you
actually change things to be mobile go
lower
that's interesting we actually had a
short-lived project that you can follow
up on which is essentially simulating
arbitrarily timed power failures and
hoping that a single power failure leads
to the corruption that we're looking for
we found that while sometimes it is in
other cases we needed multiple power
failures to get something really bad to
happen otherwise we wouldn't end up
getting the wrong value back in your
control it's packaged it's one of these
implicitly defined back at you so we
could go in and instrument the program
and add that back yeah yeah let's go
together and build that thing now yeah
we need the you know we need the hands
that's what we need so yeah that's
that's a good idea and the connection
that concurrence these deep like i said
in the pldi paper we kind of identified
this and you can use the same kind of
you know theoretical framework for
reasoning about this data races in
particular or a nice way of thinking
about it yeah so then here we could also
use logging logging is great if we have
an intermittent and executing system
like this then we want to understand
what the behavior was we could you know
maybe log the energy periodically or we
could like blinking LED or something I
mean the the peripherals that we have
are pretty limited printf we could
implement over like a UART and that's
great but all of these things cost
energy and so we're effectively changing
the discharge curve by putting this
stuff in its it's an observer effect and
in some cases it's pretty rough if you
want to blink an LED when you have some
condition like maybe you blink your LED
when you're adding an element to the
list and you want to see and then and
then maybe you're blinking another LED
when you get down to one point eight
volts so you know when you're about to
die if you can see really fast when
those LEDs are blinking at the same time
that might be when your failure
condition happens so think about that as
your kind of optimistic hopefully this
works kind of debugging model this is
actually what people do people do things
like this when they're drinking embedded
development and it gives you a situation
like this though where you're killing
the device by doing a log and trying to
put sign up link the LED so even if that
would work you're changing the system's
behavior and you get this energy
interference gap where the behavior that
you're looking at is different by some
constant amount of energy from the
behavior that you are trying to
investigate so you may mask that there's
also the problem that you need to know
more or less what you're looking for in
order to log it and try and find it it's
the same as doing any kind of tracing
printf based debugging so this
pretty bleak this isn't the way forward
this is a stopgap at best if you can
make it work if you can find some
signals to get off your board you can
use an oscilloscope that's a nice idea I
just sent a proposal for one of these
and it came out to about twenty nine
thousand dollars including all the
probes if you want digital probes to
grab a few signals coming out you want
to look at energy by the way the
correlation between what your program is
doing and what the energy is doing is
totally invisible to the oscilloscope
because you can't probe the internal
logic of your microcontroller so if you
want to get a good measurement of what
the energy is you can do that with the
oscilloscope this isn't the way forward
either maybe combining the oscilloscope
and logging and doing logging while you
have an oscilloscope trace that's that's
how we developed what I'm about to tell
you about and I can tell you from that
experience that that's extremely
difficult and time-consuming and it
wastes a lot of time with false starts
because the instruments begin to lie to
you after a while so it's it's hard to
debug these things oscilloscope logging
direct measurement none of these works
so we developed a new thing which is
called EDB this is the energy
interference-free debugger and this does
the things that I described us wanting
before we can correlate program events
and failures and certain value
conditions being satisfied and certain
energy conditions being satisfied with
the energy behavior of the system the
device that we designed I have one right
here it's real hardware we built this in
my lab we laid out the board an
undergrad actually did a really awesome
job laying out the board I was impressed
it can not just monitor the program
state and the energy state it can also
manipulate the program state and the
energy state and we support all the kind
of conventional familiar debugging
operations like assertions and break
points on values or energy you know we
have an interactive show we have like a
Python library with interactive shell so
it's really easy to use we've kind of
tried to make it as simple as possible
so that you can really debug these
energy harvesting devices in the same
way that you debug normal embedded
systems so as for monitoring we have
access to all of the program state we
implemented a little a thin client
runtime layer that we can ask questions
of and then it sends us values back
and we can read the target energy level
which is nice because then we can
correlate those points in the program
that I just described identifying using
that client runtime layer with direct
measurements of the capacitor on the
device we can read I 0 msgs we can
actually decode things as they go by
through the i/o layer by capturing on
this board and then proxying the
communications out so we intercept and
then forward is one way of doing it or
we can passively just monitor the
communications as they go by so we can
grab I oh we can grab program state we
can grab energy and this is all passive
and it's all energy interference-free
I'll tell you some numbers at the end
but I think here we were like nano amps
of current and so if you think about two
ish volts this is a negligible amount of
power this is an amount power that
doesn't make any difference over the
long term just like why it's so cheap
look what what does that in the other
for it make it cheaper than long Aquinas
said why is it so cheap why is what so
shoot why is the ARIMA target energy
level and like reading program state
boys that's Chico's whoa all we're doing
is using the ADC on this board and we
don't need to use the agency on the
target board if we connect wires at the
right place and so that's why there's
this six pin header on the bottom here
if we pop this on to the header that we
designed to fit onto in our case we
target at the whist five because it's
kind of the most mature platform that's
out there right now then the pins that
we connect to their power read a power
they expose the power over a couple of
lines then we can read them oh yeah yeah
so this is us before would normally be
plugin I should have mentioned that yeah
we're continuously powered so we don't
get any interruptions so we have a
continuous you know you are connection
to a python console we can give commands
all the time and then this thing is
blinking on and off like it normally
would be in a thousand times a second or
something and we can reliably get state
out now say we want to do some more
expensive monitoring actions than just
reading the energy level or reading
target io or you know hitting a
breakpoint or something to do that we
need to be a little bit more
sophisticated we need to be able to
manipulate the energy level and what we
do is we lie to the target about what
was happening we can charge up to
compensate for energy that the target
uses
doing debugging operations so if there's
a whole bunch of kind of ad hoc
breakpoint like debugging operations we
assess how much energy that took and we
can top up the capacitor if we want to
go into an interactive debugging mode we
can just power the device record what
the energy level was power the device
and then go into you know arbitrary
debugging activity and then reset the
energy level to what it was before we
went into debug mode and we've
implemented all that and we can get
again it's a variation of kind of I
think two to four percent of our
capacitor is all all we kind of we the
area that we insert in the energy level
device so if you're operating and you
want realistic conditions where within
two to four percent so I'm nearing the
end of my talk here but there's a couple
of slides that I think are cool examples
of how you can use energy
interference-free debugging support so
say we have a program we want to insert
elements into a list and then we want to
do an expensive check to make sure that
the list is consistent so like each
elements next next pointers previous
pointers points to the element itself
this is a pretty simple list consistency
check well if we do that we might see so
these awful awfully colored Magenta's
circles correspond to the consistency
check happening if we have one element
in the list then maybe we do some main
loop work after we do the check for the
one element that's easy but then later
we had two checks here with two elements
in the list and then three checks here
and then we kill the device now we're
not making any progress in the main loop
because the assertion is toasting us so
if you want this kind of either beta
test or development time assertion
checking support to make sure your
program logic is correct you can't use
it the check itself is what's going to
kill you so instead what we did is we
use ed B's ability to manipulate the
energy level of the device continuously
power it then reset the energy level to
what it would have been and then do the
main loop work and so by running it on
continuous power we can make forward
progress under realistic conditions
despite the fact that we're doing these
invasive checks so the last thing is
we've integrated ed be with other
hardware so Tom mentioned earlier that
we're launching a satellite so the
satellite on one side has an
processor that has a magnetometer and
gyro we're going to send this into space
it's going to orbit the earth at 6,000
miles per hour and collect a bunch of
radio measurements but then on the other
side we have this essentially and this
is going to be operating as a beta test
diagnostics collection platform so that
we can monitor the behavior of the
system while it's winging around in
space under conditions that you can
really only get if you integrate this
hardware with your application and run
under realistic conditions it's not even
like we can emulate this in the lab I
mean we're going to be in space there's
going to be all sorts of wacky errors
there's going to be all sorts of
intermittently available energy as this
thing is tumbling and not in view of the
Sun so by integrating this together we
have a reliable test framework and we
can do this kind of realistic beta
testing and get useful information to
help us fix our application if it's not
doing quite we want so really excited
about space launch march 23rd is when
we're going to send it up yeah we
already shipped to the launch company so
assuming everything goes well and
there's no surprises along the way we
should be yeah in this guy at the end of
March so cool i don't know i can send
her out a link I'll center on a link for
sure so yeah that's that's pretty much
what I want to talk about today I wanted
to give you guys an idea about what
intermittent execution is and why it's
tough to reason about I showed you that
we have some system support for making
unreliable executions reliable despite
the intermittence and I hope that I
convinced you that debugging
intermittent devices is hard and that
this is a good way to do it and I have
these available if you guys think you'll
be using intermittently executing
hardware I can send you some devices to
we have a big bag in my lab so cool any
other questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>