<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taming the Quantum Tiger | Coder Coacher - Coaching Coders</title><meta content="Taming the Quantum Tiger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taming the Quantum Tiger</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/k5CFySG7Mjg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay I think we're going to get started
so today we have a mesh vazirani here
with us and I lost my last night there
we go so uma SH is a professor of
electrical engineering and computer
science at University of Berkeley you
cal berkeley and director of the
berkeley quantum computation Center he's
one of the founders of the field of
quantum computing starting with his 1993
paper with his student Ethan Bernstein
on quantum complexity theory he has also
worked on classical algorithms for
online ad auctions as well as graph
separators for which he was awarded the
2012 Fulkerson prize with sanjeev aurora
and also Satish route so today we have
you mesh and he's going to speak with us
about taming the quantum tiger which is
sure to be an exciting talk so let's
welcome wish thanks so thanks Krista so
I'm going to start by stating as nicely
as possible what I'll talk about and
then you know will and then then I'll
try to outline the main concepts of okay
so so no this doesn't work doesn't okay
okay so I'm sure you you all know you
know the thing that quantum computing
teaches us is that is that you know
unlike classical systems where an end
particle system requires only n
parameters to specify a quantum system
requires two to the N or exponential in
n parameters to settle specify so this
is of course great if you are doing
computation like quantum computation but
but there's a flip side to it which is
it also makes it difficult to analyze
and understand and control quantum
systems so so that's this is the part
that I want to talk about in fact
this this was maybe the early motivation
for quantum computing at least in
fineman's paper where the issue was how
do you simulate a quantum system given
that they are exponentially many
parameters okay so so just visually a
you know okay so so your state of n
qubits is a is a 2 to the N dimensional
vector lying in a 2 to the N dimensional
complex Hilbert space and so Knightly
you want to think about well could it be
that that natural quantum states
whatever that means sit in a small
corner of this Hilbert space so that so
that actually you could maybe have a
hope of understanding them computing
with them working with them and some in
some way okay and then there's a second
part about quantum mechanics that's
that's very problematic when you come to
working with quantum systems which is
which is this whole idea of measurement
that in fact what you can access through
measurement is not this entire quantum
state but only a small part of it so
when you when you measure you don't see
the superposition you only see X with
probability Alpha X magnitude squared
and we also know from Helios theorem
that we can obtain at most n bits of
information through a measurement no
matter how we structure the measurement
and so okay so there's a there's a
second question that that that's brought
up by by these limitations which is how
would you actually test a quantum system
given that it's exponentially powerful
and that you have this kind of limited
access to it and so so let me try to
formulate what that what that question
might mean so so here's a has a
particularly extreme version of the
problem so so let's say that we think of
a quantum system as being a being an
untrusted device and and then we model
the fact that we have limited I Oh
bye-bye actually making their the
input/output be binary because we may as
well
and so let's imagine that we have two
buttons on this box 40 and labeled zero
and one and two light bulbs labeled zero
and one and so this is the only way we
get to interact with the with the box
and so our challenge is you know what we
want to do is we want to verify that
this that this device really represents
the quantum system of our choice meaning
it it has the required dynamics it
starts in the required not specified
initial state and then you can actually
you can actually command it to go
through a certain kind of dynamics and
it does faithfully execute those so so
so if you think about it for a couple of
minutes it should be clear that this
this should be impossible right because
for example you know if you don't have
complexity considerations then then you
know this box could be doing a classical
simulation of a quantum device and and
then report dancer pretending to be
doing the quantum evolution and what we
care about here is that it should really
be you know the dynamics should be
exactly what we specify mentally so so
it turns out that that there's a
slightly different setting where in fact
you can do this and the slightly
different setting is one where you have
two such boxes and they share
entanglement but they are not allowed to
communicate with each other and so in
this setting in fact you can you know
there's a there's a form in which you
can you can achieve this goal of of even
though the devices are completely
untrusted but you know so they are
supposed to behave in a certain way and
you don't you don't trust it so you all
you can do is you can test whether they
do through this this small interface and
and the theorem says you can okay so let
me just say you know where this this
comes up let me give you a couple of
examples so so so the first example is
in quantum cryptography where you know
of course BB 84 you know going back to
nineteen eighty-four there was this
protocol for well that proposed that you
could use you could get
security for key distribution using the
principles of quantum mechanics and then
the actual proof that it achieves
unconditional security did not come
until about 15 years later Meyers and
show cresco but then you know despite
this proof of unconditional security
they were you know the the actual
physical implementations that people
have come up with have all been been
attacked and and in particular there are
these there are these attacks called
side-channel attacks you know of which
there was there was already a you know a
hint of it in the earliest
implementation of you know of quantum
key distribution then so this was one
where it was it was John Smolin and
Charlie Bennett who worked on a on a
tabletop device which you know with
Alice and Bob were about three feet
apart and and and it was unconditionally
secure except for the fact that you know
when when he was sending a one it it it
put a heavier load on there on the power
supply and so you could actually hear
the difference ok so so now so so Myers
and yao in you know about 15 years ago
put forth this challenge of di q KD
device-independent quantum key
distribution where where they asked you
know is it possible to achieve this kind
of security with devices which you don't
even trust so so in other words you know
leave aside these 5 channel attacks and
particular attacks but let's say that
you know you just don't trust the the
implementers of these boxes to do
anything right and you just want to make
sure in your protocol that that that it
is really secure so at that point you
could really call it unconditional
security so that that's that's one place
where this this could be useful I guess
another
Oh another application is of course you
know if you have you know if you if
you're building a quantum computer and
you know maybe you're not really sure
what what you've actually achieved and
how do you actually test it so so again
it's supposed to do something that you
cannot do so how do you test this kind
of device and and okay so so so let me
let me jump back to the first team and
then I'll come back to this this in a
little bit okay so so the first thing
was you know other quantum states which
we can which we can work with
efficiently and and so you know an
interesting class of states is ground
states of local hamiltonians you know
these these are states which could be
highly coherent at low temperature and
so you could you could sort of ask you
know if you describe a Hamiltonian a
local Hamiltonian where you know it's a
sum of local terms each of which is easy
to describe because it's it's local you
could ask well can you can you
necessarily describe the ground state
using only polynomial amount of
information and of course the the
trivial answer is yes you can I mean if
the ground state is unique then you can
describe it by just saying describing
the Hamiltonian and and then saying what
I mean is the unique ground state of
this Hamiltonian so that's a perfectly
good description but of course what what
we want is what is not only that we can
specify the state but we can also
compute interesting properties of it so
for example we want to compute the
ground energy or two point correlations
or other such things and I guess you
know there's there's there's a very
interesting emerging field quantum
Hamiltonian complexity which which
studies this these questions which are
the intersection of condensed matter
physics and
quantum complexity theory so so what do
we know about it so so what we know goes
back to kitaev I guess already at least
15 years ago where he proved that that
even approximating the ground energy of
a local Hamiltonian is NP akira may odd
so cure me hard is the quantum analogue
of NP hard and what we conjecture is
that you know that that there's not even
a sub exponential sighs classical
witness 4koma complete problems so
meaning that that if you wanted to if
you wanted to approximate the ground
energy of this local hamiltonian then
there's not even you know even if you
appeal to some some infinitely powerful
approver who you know they could not
write down a sub sub exponential size
proof that you could check so so it's
it's sort of it's it's the in a very
strong way of saying that the
exponential complexity is inherent to
this problem and then he could sort of
say well what about what about special
cases of this and you know so this
result has been improved to the point
where I guess in court has been in irani
showed that it's hard under some
assumptions even for translation
invariant 1d hamiltonians meaning you
have nearest neighbor interactions on
the line and and and the terms of the
hamiltonian are exactly the same just
just translate it okay so so this seems
to suggest that you know ground states
of local hamiltonians are just hard you
know even in the simplest cases but then
on the other hand if you look at what
people do in practice so about 20 years
ago Steve white came up with this
heuristic called the MRG which which
works which is extremely successful in
practice
for 41 d systems at least and so you
could ask is you know so it works in
practice but does it work in theory and
well the answer with the MRG is that it
can get stuck in local optimum but still
you'd want to know is there you know is
it could it be that you know how could
it be that that that you have so much
success in practice and and
theoretically the problem is completely
hard so you know surely there's some
principle phenomenon where where there's
some special case suitably formulated
where you can solve the problem in
polynomial time this is why the
heuristic might work you know going the
on 1d this is is a is a is a real
challenge and there's this beautiful
work by well by vestroia she rockin with
all giving you know methods of
representing quantum states of 2d
systems efficiently using tensile
networks where you can make and
manipulate them efficiently and and you
know so so so how successful this would
be going forward is you know it's not
clear but but it's it's really a you
know it seems like an extremely
promising direction for for a very
important area so okay so so coming back
to this 1d question so how can we
formulate a an interesting subclass of
1d systems which might be tractable so
it turns out that that the interesting
parameter here is the spectral gap so
it's the it's the difference between the
ground energy and the energy of the
first excited state and if you look
closely at these qma completeness
problems then they then they have a
spectral gap which which scales as one
over polynomial in n the number of
particles so so the scaling is you know
and then you know there's this
natural subclass which is the gap local
Hamiltonians which is where the spectral
gap is a constant so here this the
scaling is important so we have to we
you know we scale so that each of the
terms of the Hamiltonian has constant
norm say known one so so when he said
there's a constant gap it's sort of
saying so imagine that the ground energy
was zero then then the first excited
state has energy which is which is a
constant which means that it violates a
constant at least a constant fraction of
of one one of these one of these terms
right so or if you want to think about
the classical analog then make a
classical analog is satisfiability where
where if if the formula is is uniquely
satisfiable so so the ground energy 0
and then the first excited state well
you know you you if you don't satisfy
all the all the clauses then you must
violate at least one so the gap would be
at least one so so there's this
beautiful theorem that Matt showed about
five years ago showing that ground
states of one the Hamiltonians have have
have a polynomial matrix product state
representation and since you can use
this represented once you have the
representation you can compute energy to
point correlations everything
efficiently so so the problem is in NP
right for so fagged apt 1d hamiltonians
it's not really you know it's no longer
qm a hard it's it's it's actually an NP
so so then you could you could ask well
how hard is it to actually compute this
this mps representation mm there's some
sort of folklore that it might be
intractable in fact there was this paper
by ashok saraf canvas trata which showed
that a closely related problem is
actually np-hard which seemed to bolster
this notion that maybe maybe actually
computing these matrix product states
might be hot so I guess
last year we you know we are working on
improving the bounds in maths result and
and based on that we actually discovered
that that you could come up with a sub
exponential time algorithm for the for
the problem and then once it's our
exponential time you know it's unlikely
to be np-hard and so so it raises the
question well surely there's a
polynomial time algorithm and and so
very recently we came up with a an
actual polynomial time algorithm to find
these these ground states with Zeppelin
de palma vitac so so let me you know try
to outline some of these some of the
main ideas here in the next 10-15
minutes and okay so so of course you
know the main obstacle to to describing
quantum states succinctly is is
entanglement so you know if you have a
bipartite quantum state then we can
always write the Schmidt decomposition
of that state and so we have two
measures of entanglement here one is
just the Schmidt rank which is the
number of nonzero terms in the Schmidt
decomposition this is sort of this is
you know this is a crude measure of
entanglement and then there's there's a
nicer measure which is of course a phone
line and entropy which is which is a
classical entropy of these of the of the
CI Squared's so the CI squares are like
a probability distribution and you just
look at the entropy so you know so the
phone no I mean entropy disregards more
or less the very tiny coefficients and
and so in that sense it's a it's a
better measure of of of entanglement so
so the the key property of entanglement
with ground states is
this is captured in this conjecture
called the area law which which says
that for gap local hamiltonians so if
you look at the ground state of this of
you know of some hamiltonian which is
nearest neighbor on this lattice and now
you take the ground state and you you
sort of consider it as a bipartite
system so you decompose the particles
into this region and the outside and you
ask how much entanglement is there
between the inside and the outside so
naively what you would think the
entanglement would be bounded by there
by the volume of the region so the
number of particles but the area law
says that that it's proportional to the
to the surface area the number of bonds
you have to cut the in order to in order
to separate the inside from the outside
morally what the area law says is that
most of the entanglements it's near the
boundary and if this were true then you
know this would suggest that maybe you
have a sexing description where to
describe this quantum state you describe
the inside and outside separately but
then you also so what you have to do is
you describe the entanglement at the
boundary and then you can sort of
decomposed into the inside and the
outside and that's that's exactly what
the tensor network would allow you to do
so ok so i guess the this whole notion
of an area law my understanding is it
you know in in some kind of folklore
sense it has been known for a very long
time although it was it was actually
formalized in terms of entanglement
entropy only about ten years ago so so
you know as I said the area law is a
conjecture and and what what Matt did
five years ago is he actually made this
conjecture rigorous for 1d systems and
this was really a beautiful you know
really a remarkable paper so let me just
say what what an area law in 1d says it
actually
so you have a 1d chain of particles and
what an aerial or what is that if you
cut that chain somewhere then the
entanglement entropy between the left
and the right is proportional to the
surface area which in this case is 1 so
the entanglement entropy should be a
constant it seems like a very simple
statement but it's extremely hard to
prove and so what what what Matt showed
in particular is that the entanglement
entropy scales as exponential in log D
over epsilon where D is the dimension of
each particle and epsilon is the
spectral gap so the it's constant
because n doesn't appear anywhere here
and once you have this you actually you
know it implies that 1d ground States
you know this problem is in NP I'm sorry
what is the argument of the log oh it's
the you know so sorry it's log of d
divided by epsilon sorry yeah so um I
guess um you know Matt's argument used
heavy-duty tools that we didn't quite
you know even after sort of working
through them we didn't quite understand
them so we you know with with dori
tanita and zeph we be sort of started
working on trying to get a combinatorial
understanding of this and and so you
know through a sequence of papers we
last year we finally managed to show
that through combinatorial arguments
that that you could actually improve
this this bound from exponential to the
polynomial in log T or epsilon so log QD
of epsilon but in the process there was
this side effect that we actually
realized that you could get a sub
exponential time algorithm for finding
these ground states finding a matrix
product state representation
now there's there's one other there's
there's a certain sense in which in
which this bound is is is optimal so
it's optimal in the following sense so
if you want to try to prove an area law
for 2d systems well then it turns out
that there's no subvolume law known
known yet so this bound is optimal in
the sense that it's the hardest you can
work without proving anything non
trivial for 2d systems so in fact if you
you know if you could actually improve
this even a little bit to 3 minus Delta
you would you would get a sub volume low
42 these systems and if you could
whittle it down to all the way to log
squared then then you would actually
prove prove the 2d area law if you if
you if you know if you could improve
this to log D then in fact it would
prove their yellow for all you know in
any number of dimensions because you
just sort of fuse all the boundary into
one big particle and you know just just
peel off layers one at a time okay so so
let me say you know just one thing about
about you know the the main sort of tool
that goes into into approving this bound
and then I'll say a little bit about the
actual algorithm for finding finding the
ground state so so the you know the
proof of you know a proof of the area
law actually relies on this object we
call the AGS be an approximate ground
state projector so so an a GSP as an
operator that that when you apply to a
state it it leaves the ground state
alone and it takes the anything
orthogonal to the ground state and it
shrinks it so that if you have a general
state it sort of gets projected closer
and closer to the ground state
apply the this operator so so this
operator itself we want to properties of
it you know so one is of course it
shrinks the orthogonal space by by a
factor of Delta but then the other thing
we want is that it doesn't increase the
entanglement rank across this boundary
by very much so you have to construct
this this operator carefully so that so
that it has a good trade-off between
between D and Delta right so if you can
make sure that that the shrinking
happens faster then the entanglement
rank is is is is accumulating then in
fact we can prove an area law and and
the way that this this operator k is
constructed is by taking the hamiltonian
and coming up with a low-rank
approximation to it right so so it's
rank is initially as high as the number
of particles and we sort of Whittle it
down and get a lower lower rank
approximation and then and then the
operator case is a law degree polynomial
in that new operator in that in that
modified hamiltonian and ok so so so the
degree of that polynomial somehow
corresponds to their increase in
entanglement drankin and the fact that
it's a approximation to the hamiltonian
make sure that it's cutting down go the
orthogonal space let me just say a
little bit in these terms about you know
about this this whole idea about the
algorithm for finding finding finding
the ground state so so so here's you
know if you want to think about it you
know where did the NP hardness result
about finding finding a matrix product
state representation of of the of the
ground state come from so they start
with a gap 1d Hamiltonian and now one
way to think about it is this gap
condition you know how how do you make
use of it it's it's really hard to you
know understand how it relates to the
ground state and you know one way you
can say as well Matt did all the heavy
lifting and he showed that there's a
sexy enough the ground state and now we
have nothing else to squeeze out of the
fact that there's a there's a there's a
gap so let's throw that away and let's
now start with the assumption that we
have a we have a sink matrix product
state representation and now can we find
it efficiently that's what they showed
was np-hard okay so so the way you get
further is you have to take the gap
condition and you have to squeeze it out
further and and the the way you do that
is you say well the gap Hamiltonian
implies that there's an AGS be and now
we have got to use this a GSB further in
order to actually find this extinct
description so that's what we do okay so
so let me describe to you how at a high
level how this algorithm works so so
remember we are trying to find find find
the this the ground state of this local
Hamiltonian H now one way we could find
the ground state is we could just write
a semi definite program so the semi that
program would just say something like
this minimize trace h ro so Rho is a
ground state subject to well row is
positive trace one okay but now if you
look at it this is this is a semi
definite program of an exponential
dimensional space and so exponential
time so what what can we do instead well
suppose that I could give you a small a
polynomial dimensional subspace which is
which is guaranteed to contain a good
approximation to the ground state and
moreover I tell you you know this
polynomial dimensional subspace is well
specified in the sense that I give you a
basis for it and I show you how to
represent the basis vectors efficiently
so you can do linear algebra on them
well then then you could you could just
say well this this particular SDP is
doesn't sit in an exponential
dimensional space it only sits in this
polynomial dimensional space so let's
solve that and there there you have it
you have your your your ground state ok
so so
additional constraint about the
the quality of approximation has to be
good that's right that's right that's
right so why in the additional
constraint of the spca yeah that's right
soso or on this or on this envelope so
so we are going to make sure that that
that this the space is such a fishery in
the progress that's right that's right
yeah so so now how do we actually design
this this algorithm so so here's the has
a first step so let's let's go back and
look at the classical case so so in the
classical analog you have 1d one
dimensional satisfiability or one
dimensional constraint satisfaction
problem and now what makes that easy is
that is that you can do this
decomposition of the boundary right so
you can you can sort of say let me
assume that the value for this
particular variable is three right and
now because the because all the
constraints our nearest neighbor i can i
can now decompose the problem into two
parts the left problem and the right
problem and they can be solved
separately right so if if if there were
these subproblems if each variable took
on D values then this will just give
rise to d sub problems and in particular
what you could what you could do is you
could now solve this problem using
dynamic programming working your way
from the left to the right you know each
time adding one more one more particle
and the the key point is that you need
to only keep the optimal left solution
for each of the D values at the boundary
so so for each each you know if you want
to extend this left solution by one you
look at every possible value at the next
boundary position and compute the
optimal value so now we want to do
something similar in the quantum case so
so how do we do it so the first thing we
need to do is figure out what's the
analog of of you know of assuming some
value for the boundary right so of
course now it's not just the state of
this boundary particle because
there may be a lot of entanglement
between the left and the right so the
natural analog is what what's called the
boundary contraction it's roughly the
density matrix that that describes the
state of this particle and the bond
between the left and the right and so so
so what's the dimension of this this
object well it depends upon the bond
dimension right it's if the it's the
bond dimension of the matrix product
state that describes you know which is a
good approximation to your dear ground
ground state so furthermore since since
we you know since this boundary
contraction is now a continuous object
we need to discretize it and so we
actually discretize it while we are in
epsilon net okay so so now the
cardinality of this epsilon net is going
to be exponentially in the bond
dimension and so you know in order to
get get a good approximation to the
ground state of 1 over N 1 over poly an
approximation to the ground state you
would need you would need the polynomial
bonbon dimension or even to get a get a
constant approximation to ground state
as far as we know you would need a
linear bond dimension at least and so
this gives rise to exponential in that
so the epsilon net is exponential in
that and so the number of subproblems it
comes to to the order n okay so the way
we got the sub exponential algorithm is
we realize that in fact you don't need a
linear bond dimension you can get by
with with bit something smaller you can
get back with something like 2 to the
log to the two-thirds of em and so so
exponential in that and that we serve
exponential and so that that's how you
get the improved algorithm but now we
want to we want to actually get a
polynomial time algorithm so we can't
afford to to do all this so so what's
the next idea so the next idea is well
we can achieve constant area you
using a bond dimension here of only a
constant so in other words we can get
constant you know so so we can we can
come up with a matrix product state who
is born dimension across a particular
bond of our choice is constant and bond
dimension across every other bond is is
n or polynomial in N and so if you want
to cut this bond you can make sure that
it has constant bond dimension and then
the epsilon net will have only
polynomially many elements and see how
you know polynomial time except now you
have introduced constant error each time
you fix one of these bonds the N bond so
you can't afford this kind of error so
we've got to somehow drive down the air
and the idea is we can now use the a GSB
to drive down there so so you know the
number of subproblems we have to search
through is small but then we can use the
a GSB to drive down there and hopefully
that will that will work you know once
you think through what it means to apply
this a DSP to well of course if you had
if you had a complete state then you
could apply the a GSP to it and that
would there be no problem it would it
would it would project it closer to the
ground state and so it would reduce
error but now remember we don't have a
the complete state we only have this
left state so how do we apply this
operator to adjust the the left half of
the state so well what you have to do is
you have to take this take your operator
and decompose it across this cut so you
write it as a sum of products and and so
what what you end up doing is writing it
as a as a sum of polynomial e many terms
of this form and you have to apply each
of these ages to the left state so so
what it does is it takes you know it
takes the dimension of your subspace and
it and it increases it by a polynomial
factor and of course we can't afford to
have this polynomial increase at every
step but this is where this approximate
decoupling comes in right remember that
for for every you know for every element
of the boundary contraction we only
needed to keep the optimal
state on the left so so what we do is so
so we are now alternating between these
two steps you know one which cuts down
the number of elements the the other
which reduces the error but proliferate
the number of elements and so we just
keep going back and forth between the
two okay now this gets a little
complicated because also in the in the
process what happens is the complexity
of our of our of our state's goes out so
remember what you're keeping track
officer is a basis for this subspace and
we've got to describe the basis elements
explicitly as matrix product States to
say well we have a sexing description
for each of the each of the states in
our in our basis so as we do this
process the complexity of those elements
goes up you know the bond dimension goes
up and so we have to cut that down as
well so so basically what we're doing is
you know each time we extend the number
of particles by one they do these three
steps where we where their reduced error
reduce the bond dimension then we then
we use approximate decoupling to reduce
the hood bit dimension and then we just
keep going on in okay and then of course
by there by the end of the process we
have this polynomial dimensional space
for the for the whole thing which is
which is guaranteed to contain an
approximation to the ground state and
then we can we can solve the SDK and
that's that's the solution
okay so so let me just say a word about
about this algorithm so so as it stands
this you know you know one way you can
think about this is it's you know to
just as an analogy you know we had this
simplex algorithm for linear programming
which was fast in practice we didn't bet
it but in theory we didn't know and then
there was this you know the ellipsoid
algorithm which was which was probably
polynomial time but nobody would ever
dream of implementing it so you know
probably that's the way to think about
this this is you know it shows that it's
polynomial time in in theory but but
this is not the way you want to
implement it but now you could ask can
we actually make this faster and and it
seems like there should be local
versions of this algorithm at least
using a GSP's and this is what you know
where they thinking about and the other
thing you could ask is well now that now
that we know how to prove things and 1d
can we actually do anything provable
into the you know and again these are
these are interesting questions to think
about okay so so let me come back to
this to the to the second theme that I
talked about way of controlling an
untrusted quantum device so so so this
is work with the been ricart and anger
from you know which was published
earlier this year where where the
picture we had in mind was a there's a
there's a classical experiment list who
is confronted with with untrusted
quantum devices and and we are
considering the extreme case where we
have we trust nothing about these
devices at all they're black boxes with
binary inputs and outputs entangled and
now we want to we want to you want to
make sure that the initial state and the
dynamics are exactly put what we'd like
so what's what's the problem with doing
this so so certainly the hilbert space
of
device could be very large but then
within that we know what the you know
what these devices are up to so for
example when we when when we issue a
command saying measure this qubit right
how do we know that the the classical
bit that's reported is even the result
of measuring a qubit right I mean it
could be it could be a more general
measurement on the on the system it may
not be compatible with a qubit at all so
this is sort of the the most basic
problem in getting started on this and
so okay so the the way to deal with this
is to appeal to you know the starting
point is is this is Belle inequality or
the CH SH game which is which you can
think of as a test for quantum Ness
right so in a in a very simple setting
it's it's it's a place where a classical
experimentalist can can at least test
that that quantum devices have some
quantum Ness to them so so what's the
test it's you know it doesn't really
matter the details but but but each of
the devices which we in in this game we
call Alice and Bob get has input a
random bit X or Y and then the output a
bit a and B and they're trying to
satisfy some condition which again it's
not so important but they are trying to
make sure that the that the sum or two
of the output bits is is the same as the
product of the input bits and it's easy
to see that classically the best you can
do is is seventy-five percent you'll be
correct on 75 percent of the inputs for
example by always outputting a equal to
be equal to 0 so as long as x and y are
not both one you get the right answer if
Alice and Bob share a bell pair then
they can achieve a success probability
of 0 point 8 5 cosine squared PI by it
ok so so now how do they do this well
this there's some strategy for doing
this which in more
was you know depending upon X but at 01
Alice measures her cube it in the bell
pair and one of two bases and depending
upon why Bob measures history of it in
one of two bases so so there's some
optimal strategy which achieves cosine
squared x by it ok and you can do no
better so the first step in improving
our theorem was was proving this
rigidity theorem for for CH SH games so
so so remember Alice and Bob the hilbert
space is not bounded right it it could
be anything so now what the rigidity
theorem says suppose we actually play
the game with Alice and Bob and suppose
that they win with probability close to
cosine squared PI by eight so cosine
squared PI by eight minus epsilon then
the theorem says that they must share a
bell state or close to a bell state
actually so their initial state must be
must be the following it must be square
root of epsilon closed in tres tres
distance to a bell state tensor product
with everything else so so it doesn't
matter what the rest of their state is
it's an tensor product with this Bell
step at least up to up to whatever level
of approximation and then uh you know
end up to some unitary change of basis
on each side right so you you ok so now
once once you do that then you can also
say that in fact they must perform their
measurements ording to the CH SH
strategy that I outlined before so they
must do exactly what I deal strategy
says on this you know once you change
you know once you change the the
individual basis to make everything look
right ok so so this gives you a measure
of control just by just by testing you
know this this fact so now on the next
step involves actually showing that
suppose we play a sequence of CH SH
games so we just do this sequentially or
over and over again
then what we can say is that if if the
device is win with close to again cosine
squared PI by eight they've been close
to that fraction of games so in the
previous case I talked about the
probability of winning which we cannot
really you know how do we know what that
probability is but now we are just
playing a sequence of games and we just
look at how many be been so if you've
been close 2.85 fraction of the games
then they must share you know then then
they must share n you know close to n
bell States intensive product with the
rest and they must perform these ideal
CH SH measurements okay so let me say it
a little more precisely you know this is
sort of a rough statement but the what
the more precise statement says is
suppose you play you know polynomial in
n number of games and then at some
random point you stop and you say ok so
you know is is the number of games that
are one close to cosine squared PI by it
if yes then then then you can say now
the rest of the state that that Alice
and Bob share is close to you know is
close to a tensor product of Bel States
and whatever else and then and the next
end games that are played they must play
it in this way according to the ideal CH
SH strategy right so you can you can set
up a situation where you are pretty
pretty sure at the at the start of a
certain point that they are going to be
doing exactly what you say in this in
this restricted space so now you know
once you once you have have them doing
something that you want you have them
over a barrel right you can you can now
get them to do exactly what you want so
so you can use tomography to leverage
this multi game rigidity theorem to
force them to do exactly what you want
you know by creating resource states and
doing computation via teleportation so
okay okay so um okay so you know as I
said before there's you know there are
various things you could you could use
this for so one of them was
device-independent quantum key
distribution so that follows easily once
you have this kind of structure theorem
you know you now don't have to trust the
devices you have belt pairs you can just
measure them and when once you've
established that that's true but there's
a problem there's this polynomial
overhead and and it doesn't you know
there's no error resilient so you really
have to work through this separately to
to do something so in fact you know
earlier this year tama vedic and i
should be a different argument that that
in fact you can modify our auto Eckert's
protocol from i think back in 92 to get
one that's device-independent provably
device independent and this particular
modified version actually achieves a bit
rate which is within a factor of two of
what's optimal even with our device
independence so it's really getting up
there in terms of um the other task was
testing that a game quantum computer is
really quantum so so actually our
results were inspired by these two
papers of RN or Ben or Andy bond and
broadband fitzsimmons and Kashif II
where they considered a slightly
different setting where where you have a
classical verify but but this classical
verify is given a little bit of a boost
so this class classical verify can also
manipulate a small number of quantum
bits and and shares a you know this
small narrow quantum channel with the
with with approval so now there's only a
single prove or single experiment that
and then there's of course a classical
channel which is you know where they can
communicate as required and so you know
so these small number of qubits can be
exchanged back and forth you know of
course of course the
the prover can build up you know a
reservoir of qubits in the process and
they showed that in fact in this model
you can you can verify any quantum
computation at all yeah so here the way
it's defined is let's say that you have
a quantum circuit in mind and what you
want is that this quantum computer
should should on input X apply this
quantum circuit to X and report output
and and in fact the verify can can be
satisfied if all the tests you know if
all the tests are past that that that in
fact that particular circuit got applied
to X with very high probability and and
output what's really genuinely what
would result this is the referee
probabilistic yeah yeah so so you're
sampling from the output distribution
from you know very close to the correct
distribution okay so so you know one
could be even more ambitious than this
and one one might say well what we'd
really like to do is you know we'd like
to come up with with with a general way
of testing quantum mechanics so so you
know you could take this viewpoint that
you know that this this exponential
growth in the you know in complexity
this is you know this is probably the
most counterintuitive aspect of quantum
mechanics and then you you know you you
take the view that one thing that this
is like to do is test their theories in
you know in the limit of its
applicability like you know high energy
or very small sizes or close to the
speed of light and each time your test
in these limits you
discover something new so what about you
know is it shouldn't we be testing
physics in this limit of high complexity
and then you run into sort of what seems
to be a basic problem which is well if
you if you want to test in these in this
hell in this limit of high complexity
then how do you even you know how do you
even know what your experiment will will
do you know you want to so to set up the
experiment you want to first calculate
what the result should be in and that
that would in general be a problem so so
what you you know so so a general way to
deal with this is you you would want to
come up with some sort of an interactive
experiment instead of the usual style of
experiment where where you know where
you think of the classical verify as as
carrying out an interactive proof with
the with their practice and what we want
to know is is is it possible that you
know in the spirit of interactive proofs
that that that a quantum polynomial time
time prover can convince a classical
polynomial time verifier of any you know
of any language in in b QP and purely
classical yeah yeah that's that's what
we'd like eventually right so so now of
course you know what what we know is
that interactive proofs are as powerful
as P space and P space contains quantum
polynomial time so would seem that
bounces trivoli yes but but of course in
order to get IP equal to P space the
approver has to be as powerful SP space
and here we only have approval who can
do quantum polynomial time computation
and and so that's that's really that's
really an open question that's okay so
in a sense we don't we don't even need
for this to be a single prove it could
be to prove us you know you could set up
two experiments that don't communicate
with each other
so you could ask well why doesn't the
result that I just showed why isn't that
sufficient to to to to solve this
problem well the point is that in in
order to in order to prove correctness
of that result we had to make use of
properties of quantum mechanics so you
know so maybe it gives you a weak
version of this but but to really claim
this what what you need to do is you
know there are two sides of this you
want you need to say well if you know so
so in interactive proofs you have this
two-sided thing right if if X is in the
language then then there's something
that the prover can't say which
convinces the verifier and then there's
a flip side to it which says if X is not
in the language then no matter what the
prover does it won't convince the
verifier except with very low
probability right so that has to be
unconditional that second part has to be
unconditional and for us that second
part depends upon well it depended upon
CH SH and so on right so so so at least
that part of quantum mechanics has we
have to rely on for their for the new
answer and getting that no answer
unconditionally I think is a very
interesting question I'm sorry if you're
willing if you are
yeah even then the trapeze I'm sorry how
helpful and we don't know so so even
there you know making it unconditional
unconditional bail on so so I think
these are so certainly there's a there's
a big technical problem here you know in
terms of well what's the one prover
system b QP banded capable off but then
but then you know once you once you try
to say well how about how about a small
amount of quantum ness and so on and
then there there there's a real question
about how do you formulate the problem
and you know and that that becomes quite
quite difficult i should finish up in a
couple of minutes or so let me let me
just wrap it quickly the last slide and
then i'll just say a cup mom maybe I'll
okay so so there's this you know there's
a very fundamental test in in classical
complexity theory called the classical
multi linearity test which is which is
sort of a major component of of the PCP
theorem and what it is is you know you
you're told you're you're given access
to a linear multi linear function let's
say and a linear function on many
variables but but you don't trust that
it's actually a linear function so how
do you can you can you sort of quickly
with very few probes tell that the
function that you're actually probing is
very close to multi linear function so
this is a very very fundamental building
block in the PCP theorem so it goes back
to blonde blue be Roman pro now this
quantum multi-game rigidity theorem this
gives you a similar you know a similar
object in the on the quantum side
because because what it allows you to do
is through these very simple tests which
are the CH SH tests it allows you to to
verify that there's an object which
belongs to a certain class which is like
the multi linear functions here it says
up to some
unitary base change of basis you you
know the state is a is a close to a
tensor product of Bel states with
whatever else and then you also get this
this condition that that you know the
measurements must be according to
exactly these these conditions so it's
it's sort of an analog of off of this
multilinear editor since it's sort of
interesting to see how much further one
can push these sorts of ideas I should
say that there was a there was a
beautiful reason recent result by
tsuyoshi toe and Tom oolitic showing
that this classical multi linearity test
also extends if you have quantum provers
so here the object that they share you
know if you do this this particular test
you can show that in fact they don't
share quantum object the quantum object
must essentially be this classical until
neit test ok so i'm so let me just
finish up by saying some of the things
that i talked about today you know these
is this general topic we organizing i
guess matt and the written and Frank and
I are organizing this program and the
Simon's Institute and Berkeley spring in
this coming spring you know with with
this focus on quantum games and
protocols and area laws and hamiltonians
and tensile network simulations etc so
you know if you are interested please
let us know and come and visit us so
there's a there's a there's a long list
of people who are already committed to
coming so it would be it should be a
nice party and you should come join us
and hopefully by the time you arrive the
you know our building will be habitable
and so
okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>