<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hints and Principles for Computer System Design | Coder Coacher - Coaching Coders</title><meta content="Hints and Principles for Computer System Design - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hints and Principles for Computer System Design</b></h2><h5 class="post__date">2016-07-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UIasWKh8kiI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this talk is a update of a paper that
I wrote 30 years ago which was just
called hints for computer systems we've
learned a few things in the last 30
years so now it can der a few principles
along with the hints but the hints
remember it's still mostly hints and the
hints are only suggestions so you don't
get to nitpick them if a hint isn't
helpful to you in your particular
situation then you should just ignore it
there are a lot of different ways to
think about things that are important
for building computer systems and for
this talk I've picked two of them you
can think about it in terms of what the
goals of the system are and of course
I'm not going to talk about um the
specific functionality you're trying to
achieve in your system instead I'm going
to talk about more general goals such as
making your system simple timely
efficient adaptable dependable and then
someone pointed out to me several years
ago another very important goal in the
modern world where computers live in the
real world not just in machine rooms in
many cases it's important to make your
system yummy
so that your customers will really want
it and of course you know today the
master builders of yummy systems are
Apple but there are many other examples
where people have been fairly successful
making Madison as a major goal so the
goals what it is you want to achieve are
one dimension that I want to talk about
and the other dimension is the how the
methods that you might use for achieving
these goals and I've organized those
under three headings approximate
approximate do things incrementally and
divide and conquer and so we end up with
the slogan steady buy aid which might be
helpful to you in remembering what all
these things are so goals first there
are six
are you you might want your assistant to
be simple you might want it to be timely
that is get to market before the
competition you might might be important
for it to be efficient adaptability is
often very important many systems have
to be dependable and I said a few words
about yumminess and compared with 30
years ago I think three of these six
goals are new there were things that you
didn't worry about too much when you
were building a computer system thirty
years ago and the other three are the
same and all together it adds up to
steady and of course it's important to
bear in mind that all right you have to
this one you're building a system you
have to decide what's important to you
you're not going to be able to achieve
all of these things Engineering is a
matter of making choices and making
well-judged
trade-offs on the house side methods for
building systems I've organized about
three-quarters of the things that I know
about how to build systems under these
three headings you do things
approximately you build systems that are
good enough not perfect you build
systems with loose specifications you
use lazy evaluation or you do things
incrementally you compose big things out
of smaller things you do things
iteratively one step at a time and you
build systems to be extensible and third
in the ade acronym but most important is
dividing Kaguya conquer you design your
system with abstractions so that at any
given time there are views of the system
that you can actually understand and
most of the complexity is masked behind
the abstractions and there are the
techniques that I'll talk about a little
more when we get to there before I start
in on the details of the steady goals
and the aid methods I just want to say a
few things it cut across that one of
them is that it's often very helpful to
think in terms of of opposition's
I'm the most important opposition that I
know of is the difference between
precise what I call precise and what I
call approximate software precise
software is software that actually has a
spec even if the spec is not properly
written down and if the system doesn't
meet the spec the customer will be
unhappy so banking systems and avionics
systems and things Microsoft Office are
that if you drop a single character out
of a Word document
or change a single number in an Excel
spreadsheet the customer will be unhappy
in fact in fact many of you perhaps
remember the giant flap that was caused
when it turned out that occasionally an
Intel Pentium chip would give the wrong
answer and division and they ended up
having to replace half a billion dollars
worth of Pentium chips because that was
a precise system approximate software is
a very different matter the important
thing is to get it soon and to make it
cool so web search shopping Twitter
these are approximate things if you get
the wrong answer a few percent of the
time it doesn't really matter it's not
that one kind of software is better or
worse than the other the important thing
is that they're different and and if
your judgement about what kind of
software you're building is wrong then
you're going to waste a lot of time and
energy or you're gonna have unhappy
customers and so it's very important to
understand what kind of system you're
building another set of opposition's is
very very closely models the the goals
that I sketched out before their
opposition's among having features time
to market speed cost dependability and
coolness and I found a way to turn all
these things into words that start with
F in English so there's there's
opposition's among being fancy first
fast frugal faithful and fun and again
it's not that one of these things is
necessarily better or worse than another
but you have to think about what kind of
trade-offs are going to make is the
system correct does it run will it sell
can it evolve and there are many other
opposition's
then that I could talk about another
important overarching consideration is
the question of coordinate systems and
notation often if you choose the right
coordinate system your life is going to
be much easier than if you choose an
inappropriate one think of it as being
like center of mass coordinates for
simple dynamics problems in physics or
eigen vectors for matrices if you wrote
if you rotate the coordinate system so
that the axes are lined up along the
eigenvectors then it's much easier to
understand what the matrix
transformation is doing then if you use
a different coordinate system
my favorite example here is the
difference between the system stay
viewed as being in the system state
viewed as becoming that that is the
difference between the state as the
values of a lot of variable named
variables and the state viewed as the
sequence of operations that you did to
get from some initial state to where you
are now so for example in the case of a
display it's the difference between the
display as a bitmap and the display as a
display list that says how to construct
the image its redo and undo logs in
there using database systems or an
example of viewing this data is becoming
rather than as being and so are
replicated state machines that are used
for building fault-tolerant systems
another example of different coordinate
systems is the difference between
viewing the function as a piece of code
versus viewing it as a table versus
viewing it as an overlay of one function
one partial function on another closely
related to the idea of choosing the
right coordinate system is the idea that
you should use a good notation that's
well suited to your problem and notation
has three aspects there's vocabulary the
types and methods that you that you have
at your disposal
there's syntax and domain-specific the
success of domain-specific languages is
a good example of how
choosing an appropriate notation for you
your problem can have a big payoff and
then there's the primitives that you
have at your disposal and the third
overarching thing I have to say is if
you're building a system write a spec
this is extremely unpopular advice for
programmers programmers hate to write
specs they like to jump in and and start
writing the code in my experience I've
given the whole story of how you can
write spec specs and do correctness
proofs on this slide how much of this
story it makes sense to use in your
particular system dependence I on how
complex the algorithms are and how
important it is that your system do the
right thing every time but at least for
n every just about every system you
should write down the state you should
write down the abstract state of the
system so for example the abstract state
of a file system is it's a map from path
names to byte arrays there's all kinds
of implementation complexity underneath
that but that's the abstract state
that's what that's what the system is
doing and the next step in understanding
what's going on is to write down the
interface actions and then I've sketched
out how you actually go about doing
correctness proof we won't go into that
here but writing down the state always
has a huge payoff and you can see that
people typically don't do it if for
example you read the typical MSD and
documentation for our software Microsoft
software usually you will search that
documentation in vain for a clear
understanding of what the state of the
system is that's being described and it
makes it very difficult to understand
what it is that's actually going on okay
so I'm going to talk about the goals and
then I'll talk about the methods just to
remind you of the the acronym for the
goals is steady were simple timely
efficient adaptable and dependable and
yummy and I'm not going to talk anymore
about yummy than I already did but I
would we'll talk about all the others in
some detail so simple why is it so
important for your system to be simple
well you sort of all we all sort of know
the answer it's because we can't do much
Computers can generate far more
complexity than we can deal with very
quickly quickly
and whenever you're building a system
you're struggling against this demon of
complexity being simple is hard and
often it's not rewarded because if you
figure out how to do something in a
simple way your colleagues will say oh
that's obvious two or three years ago I
was at a conference where there was a
session chaired by Tim berners-lee on
things that perhaps should have been
done differently when the web was
started and about a dozen things were
proposed during this three-hour session
and Tim himself proposed a couple of
them and my conclusion sitting there and
listening to it was that in every single
case Tim had made the right decision by
not adopting this feature because every
single one of those things would have
made the system the web more complicated
and thus would have made it less lei
likely that it would actually be adopted
of course the web is not simple anymore
once it's caught on then it's okay to
elaborate it and the only price you pay
for that is horrible security which is
what we have an interesting it's an
interesting question why computer
scientists didn't invent the way and I'm
quite convinced that the reason for that
is that it's too simple and if Tim had
described it in a paper and submitted it
to a computer systems conference it
definitely would have been rejected on
the grounds that it was wildly in the
faith in officially and didn't have any
new ideas in it and all kinds of other
spurious reasons when is it simple
enough well it's simple enough when you
can still understand it but then you
have to think about what's going to
happen as the system evolves it's going
to become more complicated and pretty
soon you won't be able to understand it
anymore and then one well only
abstraction and interfaces can save you
in that case okay what about timeliness
the basic point here is you have to keep
keep it real you have to have a good
sense of what it is that your customers
actually need and and not over-engineer
near not try to build something that is
more elaborate than what's really needed
in many cases
you don't actually know what the
customers need and they don't know I do
if you look for the most part I'm not
gonna say anything about the quotations
at the bottoms of the bottom of the
slides but but this one at the very
bottom of this slide is really important
the users exclaimed with a laugh and a
taunt
it's just what we asked for but not what
we want the only way you're going to
find out whether the use what the users
actually won't want is to give them some
things and see what they do because the
users are not paid to explain to you
what they want they're paid to do their
jobs the most important aspect of
timeliness I think is that good enough
is good enough why is the web successful
it's successful because it doesn't have
to work and it doesn't work a
significant fraction of the time you
know somewhere between 110 percent of
the time you click on a link and the
wrong thing happens probably four out of
five times if you click on the link
again the right thing will happen and
one out of five times the wrong thing
will keep happening and then in China of
course it's worse because you also have
the Great Firewall but but even if you
don't have the Great Firewall
this is just the way the web is and it's
yeah it's a vital component of its
success another aspect of this is even
aside from clicking on links many errors
are just not fatal
you can retry you can undo a mistake
well it just doesn't matter much all
right
if you're a customer of Amazon's for
example and you look at Amazon's web
pages with some care you will notice
that frequently there are mistakes on
them they'll tell you the wrong thing
about what it is that you looked at
recently or they'll make recommendations
that don't make any sense or whatever
Amazon has optimized for timeliness and
yumminess over correctness and that's a
good optimization
efficiency this is something that people
used to obsess about in building
computer systems and there was an
important reason for that namely that
often it was a big challenge
yeah squeeze the functionality that you
wanted to have into the hardware that
you could afford nowadays there
certainly are still cases where where
that aspect of efficiency is extremely
important but there are many fewer cases
that like that then there ought to be
then there used to be in a great many
cases if fish quote efficient unquote
use of the hardware is not really that
important because yeah you met the
demands you're putting on the hardware
are quite minimal and so it's important
to bear in mind that there are two
aspects of efficiency there's efficiency
from the point of view of the
implementer and there's efficiency from
the point of view of the client and of
course they're not unrelated the client
doesn't want to have to spend a lot more
money for the computer then it might be
necessary but they're also trade-offs
there another aspect another thing to
think about in connection with
efficiency is that there are different
kinds of efficiency and it's important
to understand which aspects of
efficiency are important for you and
your customers it's the most important
thing thing is the people cost to
administer the system then you have to
do standardized and do a lot of
automation of system administration and
people have been learning how to do that
in the context of cloud computing this
is something something that used to be
very much neglected if the most
important thing is the cost of the
hardware that you need to deploy in
order to provide a stable service then
you have to write tight cloud and code
and perhaps use clever algorithms if the
most important thing is the non
returning engine non-recurring
engineering cost and the time to market
then you should use big off-the-shelf
components burn hardware resources and
make sure that you have what you go
build is just good enough not perfect
adaptability this is another one of the
things that didn't used to be so
important it used to be the systems were
built for a particular purpose they
lived for a fairly limited amount of
time a few years years during that time
the load on the system
change that much and they kept doing
more or less the same thing that is not
today's world in today's world every
aspect of the environment in which the
system lives changes a great deal
successful systems and successful
systems live for a long time machine get
machines get faster the load on the
system increases features get added and
the basic system designed him has to be
able to accommodate has to be adaptable
enough to be able to accommodate all
these changes it's a very impressive
feat of Engineering that the internet
and the web were able to grow from a
hundred sites to a billion I've sketched
some of the most important aspects of
adaptability the most important one
probability probably is being able to do
incremental updates because big things
by their nature change only a little bit
at a time so it's very important to have
extensibility and to have incremental
algorithms and fault-tolerance is
another big aspect of that and finally
there's dependability system is
dependable if you don't have to say I'm
sorry
and of course classically dependability
has three aspects you want your system
to be reliable that is you wanted to
give the right answer you want it to be
available that is you want it to give
the answer promptly not next week and
you want it to be secure which is that
it works in spite of the fact that there
are adversaries trying to keep it from
working the most difficult aspect of
dependability I think we know how to
build arbitrarily dependable systems
that not not trivial but relatively
modest modest costs the question is how
much do you want to pay how much
dependability do you need and that's
something that more dependability is not
necessarily better a few years ago the
British railways had a couple of crashes
in which people were killed and after
that they put in place a big safety
program and it's been estimated
that the cost of that program per life
saved has been been on the order of a
billion dollars and it seems pretty
clear that that's not a sensible way to
spend your money because there are many
ways to save lives by spending much less
than a billion dollars per life saved
and that was done for political and
public relations reasons but for me any
sort of rational economic analysis it
just doesn't make sense the u.s. phone
system used to be much more dependable
than it is now in fact it used to be
much more dependable than the market
demanded and the reason for that was
that the u.s. phone system used to be
owned by a single company and that kind
of companies was regulated by the
government and the basis of the
regulation was that they could earn a
certain percentage on the capital if
they had invested so from their point of
view investing more capital is better up
to the limit where you can no longer
persuade the regulator's that it makes
any sense so they built a phone system
that was far far more today but
dependable yeah then any customer demand
but they didn't have to worry about that
that since the customers didn't have it
anyway there was no alternative for the
customers they couldn't go to a
different supplier and pay less and get
it a less dependable system and the
advent of cell phones of course just
completely changed that yeah okay so
that was that was the steady part that
was the goals now we'll talk about the
how part how do you how can you achieve
these goals and I've organized these and
as I said before under three categories
approximate approximate incremental and
divide and conquer and divide and
conquer is by far the most important of
those I look looked very hard for an
acronym that began with D but I could
not find one so divide and conquer has a
number has a number of aspects you can
do the division in in many different
ways
the most important aspect is abstraction
and interfaces yeah and the way to think
about this in this context is this is
dividing by debt differently in the
different parts of the system
and the basic motivation for this is to
limit the complexity and live liberate
the parts so that each one can evolve
yeah independently of the others but the
classic examples of this from computer
systems in the lab last 30 years have
been the tcp/ip protocol that underlies
the internet the design of file systems
for operating systems and the design of
the HTML web data representation and
each of these has had the property that
because the interface is well-defined as
carefully designed well defined and
changes very slowly it's possible for a
wide range of different users of this
interface to evolve independently of a
wide range of different implementations
of the interface so there are dozens of
different different ways to implement
tcp/ip physical network mechanisms and
overlay networks and all kinds of things
like that there are dozens of ways to
implement them mechanics of the files of
the system all of which are compatible
with the hundreds of thousands of
applications that have been written to
use the file system and similarly with
HTML another important aspect of
abstraction that I didn't understand for
a long time is the difference between
abstraction and platforms or layers if
you like and what a plotter platform
what a platform is it's a collection of
a whole bunch of abstractions together
into a single thing the most important
property of which is that you can ship
it as a single unit why is this
important because yeah because it makes
it much easier for the customer
customers to understand what they're
depending on if a customer uses think
about a customer of an operating system
like like Windows or the Mac OS you
depend on dozens of different components
of their system there's the display
system the networking the file system so
on and so forth if you have to think
separately about which version of each
one of those things you're depending on
you'll lose your mind
yeah the job of the platform is to pass
packet packet all that complexity into a
something that you can call Windows 8.1
and then then you you you can just test
your application against Windows 8.1 and
that's just absolutely critical another
aspect of platforms that's pretty
important is the platform as a
general-purpose simplifier so for
example it if you choose java or c sharp
as your platform then you get garbage
collection automatic memory management
for free of course there's some cost
associated with that but as a user of
that platform you don't have to think
about it all the complexity associated
with memory management or almost all the
complexity associated with memory
management it's taken care of
automatically by the platform a related
issue is doing things declaratively as
opposed to writing a program program
that does things one step at a time four
or five years ago I was asked to write a
chapter for a Festschrift in honor of
Allen case 70th birthday and I agreed to
write a chapter on declarative
programming when it came time to
actually write it I realized that I
didn't really know what declarative
programming is so I went and searched
the net and found a whole bunch of
references to declarative programming
that didn't seem to have that much in
common
and I scratched my head for a while and
finally I decided that a program is
declarative if it doesn't have very many
steps so for example that means they
cannot have a loop because a loop has a
lot of steps and why is this good it's
good because it's easier to understand
what's going on it if there's only a few
steps people are not very good at
following out the consequences of lots
of steps so HTM HTML and XML are an
example of doing things declaratively so
our sequel queries source schemas of
databases
and I'm going to talk about synthesis so
that was a abstract but that was the /
difference abstraction there's other
ways to do division and you can divide
by structure that's called recursion and
the basic idea of recursion is that the
part is very similar to the whole so you
know a quick sort we have distributed
hash tables we have path names and file
systems we have ipv6 all kinds of things
where you you have some idea that you
can apply repeated repeated yeah
at different levels of complexity you
can divide for redundancy
that's called replication and you can do
that either in time or in space and then
this is the essential tool that we use
to make systems that are reliable in
spite of the fact that the car
components can't be counted on to work
all the time so if you retry in time
that's retransmission you do some sort
of end-to-end check and you repeat
repeat the operation if it doesn't work
out and the canonical example that we
have of that in today's world is TCP if
you divide in space so you can deal with
the complete failure of some component
you do you do that with a technique
called replicated state machines the
essential idea is the same you're going
to do the operation repeatedly and
you're going to have some mechanism for
picking out which repetitions gave the
desired result and which ones should be
discarded and finally you can divide for
performance that's called concurrency
and in the modern world of course that's
okay extremely important for two reasons
one is that with the advent of the web
and of cloud computing demands for
extremely high performance have
increased enormously
in extremely high total performance
they've increased enormously and the
second one is that it's no longer the
case that each generation of computer
you execute a single stream of
instructions
through three times faster than the
previous generation nowadays typically
it doesn't execute a single stream of
instructions much faster at all but it
is willing to execute lots more streams
in parallel so my slogan for concurrency
is okay it's known that programming for
concurrency is hard there's two ways to
make it easy one is called striping or
data parallel computing where you do the
same let's see essentially the same
thing into them independently on a bunch
of different pieces of data they don't
interact with each other and the other
is streaming where you were to arrange
things in a pipeline and you pour the
data through and if you can't figure out
and the canonical example of that is
MapReduce if you can't figure out how to
either stripe or stream then you're
going to struggle yeah you're gonna have
difficulty writing the program so that
it's both concurrent and correct so that
was divide and conquer and we have two
other aspects of methods incremental is
the next most important one after divide
and conquer
and there's several subsidiary eyes to
make up a large part of incremental at
the top of this light I of incremental
I've put composition you can compose
relations functions processes components
to make bigger bigger things out of
smaller ones and this is a fundamental
technique that you use for building
large systems and one of the interesting
things I think that's been happening in
computing in the last few years the idea
that you could have a lots of kind of
components that you build your system
out of is a very old one it dates back
to the acid yeah
I suggested from Doug McIlroy at the
1968 software engineering conference and
to first approximation for many years it
didn't work um people tried to make
software components and they tried to
put
those components together to make
systems and it didn't work very well for
a variety of reasons basically having to
do with the fact that engineering
something is really a component in the
sense that it can be reused in a number
of different contexts it is pretty hard
and people didn't want to pay for it so
the only components that existed for
quite a long time were very big
components operating system browser
database system which have the property
that they're so big and have so much
function out functionality and so much I
knew it into them that as a customer
even if you're a even if you're only
using one percent of the functionality
of the database system it's still much
better than rolling your own and be you
use very few of them so you can afford
to deal with with the fact that it takes
quite a long time to learn how to use
each one effectively but one of the
things that's been happening more
recently I think is that we are starting
to have big components besides those
those three so for example um this isn't
this is only barely true today if it is
true but we're pretty close to the point
where a computer vision system where a
speech recognition system can actually
be a compliment as opposed to a PhD
thesis and that means that you can build
start building very interesting systems
out of these big components which didn't
used to be possible used to be the case
for example that a computer vision
system that did anything interesting had
the property that it was somebody's PhD
thesis and it was very unlikely that
anyone other than the person who built
it could actually use it successfully
and increasingly that's not true true
and if you're interested in building big
systems that have a lot of function now
that I think this is the very important
thing to think about the most important
single application of the idea of
composition though is indirection and
the idea behind indirection
is that you control the name to value
mapping some
and that allows you to virtualize things
with virtual machines or not or USB or
app compatibility it allows you to do
Network where you can go from source
writing to IP addresses to DNS names to
services to individual queries it allows
you to have symbolic links register
renaming virtual methods copy-on-write
an enormous range of techniques can be
thought of under the general rubric of
indirection yeah in fact David Wheeler
said many many years ago any problem in
computer science can be solved by
another level of indirection and this is
a quotation which has been unfairly
attributed to me by many people but he
actually actually was said by David
wheeler related to these thoughts it is
the idea that you can iterate you can
iterate design you can iterate actions
you can iterate components so there's
redo logs and replicated state machines
there's undo and there's scaling that
you get by making lots of copies of
essentially the same thing finally
there's the a of aid which is a
approximate the most important of this
aspect of this is one that we've already
talked about several times which is the
notion of things being good enough wet
the web search engines IP packets you
shouldn't work too hard she just should
make you sure that the thing is good
enough for whatever it's going to be
used for in the original design of the
ARPANET very few people remember this
but in the original design of the ARPA
know the network made a promise that if
it accepted your packet it would deliver
it at the other end assuming that the
other end is still there regardless of
anything that might happen inside the
net no network short of total
catastrophe and this decision turned out
to have a huge number of by
unanticipated consequences and after
about five years they had to reverse
this decision and adopt the best effort
stri strategy that the internet is has
had from the beginning which is that
when you put a packet in yeah yeah the
network will try to get it delivered
there but it definitely doesn't give you
any guarantee and if you want to
guarantee that the packets gonna be
delivered you have to be prepared to
retransmit it maybe maybe in several
times and there are many many aspects of
this good enough principle other ways
that you can take a advantage is the
idea of approximation loose coupling is
very important build your system out of
springy flaky parts so springy means
that they're adaptable to bad things
that happen around them flaky means that
it's okay if they do some bad things a
very familiar example of this is email
the email system as a whole
yeah very it's pretty good at delivering
the email message from the sender to the
receiver in spite of the fact that many
many of the pieces many of the
components through which the message has
to pass at many different levels of
abstraction are pretty unreliable but
the system as a whole is India
engineering so that it overcomes all
those problems brute force is always
good we have not had very good luck in
computer systems at making optimal use
of the resource now at our disposal over
provisioning is usually better Hardware
is not that expensive you can afford to
over provision broadcasting is good
scanning through all the data rather
than trying it to index it so you can
zero in and exactly what you need is
very often the best way to do business
if yeah if your assistant is not
behaving well often a good strategy is
to reboot it these are all aspects of
using brute force relaxation is another
pretty different ask
of doing things approximately the basic
idea there is you take small steps that
you hope will converge to the desired
result
so routing protocols data daily builds
in software construction exponential
back-off in TCP and in the Ethernet are
all example examples of applying the
idea of relaxation and I'll skip over
the rest of them so just to summarize
all of this I've talked about hints for
system design and a few principles not
too many the hints are just suggestions
and I organized the the hints under two
headings the goals that you have for
your system you'd like it to be simply
you'd like to simply you'd like it to be
timely you'd like it to be efficient
adaptable dependable and yummy and how
are you going to go about achieving
these goals
well yeah you can't I don't know how to
put everything that I know about how how
to build systems under these three
headings yeah but probably 70 or 80% of
what I know fits under these headings of
approximate incremental and divide and
conquer well that was a lot of things I
told you about if you only remember
three of them here we go the three to
remember keep it simple abstract with
clean interfaces and write a spec and
just one last hint none of these things
are a substitute for getting it right
and on that note I think I'll stop</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>