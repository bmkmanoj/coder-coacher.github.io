<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reasoning About Client Side Web Programs | Coder Coacher - Coaching Coders</title><meta content="Reasoning About Client Side Web Programs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reasoning About Client Side Web Programs</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IO5ECgbQ-aY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay hello I'm Gareth
reasoning about client-side web programs
okay so the the stuff I'm going to beat
i'm going to talk about it's a part of a
larger project and the larger project is
called jazz set and jay asserts you know
it's a collaboration between some of us
at imperial and some people at at in
rear end i'm just going to kill my
screensaver there we go and i'm going to
say more about the big project later
these are the people who did the work
that i'm going to mostly be focusing on
just in this talk all right so what I
want to do is verify client-side web
programs what's a client-side web
program it's some JavaScript and some
dumb all right so a lot of you said that
you would written at least some
JavaScript so you know what that is it's
a programming language it lives in all
of the web browsers it's the only
programming language I know of that you
can rely upon to exist in any web
browser that you're ever likely to make
use of with the possible exception of
things that require plugins like java
and flash but then they have their own
disadvantages this is why javascript is
important you know it's everywhere if
you want to write a program on the web
you're going to have to with a very
least compile it to JavaScript and it's
showing up in other places as well
windows 8 apps you can write in
JavaScript now and so they have access
to stuff in your operating system people
like Chrome OS and Firefox OS everything
on there is JavaScript if you want to
use linux then gnome has JavaScript apps
as well on the other side of the screen
i'm i'm also going to say a little bit
about dumb so dumb is the document
object model and that's the library that
you use if you're writing a JavaScript
program I'm going to think of it as a UI
library what it really is it's a library
specified by the w3c as a way of
manipulating XML trees and when you're
on the web the XML tree you want to
appellate is the webpage that your user
is looking at so it's going to act as
your UI library so in the talk I'm going
to talk a little bit about how we reason
about a JavaScript program and then I'm
going to talk a little bit about raising
adan programs i'm going to put it all
together okay so if we want to think
about JavaScript programs I'm going to
need to break some uncomfortable truths
to you about JavaScript semantics so
that's where I'm starting the first
thing I need to tell you guys is
JavaScript does not have variables what
it has is something like this so you
might be used in many same programming
languages to having a variable store
which you can think of as a stack and
every time you call a function you add a
new frame to the stack and that's why
your local variables are going to live
in JavaScript instead of a stack we're
going to have that's the wrong button
instead of a stack we're going to have a
list of pointers and we're going to use
objects on the heat to instead of stack
frames okay so i'm going to always put
my local most thing on the left of my
list and at the bottom of my screen
which is closest to the code and the
global most thing will be on the right
of my list and at the top of the screen
now just a list of objects representing
a stack that would be quite comfortable
that would be fairly natural but
javascript is also a prototype oriented
programming language how knows what
prototype oriented programming language
means quite a lot of people not everyone
I'm going to assume that you know what
object-oriented programming is and
inheritance if you have a superclass
which you can determine statically
you're going to inherit behavior
variables things like that from that in
JavaScript a prototype is just like a
superclass except it's not static it's
dynamic so it can change at runtime so
i'm going to write prototype pointers in
red so if I just if I call the function
and the result of calling that function
is a new stack frame this new stack
frame is not going to have a prototype
because it's just being a stack frame
but there's another way that I can add
things to my variable store and that's I
can use the whiff command if I do with
and then an object reference I'll get
something more like this the object that
I added on there might have might have a
prototype so we had a good a whole
prototype chain the inputs to with our
an expression which will evaluate to a
pointer and ugly yes and a block of code
and the result will be to run the block
of code but before you run it put the
pointer at the front of this list yeah
yes we're going to use an object as if
it were a stack frame yeah yeah and one
of the effects of this is to give you
access to all the fields in that object
and then when we're done we've run that
block will get rid of the pointer on the
front of this frame that we put there
and we'll go back to where we were
before okay so that's what weather's
going to do sorry when you say that you
mean the update to this thing okay it
doesn't matter because this is not
something that the programmer can ever
get access to all of the stuff up here
are things that the programmer can
access but this is just a part of the
semantics of the language in general
when you look at my slides things that
could be written in ascii are things
that the programmer might touch and
things that have bold or subscripts are
things that i've added just to make it
possible to narrate what's going on
right there things that are just going
to live in my logic or or semantics ok
so what I'm going to do is I'm going to
take you hmm right that I was hearing an
echo what I'm going to do is I'm going
to take you through just what happens
when
when I run a couple of simple programs I
want to do X gets five on here all right
so I'm gonna look for X see if i can
find it it's not there it's not there
there there or there it's not there it's
not there it's not there I didn't find
it anywhere so I'm going to make up a
new x and i'm going to give it 5 so
where should i put the new variable i'm
going to create this is JavaScript so by
default it goes in the global object
okay variables are global by default so
here's what just happened I couldn't
find X in any of these places I followed
all of these pointers in order to
discover that I couldn't get X in any of
those places and when i was done i put x
up there yes i'm looking for a field
named x in any of those objects and i
couldn't find it in so okay yes in in
javascript in in javascript an object
can be thought of as a map from strings
to values ok so now i'm going to do y
get six so i'm going to do the same
thing i'm going to look for y here here
here and here and now i found it so
where should I put the y that i'm going
to write if I overwrite what's there
then I'm effectively side affecting my
super class when I try and write this
thing here right so this guy is is the
guy that's actually on the variable you
know my list of variable stacks i'm
going to call this an activation record
and yeah but this is the prototype of
the prototype of that guy so I don't
want to write it here well I actually
want to write it is there in order to
discover that i should write it there i
have to look here and find that but what
this is is an overriding assignment yeah
i'm going to override my super class
with
stay okay I I can make up new objects on
the fly this thing is just a literal
object notation says give me an object a
new object with a field acts in one
right good question and the answer is
yes there is there is a prototype the
prototype of every object by default at
the point of creation is going to be the
mother of all objects so now be a good
time for you to tell you what these two
pointers up here mean all right this
stands for the location of object
prototype okay often in a web browser
you'll find that there's a variable
somewhere in the store called object
which points to an object that has a
variable in it somewhere called
prototype which in turn points to this
but those are both writable fields so we
can't rely on it so on slides I'm going
to refer to it as a lot all right but it
is special the semantics know where it
is the whole time and you can discover
LUP by creating a new object and the
thing that the prototype of the new
object points to is this one right
anytime you create a new object you'll
get a prototype pointer to ban the other
thing that special is LG this is the
global object again often in your
browser you'll have a variable somewhere
called window which will point to this
object but that's writable we can't rely
on it I'm going to use this notation it
is special because if I can't find a
variable somewhere that's where it's
going to go all right regardless of the
value of the window variable all right
ok so this is how you do a few things
its prototype pointing to this one which
I described as the mother of all objects
we won they did great those those were
created as the result of a function call
alright so those were not created by a
programmer asking for an object those
were created by the program are calling
a function and then a side effect of
calling that function was to put an
activation record on the end of this
list a brand new one and that's
pretending to be my local variables if
you follow the specification by to the
letter write the specification of
JavaScript then yes the only time you're
ever going to have not a prototype is
going to be if you're this object or if
you're one of these activation records
but nobody does alright so if you follow
that specification to the letter then
these red arrows are hidden okay there
there is part of the semantics of the
language but they're not fields that I
can grab but I can get access to okay I
can't grab them and do assignments on
them not in the spec in the browser I
can all the browsers just they just
expose these things for you and they
usually expose them with a name like
underscore underscore proto underscore
underscore okay so in practice we can't
rely on pretty well anything about these
chains people can assign numbers to
these things or strings you know okay no
the one thing that all of the browsers
do agree on is that you shouldn't have
cycles in these things so what they
usually do is if you attempt to create a
cycle at the moment you perform the
assignment that would have created in a
cycle they throw an exception and refuse
to do it it means that every time you do
an assignment to that particular field
they follow the chain of pointers until
they get to null and check each time if
if you've just created a cycle so they
do a comparison with the object that you
started with so yeah you're traversing a
linked list every time you do an
assignment to proto
in practice right in the spec that's not
because you can't do it right ok I'm
going to move on I'm going to I'm going
to quickly show you if you've got you
know two very two variables in one
expression I've got to look all the way
up this thing for X gets five and then
I've got to look all the way I've got to
look for the X and I've got to spend
some time looking for the Y as well and
notice that I have to follow these
pointers for both right so for those
people in the audience who like
separation logic at this point they
might starts clicking you know it's it's
not nice even this very simple thing I
can't break down the left and the right
with a star ok so i might say more about
that later ok i'm going to introduce
some notation this object here i'm going
to write in a formula i'm going to write
things a little bit like this I've got
an object which is pointed to by L
that's this bit and on the left of the
bar in here i'm going to write all the
variables that I know are not in that
object I really care about that I have
to I have to have a say a way of saying
this variable this field is not a member
of an object otherwise I can't
understand the variable store and on the
right of the bar i'm going to write all
of the variables that are in the object
and I know what their values are ok so Z
in this formula I am simply not telling
you anything about this formula tells
you x is definitely not there why
definitely is that and it says nothing
about Zed that means that if I'm
thinking in terms of separation logic
later on I can frame on a reference to Z
and then I'm good but I can never frame
on a reference to X yeah ok so that's a
thing that I can do a very similar
notation sometimes in fact quite a lot
of the time I don't want to worry about
all the horrible details inside this
blue box I just want to say there's
something that looks like a variable
store and it makes use of the of this
list all of these objects there's
something
points or to buy that list it looks like
a variable store and again on the left
of the barbie i'm going to write
variables that I know are not in the
store on the right of the bar variables
that I know are in the store and what
result I would get if I attempted to
read them observably what does that
variable look like in the store so
that's notation I can use given that
notation i can write this triple and
that's a whole lot nicer than all the
mucking about about following pointers
in the store right if if I want to do X
gets why I just I need to have X I need
to have Y and I can I can give it the
value the proof of this well there's one
third of the proof of this triple so
that there we go one third of it that's
one third of it that so that's a bit of
a pain but you know I've done it so you
don't have to so long as you write
programs which don't break the the
abstraction that we have a sensible
variable store you'll be able to prove
them just using this kind of thing but
some programs do break that abstraction
and if you do want to break that
abstraction you want to do things like
get a pointer to an object that you're
also using in the variable store and
mess with it by hand well then you're
going to need to use more complicated
formula to reason about it Yeah right
this star true just means i may have
generated some garbage in the process of
doing this assignment okay and the
reason for that is because when i do an
overriding assignment in this variable
store i may render some stuff would it
may not be unreachable from the point of
view of the garbage collector but it may
be unreachable from the point of view of
this as a variable storm if I've got a
width statements in there and I've
suddenly started shadowing one of the
variables in the with statement then
that's now separate from the store and I
can start messing with it another way
okay so that's what's going on there
okay
so here's a little example and I promise
you that by now I've told you everything
you need to know to answer the question
on this slide when so you've come across
this code maybe in the middle of some
app that you're looking at and you want
to understand what does it do when this
code runs what is the result of this
function call does anyone want to guess
okay so i gotta I've gotta cry for 1 i'm
going to put one here anywhere else okay
there's a one and there's a two
beautiful anything else ok let's look
let's try it alright so here it is
here's my web browser and and I've
written the code in there and this is a
simple page that just evolves whatever's
in this box and puts the result in that
box ok so so i can click the Run button
and we got one who ever got one
congratulations oh that's fine I can put
the nulling and I can click run again
you'll still get one okay all right good
this code I've tested it on Firefox and
Chrome and Safari and it and it worked
on all of those okay for that particular
thing all right so I'm going to move on
is this a good specification for the
code right we just did a test we just
tried you know to run this code and what
we got was that the return value at the
end there was was one and so is it the
case that if I ever run this in a store
where I have a and F but I don't know
what they are who cares i'm going to
overwrite them anyway and when i'm done
i'll have a store with a NF
probably won't care what they are and
the return value will be one can we
prove this of course we can't prove this
the problem is what if some other guy
came along and did this first all right
so so let's see what happens if some
other guy comes along and does that
first I'm going to run this and what I
get the results of calling f is the
string that sorry that's a good question
so let's let's walk through what happens
with with this code right that's why
I've got the chart here okay so first of
all just without the evil code at the
top right I'm just going to do the ax
gets one the width and the call and that
kind of stuff all right so so here's a
variable store and I'm going to do a X
gets 1 i'm going to create a new object
because there's my literal object and
here's the X gets one and that literal
object has a pointer up to this guy
right a prototype pointer there and now
I'm gonna and I've done the assignment
right so I'm going to put the aid its
global remember yeah that points to this
guy and then I'm going to do the with a
so I guess I'd better I better put my
one two three and four on here and
better show you that my variable store
is currently being represented by the
pointers one two three and four but as
soon as I go into the Wiz block let's
say that this thing was five as soon as
I go into the width block I'm going to
put five on the front of that okay
because that's what the that's what the
width block does right I did with a so I
look at a I fell away I find five so I'm
going to execute the body just with five
on the front ok so now I'm going to
execute the body i'm going to do F
equals function y well function y return
X that's just like a literal object all
right functions are just objects in
JavaScript so I'm going to create
a new function object there and it's got
a body and the body is there and it's
also got a closure and that closure is
just a copy of this list okay so i'm
just going to write five one two three
four there all right and this was an
assignment to F I couldn't find F
anywhere in here so I put it in the
global object and that's going to be a
pointer to this guy now I come out of
the wind block right so I've just got
I've just got to this curly brace here
I'm going to come out of the width block
and as I come out of the width block I
get rid of that five on the front there
now I do a new assignment a gives me a
new object i'm just going to create my
new object there and that has x2 in it
and I break this and that now points
there and then I try and I call the f
and when I go to run the body of the F
which has returned x I return X and my
first local variable is the five blocks
oh I get the one right that's what
should happen but what happens if some
other guy came along and did this code
first if they did object our prototype f
so here's the object prototype I'll put
an F here and that guy is going to point
to the evil code right that's the evil
code I do the with again so I'm going to
put this guy on the front of my of my
stack now I want to do an assignment act
f becomes equal to some function so the
key is I've created my F I want to find
where i should write the variable to i
look here f's not there i follow the
prototype Oh F is here so this is a
local assignment so what I get is my
good f
is in this block now it's not this one
this never got created I come out of the
width block I get rid of the five there
I create this thing which we don't care
about and then I try and call the f I
look here there's no F no F no I know F
there's an F it's evil did everybody
follow that okay this is an example of a
thing called a prototype poisoning
attack it happens right this is a good
way to steal confidential data if you've
got a piece of code you know I just
passed null in to this I just pass null
into this guy but I could have been
passing something sensitive right if I
knew it was my code then that's okay
because Maya but it might be someone
else's they might just email it I don't
think it's a consequence necessarily of
prototype based programming I think it's
a consequence of the particular
combination of prototype and functional
programming that you get in JavaScript I
think you can build a very nice sub
language of JavaScript which is which
feels very object or prototype oriented
and you can write in that language and
so long as you only interact with code
that is also written in that language
everything's nice similarly you can pick
a very nice functional subset of
JavaScript some people are like to say
that javascript is the world's most
widely deployed functional programming
language and you can write beautiful
functional code in JavaScript and so
long as you only ever interact with
functionally written code everything's
fine the problem is when the two come
together and the particular ways that
they've been implemented in each case
don't necessarily get on very well this
is the kind of thing you get
one thing you can do is you can ban with
all right if you look at echo script 5
the latest specification of the language
there's a strict mode which is designed
to make people like us happy right and
it bans with in strict mode you can't
use it which begs the question why am i
bothering with it you know if they're
starting to ban it anyway why do I care
I don't think Witt is going to go away
completely because even though it's
possible to write nice strict code with
that without with right where it's
banned and if you look at things like
Google kaha which provides you with a
sandbox for an even stricter subset
which the Google guys called SES
securing the script in order to
implement that sandbox they need to
write non strict code and that non
strict code which implements their
sandbox users with its powerful and
useful you know it is it gives you a
good way of locking an environment
around code that you don't trust which
has and CP seems like what you're saying
is there's no way of kind of
categorizing they kind of good about
behaviour sort of on the face of it you
know to me this kind of prototype
poisoning attack that doesn't look like
yeah exactly it's a problem with this
program so in fact what we should have
written for our precondition for the
program is this which is exactly what i
wrote before except that now i'm
demanding that i know beforehand that
this f not be in the prototype layer
right in fact one of the projects i'm
working on and which is nowhere near
ready yet i'm working on it with a with
a massive student at Imperial is a way
of taping preconditions like this which
you can imagine might have been
generated by a tool and using them to
generate code which we can compose with
this code to harden it so if this
code tries to run in a state where this
isn't true it will fail gracefully no no
that's not always the case at all it's
the case at the moment because we did
this funny thing with with right but a
lot you know if a lot of the time I
might not care about whether the
prototype contains a copy of the
variable or not that's fine did it's
just for this program it's important
okay so we've got a way of doing that
there I should point out okay separation
logic people may be happy with the star
down here but probably haven't seen this
thing and I'm not going to dwell on it
but what this is is it's like a star
except there may be some sharing okay
it's not and it doesn't mean that this
must be exactly the same footprint as
this nor is it star Q and true it not
nor is it and Q star true because the
footprints of the whole thing is bounded
by the union of the footprints of the
two of them it's these guys may be
separate and they may share a bit and
it's okay right so I'm saying somewhere
in this variable store there's probably
going to be this prototype and I want to
make sure that these properties hold of
it okay I've talked a bit about
JavaScript for for nice programs we can
write nice specifications we can still
prove a lot of very weird programs if
you're willing to break into that store
abstraction I talked about and just deal
with the individual objects that's great
we do have a prototype automatic tool in
fact the example I just gave you we can
give it to this tool without any
annotations and the tool will give us a
specification a true specification for
that program it is a slightly more
complicated specification than the 1i
show
you because our tool doesn't cope nicely
with that new connective I showed you
but it's not bad I'm here all day so if
you're interested in the tool I can talk
to you about that later it's primarily
by another students of Imperial diver no
gineering ok I'm going to move on now
and I'm going to talk a bit more about
done so like I said before Dom it's the
library for messing with XML and we're
going to use it in JavaScript programs
as if it were a UI library backtrack in
what context can I undo the last three
things that I did what what is the point
of having what is the point of having
prototypes is that what you're asking ok
if I want to do a standard
object-oriented programming trick right
I want to have some objects I want to
have some code which I can run on any
object which I consider to be an item of
clothing and I want to have some other
code which I can run on any object which
I consider to be a jacket yeah so jacket
is a subclass of clothes right so i do i
use inheritance I might have put on in
the item of clothing right and i might
have you know jacket specific methods in
them in my in my representation i'm
going to have it in java I would have a
class for clothes and a class for
jackets and I would have objects of type
jacket in JavaScript I don't have
classes there's no there's no type
system so I can't so what I have is an
object which represents stuff I want to
do to clothes and an object that
represents stuff I want to do two
jackets the prototype of the object that
represents the stuff I want to do two
jackets is the stuff I want to do to
clothes so it inherits those methods
automatically
and then I can have an object that
represents a particular jacket and its
prototype is going to be the object that
represents jackets in general and it's
going to contain data that's specific to
the jacket in question does that help ok
I'm going to move onto dawn xml trees
you is ok I've been showing you diagrams
that look like this hopefully it's
fairly obvious that i can look at these
objects in boxes like this right these
are the memory addresses of the objects
and here are lists of fields and their
values that hang off the things all
happy with that cool so we could think
about gum like this right we could think
about dumb as being objects in the heap
here's here's a node and it's got a list
of children and the first child in that
list is this one in the last child in
that list is this one and so on we could
do that but we really shouldn't ok one
of the reasons we shouldn't is because
this way of thinking about dumb just as
if it were JavaScript implies that Dom
should always be implemented in
JavaScript and it's not in your web
browser the the Dom nodes that you look
at are going to present sometimes as if
they were a little bit like JavaScript
objects but there's a lot of stuff that
they can do that JavaScript cannot for a
start it can mess with your screen right
that's why we have the dumb in the first
place it's what the user sees so it's
not just JavaScript but also just isn't
that nicer right we we want trees to be
trees ok I can think about the mysteries
i can look at them they look like trees
ok if i want i want the trees in my
model to look and feel like them so i'm
going to have i'm going to have a
special address top which is going to
sit in my in my address space right i
can have other JavaScript objects
hanging off the address space just fine
but this is the address of the tree and
and when the web browser wants to know
what to show the user because it's
refreshing the screen it's going to look
at the tree here and render it ok so I'm
going to call this a structured heat
right this was an object heap this is a
structured heap it's got more
complicated structure in it ok now I'm
going to say a little bit more about
separating style for those people who
put up their hands who didn't really
know what it how it works ok separating
star means I've got this bit of the heap
and it's separate from this bit of the
heap I know that this is true of this
bit I know that this is true of the
other bit and I know that they don't
touch each other that's what separating
star means when you've got an object
heaps the great thing about the star is
you can chop the object keep up any way
you want you can flick them around you
put it back together again it doesn't
matter no one cares what order the
address is coming in an object heap
unless you have pointer arithmetic which
in JavaScript you don't ok so we don't
we don't care what you know what the
names of these addresses are we trees
it's not so nice if i were to chop this
tree up like this I try and put them
back together again I end up with a tree
that's different from what I started
with or i might have you know that I
don't know how to put these things back
together it could go anywhere so the
solution to this problem is when I
chopped out this node I'm going to leave
a hole in its place I'm going to create
a logical address and that logical
address i'm going to think of is living
in my address space except that it's
blue and greek that means that the
program can't mess with it the program
doesn't know about this this is nothing
to do with the semantics of the
programming language this is just for
the logical reasoning it's just to make
it easy for me to consider the idea of
chopping this tree up and just thinking
about this little bit separately from
this other bit so in my reasoning I can
do something that we might term abstract
allocation where I allocate a new
address I make use of it
or similarly I can do the allocation
where I go that way they're really just
implications but you can think of them
as allocation and de-allocation in your
reasoning if it makes life easier okay
here's the notation I'm going to use for
this kind of stuff so I've got a tree at
the top and it looks like an HTML load
with address 1 HTML is the name of the
node there is and it's got some children
and those children are well whatever is
in this hole the Alpha hole I don't know
what's there whatever there that's fine
and next to that we've got another node
which is called body address three and
no children and separately from this
stuff separately from that I also know
that I've got this alpha thing and it
contains a tree node with head and
address two and no children and later on
I can compress these back together this
content that this idea of the the Alpha
and there wouldn't be a lot of point
because the JavaScript heap the objects
in it are so small they don't they don't
contain each other in the way that trees
contain each other there is you know
there's a potentially enormous tree
under this thing with very important
structure to it right whereas in the Dom
whereas in in the object heap it's just
it's just things like this right I'm I
never have anything very big dangling
off here I may have an object here which
contains a pointer but that pointer is
just a value you know it points to one
of these guys yeah I don't have big
structure down here
yeah and then you're back to the problem
of you you can't see the structure of
the tree anymore I would like to be able
to do this reasoning on paper as well if
you like that's not a that's not such a
bad way of thinking about it and okay so
we've got all this this idea of of
abstract allocation and de-allocation if
you want know more about that you can
read Adam rights thesis his name is on
the front as well and okay oh and I've
taken you through all of this right yes
so if you're happy with separation logic
well even if you're not if if I know
that these guys are separate and if I
want to mess with this guy with some
program then so long as my program only
messes with this guy I don't have to
worry about this one I can temporarily
forget it and call it back later and
separation logic people call this the
frame rule so I'm going to frame that
off that I'm just can be left with this
one ok and now i'm going to talk about
some Dom programs so here's an axiom
forget node name and hopefully that's
fairly obvious right I need to know if
I'm going to get the node name with Dom
address n I need to know that I have a
node with dama dress n and I've made use
of this abstract allocation to make sure
that I can grab it directly right I
don't have to traverse a whole tree to
find it so I've got this thing with
address n and I want to get its name so
when i'm done the return value is the
name dead simple all right now let's add
some javascript ok so we can't write
literal dama dresses so in JavaScript we
have to make use of a variable I'm going
to do X get node name x is a JavaScript
variable in my store which is separate
from the treat and the value of that
variable is the dama dress so I'm good
when i'm done i can give you the
the name simple here's here's the same
thing but writing the name I need to
know that I'm going to exit node name
name so i need to know that X is a
variable corresponding to the address of
a dumb thing and the name that I want to
write to it is actually a name that can
be written obviously in JavaScript you
know this could be Australia could be a
number it could be a pointer I want it
to be a string in this case otherwise
this won't make sense and when I'm done
well I'll have the new name up there and
I'm good okay so here's a simple program
what this program does is it gets the
name of a node and if the name of that
node is a name that I don't like then
I'm going to set the new name of the
node to be Bruce to avoid confusion so
we can specify this program there we go
and I've put the Dom bits in blue so I
need to know before I start that I've
got some variable store and no one else
is messed with the variable name before
because I'm going to need that I need to
know that I've got a node and that it
corresponds to the address of the node
that I've got corresponds to a real node
that I've got my hands on I need to be
sure that I have a blacklist there's the
address of the blacklist here's the
blacklist I'm just saying that I like
the names Fred Wilma and Bruce and I
don't like the names pebbles and
bamm-bamm that's just that's just what
I'm going to do and when i'm done i
still have my note there it is I still
have my blacklist there it is but the
name of the node has changed its not
name any more its name Prime and I know
for sure that name prime is not one of
these things that I knew were in my
blacklist it's not pebbles and bamm-bamm
ok so i can write this program hopefully
you can see it's not going to be hard to
prove this program right the you know
the intermediate conditions this is just
is
an instance of the axiom i just gave you
is just i get the thing you know i i've
shown you all of these things before
alright this is going to easy to prove
so this seems kind of frivolous why
would I want to do that so far I've just
told you about just for notational
convenience I've talked about Dom nodes
that have names and children of course
real Dom nodes also have attributes and
things like that if we think about this
program and instead of thinking about
getting the name we get the source
attribute of an image link then this
begins to look a little bit like an
adblocker a little bit like the core of
an adblocker right so here's a simple ad
blocker I've got some black list of bad
URLs these are images that I know to be
adverts here's the function that I just
I just showed you right there's the body
of the function I just get you know for
for whatever this image is I'm going to
get the source attribute of that image
so now I've got the URL of the of the
image and if it's in the black list I'm
going to change that image to not be
that one anymore instead it's going to
be a nice kit and then I'm going to get
all the images in my documents I'm going
to iterate over them and I'm going to
run this thing on all of them so then by
the end I'm going to know that there are
no bad images in the document so here's
the spec that's probably far too small
to read so let's zoom in on the
specifications so this is this is pretty
easy up at the start I just need to know
that I've got a black list it contains
all the bad URLs that have been reported
to the adverts I've got some HTML
document there it is and I don't know
anything about the children of this
document when i'm done i've still got my
black list there it is and I've still
got my document but now I know more
about the children
this is one of the reasons that we want
real trees in our logic and not just
objects because if we have real trees
it's really easy to write modalities
like everywhere so I'm just going to
tell you what this means this means that
at every point in the tree no matter how
far down or which branch you go down the
following formula is going to have to be
true okay it would if I wrote this
formula to allow for alphas but I didn't
this true means that there aren't any
office I've got all of it okay so yes
things get complicated if by the time
you come to prove this you haven't
collapsed back again instead of one of
these you could write that and you may
get some unexpected meanings as a result
okay this meaning with beatas in here
what you would need is so what this is
doing right if you think about this in a
separation logic way this is saying I've
got my hands on the whole tree under
here and this is an invariant about it
right if you put a beater in there then
what you're saying is well I've got my
hands on most of it but I've given some
of it up some of it you know it belongs
to that other guy over there on the
other side of the star so if you do that
then of course you can't say what this
other guy is doing right it's this other
guy i can say i can give you an
invariant about the stuff that I've got
if I choose to give it up it's not my
problem anymore okay that that's the way
this stuff works so what this says is
our invariance is going to be anywhere
that you can find an image it had better
be the case that if that image
a source URL then that source URL is not
one of the bad ones and it might have
some children that's fine okay so that's
our specification of this little ad
blocker all right so we can do we want
to do abstract reasoning for an abstract
library it's a cross-platform library
it's not specifically for JavaScript
there are implementations for Java for
Python for c4 for Haskell even their
implementations for all of these things
this dumb reasoning will work for all of
them it fits very nicely with the reason
we've got for javascript so we can do
them both at the same time we can
separate trees using style we don't have
to use a brand new logic previously we
thought maybe we'd have to invent a
thing called context logic for this
right now it turns out we can use
separation logic we can make use of all
the lovely separation logic results that
the separation logic people give us and
there is a very early prototype of the
automation for this thing by adam wright
and what that does is it makes you
severa fast if you know that ok and they
get on I promised earlier I would say a
little bit about the big project so this
is it right I've in this talk I've
talked about this box in this box and
I've hinted at the existence of this box
and I can tell you more about that
offline if you like these things up at
the top of my wish list for things I
want to exist in the universe I want to
be able to compile high-level languages
to JavaScript with confidence I want to
be able to have good IDE support on a
make up some good specialized tools down
at the bottom here these are things that
do exist in the world right we've got
documents that say what web browsers
should do and of course the web browsers
don't do quite what those documents say
so we've got the browser's themselves
and we've got an ongoing project to
formalize the semantics of these
documents in generates a correct
implementation right this bit we've
largely got that that's almost done now
for es5 we can and have generated a
correct implement
of this what we want to do is test this
implementation against the actual
behaviors and then iterate this loop so
that we can start adding parameters to
this say when you want to behave like
Firefox this is what you do okay so then
when we're done we'll have a good idea
of how browsers actually behave we've
got this program logic which I've just
talked about we want to put that in
we want to prove it against this once
we've done that then if I give you a
proof in my logic you better believe
that it actually works in the browser
right that's the confidence I want to
give you the tools I've told you about
obviously we don't want to build a tool
in I say this obviously someone
actually just told me that I probably
should and but but hard I want to be
able to do all the gnarly things I like
to do when I'm writing tools in ml but I
do want my tool to generate a script the
 can check if my tool thinks it's
found a proof maybe it's a good proof
maybe it's a bug in my tool but if you
can check that proof in well then
we're good all right that's what I want
this to do and on top of all of this I
want to be able to build these things I
just showed you a thing that looked a
little bit like an add-on forum for an
ad blocker in fact it was a greasemonkey
script very similar it I can show you
running if you like and there are people
whose jobs it is to sit at the companies
that provide systems that allow add ons
okay mozilla firefox windows 8 all the
web browsers all of these things they
invite people to submit add-ons to their
system and then we have something like a
store like an app store and there's
someone whose job it is every time
something is submitted to look at this
JavaScript code and decide whether or
not it is evil this is hard hard and
boring wouldn't it be great if we could
provide a tool which given a piece of
JavaScript code gives you a diagram of
this is all the stuff that this code is
going to mess with and um that's
particularly helpful because dumb is a
very visual thing anyway you know it's a
tree that we're used to looking at on us
greens and separation logic is very good
for this kind of thing separation logic
tools in in other areas for reasoning
about sea and some have shown that they
can be very good at finding the shapes
of memory that a program is going to
mess with so that's what we'd like to
provide at some point you know once
we've got all this kit working we would
like to provide tools which give me a
piece of code this is what it'll mess
with and you can look visually and see
will it try and access all my passwords
if so maybe I should look a little bit
harder at it that's one example of the
tools I'd like to provide okay I think
I'm about out of time there are times
when you can get quite nice listing
things out of it so if you look at Davin
ogenyi Annie's work one of the things
she is done is this store predicate that
I showed you right when I gave you the
complicated example I immediately had to
break into that storm predicate and use
the SEPA sh and say well I've done
something unusual so now I have to deal
with all the gnarly sharing yeah and
that's exactly the problem that you want
to avoid right that's the thing that
tools are not good at but we do have a
tool that can prove that program and the
way that worked was rather than using
the store predicate we came up with a
slightly more clever predicate which
while it's not quite as nice to look at
as the store one it gives you a little
bit more power in terms of the
gnarliness of the things that you can do
so we chop up the variable store in a
slightly different way and we just use
separation and each of the distinct
boxes that we chop the variables
star into they behave quite a lot like
linked lists and then we can make use of
all the all the usual linked list kit
that we know how to do and we can get
something out of it so it's true that
like in the general case you know if
people give us really gnarly code
sometimes where does have to say sorry i
don't know but a lot of the time
programmers aren't writing thinking
about gnarly code attackers might do but
the programmers that write the code that
we want to verify usually they've got a
fairly simple model in their heads of
what's going on we've got to make sure
that the model in their heads is sound
you know if their model doesn't
correspond with the semantics of the
language we're in trouble that's why we
need the gnarly logic right but we
should be able to provide abstraction
that reflect the intuition in the head
of the programmer and then we can take
on the pain prove that abstraction works
under certain circumstances in the whole
logic and then allow the automatic tool
to make use of the of that abstraction
and reason at the same level of the
programmers reasoning right up until the
point where it stops working and then we
throw up our hands to say I don't know
does that help which is you might have
developers in code you know sort of
selects it leaves fall yes and then
there's a kind of sort of sign language
which has you know lots of nice clean
properties there is there is it is it
fair to say that these kind of the
abstract predicates with scope rotation
the other ones like that that's the kind
of you know you're kind of some juice
and a kind of beautiful somewhere in
missoula you works on the other stuff is
for yes with a qualification okay and
the qualification is that ordinarily
it's safe to think about sub languages
on your own and just say well just
programming the sub language in your
fine because you have control over your
module of the program and no one else
can mess with it is your module most
programming language
provide some kind of modularity
mechanisms like that okay not see fair
enough yeah okay great in which case yes
if that's the sort of thing that you're
thinking of then yeah that's that's very
much the kind of thing we're thinking
yeah thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>