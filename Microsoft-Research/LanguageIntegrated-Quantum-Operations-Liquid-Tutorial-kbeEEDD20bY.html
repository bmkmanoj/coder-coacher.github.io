<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Language-Integrated Quantum Operations (Liquid) Tutorial | Coder Coacher - Coaching Coders</title><meta content="Language-Integrated Quantum Operations (Liquid) Tutorial - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Language-Integrated Quantum Operations (Liquid) Tutorial</b></h2><h5 class="post__date">2016-06-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kbeEEDD20bY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
you
welcome to the tutorial on using the
academic edition of liquid we're going
to start by going to the website on
github github /m SR - quark slash liquid
which is where all the examples all the
documentation and all the software exist
before running the tutorial you should
go to this site and go down to the how
do I get it which will give you a
getting started page on how to install
all the pieces all the prerequisites one
of the prerequisites is Microsoft Visual
Studio Community Edition which is free
and available for download but this will
let you program compile and run
applications that you build with the
language integrated quantum operation
simulator which we also call liquid
after you've installed Visual Studio the
next step would be to download the zip
file from the website the zip file will
be in your downloads folder in this case
it will be called liquid master nuts zip
and as part of the installation it will
tell you to take liquid master extract
all the pieces and put them into the C
colon directory which is what we'll do
the only other step you need to install
is to take the liquid - master directory
that's created and rename it to liquid
so if we take a look we will see that we
have a liquid - master directory and
we'll rename that to liquid the reason
for this is some of the software will be
looking for files specifically the latex
compiler will be looking for the file
liquid tick Z dot Tec in C colon liquid
and this saves you having to rename a
lot of other things so now that we have
this let's take a look at the file tree
there's a binary directory called bin
this contains the executable and all the
support libraries necessary to run the
system without doing anything else the
docs directory contains compiled help
information this is all of the API
documentation as well as a hundred page
user's manual which you can step through
after the tutorial and will show you all
the different capabilities of the system
the image directory is just used for
pictures used in other documentation the
samples directory contains all sorts of
things that run in the system pre-built
quantum chemistry examples web graphs
and various other things we'll spend
some time here in the tutorial and then
there's a source directory this is where
you can build your own version of liquid
with your own pieces on top of it so
what we're going to do is we're going to
start by walking down to the windows
button right click on it and select
command prompt this will give you a new
command prompt that we're going to go to
the top of the tree which is C colon
liquid as you'll see everything is there
that we were just showing
and what we're going to do is make sure
liquid is running okay so we'll go into
the binary directory
and say liquid the first time we run
liquid is going to come back and tell us
that we haven't accepted the license all
you need to do is type a capital y hit
enter and it will say thank you for
accepting and you'll never see it again
so this time if we run liquid we'll get
a whole bunch of output we get the
copyright notice and also the website to
go to for anything you need with liquid
it's also gives you a warning that you
haven't registered this copy
registration really just involves going
on to the website signing up on the
listserv and just saying you're using
the software we're only using the
listserv to announce changes things
available with the software and it lets
us justify doing the work on the system
because when you install we get credit
that this many people have installed the
system and we can continue working on it
and we get funding so I strongly suggest
that you register on the website with
the listserv but if you don't all you'll
do is just get this little message every
time you run there were a large number
of tests built into the system we'll go
through a few of them as part of the
tutorial but they're all documented in
the user's manual and then there's a
usage statement and finally liquids
complaining that we forgot to provide at
least one command line parameter so
let's do that
we'll run liquid all the built-in
examples start with two underscores so
I'm gonna say underscore underscore sure
we're going to do factorization of the
number 21 and I'm going to do it without
any optimizations you're just going to
run the circuit so we'll say go and now
we're off and running
this is a 10-bit value to do a five bit
number 10 bit excuse me 10 cubits are
needed to do five and what you'll notice
is we're getting all zeroes coming back
out this is a perfectly legal answer for
sure but it also means that we're not
actually factoring so we'll try it again
there is actually a 96% probability of a
random result giving you a factorization
but only 43% for sure these numbers get
much better of course as the numbers get
bigger and the number 21 is a fairly
small number to factor but it's a good
example and now you can see we're
actually getting some bits back from the
the quantum operations so we're running
the the example through we're taking a 5
bit number it's taking us a total of 13
qubits to actually do the circuit this
is Beauregard algorithm for solving sure
and when we get to the very end we got
one more to go you'll see that 21 is
indeed 7 times 3 that we got a quantum
result of the number 341 and when we do
the classical post-processing that gives
us the factors so we were able to factor
21 cool now we're going to try a little
larger number so like what we do the
same thing we just did liquid sure and
now we're going to go with the number 63
so everything looks the same except now
we're not getting that first bit back
very quickly in fact this is going to
take a long time to factor and we
probably don't want to sit around
waiting for it there's our first bit
just came in should notice that at the
very beginning of every line there is a
number in a colon this is the thread
number that the message came out on and
then the next digits represent minutes
so this is 0.4 minutes have gone by so
far so 24 seconds and you will see this
on every line so you have an idea of how
long things are taking to run and you
get an idea of if you have multiple
threads where the messages are coming
from so we're not going to wait for all
of this we're gonna do be a little
smarter we'll take this and say I'd like
you to optimize the circuit so now what
you'll see is we started with 28,000
gates to factor the number and we
compiled this all the way down until we
only had 1200 gates or matrices that we
have to multiply and you can see the
difference in the speed we're running
all the way through of course again sure
every once in a while will return zero
for a result so let's start them again
while we're talking and there we go
we're starting to get some bits back out
but this now runs very quickly the
simulator has a large part of it devoted
to optimizations for the classical
simulation of quantum systems this makes
it very quick to operate on fairly large
circuits with fairly reasonable numbers
of qubits and sure enough 63 is nine by
seven so we've just factored a number
bigger than any of the numbers normally
published for sure and this is just the
beginning of how big you could go in the
system so that's a quick overview just
to show that the system runs you've got
everything installed let's take a little
more time looking at other options
by using another example called teleport
again we'll call the teleport function
by using two underscores and then the
word teleport case does count and two
parens and when we go to run it we're
going to get three sets of runs that
come out one after the other the first
one we're just calling all the functions
in teleport directly the teleport
function takes a qubit state that
happens to be randomly chosen and then
transmits it to another qubit quantumly
provided there's two bits of classical
information that are discerned or
actually going to look at the circuit
after we're done running it here and
show you what what it does but we ran it
several times with different random
numbers and we always get the the number
successfully teleported depending on
whatever bits came out on the other end
we're then going to draw the circuits
we'll take a look at what the drawings
look like because instead of a function
call we're going to pull all the data
back from the functions and create a
data structure called a circuit when we
run that data structure through the
system we get the same answers again so
everything works well and then we're
going to optimize the data structure in
this case we've reduced a very simple
circuit eight gates to five gates we run
it again and again
teleport still works so the good news is
that all of this works fairly
straightforwardly and as I said we
generated some drawings while we were
going let's take a look at the drawings
if I look at teleport and just look at
the normal circuit we have an HTML file
generated that's an SVG drawing and if
we take a look we can see we can label
the qubits we can put the various gates
down on the system everything flows from
left to right this was our source that
we started with this was the destination
we got out these are the two classical
bits that were generated and then the
gates that replied based on the
classical bits so this makes it very
easy to generate drawings on the system
we can also make it a little prettier if
we if we if you notice on here you'll
see that there's one gate per unit time
we really don't have to do that instead
we can fold this this was another output
that we generated and now you see we
line the gates up a little better it's a
little prettier drawing and it also
shows you what can be parallelized in
the system fairly quickly we can also
look at the version that we optimized
where we grew the gates together and now
all the gates at the beginning have been
combined into a single gate which is a
three qubit gate and then we have to
measure and apply the output so this
gives us some very simple drawings very
quickly we can also get much higher
quality drawings if we go back to that
CF version there was also a latex Ingenu
install miktex and anything else on top
of it that would edit in this case tech
works this is the file that was
generated by liquid and if we ask it to
compile it and render the result here's
what we get so we can get publication
quality graphics very easily and of
course the file is fairly easy to edit
if you want to add your own annotations
or changes to it the system is able to
draw everything by using a latex package
we wrote called liquid tic z which is
sitting in C colon backslash liquid and
so that's why the first line of the file
referenced that file and that's why we
put everything in the liquid directory
one of the reasons was so that latex
could find the files so now let's do
some programming first thing I'm going
to do is open up the directory and I'm
gonna go into the liquid source
and this directory is set up to be run
with Visual Studio Community Edition
which you should have put on your
machine and at the very top of a project
or of a application that you're going to
build is called a solution file and
here's a liquid SLN or solution file and
this solution happens to have one
project on it also called liquid which
is an f-sharp project if we open the
solution file Visual Studio will open
and it's making sure since we downloaded
this from the internet that we're sure
we want to do this and say yes we do
want to open this file we know it's ok
and what we're going to see I happen to
like a dark dark background but you can
set the backgrounds you like is in the
solution Explorer these are the files
that were in the directory and the one
that we want to work in is called main
so I'm going to double click on it and
open up main this is a nice little
prototype file you can edit add your own
applications too and work at the very
bottom of this file is a module called
app which has an entry point for the
entire application called main which
runs liquid and this is actually what
gets executed every time you say liquid
to the command line
we're going to edit a little function
here a sample function called user
sample again we just put the two
underscores to flag that this was
something we were doing as an example
you don't need to use the underscores
but what we did is before we created
this function in front of it we put an
attribute and what this attribute lqd
does is says the following function
should be callable from the command line
so we're going to try and see how this
works by first building our own version
of liquid and seeing that user sample
works so I'm going to go over to liquid
which is ready to go I'm going to go up
to build and I'm going to say build the
solution and so in the output window we
can see the solution going by
and the build succeeded and if I now say
start the application
the application will start up run liquid
and for some reason we're running Shore
now why is it running Shore we have to
tell Visual Studio that we actually want
to run user sample not run Shore so I'm
gonna right click on liquid and go to
properties and for one thing I'm going
to do is I'm gonna say let's change
debug mode to release mode because the
code will run faster we're not actually
debugging at the moment but debug is how
it gets told how to start things so I'm
going to tell it instead of Shore run
underscore underscore user sample so
this is just what you would put on the
command line after saying liquid XE and
if I now say build and actually I'm
going to show you a shortcut you can
build the solution and then you can
debug it and run the solution it turns
out control f5 will build the app start
the app and run it so from now on we're
just going to hit control f5 which we'll
see build and run but now the
application built it runs and it says
this module is a good place to put
compiled user code which is the line we
had in user sample if you notice user
sample is using command show this is
part of the API for liquid show really
is an alias for printf and all the same
arguments for printf will work the
difference is it adds a new line at the
end automatically it also is a thread
safe so if I do shows from all over the
application on different threads they
won't write on top of each other you'll
always get clean output lines in
addition every time you run you get a
log called liquid log and everything
that you say show winds up in the log so
it's good practice to use it instead of
printf and there's really no reason not
to so now let's write some code so what
we're going to do is take this line and
remove it and I'm going to write a
little function here that's going to
gather statistics I'm gonna say stats
equals array dot create two elements and
start them both off as zero so this will
give us a place that when we have a
single qubit we're going to measure and
either get a 0 or a 1 we're gonna put
the statistics into here so to hold our
qubits we need a state vector and that's
created with the ket class so I'm gonna
create a cat with one qubit and the K
now is a vector that contains a single
qubit for loops and f-sharp are just
like any other language you give it a
start dot dot and end and say what you
want it to do like python everything is
indent sensitive so to go inside the
loop we indented with a tab and since
every time we go around we're going to
measure we're going to destroy the cat
vector so I'm going to tell cat the cat
vector to reset itself back to one qubit
every time we come around the loop so
this way we have a fresh state vector
every time so what I want to do is call
a quantum function with my qubits well
we don't have a quantum function yet so
let's add it we'll go in and say let q
function of qubits which is a list of
qubits equals and I'm going to call a
measurement of qubits every quantum
function ends in a list of qubits so
just like the one we're creating or the
one we're calling am is built in to
liquid which is just do a measurement
but it does a measurement of one qubit
every function takes as many qubits as
it needs off the front of the list and
performs the operation so however many
qubits there are measure is going to
measure the first qubit in the list
that's it we now have a quantum function
after we have the function I want to see
what we measured so if we go back to
that list of qubits we pull the first
qubit off by asking for the head of the
list we ask for its bit value which is a
data type in liquid that knows if he's a
0 or a 1 or unmeasured and I want to
convert it to an actual integer so I
want
value that'll give me a zero or one and
once we have that I'm going to store
weigh-in stats of whichever value that
was stats plus one so if we measure to
zero we'll add one to the zero entry
from agita one we'll add one to the one
entry you'll notice the dot between the
brackets it's a little different than
other languages that's one of the main
things you have to remember and f-sharp
is when you access a list or an array
you have to put a dot between the
brackets and the variable name and we'll
just show our result at the end of the
loop so we measured zero this many times
and one this many times again same as
printf the other thing in F sharp is
arguments are just separated by spaces
you don't need parens and commas that's
it
that's our entire function I'm going to
hit ctrl f5 to run it
and when we run it we got 10,000 zeroes
well it makes sense we created an empty
ket vector happens to start at zero if
you haven't said anything differently
and when we measured it we still got
zero haven't done anything quantumly
really we just created a cubit and
measured it so let's change this we'll
go back up to Q function and now let me
do a Hadamard gate of the first cubit
Hadamard will take the zero and rotate
that cubit to halfway between zero and
one so we're now at the 50/50 position
again I'm hitting ctrl f5 to build and
run so now each time we measure there's
a 50/50 probability of a zero or a one
and sure enough we measured 5,000 zeros
and 5,000 ones we have just done a
superposition the first piece of actual
quantum code so this is all good
everything works now I want to do
something more sophisticated you notice
in this file there's another function
called rot X this is a general function
that will rotate a qubit around any
arbitrary angle in the x axis again the
last argument is always the qubits list
and this looks a little different
because what we're going to do is create
a gate data structure and then call that
gate to run the gate for us and the
reason for this is this lets us do
direct function execution introspection
in getting circuit values back further
introspection to get actual matrices and
pieces so if it was just a function we
couldn't get the data information back
out so we use one extra level of
indirection to make all that work this
is the general form of how to make a
gate in liquid the gate itself has a
name you can put a help string has a
matrix that's a complex sparse matrix in
this case it's a 2 by 2 matrix where the
0 0 entry is the cosine of the angle
over to the 0 1 is the minus sign the 1
0 is the sign and the 1 1 is the cosine
so it's a general rotation or round X
and in unit Ares the angle that you're
rotating by is divided by 2
there's an interesting explanation why
but we won't go into it here and there's
a drawing line
this actually is calling our liquid tick
Z package to say draw this as a gate and
here's the name I want to put in it and
since this is late AK code you can
actually put latex directives and
symbols in here and they will work so
this gives us a nice little gate and
what we're going to do is come down
where we had the Hadamard and replace
that with the rotate X and we're going
to rotate by math PI over 2 and run it
again control f5 and yes F sharp is very
careful about data types you have to put
a period after the two because it's a
floating-point number and we got the
exact same result instead of rotating it
one way we wrote it a different way but
we still got to the equator at 50% and
we got a 50% value well now let's make
it more interesting let's make this PI
over 4 when we use PI over 4 we'll see
that we don't get 5050 anymore now we
get 85 31 and 14 69 and if you look at
this number it turns out that plugging
in our angle the cosine of PI over 8
squared is 0.85 355 so 8 5/3 is exactly
what we'd expect to see out of this and
the probabilities all work right great
however all we've done so far is
superposition we also want to do
entanglement so what I'm going to do is
change our quantum function to do the
gate that we're doing already on the
first qubit and then if there's more
qubits for Q in Q's tail everybody but
the first qubit I'm gonna say do a
controlled knot which is an entanglement
gate between the head qubit and this
qubit
so at this point this will now do the
first qubit rotate it and then entangle
it with all the other qubits now we
actually want to measure all the qubits
and we have a built-in operator in
liquid called the bowtie which will map
a measurement onto all the qubits we
could have just an ax for Q in Q's do M
of the qubit in the list but this is
just cleaner syntax and easy to use and
we'll start introducing some of the
operators as we go so now we have to
change our user sample the command-line
we're going to change to actually take
an integer that is how many cubits we
want will change our ket vector from 1
to end we'll reset it back to n qubits
and everything else will work but we
also want to prove that entanglement
worked so after we get back the result
of the function we're going to say for Q
in Q's tail again everybody but the head
qubit if Q dot bit is in equal to Q's
dot head dot bit then fail this is
throwing an exception bad so now what we
have is a test that every qubit yester
we measured the first one read the same
thing because they're all entangled and
whatever we do the one qubit will happen
to all the others so we'll run it again
and we'll see what happens now when we
run the package and actually we blow up
because the input string was not in the
correct format the problem is the
command-line doesn't match what the
function says it should be if we go back
to how we're running liquid we now have
to tell it how many qubits it's
expecting an integer argument so we're
going to put the argument in and run it
again
and this time it's running but notice it
doesn't come back right away now we
rotate the first qubit that entangle it
with nine other qubits then measure all
ten of them these are big operations and
we're doing it ten thousand times so
this is going to take a little while to
run and if we take a look at what's
going on you can see the this is on a
little surface that all four threads
were almost at a hundred percent in use
and we got the same answer we got before
but we got no error so we know the
entanglement worked and this took 18
seconds to run so this took quite a
while we'd like to move to making this
going much faster so the next thing
we're going to do is at the very top
organ defined a circuit we're going to
call the circuit class and ask it to
compile our function and of course the
function has to know how many qubits to
run even though we're not running the
function now we're just compiling it
with liquid so we're going to tell it to
use the qubits that are in the ket
vector so by doing this we've created a
circuit what does a circuit do for us
well instead of calling Q function now
we can say ask the circuit to run the
qubits and so this gives us a way to run
instead of calling Q func directly we
actually now have built a data structure
that represents the circuit we're
running and now we're running it again
but you'll notice it's not any faster
and the reason it's not any faster is
we're still doing just as many quantum
operations so the number of vector
matrix multiplies hasn't changed in fact
we might be slightly slower because now
we're interpreting a circuit instead of
running compiled F sharp code directly
but it took a little bit longer point
four inch so 2.3 minutes but we get the
same answer and so this time we now like
to make this more optimal so once we
have the circuit we're going to create a
new one and I'm gonna say to grow the
gates
there's all sorts of optional parameters
but when we have to provide is the ket
vector so he has a state vector to tell
them what to do we take a circuit and
what grow date gates does is collapse
many of the gates together into single
ones you couldn't do this on a quantum
computer but this makes the classical
simulation better and we're not going to
change anything else that's all we're
gonna do is grow the gates and so we
changed the optimization we run the new
circuit and the last one took 0.4
minutes to run and then this one took
something under six seconds to run in
standard point one minutes and again we
keep getting the right answer so that's
always a good sign so these are ways to
optimize the systems that you write
let's also get some information what are
these circuits actually look like so I'm
gonna say show test one and into the log
file I'm gonna say take the circuit and
dump it into the log file so we actually
look at the circuit see what it looks
like
also while we're at it I'm gonna want to
draw it so I'm going to say render in
HTML and lay tech test one so that'll
give us some information about the first
circuit and then let's do the same about
the second circuit call it test two
and we'll run it
so now we're running along it'll still
take the same amount of time but we've
also output some information so let's
look at what we output so we'll go into
source whoops
source and we're in the release
directory so here's everything we've
done so far and there's now a test one
that HTML HTML
Tech and a test two dot HTM in tech so
we take test one dot HTM and look at it
and gee there's our gate with the
rotation angle that we used here are the
control nots between the other gates and
here's the measurements that generated
classical bits if we take a look at test
two we'll see that all the C nots got
collapsed together into one matrix which
is why this ran so much faster and the
system will do all sorts of
optimizations for you but this is a good
feel for how it works also while we've
been running we've been getting a log
file called liquid log if we look at the
log file what we'll see is here's our
show of test one and then the dump there
was a sequence of applications of gates
where the first gate was our our X of
0.79 it's a rotate X this was our help
message we put in the gate this is the
actual unitary matrix that was generated
and the entire circuit was called on all
ten wires it's actually only operating
on the first one the next gate is a C
not here's the C not matrix and it's on
wire zero and one wire 0 and two zero
and three and so forth all the way down
and then finally a measurement which is
from the unitary point adjust an
identity matrix it's a non unitary
operation
there's could be more information that
this was a joint measurement and it's on
wire 0 1 2 3 4 7 8 9 so what about test
2 well test 2 the rotation looks
identical but now all the C knots are
replaced with a single gate where the
system generates a name for it and then
these are all the non 0 entries it's a
sparse matrix
and these are all the nonzero entries in
the matrix so this is a fairly big
matrix the indices are in hex just to
make it easier to output and then the
measurements look identical so that's
what the log file looks like so you put
a lot more information into the log and
you actually put things directly in the
log without putting them on the console
when you have large amounts of output so
let's switch gears a little bit let's
move over to quantum chemistry we're now
going to change directories and move
into the liquid samples directory we'll
take a look at quantum chemistry so
liquid that we're gonna run is sitting
in the bin directory we're gonna say
liquid of chem of H 2 so H 2 is just 2
hydrogen atoms sitting next to each
other at a specified distance and we'll
run it so it's already done but it goes
by really fast so let's take a look at
liquid log and what we'll see is we have
the molecule h2 the parameters that were
handed in was that we're doing a Trotter
number of 32 with 28 bits of phase
estimation and a first-order Trotter
ization there's a bunch of other
parameters you can set but in this
molecule there are very few terms and
very few circuits generated from the
terms these are the actual constants
that are read in from the files and
where they're used in the terms and then
finally we take the 87 gates that were
implied by the input show how they break
down for each term which gates of what
type of are available and then we
collapse all of this into a single
unitary matrix once we have this one
unitary matrix we exponentiate it to get
the 32 trotter and we get the 28 bits of
phase estimation you'll also notice
along the way we notice that we've
drifted away from unitary we get
numerical errors as we exponentiate and
so we fix them and bring this back into
unitariness as we go finally we actually
apply the result
at the very bottom we're doing an
arctangent optimization for the phase
estimation there are all sorts of things
you can choose this is from a paper by
savour and Hastings on optimize phase
estimation and then the other bits as we
come up we get higher and higher
confidence in them as we go up in this
case actually everything is 100%
confidence and we finally get a result
at the end the actual line we care about
is the CSV line here and so what I'm
going to do is run it again
let's put that away
we'll run it again
so now we'll bring back the command line
we had and I'm going to add to it a find
of that CSV line this is grep on windows
and then i'm going to sort it by where
the energy starts in column 25 so now
we're running the whole thing again but
now we'll just see sorted energies
coming out and so what you see is these
are the actual phase estimation the 28
phase estimation bits that were read
we'll see that a couple of the outputs
were completely wrong and they have no
overlap with the initial state that we
prepped the system in but all the others
look really good and the only difference
really are those bottom two bits where
we're doing the arctangent approximation
to get a little better accuracy but we
get an energy that is a total energy of
minus one point 137 and then this is the
non nuclear energy if we get rid of the
protons this is the energy of just the
electrons electronic part of the system
there's also more information here of
any information that was in the file
what trotter number what trotter order
and so forth so this is the most useful
line that you'll get from the quantum
chemistry and if we wanted to look at
what the input file that liquid used for
this we can look at h to underscore sto
3g for dot dot and if we take a look we
see a file that has a format that's very
easy for you to generate all the fields
are just a name equals so test TS t
equals starting at zero and this can be
repeated so you can have any number of
molecules in the same file and just pull
them out by test number info is a free
format string that you can use for
anything that goes into the CSV result
in this case we're saying what the bond
angle there is no bond angle for h2 and
the bond distance is this is the nuclear
repulsion this is what's used to go
between the two numbers here the
hartree-fock energy that came out of the
classical quantum chemistry package and
you'll notice this error
she is significantly bigger than what we
got because we're doing a full
configuration interaction model we're
doing a much more accurate model than
came out of the quantum chemistry and
then these are the actual orbitals and
their integrals that were generated so
you can use any number of packages there
are examples in the samples directory
for pi quante and for Sai for the
examples in liquid all come currently
from Sai for if we want to look at a
little more sophisticated molecule we
could look at h2o and it has the same
general format but now there's a lot
more integrals and a lot more
information about the molecule this has
seven orbitals or fourteen spin orbitals
that have to be specified so now we have
these files that you can generate and
load into the system and the user's
manual explains how to generate your own
and if we wanted to run water it's going
to take a while so I'm not going to pipe
the output yet we'll just say run h2o
the system will read it in in this case
now we have 15,000 gates lots more terms
lots more gates of different types and
now we're taking all of these and
collapsing them down into a single
matrix so we collapse them all the way
down and then we're going to
exponentiate and get our answers
normally if we didn't do this this would
take anywhere from one to two hours to
get us one solution for water this way
we get the solute for a solution out
very quickly in about half a minute and
we can get any number of solutions we
want one after the other
and so there's our answers so for
example we're getting a total energy of
minus seventy five point seven two eight
six and so forth so this is pretty good
we're able to do various molecules you
can actually add your own to the system
and what I'd like to do now is to show
how we can do all this from a scripting
level because then you can write
automated scripts to do a lot of this so
what I'm going to do is open up h2 fsx
I'm going to edit and let's just close
everything else and look at this file so
this is an example the fsx files in the
samples directory are good examples of
how you can write code to to automate
liquid and the main piece is there's
always a script module and the script
module is where you put your code
quantum chemistry uses a dictionary of
strings to set all its parameters so for
instance what test number how many bits
of phase estimation what trotter number
and alike all of these are documented in
the user's manual and instead of loading
a data file we're going to do it right
in line by putting data for each test
one after the other here in an array
instead of putting them out in an
outside file so this is fully
self-contained and then just like we had
when we programmed in Visual Studio we
put a liquid attribute in front of the
things we want to call from the command
line in this case we're defining two
functions one is called test and when
it's called Trott test sets which test
number we want to run and Trott uses a
default test number but overrides the
trotter number with whatever trotter
number we want to use so now we can run
liquid just like we did
but now we're going to say load the
script for h2 fsx so that gets it loaded
into the system it will load it compile
it output a DLL and then load that
library back so this will give us a
library we will run off of and then we
have to tell it what to call so we're
going to call our test function in this
case of test number 26 and again I'm
going to pipe that to find of CSV and
pipe that to a sort of plus 25 so now we
compile the script we run the script we
go do everything we did before we really
have the same code we had before and
sure enough we get the same answers and
everything looks pretty good
now we're gonna alter it by saying you
know we already just compiled this dll
why don't we just load the DLL it's
already sitting there
why compile it again and so this time
instead of compiling the script boom we
just ran the DLL and after compiling you
don't have to do it every single time
even though it's a script to show you
the difference in numerical output I'm
going to change this to the Trotter call
and say do a Trotter of 2 which is a
very bad approximation for the system
and now you notice the energies that
come out are much bigger than the
energies we had at our Trotter of 32 and
we can go the other way we could say
let's do a Trotter of 10 and 24 and now
we get even lower energy than we had a
Trotter 32 as we're slowly getting
closer and closer to the exact ground
state or as close as we can get with
this model so that's a good example of
the types of things you can do with some
of the built-in software for more
information I suggest going into the
docs directory and taking a look at
liquid dot PDF this is a hundred page
user's manual that
contains all sorts of information for
the system if you take a look through
the table of contents you'll find we
have all sorts of informations on basic
operation how to write code extending
the simulator how to manipulate circuits
doing quantum error correction advanced
noise modeling the Hamiltonian modes for
both first and second class second
quantized Hamiltonians
and then all the built in samples are
documented as well when you're writing
code it's useful to have an API manual
and in the same directory as a liquid
dot compiled help file a chum file and
here's all the information on what we
were using and in fact if we go into
circuit which we called a few times
there's the circuit compiled called we
used here's the grow gates call and the
various options we go to grow gates says
it takes an option of a grow parameters
going to grow parameters this is all
MSDN style documentation there's over
700 pages of documentation of all the
various api's and that's probably enough
to get started with there's also online
API documentation on the github site and
I suggest using the github site for
interacting with other people and
putting up source code for people to see
as well as using the listserv make sure
you're registered so that you get
notification as we add things to the
system and as we do workshops and make
things available and thank you for your
time
you
each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>