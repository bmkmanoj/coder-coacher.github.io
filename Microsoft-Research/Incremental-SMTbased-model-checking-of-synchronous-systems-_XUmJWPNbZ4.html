<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Incremental SMT-based model checking of synchronous systems | Coder Coacher - Coaching Coders</title><meta content="Incremental SMT-based model checking of synchronous systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Incremental SMT-based model checking of synchronous systems</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_XUmJWPNbZ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
it's my pleasure to introduce Chaz
originally jenna is one of the founders
of the SMT initiative he has been he has
worked in the CBC three-team the CBC for
mod evolution calculus yes it did many
working automated reasoning and today's
we'll talk about his model checker for
cold crying again thanks a lot for the
invitation Leonardo I'll tell you al
mentioned kind but I'll tell you about
the research that we've done around this
this model checker which we hope is
general enough that could be used also
in other contexts of course we have
implemented it in the context of our
current model checker this this is a
program of lasting several years now
that has involved students and other
collaborators I like to acknowledge
these ones for mrs. of mine George egg
and a current visitor from owner of
France peerless garage in two postdocs
getinge and dim echoes I so just to put
this in perspective our goals here are
well pretty much the usual ones and
verification make verification practical
in particular improving performance and
scalability but we are focusing on
embedded software for the simple reason
that well two reasons one its generally
easier to reason about in Venice offer
engine to its more critical to prove
such kind of software correct or at
least potential users are more
interested in that we also focus on
simpler problem improving safety or duly
embarrass of properties and we look at
just synchronous systems our goals were
to capitalize on the initially when we
starting they still are to capitalize on
the various improvements and
enhancements on
automated reasoning two in particular
they go beyond the sort of propositional
logic based approach that have been
common verification in particular model
checking going back from symbolic model
checking using BDDs and then set based
approaches and of course the tiki
technology for us is smt which allows us
to reason about logics that are more
powerful than propositional logic one of
the things that give us I mean smt two
techniques that one of the pluses that
they give us is that we can easily
easily reasonin differently between
about fine estate and infinity systems
when we use them so well what is the
general approach if we want to do is
empty base safety checking I'll be
calling it safety checking because again
to stress it that's what we're doing
given some this formal description of a
system m and the property that we want
to show by system I mean transition
system here convert that automatically
into some fragment of first-order logic
will built in theories for efficiency
reasons and try to prove or disprove the
properties automatic property
automatically using inductive arguments
of course we like to use SMT solvers the
main engine one of the bonuses is that
using this technology or these
technologies allows us to work well both
with control and with data properties
and systems which is usually not the
case or didn't use to be the case for
previous approaches let me give you very
little technical background this is
mostly notation it says stuff that at
least the audience he understands and
knows well so we can look at transition
systems as usual as defined by triple SI
t where s is the state space I is the
set of initial States and to use of
transition relation over the states that
defines the behavior of the system but
as I mentioned we would like to encode
such a system in a suitable logic so for
generality here let's we could consider
in fact all of the approaches that I'm
describing here
apply to any logic where you have
decided I'll entailment okay any logic
in fact when you have efficient
decidable entail so you can think of
propositional logic if you want to as in
any of the SMT logics or added objects
such as the epr fragmented fasola line
let's assume that we have a set of
variables in this logic and some
distinguished terms that we call values
okay now as you all know typically in
such a setting then you can encode stays
as tuples of values the set of initial
states can be represented precisely
usually by a formula that is satisfied
exactly by the tuples that represent the
initial states and then you you can or
we assume that you can encode the
transition relation by a formula in this
logic in two tuples of variables and
tuples if the states are represented by
two balls one for the current state and
one for the next eight so standard stuff
state properties of course can be
encoded as formulas over an n-tuple
availables okay so that syntax here the
notation that I'm using for instance for
the variables it denotes just that I of
X is a formula who's free variables are
among ax vector X okay so remember we
want to if you're doing safety we want
to prove typically that a property is
invariant for a system so we're
interesting and showing I don't have a
point yeah okay we astonishing to
showing it at a given property is
satisfied about all reachable states
well this is usually hard problem so
what we try to do is to approximate it
by showing that a property satisfies
some stronger conditions for instance a
sweet spot usually is that you if you
show that a property is inductive then
of course you've shown that it is
invariant so you try to do that
automatically they are other notions
here such as validity and triviality in
a sense that also give you invariants
but these are you know showing property
is the property have these things is
usually simple I mentioning them because
they'll come up in in the invariant
generation procedure on be describing
next so again this is just to introduce
the terminology the notion of inductive
property can be extended a bit in terms
of K inductive property where you know
typically in the traditionally in
induction when you're defining property
to be inductive you basically say well
it's satisfied by the initial state and
it's preserved by one step transitions
conduction essentially essentially says
that the property is preserved by K
steps transitions so why is that
interesting well because inductive
properties are zero inductive in this
sense and well there are properties they
are k inductive for some k greater than
0 bar they are not inductive in fact
it's a property is k inductive and also
is k plus 1 inductive so there is a
largest set of properties that we could
hope to prove automatically to be
invariant and why can we do that in this
setting because we are assuming that all
of these guys here are formulas are
represented in our logic and entailment
in decide is decidable in that logic so
to prove our property conductive you
just have to run this test and then to
run this test in principle and practice
of course yes is it true that probably
holes on a system then it is gained
active for some some kid no this is what
I was going to say next and the answer
is no for finances systems it's the
answers still no hold over fancy system
you can use improvements to the key to
basically induction algorithm to show
any property to be invariant based on
the fact that if search space is finite
okay but for infinite systems there is
definitely the case that there are in
there are properties that are not
conductor in fact conduction is fairly
weak method by itself it's very easy
it's nice you can use a sim tisha of
approvers off the shelf but it won't get
you a lot okay well which is why you
want to improve on it now of course some
improvement go in a completely different
direction such as interpolation base
model checking okay
what of course I mean you know come up
with something ok doctor man smt base
model checking can prove conductive
properties ok dr. Venus within four
months that's what I'm sorry and vice
versa in fact is one of the things that
I want to discuss with you later for us
it's a nice framework because as I
mentioned it's simple to implement and
you can improve on it these are the
probes of using conduction is a way to
prove invariance I mentioned these also
this is another interesting point the
base case of conduction is essentially
bounded model checking so that means
you're guaranteed using conduction to
find violations of the property so they
exist ok what of course you're not
guarantee it is to prove that an
invariant property holds unless it is
conductive and this is as it should be
because in the infinite state's case at
least in variance is not a recursively
enumerable prob I mean the set of avira
property is not recursively enumerable
so we cannot even hope to have
completeness what we can hope to have is
to improve on whatever method you have
so that the precision of the method is
higher that is it answers yes for more
embarrassing for more and more in their
properties so you have a property that's
gay doctor yeah and there's a procedure
that takes a gay in doctor
creates another property that's abducted
what's the size police say this again so
for every K in dr. Robertson yes there's
a a stronger prophecy dancing dancing
the final state system
property in tip yes simply answer what
is the can characterize
the trailer is there a non-trivial you
mean a sizable trade offs or well well
for me is that I wouldn't know how to
compute that I don't have a general
mechanism on how to compute to that
property that you're referring to
probably to you it gives you a good if
you have very mean you could you could
do something like that if you do
quantifier elimination but so the
question is it's not a decision mice
there is no there is more I mean this is
what i'm going to say now so there are
these cons that some properties are
conducting were very very large case so
it takes a long time to get there and if
the transition relation is large the
unfoldings are going to eventually kill
you and as i said some properties are
knocking inductive at all so how can you
say this again
flat steam machines representing I don't
know we act assistance okay it's good
for programs with loops and recursive
procedures okay no we don't do program
will loops at all because those are not
transition systems in our sense right
but you can convert them gender
transition so I'm asking are they are
those types of transition systems I mean
when you say sometimes assistance do
that I mean what sort of systems ready
but you're not here as I mentioned
before we're interested in an embedded
system in particular we work on models
of embedded systems I mean in our
experience we've been working on model
checking high-level specifications of
systems they haven't been implemented
yet for those systems those investors
there k induction is good for somethin
up ropes definitely oh definitely and it
it's good that you're asking me
questions but I'm gonna tell you all
these things as we go I mean this is
part of a part of the talk yeah the
garment sorry this is just the rigor the
way we work that's fine that's already
made the comment that the set of India
property does not our d 4 in Finnish
stasis why is that I mean I'm thinking
that how you started new Marie because
you have undecidability in general of
but let's say I can just start and you
were eating them and then for each one I
can check whether it isn't up to a large
so eventually I would have a numerator
no no I didn't say inductive I said
invariant oh yes of course inductive
proper the set of inductor privacy is
recursively no rule but they don't
exhaust inductive miss is a sufficient
condition June very right if something
is inductive is invariant but not
necessarily vice versa this is why the
purification problem is hard because we
want to prove inductive now I sorry
you're going to proving variance and
then will we use poor man's version of
invariants which are for instance in
inductive pneus and when it works is
great when it doesn't work we have to to
figure out why so this slice is
introducing a new tuition here that
allows us to do better okay but again
better not necessarily in a proven way
okay we don't have a systematic waited
this so why is it the K induction is not
complete for invariance because you
might have that the base the inductive
step which we can represent here as the
status field satisfiability question
fails ok so if inductive step fails
means that a formula like that one is
satisfied say this again this is
it has an extra work in the tech skate
oh yeah I apologize if this is a spirits
argument here thanks thanks for the
buggy so if this formula fails it's
because we have a sequence of states
along the transition relations where p
is true for the first stage k states and
then it's false in the other one if p is
in duct is sorry if p is invariant it
must be that this sequence is
unreachable okay there's no other
explanation so one way to improve
induction is to say well I don't want to
consider this the sequence okay
eliminate it well this is the general
way you would like to do it one way to
achieve that is to strengthen the
description of the transition relation
if you have a tighter description in
your logic of the transition relation
hopefully that set as 0 there will not
be satisfying any pairs TX x prime and
so you won't have that counter example
so how can you do that well suppose you
know another invariant about the system
you can strengthen the description of
the transition relation by just saying
that well I want the predicate of X also
that is satisfies in there I don't want
an arbitrary X that satisfies this
formula it also has to satisfy this
invariant and I have now the tighter
this invariant the better this formula
will be at discarding it relevant that
is unreachable states okay so this is
one possible way to improve conduction
in fact it gives you a lot of power if
you're able to generate good invariance
the question is of course how do you do
that okay despite this strengthening the
yes different you going to do what the
sameness is bootstrap invariants from
from
I'm simpler there what do you mean by
bootstrap so Jay isn't in bed and you
when you prove that when you check came
down should you basically just that the
Jay takes up
sorry
sports yeah I mean this is the effect is
the same you're adding J here everywhere
okay is there a way to bootstrap k
induction so here jay is yeah yes i we I
don't don't know the answer in general
if I mean where are good ways i can give
you one way that that we have been using
and I'll get to that later well maybe
i'll get to that way depending on your
question so let's leave some suspense
here ok so again they are stronger
approaches to prove invariants using
inductive arguments well again
interpolation base model checking apps
for interpretation PDR now and so on the
good thing about conduction is that
simple but you can improve on it and
make it as good as other approaches I by
adding invariants how do you generate
invariance there are a lot of ways one
thing that we try to do it's on the face
of it's fairly silly but it worked
rather well for us the key is of course
in how you implement it so what is the
idea suppose you don't really know
better what you could do is to say well
I'm going to generate I'll just large
set of formulas that could be invariant
just by luck and I'm going to check them
for invariance by checking their there
are K inductive but I'm going to do this
as a fishing Lee as I can and hope to
get lucky and then any environment that
I can get out of this I'm going to be
using for K induction ok now we call
this a smart brute force because it is a
brute force mechanism but to make it
effective you have to be a bit smart
about it so sorry you something so
something like you Deanie ok or
something like what is that that's
system daikon right well you have some
heuristic ways to generate lots of
candidate invariants but then the
difference here is that we actually
prove these
being their aunts persons in daikon it's
just given to the user not user as a
figure out that was just a way of
throwing up a bunch quickly well we
throw away a bunch very quickly and then
the remaining ones we also proved to be
conducted to be sure that they are they
are in their end the key here is very
quickly and start we're starting with a
very large set so you want to implement
your large set of conjectures see as
compact to you as possible and sift it
you know sift through it as quickly as
possible and as you know as sad or smt
solders are really good at the Sun stuff
so we capitalized again on our
technology so what is our key we have a
general invariant discovering scheme
that again assumes an encoding of our
system in the in a given logic and then
the scheme is parametrized by a template
formula r which represents some binary
relation over a domain one of the
domains of your system okay over you
types uses we assume this this method
the scheme is paralyzed by the procedure
you use to generate the candidate set at
the beginning use whatever we want okay
whatever method you can come up with
that generates terms that might be
interesting to instantiate the template
with so let me give you concrete
examples so one example of our would be
sorry I got it backwards here one
example of our would be implication okay
so implication over boolean terms
another one could be standard less than
over arithmetic terms okay so if this is
the template that is implication or less
than the arguments that we could put in
there are well whatever arguments of the
proper type that you logic accepts so
innocent illogic with arithmetic terms
and you could have examples like this up
notice that the Estancia shin can be
arbitrary can give you arbitrarily
sophisticated
formulas depending on the terms you
start with so here I do have a less than
that I'm instantiated but in fact I have
some control embedded in it because I
can use ites and similarly here
implication is not just between boolean
terms but between arithmetic terms okay
yeah no I'm just saying we really this
now if you want to use our system or
approach it is your business to come up
with the initial set then we can take it
from there okay now right now in our
experiments what we do is we look at the
description of the system and if we
consider all possible sub terms
obviously this this is not going to
scale and in fact there are other things
you want to throw in there are not just
sub terms okay you can come up with but
you know let's assume you have a way to
generate that set then how does the
mechanism work well we use in a sense
BMC or the base case of conduction to
discard as many of these conjectures as
possible from a set by finding real
counter examples okay to the imbalance
once we have filter that set down to one
that we are happy with or you know that
heuristic alee is small enough then we
try to prove their remaining elements of
the set to BK inductive for some k the
ones that we fail with just conserve it
conservatively throw away the ones that
we succeed we keep in the process of
doing this if the initial generations of
terms is not too smart we'll give you a
lot of trivial invariants trivial in the
sense that i mentioned well did i flash
you before those are not really useful
they are embarrassed but they're not
really helpful so a third optional phase
could be trying to identify those in
discarded because here just junk of
course identifying treatment of users is
expensive so sometimes you can just
leave them there okay it's it's really
it depends on on the particular
well that's right maybe it would be good
to put it anyway very good so in fact
this is why we don't discard them often
often because some of the traveling
parents are not eliminating any original
states however the ulemas and so they
are helping the set they might actually
end up helping the SMT solver very good
only the valid ones are the ones that
probably don't help all that much ok so
the mechanism is just what I described
here I well we have some animations but
it's not going to give you much more
than what I told you suppose these are
all our conjectures if we take their all
their conjunction we're making a very
strong claim here they're saying all
these guys old we we test them in the
initial states okay and sure enough
we're going to get lots of counter
examples that allow us to remove some of
these candidates and we do this until we
reach a fixed point for initial states
that it is all the conjectures that we
have do hold for all the initial states
when they repeat the same process so I'm
going quickly here because I've already
mentioned the stuff we repeat the same
process for states reachable in one step
reaching Bowling's to step and so on
where do we stop well heuristic alee we
stop if when we are a frame k and we go
from kate from k to k plus 1 nothing
changes that doesn't really mean that we
found a good spot it's just heuristic
alee one that we decided to do why is
that it's possible indeed it from k to k
plus 1 nothing changes but maybe some of
this stuff could be asked counterexample
some bigger k okay it's better you know
better heuristics could be used to do
that that works for us for now so once
we get to this point then the
conjectures our conjectures that
possibly are invariant we try to prove
mkay inductive simply by doing the k
induction step anything that's falsifies
the
induction step is thrown away again to
be on the safe side anything the remains
has been proven to be invariant one
thing that I want to stress it or didn't
say is that notice that we work with
conjunctions we don't do them one at a
time we do them all together why because
when you get a counterexample usually
get lucky a counterexample eliminates
several conjectures at the same time so
you want to throw away as much stuff as
much junk as possible also as you know
proving something stronger by induction
is usually easier so if you try to prove
that all of them are inductive all the
ones they have remained it's usually
easier than to prove it individually
okay so some of these conjectures have
been generated we're done okay as I
mentioned the question is how do we do
this efficiently by representing the set
compactly and by processing it that is
the set of core conjectures efficiently
so we have two algorithms for doing this
which depend on the size of the domain
in question so remember the template is
a partial order with respect to some
domains over the bullion's was one
example the integers was another example
we have a general mechanism that works
for any binary domain and for any non
binary domain really the distinction is
here finite up to a certain amount and n
greater than that but binary is the
sweet spot really ok so I'll tell you
about I'll show you about the procedure
that we do in the binary case and then
again you can yeah you can imagine what
examples will all be about bullion's but
it could be any binary domain to talk
about that however I need to introduce a
notion before so consider that we have a
set of terms over the domain that we're
working on we can and we have a sequence
of valuations of these terms so in our
algorithm the valuations come from the
counter examples but now just consider
any valuation so for instance if we're
talking about arithmetic consider these
valuations for the terms
a sequence of size three each of these
sequences induces a partial ordering
over the terms which is just the
point-wise extension of the partial
ordering or the domain okay so here I
have that deter Max is less than X plus
1 but y is less than 3 y and so on okay
so having this ordering is going to be
helpful in what I'm going to discuss
later right now so if we look at the
boolean domain is an example of a binary
domain our set of conjectures it's going
to be a set of implications between
terms so see here is the set of terms we
start with conjectures would be
implications between these terms so we
start with a stronger congestion
possible that we say all terms are
related they all apply each other why
because some conjecture can be expressed
linearly by just a chain of equality of
equivalences okay so we start with this
chain we're going to represent our
conjectures as graphs as dags in fact
where each node represents an
equivalence class of terms with respect
to the ordering oh that i have discussed
so far okay so a partial ordering
induces an equivalence class so every
terms in the nodes are related to each
other ok and then links between the
nodes are going to represent the fact
that every node in sorry every time in
one node is smaller than every term in
the other node ok in the partial
ordering that we're building with these
assignments the partial ordering in
question which is built out of the
sequence will be built incrementally as
we build the sequence so we start
initially with the empty sequence which
means everything is in there everything
is related to each other then we extend
the sequence where the first counter
model that we get in the process I
described before then with the second
and so on so we have a graph that starts
to be really compact
and starts growing as we get to counter
examples to the less than relation said
again you're familiar with that I
expected
yes in fact I should have said I should
have said this at the beginning this
work is inspired by that paper for those
since you know that what we do is
everything that that method does and
more we definitely did the identify all
equivalences between terms which was the
original motivation there because that
we're doing circuits but we do more than
that because we also do implications
instead of equivalent system okay so
suppose we have this situation here so
the conjecture is all terms are
equivalent and assume that we get a
counter model or you know a model that
gives these values 0 for false and one
for true to the terms so what does that
mean that well it's not true that these
terms are equivalent okay according to
the moth the ordering that we're
building so we break that bubble into
the ones that we have seen to be false
so far and the ones we've seen to be
true so what do we know with the current
evidence these guys could all be
equivalent and these guys could all be
equivalent but definitely these guys
guys here are not equivalent to guys
here because we have a counter exam but
as far as we know everything in here
could imply everything in here we don't
have evidence to the contrary yet well
each one each one this is an equivalence
class Julie each of them individually
can imply that issue each guy in here
could imply to remember we assuming that
these guys are equivalent so pick a
representative whatever right so the
edge means any term in here quadratic M
times and exactly so this is the
compactness that we get we are
representing our quadratic number of
implications linearly okay next counter
example well some of the assignments
here are going to break some of these
bubbles again in particular here both
bubbles are broken but what do we know
about these two bubbles the same thing
that I mentioned before well they are
not equal in terms in urine or
equivalent but I only have a counter
argument for one direction for the other
one I have to play
conservatively and maintain it so far
what about these guys well these guys
can be connected by remembering the
previous link so the previous link is
somehow in well in a sense inherited by
the new guys and there's the point of
our algorithm is coming up with a
systematic and sound way to do this
inheritance I mean that's a non-trivial
ax t the non-trivial part there and so
but you know if you look at in terms of
ordering notice that the links respect
the ordering okay these guys are smaller
than these guys in the point Weiss
ordering between these pairs and you
know it's true for all though that we
get here okay the trick is that we don't
want this link technically this link is
possible right because everything here
is smaller than everything here but this
link is redundant weaker because we have
these two so the algorithm also tries to
minimize redundant links now look at
this as a conjecture what is this a is
saying i have quadratically many
implication between these two guys
between these guys and none between
these guys I need to represent because
they are a consequence of transitivity
of my partial order so we don't throw we
don't you know we do this in a sense
marginal transitivity and we maintain
this set of conjectures very compactly
when we give it to the SAT solver or the
SMT solver we literally do this here
this is a chain of inequalities oh sorry
chain of equivalences we pick one guy we
say that is that implies some
representative here and so on so we get
a very small set of formulas they
represent our large conjecture okay and
well again we continue to there are
other cases like this one where things
are broken this way and well or things
are broken this way but there's actually
a fine a number of configurations that
you need to consider why because since
you are in a binary domain there's only
a finite number
you're in the final domain there's only
a fine a number of ways to break the
graph and you hear it the links in an
infinite domain that's not the case so
this algorithm will not work in
particular when I have to connect two
new nodes I have to figure out which of
the ancestors I should connect these
nodes to in the binary case I know I too
need to look at most of the grandfather
in the infinite case I could have to go
you know an unbounded number I would
have to look at an unbounded number of
ancestors so this algorithm doesn't work
in infinite k it's the way we're doing
it is linear in the number of nodes and
edges and this is most likely we haven't
done a precise analysis at the cost of
optimality that is some k sometimes we
do get those redundant edges that I
mentioned it's just too expensive to
make sure that you never every done
digest yeah if you throw a few edges
redone register in the in the final
formula it's really not a big deal okay
so how does this relate to stall marks
if at all
they're your conjecturing are you make a
choice that like the two formulas are
equal insertive
look at the implications I'm trying to
understand yeah I available sorry the
obvious answer is Thomas Marcus is a way
to check the satisfiability here we were
checking we're trying to show
equivalence between these guys or
implications so I I don't see an
immediate an immediate connection maybe
there is one but I don't see it right
now all right in the domain numeric
domains we have generalized this to
numeric domains we can't use the graph
however we can use partial order sorting
that is well again we have all these
tuples and these tuples which represent
the counter models have seen so far
associated two classes of terms and
these are the terms that we want to
order okay so we were order terms
according to these tuples that they are
associated with and the ordering is
refined so the important thing here is
that this is an incremental step every
time that you have a new counter model
then you have an ordering on a slightly
larger tubule a larger by one however
the current partial ordering that you
have is change with respect to the
previous one only in various in number
of small ways okay so this allows us to
this incrementally allows us to do some
operations quickly and in fact we've
come up with a new partial ordering
pressure sorting algorithm that well
it's cubic but it's cubic in the number
of nodes the height of the partial
ordering and the width is just the
point-wise extension of less than
the partial army is over two poles
remember oh that's right so the ordering
over the individual elements is just
less than and over tuples is the point
twice extension ok so this well this
tuple is smaller than this means that
you have some language and you're trying
to find the strongest theory expressible
in that language that's consistent with
your evidence which is your your two
balls mmm or the theory being the
conjecture yes definitely yeah yeah the
idea in general is not I mean it's
fairly simple as i said the the
contribution is in the actual mechanisms
that we have implemented that's
something that's going to be at least
you know quadratic in size yeah in the
number of terms that you go to get price
so
so the methods used for cell rap for
watch sumit and sabra variants
generation from templates and use
counter examples by sets of terms so
your methods have these directions see
that's why it's good to give talk to
these audiences I'm not aware of that
paper yesterday I discovered another
paper and it wasn't aware that you have
what to learn it from also you're
talking about the learning algorithm
okay so you've earned these what are the
possible invariants so at the end
anytime they have a conjecture that is
based on what they've seems so far and
they modify the conjecture is that what
they do I mean you could see this as a
learning algorithm in that sense right
it is uh Ken says you know you have a
theory and you're trying the theory
explains your observations and you're
trying to solve sorry use the smt solver
as your your tutor a tutor is giving you
the answers of is giving you exact well
in this case it's only done by
counter-examples not by positive example
so it's a very limited form of learning
learning by counter examples but it's
essentially what we're doing yes I
understand Edinburgh so when you say
counter examples these are run by the
right we'll see so imagine the first
conjecture the first conjecture says all
these terms are equivalent okay so you
try to prove that in the initial States
so when you start you say the initial
state condition implies that sure enough
you're going to get a lot of counter
examples throw away that and you keep
doing it sorry whether yes but a very
restricted kind of learning okay but
counter example it's a it's reminiscence
of version spaces some ancient learning
techniques except that in version spaces
you start with an under approximation
and an over approximation and use your
positive ink and negative counter
examples they haven't converge the
problem with version spaces that often
actually they will go like that in this
case we're just doing one direction we
start well from bottom up we start with
a very very strong conjecture and we
weaken a Greek and equipment until it
explains all the observations that we
see and so as I said in the numeric case
you can do similar things we have an
algorithm there on the face of it is
cubic except that in practice H the
height of our graphs are usually small
because it depends on well on the kind
of problem it doesn't read the good
thing is this measure does not depend on
the size of the initial set well it
doesn't depend quadratically on the size
of the initial set sorry n is the number
of nose and so the initial number of
terms it depends on on the intrinsic
properties of this ordering so you can
get lucky and have very flat situations
where you go very quickly
greater than
sit again h times w is greater than
equal to it well they are will lead it
right in suppose the height is always
one then the width is exactly in right
Oh vice versa suppose the width is 1
then the height is going to be exactly
in so in the worst case we get quadratic
essentially for us okay in the worst
best case where could I know Nikolai's
making an important point he's saying
that HW cannot be is at least order am
so really tell u by del x itself right
order is order n square so this is yes
so I was you know I said before that we
want compact in the sense of less than n
square we don't quite get that but if
this is actually quite good because
existing learning algorithm are
effectively cubic its existing partial
ordering algorithm their factory cubed
but for our purposes often 'he is
bounded and so in fact this is quadratic
it's good enough terminal results so we
work with so our kind model checker we
created a module that generates
invariants integrated into the model
checker in fact one thing that I haven't
described to you is that the real
implementation now is incremental
incremental meaning that we don't wait
until the end to produce the invariants
for every k we're able to produce in
barron's okay which means that since
kind is parallel we feed invariants as
they are discovered to the kind process
as kind is trying to prove by induction
the property you started with which
means that as soon as you Varian
generator is given to kind kind use this
is to strengthen conduction and often
this leads to effectively making the
property that you wanted easily provable
with the invariant but again you don't
have to wait until the process finishes
so you're using this you know bikini
line technique and you're generating
counter-examples to induction much going
to your building your grandson do those
counter-examples to adduction comes from
k induction for one induction conduction
conduction right so that means that you
could have had their conjectures you
could have thrown out at k equals two
we'll come back in and vehicles through
the ones that the ones that we thrown
out in the the BMC's that run that is
the base case of conduction I definitely
those that we do the ones that we throw
out a que before I said the ones that
that we falsify in the inductive step we
throw away we don't actually throw them
away we keep them around hoping that
they are k plus 1 inductive that's
exactly the process the ones that we
prove 4k so what we do a k equals to
some stuff is not conductive set aside
the stuff that remains try again right
set aside try again at some point in
some stuffy is to inductive we will
succeed will always succeed because in
the worst case we get true true is to
inductive and and so you know we will
pass those and then move to the other
ones so there is always some stuff that
we can do increasing the game yes I see
well there is a loop in the invariant
generation and there is two loops in the
conduction proper that is in the model
checker the model checker is doing the
base case and the conductive step also
parallel everything goes on in parallel
and then they synchronize the proper
times to show you so the K the K
induction step of the model checker
fails asks the in barren generation do
you have anything for me if it does then
uses then when it succeeds it asks the
bounded I mean the base case if you find
any counter example okay if you arrive
to K because if you haven't I have to
wait picture of this job I do walks with
that actually do you mind if we go over
the picture later because I want to tell
you about the results because you know
yet so we've integrated this in kind
and we work with bullying invariant a
psychic and I flash you this kind works
over where is it the impolite your kind
is the loose your language for those you
know I don't have to say anything those
who don't know it's just yet another
language to express transition systems
you know something like I send a few
female with SMB I think actually we were
inspired by looster know ok but there
are definitely similarities ok so except
that you you don't have a restriction to
finite types you can have infinite types
by infinite types I mean of course in
mathematical integers is an
approximation of machine and the Jews
and that kind of stuff all right so we
produce invariants of this form where
these guys are bullying looster terms or
this forum's where these guys are
arithmatic booster terms excuse me and
again notice that since we look at
conjunctions on these embarrass double
implication is effectively equivalent so
we discover equivalence between sub
streams or even arithmatic equality and
the benchmarks we tried we had well
about a thousand loose benchmarks where
we have a model and a single property to
be shown in Behrendt if you run kind in
you know a decent configuration here an
inductive mode that is trying to prove
invariance kind can prove thirty-three
percent of these benchmarks can prove
these benchmarks be valid meaning that
the property is invariant can dispute
disprove forty-seven percent by found an
actual counter example and is unknown I
mean cannot solve twenty one percent now
we throw in the invariant generators and
so again knowing Behrendt we can solve
aside if we now focus just on the val
or unsolved properties under the
assumption that the unsolved properties
are probably valid okay because we have
run kind for a long time in B&amp;amp;C mode
couldn't find any counter examples there
most likely valid okay no no no they're
not fire yes yes but the theories that
you are using our only integers and
propositional logic integers
propositional logic reals well in fact
you also use on interpret function
symbols for convenience they're not
really needed we represent a loser
rooster is a dataflow language so in
fact it's variables or streams and
represent streams as functions over the
natural numbers in our encoding it
doesn't have to be like that it's just
convenient for us to do it that way okay
you don't it's not necessary to to do to
achieve the same sort of results alright
so that's the current situation that is
no invariants if you throw in boolean
invariants then we go from 61 percent
accuracy 277 with integer invariants we
go to just integer invariance we go to
82 if we put them together we go to 86
this might not look too impressive with
respect to these two you only go from 80
to 286 but let me point out that integer
and Vera's often contain boolean and
variance in them and vice versa for
instance a boolean invariance that might
be get generated so I a boolean
conjecture it might be get it might be
generated is one of the form X less than
y equals true so this is effectively a
less than invariant that however your
recasting is a boolean one and vice
versa okay so these guys are not really
a disjoint there's lots of overlap in
these experiments are these just terms
that occurred in
programs yes plus a few more terms that
we throw in for a good measure so yeah
any idea what's going on with the
remaining 72 what what are you gonna do
know yeah it's a cool thing I gave you a
million-dollar ya say okay I want
announcer 2 also they do we want to
produce smarter improve the initial
phase the face where we generate
candidate conjectures okay we've
actually done it in a follow-up paper
that I don't have time to tell you about
for a lot of these systems there is a
business of modes these systems and
modes which are essentially fine estate
situations and when you encode them in
looster you lose mode information and
you can try to recover mode information
experimentally and then throw in
invariants that have to do with the
modes there are not evident in the Dean
code in the loser encoding I can tell
you about this offline so we've done
that and we have experienced that show
if you throw in these other guys to talk
about modem Barons what in Vera's will
be something like if X is 1 then why is
either 1 or 2 or 0 for something like
that where X is encoding some mode and
and wise encoding some Alamo if you
throw those in well you should not have
lost those in the first place but the
encoding is if the encoding is not so
good which is the case often you lose
them if you throw those in it you get
more mileage hours I can't talk about
these ones because these ones actually
don't have a lot of moes we've done it
for another one for another set of
benchmarks and to those we go to
something like ninety one-percent and ID
too but but again no these numbers don't
mean much I mean I want to stress these
results might say something about the
goodness of our method or they might say
something about the properties of
hardened valence set right i mean it's
always usual issue of how representative
these things are however one thing i
want to say are we have an industrial
users is using kind rock will clear our
friends at rockwell collins and they
tell us that are quite happy with this
feature for the sort of things that they
do so we just have anecdotal evidence
that it is cell phone mm-hmm I think
that you don't bling
how cool this is this is very cool for
the following reason now you have set a
bar for any future sophisticated Indian
generation right you have to be at least
as good as the super dad right this is
so simple all the stuff yeah well again
in the spirit or not underselling are
saying is the idea is simple the
execution is not be you okay but the
execution is fairly sophisticated to get
that education see what's the time of
that you can do benchmarking sold what
are we talking about yeah oh I forget
what its what's on the previous like oh
I did have it oh I'm in edison 120
seconds sorry actually I do have more
but again you know the day sorry what do
you put it back to work with nothing but
a music but have you seen the benchmark
sorry it's nothing meaning small yeah
yeah yes by have you seen the benchmarks
yeah you know those benchmarks are not
an impressive right i mean this uh they
go from fairly small to moderate large
not huge no you guys know a doubling
doesn't help I mean if a property is not
conductive yeah we respect to the
transition relation and the invariance
you have doubling the time is not gonna
do triply you know good infinite time
it's not gonna prove it okay I know that
so the only thing that you can hope here
is that you throw in more and more
embarrassed yeah that's why it was lying
people to do it's really pretty good you
know ya get a few out there K equals to
get one but let me tell you i have these
interesting results yet but III won't
can to see these for the valid ones that
there is the ones they are provable
without invariants okay
adding variants accelerates stuff as
you're saying without invariants the
percentage of problems properties there
are more than 1k in Dutch the more than
that inductive that is conductive for
real is fourteen percent in our set when
you throw in the invariance we go down
to three so you're really trivializing
the purdy the property with these
embarrassed which a suit gives us a good
measure that these are good in barrett's
okay because now here we can compare in
fact it is also true for for the other
ones well it was sense for the
unsolvable ones we go from we would
conjecture k equals infinity because
again it's not that probably is not that
case too big we don't get it just k does
not exist so we accelerate from infinity
again to very small K in some cases we
go we have 20 but I mean there's a rare
which again means that in various are
our quality and also gives you some hope
that the smarter techniques you come up
with to produce high quality invariants
the better this is going to work right
it our architecture now accepts any
variant generator so you don't like this
stuff give me your invent you know you
plug in my your invariant generator as
long as it is a stream generator then
this everything is going to work just
nicely in fact and I wanna I'm going
over over time but I want to conclude
with this interesting observation so are
our users don't care about a single
property like they have 20 30 50
properties that they want to prove about
a system and they want to prove them all
at the same time I mean they want to
prove them all of them okay so you can't
prove them separately just it takes
forever is inadequate you can try to
prove them together by just as a
conjunction but then if you know any one
of them is not invariant then you're
done you know the conjunction is false
and so that breaks away if you're doing
this naive way okay also even if they're
all in the
errands since we're doing conduction
some could be conducted for if even if
they are all inductive okay inductive
some might be inducted for a small case
and for a bit k so we have modified our
induction algorithm so that it does
something similar to what I mentioned
earlier that is it considers the
conjunction but then it looks at the
properties individually and throws those
away that are definitely not in there
and it keeps the other ones and so on
now what happens if you prove a property
to be one inductor we throw it back in
as a as an invariant while we're trying
to prove the other ones so the
properties actually help each other but
a lot more than in the standard sense of
oh okay I proved them all all try to
prove all of them at the same time I
have a stronger conjecture it's there's
a slight difference here that once you
put one invariant then you don't have
the obligation to reprove it you just
throw in as an invariant it cuts the
search space like crazy often we are
able to prove using this thing we're
able to prove all the properties without
generating auxiliary invariance at all
they just help each other which kind of
makes sense because if you think how
people right properties often properties
are related and some are in fact lemmas
for other properties you can see why you
use my rockwell collins the design of
the steroid you have they actually write
their designs and simulink sand then
they have produced a converter from
simulate models to loose your models and
then they feed them to kind so yes
initially they had they have a nice
picture that they go to looster and then
they went to sell new smv PVS saul
approver you know the commercial system
and some something else that now I
forget now they've had a kind and well
for what they tell me they're happy
enough for now we're kind of just using
kind
like how kind of careful now
you know they even they couldn't even if
they wanted they couldn't give me
numbers because this is all anecdotal
okay that is it been playing where their
models and so on it's not like they've
not done a serious study in comparison
study okay they come and say oh we ready
you know what we couldn't prove this
with prover but kind is just fine you
know where well actually prove Aries
faster here but we don't really mind
because kind is fast enough you know I
again don't I don't want to make any
claim here that that's it's the only
thing that they need in fact they're
keeping all the others but in the within
the latest rounds with all these
embarrassed and so on they said that
they're quite happy your tool takes
mm-hmm
but the method itself can you say
something about whether there's anything
specific to post no not at all in fact
my last slide talks about kind to that
we have started implementing developing
that will be disconnected from loser
just have a front elusive front end and
then we'll be able to accept other
languages so critical
in fact when we started I thought that
we could capitalize on looster specific
encoding to do better and it turns out
really meant it's it's not really
necessary to to be tied to booster is
this is the semantics or booster well
define that there is agreement among
pretty much everybody yes means so the
loser is defined formally one catch I
should explain is that loser is a
specification language but it asks it's
an executable specification language so
it has real data types meaning it has
fine machine integers and floating
points and we don't really work with
rooster we work with idealized looster
so you know we can't catch all we have
this done standard on some these issues
by real so we don't catch and applause
is yeah that kind of thing however
notice there's nothing specific in our
approach I'm sorry nothing are coded in
our approach the limits us this way that
is once we get an smt solver it is good
and up with floats or with bit vectors
then we can just switch to the Acura
semantics everything else works I mean
at least in principle you know in
practice we'll have to see but okay well
you wanted the architecture this is the
main architecture assuming jump just one
in there and generator but in fact you
could have several and they all go but
they all work independently and also the
architecture is such that they
synchronize only rarely only as needed
this is very low latency this guy is it
be BMC it just shoots until he finds a
counterexample when he finds the counter
examples tells this guy i found a
counter example for property p 1 so this
guy's knows that it can throw this away
when this guy proves a property it
double checks with this guy says I prove
the property to be three inductive have
you gotten to three yet if you haven't
gotten to 308
if you have a right to three it means
that there's no problem I can really
certify it to be to beat conduct since
this guy is a lot faster this is just
BMC in fact anytime the inductive step
succeeds it doesn't have to eat anything
at all because this guy's if case 10
here this is 200 the invariants are just
sending a message queue to it well a
general message queue to the sky and any
time the inductive step fails it looks
for invariance if any invariance is
arrived it's used if knowing variants
have arrived then k is increased so that
means that if the very generator keeps
generating invariants it's possible for
K never increase more than one you
really keep generating in this is a
generating in videos as if you're
reading candidates in Barron's so that
is oh yeah those are so basically I mean
k dr is also going on inside yeah but
this is just an artifact of our method
is promising when something comes across
and three there it is promising this is
truly invariant it's really an embed
right now we have another whipped
generator we have worked on another
invariant generation both based on
appstore interpretation techniques which
is still incremental in this sense that
is a computa postfix point but instead
of waiting until the final computation
that is the postfix point is being
computed it at any intermediate step it
tries to figure out as if the pieces of
the current apps are elements are
invariant if they are they are sent back
there they're sent to the guy so I mean
any incremental invariant generator will
plug in here again but they have to be
there that's the meter in their head
that the system uses
well this I you know the summary I don't
think I need to give to you future work
kind to I mentioned we want to work on
more impaired and generation techniques
one of the reasons I'm here is to pick
people's brain I'm going to try to do
that we can I think we can use
interpolation ideas to generate more
invariance yeah
no the architecture stop sure so if all
the candidate was missing happening in
the right box then why is there so much
time difference between the bay step
process and inductive step process I
mean they're all all their delaria the
sexiest and three steps right that's a
good question but let's ignore this for
now suppose we didn't have invariance
the base process is just doing BMC ok
this is doing real work in a sense
because it's trying to prove that the
property is conductive and unless the
property is conductive would say zero
inductive is going to fail and then it's
going to increment okay so it's always
going to generate larger and larger
traces yes but this starts from the
initial state the initial state
especially if your initial state is
small it's going to generate very few
traces right here in induction you don't
make any assumption on the first set of
states so it can be anything there are a
lot more solutions here than there here
so that means a lot more to do to prove
stuff or disprove it then there is here
I mean it's the reason why BMC is really
efficient as opposed to model checking
proper I mean when you're trying to to
prove something that there's something
holds it's a lot harder than trying to
find counter example now of course if
the system is if the the model is big
enough even BMC my slow down or die
because you're doing on rolling when
then the usual techniques can be used
like abstraction kind actually as
abstract one form of abstraction where
you actually don't work on the real
transition relation are you working on
the next abstract wine if you can't
account for example you verify that it's
a real one if it's not you you refine
the usual sigur stuff what
what is the abstraction that you do this
ah we just do what is a call forget the
name but it's the loser programs are
defined in terms of equations so every
stream is equal as a definition so we
throw away definitions is if you look at
Circus is like considering a a signal to
be an input signal you throw away the
subcircuit so define it and then when
wen we need to to refine we throw in
stop ok you know you do it in a way that
capitalizes again on the SMT solvers
forces as usual if we find a counter
example then we do an analysis of the
unsatisfiable core to see which signals
which you really throw a definition in
all usual stuff but not too
sophisticated I said any other
techniques you can imagine applying this
is all orthogonal here to try to measure
the advancing is form at home I mean
usually to purchase events I guess yeah
I'd like to now we haven't done any of
these studies yet what I can tell you
where is that for instance we played
with we do have what do we have these
settings where Christians you I don't
know if I have them here you can
eliminate the trivial in variance and
the redundant edges right here we are
using the strong version of our
invariant generation algorithm that
tries to to minimize the number of
redundant edges but we don't care about
eliminating trivial imbalance if you do
if you set this to false yeah you get a
tighter set of invariance but in fact
it's not better because you spend a lot
of time in trying to eliminate the
triple in value and perhaps since you're
eliminating lemmas you're also asking
the solver to do more work these are
difficult thing answer questions to
answer we haven't done a serious study
on this but of course it's something
that should be done because at some
point you're going to swamp the system
William bear
think we've been using yikes and I guess
d3 is the same you can throw a lot of
crap of them and I'll just go on right
so generate lots of invariance a lot of
them are useless well it turned out not
to be harmful so we haven't been
motivated so far at the same time our
systems have been relatively small I
would imagine that our systems are big
you have to start being careful about
these things</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>