<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Isomorphism and Program Equivalence | Coder Coacher - Coaching Coders</title><meta content="Isomorphism and Program Equivalence - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Isomorphism and Program Equivalence</b></h2><h5 class="post__date">2016-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VgAN2QalBKk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay it's my great pleasure to have Tim
Wood visiting us from Imperial College
London today jim has been working with
Sofia cross pelu for last couple of
years on the idea of program equivalence
and theorem provers and and that's
something of interest to us and so I
think he's going to present two talks
today first one he just presented at a
workshop at splash and the other one
more of a work in progress so yeah Tim
welcome great thank you nice to be here
um yeah so I mean talk about two pieces
of work the first one is a joint piece
of work with with my supervisor sophia
drosophila so and the context is we're
interested in program maintenance where
programmers have to take an existing
piece of software potentially large
piece of software and make some kind of
modification to it change its behavior
add a new feature fix a bug something
like that and when they do that they
want to usually want to somehow preserve
most of the behavior of the existing
program and what they don't want to do
is unintentionally break some existing
private and usually they don't want to
or they don't exist specifications for
the entire program maybe not tests or
very good tests and they don't really
want to have to read the whole program
first saying done one after one
understand the whole program with when
they can
and so the two questions that we're
trying to address here or what exactly
does it mean to preserve most of the
behavior of a program and ever got some
way of checking whether or not they've
done that and so what I'm going to do in
this talk is try to propose some precise
criteria for EM for this pond a partial
preservation of behavior and which is
that only some objects should be
affected by the change and the rest of
the objects should be should continue to
behave in the way they were previously
they did previously and and we're going
to ask the programmer to tell us what
those objects are so they're going to
provide us with some expression which
says this change was intended to impact
these objects and if it impacts any
others then then it's done something
that I didn't want it to do sorry
surgery
and then we need some way to to check
this now we're we're developing a tool
which just test generation and to try
and produce tests that falsify this
condition I'm not really going to talk
about the tool i'm just going to focus
more on the formal side of it and the
what we wanted to achieve was that we
didn't need to track all of the
unaffected objects and join the whole of
the program execution in order to be
able to and to check these conditions
because because the progress we're very
big and we don't want to generate tests
that have to explore the entire the
entire program in order to explore the
bit that we've changed and so we we're
going to propose this this sufficient
condition for RM equivalence behavioral
equivalence criteria that this says that
if the if the trace of method calls
between the bit of the program that we
wanted to impact in the bit that we
didn't are preserved in some way between
the two executions then we know that the
the impact is contained within that
within those affected objects we did a
proof machine check proof using using
Daphne and from Microsoft which maybe
I'll talk a little bit about depending
on the time and so this is a kind of
small example program that and gets a
list of students from somewhere from a
database and via some calls eventually
tries to award a prize to the top three
students in the list and and OH wrongly
um
go back one of the things that it does
is it prints out there all the names of
all of the students that it considered
when deciding whose reward the prize to
but it prints it out in whatever order
the list happens to be and a developer
decides to come along and change it so
that it prints the students in name
order so what we ask the developers to
do is tell us to elect it to allege that
some of these objects are affected and
and then we assume that all while we we
take that to mean that the developer did
not intend to affect any other objects
so here we expect that the object that's
doing the IO to be affected the logger
to be affected and the objects in this
list to be affected because we're going
to we're going to try and sort them so
we're going to have to query them we're
going to have to query the list we have
to query the students and which means
call an additional methods on on these
references are expressions of you look
at the entire class we write so and so
actually what we do in storage them agam
long and talking about but we the
program can give us an arbitrary as well
a side-effect free Java expression that
we run when objects are constructed to
decide whether or not they should be
affected so they can write anything they
won over the whole state of the program
at that time so it can be the class of
the object it can be we know which lime
we were executing we know there
something about the context at least
some over approximation of the context
and so you know they can say all of the
all of the students objects constructed
inside the database or they could say
the object online 20 or you know we're
fairly is fairly arbitrary what they
could write but there's a trade-off
between that and the performance of the
analysis so if they write something
that's very difficult to calculate it's
going to take a long time to run and
because we're going to explore the
product lawson pass through the program
and we have to run it a lot of times and
the positive bank runs that also post as
a allegedly effective right exactly so
we're trying to find and we're trying to
find some input for the program that
produces produces if we run both
versions the program produces at some
point program states that we can't match
together and a bottle I'll say precisely
what i mean by much together shortly and
so here this program has as a bug this
sort as a side effect on the list so
went by the time we get to hear the this
object is going to execute differently
it's going to get different students
given the prizes that alphabetically
first students will get the prizes which
is good for some people not for me
so I the I guess the the motivation for
using this criterion is that it doesn't
require a programmer to say anything
about the part of the program program
that they aren't impacting the idea is
that they only have to talk about the
objects that they intended to do
something to and hopefully they can they
can not even read the rest of the
program and we're going to tell them if
it was safe to do that so what's what i
mean by have the state's correspond well
we're going to say that they correspond
when the stack in the heap have the same
shape if we throw away all of the
affected objects and so this is a stack
in the heat and this is from version
one's promotion too and here this one
has this additional point this is a
different different program by the way
this is actually a program that puts
things in and out of the list there the
stack and he put the other example is
too big to draw and the so these these
don't correspond if we cuz they're all
of the objects but what we do is we
delete the unaffected pots and now they
they do correspond and have exactly the
same shape
yeah so what we didn't want to do was
have to precisely execute the both
versions of the program and every pair
of states try and decide if they
correspond or not so we're going to do
is only compare the method calls between
the these affected allegedly affected
and unaffected objects and so this is an
execution of version 1 this is an
execution aversion to and these are all
different states are drew them all the
same and it's really subtle elimination
I meant if excellent and so so we only
have to consider some of the state so
here this one this one this one this one
this one this one which are where method
calls happen method calls or returns
happen between the affected and infected
objects and and actually we only need to
consider the the topmost stack frame of
each of those states which will have the
method parameters will return by unit
the yes the nice thing is that this sort
of abstracts the difference in the
number of execution steps which can
occur in the in the affected pot so not
have to search to find out which states
to compare we we just picked these
precise points in the execution so you
end up and to do something like this and
I guess the the intuition is that the
code of the of the unaffected objects
and the the values in the method calls
uniquely determine the way that the
unaffected objects will execute
so this is what we do the traces so this
is this is the trace of calls and
returns between the unaffected and
affected objects these the values which
are pointers into into the heat these
are addresses although we can deal with
primitives and things as well I'm
shining here m and this is the trace
from an execution aversion to and we can
see that the trace has the same aliens
alien structure so everywhere there's a
10 in this trace for example there's a 3
in this race okay that's what we need to
check is quite straightforward to do and
just read no it's a trace of method
calls and returns so II whenever and so
that we have for example the court this
is a constructor call and then a return
and then sometime later we we add
something into the list and then there's
a return and then sometime after that we
add something else as a return remove
something return remove something so
it's like I guess you can think of it is
the protocol between the the affected
and the unaffected objects we
arbitrarily partition the program and
then try to examine the protocol that
observed between the two parts and and
then see if it's if it's preserved
between the two versions and
and if this if this contains all of the
all of the information that flows
between those two halves of the program
then we can say something about the
equivalence of the bit where the code is
the same
make sense
these numbers and behavior should we
think of a mess as the values of the
pointers themselves yeah they're the
values of the pointers so I mean they
can be different between different
versions of I mean they can be different
between different runs of the same
version just do to address allocation
and they're certainly different between
different runs of the same different
runs of different versions because the
modified version is free to allocate
extra objects not allocate stuff do
whatever it wants the I guess the point
is that the Soudan in Java generally you
can ignore in some slight problems but
which you can detect and deal with berm
and the only thing you can tell about an
object that you've been given to a
reference to without sending it a method
is whether or not you've got the same
object and two points them in the
execution or different objects and so
it's sufficient to just check whether or
not when you talk to another object it's
giving you back the same reference or a
different one and if in all the plate
places in the first version where it
gave you the same reference it does in
the second version then you can't
observe any any further anything else
about about what's happening and there's
some things to do with with hash codes
and reflection which occur in Java in
various other languages there's ways to
actually get hold of the real values
unfortunately but you can easily check
whether or not our programs doing that
and and then tell the probe the program
is
so it this is an example of one which is
not the same so here there's a 4 here
and there's one here but here there's a
24 graph of the heat of the curve a
smart visit no so what no we literally
just look at these numbers so what the
we don't look at the heap or so what
what we what I do in the what the tall
actually does is it maintains two
separate address spaces based on whether
or not the objects are affected or
unaffected and which makes detecting the
traces very easy whenever you have a
call between an objects and one address
place near that you just you know you've
got the trace and then it keeps track of
the order that it saw the objects in so
when it sees this one it tags it with
one and then this one it typed with two
and then it's using you 10 times with 3
just with the counter and does the same
thing in this one and then if the traces
are equal so it is very very cheap to
check the only slight did the thing that
makes it less cheap is that if you've
got I'm not sure if I should get into
this if you've got primitives in here
and you're trying to slightly more
abstractly and which we do the symbolic
xq you have to check if the parameters
were calculated the same way or or if
they if equivalent values have been
calculated for the primitive but and
we're certainly fur for the object graph
is is extremely cheap to check that the
only problem is obviously having to
produce these traces
the word of the affected and unaffected
set of objects show up in this picture
taking advantage of that yes so so the
only things they appear in the trace or
calls where either the caller was
affected and that collie was unaffected
or or vice versa including constructor
calls and returns and so we try we're
trying to capture that I guess the flow
of information between the two the two
parts the whole thing into an inference
problem where instead of letting
programmer specifying these sets
transmen further than presentable so
just doing this creative people what
would it be too expensive and yam is
something we considered that I think
that you could what you can probably do
is take some I mean that there's
probably other things you could do as
well something that occurred to this was
that you could take the the test suite
and run it and then try to guess some
some partition based on that and then do
this to try and explore whether or not
and that was reasonable partition or and
but you do and you can give some kind of
meaning to that partition while looking
at whether whether there's i/o
operations occur within the with which I
owe operations occur within the affected
part to try and give it some meaning to
the program and because otherwise if you
just come up with some there's always
there is always some partition so you
need to sort of then somehow give the
program as some how about whether or not
this was the one they wanted or not and
asking them to specify is a very firm
way of doing that they have to think
about it for themselves but
you could try to find a middle way say
you minimize the effect yeah yeah
yeah and I think I think it could be
useful and to try and touch when Tia and
it's and if you can generate a big set
of traces somehow it's very cheap to
check so you can probably try and brute
force in some way yeah yeah so there's a
bunch of other things that you have to
check that you're not doing very few
programming languages actually abstract
the addresses completely and it seems so
don't know so am I try and talk about
this quickly and we can talk about more
if people want to I've got not I've got
some extra slides with more details on
it we wanted to get into that or and so
so yeah I give this talk a workshop and
I guess I was doing there but Daphne
adverb so it's not very specific but so
what what we do is we write a function
that actually execute the the
operational semantics of the language
that we're interested in and even you
can run this and this here we have the
instructions and then you can just do a
case split calculate the the next state
and of the the program and
the so instructions you have this
non-ghosts method
and then the dilemmas are written as
procedures where so here we're going to
try and do a proof by induction which
means doing this recursive call back to
the dilemma so it's this ghost
imperative code and but we're going to
use it to prove this and declarative
theorem so you read it as the parameters
is universally quantified in the term
values as existentially quantified so
we're going to say for all of the
parameters there exists some return
values such that there the precondition
implies the post condition and so here
working this is our trace equivalents
and I'm going to say if we'd start with
these 22 states or trace equivalents
then we're going to end up in an
equivalent States and always and some
other stuff as well but that's the gist
of it and and then you can just write
normal imperative code and so this is
the base case of the induction which
Doug knee is able to prove automatically
and that's the inductive step company of
the detail on that have some moisturizer
who i'm talking like and roughly see
it's that so the theorem here says that
and so this is s1 excuse to s3 by Trace
ls1 so this is the the tracers like I
showed previously and and we know that
executing s1 and executing for action
from s1 execute from s2 or trace
equivalent and so we carry the version
of the code around in the state
so this says that we've by some method
we've established that their trace
equivalence so just by inspecting the
traces then um it's going to ensures
that and there exists some trace from s2
to reach a state s for such that the
traces the traces are equivalent which
is fairly it comes basically for free
from there but this is the main one
which is that where is at the end of the
trace the states at the end of the trace
will be compatible in that in the way
that I described so if you throw away
the you affected the affected part will
be equivalent so there is this
essentially says there is an isomorphism
that relates to these states and then we
argue inductively by looking at the the
first step in the execution and then the
rest of the institution and so on and
but it is a big speak this is like six
thousand lines of daphnia something like
that so it's about is sports because it
needed when you return and you could
have written those shorts as there
exists an s4 all right yeah something
uses it here so then there's some more
so and there's a desert determinism
argument that goes after this in the
proof so he said so eh so we have to say
that and there's that there is only one
of these essentially we made vol the AL
in line five the same way so L s2 and s4
or out parameters which s tremendous
Anthony could have been you can think of
it as that there exists an L s2 and s4
bet you're just going to give them a
tratar no not the same thing for Ella al
yeah the only reason I don't is because
I don't didn't have to use this
afterwards yeah so yeah nearly but they
mean that exactly the same thing yeah
and but I just yeah I would have had to
assign it here and then not use it so
yeah
it's very useful I mean it otherwise you
would have to call this and then do like
an assigned such that and so on to get
these back again but here you just run
it all together in it it's just various
a lot need to raise
okay it does it have the guy stack or is
it just the state so the states here or
I kind of come back to that well there's
another diagram later or no and I'll
explain it in the car it's not at about
that but it will make it clear why they
why I'm gonna give the answer that I do
and so so it's a really it's a
reasonably big proof and some of the
predicates are quite large so the
operational semantics predicate is
reasonably function is caught is
reasonably big and we have these these
predicates over the whole state same one
doesn't change for every kind of
instruction and you can actually they're
quite big as well and and we use those
too when I first slide doing this we use
those together in quite a few of the
theorems and another so so when you win
when you when the proof is correct and
complete it goes through quite quickly
but if it when you're trying to write it
a lot of the time you you you end up
with timeouts because the smt saw was
sitting there trying to prove something
that either is not provable or you
haven't given enough detail for it to
prove and so a lot of what the kind of
approach that we took to do in it was
related to not is not related to how
well it's going to perform when it's all
complete and working but how well it's
going to perform when you're editing it
and making changes to it and trying to
get it to work and and if you if you
have a lot of guess axioms or a lot lots
of different ways that and that xiii can
proceed to
then with searching for the proof but
there is not a proof available then it
can take a long time for zen 32 come to
the conclusion that there is no I proof
available I guess and so you end up with
a lot of time out and so so what we did
was split the proof up into a number of
modules and where we so I should give
some background so you can have abstract
modules in Daphne where you can define
lemmas with no bodies which essentially
act as axioms within within those
modules you can have abstract data types
so types where we just give them a name
but you don't give any concrete and
implementation and then you can use this
process of refinement where you say this
concrete module refined to substract
module and here you have to give you
have to give bodies for everything you
have to give concrete types for all of
the abstract types and um but what it
allows is that you can have some some
proof here of the main theorem that
depends on these abstract modules where
the final concrete implementations are
not exposed to this theorem and so it
doesn't have the when you're working on
it doesn't have the opportunity to go
running off trying to prove things with
these much bigger concrete definitions
it has what it has there in it can
exhaust them quite quickly normally this
is my understanding of what's happening
we may be very recent can contradict me
at some point but and the so so yes so
we split this this proof up in this way
the I guess the kind of nice side
effective of that is that what we ended
up with is something where the the
concrete semantics of the
language are not depended on by almost
the whole of the rest of the proof so
you can switch different representations
and slightly different semantics in here
and reuse the rest of these pieces and
if you're willing to change these bits
then you can substitute very different
languages into the proof and still reuse
these bits so this this kind of
performance trying to strive towards
France led us to to produce this much
more modular and potentially reusable
thing and which is kind of cool so to
answer your earlier question the states
the states in in that that the thing
that the lemon that I showed you
previously is in here so the states are
quite abstract they don't actually have
anything in them like objects or heaps
or anything they have they have them I
don't have anything in them actually and
and then we provide some refinement that
talks about heaps and stacks but
actually that that that lemma will apply
to anything for which you can provide
this refinement and I haven't tried it
but a language that didn't have a stack
and an object the the that theorem
depends really only on this notion of
label transition system so if you can
provide a label transition system in a
map in a nice morphism between to label
transition systems for your language
that that is preserved each step in in
the execution then you can reuse the
theorem and so not necessarily even
objects and if you're imaginative enough
which I'm not so Vonda and you could try
try it with a complete different kind of
language and so that's the first talk
finished and I don't know so I just
jumps right into the next one
and so the next part is kind of related
in some ways again we're looking at a
program equivalents and isomorphisms
mrs. joint work with myself sure lose
here and again sophia and and but here
we're going to look at a kind of program
verification based approach and this
working progress and so some parts of it
are not quite complete burn hopefully
maybe some people have some things to
say about it here so that's good and so
why is it useful kind of similar to what
i said previously and you know you've
changed the program in some way you want
to check that you've only changed the
bit of it that you wanted to change and
maybe program equivalence is useful in
some other places where people use it
for trying to check the compilers are
correct and compiler optimizations are
correct for example and so one thing
that is kind of difficult to do with the
the current state of your is deal with
modifications to programs that affect
the way that memory is allocated so and
that so for if you reorder allocations
or you have extra allocations in one
program or remove or less allocations in
one program and particularly it's
difficult if you if you allow loops or
recursion that allow that can make
unbounded extra allocations or different
allocations so that's what we're going
to try to address here and so first of
all and what does it meet what the was
typically done to compare
a program sure equivalents and so here's
two programs that are more or less the
same except the order of the allocations
has been changed between the two
versions and so if we if we use a
program verification approach we we
would equate the initial state so we say
that X has the same value on entry then
we make some non deterministic memory
allocation and here we get these two
addresses and here we get these two
addresses now we need to establish in
order to establish these procedures or
equivalent we need to establish that
these these calls are going to do the
same thing and but they're being called
with the different values so that's
difficult we don't know whether or not
those procedures are and are going to be
equivalent so a kind of typical thing
that that people do here is try to just
assume that the the allocation is going
to be deterministic that we're going to
have some pool of of objects of a long
we're just going to allocate them in the
order that they're asked for and so we
get 1 2 3 here and 1 2 3 here but
because these allocation orders have
changed we're going to call F here with
2 &amp;amp; 3 &amp;amp; f here with 3 and 2 and so again
it's difficult to to modularly and this
this idea that we can then equate the
initial states of the procedures is we
can't mainline assumption here because
the initial states are not the same and
there are some of the approaches that
people take particularly modeling the
heap graph explicitly up to some bound
and trying to look for ice morphisms
but being already do that if you have
these unbounded updates bye-bye called
procedures and so what we do instead is
we require prior to the call we require
and no start again so we're going to do
is going to say that the programs are
equivalent if there is some there's some
mapping between the address some
isomorphism between the objects that
have been allocated that preserves the
structure of the states of the programs
so so if you start at the stack variable
stuck variable X for example then you
reach one and one there 11 and mapped
here and how everyone was following them
and but again we have this we have the
same issue with with with calls
sorry I'm giving this presentation
before and I've kind of missed the step
I'm
so so what we're trying to do is prove
that in order to check whether two
programs are equivalent for for all
isomorphic initial States it's
sufficient to check that their
equivalent from all equal initial States
and so we say that and if we have some
program P and some program p prime then
they're equivalent and if and only if
Rahl initial stage which are isomorphic
then and running p on is a ice morphix
running p prime on the other one so
that's what we're trying to establish
that running the two versions of
programs from isomorphic initial states
we reach isomorphic final states and and
what we are currently in the process of
proving which we believe to be true is
that if you if you run the program from
the same initial state if when you run
the program from the same initial state
and you reach isomorphic final states
and so if you can establish this then
so it's sufficient to check the program
from all equal initial States to prove
that it's its equivalent for all
isomorphic initial states and what that
allows us to do is just at some
arbitrary place in the execution of
these two programs where we've
established that the states are
isomorphic is to swap them for equal so
that's what we do here we first of all
do for this call so we say well we've
established at the rights of morphic
here so we can use our rule that these
things are going to behave the same from
equal states just by swapping isomorphic
for equal and then I'm going to do now f
is going to run its going to recertify
some some isomorphic state from the
initial states eating it from the same
usual States I'm going to swap it again
to equal states after it returned this
time you're seeing that the execution
cannot distinguish between isomorphic
Jason equal State straight something
like that that is improving isomorphism
yeah that's the critical thing that's
the critical feature that allows you to
to do the sump shins about what you love
you you have to have yeah you have to
have a program that doesn't distinguish
that the value so either a language that
doesn't or a program that doesn't use
features that will where he will
distinguish the value and since similar
to what i was saying the previous
presentation actually am
and
yes oh so it turns out that if you'd if
you do this and you use this kind of
very abstract map encoding for for heaps
that that's something like and like the
bougie intermediate program verify can
can do this check for us and so this is
with some slightly invented sin taxes
what we do so um this is similar to kind
of previous work that she renders them
with with mutual summaries so this is
the first procedure and we put the body
of it here and and this is the the other
procedure and I know why I've got three
point before people have have the and
yeah sorry about that that should that
should be payin that should we be prime
but we'll have to live with it and the
then we we start again from the same
initial state run it again and then
we're going to check that the final
states are isomorphic
I
this is just motivation says the idea to
now combine this with you the first year
first part of the plan pretty insane did
you only look at that functions of the
boundary of right so that yeah so the
question is going to be what happens if
he calls cause another procedure and
yeah but we're not talking about object
orientated programs here and why they
could be but where this is just a any
kind of program that is dealing with
dynamic the allocated memory but we're
not going to make a distinction between
affected and unaffected and this will
get we're looking for procedures which
are equivalent and if it won't deal with
any procedures well at least what I
present here won't do with procedures
that are not equivalent in some in any
way and although there are probably
there are extensions that you can do to
deal with procedures that are only
equivalent over like parts of the
influent statement it's obvious that we
live in some work of compiler
purification there we had different
offsets short from different runs and so
don't think of this maintenance in drift
more complete for programs like that
it allows you to do some things like and
like allocate some heap temporary space
within a procedure and as long as you
throw it away by the end of the
procedure we can show that the
procedures are equivalent to do with the
current systems so so one of the
challenges is the the context of the
call you you can have some arbitrarily
big uncomplicated calling context and so
here for example we have two procedures
which are not equivalent and
Yeah right so they both allocate to new
objects and this one then makes two
unreachable from X and there's this one
point sit here it points it there and
then makes unreachable for X this one
points are here and then makes it
unreachable from X and if you if you
consider this locally so just from the
context of the collie then this slice
morphic so you have this graph you have
this reach will part of the graph and
but actually these in in any or in some
bigger context these two procedure
executioner's are not isomorphic and so
we have to have some way of saying
they're talking about global isomorphism
of the heaps and at the end of the
procedures even though some parts of the
heat may no longer be meaningful you
can't just talk about pass from the
procedure parameter through them so what
we do is we require the the isomorphism
that we end up with to extend the
initial isomorphism and you're not
allowed to you not allowed to produce
some incompatible isomorphism just in
case there's some more calling context
that can distinguish the two
isomorphisms that you produce and and
and because we because we always start
from the same initial states the
isomorphism that we extend is the
identity isomorphism so essentially say
you must construct an isomorphism which
is the identity for all previously
allocated objects and it's free for any
newly allocated objects and I hope that
makes sense to our can draw a diagram
again if that
so and so as you said if you if you have
a procedure that the calls some function
inside it some of the procedure inside
it you have to have some way of using
this this fact about the equivalence of
these procedures in boobie and and so
this is how we do it we and call them F
and G so we have this this mutual
summary of the two procedures so there
we give the procedures F and G this free
post condition and which is a post
condition that you just get to assume
after a call to you of these procedures
but it's not checked and so we give them
check it for the body of these
procedures and this summarizes the the
priest state of the of the procedure
call in the post day and we have to pass
the dupree state as go state here and
and then we have this axiom which is
some mutually summarizes these two
procedures and so this is the the
summary for a call to F this is a sort
of record to G and if we can establish
that the states are isomorphic before
the call then we get that that they're
the same after the call in this way we
don't have to and we don't have to do
any further work to kind of match up
which procedure calls match with each
other boogies going to going to search
and try and have match them up for it
and
and so I guess I'm just going to talk
about the kind of difficulties with the
buoy encoding and bits where I guess
we're not entirely satisfied all we've
got and the first thing is quite
difficult to to use this idea if there
exists a mapping between two heaps and
as your definition for isomorphism and
because you have to somehow give boogie
something it can instantiate that
existential with and we don't have it so
what we do instead is is try to
universally quantify everything so we
quantify over paths from from previously
allocated objects and from the stack
frames and network and the other issue
is that it's very difficult to give to
give this notion of unbounded reach
ability to an smt solver at least I I
don't know how to do and but it turns
out that you don't actually require an
unbounded reach ability predicate to
deal with unbanded reach ability because
although recursive calls can can make
unbounded updates what we do is we
change loops into tail recursion and
then each procedure call itself can only
make a bounded update and so we only
ever have to check isomorphism for some
bounded amount of updates done within a
within the statements of an act of a
particular procedure and and but some
nicer formulation of reach ability would
would be very helpful and
yeah and I guess the other thing that
helps assist as always there's always
exactly is it one or zero isomorphisms
there's never many isomorphisms that we
that we consider so right so I've got
some more slides on the actual bougie
encoding and they're kind of intricate
and so we can go through them if any of
people are interested or we can stop
here and I'll leave it all to you nice
like it yeah well it gets more
complicated
and or if anything if anyone has any
questions about what I previously said
there was maybe not the best
presentation of it ever I mean you're
writing groups and encodings essentially
in the in booking and your and you also
I mean lots of proofs and formalization
in Daphne and the in most cases you're
dealing with the same engine below we
will give XIII do you do you find a
different cinta to I mean for example if
if you were able to encode this in that
instead if that would have been useful
when you have preferred that or for the
Daffy encoding that he did of your first
system would you prefer to have done
that in that in bowie so bougie feels a
lot like programming the smt solver and
you in or in in order to use it had to
read and learn a lot about what the smt
saw was actually trying to do underneath
and how how it's going to try and search
the axioms how it's going to try and
build the proof tree and so the the fur
the first several attempts that had this
doing this in bougie were not very good
and the
and I guess the critical thing came
comes down to getting right gate
understanding how the triggers cause the
cause the matching loop to work but I
think that's that is very important here
because we're talking we're trying to
talk about these unbounded modifications
and there isn't a decision procedure
available so you have to compromise in
some places and the right how you write
the trigger expressions and construct
the predicate sees I guess how you
encode how you tell bougie what
compromise you want whereas in Daphne it
felt it felt much more like like writing
a program and doing kind of whore logic
proofs on a program and I didn't most of
the time did not have to think very much
about what the smt solver was going to
do and so the definitely that feels very
different i guess because Daphne has a
carefully crafted set of of triggering
expressions that it's already gotten its
encoding and learned quite a lot about
bougie actually from going to read in
how daphne was encoding the program's
the but yeah but i'm not sure how how to
bridge that so so here where I feel that
I need a lot of control over what I'm
asking the theorem proved to do and that
might be I might be mistaken but it
seems to be useful to be able to do that
and and I'm not sure how would achieve
that to the same degree in indore me
there were questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>