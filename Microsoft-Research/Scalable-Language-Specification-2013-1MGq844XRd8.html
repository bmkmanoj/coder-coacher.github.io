<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scalable Language Specification 2013 | Coder Coacher - Coaching Coders</title><meta content="Scalable Language Specification 2013 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scalable Language Specification 2013</b></h2><h5 class="post__date">2016-08-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1MGq844XRd8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
thank you um there seems to be a
tradition here of advertising our
positions on on scalability so you know
Peter for example has been inspiring us
for decades working on this question
scalability meaning the ease of language
assembly putting things together with
blocks but there's been a few other
perspectives like Paul and Eric have
been talking about a different dimension
which is essentially scalability in
terms of complexity of the language
being defined I've thrown this
provocative pseudo graph up here to say
that I worry a little bit that they may
be an inverse relationship I don't know
but after this talk we're going to
drinks which is a wonderful time to
discuss this question so really there
are different kinds of scalability
scaling to the real languages scaling in
terms of human effort and so on and it's
great that we're open to all of these
different perspectives now my own
interest in semantics and the thing that
inspires the title I put up about
natural science is I've spent the past
decade trying to Samantha size a bunch
of different so-called real world things
for instance I've done a fair bit of
work on JavaScript semantics which I
will talk about it a little bit today
we've done a semantics for Python I work
with Excel access control languages but
also things like cryptographic protocols
you know Alice and Bob diagrams and
trying to formalize exactly what those
mean and what the underlying
cryptographic assumptions are more
recently jQuery which is a web based
query language the core of browsers and
finally cisco boxes routers and the more
I've done this kind of work the more I
have been concerned of this question of
validation now of course we know there's
two kinds of validation always that's
kind of an internal validation does the
thing as define makes sense we prove
soundness theorems and so on but there's
also external validation which i think
is at least as important when we're
dealing with these externally defined
realities so you know in some cases like
in the case of programming languages
there are test Suites and it's pretty
straightforward you test against them
and several other people have also
talked about testing against languages
and sometimes you have to go refer to
books you know you take a canonical book
or
some interesting book that has
non-trivial examples sometimes you take
sweets of examples in the case of exact
milord ISA for example in the
cryptographic protocols there's a group
at ens kishan that has a suite of a
hundred and six different cryptographic
protocols written down and that's what
we validated against case of browsers
there's so little written down properly
formally that we just generated large
numbers of inputs and tried them out
kind of like Hosea was talking about
yesterday and finally in the case of
well you know Cisco routers this is the
one thing that's a little different we
went on ebay and actually bought a cisco
box a cheap used cisco box and through
you know thousands of packets i did try
to understand how this thing works you
got to do what you've got to do now why
bother validating it seems like that's
an obvious answer right I mean otherwise
how do you know what it's doing but
sometimes there are pleasant side
effects of doing this kind of validation
in the case of Cisco for instance it by
the way when I when I give when I give a
talk like this in a networking audience
by this time three hands have gone up
the question is always where did you get
a parser for iOS this is always you
would not believe this is always the
first question how did you manage to
parse iOS pouts turns out apparently
this is a really big deal what do I know
because Cisco doesn't really publish the
syntax they don't publish respect they
don't publish anything particularly
useful but underneath this horrible iOS
language the surface syntax the
underlying model is actually a very
pleasant one that isn't published isn't
written down but you can discover over
time there's a really beautiful
structure to the way a cisco iOS box
works and one of the things we did was
to come up with very nice relational
specifications for each of the boxes you
see here and compose them in clock using
classical composition methods the kind
that you know people like cliff and Tony
have been telling us to do for decades
compose them and obtain in that fashion
both individual pieces and a composition
to describe the behavior of one of these
boxes right so this validation process
can actually be an inspiring one because
you come up with things that are better
than what they look like
you know you get this ugly gray box but
it's actually got very deep structure so
the superficial horribleness can
actually mask a underlying beauty or you
know it could be JavaScript so this is
this is the part of the talk where
there's actually going to be audience
participation there will be quizzes
please be prepared here is JavaScript
it's a book this is a very nice book
written by a guy named Douglas Crockford
who knows about as much JavaScript as
any human being alive so anything that I
quote here is not to suggest Doug
doesn't know what he's doing he knows
exactly what he's doing um and so
crockford writes in his book you know
for instance he says JavaScript um has
much in common with scheme and because
of this deep similarity this is sort of
a very nice elegant language that you
can understand essentially what he's
saying is you know JavaScript good so
this is good for me right this is this
is my bread and butter um all right so i
might call on you and it by name so be
prepared I mean if you've seen the talk
what ah yes ok good very good what does
this program evaluate to a JavaScript
I'm adding the empty array to the empty
array anyone come on take a guess zero
okay it's the empty string good so what
does the empty array add it to the empty
object yield zero ok object okay very
good what does the empty object add it
to the empty array I mean it's obviously
it's arithmetic so it must be right yes
okay obviously yes yes Sebastian sorry
zero okay and then you know by
cancellation laws or something like that
what should the empty object yielded add
it to the empty object me nobody wants
to even venture a guess well it's
clearly not a number right it's it's the
one thing that's actually true on the
slide by the way it's actually very
interesting if you look at what's going
on in that last line it's actually
parsing the empty object semicolon unary
edition of the empty object okay so so
this is life in javascript land
here's a little function i take x and i
assign X dou X and I return the value of
x so clearly X is getting bound over
there it's getting its value from that x
over there which is bound there which is
200 so clearly this function yields 200
right yes clear yes okay that's
obviously why the functional is
undefined because you know that X is
actually the same X etc okay well it's
okay so it's corporals are a little
funnier than we think but here's another
example I'm going to take this object
object I'm gonna look up a field in it
so if i send it a why arm i change the
value of x in the top level if i send it
an ex I actually read why from the top
level and assign into the X that I sent
in so notice that the arrows depend on
the input you know this language even
statically scoped who knows um then of
course this is this one's absolutely
lovely I assume it's completely clear to
everyone here who does like web security
that this is window dot location IE a
very dangerous thing to allow the
programmer to write in their programs
it's actually a wonderful website that
will take any JavaScript code you're
right and convert it into this form and
if you wish there's a button you can
toggle to say please also wrap the word
eval around it just you know just
because it's really good okay so here's
duck Crockfords comment and here's
reality so Crockfords comment is useful
in terms of trying to gain a foothold
you know like Dominique said in our
previous talk we start off with these
lies a simplifying lies this is a
perfectly good thing to do the problem
is when it comes to trying to build
tools when it comes to doing web
security research or building static
analysis tools and so on these lies are
actually actively dangerous because
people stop at this point in fact for
several years we were reading these
papers that would say we have a sound
analysis for JavaScript I'm ironically
uh you know our papers are getting
rejected because we said we didn't know
how to prove soundness and they said
well that obviously they haven't proved
it sounded so we should reject the paper
right so it turns out that the thing to
do in computer science conferences is
bluff right they don't call your bluff
you just say we have a sound analysis
it's good so um you know a different way
to look at this
Emory burger sent me this beautiful
photograph once he said this is the
essence of JavaScript for you so the
problem is there's that much lying going
on so we said okay well we want to prove
sound so we'd like to actually write
down the semantics against which we can
prove samus so you're going to semantic
right i mean we all know how to write
down a semantics everybody in this room
can write one down and you know an hour
or so on so we call it the essence of
JavaScript always helps to be bold so
here is more or less the essence of
JavaScript I don't expect you to read it
it's a semantics right it's a semantics
like we can all right now now the
question is why you should have any
faith in the semantics well so here our
JavaScript programs and over on the
other side are lambda j s programs there
in this tiny little language it fits on
a page compared to this 250 page
programming language well it's
understood implicitly in our heads there
is some sort of D sugaring process right
we do this every time we write on a
lambda language of some sort in our
heads is some idea that everything on
the left can be converted to a program
on the right right there is a complete
that you know every single one of these
things can be represented on the right
well um we can be the mistake of
implementing the Shivering this is a
mistake because you know it's pretty
trivial to write an interpreter for
lambda j s now if you compose these two
things you get an implementation of the
language as you may have heard there are
other implementations of the language so
you can then ask how do these compare
and so in fact writing down lambda j s
took well you know as i'm going to talk
about this later the pantograph you know
two to three months well writing on
languages took a weekend getting this
composition to have the same behavior as
all these implementations took about two
to three months so this is why it's a
bad idea to write down the sugar because
then you're forced to like actually
spend three months rather than a weekend
um now I want to point out that there's
a particular structure we're using here
right we have this new sugar function
and we had this lambda j s and lambda j
now the question is which is the
semantics in fact my student origin and
i have argued back and forth quite a bit
but what we should call the cement
is it lambda J s or is it d sugar and
lambda J s and it's actually a question
worth asking because it's not entirely
clear to me but lambda G is in some
sense is the really interesting thing
here right it's it's this curated object
it's our attempt at providing an essence
of the language you might come up with a
different essence that fits on a page or
two but it is an attempt at providing
this carefully curated understanding of
the language it provides insight into
JavaScript we make decisions in there
about what to put in there what not to
put in there to try to offer some
insight so somebody coming to this
language could either read Crockfords
book and say oh it's basically scheme or
they could read this and say oh I see
for example when i try to mutate a field
that isn't there it gets added to the
object that's something that lambda j s
represents directly there are other
things that chooses not to represent
directly this is really important it's a
great target for proofs we did this
because we want it to be able to fill
tools and prove them sound you can't
prove soundness over things that have
hundreds of cases maybe you can if you
had a lot of tools support but then
there's still a human labor question
involved we wanted something small
enough that we could even do proofs by
hand and still claim to have done proofs
over the whole language and that was the
goal of shrinking the language cranking
the core language to be that small one
of the things we observed and this is
just a this is just a human observation
there's no mathematical law that
underlies this is that initially you
know it took awhile to get this
composition to work out but after about
a week or so lambda J has pretty much
stopped changing it very rarely changed
every time we got new tests and we found
tests that didn't work most of the work
went into D sugar now that made me
because we understood JavaScript well
enough that we were able to write a
pretty good initial candidate but it
does say that if you have a pretty good
core calculus you can put most of the
effort into fixing the D sugaring and
lambda j SI it stays stable when the
language makes small changes lambda J's
tends to stay the same dish
is what changes so this gives us a
stable target for tools and for proofs
and finally it feel like this is the
essence of science right it's our goal I
mean you know you heard Tony Stark right
Tony Tony took a small amount of stuff
and made a lot out of it I'm taking a
huge amount of stuff and not doing very
much but I mean I'm that's because I've
been given a huge amount of stuff to
start with but I still feel like you
know Tony stock represented the essence
of what we're trying to do as callers
here is trying to distill things down to
their essence have a small number of
interchangeable parts that we can put
together if we understand their meanings
we can then understand the meaning of
bigger things so when people write down
semantics you know we've heard several
talks over the past two days about
semantics and of course the whole point
of the plan calm project is to have
these little bits we can put together
but we've also heard about these fairly
maximal semantics right 1200 line
specifications and so on I don't think
of that as much of a specification
because I don't quite know how to work
with that having things distill down to
me is the essence of what we're really
trying to do so we put this out about
four years ago we've had lots of users
for the system several people have tried
to do various things with it um I guess
after yesterday's talk i should add like
a little disclaimer at the bottom there
but oh that's a very interesting
question i'm actually going to talk
about it at the end i'll have a slight
about that at the very end right okay
good um ha good that was also an almost
like a sponsored ad I'm sorry oh ok ok
no there's almost like a sponsored ad
placement they're very nice ok but now
so that's enough about JavaScript I
don't really want to talk about
JavaScript arrestor today let's pull
back a little bit what we're trying to
do here is to use tests as
specifications ok now you know we were
told earlier that we should think of
denotational semantics and testing is
being closely aligned well the
International semantics of specification
testing is essentially a really really
poor man's denotational semantics right
that's what it is so yes we know all the
problems with testing the moment you say
it testing everyone can trot out the
Dijkstra quote right listen two extra
quote
yeah yeah that's right testing something
on the other yeah yeah demonstrates the
presence of bugs but can prove their
absence yes we know all that so I prefer
to think of it this way tests are
they're very incomplete of course they
are only a finite approximation of this
big denotation but they are formal
objects and the very lightweight they're
easy to write down the easy for all
sorts of people even people who don't
understand algebra to write down in
contrast implementations have this
problem that they over specify the
behavior there may be all sorts of
consequences of an implementation that
may or may not have been intended the
tests hopefully are a specification of
what somebody actually intended on the
great thing about Tess's they tend to
keep up with the evolution of systems
and finally yesterday somebody is one of
the people one of the speakers spoke and
somebody asked a question about how do
you work with the standards bodies
testing is a great way to work with
standards bodies we've actually had some
experience with this people asked us why
we're not pushing for lambda G has to be
in the ECMO script specification of
JavaScript and my response is always
it's pointless the people who write that
spec and the people who read that spec
couldn't care less they don't know what
an evaluation context is they wouldn't
know if even if their lives depended on
it but they understand tests and the
committee now publishes test suites as
their way of presenting what you know
another definition of the language other
than 250 page document we work with
these test Suites in fact for a while
you know kind of like the story we heard
yesterday right we were tracking the
test Suites so carefully we were doing
better than firefox was on getting on
conformance with the test rate right I
mean these things happen real systems
behave in funny ways but the point is
this is a great way to interface with a
standards body so in the rest of this
talk I'm going to be talking about using
testing for various purposes and keep in
mind that this is a under used resource
that we have in programming language
semantics so now let me pull back even
further so talked about JavaScript
talked a little bit about a perspective
on semantics now I want to pull back
anyone recognize this photograph this
picture it's full of typos
stuff it's great so obviously you know
because I sense full of typos it's from
Wikipedia this is wikipedias web this is
the picture on Wikipedia stage on
programming language paradigms right
this this is an idea that we have been
unable to kill yet maybe someday we will
succeed at killing this idea of
paradigms but here you go apparently
there's about that many of them and it's
it's all taxonomy so it must be correct
right well languages don't fit in these
slots right the problem is you look at
papers on JavaScript say well javascript
is an object-oriented language or
whatever the heck that means javascript
is a functional language whatever the
heck that means I prefer to think of it
as you know there's this wonderful story
about the first time one of these things
were shipped back from Australia to
England you know what happened they
shipped us back right the so these guys
go out to Australia they find this
object they said wow what on earth is
this they send it back to England the
royal society gets it and proceeds to
rip it apart because they were looking
for the stitches they were so convinced
it was a hoax is that there is no
earthly way that bill is fitted onto
that body so they went looking for the
stitches to see where the bill had been
stitched on at the end of it they didn't
find any important note back saying how
could we have another one now we want to
study this plane okay so there's your
paradigms for you right this is what
programming languages look like today
it's like this is a great description of
JavaScript right it's got like a nose of
self and the body of scheme and like the
web footing of like who knows what um
and these are the objects we we kind of
have not much of a choice but to study
because they're using you know our
underlying infrastructure depends on
them so I come to think of semantics
less as a strictly mathematical
discipline it is still a mathematical
discipline but I've come to think of
semantics as closer to Natural Science
these languages were working with these
systems were working with they are
effectively found objects in nature that
is the right way to think about them
there are these objects that are lying
out there we pick them up all we can
kind of do is sort of poke and probe at
them make inspections try to derive some
understanding of their behavior
from it and I mean some of you look a
little uncomfortable that's good okay so
given us something to talk about over
drinks but the other reason to take this
perspective is you know for people in
the other when you have these talks on
JavaScript there's always people but
what about the spec what about that 250
page document it's really important
right I mean it's crucial that your
semantics be able to map line to line
and you can point out where each line
came from but here's the reality it
depends on your task if your task is to
prove security theorems attackers don't
attack the specification they attack
implementations they attack the reality
of these systems they don't attack the
specs right and that's why I think I'm
pushing for this natural science
perspective we've gone too far in one
direction we need to find a way to
balance these two even though my
ultimate goal is the same as that of
many of you which is to have these
concise formal descriptions mathematical
descriptions with retreat and proved
realty herbs okay so that's the setup
that's the background now I want to talk
about moving forward to do that on let
me first talk a little bit about the
effort needed to come up with one of
these semantics so yesterday we have
this wonderful talk by Gregor a oh by
the way you know that this is the soul
does javascript stuff in urbana needs to
like be paying us checks for this at
some point right there's since your
graduates to do this kind of thing so
efforts for let's not what the effort it
takes right here at three lines of three
things like oh god I mentioned he said 1
to 1.5 years for language you know
hundreds thousands of rules sometimes
and you also point out the configuration
changes a lot right so this is a
continuous effort once you dedicate
yourself doing one of these semantics
you're constantly stuck doing them these
are grigori's numbers a minor comparable
so for cisco iOS it took about a year
with two people involved but as a lot of
that was the parsing we don't know much
about parsing maybe some of you could
have done a lot better on xmas crypt 3
which was the first javascript thing we
did the language is part took about
three months of two people on knowing
everything we did to get the ECMO script
five took five months including a
graduate course and then to do the Dom
events took another graduate course
took about seven months times for people
okay and then we got to python so the
way we did Python was actually a little
interesting so here's here's the here's
the cover of the paper and you notice
I've listed a bunch of locations rather
than affiliations that's because what i
did was in the fall i attacked by
programming languages course online we
then recruited the top students from the
online course and put them for the
remaining so the final project was to do
a very baby tested Python and then we
spent the entire spring semester scaling
up for the baby Python to most of the
full language and basically it's pure
coincidence that three of the people you
know we had six survivors basically does
my PhD student is the number one first
author so we had six survivors in this
effort three of whom happened to be
undergraduates brown and three of them
happened to be like distributed around
the world on june song is actually
coming to brown as a master student
Anand as a professional programmer in
India and Alejandro is a triathlete who
used to be a software developer and is
now essentially retired okay so
essentially we crowdsource the problem
of trying to the Python semantics so I
can't even begin to count how much
effort went into this hmm yes do you
have any about the implementation
language version of the days was in
Haskell and decade and the second
version is different right oh well so we
typically produce two models for each we
produce a runtime system well an
implement a are running implementation
but we also do a read X model so for
each of these as a radix model we've had
some models in the middle as well
um I don't think Haskell vs. racket
versus old camel has made any difference
at all it's helped a little bit like you
know Haskell parsing Combinator seemed
really useful then we found all camel
was maybe a less painful language to
deal with for other reasons I don't
think I wish it could I'd love to be
able to stand and say oh racket was
awesome or something else you're awesome
day no not really yeah and this is with
some very qualified programmers to yeah
ok so that's like four languages and
we've already taught it up like I don't
know several person years of effort and
you know how many like just do we need
to do well
languages out there there's a lot of
popular languages out there right and
there's a lot of languages in which
there are millions of lines of code that
we need to worry about and you go to you
know Wikipedia here's a list of new
languages that are implemented on top of
the JVM and I don't think that even fits
on the page right and if you go to
something like you know Stack Overflow
you get questions like this right this
is a popular question on Stack Overflow
now the answers are terrifying the
answers are terrifying the answers
always I'll go read the dragon book it
has the most awesome parsing chapter or
something is always about parsing always
about damn parsing never about semantics
every one of these threads always about
parsing okay but never mind that and you
know no asf SDF unfortunately but you
know that you should go out stack
overflow and start answering these
questions so the point is you know we
should be happy about this at some level
right everybody wants to build languages
it's now a democratic activity right
everybody wants to build their own
programming language and unfortunately
we can't predict which of these is going
to be the next PHP and it's going to be
around for the next 20 years haunting us
so you know this is this is a problem if
you care about being able to build
semantics for real-world systems and
it's worse than this because it's not
just about languages because it's also
about the environments in the api's like
I talked about the Dom the Dom isn't a
language it's just a big library that
represents the behavior of the
JavaScript bruh of the browser that's
associated with JavaScript or whatever
else you're programming in I talked
about access control languages again
these aren't you know full-blown
programming languages these are all the
things on the side but if you can't
reason about their behavior in some
cases they get called out to like access
control languages get called out to buy
the program in some other cases Steven
worse if you think about the JavaScript
on a web page it just sits there doing
nothing it's inert it does nothing it's
only behavior is defined by the events
that come into it because of user
actions which are defined by the DOM and
is it pretty complicated it's actually
the DOM is really the right way to think
about it in my opinion is a control
operator because you click on something
and
events there's sort of a bubble there's
a capture phase followed by an action
phase followed by a bubble phase and at
every point you can sort of jump out of
it etc it's it's a pretty fascinating
thing to study in a sort of morbid way
of course so without this we can't even
reason about the behavior of these
systems now you'll be nice if we lived
in a world where people started from
simple good algebraic principles and
maybe we can push them in that direction
but this is the ugly world we live in so
for the last part of this talk I I want
I made up some slides specifically for
Andrew because poor andrew has heard me
speak few too many times and keeps
hearing the same darn things over and
over again so i tried made up some new
slides specifically these are for you
Andrew okay so clearly we have this
problem right we somehow have to get the
next 700 semantics so we've started to
make some very modest efforts in this
direction this is the picture I showed
you right this is my way of thinking
about semantics I've got some P language
over there got programs in that language
I want to construct a lambda P now as I
said I want to think of this land
language as a human designed artifact
it's the way we try to provide insight
it's the way we try to communicate our
understanding our knowledge of the
language okay but there's this thing in
the middle as I said that that thing
takes a weekend and this thing takes
three months so stands to reason this is
the stuff we should try to automate if
we can't okay so here's what I'm going
to assume i'm going to assume I have a
parser for me I know nothing about
parsing literally in fact I'm in
graduate school the qualifying exam
there was a question on parsing always
is and I left a blank because I was like
you know what they going to fail me so
you know somebody else can deal with
parsing there plenty of people in this
room for geniuses on horsing and but if
nothing else there's an implementation
of P otherwise we won't be worried about
it and if there's an implementation it's
got a parser let's just rip out its
parser okay so it's always a way of
getting a parser for p um almost almost
yes I know I know I know I hear the
laughs of the audience yes good ok so
there's let's see me on the parser let's
say that somebody's going to write down
a candidate lambda P because that's
really where I want our attention as
cement assists to be focused right
whether it's you know an operational
semantics whether you're going to take
you know fun comps and put them together
however you do it I want us to focus on
producing a lambda P and if we have a
lambda P let's assume we have an
evaluator for it okay so if it's an
operational model it's especially easy
you can write an interpreter for it or
something like that okay now here's our
problem we have P programs and we need
to obtain the corresponding lambda P
program right that's what these sugar
does it translates this tree into that
tree yes okay that's that's our story
here well let's learn this right let's
learn this using machine translation and
just to be clear when I say machine
translation I mean basically the same
technology underneath say Google track
is there a being translator may be
saying something politically incorrect
there may be okay Bing translate okay so
let's use the technology that sits under
human language translation techniques
okay that's what I'm proposing now there
is a big difference which is the
following so I nothing about machine
translation everything I know I've
learned at the past few months which is
very little so those of you know much
more than me jump in correct me please
um but basically the key one of the key
techniques is tree alignment basically
I've got a tree over here I've got a
tree over here and I need to align the
pieces of the tree okay and we need to
infer we need to induct an alignment for
this tree the way it works in natural
languages is you have lots of input
sentences that's kind of how you learn a
model of the input language well that's
okay we that's no problem for us right
we can have lots of people grams
otherwise we won't be caring about this
problem you also have lots of land that
you know to need lots of lambda P
programs which is also easy we can just
go and generate lambda P programs but
the tricky thing is they also want these
things to be aligned right they want to
start with lots of examples of
input-output pairs from which they are
going to infer this okay and the magic
number I've heard from talking to two
different experts of dr. Kevin nighta
Proctor Eugene Charney act the magic
number i've heard is they like at least
a million you know if you can give us 10
million that'd be great well I'm not
going to get even a million right i mean
i'm not going to sit there right a
million different inputs so this is
basically a non-starter well except
not a non-starter because we have
something they don't have okay you see
what we have that they don't have you
see it yes we have nested structure
that's true though I mean they do have
parsed tree they infer parse tree right
they learn a language model from which
they pretend they have a parse tree so
that's much in the way of substantial
that's right that's right yes Oh test
case is very good very good but they
weren't a million I'm you know I have
only so many grad students if I went
back it's all right a million test cases
they'd be a little annoyed they might
move to Pisa instead and that would be
unfortunate for me I don't know the
ground ah well that's a tricky that's
weird where we're trying to go yes other
hands up by some kind of yes yeah you
can tell exactly when the translation is
correct ah right there grand trip they
don't have ground truth if they proposed
English you know they say I need in
English to French translator they go and
steal a million sentences off of like
you know the government of Quebec
website right I mean they actually
literally do um but you don't steals
apparently borrow that I guess they
copied them but the problem is they
don't what given the millionth and first
sentence they have no idea where they
got it right now of course you know
you're thinking in a sort of hip modern
wait say oh you put it on Mechanical
Turk and they do like Chris Kyle stone
birch does this he takes these generated
sentences puts them on mechanical turk
as a training mechanism to see whether
these sentences are any good this is it
kind of works um but we can do much
better we have ground truth okay and
ground truth is kind of useful to have
so here basically is the learning
algorithm here we're going to
hypothesize a lambda P right well put up
put our brains to it and say we've
really understood down or Ruby or
whatever let's write down a lambda P hey
we're going to write several examples
not a million but maybe you know 100
examples of epro grams and corresponding
lambda e / p programs and lambda P
programs right so i'm going to write
down Ruby programs i'm going to write
down lambda
Ruby programs right and that's something
I could potentially even crowdsource
right if I could get you know if I could
put out lambda Ruby in a way that people
on Mechanical Turk and understand then
maybe I can get it we haven't done that
yet it's worth trying ok and then we
learned this transducer ok there's some
technical details basically it's get
something because the multivariate space
and basically the random variables are
how likely is it that this particular
transformation rule applies ok now we
have a proposed d sugaring function
that's what we get out of the street
transducin learning process we now take
a new candidate we generate a new input
program and we run it through if the
thing matches hey great our hypothesis
is validated this is in fact a good tree
trends this is in fact a good be
shivering function we go off and try
another one ok if it fails well now we
have a problem basically we have to
adjust the input and there's two ways to
adjust the input one possibility is we'd
right we know you give me this candidate
you say here's a program they learn d
sugar produce the wrong output well you
could just take that and you know give
that to the expert the expert will say
all for that program here is the correct
lambda P equivalent ok here's the new
ground truth we'll add that to the set
of tests and rerun the process sometimes
you will discover presumably that your
lambda P it was not the best hypothesis
you might want to actually correct your
lambda P and improve it a little bit and
maybe a new feature you might say oh I
never really thought about multiple
inheritance maybe I changed my semantics
to include multiple inheritance and now
I have to add some more examples that
help but learn about multiple
inheritance and basically you reiterate
this process ok so this is the this is
our our hope that this kind of thing
would work because they told Andrew over
lunch unfortunately we've had a little
bit of success which is terrible because
now we're going to waste through yours
finding out it doesn't actually work but
here's what we've done we've got this is
our input language so far it's very
simple language right it's got
primitives it's got in between you know
between is basically is this value
between these two values okay um
conditionals number strings and
constants and there's our target
language ok so in particular it has
particular kinds of primitives this one
has like lists of primitives and that
has just one into early primitives it
has a little LED feature has variables
nice holes for representing the rewrite
right this is where the sub pieces go
and we've actually successfully learned
a dish of ring function for this pair of
languages ought to give you an example
on the rule that it is most likely to
use for a between looks like this it
says let x1 be basically the first sub
expression let x two be the second sub
expression let x3 be the second third
sub expression and then check that x 1
is less than x 2 and x 2 is less than x
3 and this was actually learned on five
examples so so as i said yes it's a it's
about to get bad we're starting to look
into variables and so on but this is
this is what we have so far questions I
have friends in machine learning mostly
for learning grammar snob desktop but
how do you make sure that what you get
is in some sense small so are you
providing input examples and output
examples because you know there are
going to be many dship rings which
looking signs with human but which are
semantically equivalent as absolutely
how do you handle this is that is that
it's the thing that goes wrong it seems
to me this is absolutely right it
depends on what your purpose is of
obtaining a new sugaring in the first
place right one of the things so this is
not something I plan to discuss but I
think it's worth talking about I I
mentioned this in one of my later slides
I don't think as a research community we
have paid enough attention dude we as
the sort of the peel semantics community
right have paid enough attention to this
kind of day sugaring process one of the
things we've learned in fact from
talking to MSR Redmond people who've
looked at lambda lambda J is quite
carefully and have thought about using
it for various purposes is we we spend a
lot of attention on the source language
and really we need a whole bunch of
program transformations equivalences
reductions and so on on the target
language as well for example lambda j SS
point out it's got some issues when you
try to use it one of the things that
does is you take a program this big and
you get a program this big and that's
what the human carefully handwritten d
sugaring but um Matt might point out so
he was trying to use lime to jas and he
realized that a whole bunch of this code
could just be constant folded because
it's just you know it's the typical
recursive descent process of gin you
know is you know how code generators
work and if you constant fold it you get
much more sensible programs and so he
actually has a constant folder and this
you can do if you do sort of a
combination of value propagation
constant folding you get much smaller
programs okay so I believe there's a
fertile ground to do a whole bunch of
cleanups and optimizations now and so
there's two different strategies one is
maybe you can try to make the D sugaring
function you learn be more sane the
other possibility is you just define
these equivalences on the produced terms
because of all you're trying to do is to
obtain a term maybe the one your pain is
fine if what you're trying to do is to
produce a term that a human being can
read you go crank away at it for several
minutes and then say here's this much
smaller term and that's the one you want
to look at okay so to be completely
honest with you this is a problem we
already have we have some ideas about
how to go about solving it and the act
of learning addy sugaring will almost
certainly make it worse okay full
disclosure it's it's it's research okay
but but you're absolutely right it's a
totally valid valid point yes you have a
general assumption sugar is composition
ah there's there's compositionality
their state as a bunch of different
things we've got some thoughts about
what to do about non compositional cases
but honestly I think those are cases
where one of two things should happen
either the person the authors should
just write down the non composite
compositional d sugaring row you know if
there's like a lambda lifting or
something involved or in again in our
experience with the with these multiple
languages sometimes those non
compositional things are kind of
important language features and then
perhaps should really be in the target
language I know that sounds a bit like a
cop-out right I'm saying my technique
can't handle it so we'll put in the car
but I think there is a case to be made
that many of these cases they really
should end up in the core language
because they somehow represent the
embody some some important thing about
this language that
important for people to understand ok so
again another non answer to a good
question yes like all these parts be in
the target when the weather is going to
decide will determine that ah so so I'm
very particular about the fact that we
are not going to derive lambda L for you
right you have to write down a lambda L
and you have to write down an evaluator
for lambda L it's not for us I mean I
here's the thing learning a semantics is
on the one hand on the one hand it's
kind of trivial right because for every
language you give me i'll give you the
semantics that says here's a Turing
machine and a problem right it's
constant function it produces the
semantics and constant time that's not
very useful right on the other hand if I
leave the problem unconstrained and
somehow want a good semantics that's two
unconstrained there's no way to solve
that so instead I prefer to think of it
as a fitting problem where somebody has
put some intelligent design to writing
down the lambda language and the problem
is to fit the lambda language against
the source otherwise you get to
unconstrained a problem thinking of it
this way seems to be a place where it's
constrained enough we might be able to
do something and we can reuse all this
wonderful machine learning technology
that's been applied to natural language
as I said it's not the same problem but
we might be able to reuse some of it yes
your TV look like dickless elections
with a mind ah very good excellent yes
so yes we are learning fun comes there
you go I've justified my trip now there
you go ok other comments so um one other
thing I wanted to say soo-kyung asked a
question about what do you do when you
want to go back in the other direction
right there's this debug ability problem
um it's actually much worse than that as
you know everyone who does model-driven
stuff knows you start off with some line
program in l UD sugar it and you have
this lambda health program um and then
you start running it and you run it and
it's off running in lambda l land and
somehow you have to get this back into
an ell program and not even every step
makes sense to show as an ell program
right you might have an arguement
consists entirely or significantly of
terms introduced by the D sugaring
process you don't want to see that term
because it wouldn't make any sense to
the source programmer there isn't even a
way of converting it back so you only
want to convert back some of the terms
those that can actually be meaningfully
reinterpreted in the source language and
if you can do that then you can
essentially imagine that you're running
your program in El even though actually
it's running in lambda L right so we
have a first result in this direction we
now have for certain reasonably powerful
macros and rewriting systems so at least
powerful enough to sort of capture you
know syntax rules and scheme for example
if that means anything to you we can now
reverse this process so we can give you
this effective reduction semantics
that's entirely in L and so you can
ignore what's happening in lambda L and
we have some good properties about the
kinds of terms you see essentially you
will not see turn things that were
introduced by the discovering process so
it will appear to you that you are
working entirely in the source language
ok that's a first result we have in this
direction we're right now working to
extend this to cover the kinds of
district rings we do in JavaScript and
Python on there's a new language I'm
going to mention and that's the one
we're currently building the semaphore
okay so since I knew I was going to be
between you and drinks and didn't want
to take too long let me summarize what
I've tried to say today first is I think
we you know it's wonderful to hear that
lots of people are trying to do these
kinds of tests at semantics now but I
think we have to keep in mind that the
purpose of a semantics is not simply to
be another implementation we have enough
of those but rather to try to provide
some kind of insight into the language
and trying to strike that balance is
tricky but I think we have to go to
commit ourselves to try and strike it on
second I've tried to argue that this
decomposition in 2d sugaring and core
it's not a new idea at all everyone in
the pl community is known this for
decades but it does offer us it seems to
have some nice affordances for various
kinds of activities maybe for the
learning process maybe for the debugging
process and so on so it's worth
investigating more relate to that as its
ad sugaring itself needs to be taken
more seriously for example the theorems
that govern this thing I showed on the
previous slide are still
it's about the structure of the D sugar
rings you right right essentially
certain kinds of dship rings are easy to
reverse certain are harder it's not
quite as simple as compositionality it's
also has to do with like rule ordering
and unification and so on dizzam there's
some interesting technical work there
and finally tests are underutilized we
don't use tests nearly enough there's a
lot of richness there it's a great way
of communicating with developers with
standards communities and so on and as a
community we should try to use them more
for me personally looking ahead as I
said we want to try to scale this disha
purring process who knows maybe it'll
work maybe it won't I want to think
about improving the theory and tools for
the sugaring along the lines that have
already outlined in this talk and
finally I'm sick and tired of scripting
languages they suck they're horrible and
I know everything now there is to know
about how much they suck so what we've
been trying to do is to build a better
languages we've been working on this
language for son two years now that
we're going to put out this summer and
it's called pirate tries to take what we
think are really important elements of
scripting it has this amazing idea
static scope actually works right it's
just stunning okay which means you can
build an IDE for it one of the things we
discovered and doing this Python work
that I mentioned earlier this afternoon
was you know we have we have an 8 line
Python program no tricks know about
nothing okay absolutely no tricks no
horribleness just a simple 8 line python
program went to three different Python
IDEs and did the variable renaming
operation that they had yes you got it
right all three got it wrong and also
got it wrong in different ways because
nobody understands scope and scripting
land it's just unbelievable how bad the
scope story is so our greatest
contribution may turn out to be that we
actually got static scoping right but
we're trying to do other things as well
we're trying to design the language so
that it is title we're taking everything
we know about type systems from you know
having studied ml and haskell and so
forth and trying to make sure from the
outset the design of the language is not
inhibit types that the designer language
encourages types the design language
encourages IDEs and static reasoning and
so on while still trying to preserve
what we think are the interesting
elements of scripting languages the sort
of objects is did this object
everything short version is objects and
dictionaries are treated as an
equivalence I think that's a mistake I
think the interesting thing is that
objects can be regarded as dictionaries
but going from dictionaries two objects
needs a little bit of work if we make
developers do a little bit of work to go
in the opposite direction all of a
sudden we get flexibility without
getting sort of free formless and that's
that that's the game we're trying to
study right now well i'm teaching i'm
going to be teaching this in my courses
in the fall and we're building an online
learning environment for it so it'll be
out in the fall and if you're interested
you can take a look when it comes out
that's the end of my talk I'm happy to
take more questions I've left a lot of
time for questions hopefully up said
something provocative but I also wanted
to leave you with one last slide um this
is something I found on the web i was
actually reading some literature on
climate science and eventually got a
pointer to this and i guess it's kind of
a specially appropriated well we're not
quite in east anglia but we're in anglia
right we're really sangla okay good then
especially appropriate but um this is
this is emmanuel derman anyone recognize
the name manuel derman is one of the
world's top quants he's one of these
like you know yeah French ens graduates
whatever ended up of course like all
these people you know where Bigfoot
theoretical physicist means of course he
ends up on Wall Street because that's
what you know that's what theoretical
physicists do and he's one of the
world's top quants but after two
thousand eight he wrote this he and
Paloma brought this thing but they call
them ah the modelers Hippocratic oath
and I will give you time to read it for
yourself well I'm also happy to take
questions
good there you go</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>