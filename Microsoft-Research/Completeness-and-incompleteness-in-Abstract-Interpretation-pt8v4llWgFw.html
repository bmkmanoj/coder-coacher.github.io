<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Completeness and incompleteness in Abstract Interpretation | Coder Coacher - Coaching Coders</title><meta content="Completeness and incompleteness in Abstract Interpretation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Completeness and incompleteness in Abstract Interpretation</b></h2><h5 class="post__date">2016-07-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pt8v4llWgFw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
with the aft good afternoon for me it's
a pleasure to introduce our speaker
today Roberto Jacob at sea professor the
university / / owner so you know Roberto
as a one of the most important
researcher in Silicon Isis and in an
obscure interpretation is famous for he
worked with Francesca will give a talk
on Thursday on a domain tyranny of
interpretation particular in the concept
of a completeness and is also famous
because was my very first professor the
university the one who taught me about
the data verification weakest
preconditions yeah he's young because
what's not so long time ago senator
relatively young yes and yeah back when
I was university of pisa and then he
moved to your silver 09 yeah and I I had
him for one year and never took me about
average interpretation and then we found
ourselves later okay so thank you very
much a thank-you Francisco thank to all
of you so today I will try to introduce
the notion of completeness and
incompleteness in absence reputation but
I will make it in such a way that the
interpretation of these two inertia will
be more in the language based security
then in program analysis but i think
that the notions are basically the same
because it is about the precision of an
abstraction the precision of a procedure
that tries to learn what the program
does and what we will see is that
changing the program in order to make
this analysis in precise is like abu
skating hiding information and refining
the analysis in order to get the
information from the program is like
attacking the code so these two the
battle between this rat and cat is
exactly the same battle that happens in
security from the language based
approach of course machinarium quickly
so well this may doing this light here
is like saying something obvious I mean
there is a line that goes toward
mainframe to be quitters and this makes
things in a context where typically you
cannot always trust
the environment where your program runs
so the standard crypto assumption is
that the perimeter of Defense is around
the software of ellie's around the
software of Bob they try to communicate
and the attack tries to listen in to the
middle so I want to hide the information
but I cannot hide the fact that the
message exists indeed crypto doesn't
hide the fact that message exists it has
the context of the message I will try to
interpret completeness incompleteness
namely precision of analysis in a
context of which call it white boxer
attack or what box cryptography which is
more related to the ubiquitous nature of
software in nowadays the fact that Ali's
producer is informing her information
button he cannot trust completely the
fact that Bob will run that being Bob
first and secondly that the environment
to that Bob use is try can be trusted so
basically I I will be in in the context
of having a man at the end attack when L
is delivered his software the software
at the end there can be somebody that
tried to make complete reverse
engineering and crack the information
that the program contains so this is the
country where we try to approach and
this is basically the how how these
things are handling reality namely the
reason an adversary this is the asset
that I want to protect there is a sense
of that tries to see whether this has it
has been attacked there is a control
system that activates a defense this is
typical in Tampa proofing which is a
kind of software that reacts to
modifications or in codification
watermarking fingerprinting and so on
well this has a quite value in the
market and the interesting things in
that and then I think that this is the
line of my most recent research is that
trying to see where
behind these different bubbles there is
a common path background which can be
linked to the precision of the analysis
by viewing the analysis as the process
of attacking the code and this is
basically the picture because typically
in in black box cryptography we have an
input output but we cannot see much
about the inside of the running of the
code we can weaken this and having the
attack to the code more and more detail
about the running of internal of the
program in saturate that from the black
box we go to the white box and this is
something like making the abstraction of
the anemic in the analysis more and more
precise about the behavior of the
program this going through along these
lines correspond exactly to refine the
obstruction so basically if I want to
interpret this deep gray box script or
white book Krypton black buck lift i can
say that well this is a standard in
without obstruction that's the identity
over the traces so in the middle there
is different levels of obscurity that I
can have and for each of them there will
be probably a reaction or a protection
system that might code has to deliver in
order to defeat that attack I want to
link this to so I want to lick the
precision of the attacker with respect
to the fact that the program can be
transformed in order to defeat that
abstraction okay what is this for you
looks like a picture at the beginning of
the universe the very early seconds in
the universe if you look at the picture
looks like much this that is not is a
chessboard so what's the difference
between these two this is up to
absolutely obscure this here we have
information what kind of information
well here we know the pieces on the
chessboard so we know how many of them
type and so on the relation between
these two has to be understood respect
to the eyes so the perception we have so
the analysis is our view over this is
able to extract something colors shadows
here able to extract more I want to use
this analogy in order to do the same on
the soft on the code with respect to an
analysis which will be an absolute
interpretation so we need a model and
well of course it's standard model we
you'll know it's too complicated too
complex undecidable google showed us
that is not the recursive in general so
it's absolutely complicated so this is a
complete mess and the well we need
abstraction abstraction means that the
traces can be shaped can be we don't
have a precise definition of the single
transition but we have an approximation
of this and this should be computable in
this set we may have a loss of precision
and we all know that for instance if you
take the interval of the maximum the
minimum in these traces computed we get
an interval that contains many spirits
traces that doesn't exist in real of
execution and well we can make set up a
logical around this and have largely
comer abstract races this was an
interesting old paper that links model
checking as analyzing his mother check
as I said probably smother checking of
an absent interpretation that was an
interesting old paper in poeple I think
the 90 and then we we may have it may
well happen that we deal with the
precision procedure that well actually
we think that this is the interval
computed but in reality the true
interval computed in the end is much low
much smaller than the interval computed
by the analysis which is bigger so we
have a loss of precision incompleteness
means that the analysis lose precision
with an error okay from the early
definition of apps interpretation in
coos on cuusoo 77 and 79
there had been a flourishing of works
that deals with the precision Stefan
Mycroft and then myself Francesco and
Francesca try to solve the problem once
for all and we proved that indeed is
possible to refine an abstraction for
with respect to any Scott continuous
function namely for any computable
function in the least possible way in
such a way to make it complete and then
we have tried to apply this little
result too many aspect and the language
based security is the one that we will
try this scenario that I've shown you is
the area where I try to show this
application what are the ingredients of
cody's are Italians in Greek so the
ingredients are the standard one
abstraction let's action I think most of
you know who very well it's formalized
iphone i use the formalization standard
from absent interpretation a nice pair
of function that take a concrete object
abstract into any property and then
concretize it back to something which is
above which is the error made in the
obstruction and this correspond exactly
to look to see an after domain or to see
a subset of the concrete that contains
only the points that represent the
absurd object is perfectly as a morphic
and did this means that basically an
after domain is nothing else than an
operation that takes a pro and an object
concrete one maps into a not someone
which is above which is approximation
and then stuck there because once you
lose information you cannot recover it
anymore this is an upper closure
operator so the lattice of all
applicants or operator is the lattice of
all possible abstractions and this is
pretty nice because you can play there
the game of transforming closures which
means thus forming domains so when you
do this standard approximation you
typically inject an error because you
compute in the ashtray instead of
computing in the concrete and the error
you made is correspond busy basically to
be sound but not complete and the error
can be propagated in the fixed point and
this is what's happened typically but
this would
the true abstraction of the true
computation why if you are computing the
apps that you get an object visible
which is an opera box and over
approximation some this means what
standard Sanders that we know is the
following well you typically have a
function that computes from x 2 f of X
but in the in the absurd domain you
don't have X you have the property of X
so you have the approximation of X then
you compute the function and then you
need to go and do to the domain of
objects of absurd object so you
approximate the result so in the in the
absurd domain you compute this in the
concrete doing you compute this when the
completeness had happened so in this
case you are sound because you are above
then the approximation of the true
result which is this if this to collapse
you are complete this is called black
backward completeness namely by
approximation the input you don't lose
precision in the computation typical
example you have rule of sign euro sign
is a complete with respect to
multiplication but is incomplete doesn't
work is sound but not complete with back
to addition because you lose the
magnitude of numbers so once you have a
positive and a negative you want to
multiply then you've got exactly a
negative but if you made the addition of
the two once you've lost this the
magnitude of the number you don't know
anymore who was prevailing of the two so
you can only say I don't know you go
forward completeness is perfectly the
duel so in this case instead of looking
if you lose precision by approximating
the object in the input with respect to
the what is computed you see whether
your perks you lose precision
approximating the output so you assume
that the input is abstract and then
what's happened is that you simply you
are incomplete when you have an error
between us
tracting the output or having the
concrete up it's perfectly duel look
this example this is a classical example
to show these two notions this is the
being absurd and concrete is a relative
notion so you can be abstract of
something which is more concrete than
other and so on so consider this is your
concrete domain is a simple lattice of
intervals and take this absurd domain
this is a nap so domain with the red
bullet take the square operation square
operation is computed with the blue
arrows here look this domain that says I
don't know the number its paw it's a
positive it's between 0 and 10 is
forward complete but not backward
complete why if you approximate being
backward complete means that you don't
lose precision by proxy making the input
of the function so if you approximate 02
you get here then you do the square you
good here okay while if you don't
approximate the input and you do the
square you gets here this is the error
made here made not by poor complete but
it is forward complete all these points
are already the output of the function
square and they are all inside the
absolument so basically me if you look
being backward complete nice contain the
inverse image of the function with
respect to which I want to be complete
this is linked with the sigur algorithm
that when tries to refine that the
partitions go backwards by the
precondition the only difference that we
prove this in year two thousand and
clock made in 2002 sorry dark wood
country what doesn't kill you
and with respect to the country
semantics the fact that with respect to
the approximation of the old computer so
if you put if you compute that in the
concrete and then you approximate the
output or your computing they are in the
abstract you get the same this is that
cool completely well it's the top you
can make you cannot get it better you
don't have false alarms yeah conversely
there are domains that are not there are
back were complete and not for were
complete and this is all the world stuff
so we can what we prove that we can
modify domains so any say that the 3d
abstraction is trivially complete full
back and forward yeah of course the
concrete semantics is perfectly complete
we can modify domain name lee called
this is the case of completeness you see
that x is approximated here then
computing that approximated there so
they the two elements collapse exactly
to the same point this is incompleteness
when this happens it means that there is
an error here due to the approximation
well in this case we can if you if you
have an incomplete domain abstraction
you can make it complete by adding
points you refine your abstraction or
eliminating point you simplify your
obstruction typically in static analysis
we refine because we look for a more
precise domain that is able to avoid
false alarms but you can also avoid
false alarm by removing information
which is simplification
you don't have more force on you because
you are complete you have your less
precise that respect to the property you
don't have anymore the same property you
lose the property you want to look for
but you remove the presence of false
alarms but yeah the property is at least
the absurd to me and this was proved
well actually was from 98 that basically
a backward problem can always be
performing in the forward problem by
considering the inverse function with
respect to it to become complete
amazingly we can also modify programs
not only domains so until now we have a
domain we have a program we want to
refine the domain or simplify domain to
avoid false alarm for that program but
we can take the domain fixed and change
the code the program in order to be
complete for that domain and well it's
possible theoretically basically this is
the guise of incompleteness and in order
to become complete you simply have to
avoid that this namely transform the
function to the closest from above or
the closest from below that is complete
for that abstraction and this is simply
it's very easy because you can compose
this with the abstraction itself or with
the adjoint of the obstruction ok so how
all this fits into the staff of security
or let's say static analysis as a way
for attacking code and co transformation
towards obfuscation is wait for
protecting code we go back to the
picture so basically what is an
obfuscated ER and a few skater is
compiler or is a bad student writing
code ok typically you have in your input
output you want to keep your input
output and you want a transformation
that from this code that everybody can
understand what's what is inside here
goes there that nobody can
what's happening inside this has to be a
compiler but true hackers actually do
not perform compilation they really add
junk reorder code they do very weird
stuff on the machine level so the idea
is that I want to see if this can be
that this transformation tau can be
systematically derived from the
precision in terms of completeness of
the attacker and how this can be done so
the typical attackers use either pro
many tools like all gdb and so on
colluding attacks the differential task
there are many ways for for attacking
code for making reverse-engineer
understanding how it works and most of
them use tools that are based on the
analysis so the objection that well your
way of viewing the relation between
attack and defense either strictly
related to the analysis that doesn't
consider the human capability of
understanding code in the Indy attack
it's partly true because in reality for
a big site for industrial size code this
cannot be a reverse engineer it cannot
be done without a tool based on an
analogy which is a slicer which can be a
debugger or whatever so if you are able
to defeat an analysis automatically you
delay much the power of an attacker in
understanding the the behavior of the
code so this is the idea basically the
militia user has a lens so you cannot
really see everything but can only see a
portion and obstruction of the execution
and the occupation wants to make this
user this malicious user blind so
basically the defense has to turn this
into this and the attacker has to do the
reverse and that will use some stuff
made many years ago by neal jones indeed
this is a paper that we did together
last year and
and it's interesting because we said
oops obscuring code is compiling well
you can see specify compiler at least of
level of specification like the
combination of specialized and
interpreter because if this is your
source code that you want to to make it
obscure well we all know that the source
code is equivalent to the specialization
of an interpreter with the source code
so in if you want to keep the input
output of the program it's enough to
find any interpreter of your language
and a specialized ER for that and made
this combination but in most cases you
in hurt almost completely the structure
so basically if this is in clean and
clean clear this is clear to the
challenge is to make this obscure namely
to twist something inside here in order
to make it obscure and Link the twisting
of the object inside here to the power
of the attacker so look this is a little
program this is another program that
computes exactly the same what's the
different between these two but it's
obvious this is the true code this is
the flattening of the code if you take
the control flow graph of this program
is completely flat and everything is
handled by the prod encounter which is
statically here statically written
inside the program itself so if you have
a good visualizer typically the
specialized doesn't returns you this is
able to understand that the program
counter can be statically derived so if
you apply this equates you get back to
here so how can I let this equation
generate this instead of that this is
related to completeness I will show you
how
so the attacker I want to see in order
to understand this we have to understand
what is the attacker the attacker is an
absurd interpretation so imagine imagine
that you have the previous approximation
you have a function with tell you which
chests are on the board you have an
approximation that takes an imager
returns another nice image but it for
example the strange image where we
cannot recognize if it's a the origin of
the universe or if it's just bored this
is abstraction because this contains
this and many more other images of
course then you have a function that
counts an upper bound of the number of
different types of chest on the board
here you have a case of incompleteness
because if you approximate the image
with this so if you approximate the
input which esket is only able to say
well they are probably so many just to
all kind of chess over the board black
and white so I can produce 12 while
instead if I had the true image then I
get seven so moving from this picture to
that picture is an incompleteness and
from the perspective of our eyes it's a
notification so does it work the same on
the program yes from my point of view
alpha skating is making an after
interpreter incomplete so the attacker
is an absurd interpreter whatever
obstruction considers and the failing
the precision is like returning the
maximum amount of fat or false positives
may namely basically failing in the
capability of extracting the concrete
the true information well this can be
simply proved by simple reasoning but
well basically if you want to keep the
input-output well the transformant code
has to have the same input output of the
original one you assume that in
abstraction is complete so if you
compute the abstraction of the semantics
this is equivalent to compute the other
interpretation of the program so you
don't lose precision by a analyze
well you have to skate when you transfer
the program in order to lose some
information this happened if and only if
the transformer code is incomplete for
that obstruction if and only if so
losing precision in transforming code is
it precisely the same as telling you
that the transformant program is
incomplete for that obstruction and what
this happens also in static analysis
because if you make if you compile your
code from your code it may well happen
that the same analysis doesn't work
anymore in the same way because what's
happening there is that the transformer
obfuscated 'add the analysis let's go
back to the example of rule of sign the
rule of sign is we said complete for
multiplication we all know it so if you
approximate the input with the sign you
get precisely the sign of the output
with no loss of precision but it is in
complete with back to addition so if you
have a little program which is one line
of code that makes multiplication how
can you appreciate it with respect to
the rule of sign it's very simple you
transform multiplication into an
iteration of additions you keep the same
input output but the static analysis
which is of course very poor the apps
I'll interpretation which is very poor
is only able to see the rule of sign
face in extracting this code design of
the code so this is a transformation
that keeps input output but Appa skate
the analysis what we will try to see now
is how to derive this transformation
systematically from the property that I
want to make obscure blind well we tried
some with the Milan group and we
observed that most tools used by
attackers correspond to absurd
interpretations profiling abstract the
memory over particular variables tracing
slicing monitoring the completion
disassembly
our can all be formalized as absa
interpretations so if the each of this
is an attack model is an attack strategy
against the code then I can derive from
each of them a transformation of the
code that makes that attack blind okay
how we all know that good programs are
well structure and have gone sighs in
violence a prescriptive program should
have should be very badly instructed and
very ugly invariance incomprehensible on
the math the best is that you basically
say I don't know what's happening that
program point so this is a conflict
between being well written and obfuscate
of course there is an interesting stuff
around the day of deriving a compiler by
specializing an interpreter the
following two aspects hold the first is
that the program that you stayin in this
way inherit the algorithm of the source
code so the algorithm remains basically
the same what changes the programming
style which is inherited from the
interpreter so when you have a code you
specialize and interpret with that code
you in hurt the algorithm of your source
but the programming style is taken from
the interpreters so if i want to make
obscure my code i have to twist the
interpreter in order to change the
programming style in such a way that the
analysis becomes blind so i have to
derive at distort to the interpreter
well from the interpreter have to move
to an interpreter which is the stores
that is still an interpreter from my
language an example let's see this by
two examples the first is flattening
flattening is a pretty well-established
technology for actually the very first I
think the very first patent around this
was by microsoft in 1992 so we go back
and they wear
hiding in this flattening the key for
the use of the program such a way for
basically activating the code because
the order of the blocks becomes relevant
in order to to to activate the code it's
an interesting pattern to learn well
actually the technology of flattening is
a much developed and there is a company
clock where the now is completely
absorbed by your data in Canada which is
a multinational big company making
security that basically made around
flattening the core their core business
the flattening idea is the following
simplified you have your control flow
graph you flatten it and you have a
dispatcher that decides which block goes
into execution of course all the
complexity is moved from the control
flow graph to the dispatcher dispatcher
can be very complicated can become flow
sensitive so if you input some data the
control flow that the secrets of blocks
change for the same data you may have
the change of the counter flow because
basically blocks are redundant and so on
but it is flattening so it's very it
works very well with this exactly this
example because if you take this and you
take the program that show you before
this is the original code this is the
flatter netcode you have a case the
dispatcher here is very bad basic it's
basically the problem counter these two
are exactly the correspondence of what
of the source program and the
specialization of an interpreter with
the code this code look at the
interpreter the interpreter is by itself
flattening it flattered co flattening
code because you have a fetch of
instruction decoding of destruction and
go back to the same loop how but if i
take this program i specialize in a
little interpreter for see I don't get
that because the control flow here is
static so I can predict
the next program counter perfectly once
I predict the specialization do a little
partial evaluation just rip the true
code this should not happen because
otherwise I get back to the original
code I want to enough who skated one so
how can I make it well you take the
interpreter and if you force the problem
counter to be dynamic so the specialized
er cannot understand is is forbidden for
the special idea to understand and to
analyze the program counter
automatically the specialization
generates you a flattening program so by
specializing this interpreter with the
original code forcing the program
counter to become dynamic you get
automatically flattened program then if
you if you twist the interpreter you add
a very complicated homomorphic encrypted
function around the front counter then
you get them more more more more
complicated way and for flattening the
program and make it more and more secure
but why this is true namely why making
this dynamic is related and how this is
related with the attack because this
looks like a trick I have an interpreter
I forced a bear encounter to become
dynamic automatically returns me the
flattened it code where is the attack
there then we prove the theorem that
says that you are fortunate to be
dynamic if and only if you want to make
incomplete a very simple absol
interpretation that is the one that
could struggle the control flow graph so
if you make a very simple apps
interpretation that forgets completely
about the memory of your computation and
simplex type the counter flow graph you
make that incomplete if and only if the
brown county is dynamic so of course and
then you you you swap to another tag and
track making complete that attack why
this is the theorem namely by extracting
the control flow graph from the
execution is equivalent to extracting
the counter flow graph
tickly so you re so your algorithm for
starting the control flow graph is
complete so you don't lose precision so
you are complete if and only if the
brown counter is not a program variable
it's not viable so I static that means
that if you want to to let your attack
the attacker here is the algorithm that
accept the control flow graph which is
static and static purely it's an
inspection of the code it can be easily
extracted as an iteration of the code by
a simple after interpretation let's
forget the computation memory you you
don't lose precision even on leave that
is fully static namely if you want to
make it incomplete obscure you have to
make it dynamic this is exactly what you
do in order to to generate the transform
at code so basically flattening is
nothing else than distorting an
interpreter by forcing the program
counter to become dynamic that makes the
absolute interpreter of extracting the
front of counterfeit graph in precise is
that a theory behind this yes it's
exactly the theory of transforming
domains making a complete and complete
and so on I go quickly around this
typically you have a domain and you have
another domain and if you refine for
becoming complete you add points and you
become more complete for instance seeger
refines the domain to become more
complete so you have you at points and
the domain becomes more and more precise
here you have many domains that may
reach to the same point so there are
many domains that once refine it
provides you that domain as a result
among all of them take the most abstract
if it exists will it exists that
correspond to a kind of compression of
your domain that once refine it gives
you the target domain which is this this
is the most absurd domain that once
refine it gives you this
yeah wife the exists it exists because
it's a complete latest a abstraction or
do you see also not without opiates what
is it in there are cases but it doesn't
exist for instance if the operation
would expect you to which you refine its
negation you have a square you have one
of it obstruction you have the day at
the point the other one at the other
point but the most apps that doesn't
contain none of them it is complete it
is it is the two-point let this top and
bottom it depends on the is a property
of our we started with Francesca many
years ago the property of compressible
domains comparable abstraction freezer
if you have a disjunctive completion we
take to the disjunction the compression
is the John irreducible elements so
those a kind of flat graph Fred lattice
that contains all the basic point from
which you can generate all this
disjunction depend is a property of our
ok so basically you have a function that
refines and you have an inverse function
that squeeze the domain when it exists
not always exists most cases exist for
instance this is a this is the lattice
of intervals is the square then we can
build this little function by
considering this formula so basically if
you remove the L this is that the
respect respect to that function square
this is the squeeze of the original
domain ok so what we try to prove is
that this ref with respect to the
function that is inside our our is a way
for completing with respect to the
function f this inverse is the one that
induces the maximal amount of
incompleteness namely removes all the
relevant points that are useful for it
for removing false alarms so it's
exactly what the contrary of what we do
to static analysis but it's exactly what
we look for if you want to make the
analysis blind okay let's see this as a
nap with another example then I finish
slicing slicing of Fisk Asian is more
tricking program slicing of Fisk asian
so programs rising basically you you
generate a program dependency graph
dragon dependency graph view of this
little program then you slice off the
from this problem we respect to the
variable leaks and why and so on and all
this is statically derived from the
program dependency graph take for
instance this little world count program
okay you have number of lines number the
word number of characters okay you slice
the slicing criterion is the variable
with respect to which you want to slice
this is number of lines and you get out
this slice and if you have number of
word you've got this slide sighs okay if
you want to obfuscate a program slicing
what you should do is to return as a
slice the old code so the slicing
algorithm is more precise is more is it
is able to have a sharp view of the
execution around that criteria if the
the slice is mall is inside so if you
want to obfuscate the program the code
obfuscation the the code the program's
riser you have to make the slicer blind
to the its capability of selecting
instructions basically he has to return
the old code as a possible slide that
means that it fails of course I mean if
I try to attack the program and the user
programs lie sir to reduce the size of
the code I want to attack and it returns
me the code at the beginning it's
completely a useless tool for my from a
attack ok so how actors do hackers and
this is simple hacking do this they add
the fake dependencies because the
program slicing is real
related with the count of dependency
graph the problem dependency graph if
you add dependencies then which are fake
for instance in this case you see that
this is always true this is always false
so there are instructions that relate
the variables link make variables
depending with each other but they will
never be executed because the the
problem dependency graph is extracted
statically as it i would say in absolute
interpretation of the program then the
problem slicer is unable to return a
good slice indeed look it gets much
bigger slice for a number of lines and
for a number of words two big slice is
this related with the algorithm that
they attacked the code which is the
algorithm that extracted prong and
dependency graph yes exactly as before
here the transformation that add fakes
dependency is precisely induced by the
algorithm that extract that come from
dependency graph look the algorithm of
program dependency graph is an absolute
interpretation of the Semite where you
forget completely about the state once
again and generates the graph ok so
what's happening here if I formalize
this as an abstraction what happens is
that is very easy to prove once again
and if and only if that says that the
program dependency graph algorithm is an
absent trepidation expect defined by an
abstraction row and that obstruction is
incomplete if and only if the code
contains static so not dynamic
dependence fake dependencies namely
dependencies that are not true in the
truth trace of execution so dependencies
that are not generated at one time ok so
it seems that with these two examples
well the theory is more general of
course it doesn't work for all it two
examples basically what we try to do is
the following
we want to associate program means we
want to make blind and attacker the
attacker from myself in a season after
interpretation warning and absent
reputation doesn't need to be static
also monitoring tracing can be
formalized as an abstraction so also
dynamic attacks can be formalized by a
bind obstruction also tracing where
you'd have in when you have a huge
amount of traces and you make mining on
this the mining is related to some
abstraction because you lose some
information in order to extract some
other information once you know this
abstraction no matter what for instance
take the compilation the compilation you
look for irreducible graphs in the code
in order to reconstruct the loops so how
can you make it incomplete the algorithm
that extract irreducible graph you jump
inside the code with fake jumps in this
way the code appears completely
reducible and the compiler is unable to
reconstruct the original structure once
again this is a making you complete and
abstraction which is the one that looks
for the graph that are reducible
disassembling if you see the distance
standard disassembler they work
perfectly in the same way so once you
are able to extract the abstraction you
can always build the interpreter the
twisted interpreter which is always a
modification of the standard interpreter
that depends on this abstraction and
makes by this equation the transform at
code blind for that abstraction the
point is the following that you can
always find a better of touch that the
feed the deer who skated one of course
but look back and others proved in 2001
that complete that office key shoot is
impossible so you cannot Universal your
pocket or programs rice in 1952 proved
that analysis or is it possible
we all do program analysis for at least
40 years so it makes sense to do a
confiscation even though it's impossible
that's it okay thank you increase the
power of the abstract interpreter not
just by changing their two minute but
bye-bye for example unrolling that loop
to begin with the might get rid of the
irreducible part or the multiplication
example that you gave you can just do
Trace petitioning you would actually get
that one right now so I mean you need to
stay for the same domain in that case a
what I would do this is an would say
this is a line of research we don't have
the ending point of this of course what
I would do that is try to to specify
trespass titian as a refinement of the
domain and then I use that domain for
deriving the confiscated code that
defeats your tres tres position in the
point there is a I agree with you that
there is an a rigidity inside this stuff
that we always pass through the
abstraction in order to construct the
interpreter but I believe that the most
refinery you can do it the interpreter
you can see that as an abstraction of
the domain over a more standard
interpreter at an enterprise one the
simplest one of course if you look at
dynamic refiners like refining the
widening over on waiting some iteration
before the threshold that cannot be
specified as Galois stuff but it's a
nice challenging stuff because I think
that also for instance in the in the
delay of the widening it's very easy to
find the transformation of the code that
simply delays more the change of the
vibe in such a way that it breaks your
your refinement so probably there is
something even more general than the
things that we are looking at the moment
but we are pretty happy that if you take
this book by Christian called
some kind of Bible of all these tricky
transformations most of them we were
able to specify as an absent reputation
for each of them the twisted interpreter
where there was derived almost naturally
you
well for the moment from the moment we
tried the debt to understand yeah I mean
it was a kind of understanding that
instead of viewing office keishon as a
trick that each time I think a new stuff
i generate then i think that i have a
company of a billion-dollar company mind
that doesn't work of course we try to
derive it a principle behind this the
idea is that for now is the following is
it possible to compose in a kind of
crypto way very simple transformations
in order to make more complicated ones
by composing in such a way that the
order becomes relevant so if you know
the order of the transformations of the
very tiny little transformation that you
do you are able to reconstruct back the
original code so the order can be
exponential because you have
exponentially many different orders
among and that's that would be an
interesting stuff to do at the moment we
always try to understand the existing
but i think i think yes in general in
principle which
good question so I understand is that
all this works because you've got the
other girl stuff so yeah just aesthetic
approximation we are considering me the
best transformer master you may not
not reality yeah you always don't have
the best transformer your quality but
you if you did feel different use it you
see the worst case but if you defeat the
best transformer you will defeat any
other case but how how far is it in the
worst case from the real case yeah but
from my point of view is that I want two
diff when I want to protect because from
my perspective I want to protect against
somebody they want to enter to my house
so I want to put if I'm able to protect
against the best guy that can and I you
at all I'm probably too much whatever is
fine I'm gay locus I agree I agree with
you what's even and you know you you can
you can probably have a lower level of
press office keishon to defeat the true
tools but from my point of view if I if
I compose this is why I look for simple
transformations because if I'm able to
defeat basic attacks and compose them
with respect to the strongest possible
attacker which is the best car at
opposite then I'm pretty sure that other
attackers will anyway have trouble to
get in of course that you pay it I mean
there is you upto does not kick in and I
mean I agree with that there it to
myself holding you if you know your
attacker you know for instance were to
stay america proxy
you know the winding is used if you know
the widening you can probably you can
probably simplify this yeah consider
that anyway most of these technologies
used not for protecting the algorithm
nobody wants to protect the weak sort
because everybody knows it is for
protecting keys inside the program and
these are related to very small portion
of the code so even if so you don't
really do to obfuscate the old codon you
really to target a specific area of the
code in order to let them for instance
very hard to extract by slicing very
hard to understand in the control flow
and so on so you probably pay a runtime
slowdown of ten times over that little
piece of code computed over is doing of
mine made strange places that he made a
dynamic office cater that was encrypting
code in Java screen java bytecode so by
passing the type systems was very
complicated the slowdown was 10,000
times but he applied it in in a certain
small areas of the code that the event
was low down was less than 0.7 so
depends where of course I mean if you
apply the today all it's a complete can
be can be too much okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>