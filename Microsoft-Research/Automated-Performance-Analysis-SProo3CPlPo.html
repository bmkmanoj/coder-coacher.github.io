<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Automated Performance Analysis | Coder Coacher - Coaching Coders</title><meta content="Automated Performance Analysis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Automated Performance Analysis</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SProo3CPlPo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so thanks everybody for coming today I'm
very happy to welcome our visitor
Florian zoo bigger who is visiting us
from the technical university of vienna
he's done a fair bit of work on bounds
analysis termination analysis and more
recently some work on providing feedback
for programming education let's see I
think you did an internship here in 2009
so it's good to have him back and
talking so I'll let you take it from
there ok great so and thanks for coming
to my talk so it's actually going to be
22 talks so 25 minutes each so I try to
keep it to that time so the first one is
going to be on static analysis for
termination and computing bounds and
second talk will be about the recent
project on online education where we try
to give feedback on performance
okay so what is the problem and we want
to solve so we want to compute bounce
though bounce come in various forms
though and we want for example to
compute bounce on how often a single
statement is visited inside some
function and you can ask the same
question for multiple statements so how
often are they visited together or you
can ask how often is the loop iterated
so and so this questions also very
related to the complexity computing the
complexity of a function so by bounty of
amino symbolic expressions or we want to
compute the bound in terms of the input
to a function so I'm not making this
claim precise but from a practical point
of view I i claim that all these
questions are very related and can be
reduced to run each other so why should
you care so there are like two main
motivations for me one is verification
so this is simply a more interesting
problem than then simply termination
analysis and so sometimes you want to
verify that certain resource
requirements are met like for a memory
or or bandwidth so I'm not just for
verification I also have the feeling
that computing bounds a helpful
technique for for for debugging so you
can use spawn techniques as a static
profiler so they have been papers on non
profiling recently they want to compute
like a function in terms of the inputs
and how long it takes to to execute a
program and we this would be like a
static technique which complements
classical profilers also you can think
of these techniques as as helping you to
explore like unknown unknown code
okay so learn more from a technical
point of view though previous works on
termination and bound analysis have been
fairly complicated you're using heavy
machinery such as abstract
interpretation and computer algebra
tools and software model checkers and so
I know I've been working on this for
quite a while and studying a lot of
actual code and I believe that so you
don't always need to have this
heavyweight machinery so a goal of this
project is now to come up with a simpler
static analysis that is then more
scalable and more predictable so I know
we'll jump right into some code examples
and give you like a feeling for the for
the kinds of pounds and we want to move
on to compute so here is the absolute
easiest case so where you have just two
nested for loops so the complexity is
like quadratic and on the left you have
the same program written as a while loop
and so here you could apply simply
simple pattern matching techniques to
get this information and Nora continue
with loops lettuce simple technique the
not work so the easiest case is there
you have inner loops which use either
same counter like on the left you loop
you have the same counter eyes or the
overall complexity will be there will be
linear and on the right you have a loop
count of the inner loop which is not
reset in the outer loop so the bound you
get as also linear so then things get
more interesting if you have a loop
which uses two counters so here you see
a loop which has a counter I and the
counter j and on one the loop path your
decrementing the one counter nor the
other do pass the other counter you see
a question mark here so the question
mark always arises like somehow from the
program logic but it's not relevant for
the termination of the loop so vs um
that's abstracted into ? sense for an
undetermined
so to make it more complicated is if you
have such a loop there you in the one
branch reset the counter of the other
loop so this somehow mimics a nested
loop but written in this form it's only
a single loop and you you get a
quadratic loop out so now what is what
is kind of of new also in this project
is that we consider a counter increments
instead of only counter resets so in the
slide before you have seen that we take
this very with Jay and we reset it to N
and here we are interested in if we
simply increment that counter and a
second branch and that leads to an
overall bound of 2n for executing that
room so you can see this by asking
yourself so either I decrement I or ID
cream NJ and if I decrement I i
increment J and this can only happen n
times and so you know that Jay the
variable J and is only incremented end
times it has zero at the beginning so
you will get the bound to end for this
loop
and yeah so I want you two to understand
this example because it is really the
motivating example for the techniques to
come so here we have like the same
pattern as you saw on this on this
example before so here you have an inner
loop with counter J and the counter J
can be incremented on the outer loop but
if j is incremented so that can only
happen if I is decremented at at the
same time so you can again ask the
question so how often can i increment J
I can only do this as often as a
decrement I and so because this can only
happen times Jade will only be
incremented n times so the complexity of
the inner loop is a so the bound of the
inner loop is M and yeah so these loops
actually a cure occur in in practice and
we found them like in passing routine so
somehow to give you a feeling what is
happening so why is this an interesting
problem or what is the real problem vs
that studying here so it's amortized
analysis so this is really a amortized
complexity analysis and so I want to
recall what what is meant by amortized
analysis so Tarzan has introduced this
notion on on the example of of a stack
where you have to operation either post
you put an element on the stack or you
have a pub menu operation which removes
the number of elements from the stack
and so putting an element on the stack
is simply a constant operation and pop
many is is linear because you can remove
several elements so if you have n
operations and you're doing that if
analysis you get you get the complexity
of n square but if you take into account
only how many elements you've put in the
stack and use this notion of potential
functions then you can get that you n
operations on a roll will be of linear
complexity
and so this is really what you have seen
as the program which corresponds to this
to the stack example so you can
interpret that j + + as putting an
element on the stack and you can
interpret the inner loop as removing
some number of elements from the stack
so this really is to stack operation
which comes from the section though
computing that a volunteer is is kind of
related to to amortize the nettles yeah
and so does the problem we want to solve
so now I'm going to tell you about the
back end we are using for our analysis
and these are vector addition systems
and for then we go on and for vector
addition systems we generate a lexical
graphic ranking functions through short
termination and from then if you compute
bounds from these lexicographic ranking
functions so what r vector addition
systems so you can see a vector addition
system here down on the right they are
we have states so the nodes are our
states of the vector routing system so
late they correspond to the program
locations in the program and then we
have transitions the transitions connect
variables or the prime variables
correspond to the next state and so this
transition should be read as that like
the value of of I is less than the old
value of I and for Jade a new value is
smaller than the old value plus 1 and so
in la si ok so what does the lossy mean
so the lossy means that we have less
than instead of in quality so like
abstractions that you can always lose
values but you cannot increase
so an important thing about okay so like
the standard notion and vector addition
systems is that you have an equality
here and so the lossy is something
weaker so where you replace all the
qualities by by less than
so so this is like the general form the
transitions always look like this and so
here you can have only have a constant
with like a plus or minus and variables
take values over the natural numbers so
this is this is very important okay so
I'm going to tell you later a little bit
how we get vector distance systems but
for now I want to appeal to your
intuition so that we can get vector
distance systems out of these programs
and so they will look as follows on left
you see this example from the beginning
there you have two paths for going from
the loop pedal back to the loop header
so there are two paths on one part we
have that J is incremented on the others
I is decremented and so because we don't
have a quality but only less than but we
can abstract them like this so this will
be a a sound abstraction and on the top
oops I have additionally added two
initial values so what is this like the
vector addition system have you want to
get for this for this program so now if
we look at the next program that we
additionally have the reset and we are
abstracting this reset as follows so why
is the sound abstraction so here you can
see why we are using inequality instead
of equality so because we know or in
vector distance system that variables
are always positive so because you take
values in the natural numbers and so I
can have the J prime less than n by
approximating equality by less than and
i can add + J because jay is always
positive so this is the reason why we
any lost in s so you might have noticed
this is in fact not a vector distance
system because I have a variable here
but we are using kind of this extension
of a vector addition systems there we
require that n is a constant throughout
the program so it is not allowed to to
change ok so here we have two other
program there we increment J on the
second branch and so we can simply a
model it model it like this and then the
third program so the most interesting
one was this vector addition system we
just showed you before the blaster plus
the initial values so let's understand
so why this corresponds to the program
on the on the left so we have to loop
header of the outer loop we have to loop
header of the inner loop so we have this
one branch the if branch where we go
back without visiting in a loop and the
second on the second branch we visit the
inner loop and so this transition is the
inner loop also actually do some arrows
that it shouldn't be there and yeah and
then you simply go back so this is the
the abstraction for this program so now
the first step which we do during the
analysis as we create lexicographic
ranking functions so all of these three
programs which you see down there they
have this lexicographic ranking function
i J and so I don't need lexicographic
ranking function in full generality so
just repeat very shortly so what is it
lexicographical ranking function for
that case so it means that either the
variable i is decreased when we take a
transition or the variable J is
decreased and I is not increased so
these are the two conditions which I
need and they ensure termination because
either I
get smaller or I is it not increased by
then at least jeaious decrease and soda
spores conditions and sure that we will
terminate and you can see so this holds
for forestry air systems because on this
transition on the right so for each of
the transition systems here you will see
that I decreases and on the second
transition you see that I is not
increased by jay is decreased on in the
first transition we might increase a J's
origins allowed and so we will use this
information shortly to compute a bounce
by how much does increase but as though
this ensures that that we will terminate
and so to compute lexicographic ranking
functions we are doing something very
simple which we found to be as efficient
for for our analysis and practice and so
what we will do is the simple algorithm
so we will look for a variable that
decreases on one transition and this is
not decreasing are not increasing on any
other transition so this would be the
variable I for example so then we take
this variable and make it the first
component of the lexicographic ranking
function and then we remove this
transition so on that transition is
decreasing on the other transition it's
not increasing so we can make it to
first component of the lexicographic
ranking function and then visibly repeat
so now if you have one transition left
so there we now pick the variable J and
then append it to the lexicographic
ranking function we remove the
transition so there's no transition left
and we are done
so now how can we compute balance for
these electro distance systems so the
idea for computing a bounce as stated by
these two expressions so the important
idea of this lexicographic ranking
function is that we have for each
transition we have one component in the
lexicographic ranking function so we
have we now and we will use this
information for computing bounds so the
transition T 1 so which I marked in blue
the left one is associated to the to the
component I so I is the first component
in lexicographic ranking function so if
we want to compute now how often I our
of this transition can be executed we
simply have to take the initial value of
I why is that so we know that on this
transition is decrease and no other
transition can increase I so this means
we can exactly executed initial value of
e so now for the second transition so I
often Candice transition be executed so
it can also be executed how often the
initial value is of course but then also
the first transition might have
increased this might have increased
variable I so we have to add how often
this variable can be increased and by
how much so this is what we're doing
with the second expression so we're
adding how often it is increased and by
how much that's the update expression
and so the good thing is that we already
know how often this increase can be done
because this in this increase is on the
transition which we have already
computed so this process can be repeated
so this is a recursive formula actually
and so this can be extended to any
number of transitions and so the nice
thing here which I like is that you're
relying on determing
Nation proof to ensure that this process
terminates because the termination proof
gives you an order under transitions so
which ensures that there is no a
cyclicity here yes seems to me that
previous slide you introduce heuristic
for selecting the porter flexographic
order you so it's a greedy algorithm so
we're just taking any of you find in
this case the actual value they are
dependent on exactly you selected so in
theory there could be multiple orders
yes in multiple different down yes so
which might be better than a tech-savvy
idea I mean does it seem to make a
difference in practice or so yeah it's a
great observation though in practice
it's rarely the case that you have more
than one so does this way it works so
there are some times so that I looked
for this because I wanted to know and so
there are only very few examples where
you have my tipple and then you can take
the minimum of the bounds but this is do
you see a large variation or is it like
you know a constant factor difference
and so I found like really just three or
four Hazel's in a large benchmark so
where you have different variables even
so you have somehow two counters which
somehow represent the same data and then
you get to sir
okay so here these are the update
expression so which are for your
convenience marked heroes on wed and now
we can simply apply this formula and
then you'll get these different bounds
which you have that you have seen before
so you can see like on the left that you
get a linear bound because jay is not
not increased here you get a linear bond
because j is only increased by 1 and
initial values 0 and here you get an a
quadratic bonds by this formula okay so
now I told you what we do for loops this
don't have inner loops so what is
remaining is to deal with inner loops
and so this is this last example and so
how can we loops and loops at different
locations handling loops at different
locations is is very difficult and so
previous approaches so by myself
included we have summarized in a loop so
we have computed a relational summary of
the inner loop and so this is already
very hard in general and we even needed
this junk to summaries of of inner loops
and so I would I wanted to to do
something different and so the PhD
student haters idea that we simply merge
the inherent I outer loops so when he
told me was the first time I thought you
cannot do this so what is the semantics
what is the semantics of this and so you
see what has happened so we have taken
this just in a loop and we have simply
attached it up there and then we have
the same transition here and then we
have just for the left box we have just
concatenated the path but because of
this very simple abstract model of
vector addition systems it turns out
that you can do this somehow because of
the only thing you can do is adding
and so and addition is commutative and
so for that reason we have a sound
mysterium that allows us to compute that
establish a set of bones we get our our
sound so for this example if you then
get this lexicographic ranking function
which has three components and then we
can compute the bounce off of two and
for that so we are doing this analysis
and so if you think about it a little
bit you can interpret thus lexicographic
ranking function kind of as a
multi-dimensional a potential function
so to connect the tudors advertise
analysis yeah and so this idea of using
addition is like a new contribution of
Oliver sure so can you explain this
ranking so you have iij yeah so what
does it mean that I in curious ways or
am I missing something sure so during
our ranking function computation we
create one component of the
lexicographic ranking function /
transition so if you take if we get
variable I we only remove one transition
so we could also remove the other
transition so we are doing that which
seems a bit unnecessary because we can
we make use of it during bound
computation so that we know like for
each transition which so you could do
something smarter probably here directly
but but it's not needed so we in during
the the bound computation we then met
video views the fact that you have the
same variable so it's not so important
technically so basically you in
comparison it's less than less than
you just have it for me when you down
yeah so just to make the formulation of
the algorithm easier but yeah you should
use the fact some ordering the bound
computation to get better recites hey
knocking function of just I work this
will open each a decision
so the thing is that there's an error so
which I told you before so that on this
app a mouse transition it should only be
i prime less than i naught minus one
sorry about that
ok
so what allows you to do this virgin in
general why can't you do this for any
bastard oops
so
so we have a soundness a claim for
vector addition systems and a folder for
our bound algorithm so in general I mean
you have lots of variability of
different arithmetic operations so if
you just take two different loops which
are somewhere really different places in
the program in you merge them you will
increase the possible executions so it's
not so clear that what you're doing then
then there will be sound so it's really
an property of that simple abstraction
so we increase behaviors and so some hog
increases a little bit and but what we
sow the property we are really
establishing is that the combination of
this abstraction and debating how we
compute pounds so this combinational
salt
yeah so I can tell you more afterwards
so changes and okay so what is like
important to say is that the what a
vector distance system variables so in
all the examples you have seen so they
there was a one-to-one correspondence
between the variables in the in the
program and the variables in the vector
recent system but in general you
shouldn't think about these variables as
program variables but rather as norms on
the program state or like as any
expression on the on the state so which
gives you a number and so you could use
for example the height of the tree or
the length of a list or any arithmetic
expressions of those entities so any
expression the the video might think
useful you can can use and so what we
are doing in our implementation is that
we are using expressions that show you
that one particular pass during in one
loop a ver get smaller and so that it so
that this path cannot be repeated
forever so what we do is we simply take
two expressions from the conditions and
we check if they get smaller so this is
what we call a local ranking function
and yeah so we act is easy heuristic to
take expressions from the from the from
the program conditions and so then to
make sure that they are natural numbers
we use this expression the maximum of
this expression and 0 and yeah so I
don't have have time to tell you how we
then really get abstracted transition
system but we don't do something fancy
so does this like the main idea okay so
we have implemented this and a tool
called lupus so its core implemented
with llvm and it uses set 34 for
detecting unsatisfiable path and for the
abstraction so we have evaluated our
tool on the CB
unch benchmark so it's a compiler
benchmark but interesting thing for us
that it contains like standard Linux
programs like VSIP and jpeg algorithms
so it's around two hundred thousand
lines of code and around 4,000 loops and
we can compute 78% bounds for seventy
eight percent of the loops and yeah so
we have some optimistic assumptions for
for data structures service regard to a
lazing and thing but so does we have
fair fair trust and our resides so we
need less than 40 minutes of of analysis
time and only a few of the loops
actually need more than then 10 seconds
of analysis time and our earlier to
needed eat at certain hours and so to
our opinion this improvement is really
to to this abstraction for inner loops
because the relational summaries are
very costly
ok so then so this is like fashion
literally still cannot answer
satisfactory and so what we plan to do
some time as you dispatch my comes with
test cases so we could run the test
cases and and see if and count the
number of rupee directions and then
compare these so but at the moment I I
can't say anything more that we looked
at a sample of that meant yeah did what
you can about those loops
so I have a slide on this so let me look
at that so it's mostly on the fact that
we cannot find the local ranking
function for even one path in the in the
in the loop and so there we sampled like
like 50 loops and so some of them are
due to things you didn't model like bits
operations or the only apply function
inlining very respectively so our
analysis is his interprocedural inverse
function inlining and so sometimes you
don't model unsigned integers and then
there are is this class of of those
sometimes determination is conditioner
or cannot be proven and so for all of
this 50 then there are like two 1727
cases they are you could combine our
analysis with stronger our techniques
for generating invariants so we consider
this and problem which is orthogonal to
what we are doing because there's no
general reason why our techniques to not
work so if you would have the knowledge
about the stronger arithmetic invariants
and sorry yeah inside the report you
abstract up some hours yeah so Vav
abstractor so either be in line them or
we abstract them and so if there's a
functioning which is like handling a
global variable than we might even be
unsound there and vie saying that if you
have a better environment designed for
degrees that you essentially use the
expressions in vials in the ranking and
so that depends I mean sometimes you
yeah you need that like an expression is
bounded from below so then we would use
this expression but other wise you know
that the but then you want to know that
like if you have x equals x plus n then
you want to know that n is positive so
that you know X is going up so that's
like another case where you need
invariants
okay so you have some other questions
well I guess I had one so i guess the
case that i like the potential function
set of your high because the case that i
think of the jury annoying is i have
like a loop it's copying you know some
collection into a list and in that list
it has you know a case where it says if
i'm in capacity to a resize yeah yahoo
it looks linear and it is in practice
but if you just do a pattern matching on
the two loops should get a quadratic
bound right with this potential function
we're talking about would allow you to
handle this adequately is that correct
so the case you are talking about and so
does not fall into this abstraction
because this resize upper bound is not
is not constant but so we are working on
this and so is very busy next tension of
this we will be able to handle what you
are suggesting
so now I think what you're talking is
that you like like standard vector in
head has this property this stl so that
if you reach the limit you will double
the size of the container you will copy
all elements and it is expensive but
though exactly is linear constant okay
it's constant yeah yeah so this is a
case here working on me only the first
melody will copy Logan
okay so then I continue with the second
was the second talk okay so this talk is
about online education so I guess you're
familiar with two packs for fun project
and so X for fun is helping you to
complete a programming assignment so
it's giving you feedback and so in text
for fun and in related research projects
the main focus has been on functional
correctness so we set out to to study
performance problems in in these
programming assignments and so we assume
functionally correct programs for a
start
so in order to motivate the techniques I
will first tell you about our
observations from the pecs for fun data
so if you have a given problem that
students have to solve there's typically
a small number of different strategies
how to solve these problems and so by
strategy I mean somehow the global high
level inside of the student how to solve
this problem and these strategies they
require a different feedback so i will
give you an example and then on the next
slide however and the same strategy can
have myriad of different implementations
and so by implementation i mean like the
low level choices like the programming
contracts they use and so this is the
path which is not not relevant for
feedback so as an example so i spent a
lot of time studying as allusions to the
anagram problem so anagram the problem
here is for student to write a program
that given two strings determines if the
two strings are anagrams and so one way
of doing this is to count for each of
the of the letters how often to cure and
to compare the these these numbers so
you can do this efficiently and so
basically linear but what the student
ended up doing here is going over all
the characters in the string and then
counting again and again how often this
character occurs so this basically gives
you a quadratic resolution so what you
want to give as a feedback to the
student is that you should calculate the
number of characters in a preprocessing
face so different strategy of of solving
this this problem is sorting the two
strings and then simply comparing them
so if you have quicksort implementation
does this like a quadratic but even if
it's n log n the point really is that is
this inefficient and that you want to
tell
the students about it so it turns out
that sorting is very popular with the
students so they understood sorting and
so they applying sorting again and again
so whenever they feel there is a
opportunity to apply it so here is
feedback would that instead of sorting
and try to compare the number of
characters so that I want to skip as or
regarding different implementations so
in c-sharp you have the possibility to
using a link expressions and so the
program and you will see on the right so
it has exactly the same logic as the
program on the left it's simply a
written Eva's ling a ling statement but
it looks quite different also for
sorting so you have the possibility to
use added library functions on the left
or you can implement your sorting
algorithm yourself and so there are tons
of different sorting algorithms so can
be quite different so now coming back to
to this problem statement from before so
how can we distinguish the different
strategies while ignoring at the
different implementations
and so the implementation detail is it's
like how you implement that way of
counting so the strategy is that you
will count the number of characters and
you're doing it again and again so this
is the strategy and so any way how you
implement it basically is a
implementation detail and so the same
for sorting just a strategy is that you
are sorting and no matter how you sort
that's implementation of that strategy
is here they you know on the left let's
say you actually had an N log n sir yes
and on the right you ready Bulbasaur
yeah those are are you actually going to
want to say like there's a performance
difference between these two words you
just want to say this is a sorting
family categorical solution so that's a
fair question so this these things are
kind of fuzzy so it always depends on
the goal of the teacher so with our
techniques you will be able to
distinguish them if you want or not to
distinguish them and put them in one
bucket if you want so the teacher should
have the flexibility to do either of
both
so yes but so the problem statements are
we can distinguish these strategies
while ignoring the different
implementations and so you have seen the
previous talks or how I started out
doing this was can we use these
techniques in the setting and so can you
use performance analysis and so further
motivated by the examples you just saw
so it will not be as efficient for what
we want to achieve because the same
different strategies can have the same
complexity and you will not be able to
distinguish them by performance analysis
so you can have two quadratic strategies
so this also applies or two dynamic
approaches of just measuring the
performance so this also might not help
you so another approach this is very
popular in online education and pursued
by by many people is machine learning
and machine learning relies on
recognizing syntactic patterns in the
solution and we feel so we have noted
that for this domain so there are too
many programming constructs and you will
not easily be able to distinguish them
so we then came up with something
different and so what we end up doing is
we specify strategies somehow by the key
values which appear during the
computation so this is a dynamic
approach so we will execute programs and
observe what is going on during the
execution so for these two examples and
so which implement this counting
strategy as what we've what we want to
observe is the fact that they count so
that they go over each character deck
counter often it occurs and doing this
more often than necessary so you see
here these the locations where this
county
is happening and so that they here you
can see the on these two sequences the
line numbers where this value is
happening and the black other are the
values so for these two strings so
actually this is the for the string s
you get these value sequences and so by
executing the programs and only are
observing the value sequences we kind of
get rid of all these implementation
details and we just can observe what's
going on so this key value idea is quite
quite flexible so it allows for example
to to see that you're the student is
starting in a very simple fashion so we
just have to observe at some point of
time the VC assorted string during the
during the execution so the key value
here simply would be this observing the
sorted string okay so what what will we
do so I will sketch now the methodology
of our approach so the student provides
an implementation so this is what you
have seen and then there will be a
teacher and the teacher the writer
specification and the teacher will
provide the test inputs so to execute
the program then we will execute post
implementation in the specification and
then we will get traces and we will
compare these traces with this notion of
trace embedding which I'm going to
explain you in a minute so how does the
teacher specify the trace that he wants
so the teacher simply has access to to a
special print statement which we call
observe and so when the program is
executed the observe statement will
simply put the value will append value
to
and zone this way the teacher at the
teacher is able to specify exactly the
sequence of key values that that he
fields are important to match for the
matching so for the student when we
execute the program we will instrument
to the code before executing it and
we've instrumented in such a way that we
record basically every sub expression so
every during the computation when an
expression is evaluated we verify the
sub expression append the value stood to
the string to do this to the sequence so
you see that we not only get the key
values which we want to observe but also
additional values which which appear
during the execution of the program so
now we have these two traces so this one
trace trace a we got from teacher and
via the stray speed we got from the from
the from the student and now we want to
match them so the central notion of this
approach is the notion of trace
embedding so the notion of trace
embedding so this determines whether
this is a match or not so what we what
we do is we try to make this trace a a
subsequence of the trays b-but so for
this we require that there is a mapping
from the probe from the blue program
locations to do to the red a program
location that is injective so here if
you map 322 if you map 6 to 12 and if
you map 11 to three then the
specification trace really is a sub
trace of of this trace beam so
intuitively what does this mean so this
notion gives you that the same values
appear in the same order so this comes
from the from the subsequence
requirement
and then the second requirement that you
have this injective mapping so this
gives you that the same values appear on
matching locations so if like values are
generated at location 6 so all these ABA
are generated location six then ABA must
be also generated at the location to
which success map so at 12 so this is a
fairly strong requirement so why don't
we simply go with subsequence so this
notion is inspired by the notion of a
simulation relation so in a simulation
relation you associate locations and
then when you get there you want the
same values so this is a dynamic version
of office emulation relation and so we
did this because if you don't have this
requirement you can match some garbage
like if you have a loop counter simply
as though it's going computing from 1 to
N and if it's so you can find any value
in there and so does sometimes recited
imagines that were not intended but this
a stronger notion works works really
well so the last thing I want to mention
is that injective injectivity does not
allow you to map two locations to the
same location and so this is sometimes
needed so we have an extension I will
come to that later but it's rarely the
case so most of the time you want to you
really want an injective mapping ok so
how can we decide us so it turns out
that deciding this trace embedding
notion is np-complete but so we have an
algorithm that is as fast and works
fasten in practice
yeah so I will skip to algorithm so how
do we imagine this technology to be used
so we have the student so the student is
writing an implementation and then we
have the teacher so the teacher
maintains the set of specifications so
there are specifications for in
efficient implementations and their
specifications for efficient
implementations and I will come to them
in a minute but so for now if the
student writes an implementation it's
matched against us the set of
specifications so if there's a match the
student will be provided to feedback and
if it's efficient the student will be
informed that it has done a good job and
if there is no match then the teacher
will be notified that there is no that
there is no feedback at the moment and
then the teacher can provide a new
specification so this is how it could be
used for unpacks for fun for example
yeah
so now coming back to em to the
specifications so one interesting detail
is also that the the subsequent
requirement so the subsequence
requirement allows us to do partial
matchings so in these two counting
specifications so you have the
implementation on the left so there the
implementation will return for us as
soon as it detects it is like a
different number of two off to your
number of characters and on the right
you have this s all statement so I
actually do not know for sure if it
exits early or not but let's assume that
it goes over oil it compares all numbers
of strings and and so you have no two
versions so we are we break early or not
and by having the subsequence
requirement though a specification which
is also partial they match both of them
so this is quite convenient so to be
able to handle these two cases and one
specification
but the most efficient of the nation yes
yeah yeah that's this is so you can also
do like a bit some other things but we
should discuss this offline so yeah
that's what I said and so in contrast to
this service efficient specifications we
want to be more careful so for efficient
specifications if you will have a
coverage criteria and the coverage
criterion says that every loop should
have a location that is matched so to be
sure that there is no loop which doesn't
have a location to which we match so we
don't get it and the second requirement
which can be specified by the teacher is
that if you add this notifier full to
the absurd statement that then for this
particular location you don't want to
have a sub trace but the trace equality
so by this you make sure that there is
no additional stuff going on so you
could use this and also like in this
case if you want to ensure that
everything is is matched so this is what
you could do and because this forces
suzhou like full and does full notify
and discovers criterion they really
require you to match every loop and so
in order to make it more convenient and
we provide like a special cover
statement which allows to match loops
with a specified number of iterations so
this is an efficient specification so
let's understand what is going on so in
an efficient specification you count for
both strings the number of characters so
you store and you set up an area with 26
size 26 so for every letter and then you
go over the string and so for each
character you increment this counter by
yeah for each character that you see and
so and the code student can write so he
has to do that for the second string as
well so he has to count the second the
occurrences for the second string so you
can either do this in the same loop or
he can write an extra loop but there's
like a different implementation so value
instead of incrementing for a second a
character ever for for the second string
instead of implementing you can use the
same area and simply decrement and then
check if everything is zero in the end
and so because of these different ways
it's very convenient to observe this
really for one string and then you say
the second a loop may be there or may
not be there so this specification
allows you to match three consecutive
loops with each up to 26 iterations yeah
so does it yeah
so now if you go over the second string
you actually have to go are not 2650
good life
is your right so I made a mistake there
so you could shut then add for this 26
and so for boss 26 you should add tea
length and then it would work
okay so now I want to come to some
extensions and so you have seen the core
idea and we provide some additional
constructs so one construct so one
challenge is how to deal with library
functions so you have again the
accounting strategy of the student and
now he has implemented counting by using
the split function so what should we do
about it so for library functions you
can either go into the implementation of
the library function but it might not
always be available and you might not
want to do it so what we do is we make
if you see that the library function is
called we make that the value so we
record that this library function has
been called and reservoir values so we
extend our language to allow the teacher
to specify that he wants to observe
function calls and was what value so
here observing this function call will
result in that in that string and that
sequence so where you see that as a
value of you have recorded that is a
function has been called so this is how
we deal with library functions and our
challenge is and symmetry and minor
implementation differences so in a in
this NR game problem you have like s and
T but the student can simply switch the
role of S&amp;amp;T and so that might cause you
to to write a second specification and
so what we can do is that we provide a
non-deterministic choice so the teacher
can write a specification they are non
deterministically he swaps s and T in
the beginning
so the non-deterministic variables are
only decided once so if you have any non
deterministic choices this will
correspond to 2 to n similar
specifications so this is just syntactic
sugar and it allows you to conveniently
specify and multiple specifications in
in one compact specification so then
there are other extensions so one of
them is one too many matching so that
you allowed it and one location matches
to to several locations and only one and
so the other thing is that we allow
teacher to specify how to convert data
so for example if you have a string but
the students sometimes will stay
converted to an area of characters and
so then we we want to allow the teacher
to specify that you want to compare that
so we also allow threat so by threat I
mean that you can specify so what values
are independent of order so the
definition I gave you and this
definition works almost all of the times
we insist that the order is really the
same but so for this case where you can
swap S&amp;amp;T both of the strings so the
order if you do s first or tea first
really does not matter so you could swap
a new order and yeah another interesting
extension is that if you want to observe
iteration of the data structures and you
have an iteration over a set was order
the iterations under specified so the
set can choose which elements vote to
give in what order but the correctness
of the program doesn't not cannot rely
on this so we can simply determine the
order in which we see the elements okay
so we have implemented to this approach
so its interim plan didn't see sharp and
to the specifications and student
implementations are awesome and C sharp
as only Envy studied three assignments
from the pecs for fun platform was over
two thousand correct implementations for
them and then we created our own course
and was 24 assignments but we only
managed to get 50 students to do it as
we forced them as part of a cross
requirement and so our observations are
that there is indeed a large number of
inefficient implementations like for the
anagram problem there ninety percent of
the implementations are inefficient and
so they are also like 2826 of all these
assignments which have more than one in
efficient strategy so you want to be
able to distinguish between these
strategies so our tool is as fairly
precise so for the moment we've early
only a evaluator so this probably to be
expected but at least the formalism is
precise so we didn't get any false
negatives so nothing matched which
shouldn't match but 45 cases
implementation match the specification
visual shouldn't match so specifications
are fairly easy to to write so they're
typically the same size of a of an
average implementation maximally they
get three times larger so we rely on
inputs provided by the teacher so it's
nice that you really only need one to
two inputs and you don't need too much
and non deterministic choices so the
performance is really fast so this is
important if you want to use it in an
interactive setting as online education
so at the last slide is under under
under teacher
effort and it's also really about how
you are able to to give feedback fast so
you can see in these charts so on the
left you see like the number of
specifications written by the teacher
and how many implementations they match
so the setting is so you're now sitting
in front of all these student
assignments and you start writing
specifications so we then the teacher
gets randomly one of these
implementations so he writes a
specification for that and that matches
already like 200 or 300 solutions then
he gets the next implementation he
writes a specification for that and then
you already matches over the stars and
implementations and then you see with
more and more specifications or mistakes
the teacher does refine the
specifications you use saturate soon the
most of the implementations receive
feedback hella fast on the right you can
see the corresponding time and overall
the teacher had to go to three percent
of the implementations to to write
specifications for all of the
specifications and yeah so we are hoping
that we will be able to do a real case
study okay so that concludes at a second
talk
number questions throughout the thing
really has more questions
so when teach other guys the
specification all they know that they
only much the solutions that they wanted
to much
sleep
yeah so this isn't a decision issue
though and for that our our notion of
Christ and building is fairly
prohibitive so as I try to to motivate
so it's it's it's really strong and so
this so if the teacher should take care
there so then the other thing is the
setting so the if the students they
could have a button so they could say
like wrong specification or like answer
doesn't make sense so that day that will
help if the student get worse grades not
but if they get a better grade they
probably wouldn't complain but yeah so
these are my answers to that
okay well thank you very much and thanks
next</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>