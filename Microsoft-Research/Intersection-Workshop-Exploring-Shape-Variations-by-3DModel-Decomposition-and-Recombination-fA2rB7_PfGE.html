<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Intersection Workshop - Exploring Shape Variations by 3D-Model Decomposition and Recombination | Coder Coacher - Coaching Coders</title><meta content="Intersection Workshop - Exploring Shape Variations by 3D-Model Decomposition and Recombination - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Intersection Workshop - Exploring Shape Variations by 3D-Model Decomposition and Recombination</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fA2rB7_PfGE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
yes welcome to my talk so this is
conjoint work with Argentine who's a PhD
student with me to be as Richard and
hans peter schneider and the title is
exploring shape variations by 3d model
decomposition and pathways recombination
so i recently became interested in
looking at 3d models databases as they
are a variable on the internet so maybe
that many of you have heard about google
3d warehouse there's turbosquid there's
dosti and many others and there we have
these perfect 3d models modeled by
designers who know how to do this and
the ideas now can we harvest this
information to provide new modeling to
it's easier modeling foods that are
maybe accessible also for novice users
and you see a robot from this database
and it's composed out of many parts and
there are other robots in this database
and now the questions that proposes can
we generate a blended shape between
these two robots or if you have even
more robot can we generate a blended
shape between these three robots and
obviously we can so this is your our
system and as you see it has very easy
user interface where there's a slider
user interface and when the user moves
the slider the system automatically
interpolates between these shapes so i
have to say these shapes are not anyhow
annotated or something this is a fully
automatic analysis and this is the
result that you can get out of this so
here we now combine a third robot into
this so you see a system overview of
this tool so input to the tool as all
the data base models then we perform a
shape analysis of all the models this is
in the offline phase then we store all
the pre computed data
into a into yeah serialize it onto disk
and then we perform on the online phase
we use this information to perform an
interactive session where we do shape
synthesis and generate new models okay
so I first want to talk about the shape
analysis part of this pipeline it has
several steps so first the segmentation
then there's contact analysis symmetry
detection and a hierarchy and now in
this video you kind of see a
fast-forward of these steps so first we
perform segmentation then we perform PCA
we perform contact analysis and we all
do this in a hierarchy so here you see
different hierarchy levels for the
segmentation different hierarchy levels
for the segmentation into PCA and
several hierarchy levels for the contact
analysis so I go now through all these
steps in a bit more detail so on the
left you see the input model and the
first step is to segment this model in
two parts and there we assume that the
designer while creating this model has
already created it from parts but while
storing it on the in the internet
repository maybe as an obj file or
something this information is usually
lost and so what we do is we look for
connected mesh components and this we
can simply do by doing region growing on
on the connected components and this
gives us this part representation and
this is the finest representation that
we can get for the parts then we sample
the surfaces of the polygonal mesh to a
point cloud and on each point cloud of a
part we perform a PCA and this PCA gives
us a local coordinate system for each
part you see here these boxes these are
individual local coordinate systems for
all these parts
robot do you see it's composed of
definitely maybe maybe 200 parts or more
next we perform a contact analysis this
gives us the structure of this object so
you see the connections between parts
that are almost touching each other once
we have that we run a symmetry detection
step and in this step we kind of a
random sample to similar parts maybe
these are the the two-foots or something
the two-foots define have 3d points in
space and so do they define a symmetry
plane and then we look how much the
other part supports this maybe symmetry
plane and this gives us the dominant
global symmetry transformation which we
call each now with all this information
we build a shape hierarchy so and this
goes in front of a course to find levels
or level 0 0 ke 40 is a cautious
representation they're all parts of the
object I kind of glue together to one
part and then in each next level we kind
of split the object either into two
objects or into three objects dependent
on the configuration and during this
flipping operation the the symmetry of
the object is taken account and we also
enforce that parts are always connected
okay so we do these for all the shapes
we have all this information now in our
our database on disk and now in the
online mode we do perform shave
synthesis and this consists of shape
matching shape interpolation and a
contact enforcement so I start with
shape matching so one approach one could
think now is that we have we have our
high repeat for the sauce shape and we
have our hierarchy for the target shape
and maybe one could look
at a certain level maybe k equals 2 and
K equals 3 we're both of them have
approximately is a similar number of
parts and now the task is okay which
parts could match and as we see this is
very difficult because maybe you know
this car has as one tire whereas the
truck has truck tires maybe one word
about the the visualization here so the
2d polygons are the parts on the finest
level and the the color coding is what
is one part on this particular level so
what we tried first to match these
things is we performed spectrograph
measuring we have a graph because we
have this contact lenses so we said or
while mayor we could run spectrograph
measuring but the best maybe assignment
even might want to do manually is maybe
this one and and why is this not perfect
because the segmentation of these bows
but most these objects are not the same
so we learned by doing it or maybe we
need to update the segmentation while
matching and this was actually the key
success to make our approach work so
what we do is we kind of first rebuilt
the hierarchy to have a similar
segmentation as associate okay here's
the comparison on the top you see our
original approach and down there you see
like what would be the matching color
coded was our new approach so okay so
now I go in a bit more detail how does
the shape measuring work it's very very
simple so on level 0 as I said they're
all the parts belong to 2d objects or
the object is assembled out of oil parts
then on on the next level we split it
into three so the main body of the car
and two tires and we also know now the
center of of the collection of the part
and we know the center of the opposite
hires and what we do now we just move
these boxes all over to the right
and see now or which parts are closest
to the centers and further for the for
the upper part of the track these are
assigned to the green ones and the lower
our time to the average one and the
purple one assigned to the purple tie
off the car and we redo that for the
next hierarchy level and so on until we
have a good match so one thing that we
did that is also a key to success is
that we always do the matching in the
local coordinate system so let's assume
on a on a higher level these two arms of
these two robots have already matched
what we do then we kind of look into the
local coordinate system so maybe these
things are back projected into their
local coordinate system then we look at
the center of these parts and then we
just say ok which parts are closest to
which so the one downed it this one is
closest to this center and the upper one
is closest to this center and then we
get a mapping and you see this this only
takes positional information into
account but it's very powerful if you
have very different shapes so if you
would say oh I want to do shape matching
between this and this this is so
different and it's so differently
segmented you would never succeed but so
next is shape interpolation there we
have this slider interface and this the
position of the slider tells us how many
parts from the target object should be
replaced in the source object
where we know now which parts to
exchange but obviously when we
instantiate them they appear at a
totally different position and so we use
the the contact analysis the structure
of the object to build up a mass spring
system which always puts part parts to
their correct position because we know
which parts should be connected and here
you see the mass spring system and of in
action ok let's come to some results so
usually the user selects the target
shape and move the slider and as you see
you know there are many shapes that
might be interesting that you maybe as a
human wouldn't have figured out maybe
you would have never assigned such big
needs to this slim guy so it's also nice
to maybe generate some new ideas for
artists and not all shapes of you know
look perfect but but some you know you
would maybe think okay this might be a
suitable model we can also blend between
different categories of shapes so you
see a blend between the plane and an
aeroplane and though it's not perfect
you know some intermediate shapes are
maybes may be quite interesting you now
see blend between two boats and see
they're completely different scale also
you know this is as many levels and this
Fisher boat or yacht has only the one
level but because we do a reset
mentation this is no problem it fits
approximately so we get a nice mafia
reside you see the morph between true to
contain about they have very similar
structures of the morph is quite good
more boats
you see more between a an aeroplane with
with four jet engines and to a jet
engines and also the wing structure is a
bit different so here you see it
changing and maybe once again so there's
no manual annotation so this is purely
from the data that is on the internet
repository we have some metal machinery
ok
so yes so the discussion obviously not
all intermediate shapes are correct this
is natural for an automatic method right
and another point is that morphing is
more challenging than only exchanging
some parts so there are methods so you
could now look at all the the methods
all the models that come out have some
criteria and say oh this one looks good
and only present the good one to the
user but if you have a slider interface
where for each slider position you have
to generate something obviously it's
much harder because there are also some
which might maybe even a human could not
figure out how to assemble these parts
but yes this what yes yes yes yes it's
as it comes from dosh so they are very
detailed models so several the part that
you see I only a fraction of the parts
that this model self I don't know I
don't know I one problem that we have is
that this typically works better on
tree-like structures because obviously
when you replace a child then you know
the rest of the things knows exactly how
to configure itself with a mass spring
system if we have interiors and they are
very connected then you have many
constraints you have to fulfill and
obviously do their conflicting
constraints which you cannot fulfill
necessarily and maybe then you need to
need a model which also allows to deform
parts or these kind of things this is a
key simplification here we avoid the
ryans of geometry of individual parts so
maybe you have a door from one car which
you want to fit to the door to the space
of the other car but it does not fit so
it looks you have an artifact there
yes so maybe semantic information and
functional owners would be useful so we
saw that whatever a boat was equipped
with some jet engines but because we
don't have any semantic information
currently it's purely on positional
information we get semantically wrong
recombinations but what what is it may
be the key take-home message here is
that position information if applied in
this hierarchical fashion is very very
powerful and good tool to to match
shapes so summary I have presented a
system to synthesize new 3d models from
a database of many parts Apes one can
blend objected highly dissimilar can
help artists brainstorm ideas is well
suited for non-expert users because only
has one single slider and yet might also
might be useful to generate a large
amount of synthetic data shapes food may
be trained computer vision idealism
that's it so thank you very much we have
time for questions and we have questions
so yes yes so this is paper by NIDA
Mitra or his group how things work you
know this so he really in L it analyzes
the joints how they you know can
interact with each other but then you
also need to assume that the modular who
designed this thing has really built it
such that it would work right so yes
dieter just
no I mean a key challenge is the
segmentation if you would provide the
segmentation I would assume it would
look I mean noise is not a problem here
it's a you know it's a very very simple
algorithm as you might have noticed it's
just over laying position information so
they're not much that can go wrong so I
I don't see the noise as a problem spin
and then why not there's much more
information than change we have right so
people could decide to first change the
arms than the legs etc etc yes so how
would you maybe maybe you elaborate a
little bit on the possibilities of
advanced user interfaces yes actually
you know when we first meet us this
paper we had all these user interfaces
in there and then they bash the paper
because we didn't evaluate at them all
and so we took them all out but yes so
we had to user interface you can pick
apart and then it suggests other
possibilities and so on but usually the
thing that comes out of this is much
better of higher quality than what you
see here it has set the blending is
actually actually the heart of it and if
you can succeed here you can also
succeed in be in the other task we also
had a user interface where you can only
navigate by a semantic attribute so you
could say i want to make the ship older
and will then would take parts from
older ships or these kind of things
because they intend on this pc a very
beginning this depends on not one may
excess of the object like this depends
on the distribution of points yes but I
mean how do we use this information we
only use this to define a local
coordinate system so if this local
coordinate system is maybe flipped or
something then we need to have it
flipped on the other side as well but
this is no problem because we reduce the
segmentation on the other side if you
will do it independently then you know
if you have a flip coordinate system it
would be killer right so you would match
the underarm to the upper arm no no I
mean let's assume you know so you match
to human characters so first one has the
arm here and the other has yeah I'm here
so first you say only left and right and
left and right those on the arm level of
the image and then we have a local
coordinate system for this guy a local
coordinate system for this guy and only
in this local coordinate system you have
to make them left left and right right
and so it's this is what you meant so
it's yes obviously also we assume that
they're all up right facing north these
kind of things you know facing front
we're facing this is what we assume is
done by the modular in the database or
if not we flipped it and this kind of
gives you the information that the head
is not you know on the other side
exactly yes
discrepancy between what people with
different levels of expertise would
think about the results and there's
something but I look at a robot st.
early cool robot person giant robots I
look at it and say it will fall over his
obvious didn't eat a hydrogen that piece
has to wait a whole lot more than you
might think that it actually want or you
have two pieces that that when put
together a near each other might make
for hydro dynamic properties that
accenture just not work and you know
you're an expert you might not even know
that but of course you could Gary be
doing the analysis to figure out whether
that was the case you're not bigger
range yeah so you could in theory put
this all on top right you could have
this built many models and then have
some objective function that tells you
this is physically possible this is
maybe mechanically possible as may be
semantically possible you yes yes yes
yes
again
it's another paper any more questions we
enforce that there appear at the same
position again right but we don't
enforce here but we could it's that if
they would intersect maybe ensure that
they don't intersect but it's a mass
spring system so these kind of
constraints you could easily put in we
were just too lazy kind of discussion
that the comic made by the users today
it seems like a really example of some
really really bad review process of a
show i watch out for like it might
pressure this is it you shouldn't need
you to say it all for these it's the
results speak for themselves and its
really bad if you your favorite was made
a lot worse because people have
requested an evaluation in skate you to
tell you just icing on the cake so I
have a question but I just may comment
comment
yeah I think we had a user study
obviously yes but it's more than I can
task performance these kind of things i
have a user study
okay I think this is a good point to
move on to the next paper thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>