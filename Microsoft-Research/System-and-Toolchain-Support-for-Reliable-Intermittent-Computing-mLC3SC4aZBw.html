<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>System and Toolchain Support for Reliable Intermittent Computing | Coder Coacher - Coaching Coders</title><meta content="System and Toolchain Support for Reliable Intermittent Computing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>System and Toolchain Support for Reliable Intermittent Computing</b></h2><h5 class="post__date">2016-06-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mLC3SC4aZBw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">materials supplied by microsoft
corporation may be used for internal
review analysis or research only any
editing reproduction publication
reblogged public showing internet or
public display is forbidden and may
violate copyright law
I'm tomball and it is my great pleasure
to welcome Brandon Lee to you back he
was a researcher at Microsoft Research
and now he's an assistant professor at
Carnegie Mellon University he does
amazingly cool stuff with hardware and
run times and he's about to launch into
outer space via SpaceX some cool little
circuits and I guess we're going to hear
a little bit about what the challenge
might be if you want to put something in
outer space that doesn't have its own
battery pack welcome back yeah thanks
for the introduction stock won't be
about space entirely it's going to be
about a general problem that we run into
in space which is intermittently
available energy and energy harvesting
so there's a lot of a lot of different
design challenges that you run into when
you're trying to build devices that you
want to run off of energy that your
borrowing from your environment so I'll
talk about what the challenges are that
I'm going to talk about some system
support that we built for that that kind
of dropped last year and they'll talk
about some stuff that we have going on
right now which is kind of the state of
the art and debugging devices that are
doing intermittent execution and energy
harvesting I'm from Carnegie Mellon
University the electrical computer
engineering department and the stuff I'm
talking about is what I've been doing in
my students have been doing together so
it's kind of big big happy family group
effort from over there so probably I
need to tell you guys too much the
motivation for this kind of work is that
we have little devices everywhere so
your medicine bottle isn't just a
medicine bottle anymore there's like a
computer in there that's telling you how
many times you've opened the lid and
where did that come from and where is it
going so you know if your medicine has
been somewhere that you don't want it to
be and are in the hands of someone that
you don't want it in their hands and
these devices are in the medical domain
we can put these devices into space and
they can do things like try and find
resources extraterrestrial e that we
want to mind and bring back to earth and
lots of other really cool stuff so
emerging devices are everywhere and a
lot of these especially if we're looking
at kind of medical applications we need
the devices to have high reliability in
particular things that are expensive or
dangerous need to be reliable and so for
the most part when we
build devices using little embedded
systems like this we are tied to a power
source like two double A batteries or
maybe you have to plug into a USB or
maybe you have some big chunky power
pack or something like that so this is
problematic because these devices you
can't put them everywhere they're not
tiny it's hard to put them say inside of
your body for medical applications and
if you're going to launch something into
space you probably want something more
sophisticated than for double a's that
you're going to go and shoot it into
space or if you want to you know monitor
volcano your double a's are just going
to catch on fire and go away so that
won't work so we're looking at the
result of kind of years of research on
something called energy harvesting and
energy harvesting is the technology that
effectively untether is the device so
here's how it works this is the basics
you have an antenna which is an energy
receiver you have a capacitor which is
an energy buffer it's just like a bucket
you're pouring electrons into and then
you have kind of the downstream
application hardware so this is a
computer could be a microcontroller you
can have sensors you can have a radio so
that you can send communications from
your device but the basic model of
operation is you have some energy source
over here like this big square antenna
that I have on the slide you have some
empty space this can be you know 20
meters 40 meters that kind of range it's
not you know infinite range if you're
especially for using this kind of like
an RFID reader antenna as your energy
source and then you have a target device
like this kind of janky breadboard
mock-up prototype that we built in my
lab that is implementing some
applications so the future what we hope
for is that someday you can cram one of
these things in your head and it can
help you to understand say you have
schizophrenia or say you have autism or
something this can help you understand
why you're behaving a certain way on a
certain day these kinds of applications
I mean these these are the exciting
applications doing things in especially
medicine that we can't do today because
you don't want to be cutting someone's
head open to replace batteries or to
power and that's literally how these
things work today is you'll have a power
pack and you need to charge it so this
is a big shift this would be a kind of
dramatic shift from the way things are
done today so there's a problem
the purposes or is this that is riddled
trade purposes this is effectively click
on a clip art this is some existing
medical procedure I think that thing in
the center is I think this is actually a
battery I'm pretty sure that's a coin
cell so I think this is a probe that
someone put in for a shed for a
short-term experiment now this is this
is a probe that's some computation
probably radio and I don't know about
this particular image because I just you
know this is from google but yeah we
don't know the provenance of this image
I was just curious yeah but in general
experiments like this and they're short
lived because you have to take them on
replace the battery that's it that's the
big problem here yeah so if we go to
this energy harvesting that I was just
describing about where we can take
energy from the environment we can use
radio waves you can we can use solar
energy and we can power of these devices
there's a caveat and that is that the
energy that we get is intermittently
available we don't always have energy
available if you're near a radio tower
then you have lots of energy you can
soak it up and fill your capacitor and
run your device but if you go far away
from your radio tower then suddenly you
don't have anything available your
device turns off even if you're near a
radio tower you charge up a capacitor
and then you start running your device
that drains the capacitor and when the
capacitor the capacitor is going to
drain much more quickly than it can
charge up so when you run your device
unless you're very careful in software
and that's actually an open problem how
to be careful in software you drain the
capacitor and so you essentially the
device just kills itself at the cadence
of the charge and discharge of the
capacitor I'm going to tell you more
about that but that should give you an
idea that these devices are inherently
unreliable this is an important point
they're inherently unreliable because
you don't have a continuous execution
model because the energy is intermittent
so this can i solve a pie and the switch
between you two passengers turkey if i
do have you and you do that but it's not
going to solve it's not going to
entirely solve the problem because then
you have two things that are going to be
charging and reliably and you have to
power the logic that switches between
them so okay what if we have three let's
have three capacitors now we can switch
between the three we may not have
charged in any of them that's adequate
to run our device and now we have to
have more sophisticated reasoning about
which one we're going to use so there
are yet we could we can try and
fine-tune the power system I think we
should attack the problem in software
and says what I'm going to talk about
today is actually how we can take this
on in software and there's a little bit
of hardware stuff
talk about later but primarily I'm going
to talk about how we can solve the
problems of the intermittent execution
model which I was just describing and
how we can think differently about
building systems and in particular
building software for these kinds of
systems I'm going to talk about some
systems support that we've built for
making intermittent executions reliable
and then I'm later going to talk about
some very recent work that we've been
doing on a hardware software platform
for debugging intermittent devices so
this is filling the gap the absence of a
tool chain for understanding
intermittently executing devices okay so
to give you a clear idea of exactly what
it looks like when we're running on
intermittent energy we have a plot here
the y-axis is the available energy and
we have time going across the bottom and
here we have a lightning bolt indicating
with some radio frequency energy being
transmitted over to our advice and so we
charge charge charge and then we hit the
Lifeline this is an important point in
the timeline of this device when you hit
that point turns on you start operating
the device can use sensors communicate
whatever and when we're operating you
see we precipitously drop off and the
amount of energy that we have the
capacitor is being drained very quickly
because maybe we're being naive about
how we're using the energy in the
software then we hit the deaf line we
run out of energy by the way the
lifeline it's around 2.4 volts for a lot
of microcontrollers 33 volts is a kind
of standard operating level for
microcontroller to point 4 volts just to
give you a concrete idea of what the
parameters are here is kind of what that
lifeline is and 1.8 volts as the death
line and so if we're looking at kind of
hundred micro a hundred micro watt
operation that should give you a
ballpark of the kinds of devices we can
support with this with this month with a
radiofrequency charging in particular so
we hit this deafblind crossover and then
we're not charging we're dead we're far
away from the radio antenna and we can't
get an energy a little while later maybe
we get some more energy we're charging
and then we hit the Lifeline again and
okay cool we can start operating again
this is a complicated plot because
there's a bunch of continuously varying
parameters we have energy level and we
have to find a way of measuring that
accurately and time is moving forward so
part of the work that we've done in
defining intermittent execution is
abstracting some of the details away the
way we abstract it is by noting that
here the computer shuts down and here
the computer reboots so really instead
of charging and discharging
all we need to see from the software's
perspective is that we have a sequence
of periods of reboot and computation the
red parts are when the device is turned
off the green part is when the device is
operating this is what we called the
internet an execution model and this is
stuff that we published appeal the eye
in 2015 the internet and execution model
says you compute for a while then you
drop out and then some arbitrary period
of time later you don't know how long
it's been you don't know what
environmental changes have happened
that's the intermittent part you turn
back on and you start computing again
and our goal is to make computations
that go longer than one green box that's
the hard part so just to look at what it
looks like to run a computation if we
have some code that looks like this you
want to append some things to a list we
have a main function at the top that's
going to append 10 things and we have
the append function which bumps a
pointer in your list and then puts a
character in the location that's pointed
to in the array so let's run this on
intermittent energy and just see what
happens we could maybe run for a couple
of loop iterations then we get a reboot
okay well we're going to start over then
and we're going to do one iteration
start a pending and we're going to get a
reboot we can do this all day and will
maybe make it you know as far as three
loop iterations or four depending on the
size of our capacitor and the amount of
energy we have but we're not going to be
really successful at doing any useful
computation if that's our model so we
noted that we can model intermittence as
a control flow problem so this is a
control flow graph and it maps to the
program that I just showed you and we
can add edges to the control flow graph
that essentially go back in time so
you're at some arbitrary point in the
program and according to an external
environmental condition it's not a
data-driven control flow edge but
instead it's a kind of environmental one
you go back in time and so these are
implicit control flow that's one thing
that's really hard about this there's
nothing in the code that says from here
you could go back to the beginning of
main the programmer has to reason from
each point in the program that they may
be able to go back in time this is hard
even if you're even if you're very
clever and you decide to use some kind
of check pointing system which I'll talk
about in a minute this problem doesn't
go away so intermittent a big challenge
to doing intermittent execution
successfully is dealing with the fact
that you can go back in time these
devices that I mentioned in written the
executing
you're harvesting devices typically have
a hybrid memory system so what do I mean
by hybrid the hybrid is between volatile
and non-volatile memory so a small
amount of volatile memory is typical
around 2k and then a larger amount of
byte addressable non-volatile memory is
typical and a lot of microcontrollers
these days are using something called F
RAM which has reasonably low access
latency and energy although it's still
much higher than SRAM or D Ram so we can
use the non-volatile memory a lot like
we use the normal RAM in the computer
and of course we can use the volatile
memory just like we would normally
except that the volatile memory has this
peculiar property which is that its
values disappear so if we want to span
periods of failure then we have to deal
with the fact that our memory gets
erased all the time and the non-volatile
memory doesn't disappear it keeps its
values this is straightforward but I'll
show you in a minute that that gets
problematic if we start using the
non-volatile memory just like ram and we
are also using some volatile memory like
rain so zooming out for a minute the big
idea is that the tools we have and the
mental models we have for building
software don't align with the internet
execution model and in fact something
that is correct when you have continuous
power gets really weird and sometimes
incorrect in unintuitive ways when you
do intermittent execution especially
when you start mixing together
non-volatile and volatile memory and so
I'm going to talk about a new category
of bugs which are related to
intermittence and the hybrid memory
system I thought this was really gross
comic which is why I included it okay so
I'm going to talk about intermittence
bugs now and you guys can stop me if you
have any questions along the way I'd be
happy to keep taking questions align the
first intermittence bug that I'm going
to talk about is an out of thin air
value that you can get and this shows up
ok so the setup here is we have the same
program we were looking at before now we
could say that there's a checkpoint at
the beginning of that loop and we can go
back to that checkpoint and now the
setup for the checkpoint is we're
capturing the volatile state of the
program and when we fail we're going to
reboot repopulate the volatile state
we're not going to do anything to the
rest of the non-volatile state because
it seems like we don't need to check
point that it's non-volatile we can just
keep that around
and so we'll go back to this checkpoint
at the beginning of that loop and will
execute forward again so if we do that
we can see that size and buff there in
grey that means there in the
non-volatile memory and they're
initialized to buff is an empty buffer
of characters and size is negative one
meeting we have nothing in the list
right now so if we run the program like
I showed you before we get through
incrementing size and then putting a
character in the buffer this is pretty
straightforward this is easy easy to
understand how the state gets
manipulated there and then we fail so we
were at this point let's say we hadn't
made it around this loop like I said
there was a checkpoint there so each
time we go around the loop we're going
to checkpoint and say okay we captured
that we did one two three loop
iterations but we died right at the end
so now we're going to restart we're on
loop iteration one again but that
non-volatile state doesn't get erased
when we turn the power off that's going
to stick around and so what we see is we
have an out of thin air value a gets
appended twice for the i equals 1
iteration it's a buffer state that you
never exist it's impossible in a
continuous execution we won't be able to
see this behavior in fact we can run
this out to its kind of natural
conclusion let's keep going around this
implicit loop it's still loop iteration
number one but if we just turn the power
off repeatedly like that we're going to
keep updating that buffer and eventually
we get the size to 11 that's a value we
could never see before we have this
array it has 11 days in it that's a
value we could never see before so we
can produce values in the execution of a
program that if you run on continuous
power you would never encounter and the
important thing about this is the
failure is dependent on the availability
of energy and the rate of charge and
discharge of the capacitor that should
be concerning because that means if I'm
using radiofrequency energy to charge my
device and the transmitter is here and
the device is here I can do this and
change what the software does that's a
system behavior you probably don't want
there's another kind of bug that we
encounter this is an atom icity in the
conventional sense of an atom icity
violation some things that should happen
all at the same time don't necessarily
happen all at the same time and you get
values that end up being weird in this
example program we want the increment of
size and the population of the buff
to be atomic with one another and we can
clearly see that if we kind of execute
up to the point where we're incrementing
sighs and then we have a failure and
then we restart will be incremented
sighs twice and we only put one
character into the buffer so now we have
this weird atomicity violation
manifesting as corruption of the state
you have the size equals one and you
have the first entry of the buffer is
unpopulated so Adam st violations are
another problem we run into we can get
memory corruption in the non-volatile
memory and remember we're using
checkpointing here we're preserving all
the volatile state in a checkpoint we're
going back and repopulating it okay
another another problem that we can run
into is if we have some high cost high
energy costs piece of code we could get
into a situation where we started a
checkpoint and try to run forward and
regardless of how hard we try we just
can't make it through the region of code
between the two checkpoints and this is
something that could vary in
environmental conditions rate of charges
the capacitor and the programmer has no
visibility into whether their program is
likely to or with what likelihood will
succeed and so this is problematic we
eventually you know end up in an
infinite loop and this program works
correctly if you plug your device in
that's that's one of the big problems
here is the programmer is probably going
to do most of their initial development
using continuous power and they'll say
ah my program works all I have to do is
foo and then high cost and then whatever
and in fact when you go over to the
intermittent power supply you're going
to see that this program doesn't
actually appear to do anything so I've
given you some evidence that these
devices are too unreliable to put inside
your body right next to your heart I
wouldn't want to do that and we need
better programming abstractions to make
these things reliable and I think we
need system support to go with the
programming abstractions to enforce some
reasonable guarantees on the behavior of
software that's running on
intermittently executing devices so we
came up with a couple and I'm going to
not go into a lot of details because
I've given some rendition of this talk
at Microsoft before so I'll skimp on
some of the details here but i'm going
to give you an overview of the kind of
system support that we have in mind to
make these devices more reliable
so in pldi 2015 we had a system called
Dino Dino as an acronym for death is not
an option and this takes if this
addresses the problem that I pointed out
before that checkpointing doesn't get us
out of this mire if you have
non-volatile memory in the system and
you have volatile memory in the system
you can end up with these problematic
inconsistent memory states where your
non-volatile memory has values in it
that you don't expect so if we take a
program like this one we can convert it
into a collection of tasks tasks are
demarcated by static boundaries in the
program and there may be and tests are
dynamically defined as you flow through
the statements in a program you may
traverse across a task boundary that
ends the previous task and it begins the
next task our system supports task
atonic semantics meaning that when we
start a task if it completes then it's
as though that task executed without
being interrupted by any power failures
so we eliminate the atomicity violation
problem and we eliminate the out of thin
air value problem as well the way that
it works is by selectively preserving
not just the volatile memory but also
grabbing pieces of the non-volatile
memory that through program analysis we
realize that we need to preserve
otherwise we'll end up producing those
funky memory states that I showed you
before another important thing is that
we eliminate these effective control
flow edges these implicit backward
control flow edges because we have these
task boundaries that have checkpoint
semantics with regard to control flow so
when we have a failure we go back in
time to not an arbitrary point in the
past where maybe a checkpoint was
collected or two main or something like
that but rather to a point in the
program that the program are statically
defined this is helpful because now we
can understand from if we look at the
program from a certain point in a
function there's a small set of points
backwards to which we could go on a
failure so we've eliminated this kind of
arbitrary implicit control flow problem
that we had before yep it seems like all
of the bugs are related to their very
similar to concurrency boats currency
related books
this has a feel of transactions in some
sense we miss available for a single
task yeah but transactions are really
hard so I had other other things that
people have solved in concurrency that
can be applied in this domain yeah this
is a great question so this is a lot
like concurrency and in fact in the
paper that I have cited here and you can
take a look at it we frame this problem
as not just the control flow model i
showed you before with implicit
backwards control flow edges but also as
preemption and it turns out that if you
have to preempt abul tasks that access
the same same state which is like a data
race then you have the penny can have
one of the problems that i showed you
before now with regard to the similarity
transactions I think you're right on the
money with that we want transactional
semantics we want tasks to be like
transactions there's a few differences
that make this this model maybe a little
weird but also really implementable one
of those is that we have kind of
statically bounded but dynamically
defined region so you can have this this
is kind of a weird thing transactions
are typically scoped with a beginning
and an end and each beginning has one
end in our case you could have an
initial boundary and then some
statements going forward and then a
branch and you could have a terminal
boundary on either side of the branched
and others for that given start task
boundary you have two potential end task
boundaries so that's just a kind of
mechanical difference from transactions
we do have some problems that
transactions also have like open nesting
and I oh and the fact that you have a
world that you're operating in and the
effects of that world whether it's
through other software modules or
through i/o interfaces it could make
your life more difficult for preserving
the item s if you have your tasks yeah
great question though I think we want a
lot of the same guarantees transactional
memory provides and so going forward
we've actually been looking at how we
can kind of take some of the big ideas
there and boil them down so we're
actually we're constrained in a way that
a lot of transactional systems aren't
and that is doing rollback is expensive
we need to consume memory to store a law
give everything that we've done and if
we encounter a conflict to some previous
failed incarnation of the same task that
we're trying to execute we need to go
and repopulate from that log or maybe
replay parts of the execution we have a
flavor of that here going forward though
we need to move away from that model so
that part of transactions i think is
similar now but should not be similar in
the future it's it's too expensive in
this domain you can't spend the energy
to go and repopulate the entire state of
memory based on after a failure based on
some log or something this is seems like
curriculum haunted very another
difference is that there is no such
thing as a local access as every single
memory access you do is in a transaction
where is it Tim system unit niche take
advantage of the fact that some of the
things you know are only give you rent
locally right there's no such thing as
local when and everything that can you
subject to car battery yeah that's a
shame point so something I'm not going
to talk about today but we could talk
about some other time is distinguishing
between volatile memory and non-volatile
memory and treating volatile memory more
like local memory and treating
non-volatile memory more like global
memory because you have this nice
property that when you fail you're
volatile you're volatile values all go
away so you don't have to worry about
partial results being preserved across a
failure like you do with non-volatile
memory so in a way that's sort of like
your local memory you nothing else can
mess with it now previous executions can
mess with it but you need to make sure
that you reinitialize it every time you
start a task and then run forward so if
you if you apply that programming
discipline to your volatile memory it
begins to look a little more like than
the local memory in transactional memory
systems cool cool so I'm not going to
dig into this in excruciating detail
because the examples pretty simple but
this figure shows how our system that I
just described with tasks and check
pointing and selective versioning if the
non-volatile memory eliminates bugs so
here's how it eliminates the out of thin
air value problem we capture the
checkpoint and this captures those
non-volatile memory locations and it
should be straightforward to see that if
we preserve those here and then fail
before we hit another task boundary when
we restart as
as we restore the values of buff and
size that we had before we can go
forward and we have a consistent state
of memory this is this should be pretty
straightforward so we're essentially
adding to the checkpoint is one way of
thinking about it it's important to
point out that prior work on this
overlooked the need to do this
versioning of non-volatile memory so
there are systems out there software
systems and hardware systems actually
there's a another paper and I'm not just
picking on mementos here there's work
called quick recall system called quick
recall that implemented volatile only
checkpointing in hardware even and if
you add non-volatile memory to the mix
which I think their devices even
probably assume it's problematic you get
the wrong result so i can pick on this
one because my co-author on the paper
that i'm talking about here is a
co-author on that paper too so he
happily welcomed the correction so the
the question though is which parts of
the non-volatile memory do we have to
capture in the checkpoint which parts do
we need aversion and we need to make
conservative assumptions because we want
to do the statically you wanted side in
advance we can't do any runtime
reasoning that's too expensive so if we
have a task battery we have to say which
parts of this program do we have to
capture well we can look at how data
flows so if we look at our control flow
graph we can see how data flows along
the control flow arcs in that graph and
we can see that on the implicit edges
that we added if there's no flow through
non-volatile data then we don't need to
capture that non-volatile data as part
of the checkpoint so you can see here
we're just assigning into this
non-volatile array we're putting I into
the bin I in that non-volatile ray and
so we don't need to preserve it because
when we restart we're going to go back
to the task boundary and we're going to
just blow all those things away it's it
seems this is straightforward that we
don't have to capture those however if
we if we change this program a little
bit and we say that we're going to be
incrementing each of the bins in this
non-volatile right now the story is
different now we do need to check point
that because we have a data flow around
the loop that's created by that implicit
control flow edge so if you store
something and then you restart you're
going to see the result of what you did
before you're going to see the
incremented value and you'll get wacky
values all over the place
so the key inside here is that we have
to version the data if we both read and
write the value that's something that we
can look for in the compiler and that's
actually what we implemented we look for
situations where we have both kinds of
operations and it's actually that's a
superset of what we need to look for
that was conservative we can trim it
down and we could have trimmed it down
that's what we did in our compiler
because it was easy to implement and it
works to keep things correct yeah more
precise will be upwards exposed uses
that was just those definitions
frightens you need to really see a data
flow around though you need to have a
use which is upwards exposed which means
there's a path to these from the
beginning of the task but some of those
are okay because if you have an upward
use a definition that right yeah yeah
yeahs a definition later yeah but I
think that produces that produces a data
flow around the illicit control thorac
run yeah right so if you do this so you
make it more precise than me right yes
we r ya working in certain weren't we're
saying we see both of these on the path
to a task boundary then then we would
preserve that in the novel maressa your
bush first thing I said it was also
going to take a shot at summarizing the
exact requirement doesn't really fit if
it is exactly hiding funds we want that
in votes yeah so it's like I'm just
saying anything this item focus free
anything just not let me put it oh
that's true that's true museum is a gem
quite a task boundary at a point that
defines all forward tasks to be added
home tasks in other words it encloses it
never it never cuts one of those edges
right then every check when it's true
but every one of these boundaries code
is free and the father you amount of
check when you do dragazine toward I'm
phones and once that's in and once
you're done we'll check by doing that
you have maybe there's another factor
and that is sometimes you don't want to
put a checkpoint or sometimes you want
to put more checkpoints both of which
could mess with that impotent the reason
you might want to do that is if you have
i oh and you want to for example put
task batteries tightly around io or if
you need several i/o operations to be
part of the same task because you know
you're correlating values to
sensors and if you collect one sensor
value now and 1 10 minutes from now then
it doesn't make any sense so subject to
those other constraints which by the way
are not edge cases they're very real in
this environment like this environment
is all about I oh it's your doing
sensing and your processing and you're
transmitting you you may be able to get
those item potent things but not always
yeah but it's a good observation yeah ok
so this example does reveal where we
work on them it reveals a fundamental
limitation of checkpointing and this
really sucks and this is something that
we're trying to get away from because
it's very expensive to implement this
what I was saying to you just a second
ago if we can't know in advance where we
might be accessing we need to capture
the whole thing and that's a huge drag
especially when your task boundaries
could be subject to external constraints
like the position of Io and your code
you could be really host I mean this is
a really contrived example we haven't a
you know million entry array and we're
choosing a random element of it that's
probably not what we're going to be
doing but you can imagine how this
manifests as control control flow
deciding which things you're going to be
accessing so my view is that in the
future checkpointing is not a viable
solution for solving the intermittence
problem we need to do something else
that preserves state keeps it consistent
gives good guarantees but isn't
reloading values every time we restart
so we built the prototype this is sort
of an unremarkable prototype it's the
way that you would expect it to be if
you've done this kind of work before and
I know most of you have so we start with
the program you have to put these
annotations in our compiler does a
dataflow analysis and finds the
situation's we were just talking about
it links us to a runtime and then when
we get over there we have a runtime
library that compiler links it to and it
does checkpointing and it does the data
versioning stuff dynamically as we need
to as you cross task boundary that's the
implementation we evaluate on a bunch of
different benchmarks that we got from
kind of various places we have a MIDI
musical instrument interface we have
sensor logs some very stuff we
implemented for a custom breadboard
prototype and for the wisp 5 platform
which are two different radio frequency
energy harvesting devices and if we
don't use any support for these things
we have errors and the system the
systems don't work all of these
applications for
is the wrong result or they have a hard
stop failure that we can't recover from
because for example the histogram that
we were we were storing sensor log
readings into is corrupted one of the
bins got unlinked and so now what are we
going to do we have we have no way of
recovering the value so if we look at
one benchmark like an activity
recognition benchmark that takes
accelerometer readings and decides using
a nearest neighbor classifier whether
you're having a tremor which is kind of
a medical condition that we could
identify pretty easily this is a
wearable medical advice medical device
kind of application then we can see how
much air do we really get if we're
running at say ten centimeters or 20
centimeters pretty close to the to the
power source this is a radio frequency
power source and these distances are
fairly short because we wanted high
fidelity in the experiments without
having to do 26 gazillion measurements
as you go further away the variance
becomes higher in the measurement so
we've had anymore so we went out to 60
centimeters which is not kind of notably
far but we saw that even out there we
had edging toward ten percent error in
our measurements and that's pretty close
so if we want to use this device in a
real environment where say we have
instrumented rooms in a hospital with
RFID readers where we're going to be
going in and out of range say 10 to 20
meters of these things we're really
going to have to improve the fidelity of
this because the error seems to scale
maybe with diminishing a diminishing
trend toward higher error at higher
distance suppose that I have that exact
scenario where I'm in a hospital and one
question is are the errors uncorrelated
because you could imagine having two
devices for instance if the air is
aren't correlated if it's really a
particularly like a kind of a blip in
the air right a you know then the
probability that actually both devices
for instance have an error when I enter
a room goes down exponentially that's a
good idea I think we should probably do
that doing using the issue is going to
be but it depends on the correlation of
the air it depends on the like I'm kind
of asking about the error quarterly so I
don't know if there is a rural
I suspect part of me wants to say yes
because you'll have more errors if you
have more failures and so if you're
further away from a power supply you're
going to be dropping out more frequently
so that means that both systems are more
likely to be failing and so they're more
likely to have errors but then on the
other hand it's a function of the
software and so we don't know they might
not be in the same place they might be
just out of phase enough maybe this one
I mean it could also be a function of
the hardware maybe you use different
memory technology in one device than the
other try and be more robust an issue
that I see it implement this kind of
system is that you have a distributed
system now and if their computing the
same value they need to agree on which
value they computed or you need to build
your application in a restricted way so
that they can produce an arbitrary
stream of values and you know that
whatever the streams are that the two
devices compute you can put them
together and make something sensible
that your application cares about in
either case I think there's some
distributed systems coordination stuff I
mean you're not going to run paxos on
these things just because there's not
enough energy to you know take
checkpoints so good luck with paxos but
I think you would have to do some
coordination stuff they can communicate
they could actually communicate with one
another and that might be a one way out
of this cool so with our system sadhana
nowhere that's because we eliminated by
construction so the point here is that
we can compile programs differently and
get better reliability guarantees for
these inherently unreliable devices
that's the punchline we eliminate the
error because we'd compile the program
differently and put runtime support in
to prevent these things from happening
ok so now I'm going to switch sir just
something much as cost so because i
don't have in the slides but in the
application we were just looking at it's
hard to measure the overhead but it's
about 2x on 2x slow down on the baseline
implementation with the caveat that the
baseline implementation is incorrect so
it takes it takes about twice as long to
complete the computation and that's not
just because we add more cycles to each
loop but because if you arrive at a task
boundary and you're at you know your
buckets half full you have to do more
work and so you're more likely to fail
and then you have to go back to the
beginning of the task and spend a
quarter of your bucket to repopulate the
memory and then you can complete the
task that you were doing so it's not
just the additional work of /
ask overhead it's the additional work of
wasted work in failing in tasks that you
wouldn't have otherwise failed and so
that's why it's 2x that's why it's it to
me this is a surprisingly high overhead
number for kind of sparse checkpointing
because we're manually placing
checkpoints the checkpoints can be as
sparse as we want them to be so that's
why it's too XO is because we have not
just more work / task but because we
have more failed tasks so this is I'm
not sure my question is fully formed yet
but I'll try it so you you kind of made
this comment that checkpointing is where
you you guys want to move away from it
because you have this very concrete
example of accessing an array that's
billion a billion elements it seems like
that's a from your programming model is
very low level like your seat right and
so you you know you one thing you could
think about is a set of abstractions
where you still allowed to have
checkpointing but you've put the right
kind of kind of you know data structures
80 of whatever whatever those things are
that let people do certain class of
operations easily where you can still be
amenable to checkpoint so I part of the
question I guess to kind of come back
the question is how do you thought more
like about permanent abstractions that
help people do this type of work as
opposed to you yes maybe that's like
stealing the rest of the Thunder so I no
no it's not the rest of this talk is
actually a talk that I three months from
now I'll be giving that soccers okay um
but yeah the basic idea is that we can
we can do it's sort of like decomposing
decomposing checkpoints into the
individual memory locations that we want
to be accessing and if we force the
programmer to adhere to a discipline in
the way that they use their non-volatile
memory then we can eliminate the need
for checkpointing but still have item
potent task restart and so we can talk
more about this offline it's basically
roughly what you said except that we're
not using any kind of ATT abstraction
it's more of a kind of general you can
think of it like as a kind of key value
store abstraction and then working
forward from that you can do arbitrary
computation build up arbitrary data
structures yeah the task abstraction is
pretty similar though that's that's
roughly the same it's a little bit
different but it's roughly the same yeah
cool so if we want to debug these things
we have all these weird bugs we need to
change the game a little bit and I'll
show you
we need to change the game a little bit
debugging is a particularly hard problem
because the intermittent behavior that
we're seeing not only causes
conventional software's like we're
already fairly familiar with but it also
can lead to kind of the hardware
misbehaving in ways that are apparently
invisible and so both of these are
problematic I'm focusing on software
here but I wanted to mention that there
are also there's the possibility for the
hardware to go wonky too so debugging is
something we need to be paying a lot of
attention to going forward ok so i
showed you before how we can get
intermittence bugs and these can lead to
application errors like if we have 11
then this is obviously a problem we
don't want 11 entries in our 10 entry
buffer and we note that this failure
only manifests when we're running on
intermittently available energy when we
running an intermittent power so if we
have the radiofrequency harvester
pointed at that device we're going to
get this bug manifesting when we have a
reboot here halfway through our loop and
then we start again and we execute and
we increment ok now we're at 11 now we
have this problem so we don't want this
to happen because this doesn't
correspond to any continuously powered
execution our group is approaching this
set of problems with that as a
correctness definition so when I say
we're debugging we're trying to move
toward a more correct program we want to
permit behaviors that are permitted in
continuously powered executions this is
a reasonable definition of correctness
that we're pushing towards so what do we
need to understand why this bug happens
and how we can fix it what we need is to
look at how the energy is changing like
on this curve that I showed you before
and what's going on in the program at
each of those points when the energy is
changing so here we have size
incrementally buff incremented and then
we had a failure on that curve and we
saw when I showed you the example and
explained it we saw why that was
happening but if you're just writing an
application and one out of every ten
thousand executions fails good luck
figuring out that this what's happening
you have events a B and C on the
downward slope of your discharge curve
then you restart and you have a and B
again and that leaves you with a corrupt
state this is difficult to reason about
because we don't have any visibility
into the device we want to be able to
answer the question what was happening
when that weird thing happened and we
saw our application produce the wrong
value what was going on inside the
device so the problem with trying to
diagnose this type of failure is that
typically we're in this kind of cartoon
set up you attach a big chunky plastic
box to a power supply like a USB port
and you attach the other end to your
target device you have visibility into
your device this is great you can do
jtag debugging you can get all the logic
bugs out of your program but you're
providing power so your discharge curve
looks like this you're at full full
voltage the whole time this great out
part never happens you never see the the
bathtub of kind of you know discharging
and then recharging again so we'll never
get ten you can run it as many times as
you want to you're only ever going to
see ten so that's a real drag we can see
the failure behavior run on intermittent
energy but not be able to look inside
the device and use jtag or use any kind
of debugging console or we can power the
device and we can look at all the
registers and everything as the things
executing that doesn't help us very much
because we'll never see the failure this
is the problem that we have this problem
is called the energy interference
problem and no devices that are on the
market today or from research solves
this addresses this Oh couldn't you just
again taking the idea that this is an
instance of a concurrency related bug
use congratulated tools in an emulator
so for instance I could imagine is their
outer either side use an emulator so the
emulator is the problem here you'd have
to be able to model the behavior that is
causing your bug in the emulator we
notice I mean you could just a peck of
it everything okay fine but it's a
non-trivial mapping I accredit but you
could imagine maybe you could say
something like you know you remember you
know you have a maybe I can take this on
five because I'm not sure I advancement
that's my question but though but the
point is that it seemed like you could
come up with a leader leaving for
instance of an execution of a concurrent
execution that gives you a value of 11
for your se but if you actually change
things to be mobile go lower yeah that's
interesting we actually had a shortlist
project that you can follow up on which
is essentially simulating arbitrarily
timed power failures and hoping that a
single power failure
leads to the corruption that we're
looking for we found that while
sometimes it is in other cases we needed
multiple power failures to get something
really bad to happen otherwise we
wouldn't end up getting the wrong value
package in your control it's baggage
it's one of these implicitly defined
back at you so we could go in and
instrument the program and to add that
back end yeah let's go together and
build that thing now yeah we need the
you know we need the hands that's what
we need so yeah that's a that's a good
idea and the connection that concurrency
is deep like i said in the peel the I
paper we kind of identified this and you
can use the same kind of you know
theoretical framework for reasoning
about this data races in particular or a
nice way of thinking about it yeah so
then here we can also use logging
logging is great if we have an
intermittent and executing system like
this then we want to understand what the
behavior was we could you know maybe log
the energy periodically or we could like
blink and LED or something I mean the
peripherals that we have are pretty
limited printf we could implement over
like a UART and that's great but all of
these things cost energy and so we're
effectively changing the discharge curve
by putting this stuff in its it's an
observer effect and in some cases it's
pretty rough if you want a blinking LED
when you have some condition like maybe
you blink your LED when you're adding an
element to the list and you want to see
and then and then maybe you're blinking
another LED when you get down to one
point eight volts so you know when
you're about to die if you can see
really fast when those LEDs are blinking
at the same time that might be when your
failure condition happens so think about
that as your kind of optimistic
hopefully this works kind of debugging
mobile this is actually what people do
people do things like this when they
drink an embedded development and it
gives you a situation like this though
where you're killing the device by doing
a log and trying to put trying to blink
the LED so even if that would work
you're changing the system's behavior
and you get this energy interference gap
where the behavior that you're looking
at is different by some constant amount
of energy from the behavior that you are
trying to investigate so you may mask
that there's also the problem that you
need to know more or less what you're
looking for in order to log it and try
and find it it's the same as doing any
kind of tracing printf based debugging
so this is pretty bleak this isn't the
way forward this is a stopgap at best if
you can make it work if you can find
some signals to get off your board you
can use an oscilloscope
that's a nice idea I just sent a
proposal for one of these and it came
out to about twenty nine thousand
dollars including all the probes if you
want digital probes to grab a few
signals coming out you want to look at
energy by the way the correlation
between what your program is doing and
what the energy is doing is totally
invisible to the oscilloscope because
you can't probe the internal logic of
your microcontroller so if you want to
get a good measurement of what the
energy is you can do that with the
oscilloscope this isn't the way forward
either maybe combining the oscilloscope
and logging and doing logging while you
have an oscilloscope trace that's that's
how we developed what I'm about to tell
you about and I can tell you from that
experience that that's extremely
difficult and time-consuming and it
wastes a lot of time with false starts
because the instruments begin to lie to
you after a while so it's it's hard to
debug these things oscilloscope logging
direct measurement none of these works
so we developed a new thing which is
called EDB this is the energy
interference-free debugger and this does
the things that I described us wanting
before we can correlate program events
and failures and certain value
conditions being satisfied and certain
energy conditions being satisfied with
the energy behavior of the system the
device that we designed I have one right
here it's real Hardware we built this in
my lab we laid out the board an
undergrad actually did a really awesome
job laying out the board I was impressed
it can not just monitor the program
state and the energy state it can also
manipulate the program state and the
energy state and we support all the kind
of conventional familiar debugging
operations like assertions and break
points on values or energy inner we have
an interactive shell we like a Python
library with interactive shell so it's
really easy to use we've kind of tried
to make it as simple as possible so that
you can really debug these energy
harvesting devices in the same way that
you debug normal embedded systems so as
for monitoring we have access to all of
the program state we implemented a
little a thin client runtime layer that
we can ask questions of and then it
sends us values back and we can read the
target energy level which is nice
because then we can correlate those
points in the program that I just
described identifying using that client
runtime layer with der
measurements of the capacitor on the
device we can read I 0 msgs we can
actually decode things as they go by
through the i/o layer by capturing on
this board and then proxying the
communications out so we intercept and
then forward is one way of doing it or
we can passively just monitor the
communications as they go by so we can
grab I oh we can grab program state we
can grab energy and this is all passive
and it's all energy interference-free
I'll tell you some numbers at the end
but I think here we were like nano amps
of current and so if you think about two
ish volts this is a negligible amount of
power this is an amount power that
doesn't make any difference over the
long term just like why it's so cheap
look what what does that in before it
make it cheaper than then long Aquinas
said why is it so cheap why is what's of
shoot why is the ARIMA target energy
level and like reading program state
boys that's G cause what all we're doing
is using the ADC on this board and we
don't need to use the agency on the
target board if we connect wires at the
right place and so that's why there's
this six pin head around the bottom here
if we pop this on to the header that we
designed to fit onto in our case we
target at the wisp 5 because it's kind
of the most mature platform that's out
there right now then the pins that we
connect to their power read a power they
expose the power over a couple of lines
then we can read them oh yeah yeah so
this is us before would normally be
plugin i should have mentioned that yeah
we're continuously powered so we don't
get any interruptions so we have a
continuous you know you are connection
to a python console we can give commands
all the time and then this thing is
blinking on and off like it normally
would be in a thousand times a second or
something and we can reliably get state
out now say we want to do some more
expensive monitoring actions than just
reading the energy level or reading
target io or you know hitting a
breakpoint or something to do that we
need to be a little bit more
sophisticated we need to be able to
manipulate the energy level and what we
do is we lie to the target about what
was happening we can charge up to
compensate for energy that the target
uses doing debugging operations so if
there's a whole bunch of kind of ad hoc
breakpoint like debugging operations we
assess how much energy that took and we
can top up the capacitor
if we want to go into an interactive
debugging mode we can just power the
device record what the energy level was
power the device and then go into you
know arbitrary debugging activity and
then reset the energy level to what it
was before we went into debug mode and
we've implemented all that and we can
get again it's a variation of kind of I
think two to four percent of our
capacitor is all all we kind of we the
area that we insert in the energy level
device so if you're operating and you
want realistic conditions were within
two to four percent so I'm nearing the
end of my talk here but there's a couple
of slides that I think are cool examples
of how you can use energy
interference-free debugging support so
say we have a program we want to insert
elements into a list and then we want to
do an expensive check to make sure that
the list is consistent so like each
elements next next pointers previous
pointers points to the element itself
this is a pretty simple list consistency
check well if we do that we might see so
these awful awfully colored Magenta's
circles correspond to the consistency
check happening if we have one element
in the list then maybe we do some main
loop work after we do the check for the
one element that's easy but then later
we had two checks here with two elements
in the list and then three checks here
and then we kill the device now we're
not making any progress in the main loop
because the assertion is toasting us so
if you want this kind of either beta
test or development time assertion
checking support to make sure your
program logic is correct you can't use
it the check itself is what's going to
kill you so instead what we did is we
use ed B's ability to manipulate the
energy level of the device continuously
power it then reset the energy level to
what it would have been and then do the
main loop work and so by running it on
continuous power we can make forward
progress under realistic conditions
despite the fact that we're doing these
invasive checks so the last thing is
we've integrated ed be with other
hardware so Tom mentioned earlier that
we're launching a satellite so the
satellite on one side has an application
processor that has a magnetometer and
gyro we're going to send this into space
it's going to orbit the earth at 6,000
miles per hour and collect a bunch of
radio measurements but then on the other
side
we have this essentially and this is
going to be operating as a beta test
diagnostics collection platform so that
we can monitor the behavior of the
system wallets winging around in space
under conditions that you can really
only get if you integrate this hardware
with your application and run under
realistic conditions it's not even like
we can emulate this in the lab I mean
we're going to be in space just going to
be all sorts of wacky errors there's
going to be all sorts of intermittently
available energy as this thing is
tumbling and not in view of the Sun so
by integrating this together we have a
reliable test framework and we can do
this kind of realistic beta testing and
get useful information to help us fix
our application if it's not doing quite
we want so really excited about the
Space Launch March 23rd is when we're
going to send it up yeah we already
shipped to the launch company so
assuming everything goes well and
there's no surprises along the way we
should be yeah in this guy at the end of
March so cool I don't know I can still
send her out a link I'll center on a
link for sure so yeah that's that's
pretty much what I want to talk about
today I want to give you guys an idea
about what an intermittent execution is
and why it's tough to reason about I
showed you that we have some system
support for making unreliable executions
reliable despite the intermittence and I
hope that I convinced you that debugging
intermittent devices is hard and that
this is a good way to do it and I have
these available if you guys think you'll
be using intermittently executing
hardware I can send you some devices to
we have a big bag in my lab so cool any
other questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>