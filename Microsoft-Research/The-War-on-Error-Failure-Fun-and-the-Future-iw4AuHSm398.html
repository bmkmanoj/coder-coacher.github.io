<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The War on Error: Failure, Fun, and the Future | Coder Coacher - Coaching Coders</title><meta content="The War on Error: Failure, Fun, and the Future - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The War on Error: Failure, Fun, and the Future</b></h2><h5 class="post__date">2012-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iw4AuHSm398" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Andrew Blake great keynote there to get
us going so we're gonna have a bit of a
chit chat now and meet actually a number
of the characters that appeared there in
in Andrews keynote first of all them
Andy Gordon whose face we saw right at
the beginning of that address I don't
know if indeed wants to come and take up
you any pew here okay as he takes his
place too young you probably all know
him but he said principal researcher
also holds a chair in computer security
and is a member of the foundations of
computer science lab at the University
of Edinburgh School of Informatics so
he's going to be in conversation with
with jasmine as Mel's yeah Jasmine
Fisher he's also going to come and sit
right next to him Jasmine's researcher
and affiliated lecturer in the Cambridge
systems biology center and also the
department of biochemistry at Cambridge
and completing the threesome is going to
start going to start a new seat here as
well Byron Kirk principal researcher
will say a professor of computer science
at Queen Mary University of London and
they're going to be in conversation with
with Peter showing that Queen Mary
University of London are out in force
here today that's so where Peter is a
professor of computer science and he is
now going to host the next stage of our
event a favor to you Peter thank you so
um so I'm going to have a chat with
these folks here and the subject is we
see is called war on terror so let me
just say a few words about the subject
area before we get started so the area
is called software called verification
and some of its software verification
now this area is important and becoming
more important as computers are used
more and more in our daily lives just
because computers have flaws and very
often you you hear about the importance
of cybersecurity and things like this
and difficulties in cybersecurity often
come to
two flaws in the software so it's
important but also as a research area
for the researchers to be interested in
it it has to have depth and it has to
have difficulty and hold a certain
fascination in this area really has that
the difficulty can be traced back to the
fundamental results in the 1930s at the
birth of computing results by girdle and
touring and church showing that certain
problems couldn't be solved by computer
programs so saw verification is has
squarely has to has to square up to
these sorts of problems now that makes
it sound very difficult to approach the
verification problem and yet there's
been a tremendous amount of research
over the years a lot of it has flowed
from research of sir tony hoare who is
now in here in the lab work that he
started in the 1960s and has done
throughout his career you might say the
idea that a computer program can prove
another computer program we might call
that whores dream and it's so difficult
because of the unsolvable ax t results
of the 1930s that you might worry that
well it's it might turn into whores
nightmare because it's so difficult but
in fact in the last 10 to 15 years we've
seen tremendous strides in practical
computer science many of them coming
from Microsoft on this problem and so
with that as backdrop I'm going to now
ask some of the key figures who've made
these advances how they've done it and
their view of the subject as its
evolving so I'm going to begin gonna
begin with Andy so Andy Gordon as was
mentioned he was one of the early people
in the lab and he's invented several
important formalisms ambience spy
calculus and another one ambient logic
which has been very influential and he
got into verification early in the in
the Microsoft lab and so Andy would you
just offer a few words on the kinds of
programs you verify how you got into
verification sure and so on sure thanks
thanks Pete yeah so we've refocused on
the
the question of looking at cryptographic
software for example like internet
protocols or the kind of software that
runs on secure core processors that can
secure banking transactions now these
are as Pete says you've got to have a
passion about the intellectual questions
and and these protocols turn out to be
incredibly subtle to get right I mean
you can have those famous examples of
like five line programs in this area
that were used for a long time in line
sort of 15 years later you know
devastating flaws were discovered in
them so it's very hard to get these
things right so I've worked with my my
colleague selling phony here and with
the the team at the Microsoft inria
Research Center in Paris to build what I
think we could say our world-leading
tools for verifying the actual
implementation code or crypt of software
I mean notorious problem you have is
that people build tools and could verify
abstract specifications of protocols and
then it turns out that the code you
actually ship has got bugs in it that
we're different you know there's a
mismatch between the spec and the actual
implementation so our goal has been to
like verify the actual code proof
security properties of that and we've
built one tool that works on reference
implementations are in an f-sharp that
Andrew mentioned and we've we've done
some big reference implementations of of
standard Internet protocols and found
some glitches in them and more recently
we've been looking at at see software it
turns out that most of crypto protocols
are actually written in C and so we've
been working with students on building
tools now that publishing it at
conferences this year that can verify at
these small protocols and we haven't
been able yet to scale it up to really
big production protocols but we're very
confident and we'll go there and it's a
nice area to work on because we can we
can make a lot of work in lot of
advances in collaboration with
universities and publishing research
conferences but at the same time
cryptographic aspects touch a lot of
Microsoft products so along the way we
found lots of bugs and Microsoft
products and in specs and ship some code
and to help prevent these kind of errors
so it's been a lot of fun great thanks
Andy so I'm so next Jasmine Fisher has
worked on well not exactly programs
remember they
programs doesn't works in I'm
computational biology and she's done
she's bringing verification to bear and
she's also making her own models and she
has a neat phrase she's going to called
executable biology so Microsoft's a
software company it might not seem you
know immediate that they're going to be
working on biology but with the broad
kind of point of view you've got a
Microsoft Research you've got spokes
going off into variously these others
areas and very excitable exciting things
are happening in the meeting point
between computing and biology these days
so Jasmine how about a few words on your
work okay so i think the the main idea
is that we're trying to use form of
reification methods just like we are
greetings we're using a this kind of
method to try and figure out whether
certain mechanisms hypothetical
mechanisms and voucher and did
consistently what we actually find in in
in the lab so we try to automatically
verify that indeed these are consistent
and by doing that we gain new insight
into these biological systems and this
is obviously something that saves a lot
of this directs the next experiment and
highlight what are the next experiments
that need to be done and verified
experimentally so it's obviously saves a
lot of time and resources this is on the
one hand on the other hand when we are
using these kinds of verification as
like model checking we can we can also a
query the system we can check whether
specific properties hold for those
system only in when we're talking about
software we are checking whether we
would like to see whether we can prove
or disprove the certain property holds
for all executions in biology we're
talking about different kind of
properties we're talking about more of
the features of the system like levels
of
proteins and genes and cell signaling so
we are I think the the point being as if
we're trying to look into the probe into
the cells machinery and figure out
what's the program of life so to speak I
think it's very powerful okay so our
third or third panel member beside me is
Byron cooked and Byron has worked on
he's worked on the static driver
verifier when he was in redmond which is
very prominent tool and he's works now
in cambridge he founded the terminator
project the terminator project it
attacks there's one of the fundamental
problems of the 1930s is called the
halting problem can you write a program
that tells whether another program halts
on all inputs and this is touring showed
and in the very beginning of computer
sites that this wasn't soluble and yet
Byron cook here is attacking that
problem him and many colleagues so Byron
would you tell us about some of your
work there sure so what we've been
trying to do is dead I mean we know that
the halting problem and also actually
just the question of asking properties
of infinite state systems is undecidable
so what we've tried to do is to
characterize certain kinds of programs
and maybe we can do do something with so
we've looked at device drivers bits of
aircraft software software that's used
like in things like Mars rover or things
like that's a very low level bits of
code and then we're and then we're
trying to develop more general
techniques that that can automatically
approve properties of those classes and
programs and with a particular focus on
programs that manipulate the heap and
and the programs where we're asking they
may be running forever and we're going
to try and ask questions about what
kinds of things they will eventually do
thank you so um so you see there's the
word failure up here in the sub in the
subtitle um I think this goes back to
the so when Needham founded the Latin
told he wanted to front fender lab where
people worked on difficult difficult
enough problems where sometimes they
failed or else you're not working on
difficult enough problems so now maybe
we can put our panelists on the spot a
little bit Andy have you got any
prominent failures to tell us about
maybe maybe so yes I was on the first
guys in the lab and yeah Roger certainly
was encouraging us to take some risks
and I've been told if all his projects
exceeded that he'd failed so you know
Tony hora was a consultant and he went
out to redmond and came back with his
quote from bill gates that really was
confrontational for me because I'd been
an academic and I'd be used to you know
the whole doctrine of having a sort of
formal specification that you would then
turn into cold and Gates had said one
document one it's the source you learn
everything there and you know everything
there so what he's saying is that you
know as far as any interviewing since
own you know the source is really what
matters you know forget in each sort of
formal specs or or all that sort of
stuff so you know I then so we felt put
on the spot so we thought let's see what
we can do so there was a the so
Microsoft was working on this net
runtime and eventually got released in
two thousand don't have this and bike
word verifier that was critical to the
security of it and effectively it was a
fantasy type systems to be thought why
don't we sort of build some tools to
look at the source of this and you know
verify that it's entirely secure and
therefore there won't be any sort of
viruses that they can attack dotnet so I
barely male to speak this is about this
in public because you know it just we
toiled away you know we felt you know
sort of gone ahead you know to get this
thing proved and we didn't manage it I
mean the end we got a pop-up paper which
which is the nice sort of consolation
because that's kind of religious but you
know in reality we really wanted to be
able to verify the code but in the end
we we gave up I mean on the other hand
you know it got bill gates of Roger
Needham's back so you know it's never a
bad thing to do your boss a favor and at
the same time Don got really deeply
involved on eight people and that led to
his doing generics and then eventually
led on to F sharp and at the same time
we also i mean you know
it was a failure but it was also a
success so we we got with the end with
people who donate forks and with
security folks in the company and then
they started coming to us and hey we
persevered from source code and you know
eventually built these tools i mentioned
that can can analyze you know see how an
f shot for vulnerabilities so okay now
when i was a graduate student i remember
reading a phrase where computer programs
are mostly amongst the most complicated
things we've ever seen and that's why
they're so difficult to get right yet
maybe their complexity might be divorced
by um biology and so i don't know if a
few failures to tell us about jasmine
given this simplexity you know jasmine
never fails okay given this complexity
and how do you do it how do you approach
this problem well i agree with you that
most most often is the case that they
need biological system are more complex
than any man-made system but a more
complex more reactive in nature but you
have to remember that the whole
motivation and goal to do these kinds of
of modeling and analysis and in biology
is different than in engineering so if
the grand challenge in engineering is to
eventually verify the whole system or
the whole program we we don't even we're
not there yet in a sense that we don't
have a whole organism model yet we don't
have a whole were more whole fly so we
can only look on very specific pieces of
the system and choose manually what is
the level of abstraction that it would
like to look at and by doing that in
such a small scale so we bypass the
complexity by looking on smaller pieces
and so far it's been very successful
because from from our perspective from
the biology perspective the minute that
we increase the knowledge that we had of
the system before we did them only work
we got something something new and so
far it's been working very well what's
what size of oregon has an organisms or
portions of organisms could you
accurately model now so
now we're dealing with it depends on the
system so in some of the system we're
focusing just on six or seven cells in
an organism has about 1,000 which is
just one system of the whole organism
but in other system where we're looking
more on that on the tissue level we can
go up to a few thousands of cells and we
have some of our tools actually scale to
that amount of cells so it's it's pretty
what's the analogy with error comes a
computer bug what's the analogy for you
in here so i would say that we are sort
of looking for the for the bugs in these
cell programs so we would like to know
how do we get these errors because if
everything goes it goes normal and
everything is fine that everything is
under control the problem is that new
disease we have these kinds of bugs in
the in the cells program and the whole
idea of these executable models and
analysis is to try to create these
computational model that mimic aspects
of the behaviors that cells are actually
executing so if you can find those bugs
we can basically identify what are the
errors in the execution of the program
going in the direction of the disease
versus a normal development for example
okay now Byron so you have the temerity
to take off take on the halting problem
so we're speaking of failure now so and
since we're thinking Byron you must be
doomed to failure right so first of all
do you agree with me that you're doing
Stu failure and second of all whatever
your answer is how do you deal with it
emotionally why did I don't accept
failure Peter yeah i mean it is it is
doomed to fail so i mean if you look at
my research goals to build a tool that
can prove termination of any given
program and clearly i won't be able to
do that so I mean technically what
I've done is I've changed the game a
little bit so it's acceptable acceptable
for my tool to say yes the program
terminates no it doesn't terminate or I
don't know yeah so I mean one way to
solve that problem should be to make a
tool that just always says I don't know
and that the game is to make that
threshold higher higher and so so I mean
there have been many failures in the
sense that when we first felt we set out
as a goal to build the termination
proved they could prove termination of
Windows device drivers and in the early
days of the that project it failed in
the sense that if the program used heap
at all they would fail if the program
had concurrent execution it would fail
and if it used a low-level bit masking
it would fail and that actually is every
device driver right so so we could build
a few specialized device drivers didn't
actually exist so that we could say we
had done something and but then for from
there each for each of those problems
then that led to the new research
question so basically every time I fail
then that becomes the new thing to solve
and that's that's where we go from that
so it'll it'll never end so does this
experience does this experience where
you're having some success in the face
of unsolvable problems do you think we
have the right notions of unsolvable
problems these are some rethinking to do
the Arizona so I think it's like as a
community if you look at the big
advances like an program automatic
program verification or automatic form
of clarification there are the
rethinking in our community of MP versus
p and undecidability so nowadays
effectively p is equal to NP it doesn't
matter that maybe they're not
technically equal to NP but effectively
there's the same and that actually is
undoing a lot of education that you see
in computer science it's a lot of people
with with deep computer science
backgrounds have a way of thinking that
really needs to be undone so you need to
think of P is P as effectively equal to
MP or undecidable problems as
effectively decidable okay
look forward to understanding that the
new capability theory okay so now we're
going to turn to the future where these
folks see research and verification in
particular their own kind of research
going maybe they'll paint a little bit
of a picture for us so again we'll begin
with you Andy in verification general or
it's related to security how do you say
things going I see two challenges one is
is quite theoretical other is quite
quite practical so on on a theoretical
side in a theory of crypto software
there's actually a bit of a divide
between what the cryptographers who are
mathematicians see as what needs to be
proved and on the other side what the
computer scientists the formal methods
people like me are currently able to
prove so we're really sort of two
different communities but just recently
we're starting to come together so a
challenge would be to take the will be
able to build like verify permutations
of some substantial internet protocols
that are actually verified against the
mathematics that the the control group
is use so there's a paper that makes
nice advanced to that at the crypto
conference in chicago press conference
this year by joe bart and him as an l
a-- so it's santiago zanella and we're
very happy to have him coming as a
postdoc we managed to recruit him so
hoping to make some progress on that and
very beefy on the practical side and
they think it's happening the moment is
is is web applications and they're being
standardized and you no html5 and
JavaScript I like that they're allowed a
core of the web they're going to be
really important for windows 8
applications and I think what we're
seeing a next few years is people from
our research community building tools
for reasoning about such web
applications and we're quite confident
that the softer the verification
techniques that we have for our short
programs could be adapted to JavaScript
eventually to be able to do proofs about
the web platform and and show web
applications secure hey jasmin same
question to you what about the future
well I'm not a former member of
software or education community more of
a guest it kind of came to visit eight
years ago and never left but thank you
from from more of a biologist
perspective I think that there are two
main challenges in that realm of things
so one thing would be that that we
really need to create these tools and
means for biologists to do these kinds
of work so these means really user
friendly kind of tool biology's friendly
for non professional programmers that
will be able to do this on a daily base
in between the two integrate it into the
lab everyday lab work and on the more a
long term I think that this is part of
the this transition that biological
sciences is taking towards more of an
engineering kind of science and I think
this is what we call executable biology
we try to make the major challenges to
try and make this kind of new emerging
feeling more mainstream technique in in
ever logical and medical research and in
order for that to happen the first one
has to happens we need to provide the
tools and this is a major major
challenge I think okay bio and same
question to you so I mean there's always
the problem of scalability precision
running on concurrently are proving
concurrent programs I mean I promise
that P was equal to NP but we actually
have to make that so yeah but then I
think another thing that's come out and
my work with jasmine I've noticed is
that biologists have a really different
viewpoint on the tools when they're
usually when they use these sorts of
tools so in when applying our tools to
software strictly often the developer
just wants to know is there a bug or not
and please show me the book but but in
the application to biology actually it's
a biologist who's asking maybe deeper
questions say so they actually they
don't want just say yes or no answer
they want more information about
counter-examples when it's not true and
they want information about why
something is true when it's true so so
it's less of a yes or no sort of thing
and more analysis or
your information about the the system
that's being analyzed and I don't I
don't I mean I don't really know how to
do that very well for right now for jazz
museum that's in second area future work
so it's one of the amazing things that's
happened is where this verification
enterprise has gone from a lot of
fantastic pencil and paper work to these
folks are all now talking about tools
and I'm wondering about the relationship
between tools and the theory let me I
don't know if this is true but we would
with something like the following be a
good way to view research in the area
that we have the experimental method
usually we have that in science is the
tool and running it against things like
is that's an analog of the experiment
the tests are theory or how do you how
do you think of how to organize your
science as you do it if any of you want
to want to pipe up on an answer it's
okay well that's right i mean you find
you find examples of programs that don't
work and then try and build tools that
can can check them and i suppose in
principle you should go and find more
examples that independently and see
whether your tools work here instead we
try and do that i'm not sure if as the
community work completely perfect so i
guess you know verification is learning
a lot from building the tools and i can
well imagine Byron and Jasmine working
together not only are we applying
verification to biology I presume your
work you're learning a lot about
verification by that attempt I'm
learning a lot about biology yeah I
guess I guess that's a pretty good
result yeah doesn't it yeah one thing is
interesting is that the techniques that
you can use when trying to improve
absence of bugs and software and the
techniques you can use in the models
that come from biology actually quite
different so things you can never get
away with and normal software will
actually work in biology and vice versa
so that's that's quite interesting what
you see in our area through software
verification is there there now
competitions and there are multiple
tools being run against each other so
that's that's one way now that we're
sort of sharing results that's a little
bit different than just sharing ideas
and research papers okay so I think it's
time to draw the panel to a close so we
didn't didn't want to finish on with any
on any big note rather we wanted to show
how the area of software verification it
has importance and growing importance
but it's a deep area and it's an area
where there's lots of fascinating things
going on as illustrated by the comments
from my colleagues here on the panel so
well thank you for listening cheers guys
fascinating stuff Sarah Peter oh here
and there with Andy Gordon Jasmine
Fisher and Byron cook so there's a
really nice kind of flow through the
through the concepts</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>