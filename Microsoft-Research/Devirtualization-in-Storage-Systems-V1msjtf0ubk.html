<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>De-virtualization in Storage Systems | Coder Coacher - Coaching Coders</title><meta content="De-virtualization in Storage Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>De-virtualization in Storage Systems</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V1msjtf0ubk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
alright good morning everybody it's my
pleasure to welcome you Shang she is a
student with the Apache do shows at
Wisconsin and she's interviewing for a
postdoc position with the systems group
she's well decorated with several fast
papers and neuroses paper and she's
going to talk to us today about D
virtualization thank you for an
introduction and thank you for coming
for my talk I'm eating down from
Wisconsin Madison I'll be talking about
the authorization storage systems which
is the work I did with my PhD work so we
know that virtualization is a common
technique to transform physical
resources into an object form that can
be more more easily accessed and much
validation has been used in many systems
for example physical resources a further
coat membrane is virtualized into
virtual memory to provide that your
spaces for different processes and hard
disks its internal cylinders and
clatters are also hidden and virtualized
into the logical block interface and for
the flash base SSDs its internal
structures and regimes are also
virtualized and behind the same block
interface and we can see that
virtualization provides simplicity
flexibility and usually a uniform on
interface to different clients and to
realize virtualization the technique of
interaction is usually used by
referencing object with a different name
as in this example if you want to
virtualize object B to a we can add an
interaction from A to B with a mapping
table and this mapping table is used
widely in different systems like page
tables in virtual memory management
flash translation layer is for fresh
base SSDs and also remapping tables for
hard disks and also rate.rate
constructions
so we know that virtualization is good
but my question is have we taken in too
far that redundant levels of
virtualization is added in a single
system a problem we call excess
virtualization I think this example the
object a could have been directly map to
object C instead two levels of
modulation I did such access
virtualization helping many systems a
good example is when we run the noise on
top of a hypervisor another example is
when we run a file system on top of rate
or SSD so each will maintain their own
logical address mappings and in all
these examples and there's an
information redundancy because because
of our excess virtualization and imagine
now if we have a file system on top of
virtualized on sorry so but the real
problem is that there's a cost with
excess virtualization and first we need
mapping table at each virtualization
layer to start the mapping tables and
these are always usually starting main
memory or more costly device memory and
also there's a performance cost to
access and maintain the mapping tables
so we can see that excess virtualization
gets redundant and cost both memory and
performance and my question is is there
any way we can make systems work
together so that we can more compactly
represent the redundant information and
the technique we propose is d
virtualization which collapse multiple
levels of retardation I think this
example we claps the two levels of
validation and remove the mapping from B
to C and directly in back from A to C
and now inviting if we have a file
system on top of a virtualized device
and first we have a four-block we first
map from afar off there to lodge
gorgeous use a fast to take the
structure and then you from logical
address to a physical address use device
mapping and what we do is remove the
device level mapping and directly map
from fire offset to physical addresses
and so with this basic idea I first
begin my research with a simple
hypothesis that wasted right interface
we can remove the redundant
virtualization and with this hypothesis
I designed a new interface Corning with
right inglis right is like a normal
right but it only sends data and no name
or logical us to a device and then the
device will allocate a physical address
and returns to physical jest with the
file system and then the fastest or the
physical address and for future reads
and I implemented in English rights with
East III and then emulate emulated SSD
first but then I found that the English
rights change many aspects of the
software hardware than the interface so
I was curious to see if the an idea
still hold with the real hardware and
that build a hardware prototype on top
of our testing SSD board and then always
the hardware experience I found that
there are actually many problems with
the name is rights interface basically
because name is rights and is
fundamentally difficult to integrate
into the existing data interface and
with these ideas I am now building a new
tool called fascism d virtualizer which
then have the proper on complexity of
nameless rights and can still use the
existing io interface but what it does
is it can dynamically change file
pointers to point you physical addresses
so it will fit better for that number k
removing mapping mapping table space and
this is an ongoing work so i don't have
satisfying results to show you
and but overall we found that the
virtualization removed device Ram space
by 14 to fifty-four percent and also
improves random write performance by
twenty times x time sorry waiting to 40
victimized yes essentially scales us
from 14 kilobytes one kilobyte or 14 big
plans to one day bike I think it's from
maybe one gave it one GD to hear nothing
that it depends on your device size
actually and I also learned a set of
lessons in this experience first with
the right interface access
virtualization can be largely removed
but adding a new interface can be hard
and also it's even more difficult with
real hardware's but with a light world
tool on it can be done with more
flexibility so in the rest of my talk I
will first go over some background of
flash base sd's Saudi but the technique
of the visualization applies to
different types of storage devices but
SSD is a major you use case so I would
talk more about SSDs and then I will
talk about the new interface and the
software and hardware prototype of it
and then the new tool that I'm building
now and finally future work in
conclusion so I I know many of you
already know a lot about this design and
I apologize for more redundancy but i
will go try to go quick so SSD is a
device that provides a block interface
and inside SSD there's our controller
internal ram and a set of flash memories
and then within the flash memory it has
a set of erase box and each erase block
has a set of pages and each page is
associated with a out-of-band area which
starts things like valid bits and there
are three operations for flash memory
read write and erase and rewrite read
and reason rights happened add a
granularity
flash page which is usually 248 kb and
the property of flash memory that you
cannot write a flash page without
erasing it so for this example if you
want to write on to the first paper
first page without erasing the first
block erase block then there will be an
error and such erases happened at the
granularity of furious bug which is
usually on 256 21 mb and then are with
these erases fresh box where out and um
so with different access to different
blocks certain block may certain blocks
may die sooner than the others and to
prevent certain blocks from dying to see
the technique of we're doubling is used
to make new racist way out and similarly
and to virtualize SSD flash translation
layer our FTL is usually used to give
you up the block interface and to hide
the internal operations and it usually
use a mapping table to map from logical
us to physical address and such mapping
table is usually added at the device
room which is more costly in both
monetary and energy and for example for
one terabyte SSD you need when 16gb just
to store the mapping table if we map at
the 4 kb granularity so instead most
modern SSDs use a hybrid mapping
technique they map a lot of smoke area
of page mapped area and a large area of
block map area and now you have 1.8 gb
for one terabyte disk however there's a
performance cost because of garbage
collection for hybrid FTL and this is
the main reason for poor random read
performance in necessities so now
imagine if you have a file system on top
of SSD you first map from file of the
two logical choice and then formaggio
ideas to fill the gorgeous so and
there's a excess virtualization here and
what we do is we store philco dresses
directly in file system
and then remove them macking in the FTL
and doing so will reduce post a memory
space cost and performance overhead and
also one major thing that we want to
make sure you that device do you have
it's critical control of this hardware
like garbage collection and we're
leveling so now I will go to the new
interface nameless rights work and our
first go through the simulation results
in the major design so this is a major
architecture of thing with rights so you
first you need to report the file system
to nameless rights and then have a
nameless writing device and the
interface between them is named as a set
of nameless right interfaces so
basically with this is it returns the
physical address to the file system and
then fathoms toss it for future reads so
now I will talk more details about the
actual interface cutting this right I'll
show you with an example of how it works
so English Campo the orange block you
can think of it as a data block and blue
block you can think of it as an inode so
the inode plot points to the data block
and the file system wants to write the
orange data block so it sends only the
data to the SSD and no address and then
the situ writes it at physical address p
and then your tents feel about us p to
the file system the first item then
stores it in its i note and so for
linguist rights we also need a set of
other interfaces to work together for
example for reads now we need to use the
physical JS p to read the data block and
we call it physical read and also
because the english right is an
allocation process we also need the
allocation so we use free or trim
command for deallocation so the
interface that i just spoke of obvious
quite simple and naive but it has a set
of problems with the simple interface
first if we use nameless rights as the
only right interface then there will be
a performance cost and also for
um devices like flash-based SSDs they
need to move physical blocks and we need
a way to handle it and finally there's a
way of how we can find metal data
structures efficiently yep blocks is
that I thought that the point of this
interface is obvious how the ruling was
to be able to grab fresh and so on
we're lovely but if you're exposing
allocation of player why do you need to
still move along so one thing I like I
said we still on the device you can
choice we're leveling and garbage
collection so device internal it does
capture fashion and we're leveling but
whenever it does it changes to philco
edges so it needs to a file system to
know and the reason why we want the
device to maintain its can show you that
so one thing is that it can be dangerous
if yourself to a conscious hard work
directly and the other thing is we don't
think vendors will show up things that
they do they cannot guarantee four
underwears you said that if you use
nameless rights for everything also each
of these points in ten so to explain the
first problem of the overhead of
nameless rights I will use this simple
example so imagine without a small file
in the root directory and the data block
is pointed to it is I note which is
pointed to you by the root directory and
the file system wants to override orange
data block so what it does it sense only
the data to SSD SSD allocates physical
address p0 and returns p0 to it till
file system the fast intense toss it in
the inode and since the inode is changed
it also needs to write to the SSD so
again the SSD allocates p1 and attends
p1 to the file system and then the file
system stores both p 1 and the offset of
the inode within that block p1 together
to point to the inode and since the root
directory block has changed it also
needs to write it and the city right say
that phila cadres picchu so you can see
in this process there are several
problems so the first problem is that we
have overhead of recursive updates so
originally we only want to override
orange block and now we have three
rights and also we need to enforce the
ordering in this chain of recursive
updates and imagine if we have a long
directory chain so this can go up to n
rights another problem need that
this with only name is Right see the
fossil will become more complex so
originally the inode can be pointed to
by the inode number and now we need the
physical block address of the inode
block and the offset of the inode
withing that block together 2.2 dynode
and also we need a different technique
to unlock it through there to block so
to solve this yeah okay so the first
method you push this off um but um this
mean that assisting us to maintain free
list in other words if you delete a file
original file system you just delete the
metadata right and later you can rewrite
the same blocks but now it seems like a
system like to know which box already
yeah that's why we have to have that
free our trim command and not all
fascism or unsupported trim so we added
that trim our system so to solve the
first problem of recursive updates we
propose to a technique of segmented
address space so the first address space
is a physical address space where we use
nameless rights and physical reads and
the second address space instr a virtual
address space where we use traditional
reads and writes and also we need to
keep an interaction table for the
virtual address space we map all the
data data blocks to the physical address
space and all the metadata blocks to
virtual space and notice that melody
review is usually small around one
percent in the file system layout so
this mapping table for the virtual space
can also be small and now let me explain
how the segmented address space work so
we map all data box which is the
majority of file system to the physical
address space and all the metadata to
the wall charger space so for the
physical address space we send only data
to a device device air locates philco
addresses for them and then writes them
to their physical locations and after
that they return the physical address is
to do the file system and fascism keep
them and then for the virtual address
space we send both the data and their
logic addresses together on tutor SSD
and then the SSD ELO kate's video
address and keeps a mapping for them and
then write them to the field
patience so now let's revisit the same
problem same example so now we want to
overwrite the orange book and the
foursome sends the data to device device
I located p0 under-10s p0 to the file
system for the fascism updates di node
and now since they I know this in a
virtual address space we write on both
the inode block and logical block at
yourself at l1 together and to SSD and
then SSD will allocate a physical
address p 1 and then it will add a
mapping from a 1 to p 1 but now we don't
need to change it root directory block
because it always used I know number to
point to the inode so we can see that
now we only have one level of update
propagation and we we go from n rights
to two rights and with this design it's
all so simple and to implement and debug
and the second oh yes I should hear that
to rights not to the single rite of a
filesystem talking to the top the device
virtual interface
to rights of filesystem pocket like the
these two rights are two physical rights
kind of contrasted with the when you
have the stack Virgil other spaces there
things look like one right of the file
system became more than one right FTL is
that why to rights is not bad so this is
all rise of blocks below the file system
or what we want to do is an overwrite of
the orange block so and I not points to
orange block and there's a field like
change times in the inode so whenever
you modify a file that I know I note
with traditional fast money anyways it
needs to write I notice she writes all
right good yes step right right so I
didn't go back to the few guys one day I
noticed or just the block number if you
boys on the block number itself where
did you have hired just one way to the
previous cases room so they are not
usually it also has a field called
unchanged times so you need anyways
update that modified time and rich box
is a large file yeah I know
yeah for indoor aprox yes so if it's not
pointed directly by the inode so if it
has indirect blocks inside it then with
nameless rights you need to update the
drug up level of indoor blocks but with
traditional you don't need to update
that i know'd us or indirect blocks but
with xt3 we write all these metadata
with a journal so it can gather more
data blocks more metadata blocks
together but yes that that's a there's a
performance cost so the second problems
comes from the need for flash base SSDs
who migrated blocks physical blocks for
tasks like on we're leveling and now
show you why this can be a problem for
namath rights so now imagine the SSD you
wants to do a we're leveling and moves
the physical blocks from p1 to p2 after
it has been moved its old address can be
erased and then can be written with new
data yes because you want to needs to do
well Evelyn so basically you have
different right pattern two different
erase box and you have different ways
and so the SSD actually not actually
moving
which is happy the day no it is that's
what is good but don't just write it to
the same for the same one location after
it is when you create you could
potentially create an erase block write
the data to the same one location and
you have a lot of things when other
blocks can be stored the same location
will have the same red pattern so if
that block has keep the physical address
of the light blocks the scene and what
are godless blocks are there use those
holster filling in now 30 points so
there are two things one is garbage
capturing the other is we're leveling so
for we're leveling so imagine if you
have our data block that says Ben is
written very frequently so it's it has
hard data and if you move it to get
steal it has the hard data then it will
has it will as more and more ah erases
I'm confused about this because i
thought the interface of vehicles rights
is that you can't you can't make a hot
block because you can't say what the
file says we can't say i want right
there it says i would like to write
right and then the ssds is well you can
right over here so i don't understand
why the SSD you can't do where we're
leveling Ethel because just
good to read has a physical addresses so
it needs you need to update responses
the solution to the previous problem job
was to reintroduce illogical
translationally I was fine with it lost
and that me introduces heat since it's
just for metadata that this is just for
the virtual said that you said you cut
to Perdition see right there's no one in
the virtual one right this is just for
the virtual one is that right it's
whatever the device wants to do with
we're leveling so it does it doesn't
know what is better than what is data so
whatever it does is whenever whenever it
sees that block is written very
frequently then it will consider it as
hot block and then swap it with some
code block that's a basic idea is very
famous question which is hahaha is in
the data partition not a metadata
partition then the solution is just to
stop writing there when then when
another right comes down pick some one
o'clock right whenever right comes down
to a city will always pick another
another location but that's we hope that
SSD does but internally we don't like
make assumptions of whatever the SSD is
doing for their we're leveling but the
main point is whenever they do and they
need to do for at least for the metadata
part it's ready that this is an
autonomic process happening in the
background so asynchronously you have
data moving around as part of the whirl
of it and that's why it has to notify
asynchronously the pasta because the
fastener house in a knowledgeable
that has to get isn't usually up to it
yeah so basically after it moves i will
go to this now so after it moves the old
address will be written with new data
but the first one was using the oh this
block is at p1 so it will read p 1 and
then wrong data will be returned so
you're changing the face you're not
changing these is decent I mean also
changing the FTL but so the f you still
need to do wherever the end uses are we
don't change the technique of doing
we're leveling from traditional I said
as a tease so what it does it just when
it identifies a hot block it does this
were leveling and so that code data can
be written to this block so it needs to
move data around Megan's process is
happening all over yeah it's about what
you're good you're inventing a new SSD
that has a new interface whether you're
trying to use it moose or the modern
existing SS to you the interface needs
to be changed and that's as the fto also
needs to be changed but we don't like
particularly changed at least we haven't
changed we're learning algorithms so it
still use whatever it can still use to
whatever it did before so we're little
is triggered and from within the FTL yes
yes and you did modify the FTL or to
modify the air Petrak not modify that
aspect of the FTL right so the
suggestion the john man is something you
could have done what did not do right
right yeah
but sorry I go I can do this offline
maybe so whatever whenever it does so it
needs to inform the file system of this
Philco address change and the solution
we propose for this is to use a new
interface called migration call back so
now let's revisit the same example now
for SSD moves from p1 to p2 and after
it's been moved it will add a temporary
remapping entry to map from p1 to p2 and
now if the file system wants to read it
into a read p1 and which will be
remapped to key to and get it correct
data an SST also sends this information
back to the file system and the
background processing file system will
process these poor back entries and then
update the metadata to the new physical
address and after its being updated the
file system will send acknowledgement to
SSD and the nesa t can remove the
remapping table yes this anomaly was my
long story
how does it know where physical not I'll
go to this is a sleep problem so the
third problem is like you said we need
to add on locate their metadata that
needs to be changed and this can be can
be needed for callbacks and recovery
process and naively we can scan through
the whole file cinema to find the right
metadata but of course is too costly so
what we use is a simple solution and
what we call associated metadata and
it's operates like a back pointer so it
keeps information like I know number I
know generation number and offset so
with these information you can find on
the metadata so what it does is whenever
it fascism writes our data it also sends
the associated metadata to the block or
to a device and a device right sit in
fact sorry a decent location next to the
data page and this is the oob area and
whenever it does callbacks on recovery
it uses associated metadata to locate
that on the right metadata block did
that answer your question
so for every block you have some small
amount of extra storage so the OB area
is already there so it used to store
things like valid page it's within a
flash memory so it has a usually 128
bite area next to each 14 kb flash page
previously completely private to the
city SSD and you've now exposed yes and
I'll show you why how that can be a
problem but the s80 were right of the ov
but the Phantom needs to assume that
such a B can be written and also for
reliability reason a quelle go go over
this now so we'll make some further
doctrine for reliability reason so some
way of you may have already noticed that
there can be reliability issues within
this processing and the name is right on
process and what it it can happen is if
the crash happens during the migration
call back or before on metadata blog is
updated your you have increases metadata
and there's also other reliability
issues that i will go into in details
use sounds like you just declare every
book that was previously four pages now
for k plus a few bites
you've got this open of extra data on
the side
let's um funny interface comfortable
forces
but that that's a solution we have and
we will see that that OB area is already
there but and it's usually 128 bytes and
I think we use around 32 bytes something
like that oh and it's not already using
cross / page it's using in it but we are
hoping that they are not feel it but
that's a problem and that's a big
assumption that we make so I'm a flash
finger it sounds like you've suddenly
magic up to next year a few percent of
storage I never flash drive that we can
use for our own purposes I'm sure
they're putting it there putting that
storage say they're using it something p
cc's yeah yeah it's using for ECC and
valid bit but it has a larger space the
counter argument is that if this is the
if you're willing to seems this
interface then maybe you're willing to
change the shape of your rectangle ever
so slightly remove a couple rows matter
of calls make it well and south side so
it hypothetically couldn't the
filesystem just instead of using the
flashes private or at least or as
process and we just take the take the
device drop off some extra space that
it's not going to use to store bar box
and use that to store this
oh I found it part of the goal is to be
able to do it in continuous right so
basically when you read for like
callbacks and other things it can be if
you start it adjacent to the flash page
in or will be out of band area then you
can read them together and you only pay
one read otherwise you need to read to
flash pages but that's a big assumption
that we are making here yes and that's a
cost your device will pay yes miss any
of you will be currently used in service
to the FTL which then you wouldn't need
because you which you would need and you
could be first it's using it but at
least as far as I know um there it
doesn't use the fool 128 bytes and you
don't this part of the address spaces I
understand you're saying is not part of
debt it's not being remapped so maybe
you could use that bites the fingers for
very logical to physical mapping p for
eat them starters back yes but again you
are saying that you can we can start
back pointers with metadata the virtual
address space within that space I'll OB
area you're that know your suggest you
think I'm not i'll talk to you okay
so but for these reliability issues our
basic technique is again to rely on the
associate method order by pointers and
we can use these back pointers to
reconstruct metadata during a recovery
and also a side thing is that we can
also we also keep a time stamp which
also increases the OB requirement to
find the latest version and so and we
have two requirements here so major
requirement that we need to atomic Lee a
first that needs to be all be space for
us to write and then we need to atomic
later right or will be an area and a
flash page for reliability issues and
also this is something I won't go into
detail but if you're interested we have
a different garbage clashing method
which is better for reduce migration
callbacks but we need to use nvram
during this calculation colistin I can
talk more well when is with a one-on-one
and with our liability without sure that
we can recover all system crash your
cases and the recovery process is 0.4 26
seconds 4 4 4 gb SSD I implemented an
exe 3 on with name is rights and we used
Jonah Jonah order journal mode because
it's a wide why do you widely use jono
mode and also it fits name is right well
because it always writes a metadata
after a data and also we segmented are
we support the segmented at your space
different interfaces and migrating
callbacks and the total lines of code is
around 4300 and they are existing dc-3
TBD and general cows and you can see
that they are more invasive than at
least I already any sort yes did you
have a
both on their side you have you modified
SSD you're getting simulator I'll go
into that a couple slides so to put a
nameless right device to name is rights
it first needs to support all the
interfaces and also we allow the device
to choose any kinds of a location and a
specific device that i built and uses a
log log log structured like a locations
because it gives you more sequential
like right performance and also it needs
to maintain a small mapping table for
the virtual address space and remarking
table and also one thing we still let
SSD concho yes it's garbage collection
the world I want technique and I have
some optimization for these things and I
can talk more offline so what I built
first is a pseudo block device drive in
the next to emulate the name is right
device and it sits directly below the
file system and talks to the file system
with your name is Right interfaces and
it writes all the metadata and data in
Graham so it can emulate the performance
and I build three types of FTL's the
first FTL is page level ft 0 it's a log
structured a location so too will give
give you ideal performance but then real
estate instant wiping tables yet space
because it maps with each for kb a page
and the second left you I had is hybrid
fto which I try to model Rio SSDs and
finally I happening this writing or
writing this is so this is a the mapping
table space without that we have so we
used the impressions to generate typical
filesystem images and here i show 100 gb
and 1 terabyte filesystem images and the
mapping table sizing Hamby so we can see
that paid on the page level FTO uses a
lot of mapping table space and however
it has moderate mapping table size and
Nimbus has very trivial magnet oversized
and in fact we find that our numerous
rights uses 14 to 54 times smaller
mapping table than the hybrid mapping
which is models real hard
Rio SSDs and 122 for 65 times smaller
than page fto which you saw performance
upper bound the way I should think about
that savings is the terabyte of flash
would incur the cost of buying other two
gigs of RAM right and this makes that
was free so what portion have those
possibly do we just save ten percent or
five percent of the cost of the device
so the fixed cost is one thing and the
other cost is energy costs which is more
of a concern for the energy the Masters
I don't have exact number but i think a
lot of it goes to the realm and it's
especially true for our cell phone
mobile devices they consume more about
energies yes model with the market is a
desert
matic instances oh yeah yeah right I
know you wouldn't probably need the
entire market yeah yeah but then we need
to assume there's a small size of our
working set size and also you still need
the storage for the hope and being able
but that's maybe a lower cost so now I
will show you the performance results
and our first joy a sequential and
random write on performance in super
dinky Alps and here we can see that for
sequential writes all the three up tears
perform similarly and for random writes
hybrid is perform much worse than page
and nameless right yeah yeah although
all I build order 3ft also and research
facility is the scenario device slowing
down ram exorcist anemic yeah that's a
memory cells making it sorry too slow i
have a question on the previous oakley
result is
for the hybrid scheme where you're
splitting into the data region of the
metadata region isn't the savings and
then upon your workload this hybrid is
not an MS Wright hybrid they were less
right this what I propose for the name
was right I'm depending on the world if
I hope alls right minutes right that's
why we use this tool called impressions
it generates typical file system images
so I guess what I want to use if I was
gonna build an SSD yes Howie should I
make the mapping table do they have a
fix for this was you can have a fixed
mapping on Rams face and then whenever
it's going beyond that it will just go
to the normal fresh page paid out to the
normal flash page but you can typically
it's around one percent and exercise and
an SSD is already not that probably
today what property like they have a run
and now they have a fixed size they can
calculate for both page and hybrid it's
a fixed size mapping table space I'm
planning this right you've made the
performance properties of the device
I've Iowa
because today if I buy a device you know
has a certain random access time certain
green performance right performance but
in the future if we adopt this the
performance of my device depends upon
decatur I'm storing it if I'm storing
lots of big files or lots of little
files and i'm using the mapping table
more about patching in and out does that
make sense I mean that's a shirt from
certain point of your we're talking
about a cliff right when suddenly my
flash device start swapping my place
device that's walking because I put too
many loom Falls not enough big falls on
my phone but maybe another way to
honestly it it also also King said
thousand designers to have more smarter
technique to reduce them editor space
it's not it's not a bad thing
necessarily but it's another sitting in
proposals right so here um overall we
found that the English rights has 20
times random write throughput than
hybrid FTO and it's close to the Patriot
web tier which is the performance upper
bound and I also show you some macro
benchmark results and this is why Mayo
files open web server from the file
bench sweet i'm here i shall sue putting
mb per second and we can see that for
VAR mail and parcel hybrid is to image
worse than the other two ft us because
Miami and father has more have more
random writes and for web server it only
has less than four percent random right
so everything performed similarly so to
summarize on the name is rights are at
least ambulation part we find that on we
use a new interface for d virtualization
and it can reduce both mapping table
space cost and performance overhead and
now I'll go to the next piece of the
hardware prototype so as a researcher we
often evaluate our ideas with an
emulation or simulation at a more
conceptual level and this is fine
because it's a more conceptual level and
actually it's this is a most common case
for flash related research but if
imagine a few or someone wants to
actually build a thing
it can be more complicated so to
transform our ideas to reality we can
see there are many differences so first
real hardware is more complex and then
the real interface can be different and
even the software stack to the hardware
can be different and actually the
English rights change all these three
parts so it should be good to see if the
ideas you hold with real hardware and
there's a person myself I was also
curious and excited to build a real
Hardware prototype because I haven't
done this before so I had this testing
board SSD testing board what it has it
has a English barefoot arm a city
controller and their internal 64mb drm
and a set of flash chips and the
interface to host is not how to point or
interface and it also has a cover of
cereal part two for debugging so now
what we need to do is to transform
emulations to reality and so we can see
that reality is more complex than a
ambulation so below the file system
there's rock layers ghazaleh italian HDI
driver and then finally there's a SATA
interface to the SATA SSD device and
also in different layers there can be on
command queues and I all schedulers so
now what we need to do is to map the
name is writing to face to the whole OS
tag and also we need to build the SSD
emulator to a real device so my first
deadline is to build the nameless right
FTO added thought were device and work
everything else towards it and then I
found a set of problems with this design
and move to the second design which
place most of the nameless right
functionality in OS and then have a role
from well with the device so I'll go
through the problems at that I had with
the first design and then come back to
the second design to show your white
works well but before going further I'm
sorry that again giving you some
background on SATA so basically what
SATA has it has a stack
of layers and the top layer is a
software layer which can be controlled
by host and device and lower layers are
more related to hardware and use and
does the actual physical communication
but all we need to know if that the
lower layers are in host and device port
and cannot be changed and the top layer
talk with our task command standards and
can be changed this standard cannot be
changed but on the top layer can be
changed so i'll talk more about the
utter command I'm standard so for other
command on that there's a first set of
non date her commands so it sends from
hosue device the command and then
optionally lb a size and features and
then from device to host the status and
then optionally lpa size and if there's
an arrow the arrow bit and for the
actual aisle it supports pio and dma and
from host device it sends a command lbs
eyes and the data data to be written and
from device to host it has status data
to be read and needed an error the error
bid and the first logical block address
that has an arrow so now I'll go to the
problems that we need to solve to build
a name a name is right nefta with the
hardware so the first problem we have is
we need to add new and command types and
then another problem is that we need to
return physical addresses back to the
file system and also we need to
integrate the migration call backs into
the interface and finally there are some
consistency problems so I'll go over on
each of these in turn but maybe quickly
for the easier one so this is one is
much easier so what we need to do on
with a new on hardware interface is we
just add a flag in the OS and for device
we use the highest two bits in a size
size field to represent a new command
type and the second problem near that
phone image rights we need to return
FIDIC addresses and this is a more
severe problem because there's no art ah
yes
so chiropractors nameless rights is not
something that has been specified
assembled I Sam's apartment
so basically the our task command
standardin support any address written
back in the return path and our first
attempt is to repurpose the error
written so if you remember the arrow it
will send the first logical block
address that has an error so instead we
can just send a physical address so this
seems viable but whenever the device and
sets our Arab it the device will freeze
and our second attempt is to repurpose a
special and data attack amount and this
is called re native max address which is
the only a command that that's expecting
that dress so it's expecting the maximum
maximum address of a device but instead
we can just send a field called us back
and then with this physical address you
send the nameless right but there's also
problem with the second attempt so first
is we now use two commands for each name
is right come on name is Right function
and also there's a danger of silent data
property yes device freeze just because
I'm not sure but it every time whenever
it set up a writer of the devices
freezes at least with that board maybe
it's not true for all the world so
basically the first one we need of
mattress is effective like allocating
the region and the physical dressing the
next one sense to the right down right i
buy boxes happen at the same time how do
I associate that's why you're exactly
that's why there's a silent a
multi-process only employing one right
four at a time so imagine if you have
like you allocate two sectors in the
same flash page but then you have
different processes and you have
different scheduler at different places
so finally when the name is right
happens you can write a fling page to
clean page twice and again that's why
you can have silent eight approaching
and the next problem is even more
difficult that we need to send address
back from the device to the host with
name migration call back and when
possible solution is to piggyback with
other attempt but then again it has the
same problem as the second the last
problem and another option is the OS can
poll for this migration callbacks but
it's more costly performance and finally
there are some device are related
assumptions that then hold for like a OB
area that we required the actual
hardware actually the FD a-- didn't have
the access to the OB area at least for
that board so it has an OB area but it's
automatically with Hardware doing the
eec and other things so we don't have
access to that and there's no ought to
make rights yes
so this is the firmware that we are
changing but there's also like a more
yeah that's my next do that actually are
critical yeah yeah alright Justin 22 if
we're gonna so well one thing that I
won't cover in the slides that you can
probably use pcie and more IPC like cost
but I have a another design waste stick
stuck with the interface but this is
more we suspect that these are more
specific to this hardware board and may
not be hold with through hardware so we
can see that the further than 10 work
and that's why I moved to the second
design and the second design place most
of the out or talk about this design so
it places on most of the linguist right
functionality in OS and then all the
interface between the file system and
this block layer name is right FTL so
everything can be done in software and
it sends only rock commands to device
roll commands include flash page reads
and writes and fresh block he races and
these rock commands can be easily built
with arta and it's also easier to
implement in debug but there can also be
danger in this design if we are not
careful so at the first at first what I
deities are placed the name is right ft
0 on top of the io scheduler so what it
can happen near that it can again write
the same page twice without erasing it
because the io scheduler below are below
the FTL and then there will be a silent
data corruption so and next what I did
is to move to our scheduler above the
FTL and then I also make sure that
there's only because fto does a location
after that I'll schedule so I can make
sure that there's at most one right per
page and also i have a special io
scheduler that's designed funding this
right basically it can watch any kinds
of rights because the name is right on
nameless right ft 0
anyway allocate the physical addresses
and this is a performance or result we
show sequential random write and
sequential and random breeze and this is
throughput put on key apps you can see
that earning some cases name is right is
outperforming page level ft 0 this is
because the special i was going to
schedule a that i had but overall we
found that demonstrate perform similarly
as the page level ft 0 and for the
mapping table size we have the similar
conclusion that it's much smaller than
page table size hitch FTL so with this
hardware design i learned several
lessons so first adding our new command
is quite easy but adding information in
device return path and adding them any
information initiated from devices much
difficult and also there's certain
assumption that may not hold with
hardware but most of these are because
fitting lingus right interface is
intuitive protocol is fundamentally hard
and that's why i moved to the second
design of the spit FTL and this way with
moving the fto from connecting mostly to
lowes deck we can make things much
easier but these are dangerous that we
earn the device loses it can show and
let the software control its internal
hardware like io scheduler example and
also because we are placing the heart
FTL in OS it will consume or host cpu so
to conclude name is right we with
nameless right we can see that a large
part of the excess water hydrogen can be
removed and it improves both smacking
tablespace energy cost and performance
overhead but it's hard to integrate name
is right into the other interfaces and
it also requires from the manual changes
to the firmware and file system and over
stack so now i talked about the last
piece that I'm working on now so the
first motivation why we need get a
different technique to perform
dehydration is to reduce complexity as
warden
miss Wright has so ideally we want to
have no fascism changes no device
changes and it can still work with
current IO interface and the second
motivation is slightly different our use
case so originally when we designed
English writing mind we had this
Hardware in mind that the hardware
maintains the mapping table interaction
layer but now what it many system have
is it has a software layer to maintain
them interaction tables and whenever the
storage device needs more are making
table space it will contact the OS or
the hypervisor to allocate more memory
for it so in this situation we want to
have a more dynamic on way to reduce the
demodulation and the mapping table size
and also we want to do it whenever I'm
needed without the complexity of nimbus
rights so that's why I built this tool
called fascism debauchery Liza of FS TV
so what it does is normally everything
works as traditionally so the there's a
device virtualization layer it can be in
software or it can be in the storage
device and then the frustum talks about
it in with normal block interface and
also it keeps on working table around
and periodically or whenever needed FS
TV is invoked and it talks with a
storage device with normal aisle and
simple command to the modulation layer
and after a festiva is involved the
mapping table can be removed so what FS
TV does is that it changes thousand
pointers from logical pointers to point
to physical addresses and doing so we
require small files and changes small
device changes and no it can still use
normal I own interface so i'll show you
how it works with this example so its
first imagined offline process that it
on the best FST be first among the file
system and then processed individual
files and then finally mount the file
system so in the english comp oh there's
a I node and then some indirect blocks
and then finally data blocks and what
this is it looks at the pointers and
change them from logical to physical
from bottom up so it will first look at
the bottom layer and then it will ask
the virtualizer layer what's the field
hide us for l1 so the virtualization
layer returns p12 on to a file system
and then faster to FS TV and then FSDB
changes point here to p 1 and similarly
from male to 2 p2 and then the interrupt
block is changed to point to p1 and p2
and after it's been changed FST will
write this blog to a device and then the
virtualization layer can remove mappings
and similarly for ps3 and also for the
other trees the part of the trees and
finally on the top level I node and then
it can remove the final mapping and we
also keep a lot for consistency and this
process is what the savings depend on
the kind of data structure
you something like a page
removing only actual our sales because
you still need to slow the entire page
containing
what is the kind of cater to the region
to get people
mr. get smashin table please it's just a
mapping table for the device modulation
it's a virtualized device so it will
keep its internal either the device or
some virtualization layer for the device
we keep a mapping from Rohtak allowed us
to feel gorgeous
so the process I just outlined these are
offline process and that it has more
performance overhead so what I did is to
make it perform online and that's the
part that I'm working on now so
basically the first optimization that I
had is it will only process the changed
files from the last one so from the last
one off STV it will keep a record of
what files have been changed and only
process those files in next one and
another online process that we have is
to allow for ground iOS perform while
FSDB is running so what FSDB it does is
it only process browse that are closed
and noting page cache and also whenever
it's processing a file it will block all
the owl's to that file so to summarize
the fsd we work we can we propose a
simple 20 to 40 virtualization by
changing thousand pointers to point to
physical addresses it requires more
changes to file systems small changes to
device and it can still use normal iowa
interfaces and now i will present
present some of my other work and future
work and finally conclude so the part
that i talked about just now is about
you virtualization a single flash base
SSDs so what can happen near that we can
have flash based erase and one problem
that I looked at is called correlated
failure so imagine if you have a
mirrored SSDs and the mirroring pair
will receive the same right patterns so
they will die at the same time so what I
did here is just to add some dummy
writes what we call them e rights so
that one device can fail sooner than the
other one and another work that I did
when I was interning with Microsoft
Research is duplicate aware I race which
uses inherent duplications for
availability and reliability issues and
also flash can be used as a cash so I
helped with the project of solid-state
cash and also there's a problem
of storage level cache warm up so
basically when you have a large SSD
cache which can be hundreds of GBS and
you need to warm that up so only man
warm up then work anymore so I had some
analysis of data and some tools to make
cash warm up much faster and for future
work I I've been thinking about many two
directions so the first is the
continuing of this identification and
removal of excess redundancy so what a
linguist right and FS TV does is to
remove the redundancy in pointers or
mappings and there can be also other
kinds of pointers like in deduplication
or other kinds of devices that has a
word virtualized inversion layer like
single disc I don't know if you are
familiar with that and also there's a
Content redundancy which has been looked
a lot before but when using at least I
have I think it's kind of interesting is
a algorithm make on redundancy so think
if you have a lot of players and if you
have say I Oh schedulers at different
layers they can be redundant or even
worse contradictory so all these are
because we have more and more complex
software and software stack and hardware
so there will always be some redundancy
there and another direction I've been
thinking about is new abstraction and
into your face and for things like
storage class memory software-defined
storage and what I think is the
interface can should be more
customizable and also by exposing the
right amount of information from the
lower lower layer can be beneficial I
can talk more about these things offline
and finally to conclude let me use a
famous quote that our problems in
computer science our computer science
can be solved by adding another level of
indirection which is usually attributed
to battle Emson who actually actually
attributed to David wheeler and they
were really usually add but that usually
will create another problem
and that problem is excess modulation
our interaction so to solve this problem
my first proposal interface cunningness
rights and build a emulations and the
hardware prototype for english rights
and now i'm working on this file simdi
virtualization tool which is a
lightweight tool which you then have the
complexity and fix more that dynamic
situations and it improves both space
and performance and to finally conclude
at the first thing I want to say is and
in my theater experience I find that
reality is important so it can be it
looks like everybody knows but it can be
more different from your you're on
research and even if you don't want to
actually build a the real thing it's
always good to know the reality so that
you can maybe say to others how you may
want to build this and another aspect is
our theory which is more recently what
have been thinking is there any
information theory behind this
redundancy of XX can be anything and and
welcome to more discussion along this
line thank you I questioned about the
online app stds you go back to that
slide the one after the fight my villain
world actually is it a running system or
files of changing
while you getting their distant so is
there a while running this the file
system has idea where some files are on
a bizarre and this is a process for some
files is mapping poner from 24 the
physical address in student other ones
are still a lot of young ones we
actively and how can you do this not
change the file system so um there's
well only one small change that we need
so you you point out that a block
address can both be logical and physical
if you're not careful so basically we
offset the whole physical address to the
next our next offset so basically if you
have a 100gb device so 0 to 100 gps
logical represents logical address space
and 100 to 200 gb is for physical
address space they both might not the
same actual so on yes yes but device
whenever it's easy it's beyond one grade
knows that they serve for the quarters
but you got to go and fiddle with the
memory the mapping information of the
possible well melted yes kindly laughter
but it's really different and you're
assuming that you seized in the page
cache all instances of lots that might
be cashed in any way public policy so if
the file system implemented its own cash
or the buses have kept a pointer to a
logical block hanging around somewhere
in variable but wasn't in the page cache
first is this part is I'm still working
on but at least now I'm only looking at
paid cash and also files that are closed
at least a the function path that I've
seen they all put it in paid cash uh-huh
so I just want to go back to deleting
files still seems like we file the file
system would have to go back and
manually or explicitly work every block
that he's in violence-free you go
talking about a bit back power is it the
bitmap that thousand is using well the
current file system huh if you have a
big file you delete it right then the
file system just doesn't meant it
updates maybe try some new I know that's
a bit fit me but then when you try to
write a new file at Hot Wheels face huh
you can just issue rights to those old
box the old box get overwritten right
it's fine is there steph has been
deleted right but with the SS with
nameless rights where the SSD is picking
word right it has to know that the block
is allowed to be overwritten so it seems
like when you delete a file you have to
go through the interface would have to
go would have to change that when a big
file is deleted millions of em Lock
deletion request go down the SSD to mark
all those boxes free so what at least
the way I implemented this it collects a
set of blocks that has been deleted ins
and sensitive device so device were only
invalidate when the actual physical
address whenever I'd received this on
what we caught you are free come on the
trim is so my control gay person
pertaining to lead the fastest the
reports of ntfs sense trimmed when it
doesn't do during a check by nikos and
marks of the patella bitmap it was done
for us to perform sure it's just a silly
night it's literally device data
attributes this isn't occasion it said
it's a little but for the bitmaps up you
didn't need to change actually we don't
actually use bitmaps anymore other than
for the Voyager space so it only needs
to know how many blocks it has been
allocated so that didn't exceed the
total amount so there's only this trim
come on that then send the actual data
it's only telling the device which
blocks you can free another quick
question about here so it seems like
you're saying the major benefit was that
we're using less ram you showed some ram
comparison numbers did that there are a
couple things that I wasn't sure if you
were counting for one is you're adding
you're taking away some big structures
where you're adding some new ones so did
that comparison account for the fact
that there was extra metadata being kept
on your scheming
so they're two places you can't keep so
when is the internal deram which the
mapping table has to be sit there all
the time at least for the hot working
set and the other thing is the OB area
which we use for storing associated
metadata it doesn't need to be accessed
all the time it only needs to be
accessed whenever there's a call back or
whenever there's a recovery so it
doesn't need to be loaded into the RAM
and it's cheaper with flash than with
the painting of the rebels SSD would
mean they can't get rid of the entire
mapping table because he still need the
mapping table for the portion of seats
for the I notes and things right did
that work what ratio of data to meditate
was that comparison something um if I
the results I used is these two
impressions so it has different types of
file system layout but usually it's less
than ten percent so one one to ten
percent and that depends are so that
will decide how much space you need for
name is right for the mapping table size
heard about this new type of hard work
which is combination of that
so you can come in with that hard life
have you heard about him come in hint
hint the new command site I have heard
of the hybrid but I haven't put it I
think pink is basically I mean like tree
huh it's another hint from the OS to the
hard way seeing certain the area is hot
okay others so final four previous basic
says I'm not going to use this year and
the more yeah pink is basically says
this area is going to be used more often
helpful for those basically that kind of
hybrid hard water what do you think file
system basically we had that he used on
multitude
what do yuh you are saying foul so may
adopt to what I'm basically meaning is
is there anything else file system
should do you use those hybrid drive
more efficient so one thing first hybrid
drive it can probably detect the
temperature of the data themselves but
if you want how you have more awesome
support and one thing I think can maybe
improve the performance see that the
foot SSU part it has some internal
operations like we're learning education
it can tell the fasten whenever it's
doing so so the file system can schedule
you things differently is that the
dancer okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>