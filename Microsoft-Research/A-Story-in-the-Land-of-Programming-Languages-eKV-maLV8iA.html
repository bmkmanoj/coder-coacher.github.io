<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Story in the Land of Programming Languages | Coder Coacher - Coaching Coders</title><meta content="A Story in the Land of Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Story in the Land of Programming Languages</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eKV-maLV8iA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay well thank you for coming this
morning it's my pleasure to have
Jonathan protank Oh visiting us for the
next couple of days while interviewing
at the rice group Jonathan's going to
tell us about some work he's been doing
on med Zoe and ml like programming
language with a type system that's
inspired by separation logic and what's
also cool is that Jonathan's bit of a
doppelganger is has got a second life as
a as a as a web developer doing open
source development for on various
Mozilla projects and as I understand
correctly maintains one of the
extensions with Thunderbird that's got
more than 100,000 users and so that
celery so that's pretty awesome so
looking forward to hearing about both
these things maybe more about meds oh
then about the other but both to welcome
all right um thanks Neil for the
introduction as nickel said that talks
are going to be about my research and
it's mostly going to revolve around meds
of the language today design during my
PhD so there's going to be three main
access to this presentation first of all
I'm going to tell you about the design
of it and then how we implemented it and
then we're going to tell you about the
user interaction and that's where the
visualizations and all the fancy d moves
are going to coming so quickly word
about myself I flew in from inria back
in France and I mean the gallon team
which you certainly know for some of the
famous project such as o camel or
concert my advisor is from swap ideas
and and as nickel said I happen to be a
module contributor my PhD work was
really meds of the language it's been
all about designing it and what we've
been trying to do is provide language
that's introduced in the tradition of an
L but that goes further right using the
type system it go through there it
provides more guarantees about three
buzz words if I may say so which are
state ownership and addressing so
hopefully it will be more clear by the
end of the top where I mean by this but
we did key points that I'm going to
cover among other
things or first of all I'm going to tell
you how we designed the core of meadow
how we combine various ingredients from
the literature to create what we believe
is an interesting core calculus then
will come the problem of a complex
aliasing you have a number arbitrary
graph of objects pointers in every
possible direction what is our strategy
for dealing with that I'm going to tell
you a little bit about the
implementation since that one major
fragment of my PhD why was it hardened
too many meadow and how is it done and
then I'm going to tell you word but the
visualizations so really that talk is
going to be a sprinkled with demos and
visualizations and hopefully they'll
make it more interactive and really if
there's anything that's in here I really
do wish to be interrupted to make sure
that no one is lost on I think it's
going to be better for everyone if you
ask questions in the middle of it so I
like to start this talk with a small
example of what I think is a bad
programming language that's the control
equations for Apollo 11 and the lunar
landing and the comments are really
interesting it reads temporary I hope
hope hope and they landed people in the
moon with that so there's a it's
actually on google code there's been a
release of all the old documents so you
can actually read the original control
programs yeah so um back then there were
some pretty bad programming languages
but means that verification is not
needed it was man
come without right I wouldn't want to
fly to the moon we said that program so
people quickly realized that we needed
better for growing languages guy called
Knuth said I think we're on the verge of
discovering at last what programming
languages should really be like by 1984
consensus for a really good programming
language right so it turns out that's
not quite the story that's an example
that I kind of like there's a variable
which is equal to itself and also equal
to naught itself so what I won't tell
you is not I don't want to bash any
language what I want to say is the quest
for better programming languages goes on
it is still an open problem and why do
we want better programming languages we
want better programming languages to
better reason about your programs if
you're lending a guy on the moon you
want to have maximal confidence that the
program does what it intends to do and
one way to attain that goal is to have
better programming languages that from
the start roll out more bugs and that's
what I've been trying to do and the wave
been trying to do it is through type
system type system is from component for
my team and really we want it to go the
next step there's the famous Milner
meadow well type programs to not go
wrong we really want to take it to the
next level and the way we did it through
a type system that in our opinion
there's a lot of advantages to doing it
through type system inspired workflow
it's every time you program you got to
think about your types if you want to
port a program to a better type system
you can do it incrementally you don't
have to rewrite the code you can just
improve on the types it's one layer you
don't have like a verification layer on
once on the one hand and your program on
the other hand and also what we are
really trying to achieve is compromised
we don't want full specification we just
want a better type system that gives you
more guarantees and really the end hope
is that programs that are written in
mezzo because they've been written using
that fancy type system are more
structured meaning they're more likely
to be proved if someone wishes to do so
so mezzo feels like ml
the syntax looks like ml is very
familiar but type system is closer i
would say to separation logic it allows
you to talk about state i know is my
socket initialized already or closed
ownership have that piece of mutable
data which thread owns it and aliasing i
have many many pointers how do I manage
that and again I really wish to stress
that meadow is not the ultimate answer
it is not going to provide you with a
complete specification of your program
just stronger guarantees while hopefully
remaining somehow the Nashville the
reason we're doing that and I really
should clarify how we stand with regards
to it is concurrency the really the end
goal is to have a better type system for
helping you right concurrent programs
the initial effort was aimed at
sequential programs because there's a
lot of things that you have to sort out
before you move on to talking about
concurrency working on sequential
programs has allowed us to incorporate
new idioms to make the type sister
understand more stuff it allows us to
talk about the effects and then it
allowed us to gain that guarantee one of
the main theorems that we have is that
programs in mezzo are dead erase free so
what we have now is a lot of modules
that are formalized in mezzo for Lux
concurrency threads channels however the
main caveat is that we do not have a
concurrent time I just want to be clear
about that we're using ocampos model
which is not parallel so the future
would may maybe to move to a better in
time we formalized and we set the
mechanisms for talking about it but we
don't have a parallel execution in mezzo
as of now before jumping in right to the
examples I just want to tell you about a
few sources of inspiration that we had
so that hopefully yeah sure so you're
saying you some or threads that you they
can run on you in a single core yes so
you will make sure that the operating
system doesn't context which know what I
mean is that we have signatures for the
spawn function in our type system we can
type check the spawn function with very
fine grain
type that tells you what the thread
modifies in the hip etc but ultimately
there is only one thread that's running
in the runtime system of a camel we do
not have multiple threats it's just
sequential programs are compiled
sequentially actually I think the thread
module does not even compile you cannot
use it i mean there's a type checker
interface for it it's formalized it's
muddled but we do not have any support
for running threads right now question
was are you you said not truly parallel
but you could you could be supporting
switching between threads on a single
yes correct we do not even do that I
mean our effort was really in the design
of a language not in the implementation
of a runtime system blocking primitive
like I don't with that dead love the
program without the dead of the program
if you just be like what kind of
blocking primitive basically I lied a
lot walk um I don't think locks are
implemented right now I mean they have
seen the shoes you can write a problem a
program that has locked I mean it's very
primitive I mean we have a compiler just
to say that we can run basic programs
that do printer okay it creates about
the design of a type system not okay to
extend you could in principle it's of
engineering have a run and then does
this job absolutely I mean it's just
some missing manpower we just need to
you know fill in the gaps in the
calculation tool chain okay so you use
the okay no runtime in bits yeah the way
we do it is that the compiler translates
mezzo code to a camel coat
yeah so when you can interact between
the two we can call mental code from a
camel but again our focus has been on
the design of the language and the proof
of soundness right now the compiler
outputs a new camel file with several
calls to up that magic because the types
yourself matter is more powerful and
then you just compile it and run it we
have a some very basic simple programs
any other questions okay um so let me
just give you a quick a few sources of
inspiration to make sure that we can
locate met so in the design space mezzo
is influenced by a lot of existing work
of course there's the linear lambda
calculus which has that idea that some
variables may only be used once and that
will you get predictable the allocation
and that's inefficient way to model
system resources so we do have that
notion also in bed so that some
variables can be uniquely used or have a
unicorn another source of inspiration is
all these types do maybe in my opinion
main idea analyst types is that you want
to keep track of aliasing relationships
in the type system you want to remember
that this field is this object and this
other field point to the same thing and
that's included in type system and we
have a similar mechanism in meadow
separation logic is probably our main
source of inspiration the fact that we
have a star that can possibly separate
distinct fragments of the heap the fact
that you can have local reasoning on a
function and you know that whenever it
touches its own fragment of the hip it
will not interfere with whatever lies
everywhere else the frame rule these are
all things that are in a way that appear
in some way meta another source of
information has been object-oriented
there is that Platt family of languages
where people have a language that feels
like Java that has a type system and on
top of that they have reasoning about
permissions and they want to model
object protocols like iterator has next
ready or closed so they have state
diagrams and I want to model that and we
also have something similar in that so
and finally a paper that I quite like is
the one about ownership types there's a
lot of
aight ids and paper the fact that
there's an ownership here hierarchy that
objects may own others and also an
essential ID that we also have is that
you may have a pointer to an object but
you may not have ownership of it and
that's something that I will elaborate
on this side so that's pretty much all
for the intro body language i'm going to
directly jump into some demos so there's
going to be several self-contained
examples i'm going to switch back and
forth between meds oh and this
presentation and i'm going to do some
quick recaps so if anything the syntax
or what i say isn't clear please do
interrupt me i'm going to start with a
usage protocol which I call the right
ones references say you're parsing your
command line options you have some
uninitialized memory you're going to
initialize it once and never after again
are you going to modify it and say you
want to include that in the type system
so you start with a new right ones
reference which isn't a state writable
then you seal it so seal has two effects
it writes something into the reference
and then it makes it immutable so you
can no longer right into it and then
once in your in the frozen state you can
call get repeatedly which keeps you in
the frozen state so here's some code
that does that in mezzo it construct the
value which is unnamed and which is a
pair of integers by allocating a new
right ones reference selling it and
calling get twice so how do we reason
type system wise about that example type
checking in mezzo is flow sensitive so
we start here and we say that we have
the mt permission a permission mezzo is
something that has this form with an ad
sign for instance if you call new you
get a new permission for our which tells
you that are as type writable so
permission conveys two types of
information it tells you about the shape
of the object in memory r is a writable
memory cell which has a countenance
field for instance and it also tells you
something very important it tells you
that because r is right about you have
ownership of it you own the fraction of
memory that is pointed to by our how you
own it is going to depend on nature of
the type i will get back to that later
but if you have that permission you have
a certain ownership
are what happens that call seal will see
in a minute the signature of the cell
function but it expresses the fact that
it needs to have this as a writable and
it transforms it into something that's
frozen the signature of cl expresses
that so actually the permission
disappears and another one appears so
relate permissions they come and go and
they may change through execution
permissions they're completely in the
type system they do not exist at runtime
it is our type system we don't have a
separate judgment with a gamma this is
what we use for our type system is that
clear so far ok I think I have a demon
ok so can everyone see properly ok let
me click on right to want references so
I'm going to clear this so that's mad so
any web browser at compile meadow to
JavaScript any type checks in your
browser I'm not connected to the
internet so it's not sending off
anything offline for some another server
to type check so it may be a little bit
slow because it's JavaScript but it's
still fairly acceptable so that's the
implementation of Rights wants
references basically we're yeah
oh sure yeah as so that is the
definition of a data type that's the
right ball data type it only has one
field contents which has type units so
it's just a placeholder value it's
mutable because there's the keyword and
then the frozen type also have a
constant field except the conference
field has type a and because there is no
mutable keyword it is immutable the new
function well it just returns to you a
new ready ball with placeholder value in
it and the interesting bit here is the
seal function the sylph function tells
you that it takes ownership from its
color of a thing called r which is a
writable it also takes ownership of x so
that's the special consumes keyword here
it tells you that you're stealing from
your color due to permissions and in
exchange you're returning a new one to
your color you're returning to your
color a permission for that very
variable R and you're returning to it
the fact that is now it's now frozen the
function operationally does two things
it right X into the contents field and
it writes into the tag of our the frozen
tag which basically amounts to tongue
type system that the thing is now frozen
and finally the get function it just
takes a reference our and it returns a
pointer to the contents field on line 13
yes so the pipe is to separate it's the
conjunction of a type and a permission
so if you write T pipe p it's a value
that has type T along with a permission
p so if you have the unit value along
with permission p that's written like
this and we somehow abbreviate it as
this so it's the unit value along with
conceptually a permission any other
question about the syntax yes
take the ownership so if you get like
nothing seems like nobody else can have
anymore that is an excellent question
which is going to be addressed in ref
get fixed too I'm going to get to that
in a minute we do not we did not
coordinate with Dan so that he would ask
me the question yes so in your side you
had writable and frozen and and here you
have viable and frozen and where they're
declared as types that they're not
building to the language yes so I guess
then they were released yes absolutely
we're but what's building that is the
confuse yes consumes is a built-in can
satisfy yes so the now in the seal
function you have our contents and when
you has an RS available that has a few
nips yes its fuel so let me show you
yeah so let me show you this wouldn't I
drinking single times absolutely there
is actually a state change that takes
place the variable growth through
different types so initially we have our
a tradable but the type system is aware
of the fact that rideable only has one
branch so it expands that as what we
call a concrete type it's basically a
type that tells you about the structure
of our in memory so that's a more
precise type that tells you that there's
a writable tag and then there is a
content field which has type unit and
the system knows how to deal with that
in the sense that if you assign
something into the content field it's
going to keep track of that change by
saying that the contents field has type
a okay so we are in an intermediary
state we have somehow broken the
invariance that type cannot be seen as a
writable and cannot be seen as a frozen
either it's something in between the
type system keeps track of that it
allows you to temporarily break in
variance and then on the next step you
change the tag so you just modify the
right
portion of it and you write frozen
instead and then the type checking says
the post condition of that function says
that have to have or as a frozen thing
is it actually frozen yes because this
is a subtype of our at frozen a so
subtyping takes place and then you get
what the post condition of the function
requires decoration and clears reports
and they have tags yes a geeky word
accesses the tank of the record tag of
is a keyword yes and when we say mutable
here it means that everything the whole
memory block is mutable I'm guru tag yes
absolutely ok so then frozen is that you
know so if I were to do another
assignment here like Tyga or gets
Mirabal that would be an error because
the thing has been frozen in no longer
is mutable synthesize these intermediary
types that aren't expressed anywhere
else in the program of a writable winner
oh you can write that type you can
actually write it you can write that
that type I could have said here instead
of writable I could have said are
writable contents unit that's pretty
much the same thing so now you have a
writable with contents that's not unit
just not described anywhere else in the
program it just emphasizes diesel yeah
it is aware of that it is aware of that
and you could actually write it here
like say I wanted to give it a somehow
different signature let's say I'm going
to do something stupid I want to only
initialized initialize writer balls that
originally contained integers you can
write that intermediary title ok
so quick recap permissions they're
available at each program point they
change as you step through the program
so type checking is flow sensitive the
functions have in their signatures the
effects the day perform and the
permissions they are our type system and
here we've been talking about states so
for us the state of an object it's
simply the type that it has it may move
from type a to type B through a function
call okay i'm going to show you another
example which is that of a race that is
rejected by the type system of meta
whoops not this this so i have a
variable r which is a regular reference
so i'm just calling the built-in new ref
yo ref has an implementation that just
defines rev contents so it's just
regular references and there's there's
an inker function that mentions in its
signature that it modifies are because
there's no consumes keyword it takes on
a ship of our and it also returns it
that's the syntactic convention if you
don't do not have the consumes keyword
you're just modifying your permissions
so anchor does not take a pointer to our
it just modifies it it closes over the
pointer and it's basically a signs r
plus 1 into r so let's say that I want
to start two threads that only do anchor
what do I have in terms of formation at
that program point i have r which is a
reference and also have a permission for
anchor which is a big function type I'm
gonna called spawn because incur
requires the permission for our after
I've called spawn for the first time I
no longer have the permission for our so
if I try to call spawn for anchor
another time that is going to fail
because the required permission is no
longer there so let's try to type check
this I hit go it tells me that at the
highlight application I cannot obtain
the permission for our as a reference to
an integer it tells me that there's only
another lesser permission of elbow for
it which I will mention in this example
okay so how does that work the system
has a built-in notion of what is
shareable and what is not sharable for
things that are mutable it knows that
they must have a unicorn because say if
you modify a thing and you put it into
another state if someone else still owns
a copy of the permission that points to
the older state you're going to have an
inconsistency so anything that's Mirabal
must have a unique honor and the system
is aware of that signatures form yes I
suppose let's look up in the standard
library not there let's look up in the
core library yeah here's the signature
respond it basically takes a function f
that requires a certain permission p the
outer spawn function also takes itself
the permission p and it turns f by
conceptually passing it the permission p
you're basically expressing the transfer
of ownership spawn takes from its color
p transfers e2f and starts f on a new
thread and actually it doesn't quite
consumer permission right it takes it
and gives it back correct and you have
subtyping yes I'm pretty sure they're
subtyping going on where we're dropping
the permission the syntactic sugar for
without consumes translate to a
permission that's consumed in the
argument and returned you can just drop
it in the code domain of the function ok
yes so there's a built-in notion of what
is wo noise not data may be frozen from
mutable two immutable but of course not
the other way around for that would be
unsound let me just now move on to
another example which is an aliasing
violation by the way there is a way to
fix the race which is to use block and
that I'm just going to run over that
example quickly but this is a
higher-order function that transforms a
function f that has some internal state
s into a function that no longer exposes
its internal state by educating a new
lock so what the function hide does is
that it allocates a new lock for the
functions internal state and it creates
a new function that has no internal
state first thing it acquires the lock
cause the original function and then
releases the lock so it's hiding the
internal state of a function in a
higher-order way and if you call hide on
incur you're basically getting a
function from unit to unit and that
function you can spawn it twice if I
clear this I think I can type checks
that example ok so a bit long yes type
checks in successfully in about three
seconds ok um because I don't think you
really hype this internal state is it's
observable what you really mean is
you're saying you hide them permissions
that yes such use in an alternate way
yes still guaranteed
in a race field yes absolutely right
that's what the fact that this program
type checks means thanks for rephrasing
it in a better way than a dead so that
example should make you happy that is
the usual get function for references if
i try to type check that example it's
going to tell me that I have an aliasing
violation why because I'm pretending
that I'm maintaining the argument are as
a valid reference but I'm also returning
a pointer into the reference so now I'm
aliasing the contents field of the
reference I have one way to access it
through our and also through the return
value that's returned by the function so
that's an LS in violation how can I fix
that the first natural way to fix it is
to require that the reference contain w
ball elements which I can then free
areas and then this example becomes
illegal but I can do something smarter
what I can do is use a special
qualification what I'm going to say is
I'm going to return a pointer to the
element X which happens to be whatever
is in the Cotton's field of the
reference so what's that bizarre thing
equals x that's a type which we call a
singleton type the ceiling of the type
equals x is the type of elements that
are equal to X so that's the way that
are the only way we get dependent types
in meadow and what that tells you is
that you just return a pointer to the
elements called X without any ownership
information so your do not attempting
attempting to duplicate ownership you
are just returning a pointer into it the
square brackets stand for universal
quantification over X so I'm going to
run that example in the term yep sure
this is another time
and it's a kind it's the kind of
variable so that is a type variable at
kind term so program variables if you do
let X you can use X in expressions and
it types with kind term get square
brackets a and X colon a that would have
been embarrassing because I will you be
no you cannot do that no that wouldn't
work because a would have to be a kind
here and we do not qualify on kinds so
you would have you can write for all a
but then a is a type right so right for
all day yeah you also write for all X
Type A this
like this justin is a second square
bracket of the a X colon a I think you
said you don't support for education
ever yeah we don't support that so this
is just one indication of a types no X
is already a type variable a cough kind
terms so that really means a of kind
type as you and this is X of Cain term X
is already a type it is already at I
variable you're in singleton type yes
okay yes it is a dependent type okay I'm
just going to run that example in a
terminal right what appears in the
terminal is not important what is
important in this but when I tell you is
that the type checker because of these
singleton types keeps track of aliasing
information so let's move back to the
example for a minute what does the
example do it allocates X which is at
uppal it allocates a new reference whose
countenance field is X and it calls get
our and stores the result in Y so I'm
just going to put the two side by side
the type system knows that x and y are
the same things it knows that the
contents field of our points to X which
also happens to be why and it also knows
that the top oh here has two components
that are integers so internally the type
checker has a graph of objects and that
is done through the mechanism of
singleton types why do we use singleton
types yes
okay so I'm the problem suppose that X
has a reference direction of misfit up
just to has a fighter too soon I'm sorry
suppose that so here you declare
accessing or defined excess of 21 yeah
11 kind of true yeah if you declare the
egg or defined XSL to pour ref 122 yep
so then the state of makes you feel
beautiful yes I get your your gate
function which still work because x and
y are equal in the type system yes but
it certainly does your type system then
let you write programs without deep
copying your values too deep copy when
you started the examples of RC expecting
a function again function that would
perform a deep copy ok I'll seem
startled know what happens really is
that when you create an alias like let x
equals y instead of deciding whether X
or Y gets information whether we have X
at interesting stuff or why add
interesting stuff we just remember in
the type system that x and y are the
same thing and that's where the
singleton types kick in we have a
special permission x at equals y and we
just add that we do not try to do a deep
copy to make sure that both x and y are
references we do not try to assign on a
shape to the other one we do not do
borrowing like x borrows the reference
from y or something else we just put
that equation on the side and the whole
type checker is able to deal with the
equations it can perform your writing
and use one or another and differently
and using similar types we keep track of
the aliasing relationship between
program variables temple fields and
record fills
that is an excellent question through
the short answer is we thought it would
be a problem and it basically never
happened in practice we whenever control
for diverges I'm going to get to that
later we do a graph traversal in
parallel and we reconstruct maximum
aliasing information and we don't have
problems in practice I mean we are able
to reconstruct the aliasing information
so really a conjunction of permissions
it is a graphical description of the
heap and that's the way we think about
it I'm going to switch to a complete
example I am going to do the example of
list concatenation let me just wish my
browser again that is the definition
place either in it it's either Neil or
cons these are immutable lists we have
some helpers for constructing cons and
nil and we're doing a pent so append
it's just like in ml you imagine excess
if it's Neil it's YS otherwise you just
create a new cell until ultimately you
make it point to is the interesting bit
and the reason why I'm showing that
example is that there's a consumes
keyword because you have to take
ownership from your color of the two
lists otherwise you would be creating
aliases like if your color can still
point to the original list and the
concatenation the elements that are in
xs and ys will be aliased so the only
way we can write that function is to ask
it to require ownership and do steal
ownership from the color that seems very
restrictive and indeed well when it's a
list of references because references
are uniquely owned the color loses the
ownership of the lists right if you try
to assert that l1 is a list of
references at this program point that is
not going to work let's try it it tells
you that it could not obtain the
permission that l1 is a list of
references to unit so really the type
should the type system rules at this
dangerous behavior the good news however
is that if your lists happen to the list
of integers lists are immutable integers
are immutable so l1 points to
an immutable fragment of the heap and
the type checker knows that it knows
that this permission is duplicable so
it's safe to save a copy use the copy
for calling append and then keeping a
copy for yourself so these assertions
are actually going to work and we call
it call sitepoint morphism yes type
check to say successfully and to be an
example that i'm going to show you is
that i am going to write a tail
recursive range version of app and so we
can already right a tail recursive
append in ml by doing two passes first
rev append and then Rev but we can write
it in one pass in meadow and there is
something that you cannot do in ocala
without resorting to and safe
implementation techniques so how do you
do to recursive concatenation of lists
in one pass now you use three types of
cells the yellow ones are cons cells
they are immutable but they do not point
to the start of a well firm list the
blue cells during mutable they have an
uninitialized tell field and green cells
they point to well firm lists there's a
loop which we model as a recursive
function and the loop works as follows
you have created copies of excess which
are the yellow cells and then you're
basically trying to stitch DST onto is
by copying cells from excess so this is
a mutable cell what you do is that you
allocate a new blue cell which is the
copy of access that you have to do you
perform pointer rewiring because that is
a mutable cell and then you freeze the
blue cell so that's going to be one step
and you move forward as you go you
allocate cells on the fly you will wire
each cell to the next one until you
reach YS and in that case you're done
you've created copies of excess and then
you rewired the end of excess on two YS
so you have a well firm list the problem
is the type checker does not know
there's more reasoning needed to prove
that this is a well from list you have
to say ys is a well firm list DST is
an immutable council that has a tell
field that points3 well from list
therefore it must be the case that DST
is also a well feminist nothing happens
at that time this is pure reasoning
there's something that has type list a
that is not a well from list because it
ends up with a dangling tell field so
that is not a well-formed list where is
that died in vain I can show it to you
yeah this is list and the definition of
cell is basically a same thing there's
ahead and tell field except the tail
field is a placeholder and it's mutable
I think you had a great advantages okay
and so yeah after that you're done doing
operations after and time but you still
need reasoning to unroll your recursion
and to finally convince you that once
the function is done DST is the start of
a well-formed list I'm not going to show
you step-by-step the entire example what
I want to show you is the tight loop
here it's the app and ox function that
I've been mentioning in the slides yes
what happens is that there's an
additional reasoning that takes place at
the type checker level after the
recursive call so basically we're in a
state where DST is our old blue sell
that one that has been made immutable so
it has a Const I've DSC prime is our new
blue cell tail is our new xs and ys is
the thing that we have to rewire
ourselves on the recursive call consumes
the last three permissions and returns
to you / its post condition the fact
that DSC prime is now a well-formed list
and we know that cons that DST is a cons
cell whose tell field points to DST
prime so it's basically the drawing that
I made here
previously we were in that situation and
we are in that situation and we need to
perform the bit of recursive reasoning
that tells us that the st is and yes so
you say that
the console that we know to answer yeah
you're saying at some point you're
allowing the tail that means something
other than yes absolutely you're
breaking the you're breaking in the
implementation to listen absolutely
that's the question that we had before
in the sense that we can represent
concrete types that are not subtypes of
a nominal type we can represent a little
yes absolutely and for that for that you
need to have the reasoning that these
things have a unique owner because
you're mutating them into something
that's completely illegal have some
other types and I've require things of
BS let me do this mutation as long as in
the end I can prove everything is back
yes at the low blows precisely unless
you don't even have to prove that at the
end you're back at a risk you could you
could return something in the middle
with something in a hydrate you can
write these tires if you want so say
suppose the data at type cell at two
cases size XL and sell nil yep and now
you change the tag yeah of tests to cuts
yeah your type checker would have to
check that without taking a Cell nail to
comes
they record heels and until with Africa
violence yes absolutely here so the
weight step check is that here we have
DST DST adkins wait no cell head type 8
l equals the SC Prime and there it
checks that the size matches that there
is exactly two fields and that it's
legal to mutate the tag the field names
may be different but the size of the
block has to match for the runtime
concerns that is something that
unfortunately we're exposing because we
have rent time limitations we can not
expand in place GC blocks house you say
that dsds comes with DST fine but it's
just you and then but then you say the
DST prime is indecent life where g list
here DSD Frank becomes a list updated at
all yeah after the call that is the past
condition of a pin dogs you pass it a
thing and it turns the thing into a
well-formed list so you pass it the SC
prime and it turns the SC prime into a
warm front list and then there's a last
step of reasoning saying that if the st
is a con sell it still points to a well
from list then also it must be the case
that it is a well from list and the type
checker knows that and performs that
automatically these are just comments
these are no hints to the type checker
that just comments to explain what's
happening
okay so I think I've explained that
enough the pattern works because we have
tail-recursive reasoning that is we
reasoning that takes place after the
recursive call and we have state to
change and freezing of mutable data so
I'm done expressing explaining to you
the base layer of metal these are all
the mechanisms that we are using
signaling the types the notion of east
applicable versus is not applicable and
these intermediaries states that are not
a nominal type so with that we can
express several usage patterns borrowing
an element from a list in place linked
reversal basically anything that has a
tree shaped interesting pattern works
and that is restrictive somehow you may
want to have arbitrary anything and
that's my next part I'm going to tell
how we deal with the problem um so you
have an object that owns other objects
that owns other objects and you don't
have back pointers so typically the
example that we cannot express is that
of a graph in the graph you have
pointers in every possible direction
between those and you cannot make it in
a way that knowns that a node owns its
neighbors because there's different
pointers and that would be an ownership
violation but that would be an orange
evaluation because you would have two
objects pointing to the same thing so
who owns them we can represent loko
aliasing using the singleton types but
as soon as it's arbitrary sized we can
longer express it with the mechanisms
that I have shown you so far and
actually let's let's do it let's try to
yes precisely yeah exactly yeah so ready
to grab not everything is only one do
you mean in the grand is intriguing back
edges in a graph you cannot express a
graph with what I've shown you I mean
the graph definition would not type
check that's my example actually Andy
you can't even do that gasps by the way
something I mean is it is if not
possible to just ordinary programming if
I'd known you love a fancy type system I
just want to write a rap album and I do
it you have to use the escape mechanism
we have a escape hatch if you will that
allows you to break out of the
restrictions of the base layer but you
have to be careful you know so does that
mean that you could write your rapid
rhythm in now and do that in Lincoln
against program written in metal you
could I don't think I've gone beyond
this stage of a simple example program
that yes in theory you can link them
because do not like allowance oh no we
are different in the sense that really
are ruling out programs that are very
few cattle because we think there are
too dangerous they're doing in st. stuff
with their illness e and conversely also
allowing behaviors such as the territory
function that are more fine-grained know
so if you want to interact you can
include technically because metal
programs can link with the camel
programs but you'd have to be very very
careful so what I'm trying to do here is
I'm trying to create the graph with one
note that points to itself so basically
a node just has a list of neighbors and
I'm going to do it in a naive way and is
going to fail I'm going to say that
neighbors is a list of nodes and that
nodes hold the value and I want to
create the node that points to itself so
I'm initializing X as a node again I'm
putting a placeholder value in the
neighbor fields because I don't know
what to write in there yet and then I'm
going to create a list of nodes so as to
write it in the neighbors field and that
is going to fail the reason it fails is
that you already consumed the permission
for X as a node in order to create the
list
and then the permission is gone so you
no longer have any useful permission for
X you no longer know that X has a
neighbor's field because that permission
has been used already so you can do it
it tells you that the only permission
you have 4x is that permission called X
at dynamic so it has appeared already in
the examples so let me show you what
exit dynamic means that's going to be
our escape hatch so I'm changing
definitions slightly I'm adding a scene
field because i'm going to do a
higher-order graph traversal so i need
to remember which knows i visited but
more importantly i'm changing the
definition of neighbors to be list of
dynamic and now i'm defining a graph to
be just a record with a list of routes
along with a special directive called
adapts not a and we're going to see on
the concrete example how that works out
so here I'm creating g which is a graph
that holds integers with one node that
points to itself so again i'm creating
the node but what I'm going to do here
is that instead of creating a list of
nodes I'm going to create a list of
dynamic because I've used the permission
exit dynamic I'm so left with the
permission X at node so I still have the
information that X is a node so I still
can write into it the good thing is exit
dynamic it's duplicable so even after
that line I still have it I can ask for
some information about X oops sorry I
can call info X and it's going to tell
me that at this program point I still
possess the permission X at node I think
it didn't yeah I still possess the
permission X at node and I also still
possess the permission X at dynamic so
you also notice that it knows that the
neighbors field of x is a console
features that you call back into the
type trackers yes yes that's a special
hook that allows me to poke into the
type checker and the type checker knows
about that special function and it dumps
some information about a variable that's
very helpful for
debugging so the important bit is that I
still have that permission exit dynamic
so I can use it once more to create the
list of roots for the graph and now i'm
using a special instruction called give
x 2 g so does that mean it means that
I'm relinquishing I'm giving up my
ownership of X in order to transfer it
to G so I'm giving up on ex I no longer
own eggs but G owns x how is that type
check I see that G is a graph that graph
graphs they adopt node X is a known so
it's legal for me to give X 2 G and
after that data yes Isabel turn access
now you're absolutely objects are
allowed to own other objects yes and now
it tells me that at this program point
the permissions that I have left for X
or just X and dynamic and it's good
because I no longer have ownership of X
I have ownership of g and g has on a
ship of x and intuitively that allows me
to regain a tree shaped ownership
structure I on g g owns all the notes
the notes do not own themselves so
there's no back pointers that's a
special directive that instructs type
checker to print out some information
whether you will see can you do in oh
sure it's not going to be very
informative yeah sure it's going to tell
you that G is a graph that has a roots
which is a list of dynamic and that it
adopts notes of instead of integers
otherwise you're you have subtypes and
data technics references yes that is
going to subtract the nominal type
graphite or graphene sorry
yeah I'm going to move on so that's the
DFS procedure I'm not going to explain
it into the detail what happens here is
the relevant bit I need to visit node n
n is a node that is dynamic so I'm
taking ownership event from graph G so I
regain at this program point I'm
regaining the X at milk permission I'm
doing my stuff with n I'm calling the
higher-order function f on it I'm
appending this neighbors into the work
list so that they are scheduled for
visiting later and I'm also remembering
that n has been seen by writing into
it's true it's Sinfield and then once
i'm done doing stuff with n i'm giving
up ownership event again by passing it
to the graph G and only after that am i
visiting on other nodes so I'm making
sure that I give up my ownership before
actually visiting other nodes and of
course for that work I need to have a
runtime mechanism how do I guarantee
that these operations are legal what
happens when take is written in that
there's a runtime test it dynamically
checks that n is owned by G and if I try
to write take twice it's going to fail
at runtime yes yes I'll time and
attaching the permissions of and to the
permissions of G so conceptually you can
think of it as it as this you can
conceptually think of G as possessing a
list of all the elements that it owns in
the implementation we have something
smarter using a hidden pointer from n2g
when n is owned by G it has a hidden
field that points to G when it's not
owned by anyone to get the hint feel is
cleared out and we check the hindered
field of n against G in every operation
that's why we're passing both energy
into take and give operation
yes though I was wondering if you
consider doing this management instead
of at one time instead of using a
runtime mechanism doing it at compile
time by attaching it to the type of
treatment so touching so when you say
give into G it actually attaches your
permissions on em to the mountains of
gene program that is not something that
we have considered um I'm just it's
probably not want to do I mean this is
essentially a trade of I mean this is
where you go from the star people that
they absolutely that's our layer
simplify the type track yes as an
otherwise you would have to quantify
over all the normal yes precisely sounds
of instances that's our design choice we
wanted to say we keep the base layer of
the type system simple we don't have
don't want to have complex predicates
like there exists a G which conceptually
owns a memory region in which the nodes
live and the nodes are pointing to other
nodes from the same memory region we
don't want to express that so our story
for the user is clear whenever you have
complex editing patterns just use that
one time test mechanism and the whole
system remains manageable I'm just going
to skip the type checking this is slow
I'm just going to interpret the program
so I fail ok i'm doing the gfs the DFS
by passing it the print function and
it's printing 10 because that's the
value that's stored in my node so let's
see what happens if I do a violation
like let's say classic rookie mistake
I'm visiting other nodes before
relinquishing leadership event so I take
ownership event I'm visiting its
neighbor which is any self some doing a
double take there's going to be an error
message at runtime that says that the
take instruction failed the error
message could be better I'm going to
just skip on that bracelet that's about
all for that extra layer it is very
important otherwise there would be a
whole class of programs that we can
write like any realistic program
so this is about delegating the
ownership of the individual nodes to the
graph the whole point is that dynamic is
a dub lickable type that contains no
ownership information there's a runtime
test that guarantee is that the whole
thing works it's already about an hour
so I may go a little bit faster I'm
going to talk about the implementation
of metal so I designed the language with
my advisor and I was mostly responsible
for the implementation so what do we
have now we have a working type checker
a compiler that emits a camel coat with
AB magic there is a big implementation
effort for the type checker we have a
chip module system wat net sheet we have
a module system as you saw which has
several modules from state library we
have the error messages we have all the
visualizations that you have seen with
the graphs that appear the web interface
the thing one other that i'm going to
show very soon and we have several
thousand lines of libraries for about
everything mutable data structures
mutable trees iterators we have modeled
the protocol of iterators laziness etc
why is type checking meds so difficult
there's some very complex algorithms in
the type checker type checking is
similar to proof search in separation
logic you have a function call you
basically have to solve the frame
inference problem extract from the
permissions that you own just the
minimal set so that you can run the
function and leave the rest in touch as
you saw permissions that are represented
internally using graphs and we have
another algorithm that is similar to
what is called in the field of abstract
interpretation to a joint in a shape
domain so I'm going to run another
command ok so this program i think i may
it be able to do it this program does
something very silly in the then branch
it's our case a reference and returns a
tuple whose two components are pointing
to the same reference and in the else
branch it's returning at apple whose
fields are too physically distinct
references so the type checker knows
that on the one hand we have this
aliasing pattern where we have a couple
which is defined here so they can judge
a little bit a tapa which is defined
here a reference which is defined here
it highlights in your source code
applications and an integer it comes
from here and here we have that other
tuples with these other references so
what does the type checker do well it's
complex you cannot say that we have if a
top of whose two fields point to the
same reference because that would be not
true here and conversely you cannot say
that you have to physically distinct
references because if the code takes the
van branch you're going to have
something that's not true either so what
the type checker does is pick an
arbitrary side and decides that well the
right component is the double it is a
reference under left component of the
double is nothing it could have picked
the other side so that's an algorithm
that we have this problem never happens
in practice that's completely wacky
programmers don't do that however we
have that I wrote that visualization to
somehow try to explain to the user what
is happening in terms of anything and
the decision that we've made back to the
presentation the type checker also
performs type inference when we have a
polymorphic function we don't specify
the type of application it is inferred
so it's kind of hard to infer because
there's a lot of backtracking involved
you can have multiple permissions from
the safe for the same variable you
always have X at equals x you also have
except dynamic you also have X href
something so there's a lot of different
solutions to explore oh that's time make
this arbitrary choice yes it is very
difficult to have a desktop we have
guidelines like we know how to write the
best I probe function we can show the
equivalence of several types together
but yes the type checker makes arbitrary
decisions there's a lot of heuristics
like there's been a lot of fine tuning
and i would say in ninety-eight percent
of the cases the type checker goes to
the right solution immediately and in
some very complex examples like
iterators or something there's a lot of
backtracking involved on
the type checker is still able to do it
door yes it's very hard I mean I think
it's I would say it's NP complete just
because we have quantification over
permissions so we can say for any
permission p and then if you want to
infer that permission p you have to try
every possible subset of the universe to
figure out what could be that permission
p that you have to pass the function so
in those cases we have heuristics like
we may qualify over a certain p for map
the map function says that the small
function that's being called repeatedly
may have some internal state p and then
because our function types are annotated
the type checker is smart and knows that
the function that is passed to map tells
you which p you should seek to obtain
but in the general case you have to
annotate yeah the techs check also
produces a typing derivation if someone
wants to check it later we don't do it
but we may want to do it later and
there's also other extra modules that
perform fixed point computations we have
that thing called facts the type checker
is aware that list of a is duplicable as
long as a itself is duplicable so that's
something that is computing computed
using a fixed point because of mutually
recursive data types quick wrap-up and
mezzo language that blends many ideas we
are keeping everything presented as a
type system give you strong guarantees
and there's that escape mechanism when
the base layer is not enough what do we
want to do in the future we want to
extend the language we may want to have
some patterns wearing your own a piece
of mutable data but you may want to
share it with someone just as read-only
there's another big question that has
been somehow keeping us wondering is
that if you're doing great lengths to
prove a program how much does that help
you prove it you only have a very clear
ownership structure is that something
that helps you prove functional
correctness can you leverage what the
type checking of a measure program gives
you in terms of guarantees to help you
prove the functional correctness or
programs we may want to try to express
proof obligations as type checking
operations as proof obligations for an
instant
is over see if that works better or less
than our custom algorithms and we also
want to explore a visualization so
you've seen quite a few villages
visualizations that were mostly in a web
browser the reason is I've been
contributing to missoula I wrote some
major add-ons for thunderbird and I also
wrote a book about developing at us for
Firefox and my big ad on this called for
every conversation gives you a
conversation you in forever just like
gmail so it's been interesting in the
sense that add-ons are not written in
standard JavaScript lingo because
they're written using the internal
version of java script that lives in the
missile products i get access to some
nice features from the next versions of
X subscript that is this fracturing
assignment that is a function expression
there's the lead keyword iterators for
each etc etc so that is not research
however it's been nice for the error
messages that I've shown you the ones
where you can see the graphs and click
on the notes to see where they're
defined and also for them sorry about
that step-by-step examples so whoops
yeah I don't think I'm connected to the
internet so it's going to be kinda can I
do that ok msft open ok ok I'm going to
do this real quick let's click on the
tutorial collect ok let's click on the
tutorial again
this not loading okay I'm going to get
back to it later when it's loaded the
web interface that you saw it all runs
in the browser I've compiled the mezzo a
type checker into JavaScript using a
thing called Jessica camel and it only
required minor modifications our dream
is to have an interactive top level when
you can go back and forth and explore
the permissions they come and go in a
visual manner I think I'm reaching the
end of my allotted time so that thing
does not seem to be intent unloading so
I'm just gonna oh yeah works um so
that's the unfinished mezzo tutorial but
what I wanted to show is that thing
which kind of helps me in the tutorial
explain what happens to people so you
basically have two boxes with the
applicable and Anand applicable
permissions and you can step through the
program and see the permissions as they
go go back and forth and explore things
as they happen in real time that is not
auto-generated that's handcrafted I wish
for it to be auto-generated so that's
one of our goals because that's really a
nice way to explain how programs are a
type checked and really we wish to have
everything blended together where your
editor program step through it see the
permissions that's more involved so
really quickly why am I here doing that
presentation I am interested
research-wise in better verification
tools what I learned with meds oh is
that it really is hard to provide a
better experience for users especially I
things get more complex there's a lot of
things to explain I've been spending an
hour explaining meds 02 very component
researchers I don't know how we can
explain that properly to a user we need
to have better tools we have
visualizations interactive stuff that
really makes it easy to understand
what's happening with your program and I
believe that these are research problems
the algorithms for instance to select
the relevant bits of information that
you want to show to the user that's
completely non-trivial showing Alison
drawing the the graphs
is that a good way to explain stuff to
the user that's that's not clear and the
tooling I've been implementing that
thing in the web browser and it's great
i mean people love it they can go onto
it they don't have to install metal
there really is something to explore but
how how do we do it that is also another
question user studies user interface
these are interaction that's not
something to be taken lightly there's a
lot of real work to be done and I really
do believe in the web-based tools you
reach more users you have more impact
deployment is made much easier and I
really believe that there is something
to be done here that is something that's
been explored at MSR too can we have an
ultimate web-based ID I think that's a
valuable research question so really
what I would be eager to do is leverage
the experience that I've acquired with
metal to contribute to the projects that
are being developed here on two axes
there's the types axis there's a lot of
projects that writing types there's a
coca the type system with control the
effects that's something that talks to
me right speaks to me I've sorry
iterations on the design type system
there's also lean do we want to add
separation logic theories into lean can
we somehow we use the implementation
techniques of meadow or the heuristics
of the algorithms that provide to do the
same thing to teach that knowledge to
the smt silver there are programs to be
written FS are so really there's a lot
of experience that would be eager to
apply to existing projects and also I
think all the visualizations that have
shown truly express the i'm
interested in what happens on the web
anything that's something that is taking
place here two things that i'm thinking
of or rice forefront and touch develop
and i believe that is something that i
would be very eager to tackle and see
what i can do about this I've been
trying to do it but I won't have I'm
just only one person so there's only so
much I can do on these web examples they
need to be integrated and i think that
there's a lot of potential here I think
I've overlapped a little bit but that
was good so thanks for the questions and
for your attention
to create a type systems that work for
avoiding data races have you looked at
any of the kind of programs that goes
off any special parallel algorithms I
guess would be a good test for prototype
system one program that I work recently
was like that's very textbook example of
a concurrent queue or you have threats
waiting on a condition variable and you
have to make sure that that is something
that is very neatly typed in mezzo
because we have a dependent type that
says that the condition is that of the
lock code l and it like already rules at
several errors where you broadcast the
condition with the wrong lock or you
mess up so that would be pretty much the
standard paradigm one thing that we
wanted to explore is that here the graph
G that I showed is a uniquely owned so
you cannot have two concurrent threads
trying to take from G at the same time
they have to need they need to have a
lock on the graph G before they can take
notes out of G that is usually internal
nature of the thing and having G
uniquely own guarantees that our
mechanism is sound in a concurrent
setting what we would like to do is
extend that give and take paradigm to
objects that are immutable so for that
you need a compare and swap operation
but that is so feasible so that maybe
would be a novel way where I have a
building paradigm for expressing people
that try to take maybe jobs out of the
queue concurrently and possibly fail so
that would be a fable operations like
parallel are sore
girl Harold mergesort parallel sorry now
the one where you've yeah I guess that
we I didn't write it but I don't see any
difficulty as long as you do it with
lists difficulty usually that case is
that you're talking about indexes into
an array so you have to reason it aside
and get in there that's why I said let's
with an array it is very difficult we've
had an intern work on that and if you
have a race you have to start talking
about arithmetic portions of the array
who owns the array from those indexes to
the those other nurses and that is
something that is still an open question
in meta merge short works well as long
as you use this so you do the partition
you get two different lists spawn on a
ship and then merge them that works with
your ray I don't have any answer for the
array so
if your type systems in place what are
the kinds of programming errors that
would be alone so the first one the
first big guarantee is that program
series new meds o our data rates free so
that rules out every access to mutable
data that is not protected in some way
or another that really is our big meadow
the another thing that we're trying to
sell is that we have that mechanism for
expressing intermediary states so
there's patterns where you progressively
initialize objects so that's something
nice that we can type check as well but
really we did it we built everything
from the ground up with the end goal
being to have an answer for concurrent
programs piece of work that Matt
Parkinson was doing with the midori team
on the M sharp language and it was
published in equal a few years ago
there's many aspects of the system
seemed a bit like that are you can we
know that work and this is not simpler
in about so why did you choose Pacific
we like with they're going to use the
function languages amount ow camel and
how much of this could you transfer to
other languages and like because people
try to do is first up didn't right away
I mean camera offers kind of possible
still what was the main force you you
went there and how much of Italy
languages and like link type qualifiers
something comes to my life when people
try to lowest um so I would say there's
two points i can bring here first one is
that it's mostly a pro sporting and
cultural thing in the sense that in the
team were very familiar with your camel
so we initially went for like something
that goes a little bit further than now
another thing that may be worthwhile is
that i don't know if you heard of the
rust project at mozilla the premise
trying to do the same thing a language
with a control of ownership and effects
they're not using the same mechanisms
they're using lifetimes instead of
permissions but the goals are the same
but there are in a much lower level
setting in the sense that they're
talking about what is allocated on the
stack what is allocated on the heap and
that makes their lives much more
difficult because they have to talk
about the different varieties of objects
depending on where they live and that is
something that we do not have so i think
we simplified our lives by going into
the ml setting everything is heap
allocated everything's passed by
reference there's a garbage collector
and that allowed us maybe to focus more
in the design ideas rather than the
interaction with the low-level world so
I guess the ideas are applicable to a
wide variety of languages but they would
probably run into some concrete issues
if you try to apply them say to a
language that has stagger assess heap
allocation yes no
just a little bit more about the object
layer condos when you were running the
types like the intermediary types that
were I believe you said not to run from
a nominal time yes so you have them
written out as you had the tag and then
you have been hoping early and you have
no named position labels yes set Devine
types yes um so you can only you can
only change the tag to other nominal
types that have the exact same position
labels and the exact number of fields
know the name of the fields do not
matter only the size of the block
matters if you change from tagged a to
tech be your thing gets renamed with the
fields that belong to tag be so we're
structural for the field names in the
sense that they're updated as you mutate
the tags because you can exchange the
type center sorry you can exchange the
tags wait between pretty much anything
that I assume that means that all of
your tags then have to be an assigned
unique ordinates across the entire
program space mm I don't think how do
you distinguish between the tags I
suppose well um type checking gives you
runtime safety so we know the oblation
is going to be fine actually what was
just the tags exist at runtime the
compilation not always that when you
have a data type with several tags
they're allocated in sequence right 0 1
2 3 and then that's used for compiling
pattern matching to discriminate on the
tag that's all we need so we just need
tag numbers to be distinct across
branches of the same time that you just
need that to compile a pattern matching
problem right
between different normal time no I can
only parry mention things from the same
limb no time so many past ownership ye
that also gave the time to the end I I
mean when you when it took all the sheep
from the gap put it like in it I guess
the sealer or whatever that also gave I
to the the viable because before it was
these dynamic and then after that so we
look up the definition of G we see that
G adopts not a I don't know if you
remember it can only even done only
adopt one yes it would be unsound
otherwise and there is something that we
have exploited as well and you can only
have one object adopt one type or you
just do a variant type if you want to
have an object adopt multiple things
they could define a new type thing a of
thing a else think to our thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>