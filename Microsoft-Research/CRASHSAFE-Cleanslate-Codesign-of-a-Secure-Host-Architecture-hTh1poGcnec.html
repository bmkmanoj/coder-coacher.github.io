<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CRASH/SAFE: Clean-slate Co-design of a Secure Host Architecture | Coder Coacher - Coaching Coders</title><meta content="CRASH/SAFE: Clean-slate Co-design of a Secure Host Architecture - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CRASH/SAFE: Clean-slate Co-design of a Secure Host Architecture</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hTh1poGcnec" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
so and I'm going to tell you about crash
safe and so kind of for the first third
of my talk then I'm going to tell you
about two papers I've been working on so
more research oriented on exceptions and
information flow control and on testing
non-interference with quick check and
then I'll discuss a bit about future
directions so since one of the papers is
due in like 24 hours I don't get much
sleep so if I kind of stopped responding
you could reset me or something and so
the crash safe project is a big project
by research team terms we are 40 people
somehow if almost evenly split between
industry and academia most of the
academic people are at Penn most of the
industry people are at be a system one
of the defense contractors British
Aerospace you might have heard about
them it's a DARPA funded project under a
big umbrella program called crash under
which also some people folks here at the
University of Cambridge are funded and
also many people in the US
so the goal of this project is to
redesign but significantly more secure
architecture so a new computer without
having any sort of backwards
compatibility constraints so this is
kind of great opportunity and we are
doing redesigning language system and
hardware from scratch so we have
language people systems people and
hardware people on the project and we
are working together to make this work
well and as a secondary goal more like
personal earth for more formal people
there there is a goal of verifying that
we really got something more secure we
really got something secure well
whatever the notion of secure means for
a whole computer more focused we are
looking at mostly at the security of the
operating system so I I made a break
because it's an operating system if you
look at it from the hardware perspective
it's a runtime system if you look at it
from a language perspective
so you might have heard that computers
today are really insecure and you might
wonder why and one of the reasons for
this is that they were designed really
long long time ago when hardware was
really expensive and performance was the
driving factor in making always harder
and faster and faster in fact faster
security was never a concern however
hardware is now abundant we had many
orders of magnitude increase in hardware
capacity so this is a logarithmic scale
and it's like the usual thing you see
when you talk about Moore's Law and sit
today's systems were designed kind of
around this time yeah well since then
there have been one two three four
orders of magnitude increase in hardware
capacity so hardware is no longer a
problem now but are we using that
hardware to solve today's security
problems well not really or how much of
it are using it for that are you using
10 to the four or five to solve the
security problems so we want to do a
redesign targeting security by taking
ideas well from where I see it mostly
from cool ideas from the programming
language level and applying them also
the system's level and also at the
hardware level well other people on the
project see it differently so we are we
are interacting taking good idea good
ideas for security and and and sharing
them across the layers of the system and
some of these ideas which I like around
this slide so we want to have type in
memory safety in force not at the high
level but enforce all the way to the
hardware and we want to have so that we
get something like
basic abstraction all the way to the
hardware and we want to have
fine-grained protection by an access
control and an information flow control
mechanism that's work on like on
individual values at the language level
and on individual words in memory at the
hardware level so I'm going to return
for all these things and to make it all
more fun we want a base or all this on
on verification in the broadest possible
sense of the work which includes testing
so I'll spend like one slide on each of
these layers language system and
hardware and give you just what i can
give you in a slide about them there's
lots of details like I cannot give you
but you can ask her you can talk to me
so the language is probably the least
surprising from where I stand it's it's
more like a testing ground to tend to
try out ideas which will later port on
to the other layers it's a type and
memory safe language but dynamically
typed and it has dynamically checked
contract so that so that it recovers a
bit of the niceness of types it's a
functional language with state and
concurrency it does message passing
communication so no shared state between
threads they just communicate over
channels and it has this built-in
fine-grained protection mechanisms so
this is the new part I mean up to now
scheme scheme I guess has that so it has
security bility and it has security
labels attached to each value things
like this value is public this value is
secret and then it has dynamic
information flow control to track these
labels through the computation and to
taint
secrets this to taint values the depend
on secrets also at sick our secret and
then based on the same lay labels we do
access control and this gives us an even
more powerful attacker model then for
information flow control so if your
untrusted code and you don't have
clearance you can't even touch a value
you cannot branch on it you cannot
compute with it and then try to to to
use side channels or things like this
you have to be completely polymorphic or
parametric in that value you have to you
can pass it around but that's all you
can do so this is the access control and
then we have a novel exception handling
mechanism and the second part of the
talk will be about that now the run time
or the operating system is simple it has
it has a scheduler an alligator and the
garbage collector it has channels which
are used for both for inter process
communication and for communication with
devices so like infinite size buffers
which resize automatically and it has
well this dynamic information flow in an
access control as a protection server
which which I'm going to talk about we
call this sometimes a zero Colonel
operating system because this has a TCB
that's even smaller than a microkernel
in particular this is not monolithic so
because a microkernel would contain
things like paging and things like that
while this protection mechanism for that
word is more lightweight than that also
the thing is compartmentalized so broken
into tiny pieces which which have the
list
they need to operate the scheduler can
schedule threads but cannot say for the
pointer while the allocator might need
to forge a pointer or to do some fancy
things with pointers so in the end even
if one of these components of the
operating system gets compromised even
then you cannot do more than what that
component could do one it's all maybe if
you if you compromise the scheduler you
can bring the system down but you can
still not read everybody's secrets okay
so this is about the operating system
else for the hardware I think this is
where the funnest things are and most
novel because at the hardware level all
the instructions have a well-defined
semantics and abstractions are enforced
we have fat pointers so you can't write
out of frame bounds you cannot do buffer
overflows jump to lipsy stuff like that
because we also have dynamic types which
prevent you from forging pointers for
instance you cannot turn arbitrary
integers into pointers which means
pointers are unfortunate E as they are
at the high level in a safe language the
point is says have big V so the thing is
so you can't access how to balance is
that well well so the didn't suppose
that so that so with each pointer there
is a base on the bound so then in order
to make sense point is how do we do that
by allocation that is the allocation in
in Hardware know so there is there is a
privileged instruction which can forge
pointers but the privilege to run that
instruction is only given to the
allocator
and not no other piece of code in the
system will ever have that privilege you
can forge pointers but that's mainly not
enough to mount a full-fledged attack
you might still not be able to turn an
integer into an instruction forests
which might be necessary to do a buffer
overflow so this is the this is the next
point so okay the the one after the next
point so I come to it we have lambdas
the closures at the lowest level and we
have a protected call stack at the
lowest level and we have authorities and
gates and I think this is to answer your
question we have a notion of authority
which are first-class values even at the
hardware level but most of the times
they're not really used like that but
they're used with something we call
gates so the gate is you can think of it
as a system call it's an authority
changing lambda call or whatever
function call and the nice thing about
it is that first with the gate mechanism
you don't play with the authorities as
first class values but you just create
this gate pass this gay to untrusted
code and the only thing the untrusted
code can do with this gate is call it
and when it calls it it's like a system
call it just takes one instruction as
opposed to what it takes on on or normal
architectures so so we have very cheap
system calls which means you can really
break things into very many tiny
authorities or make many tiny protection
domains and then give give each
protection domain the least amount of
authorities it needs to do its job
because it's very cheap on modern
hardware it's the most you can do is
like I don't know four rings or
something and nobody even uses that
a system for the most one hardware is
also a single instruction but that
doesn't tell you anything being in hell
of a performance you mean because you
have to flash pages Invictus well it's a
multi-cycle operation that involves TL
beach and registered sheriff various
other things on either side so what what
sort of performance relative to a normal
function cool you're cool gate not any
more than a normal function called there
can still be cash locality prob I mean
they cannot when you whenever you jump
there can be especially on long
distances there can be locality prices
to pay but that's all the thing on the
other side what do you have some
mechanism for saying you can't access
these registers to the other side of the
pool we do have some mechanism I don't
discuss it tho you gotta thorities gates
labels fat pointers it's hard to know
what all these things are at this stage
but you're going to tell us well no not
really so you better ask now okay yes no
maybe so this is at this point I'm so
the first part is about the project as a
whole I definitely contributed to the
project and especially to breathe like I
was one of the main designers of grease
and i participated in like all the
meetings for designing these things as
well but and this core design thing but
i'm not a hardware designer though i'm
just telling you to give you some
background about where what i'll present
next the seats in the whole thing sizing
complexity the implementation of the
hard way
I is is it how many you know do you is
there a lot of complexity hidden under
this Maya in the market salad or in the
in the oven well I think up to this
point things are quite easy I think I
have one more bullet which is the
complicated part and and it's all
implemented in blue speck so it's a it
is done by a couple of people so it's
not it's not like most of the team works
on on designing hardware and I think the
most interesting feature of the heart
there is this the programmable tag
management unit so tag you can think of
it as an IFC label although it's more
general than that but for for this talk
you can think of a tag as secret or
public or something like that and every
word has a tag with an arbitrary pointer
so if you have a 64-bit machine you have
64 bits of payload for each word and 64
bits of pointer which allow you to be
very flexible about the kind of schemes
you support what what this thing really
does in the end the operating system
doesn't really interpret this pointer
all it does is on each instruction say
if you have a public integer and you try
to add it to a secret integer it's going
to take the late the ALU is going to
take the numbers and add them and in
parallel this T mu is going to take the
tag of the first integer in the tag of
the second integer look at the map in a
hardware rule cash so addition of a
public to sort of arithmetic operation
of a public and and the secret and if it
finds that in a hardware rule cash it
hits and it doesn't it take it doesn't
take any performance penalty if it
doesn't it traps the software and that's
this is where this protection server
comes into play because then there is
part of this operating system who needs
to decide well is this operation allowed
or not and if it is allowed what is the
tag on the result so if you
public + secret well the results should
be secret and this allows to do for
fine-grained access control and dynamic
information flow control at the lowest
level so at the system and hardware lab
working to get thank yous guys need to
be implemented in the same sort of way
as a TLB and tail visiter camps which
are very expensive and on current
systems TLB misses are the main
scalability bottleneck or
compartmentalizing software so if you're
saying compartmentalize software using
some of those it implements in the same
way as a TLB button me more entries in
it that seems like the opposite of
scalable metallization well so at this
point we are not yet at the point at
which we really have experiments to show
what the impact of this it can be indeed
very big especially since well trapping
to software can be in thousands of
instructions for an addition so the
price to pay if you miss is very big
however we also can use a big amount of
the area for this cache and there are
some clever techniques the hardware guys
are doing like hashing and things like
this to to make this work reasonable we
don't know yet if it does we can use all
the area for this if you saw here you
for this you lose the area for
everything right well on our SVG we are
like people using thirty percent of the
of other FPGA currently case in space
over here where are you managing it in
some kind okay so we are not we are not
concerned with space overhead I mean
unless we really run out of fpga cannot
be one instruction we can use of the
available die for this right no this is
not our notion it was the site was
trying to simplify it's not Beca it's a
gross oversimplification
wanted to counter Phi so you are
consuming twice as much memory and twice
as much memory bandwidth for every
memory yes Oh however well yes for the
tags the pointers are encoded using a
compact scheme which encodes base bounds
and the pointer itself in just 64 bits
so but fat pointers that's why i call
them low fat the fort for pointers we
don't have a real overhead on a 64-bit
machine for tags we do well this size
there is a size that do something for
how much you can dress the one pointer
no we can we can address I don't know
something like 2 to the 48 or something
like that we have some sort of how do
you call this floating point like
encoding for pointers where you you you
have some fragmentation and something
like that but it's on the order of one
percent person as far yeah yeah whose
looks personnel our experimental around
one percent I've got the hardware guys
experiments or around one person they
have a paper about I can point you to it
ok so that was about the architecture as
a whole now some some things I did some
research things I did I also do have
done a lot of implementation and design
and things like that but this is like
papers so the first is about robust
exception handling for sound fine
grained dynamic information flow control
sound in the in the sense we get a
security guarantee called
non-interference as opposed to just
doing tain tracking and you don't get
really any guarantee fine-grained in
that we we label that each value and
each component of a value separately
dynamic in that it's a dynamic
enforcement mechanism and usually the
dynamic which
mechanisms whenever I whenever I saw
from for the first time dynamic IFC I
was like okay what do you do when when
something goes wrong and this is what
I'm tackling here we since breeze has
such a mechanism we wanted to do
reliable error recovery in breeze and
this imply that we wanted all exceptions
including information flow control
violations to be recoverable and the
problem is that existing techniques for
dynamic information flow control for
sound fine grained dynamic information
flow control assume that you can just
stop the Machine whenever a fault
happens so something called stop the
world failure so they this make some
things easier like you can get secrecy
and integrity but at the expense of
availability so in a real system is it's
not conceivable that it just stopped the
machine whenever something goes wrong so
we wanted the information flow control
exceptions to be recoverable and however
information flow control exceptions
reveal information about labels and it's
well known in the I mean labels are like
a runtime entities they in a dynamic
information flow control cyst system
they really attached to values and they
flow in the system is not just something
that happens in the type system or
something they are attached to run time
values and it's it's well known in the
literature that the these labels can
themselves leak information and usually
what you see in the literature is you
can prevent secret either from liquid
into the labels or from or labels from
being observable and if you buy them if
you make if you hide labels you can
allow labels to depend on secret and if
you
and this in certain cases gives you like
more permissive enforcement mechanisms
there is even a paper by Austin and
flanigan we're called permissive
information dynamic informational
control affect execution in some way so
as soon as you can affect execution
there's a child like so does it is a
non-starter well indeed this is a lost
art and this is what I'm going to get it
done it all started so I I can show you
a counterexample to it on it or
everybody agrees that the non-starter so
let me show you counterexample to it you
have a secret bit and you have three so
this this late s is labeled secret but
you have you have two more labels public
label and the top secret label and you
can encode the secret as a label so you
can branch on the secret and return
always the same dummy value but on on
the eve branch return the secret itself
sorry Victor something label secret on
the else branch return something labeled
top secret something even more
classified and then we can assign this
value to a high reference it's like to a
secret reference rate and if you are on
this branch the assignment works if
you're on that branch the assignment
fails and if exceptions are recoverable
if I have see exceptions are recoverable
then I I suppose you can catch them and
return different values when you catch
them so Simon was convinced from the
start but if labels must be hidden then
information flow control errors much
must be hidden too and that's exactly
what we don't want we want to recover
from them so we have to prevent secrets
from lib it from leaking into the
labeled Channel so we have to enforce
that labels don't depend on secret and
this is the example I had before of of
of branching on a secret and
and then choosing the label based on the
secret so what can you do with this
example how do you protect it so the
first solution so the solution for this
problem is to use something we call
brackets which choose the label of the
conditioner based well before you
actually branched so it cannot be based
on the secret and if you choose wrong
then I'll explain later what happens you
get an exception but it's it doesn't
break anything and so the label you
choose here if you want that both
branches of the conditional to succeed
has to be above both secret here and top
secret there and then the secret is
going to be topped up to top secret so
on both branches are going to get units
at top secret and you won't have a leak
now the second problem which has nothing
is not specific to information flow
control errors is general to all
exceptions is that well exceptions
change the control flow graph quite
significantly and in particular they
interact very badly with this bracket
construct and this is how it works so if
you have a secret bracket in which you
branch on a secret and then either throw
an exception or do nothing and and then
catch this exception in a lo conte in a
public context and return true if if if
you caught an exception and false if you
didn't then well you've just licked the
secret so throwing an exception from a
secret context into a public context
well this is bad and this example shows
why so we cannot allow exceptions to
propagate beyond that point beyond the
end of the bracket which means we need
to delay them because we still need some
information that something wrong
happened we cannot just swallow it or
something like this so
brackets need to delay exceptions
blackest need to be like a control flow
what join point and in order for them to
be sound so so now this example with the
secret if the secret is true then we
throw an exception however it gets
delayed and it gets labeled with secret
if you don't throw an exception you get
a unit because you didn't take the else
branch it gets tagged with well it's a
success whatever and it gets labeled
with secret so now both things are
labeled with secret but now both things
are valleys we don't really want them to
be values and then I'll return to this
but they need to behave like values well
similarly when you have a failed bracket
and this is i told you i'm going to show
you what happens when you miss label the
bracket so this is the mislabeled
bracket you try to return 42 a top
secret and then say label that secret
you're going to get an a value which is
labeled secret as you asked however
inside it doesn't contain anything about
what you want it semantics for bracket
the labels and values I kind of had the
idea that if you've got a value labeled
with one thing in you and you've got
cells references label with another then
you do a check when you assignment that
I kind of vaguely get that book so
what's the semantics that you have in
mind for these Blackett things so that
it I didn't show you all the ingredients
necessary for that semantics but I can
give you like a one-minute explanation
so the in in dynamic information flow
control systems there is a notion of a
pc label or like a current context label
which truck which tracks on other how
many high branches you are so if you
branch on a secret your pc or all of a
sudden gets high and then in the
branches of a conditioner like when you
when you branch here here the pc is high
and what the bracket does is when you
end the bracket it restores
bc2 to what it was at the beginning of
it so it it says this is the end of this
high context let's say we are we are out
of it it is a scope it gives it gives
the scope for the like you go ha you
branch on secret at some point you have
this control flow join point and you say
ok now I'm been branching on secrets i
can continue in the low context again
and that's what the brackets to in
previous systems without brackets that
happens automatically on all control for
joint points but they don't require that
you give a label on all beginnings of
things that eventually join which means
they cannot enforce this they cannot
have this public sound public labels
they cannot have labels and ifc
exceptions be observable in those
systems will affect the ambient level
and hear your conditionals do not well
only these buckets do instead yes and
has an advantage ok sensor so i mean you
could you could in line brackets i mean
kind of have an if Blass bracket
construct but but then it will have to
take a label so and then you would have
to have a function called last bracket
and things like that so in the end it it
takes this pattern and it gives you a
general construct it does it soundly ok
so we need we need delayed exceptions so
there are somehow unavoidable and I
believe they're unavoidable however we
still have a choice on how to propagate
these delayed exceptions and we looked
at more alternatives but there are two
main ones one is to have the normal Java
like or whatever like medulla like
exceptions in which you missed mix
active and delayed exceptions so you
have when division by zero happens real
exceptions gets thrown when a bracket
at the end of the bracket this
exceptions gets delayed becomes a value
and as soon as it touched that value the
exceptions get gets three throw
reactivated so this is one thing you can
do and we study this mechanism however
we have a more interesting mechanism
which only delay relies on delight
exceptions for for exceptions handling
we called this delayed exceptions not of
values like not the numbers but they're
not quite the same their first class
replacement for values that propagated
solely via the data flow they're labeled
and they're pervasive they can appear
everywhere and this is a simpler and
more radical solution which we
implementing breeze it's simpler because
the other one also has delayed
exceptions is just they also have the
other ones so what exactly is enough or
what does it contain it contains
debugging gates so first if you've
divided by zero you're going to be told
that if / 0 so it's it's more than a
null even more it remembers the stack
trace at the point at which the map was
created which is again different than
nas or things like that which well if
you get the stack trace you get it at
the point at which it references which
might be very far away and get the
propagation trace which shows you how
the exceptions made it four from the
point that was created to the point
where you touched it or were you got it
where the printed edition so this this
would help programmers understand well
where these things come from and how how
they work and however we we might not
want to be fully precise in the
semantics about things like error
message the stack traces and propagation
traces so we might want if you want to
have
a very efficient compilation we might
want to do the Haskell click and have
impress Isaac exceptions in which well
maybe not on locations will appear in
the propagation race or maybe maybe the
error message will be of another
exception that could have been raised by
that expression so if you are willing to
give that up the compiler guys in our
team like Greg Morris I think they can
make this really efficient and simple
for in the compiler now there is this
something funny about this there are
still some choices one can do about navs
so if you add enough to an integer
you're going to obtain the same knife
with with a with an extended propagation
trace labeled well by the join of the
labels however for for operations that
don't really use the value that I just
pass it around I call them parametric on
the slide then you have a choice yeah so
if you if you just apply a function to
enough should this just bind the
variable to the nav and continue or
should this just returned a nap so this
is something like nav lacks not strict
behavior if you concern after a list
should you get a list containing an
average should you get enough or if you
write a reference should the reference
contained an average should just should
you just get the nav and the reference
be unaffected so you have you still have
this choice about whether to be enough
Lacson enough strict yes kill then you
construct doona including both and so is
this is the old map the only thing that
changes is the propagation trace is
going to record the location of the plus
because it propagated to navs each other
your own propagation choice in your own
sauce now you get here it is exactly
where where this in precise exceptions
could come into play if you do in
precise exception you get
either if you do precise then we are in
a left-to-right call-by-value language
you should get the first maybe you
should get both well so okay now you as
language designer we can choose between
these two the advantage of not strict is
that it reveals errors earlier but the
problem is that it introduces additional
constraints to the information flow
control mechanism because if you do this
if you you're basically not executing
the body of the function so you have a
new control flow branch going around the
body of the function not executing it
which means you're going to have to
raise the pc and now i explain what the
PCs and so so so it makes it harder for
ifc in fact if you apply enough
strictness everywhere you get a an
exception mechanism which is very
similar to exceptions but which is
completely useless in this setting this
because as soon as you have a bracket
and it restore the pc your context is
going to force and see is this enough
and it's going to raise it back again
which means brackets become completely
useless inside in in such a if you would
do latin of strict anywhere additionally
if you are in a lazy language you will
also force the whole language to be
strict so it would also not work in lazy
language to be enough strict so in
breezeway we allow the programmer to
choose in particular the contract system
and allow us to specify do you do you
want these functions to be strict in its
argument or not in the formal
development we just take novel acts as
the default and then have just one last
recons construct which branches is this
enough for now now we proved
nation insensitive in coke for a couple
of calculi one with knives one with both
delay than inactive exceptions and one
just with brackets but without
exceptions at all and and for the nav
calculus the proof is done with all the
debugging aids so even with all the
debugging aids you don't lose
non-interference and the proof is Error
sensitive in a sense which we don't mix
termination insensitive and error
sensitive we are clear that errors are
separate from non termination we know
termination is hard to deal with but
errors we can build it and additionally
we proved we provided translations
between some between most of these
languages showing that they're entering
code the ball which at least the same
extent gives some intuition that the
these things have equivalent expressive
power however you can also look at which
one is more complex and which one is
simpler and things like this and which
all of them are anyway whole program
transformation like they like the air or
more adding coding so so we're going to
do this and everything and now you see
me sir other point about these these
three things up and you seem to be
saying something without the Nabi stuff
that was terribly important turns out to
be equivalent well it's not quite
equivalent it's incredible with a full
program transformation the same way
exceptions are encode the ball in the
language without exceptions by a full
program monadic transformation this
doesn't mean that exceptions are not
useful does it mean this difference
formations are quite complicated do you
write the writer program ten times the
size if you and work in the image of
that transformation it's theoretical
result it could also help for instance
before we had we didn't non-interference
proof before we had this
we did them for each language
independently if we had this results
before and fully proved not just quick
check we could maybe just transfer
non-interference results from one to the
other okay so summary we can do
exception handling even in the setting
of sound fine grained dynamic
information flow control systems I
presented two mechanisms where all
errors are recoverable even information
flow control violations the necessary
ingredients for this are sound public
labels and delayed exceptions and I
really want to stress this necessary I
think maybe didn't come across in this
in this talk but we really believe that
you cannot do it without these things
that you're really forced to have
something like this if there are nerves
or the other kind of things we
investigate and it's a quite radical
design I mean none of this is compatible
with JavaScript but more most people
look at when they talk about dynamic
information flow control it would
require changing the semantics of the
language is not something can do without
touching the language and we believe
that this is applicable also to static
information flow control settings
especially the idea of delayed
exceptions there are many papers which
do quite horrible hacks to to recover
precision in the control flow graph
which was lost because of exceptions in
fact there are also case studies that
show that when an information flow
control type system fails or such tools
fail most of the time they fail because
of exceptions they fail to type check
the program because of imprecision and
the program is still correct so if they
work to do something like delayed
exceptions then they they just avoid
that problem but they might need to
change the language now the third part
of my talk I'm going to tell you about
this recent work on on testing
non-interference
using quick check so the police
protection server so the piece of code
that gets called when when the TM you
mrs. in that cash in that Harbor roll
cash well is the most security critical
and novel component of our architecture
so is the best target for verification
and again verification the broader sense
so that the idea is we want to have the
real machine running this protection
server and prove non-interference for it
or some securities or some other
security property but in this talk I'm
focusing on non interference so we want
to prove non-interference of a real
machine running this real piece of code
and we do this by designing an abstract
machine that does dynamic information
flow control magically like a part of
its semantics and act as an executable
specification for this piece of code and
then prove non-interference for this
abstract machine correctness for the
protection server with respect to the
executable specification and then
hopefully put these two pieces together
and show non-interference of the of the
real machine running the real software
now I'm only going to talk about that
part and the question is can we quick
check an abstract machine for non
interference can we check the
non-interference of an abstract machine
and another thing which I didn't mention
it is this more this is part of a much
bigger stack of apps more up more
abstract or more concrete machine which
wouldn't be necessary if you were to
prove the security of the whole thing so
here you might have intermediate
languages of the compiler or something
and here you might have things like that
abstract or that implement a locator or
the garbage collector or or even lower
pieces of the
of the system so however we just focus
on this one slice of the cake the
abstract machine which which acts as an
executable specification for the dynamic
information flow control mechanism so
now quick check is a property-based
random testing tool for Haskell and so
can we use that to verify this property
now yes and we've done it for a very
simple machine which we call the Pico
machine it's a simple stack machine with
ten instructions and they fit on a line
I don't think I need to explain them
designing a machine even a ten
instructions machine with dynamic
information flow control is tricky I
don't have time to really explain this
but things like this no sensitive
upgrade done on on stores well published
in 2009 so it it's not yet quite a
state-of-the-art but it's not very far
behind the state of the art in in what
the information flow control people do
so this is a very simple machine so we
could prove no interference for this
machine in one week in so you might
wonder why Bob however we hope that
quick check will scale better than
for doing the real thing which well has
ten times the number of instructions but
Benjamin was doing a like
back-of-the-envelope calculation is like
a thousand times more complex so if if
this one week is multiplied by a
thousand then that's already too much
for us but we hope that with quick check
we can do it faster
well there so first no interference is
not the simplest property you can
imagine so there is something about the
property and second there is something
about the degree of confidence in
finding box you sure you can you can you
can flow tests at at the piece of code
and if it doesn't find anything be happy
but say you introduce bugs how do you
say systematically on purpose will this
framework find them so so this is more
most of the things can you can actually
find all the bugs fast not just where
can you run tests against the piece of
software program with an input that is a
few numbers you can sort of and early
general assemblers but here you think
you're trying to test is the space of
all programs yes all the people that the
pairs of all the tiers of programs like
so that's a very big space and a lot of
complicated one yes the invalid programs
that it's sparsely populated and very
large yes that makes it a hard test case
yes I exactly cool okay so how do we do
it so first I told her that we inject
these bags in order to test to testings
and we do three things we have clever
program generation strategies which you
have to believe me that they really
improve things a lot like for this
injected bags like an order of a
thousand or something in how fast the
bugs are found or if they're found at
all then we have linking of counter
examples you don't want to present I
don't know 100 the instructions program
when a three instructions program is
enough to to falsify the property
especially if you are doing this during
the design process where you where you
discount that example really help you
change the rules so that you get them
right and then
we've noticed us testing stronger
non-interference property improves
testing quite a lot and that's that's
the part with which I'm going to focus
on so we have these security properties
you don't need to know where they are
just um however what you need to know is
this this is stronger than this one
which is stronger than that one and
that's also stronger than that and then
we have some property the weaker
properties is what we actually want in
the case of successfully terminating or
like looping forever programs these are
the properties which we can easily test
no intersection and these are the
problems we can hope to have inductive
or Co inductive proofs for so you see
there is an intersection with an
inclusion and this thing is usually
called unwinding conditions in the
literature so I'll skip what they are
and just go to the experiments which
showed that well stronger properties
describe bark barks much faster and this
is like even more bugs it even more
complex machine well more the other one
was like six instructions on this one
step the ten i showed in front so these
are the properties in like this is the
strongest and this is the weakest thus
the the weakest properties use the most
sophisticated regeneration strategies we
could find well the strongest property
use something either fully naive or well
slightly better than naive and again we
get almost 100 factor of 100 improvement
in how fine we cast we can find those
bugs no so so our machines have so our
machine has all these properties we
could actually prove this property in
cox so in order to guarantee the
property of a server loops or whatever
the weaker properties are the ones you
want so it might be that
chain war program that didn't satisfy
these stronger properties was actually
pleasantly line yes it could be that you
can construct a machine which has the
weaker but the stronger property and I
believe that machine will be quite weird
but our machine does have all properties
so and I believe even our real machine
has all probability so yes so it's like
the inductive invariant you would need
in order to prove the weaker one so okay
i'm almost done so this stronger
property is very cool i mean it can find
it can find bugs in the order of
milliseconds on the average and well
almost milliseconds also on the worst
case out of this 14 bucks of course if
you're stronger property refundable
faster really surprise me well how much
faster it could be zero point or 1.2
times faster or something while well
this shows like a hundred times faster
and so so well you might you could say
sure always use this very strong
property however this property requires
discovering stronger invariance than all
the other properties so so I didn't show
the property so it's hard to explain
this but you know in order there is
there is a trade open in both we're
proving that this implies that and that
implies that which we've already done so
you could say that's once and for all
but there is also a trade of in using
this property because you need stronger
equivalence between states which require
require you to discover invariance of
your machine things like rich ability
and can be complicated invariance so for
this machine they were very simple prop
invariance but I will know to tell you
of the CAF now what the invariants are
for the real
safe machine and how complicated the app
they are probably very complicated so
which means yes if you have the right
invariance you can apply this property
and you will need to if you were to do a
proof so if you if you see this just as
the first step towards a proof then SSN
I is the right property however if you
if you just want to test things and you
want to make sure to find some bugs well
I think this might be the right one
because it doesn't require stronger
invariance and it still performs quite
well yes so quickly is discovered in
variance but no quick check is giving
you counter examples if you didn't find
the right okay yeah so it can help you
find the right in there it but they
still won't find them for you property
that you're trying to check for you
nearby variance here well so this this
SMI properties parametric in the in the
indistinguishability relation use on
states and the indistinguishability
relation you need for SSN is different
than the one you need for lln i and and
everything above it's much stronger it's
like the usual thing with strengthening
the induction hypothesis yeah so you
need to strengthen the induction
hypothesis because it before you can use
it yes okay I have to find the slides so
first I have lots of ongoing work on
this project the first bullet is about
proofs for all of this so we have the
diagram I showed you with both the
vertical and the non-interference
property the correctness and the
security property we have proved for the
Pico machine and we are working on a
slightly more advanced an interesting
machine and then there are lots of
things which which I might might not do
depending on how much I has to work on
this project some future directions I'm
very interested in in privacy and in
curity protocols for and security
applications for which guarantee privacy
and especially one so based on zero
knowledge proofs so things like and so
the knowledge proves that allow you to
do things like you can prove that you're
over 18 years old without revealing your
age by cryptographically but in a way
that that's not for jable or and this
III de mixes is the IBM project you
proved is a microsoft project so this
seems quite a quite a big upcoming
technology which starts to get practical
applications zero knowledge proofs were
were quite expensive and until recent
advances something else I find
interesting is applying this fine
grained access control and integrity
protection to mobile devices so that's
all from my side thank you did you
compare it to any other testing tools we
are not aware of any other testing tools
for no interference we tried some
experiments with no no I mean we have
this framework which we built for
testing or interference there there is
no such framework and as far as I'm not
aware of so that we didn't have anything
to directly compare against we tried
doing something similar with a symbolic
execution beistle courtly but it was
able to find only the very simplest bugs
and in the term in a matter of minutes
while we find them in like a matter of
milliseconds another please another
example the former verification people
move into testing but there's
like traditional testing techniques that
is use any of them well imagine Michael
for example has a testing regime uses to
choose any of these like traditional
testing techniques you mean by unit
testing well that I mean I didn't show
but when we are generating something on
the order of 20,000 programs per second
to test the property with so we can and
we have we are working on good
distributions and things like this you
can feel it five unit tests but what
what will that tell you I mean the unit
tests in general are are as good as I
mean are better than nothing but
compared to property based random
testing I don't think they they're on
the same scale Simon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>