<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Frog Model on Trees | Coder Coacher - Coaching Coders</title><meta content="The Frog Model on Trees - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Frog Model on Trees</b></h2><h5 class="post__date">2016-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0t84W2kXkxU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
all right good afternoon everyone so
we're delighted to have Matthew from
University of Washington and I see his
co-authors Toby and Chris are also here
and he'll be telling us about the Frog
model on trees please so thanks everyone
for coming and I will be talking about
the Frog model entries and as you've all
just pointed out this is joint work with
my advisor chris hoffman as well as Toby
Johnson so first let's start with the
definition and we start by fixing a
graph g and i was introduced to this
problem on the binary tree so typically
i think of a binary tree when i think of
the frog model so we'll start with that
and the model earns its name because
we're going to put frogs on this graph
in particular will place in a wake frog
at the root which is any distinguished
vertex and i'll call it V naught
and we'll place a sleeping frog at every
other vertex
so you can actually let's do that on
this graph I'll put an awake frog at a
natural place for the root on a binary
tree is the route and will play sleeping
frogs everywhere else to set this model
in motion what we're going to do is have
a wake frogs perform a simple nearest
neighbor random walk and they'll wake
any sleeping drugs they visit so awake
frogs do a simple random walk and they
wake any sleepers they visit and by
visit I mean land on the vertex data
sleeping frogs occupying
it couldn't hurt to just look at a
couple steps of the evolution of this
model so at time zero we have one awake
frog and now in discrete time he's going
to choose one of his neighbor's
uniformly and jump to it so let's say he
jumps to this neighbor here and he's
going to wake that sleeping frog up that
he landed on now we have two awake frogs
and independently they'll do their own
simple random walk choose a neighbor and
jump to it with uniform probability say
the frog that just woke up jumps back
and our initial frog jumps forward to
here so we have three frogs and they'll
continue doing this and that's giving
our random model its dynamics and for
concision I'll refer to this as fmg for
the Frog model on the graph G now this
was introduced in the mid-90s by ravi
chakka and the first paper came out in
99 from couch in warm old and i'll say
something about the result in a minute
but first i want to give this some
context by talking about some similar
models that have come out in the last
decade are there any questions about how
i'm defining this model the main ones
that I get is our frogs allowed to move
backwards and yes because they choose a
neighbor uniformly and is there any rule
about multiple frogs on a site and no
there's no rule about that you can have
as many frogs on one vertex as you want
because once they're awake they don't
interact at all oh yeah this is will be
talking about an infinite graph but it
makes sense on a finite graph two
different questions though
so activated random walk is a model that
was introduced by i believe it was first
studied by benjamini oh no add that
backwards by dyckman rola and sitter a
vicious in 2009 and this resembles the
frog model because we have infinitely
many particles and they're going to move
like simple random walks on their graph
except we allow the possibility they
fall asleep and then they can be
reawakened by other frogs and the main
result in that is they actually look at
a random number of frogs at each site
and see if they vary that parameter when
you see a phase transition between all
the frogs being awake or not all the
frogs always having some awake frogs or
every frog eventually falling asleep and
something that came up in 2003 what is
known as excited random walk and this
was studied by benjamini and David
Wilson
now excited random walk is actually just
a single random Walker there's only one
particle and why it's excited is upon
its first visit to each site on the
graph it has an extra drift in a certain
direction so say you're on Z the first
visit to each site you get an extra push
or an extra bias right word in the
positive direction and they actually do
study this on ZD and they prove that for
every d the model is transient with this
drift and why so with activated random
walk the parallels are pretty obvious
there's well there's not really many
particles they're moving and they're
interacting in this way and excited
random walk also a similar to our model
because say that we just get rid of all
the frogs and start with a single
particle at the root we could think of
the Frog model as an excited branching
random walk we're up on the first visit
to you site branches into two particles
and in a similar way that they studied
recurrence transients that's going to be
the question we also look at so let me
get the definition down before we get
started so we'll say that fmg is
recurrent and I'll review it with re see
in the future if the root is visited
infinitely often
with positive probability and otherwise
you say it's transient
so there is that ok that definition the
with positive probability is the main
thing about it other any questions and
this has been studied in two previous
papers and particularly the very first
paper about the frog model was about
transient recurrence and that was on ZD
does anyone want to guess what they
found on ZD for the frog model yeah they
found its recurrent for every d
and another variation that was studied
was also on CD or in particular just the
integer Z and this was Ganter in Schmidt
in two thousand eight they looked at fmz
with a drift and they also let a random
number of frogs be at each site let's
say NK and then they classify what
conditions on NK guarantee recurrence or
transience of the frog model and they
find that fmz with this drift doesn't
you only guess what the condition on NK
is that might not be as obvious they
find that it's transient if the log of
it has finite expectation and otherwise
it's your current
so in this paper this is 2080 in this
paper they leave as an open question
what's the transients recurrence
behavior on a binary tree and in an
earlier paper by Alva's Machado and
Popov they asked what's the behavior on
just any de area tree in terms of
recurrence and transients with just the
one per site model so the reason this is
an interesting question or is not a
trivial question is we see on any tree
there's going to be say on the binary
tree there's two edges leading away from
the root in one leading back so there's
this strip which says that any single
Prague is going to escape to infinity
and the question is can the collective
effort of waking frogs overcome this
drift and visit the root infinitely
often and that's the result of our main
theorem sorry good question is this the
wrong with the special because it's an
just one then it would be transient so
this is with trip Oh and Owen what's
interesting about this is this or does
that make sense and what's interesting
is this is independent of the drift this
condition
so what we consider is the Frog model on
TD which is the rooted dierry tree and
we we end up showing that doesn't even
want to guess what the behavior is you
didn't read the abstract on the tree how
about diego's too there's no drift no
there's no drift except the tree
structure is in creating this natural
drift there's one frog one frog per site
yes so we found that D equals 2 is
recurrent and we found that as we
increase d there's a phase transition
where it switches to being transient our
proof covers the cases up to five so we
know for d larger than five the model is
transient and from simulations we have a
conjecture for the remaining two
dimensions or degrees in particular that
D equals three remains recurrent and D
equals four is where the switch happens
to transients so no one was conjecturing
any phase transition with regards to
this so we're excited to see that and
this recurrence result came after the
transients result and is what I think
I'll spend most of this talk talking
about I found out i have ten minutes
less than i was planning so i'm going to
say a little bit less about the
transients case but i will still give a
sketch it is the
we're an earlier whether the phase
transition is actually I bet three or a
four or a tree and a half or something
all right only from looking at our
seniors simulations I think it's very
close to three and I'll say a little bit
more about why we think that at the end
of the time but we don't know exactly
it'd be neat if it was exactly yeah if
you collapse the tree to a line and then
put one frog and then two frogs and four
frogs and eat frogs is it somehow relate
to the tree prep well that that one will
be recurrent because you know because of
good that's gonna that's going to say
the Frog that's going to be this model
where every frog gets woken up as you go
out so that would be a recurrent and you
could put it you could actually put the
same drift and that would be recurrent I
think it would or it's deterministic how
you're placing them but that's that's
actually just the right amount of frogs
to overcome the drift be or if you look
at the quotient of these two drips you
see that you need there's a bias of two
to the negative K to getting back so you
need some constant fraction of each the
frogs in each distance to wake up in
order to have recurrence
so for t greater than or equal to 5 the
idea is that we need to find something
simpler that dominates the model and
will prove that's transient so we want
an upper bound and then we want to make
use of the self similarity in the tree
to do some sort of recursion on that
upper bound does anyone have a
suggestion for a process that might
naturally upper bound the Frog model
it's terrifically everything away that
would do it yeah and that's never ever
that would be recurring percolation it
it ends up the couple really naturally
to a branching random walk and then we
can use martingale techniques to prove
things about that branching random walk
and doesn't even see it may be an
obvious branch and random walk that
would dominate the Frog model or obvious
isn't the right word but a crude
estimate every step each frog gives
birth in yeah and what if every step you
just split into a new frog so I'd say
every step doubles and if we analyze
that branching random walk you can
already proved 4d greater than or equal
to 14 the tree is going to be transient
so what we end up doing to create a good
upper bound is we refine this down to
get as close to that modeling the real
behavior of the frog model as we can and
to do that we use a multi type branching
run amok that actually has 27 types of
particles it ends up getting you get
exponentially decreasing gains as you
add more and more particles for lowering
d but this gets us all the way to d
greater than or equal to 5 so that's
that's how I proof for transients goes
and we like it because we always know
what's going on we have a good grip on
the probabilistic objects that are going
on I'm going to go into a lot more
detail for d equals 2 because in a
certain point we lose our probabilistic
interpretation and I'm curious if anyone
can help us recover that that's going to
be one of our questions at the end so
could you just give us this sort of
vaguest idea about what these types yeah
I'm glad you asked so one type of frog
it or we treat for instance when two
frogs are at the same site like these
two frogs right here as a single
particle because when these when these
frogs jump down there's this chance they
jump to the same site and so they won't
wake as many frogs as if you're just
taking that in isolation and we get up
to 27 by stimulating say that we let
these jump two steps and look what they
could do and 27 ended up being the nice
number and about as far as it could go
realistically and you don't expect to
get it down to the rules for right a
little bit more it's not just a little
bit more to get there there's no reason
this couldn't work though unless if if
do it for was where the transition
occurred that probably couldn't work but
we think there's some wiggle room where
maybe it would get you there so the idea
for d equal to D equals 2 is the same
except sort of except we're going to
look for a good lower bound now
and then use a recursion good lower
bounds are harder to come by than a
branching random walk one that we did
try was a Galton Watson process you can
embed several different types of those
in the growth of the frog model but none
of them showed the growth that we needed
so I'm just going I'm not going to grill
you on a good lower bound I'll tell you
what we used and it came in two steps
the first was that we're going to
restrict all of our frogs to non
backtracking paths and what I mean by
that is since any frog is going to
escape to infinity along the tree we can
break its path say that a frog woke up
here we can break its path into a direct
path to infinity and then excursions
away from that line where it comes back
to it is that is that okay and what we
do with the first thing that we throw
out is any frogs the frogs it's outside
of that path so as far as we're
concerned frogs are just going to be
jumping back for a while until they turn
around and then they'll continue a way
to infinity on the tree so this already
gives us a lot of control over the model
but we need to do a little more the
second step will be a little more
detailed to explain but it roughly goes
like only allowing one outsider into any
given subtree
let me draw a diagram to explain what I
mean by this
so say we have the root here and we're
going to look at the right subtree of
the root I'm going to label these
vertices X XL and XR and you can picture
say the sub tree rooted at XL starts
here in the sub tree rooted at XR starts
there so when we want we want to get
added recursion and that's what's
motivating this rule because in order to
do that we need to make subtrees act the
same in some sense and a problem that we
run into is what if 10 frogs move into
one sub tree then it's going to be
distributed differently than one that
had just two frogs enter it but if we
just cap the number of frogs they can
enter a given tree at one they'll all
look the same and what I mean by only
allowing one outsider enter is say the
next frog that tries to go into a tree
we just will ignore all subsequent
visits after that and this is done via a
coupling so does that can you picture
what that means at least it might not be
so obvious why that makes it distributed
the same but that's the rule that we're
going to enforce and these are frogs
that are following these non
backtracking paths so we can ensure that
once a frog on this path enters a
subtree it's going to be it's committed
it will stay in that sub tree oh I'll
say a little bit more as i define things
about this so hopefully will become more
clear don't you run out of so creepy I
mean they're two frogs for sub trees
what there's always alright so this will
recur stone because there's a sub tree
rooted at X there's a substrate rigid XR
but these mill knocking trucks are not
going to get you back to the origin so
you get recurrence as you defined it you
need somehow use more than just the
battery all right non backtracking
perhaps their first they first start by
walking backwards towards the road so so
for instance the Froggatt XR it could
step back and then step back and visit
the route and then from there it has to
walk forward so r sub stepping backwards
and backtracking or different know
hands on the tree which sector can you
manage watch this again watch the
definition of known but Craig is not
usual Oh or it's just I think it might
be the usual so say a non backtracking
path from here could go like this and
then forward so you just never intersect
the route that you so it's super I stink
no no this is no better keep an i think
you were going to that conversation now
so you can't visit an edgy visit it and
so we they still are able to visit the
route and they also have that condition
once they step away from the route
they'll continue to step away from the
room so if we make the assumption that
if we're looking towards actually a
painting and recursion let's assume that
the Frog @ XR is visited by the frog
that started at the root just so we have
two can fix our notation I'm going to
define V to be the number of visits
two frogs that are at X and jump to be
not and similarly i can define vr + VL
as the number of frogs that come from
the subtree started at XL and visit x so
the advantage of these two rules i mean
on backtracking paths and this one
outsider is that these actually make
given this assumption is identical in
distribution to vr and if we assume that
XL is visited v's equal and distribution
to VL conditioned on that event and
these are independent because there's no
interaction between the trees so so this
this is what motivated us looking at
this coupling is that we can get
something about visits to the root
that's going to look the same down the
tree and if we actually try to write
this down as a formula and we do have a
question yeah ok maybe didn't enseno BR
are their number so this is just from
the children of the routine vr is just
is the nut is the total number of frogs
from this sub tree that visit acts when
you take form you mean the ones that are
born in that sub tree frogs are born in
that yeah because 11 visited from above
so the mother that came from below it
from that sub tree and v is the number
that came from the sub tree rooted X so
what this all adds up to in terms of a
formula we get we can express v in terms
of VR and VL and I'll write it down and
then explain where it's coming from you
can get color it'll be good
so we claim that VL is equal to this we
can express the number of visits to the
root in this reduced model in terms of
these three terms so let's look at them
one at a time I'm claiming we have a
binomial vr1 half because VR is going to
tell us how many frogs land right here
at X and now since they're following non
backtracking paths they can either jump
to XL or to the root with equal
probability so viewing each frog it's
like a Bernoulli one-half event we're
going to get a binomial distribution of
returns is that ok and similarly if we
know that XL is visited we're going to
see the same number of returns to the
route from VL we're going to percolate
in the same way and can anyone see where
this Bernoulli one-third might be coming
from
there's one thing unaccounted for yeah
we haven't said anything about this frog
who's yet to take a step and so he can
with equal probability jump to each of
his neighbor's and will contribute it
for nearly one third um I'm still
confused about the if he's not
backtracking does he really have a
one-third probability of going in
direction that that's a good question
because we're on a tree the structure
out of guarantees that when we actually
look at how this rate is selected it's
also selected uniformly so it is true
but that's not obvious that he has those
transitions so it is a binary notice
three regulatory thanks everywhere
except clear route it's going to look
the same and so we in are a couple you
actually you have to do one extra thing
where if you visit the honest route you
get frozen there and you no longer do
anything otherwise it would have a
different distribution for as facts yeah
so if you visit the route then you're
gonna loud to go back off to incident
yeah you we just ignore you and that's
okay because I will still lower bound
our initial process so we're trying to
prove that recurrence for the binary
tree and we've reduced we've found a
lower bounding process that satisfies
this and now what we're going to do is
transform this into a question about
functions whether these infinite almost
surely or not in particular we'll look
at the probability generating function
of V so I'm going to let f of X be the
probability generating function and so
this transforms a question about be
being infinity almost surely
to proving that is generating functions
equivalent to zero and what we can work
with is this expression here to write f
in a different way so at this point our
proof turns into one about functional
analysis and I guess the appropriate way
to get that started is by introducing an
operator it'll seem unmotivated for a
minute but then I'll bring it back to
why we're what we're talking about here
so consider the operator a that's going
to take functions on 0 1 into 0 1 that
are increasing in two functions that
take 0 1 and R let's defined as follows
so given some function if we want to
evaluate at a point X will look at X
plus 1 over 2x plus 2 over 3 times G of
X plus 1 over 2 squared plus X plus 1
over 3 1 minus
g of x over 2 1 minus G of X plus 1 over
2 so this may seem like it comes out of
thin air but is the definition clear and
let's collect some facts about it I
think the first fact will explain its
origin and that's that our generating
function for B is a fixed point of this
operator so we have f of X is equal to a
f of X for X in the appropriate domain
now where is this coming from if you're
comfortable with generating functions
you might recognize some things for
instance this is the generating function
of a Bernoulli one-third and when you
think about a binomial on a random
variable that's really like a random son
and that results to function composition
with probability generating functions so
that's why we see G of X plus 1 over 2
looks like a binomial on some random
variable V we get a lot of i'm not i'm
not sure but we get a lot of there's
some supplicate a lot of simplification
going on here but but this formula is
coming from looking at this and then
computing the appropriate probabilities
it's important to know that there's some
dependencies in here and that's why we
get some of this this kind of noisy
equation right here why it's not
extremely clean or doesn't look exactly
the same as that so remember our goal is
to prove that F is equivalent to 0 now
and the key property of a that lets us
do that is that it's monotonic so if you
take G less than or equal to H the nays
going to preserve that domination and if
we combine that with the fact that we
know because F the probability
generating function it's bounded by one
we can string together the following the
following bound
and that's that f of X is going to be
equal to any because it's a fixed point
is in the amount of iterations a day and
then by monotonicity and this bound we
can just look at a operating on the
constant function one so we reduce this
question out of recurrence and
transients to studying if you plug one
into this operator and start iterating
what do we get and with a technical
lemma that actually uses some single
variable calculus we we can bound this
by e to the C n X minus 1 for some
sequence CN that's increasing to
infinity and to remind you what these
graphs look like if this is 1 and this
is 1 SC n increases they get
progressively flatter and then steeper
at the end and actually converge to 0 so
just just like that and it seems like
all of a sudden to us when we prove this
we have F is equivalent to 0 which going
back to our original random variable
says this is infinite almost surely and
because we were Dom we were lower
bounding the process we have recurrence
for the Frog model and we're still a
little mystified about how this is
working and with that let me jump into
our further questions because the first
one is about a few steps in this proof
are there any are there any questions
from the audience before I do that
so we really have two things we'd like
to know hey actually I do have a
question yeah so when you have this
indicator that XL is visited in your
blue equation mm-hmm so how does that
manifest itself in li in the calculation
yeah I mean so we that's actually the
event that we conditioned on when we're
computing when we're writing out the
generating function so what we do is we
look at this event and we ask ok how can
exile be visited so it's either going to
be visited by the Frog here for the Frog
here right and and that's that's
basically where it comes up I see and
you're still sort of have enough
independence and appropriate things the
key independence is is this one
everything else is related in some way
but this is the K independence so our
proof took a turn into analysis right
when i introduced the generating
function and we'd really like a
probabilistic interpretation of what
we're doing in that argument
for instance okay for instance we see
that the functions that were actually
ultimately bounding our generating
function by these are generating
functions of Poisson c n random
variables so it just seems like there
must be some probabilistic
interpretation of what's going on here
but we don't see it and secondly if you
look at my idea our idea is that we
wanted a good lower bound and I told you
a lower bound but if I just told you
that really when we defined it we had no
intuition for why that would be good or
bad we can't tell how many frogs were
throwing out with that second condition
the non backtracking condition is pretty
harmless for sure but that second only
one outside a rule we'd like to know why
that's the right why that's not cutting
out too much whereas other things we
tried work now in terms of actual
further questions we're interested in
placing Poisson lambda frogs at each
site and then forcing a phase transition
for higher d
for instance it's it's open if you put a
thousand frogs on each site is a five
area tree recurrent with that we don't
have a technique that addresses that
question and it really ought to be at
some point and in regards to our
conjecture we actually give a sharper
conjecture in our paper and we think
it's possible that there's a three phase
transition and what I mean by that is we
think that binary and ternary trees have
a different type of occurrence there
exhibited namely strong recurrence and
weak recurrence
so by stronger currents I mean the
fraction of time that the root is
occupied is staying away from zero on
the binary tree in the fraction of time
that it's occupied on a ternary tree is
going to 0 so we think it would be
really neat if maybe if we find this
phase transition for placing this on
lambda that we could exhibit all three
phases by varying that parameter or
proving that for three and four area
trees with one per site it would be or
two and three would be really nice so
that's that's where it stands and I
think the one of the reasons I'm talking
is I we want opinions about this proof
if people recognize this technique
coming up before or see something that
we're missing about it because we really
hope that it could cover both of these
cases that the ideas could be extended
so thing thanks for having me and I
there any questions so what breaks down
exactly called equals street yeah
nothing breaks down except this so we've
done the same thing for D equals 3 and
we get an operator but it has I think
seven or eight some ends in it and you
have to actually start looking at
derivatives of your function to when you
talk about it so we just can't we can't
push through the same analysis on that
but you busy do you think that this kind
of bound just using 11 outsider can work
for a ternary tree so you're that that
goes to the question that we don't know
how much for throwing away so we're not
sure but thing but in your simulated but
this is something you can try all
students relation to see if you allow
only one up already three was very
sensitive for simulations the hardest to
simulate this for one per site so we
haven't tried it but with this rule but
I suspect it won't be clear because it
wasn't very clear with one per site
already but that might mean that this
clear with this rule
yeah I know it I think that's a good
suggestion to look at simulation more
than and again this operator even if
it's hard to analyze analytically you
can still it's easier than simulation is
just to flying step I the operator
neuron everyone many times you see where
that's going now the malignity you
mentioned is that supposed to be obvious
because then you do have a one- term
there it's not obvious there because of
the miners turn but if you can make
comparisons that this is not
contributing enough to change it there's
another ball called the lilypad model oh
really thank you should combine the
truth that's one is in ardido to go
where you can help treat I I thought
about a lily pad model actually where
you you picture frogs movie news
Brownian motions and actually like
they're on a lily pad and they're moving
around so I so a little bit but it's
best to avoid too much too many
fragrances you're talking about how many
is too buddy though these so the method
the general methods are bounding by
branching process or branching random
walk have been used many times Soviet or
a multi type thumbs up but of course the
devil is in the details of finding the
right Tommy boxes yeah so once you bound
but why do you say that 27 is some kind
of limited scene and all you need is to
find an eye so can't you somehow
automate the process and do your stuff I
thousand but then all you have to do is
find an eigenvalue or rotary cell go in
that we actually did optimize the
process to get to 27 and this is a
computer-assisted proof for transients
and we were unable to optimize any
other than that we're running into
computational runtime problems in what
spark calculating eigenvalues and
calculating the matrix because we need
to actually simulate the transition
probabilities between particles and that
that gets complicated quickly if you're
talking about several frogs taking
several steps that doesn't even
recognize proving a generating function
is zero to prove infinite visit source
of random variables infinite
yes a little yes okay yeah so we're
curious about that each year microsoft
research helps hundreds of influential
speakers from around the world including
leading scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>