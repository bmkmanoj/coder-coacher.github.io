<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Searching for the User Interface: First Steps | Coder Coacher - Coaching Coders</title><meta content="Searching for the User Interface: First Steps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Searching for the User Interface: First Steps</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8RRVIAxtuDk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
alrighty hi I'm Tom ball from a research
in software engineering group and we're
pleased to have professor Stephen rice
from Brown University I've known Steve
for many years I think we met in 93 at
the a debugging workshop yeah Beck Oh in
Sweden yeah I think that's when we met
first and steve has done work over many
decades on really software engineering
systems I think they were there was
garden and was it wasn't it something
like that yeah field garden many many
different ways to bring together to
bring together programming environments
before there were really sort of things
called IDEs and really looking at the
architecture and innovative ways to help
programmers and today he's going to I
think tell us some interesting things
that builds on all the work that he's
he's been doing about creating user
interfaces so welcome back to Microsoft
it's not really creating user interface
but we'll get to the hug so you feel
free that interrupt ask questions the
two of you who are here I assume the
others can't oh um you know they
actually can I'll just I have to monitor
the website they hang that they can s my
check okay okay so we start into the
something uh you have code repositories
out there olo claims to have 30 billion
lines of code I'm told github is more
that's a lot of code and these things
keep growing exponentially you last year
github was around 18 million 18 billion
lines now it's 30 anything that you want
to write these days at some level has
already Brett been written by somebody
else you just have to find it or
something if not exactly something close
to it has been oh and and and the
hypothesis the stealing code should be
easier than writing it in the first
place however given that code search
which is how you access all this data is
not really used today there are variety
reasons for this it doesn't return the
right results
it's hard to determine whether what you
get is back it is acceptable or useful
or not it's hard to determine what you
get back what it does whether it does
what you want it to do or not it doesn't
fit your existing framework you're
trying to put code and you find a
function will fit in your program this
code doesn't quite fit doesn't fit your
style if you ever had to work with code
in another style you it's really hard to
do it's just too much work there are a
few exceptions the smaller end but we'll
get to that but I want to do those use
this so let's go and do an example here
so let's put a few keywords in here and
now what we want to do is search now I
can explain what's going on here so here
I have a sketch of a user interface
which I've grabbed off the internet and
just duplicated here and I want to find
code that implements this really I
really get you googled or user interface
sketch right bing it was a JPEG as i
said i converted it's now an SVG Oh or
was a PNG or something I just took the
picture and converted it okay and I tell
it to search and find the user interface
and it's found user interfaces that look
something like looks and look something
like it and actually or because giving
keyword address book they probably are
something like it okay so we got that
sorry about the delay slideshow here we
go there's a lot of magic going on there
cool coupon code it ran the code in the
random your anthem gently ran the code
to generate all those interfaces and
there's then the comparison you know a
lot of magic you're getting the code
from the repositories that does this
finding the user interfaces in that code
getting the code to compile and run if
you ever tried to get compose from the
repositories to compile and run it's not
easy matching the user in
face that results to the picture I gave
it to the sketch validating the user
interfaces we haven't gotten to that yet
but what user can go through and
validate them and then making the
results useful generating code that you
actually want to use as a user interface
code there are a lot of things and I
want to show you how we do each of these
now getting a code should be simple you
know we have all this code out there
their existing search engines just go
and use them it's not as simple as that
though the code search if you remember
using code search about nineteen ninety
you got caught using bit web search
about nineteen ninety wasn't very fun
you know you learn techniques that sort
of work well code search engines are
about at that level of permittivity the
best one I found so far is google web
search address in github but the Google
API interface is not as good as the web
interface it returns different results
and they don't let you use the web
interface from within a program they
turn that down and Bing has an access to
github yet as an index get up so I can't
try that keywords are lousy interface to
code the code doesn't have key words in
it particularly you have to manufacture
them from comments from variable names
and they're pretty random the way things
go and what's return our files not the
what you're in looking for so the
results not particularly easy to use so
you have to get through all that so you
can show what's going on here I have
another demo I can find it this one's
all set up this is looking for ordinal
numbers I want to find a routine that
given the number 17 returns 17th or
given three returns third except
programmers probably don't know what
ordinal numbers are so they probably
common in it incorrectly or called it
and correcting their code you never know
what's going to happen so here's code
search for ordinal numbers and trying to
figure out what this does this is
actually github here
and access and now you're trying to
figure out what this code does is
carefully here what'swhat's you know
that doesn't look like much here's gonna
do what I want but it's hard to say and
and business open this is just sooo not
a surprise cuz you're just snatching on
the streets right and I'll lowes know
better so we in order to do this type of
search we want to do we have to be able
to do better search ah so let's see what
we get here browsing source repositories
go to the next slide okay so we went
over this play from current slide so
that you have lots of problems if he
turns files it's hard to browse and
understand it's hard to determine
whether it's relevant whether you want
to use it or not who knows whether it's
going to compile or not you know and
then try to figure out what it does is a
lot of work so what we did is we decide
we have to do better than that
especially we're going to use search all
the time so there's not hopefully this
cook you live it I don't have a circle
going so what we're going to do is we're
going to do search here and what we did
is we put up a coat use code bubbles
essentially as a front end for code
search so we go and i think i push the
search button so much yes okay so yeah
it goes out and in this case it's going
out 200 and github and using that and
returning the search now i can use this
in various ways i can now look at the
code and see what this does when it
isn't that ordinal tranzbyte I don't
know whether I want to use that doesn't
look that relevant but you can
essentially look at things the way you
normally look at code so I
look it's expand ordinal see that's a
little relevant and I can go and see
what this routine does and i can try
figuring out what's going on here um
let's take a look it with this this go
to the next one format format double
looks like it might have a right now
format double for Matt long yeah 00 that
looks like it might be working or close
to what I wanted fix me what it's got a
nice comment in there though some look I
haven't even branch mm-hmm using a
unique a one point yeah I'm suspicious
but you can again browse that I can see
if it's going to come pot test if it's
going to compile fairly quickly they
build it and you see it most of it
compiles there's some stuff down here
that doesn't compile because it's using
a consumer but the right routines I
probably don't need but I could do this
type of investigation if I want to get
more let's see let's look at one more
there's warden'll get long to ordinal
event that looks like a good routine use
that bring that up are we really your
guinea pigs here for the top I mean are
these this is the first time you're
looking at this guy are you carefully
Slappy's I not particularly care not
that I'm accusing you of anything Steve
you're not very good magician's
assistant here let's turn it up it
started out looking pretty bad with ya
okay but here this one's looking better
right for this one this one looks like
it works except to use as a routine
cardinal and if you want that that's
probably also in the class so what we
can do here is go and tell it to expand
this result we should get the other
packages in the class and it'll go out
and do a search for that and add them in
so what happens if you really just want
this one feature and goes okay like I
can now you want to just extract and the
end you want to extract the stuff that
you believe you don't want to take a
dependence on if I if I if I find a
single routine i want i can just go here
and accept that particular result okay
and now i can go up here and this one
right yeah safe which exports the
accepted results and just say and just
export the code that i chose there and
it also does other things not all that
well but you'll notice there's a suggest
button down here and as i go and accept
results and as i go and delete results
it'll we compute a set of the get
guesses a set of words to do a new
search with so it's doing word analysis
it's sort of working so i can I haven't
I haven't rejected anything but if I do
is suggest here it goes out computes
things comes back
maybe maybe not and tried that um
gahanna with running at the back end
okay so we can go back to the talk we
can now do search and we actually use
this to make a defined get the user
interface code to work so talk talk no
that's not talk where's the talk here
there's a talk okay so we had that what
we did here it turned out when you did
this in a week or two weeks or something
like that because we had code bubbles
and code bubbles is designed is a very
plug-in interface so you have mint
running which is the web the message bus
and you have code bubbles there and the
message bus talks to eclipse at the back
end with a little plug in an eclipse and
then you have various active things and
then code bubbles has all these
different plugins for editing code
editing text editing debugging and so
forth now we started with that for rebus
and what we did is we just removed all
the stuff there was a clip specific
including things like debugging which
you're not going to do in search and
educational extensions in the
programmers notebook and then we added a
back-end rebase to take in replace
eclipse and that's it that meant that
made it work now re basically yet we
have to work on this back end and it's
fairly simple as well it talks to the
message bus it has a command interface
which tests very search commands we have
plugins for the different search engine
so you can add a new search back end in
the matter of an hour or so and so it
was an hour for the law for grep code
which is the last one we added it has
this code to handle word bags that do
the deal with suggests it has an editing
interface to let you edit the file so i
can actually edit the code there and
then try compiling it and seeing what
happens as i edit to make a compile a
project interface has filed and then
there's a plugin for java back end so
you can plug in whatever language
semantics you want to make it work
search over particular languages because
it has to be able to compile and
understand the code
so that was the first problem we had to
deal with an user interface search is
getting the code for the user interface
so assuming we did we can do that we
still have to find the user interfaces
in the code get the code to compile and
so on and so forth now I'm all of that
we were convinced we could do and the
way we were convinced to that is we had
another search tool we did before this
is here and that's here and this
basically is what we're searching for us
or an old number and say third just to
make it a little more specific and we
told that we have a signature which is
string of Ord wheat take a function
taking it returning a string and we're
giving it a test case in this case we
say 17 should return 17 and that's all
we're telling it and we want this to a
fine code that actually does that now
this is going off and it's going to in
this case github and finding code that
matches ordinal number and third taking
every function in there thinking that
might be a particular solution and
seeing if that solution works or not and
can making it compile first then testing
it against your test cases and whatever
comes back it'll if it passes the test
cases it's going to accept it and show
it now there's a lot going on to make it
make it all do that
um no I'm running what one the it's run
as a separate process ok they can stop
to the file system and two it's running
with the Java security measures ok so i
guess it doesn't happen sitive yes sort
of thing I could set whatever level of
security I want so i can set file
security to be to allow whatever i want
to allow the default is don't let it
right files question of what partisan
third help the research obviously you
search for ordinal number of 30 right oh
yeah confidence or well I want something
I'm thinking that if it's going to
convert the convergent things like 17 to
17th s convert three the third and
thirds of words it's not going to appear
that many other times so I'm trying to
restrict the search in some way you're
in the Coachella well it's going to
output third yeah I expected that's
going to be a hard thing for the code to
have to code to generate without having
to string their special cases so you're
saying I know some special cases that
are probably I could do it without and
actually without in github it works
without a nolo it doesn't work it just
takes longer because it has to try a lot
more things I wanted this to finish so
here um we can hear you see you get
here's one piece of code that does it
and yeah it's sort of reasonable um
here's another piece of code that looks
like January
I think it's just you typed in well it
just reform it just reformatted
everything I told it to reform you want
to use it it basically will reformat
into it whatever style you want and I
told it to fort reformatted my style so
that's getting the output here's another
case this is actually similar to the
previous case same code probably minor
change this is different code but yeah
the code exists it's out there and you
should be able to use and I can just cut
and paste this and stick it in my
routine no no and having some sense
it'll work I can do additional test
cases if I want it's now in my format
very you and it's useful you'll find the
licenses and pop those up too so you
know look again there's looking license
should be here why doesn't it happen but
no it is that seriously it does have the
license okay so if it had one it should
have a button over here to show other
licenses it does it does extract the
license from the code sticks in a
database know maybe yeah as you say the
Paris distributed system depends on lots
of machines the database server might
not be working at this point and then it
depends on the database server to look
up the license based on the license ID
actually since the system that's running
here has been running for three or four
weeks it's probable that the database
server has at some point died and it
hasn't necessarily recovered from that
um I'll try fixing that though but yeah
it should have a license and we do
extract the license
okay so we had to get the the only found
in doing this making that magic work is
you have to get the code from the
repository you find a candidate methods
so find particular methods that might
convert a string to an int get it into a
string get the code compile and run
again checking the resulting code using
your users test cases validating the
code making sure that works and making
the results useful now this is a lot
like what we want to do to make a user
interface search work basically the same
thing and what we're trying to do here
is take some set of specifications
whether there are test cases or whether
they're a user interface sketch and
essentially generate the program from
that using blank a black box automatic
programmer in code search you're doing
something similar you're taking
specifications which happen to be key
words usually going into a black box
search engine you're getting code back
well actually what you do is you get
that code back and then you do a lot of
program analysis on your own and program
editing and try making it do what you
want to do figure out which code might
work the way you want it to and take
that code and eventually you get a
program well we tried doing in s6 is
take the solutions you get from the code
the code search and tool code search
engine and do the type of Trance forms
on those that you as a programmer would
do yourself to make it compile to make
it run to figure out what's what
actually would be useful we generate
lots of more solutions we again do
transformations on those solutions we
eventually validate it and generate the
program and that that's basically what
that six does so we think about taking
specifications which in this case or the
signature of the test cases and the
keywords feeding it into s6 and
generating program from that now the way
this works is the first uses keyword
search to go out to the search engine
that generates a set of initial
solutions when we're looking for a
method we say each method in any of the
files that's return is a candidate
solution and we generate all the
candidate solutions now we apply
transformations transformations
coming a whole bunch of varieties
there's some simple ones like change the
name of this method to be the name the
user-specified very simple
transformation except you have to change
any recursive calls and things like that
or some are more a little more complex
and it has an extra parameter here let's
remove that parameter insert an
assignment statement so the boolean
whether to return up or a lower case you
know we'll try booth true and false and
see whether each one of those works and
then there are even more complex
solution so final line the code that
computes a value of the return type do a
backward slice until the only free
variables or values of the input types
and extract that code from the function
this is useful because they were often
find code that does multiple things at
once and you only want one of those
things done so we're essentially
splitting the function of automatically
but we have about 40 different
transformations we're using and each
time you do want you getting ready new
solution and you just keep doing this
until you can't apply any more
transformations to get generate new
solutions is it yeah it's on the web you
know people try I've done I've taken in
the original paper I had a number of
tests k of 20 10 15 s cases and so what
sort of things mirrlees
absolutely the original paper they range
the gamut from little simple string
manipulation functions to robots.txt
finally Saturday computes robot it tells
you whether there's a robots.txt on this
web page I did English stemming recently
this way English stemming something that
would stem English words or remove
plurals at least but you know it depends
there are two things that depends on
okay one is the keywords which we've
hopefully which given now we have the
rebase the rebus stuff there so you can
do a better exploration and figure out
the right set of keywords to ask add
makes that easier and the second is a
set of transformations and we keep
expanding that set of transformations
transformation so so you said let's
slice in from well we basically blind
align the computes of value to return
type and do a backward slice until the
only free variables or the input types
essentially identifying code within a
function that does what you want it to
do potentially but but the only
specified keyword so we're how you have
to specify some sort of interface what
we also there were three thanks to the
specification keywords the signature Oh
in the test case okay so so the
signature is is it's going to help you a
lot but you might have functions that
like how ulcers of generousity have
extra out parameters in parameters we
have two informations that remove extra
parameter we have transformations that
reorder parameters this is giving back
to my original question is how do you
extract so the transforms are about
extracting sort of Jessica that you need
and making a compile grab another tests
or your your validation right it works a
surprising amount of the time especially
is this trial okay
we have to do dependency analysis
because you saw in the ordinal number
case there were the the function is one
thing but it used some static variables
and used helper functions and that's
that that's what this does it finds all
the other things that are needed from
that other than the original solution we
generate test solutions we actually run
J unit tests on all these things that's
that's what takes the most time we
actually analyze the failure reason for
these solutions and we can do additional
transformation so if it returns 17 where
17 is capitalized or the S is cap or the
whole thing's in caps and we want it all
lower case we have transformations that
can deal with that way of
transformations that could deal with off
by ke errors things like that you can go
generates new solutions they get tested
eventually get some to pass hopefully we
can do formatting and then return it
back to the user so this magic can be
used for user interface search we looked
at user interface search as a problem
along the lines of what we were doing
here with s6 you wouldn't you're not old
enough to know what s6 is a play play on
words of right okay Bell Labs had a
system called l6l labs low-level linked
list language oh it was the first
graphical it was essentially it
generated videos from the language oh it
was great great it was sort of early
Lisp okay but it's again good name the
issues you know here we have to get the
initial files again we're going to do we
have things for that we have to get the
candidate solutions solutions differ we
don't have methods we have user
interfaces instead of that we have some
problems with files we have to find the
appropriate transformations because the
transformations use in s6 may not be
appropriate for user interfaces or there
might be additional transformations
which are appropriate for user
interfaces you have to find a way of
testing the solutions we don't have test
cases anymore we just have this picture
and we have to present the solutions to
the user and
code isn't exactly what you want to do
here so we have that six what we did
here is we removed parts of s6 we don't
longer neither the dependency analysis
and we didn't do want to look at failed
certain transformations and failed
solutions then we just added something
to show the user to validate so other
than that it's the same architecture
it's actually using s6 in the back end
so finding user interfaces in the code
this is what we need to do so initial
files use keywords as before this is
going to work right we're doing return
the key word files how many people right
user interfaces to fit in one file not
that mean there are few out there and
then we found them but if you want to
have a broader selection of user
interfaces people are going to write
their eggs ilary files are going to
write their own implementation of the
the list widget that they want some
additional features for they're not
going to necessarily nest it they're
going to have a user interface class
they're going to use or user interface
package they're going to use for the
rest of their system and you have to
deal with all this so in a vase is tend
to span multiple files depends how they
were written and that so what we did is
we extended s6 to handle package and
system search so instead of looking for
files you can say look for everything in
this package and I'll essentially you
know find out find the file that comes
back from the keyword search then expand
that to include everything in the
package just like we did in rebus to
expand it you can expand it a second
time and get all the related packages in
there you could do that in Reba's to
takes a little longer but that this
generates a single source and then we
just do transformations it has multiple
classes in it probably is not legal job
at compile but we consent and it's
closed and we can eventually generate
real classes from that and actually
compile it and we added a lot of new
transformations are a few new
transformations to split classes up to
extract in inner classes into other
classes make class a static we're need
be well there's going to be are you
relying on
like model-view-controller splitter even
that actually I like bring data of the
application over I mean if you want to
show the user interface then you know
you have to you have to generally
populate with something yo we'll get to
that okay that's transformations yep so
just a quick technical question so one
thing that can happen with you eyes due
to things like localizing tax and things
like that is sometimes things can get or
externalize outside the given week eight
with that ok so we first have to
identify I'll get that bets in the swing
transformations here so we hit do with
transformations that's what that's what
that six does so we added
transformations to well first we had to
identify potential solutions to identify
potential interfaces so any class that
implements J component we say this the
the constructor for this class can be a
potential user interface any method that
non private method in a class that
returned something of type component we
said this can be a potential user
interface now we have a potential
solutions we have to set it up so we can
actually use it so we set it up to have
a separate class which eventually be
called you know make cults a constructor
or calls the constructor and calls the
method and then returns that user
interface so we build to have a
transformation that does that now we
have to handle all these weird cases of
swing and internationalization and
everything else that goes along with
that and we added these swing
transformations and they effectively do
that they look at all the calls to the
swing coat and if anything is undefined
in those calls like or if they are
calling the resource manager at any
point where you place that with the you
know don't remove the call but replace
it with something with a fixed string or
a new string each on s6 underscore temp
something something some unique string
we replace all resource manager calls we
have our own resource manager we can
substitute in you have problems and that
they'll use outside models three models
or list models for your particular
application that's usually not in the
same class you may or may not want that
to copy their whole model so we'll
replace it with our own model
so we have a transformation which
removes their model and substitutes our
model we have transformations that the
tribe you know that they are using some
other some class in the we don't have
library but it looks the same as a swing
class will replace it with the swing
class but there are lots of different
transformations that try to make it so
that it will compile and still generate
a reasonable user interface we have
transformations to simplify things we
are taking this code which is not just
the user interface we want just the user
interface back so we want to throw away
everything that isn't related to the
user interface so we'll go and do a
dependency analysis and effectively any
code that you that's not used or they
can't be reached directly will throw
away and then we'll throw away some
other code too if it looks if its
private methods and things like that
with what will make sure it compiles
we'll make sure you remove anything
that's after that's other than swing
calls that looks undefined and
eventually we will come up with code
which is just the user interface and we
also do all the standard ones and has a
good chance of compiling now we need to
test it the code has to run and we what
we do is we run actually run the code we
actually build the user interface from
the code that generates a widget we do
an internal we basically crawl at widget
looking at the hierarchy imposed by that
widget and compare what the widget with
that widget is to what the users diagram
look like and then we order the results
on how we match now we have to do this
we have to understand the user sketch
and we had to match develop a matching
algorithm that the sketches well we
didn't want to start with arbitrary
sketches although I'm told in another
two weeks we can start with arbitrary
sketches because we have something which
generate translates an arbitrary sketch
into an SVG diagram suitable for our use
so we're working on that but then we
essentially take an SVG diagram which is
a structured graphics you can do almost
anything there but it's great because
they're there lots of tools to generate
sv
or let you do that either web tools web
interfaces or inkscape and things like
that and then we do have classifiers
which we run over the SVG to try
figuring out what each component of the
SVG is some of them group multiple items
they assign properties to the items so
here's a simple example it's a login
panel login dialog we first identify all
the SVG elements here so you have eaten
one for that text element there text
element here rectangle here rectangle
here with some text text element in it a
rectangle little box there remember me
text there and in a circle around it and
then the whole thing is in an element um
okay and now we basically identify what
these things are so we say that's a text
field and we say it's probably going to
be a text field because it's a box since
that and it's shaded let's now the user
would typically shade or our big outline
around it that's how you typically
represent it this is a text field as
well but because it has stars there
we're going to guess it's a password
field these are labeled that's fairly
easy then they're not inside a box or
anything they're just text this these
two go together because they're adjacent
to one another and this is sort of a box
of some sort next to a piece of text
this is probably a radio or a toggle
button of some sort and you're not going
to be able to differentiate them from a
sketch the users going to make them look
the same way this is again text inside a
box is and it's either lay the text
field or in this case because the box is
round it's probably not a text field is
probably a button so we'll do that type
of analysis on that and these are the
properties we're looking for we're
looking for is it an input area or not
is it a button or not is because they
represent a table you know with a box
with lines vertical and horizontal lines
a list a choice thing where you have a
box it has a down arrow on the right so
you know you can choose multiple things
they're plain tax whether it's sim
assemble some little Dyke on their user
try to draw
whether it's a line whether it's
something used only for grouping it
doesn't have any other effect options
multi-line text versus single line text
scroll bars we detect we have a
classifier looks for those numeric
fields if you only have numbers we can
detect that sliders icons and we look
for all these different types of things
so example components only containing
text combo boxes as I said there's a box
with a symbol to the right those are
examples you're not so you're assuming
somebody has done the conversion of the
conversion of a picture to this region
yeah you know what odds are you right
SVG is telling you this thing's a box
right right and that's what I have a
student work at student working on okay
so you have this decomposition of the
SVG the problem of taking up just an
arbitrary set of pixels array of pixels
I'm mapping SVG I'm how I've separated
down right but once you have that SVG
you still have like quite a bit of noise
so what are your classifiers are your
classifier is dealing with just in
different ways of a scrollbar they're
basically hand coded and trying to look
at all different possibilities so it's
the first scrollbar think it looks for a
rectangular region which is either long
and narrow or tall and narrow now one of
those and it has something at the top
and bottom and maybe something in the
middle so a little symbol that you
typically will put an up arrow down
arrow these are robust what scale
translation i mean the classifiers are
right or robots too many transfer
like you're doing right then I've tried
to make them that way you have data on
sir how to do I've done and i'll show
you the test cases I've done you know we
have lots of different ones um go there
we now get a hierarchical set of items
you have nesting here each item has a
position has a size each has properties
which are these these things we can
assign to it we now map each of these
items into a candidate by saying this
item can be one of these types of
widgets this is the only place where
spring specific if you wanted to use
Android or some other tool kit you just
use a different mapping here so we'll
say this could this can be a text field
or a text win text region or whatever it
can be we also look at and determine
relative positioning between these at
components so this is close enough will
say this is above this one this is to
the left of this one too to the right of
this one if its nest that we can say it
sits at the top of its nesting thing or
at the bottom of its nest of its parent
and we're generating a hierarchical
component specification which looks
something like this for the for the
example we had so you had the thing
here's a component that's the top it
says it's a panel then you have a
component which is a label which is the
username there you have a component
which is a text thing that's this thing
here which is left of the label to which
the label is on the left of and so on so
this is what this is what we're trying
to match against effectively and that's
the output of our priests can now we
have to compare the hierarch if you have
to compare the actual widget to this
hierarchy so we get the widget hierarchy
through introspection we find all
possible mappings or within theory will
find all possible mappings between the
actual components in the wizard and the
widget and the user the components in
the hierarchical specification it turns
out we are going to stop at some point
because there can be an exponential
number of the
if you have 20 text fields you have to
to the 20th different matchings you
don't want to look at all of them or if
they're 32 text fields you're never
going to finish but we'll find some set
of matchings there and then we have the
matching has to obey the hierarchy so
says this is nested in we have to be
nested the type constraints are obeyed
most of the abstract widgets are mapped
and they're not too many extra
components now we're real little fuzzy
here and there reasons for being fuzzy
I'll get to them then we score the
mappings so we'll look and you have a
diagram there we'll look at the width
and height of the actual widget and if
it's over within 100 will give you
points for that will give you credit for
being wits and credit for the height if
its strings we're going to do a string
difference on the text so the strings
are the same we're going to give you
quite a few points for that look at the
if you have relative positioning we'll
look at the relative positioning between
the two and if you're within 50 pixels
will give you points for that if you
have extra components or take off points
or if you have missing components we're
going to take off points so we're going
to penalize and we're going to add and
we essentially come up with our mapping
so the scores see no need for ranking
right we're right exactly so I would
think a good property you would want the
scoring system to have would be
something like you want the differences
in scores to be sort of proportional to
the amount of engineering effort it
would take to overcome the gap so for
example things being kind of in the
relic wrong pixel border like
something's supposed to be above but
it's really below I mean that's a super
quick fix right i mean that's that's no
big deal for the Unicode but for example
if something is supposed to have a
password box and it doesn't have it
obviously it takes a big engineering
yeah there's a big the larger penalty
from extra components of missing I own
III don't know I guess my question is
missing missing the large was a scoring
your sickly experimentation ok now the
scoring but you know you get the one
that the good match is going to be at
the top and you don't care it but about
the things towards the bottom any way to
validate the results I'm not going to do
the validation we're going to show the
results to the user and you saw that the
original screen and we have the ability
to return the code so we can go back to
where we were maybe want that later on
this one yeah there there are results
what we can do here is we can click on
any of those results and we actually get
the it lets us run that immediately we
can see what it looks like we can play
with it we can see all the events that
are generated we can see what happens if
if it lets us to change if it this one
doesn't let you change the size but if
it did that you change the size we could
play with that here's another one why it
doesn't let you change the size of it is
but you can interact with it and see if
it's acceptable the ones you like you
can Mart you can accept here or you can
accept them here reject them and this
needs your decision
can you be side-by-side sort of what you
know just have to find it there
I didn't get rid of it there so it's a
big text area I'm left all those sort of
to you except for the bomb it's a bomb
and then it's got some fields in the
right with text alerts no this is
missing and some labels of tops missing
all of them but they're reasonably close
and you know something like this you
know it has name address no you not but
once you accept whatever you want you
can now say get the code and it returns
the code for you're accepted things we
haven't done has made the code something
you want to use yet because most of the
code is out there that generates user
interfaces you don't want to touch with
a ten-foot pole but that's another set
of transformations we have to work on we
are but you can actually get the code
that implements that interface you can
do a few other things we let you do some
minor editing of the user interface as
well so I got made if I can change the
labels to say what I want rearrange make
things miserable or not visible as I go
and if the code is interactive you can
actually interact with it so if it has
buttons tabs and to show you different
fields the interaction will show you
that you know they seem like you know it
really clearly hard example right
because there's stitch together multiple
levels of things you're to understand
the users intent in terms of what is the
image marketing aspect of it and so on
and then down all the way to the code
comprehension stuff I mean do we have
code search working well for non user
interface related class can you search
effectively for a nose oh my XX will do
a fine if you have test cases you don't
have test cases I know how I yeah we're
dressed case is that with this case yes
as sex tends to work I know if you can
find the right keywords people been
using that and I have of the user
made that help that public but i have
been using it whenever I need whenever I
start writing code where I think
somebody's you know I don't feel like
writing this routine whether it's doing
some string manipulation whether it's
doing English stemming robots that text
or even simple things just a mainline
parsing for example the test cases that
you provide are usually textual I mean
can i describe you know I need a red
black tree implementation that's got
some tweak on it how would you specify
well it's hard to specimen to do tests
for a red black tree because any tree
implementation should pass all your
tests now you could do keyword search
with red black and then see if if you
have a tree implementation in there and
that might give you what you want or you
can give it a very complex case and see
which ones have the proper timing
justice from from you know from from the
up you know you can just functionally
from the outside right but if you are
able to say you know I wanted a tree
data structure I want to look like this
and I want it Essex will handle that if
you it's not easy to use it has it has a
notion of user context if you actually
actually run it from within code bubbles
you can write your own test cases and
their transformations where it'll use
your classes and it'll take code that
has some other class there and map that
class into York to use your class so if
you have their own note you know
whatever you want to implement there for
that it'll try transformations which do
that mapping for you so do you feel like
the basic code search for functionality
in Essex is you know good enough and you
feel like that's a almost a solved
problem and that's why you're exploring
this like one more level in trouble
well it is a solve problem I think it's
a solve problem given you you probably
need another dozen two dozen
transformations to handle everything to
do the sum of the mappings there
especially on the context stuff context
mappings we have our sort of primitive
to you need a lot more CPU power I'm
right now running this on my desktop
machine now my desktop machine has 16
cores and 64 gig so it's not the trivial
machine but it could actually run in the
cluster very easily and you need to have
the right keywords to begin with keyword
search is really bad but and you need to
be able to do test cases and that only
works and as as you noted a smaller set
of things but I thinking though that for
those cases yes we've basically shown
that if you can find the code we can do
the transformations and make it useful
useful if the code exists in the
repository doing something really
complex code Frank might not exist in
the repository in that case there's not
much we can do this is why we aim for
guided code search where you do is piece
by piece and the pieces are there but
user interfaces or one of the things
going trying to go beyond test cases
what can you specify and this is one
another one I want to work on this
summer is architectures where I can
specify with a UML diagram and then do a
search for something that implements
that architecture ok
so this time I'll start from the current
slide so we did that did that to
validate this we did we start we did the
web search I don't know if we use Bing
or Google one of those for user
interface sketch and we basically found
all these things out there we converted
them to SVG just by taking the picture
and making it an SVG diagram that looked
basically the same and then we had to
figure out keywords and the first thing
time through without the rebus there
half of them failed because we need
didn't have the right keywords after we
could go and find the right keywords we
got we can make all of these things so
we could actually find the corresponding
interfaces and you can see logins should
be fairly easy and you had lots of
solutions that it had to look at and it
actually found 45 but you can see all of
these it found them the stars here mean
there there were other things other
solutions that didn't try that had
stored up and basically if it finds some
it only looks at a limited number at a
time so they're potentially more
solutions there and we didn't look at
more than about 5,000 solutions on any
of these there are test cases when we're
doing looking at things that the not the
file level but we expand it to package
your system where we look at 50,000
solutions or something along that it ilk
and it takes hours or other than minutes
to do but we did find solutions for all
of those problems question of you
there's going to see you not investing
in in the designers for cami's where
people draw the things they want and
then you get the code so if you go this
route you get a piece of code that
sorted is close to what you want but but
are you better off in the end this way
then then starting with you know what
you know visual studio provides and well
very suspicious right yeah I'm getting
some understanding what you want and
it's got a bunch of underlying code then
yeah you may or may not want to use it
there might be easier but you if you
would try using any of those toolkits
you find that it's a lot of work to make
it so that it you have the right
hierarchy there it grows the window
grows correctly yeah the right
interactions between all the things the
color coding potentially includes all
lapses somebody else has gone through
the hard part really making it work well
here so I can drag and drop the widgets
but then i'm going to yourself a lot
more work and it may or may not scale
when you do the right thing when you
resize the window okay that's 11
argument i can give a second argument i
can give is that i'm going to do UI
development here's my initial sketch ah
this is I start with the initial sketch
for the peach up reach the program I
relax it a little and I got all these
different sketches which are different
user interfaces for restaurant ordering
basically so I can use it for
exploration so I can take my initial
sketch and most of these sketches aren't
you're really final interface even the
address book I didn't have a separate
name and surname seeing the scene the
examples there maybe I should be doing
that maybe they're other fields I'm
missing I mean this is valuable justice
yeah yeah so that's one of the things it
seemed that that's one of the reasons we
make the scoring fairly lacks not only
because we want to find something but
also because you you you want to have
the ability to find alternative
interfaces and it's a valid use in and
of itself so here's a nice one doesn't
look like necessarily like the original
it has most of the capability and it
actually does that that this move the
total there there's an interactive code
for that and there's another use we're
able to generate an image so going back
to our example here this one let's
remove everything the big red button
does and do login J checkbox Jake
password um both and do a search should
we move all windows here
now we can take something here take
through this and say show the user
interfaces so not only can we search the
code we can now tell it to find the user
interfaces in this code it will go
essentially using the technology that we
developed here to show the user
interfaces that can be generated from
that code you can see the different
transformations to get different labels
but you can do this for anything to see
what the code looks like okay so go back
here play from crunch like so we can do
use that current status s6 as I said a
functional website rebuses actually
distributed as part of code bubbles and
tell anybody but if you just run code
bubbles minus Reba's you get that suisse
the user interface stuff is under
development the code is actually out
there not necessarily the current code
but it's there and we're working we have
a number of things to do the other which
I mentioned all we're working on going
to direct manipulation interfaces rather
than just static ones I don't know how
to do that they're not that many Java
ones out there and do direct
manipulation and these don't do it
cleanly and then looking at as I said
frameworks our eventual goal is to take
this little toy here and write a
simulator for it with the user interface
and the physics engine and everything
else without writing any code ourselves
doing it all via code search so we want
to do a you know start with specs and
essentially do create program creation
from code search we're also looking at
bug fixing via code search we do a lot
of other things that great
I didn't want to take rest hun thank you
see</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>