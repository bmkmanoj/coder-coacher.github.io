<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Proving That Programs Eventually Do Something Good | Coder Coacher - Coaching Coders</title><meta content="Proving That Programs Eventually Do Something Good - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Proving That Programs Eventually Do Something Good</b></h2><h5 class="post__date">2016-08-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wpr251OSgRM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
ok so the this the sort of subject area
of this talk is in modeling programs or
Hardware railway systems biological
systems and then trying to prove the
absence of bugs in those systems right
so if we for example take device drivers
and which is on my list and at Microsoft
we have we have a device driver quality
problem we might ask what sorts of
things would we want to prove them
device drivers so this is an example of
something we'd like to prove the
parallel port device drivers event
handling routine only calls ke spinlock
when Oracle equals passive whatever that
means it doesn't matter right it's that
the point is is that when you're a
device driver writer you you typically
don't work for Microsoft you typically
don't understand all the things you are
and are not supposed to do but then
there's all these Byzantine rules of
that you're supposed to follow and if
you get them wrong then the driver does
bad things and then Windows crashes so
that's something that Microsoft has an
interest in solving and what this is st.
Oracle equals passive is talking about
the thread priority level so it turns
out that device drivers are typically 15
what they call dispatch routine so like
they're like functions that are called
and those functions are designed to
respond to events and or those event
handling routines are run in kernel mode
and so they can increase their their own
thread priority and so when they
increase their own thread priority there
are certain things that they're not
supposed to do because it causes
inversion problems this is an example
something would call us we call a safety
property okay and the safety property is
a property that for any counter example
to the property is always going to be a
finite trace through the program so you
can start from the beginning of
execution through the program and go to
the look to the point in time where the
program is violating the property and
say now you violated the property
typically point to the line of code that
violates the property and typically
safety properties like morally speaking
they're designed to rule out things that
didn't happen and some time ago I was
involved in project called slam which
was designed to take in C programs and
then automatically proved the absence of
safety property violations so and this
is in particularly applied to device
drivers so we have a tool that's
delivered with the windows device driver
development kit that takes in a device
driver takes in the source code it has
about 80 maybe nowadays like 150 safety
properties it's trying to prove and it
automatically attempts to prove the
correctness of the device driver with
respect to those properties and here's a
pointer to the paper that describes that
and some detail if you like to know oh
oh and then what happened is so so this
was in 2002 2003 and this inspired a lot
of other groups so this this area of
automatically proving the correctness of
programs had been in some sense left for
dead right like in the 70s and 80s lots
of people thought about the potential of
doing this kind of thing and they made
lots of promises but by the 90s the
promise had we'd failed and so many
people thought that this area was it was
a dead area and then this there's been a
resurgence in this area and now you see
lots and lots of tools so here's
pointers to different papers that are
basically doing the same thing but often
you know better faster more scalable
they handle more features and there are
many many papers that handle this kind
of thing nowadays oh and there's a
competition so nowadays you can go to
this competition website and see all the
tools that were entered into the
competition and see who's winning four
different for different categories okay
here's another example of a property
that's not a safety property right so
every device driver dispatch routine and
actually basically if you think about
how programs are written nowadays every
program is written with handling
routines right you the code hangs out an
event happens and there's some code
that's called that's that's designed to
respond to an event right so device
drivers are the responding to events
code for operating systems and this is
an example of something you would like
to hold of all
this resolve all dispatch routines in
windows and all operating systems right
so you want the device drivers event
handling routine to eventually terminate
like its bets a bet it's bad news if
you're if a network packet comes in and
the network device driver responds to
that event within response forever yeah
so this is an example something called a
liveness property this is the simplest
of lightness properties and liveness
properties are morally speaking designed
to specify good things that are that are
supposed to happen right so one way one
way to make a very very safe program is
to make a program that as soon as it
starts up it just gets hung in an
infinite loop and doesn't do anything
right and so you've now not violated any
properties you're not going to crash
you're not going to call ke ulay circle
will go really spin lock while it raised
thread priority and so on but in some
sense it's not making progress so
liveness properties are designed to
ensure progress okay and then i'm going
to i can so if you'd like to know more
about this claim i can tell you about it
in excruciating detail on the whiteboard
but basically termination and liveness
are the same thing so if you have a
termination prover you now have
mechanism by which you can prove
essentially all aliveness properties you
can reduce liveness basically
determination so it's kind of the same
thing there's a there's some formalities
but it's basically the same thing ah and
so myself and Andre who's in the back
corner then I decide to look into this
problem so what very much like slam we
did I decided to make a tool called
Terminator which takes in C programs and
is designed to prove termination of C
programs and then we and the early days
really had a focus on making this work
for device drivers in particular but but
things have moved on from there okay so
all right so you you want to prove a
termination of a device driver so well
so here's a bit of device driver code so
this comes from the mouth class this is
a basically some library code that every
mouse and keyboard device driver calls
into right and if you're trying to prove
termination
of device drivers then you're going to
see things like four loops and you're
going to now attempt to prove
termination of loops like this so take a
moment and look at the code and try and
convince yourself that it terminates so
probably as you're looking at the code
you're realizing that there are some
some issues right like it's its going
over some sort of data structure right
and now you're wondering what kind of
data structure could that be and then
like you're getting some hints because
there's something called flink maybe
that represents forward link right and
so maybe this is cyclic doubly linked
list right and so this is the sort of
thing that we have to now work out when
we're trying to prove termination we
have to basically work out what the data
structure is and then now oh how do we
prove that that this so I don't know if
you know see but and see the that the
program will terminate if this second
expression eventually becomes false
right so we have to show that eventually
entry will equal device extension read q
okay so that's that's the game so here's
here's how the talk is going to go so
I'm gonna basically I'm going to give
you a little history lesson on
termination proving and it's a really
easy lesson because it really isn't
there really wasn't much known right so
there was a couple of papers by Turing
and then nothing happened for 5060 years
and then there's been a explosion of
work suddenly and so I'll tell you a
little bit i'll give you sort of my view
on that explosion of work like it's a
very byron centric view of the world but
that's what i'm going to do and in
particular i'm going to tell you about
to advances that makes it such that
nowadays you can build a termination
river in like an hour if you want ok so
here comes the basics so so so yes the
halting problem is undecidable it maybe
maybe you know that so lots of people
get confused when they hear that people
are working on termination proving and
they think that you can't build a
termination printer and that's not true
you can build a termination paper the
trick is is that you need to make a
termination prover that muck that is
aware of its own flaws right it needs to
know when it's failing so if you can
make a termination paper that says yes
the program
it's in some case and say no this
program doesn't terminate but we we know
that there will always be programs for
which the prover can't succeed and so
it'll either run forever or maybe say I
don't know if the program terminates or
not so that's that's the whole thing
problem but what Turing so he proved the
halting problem undecidable but he also
gave us the recipe by which we can prove
prove programs terminating so I'll just
I'll just read this to you so this is a
little snapshot from his paper so he's
saying to prove that the program
terminates basically we need to be
assisted by the programmer that gives us
an assertion to be verified and this MIT
this may take the form of a quantity
which is asserted to decrease
continually and vanish until the machine
stops and to the pyramid mathematician
this is an ordinal number or you could
think of well ordered sets if you have a
have that sort of background ok so so if
you know what ordinals are or if you
know what well ordered sets are that's
fantastic and you're in really good
shape and you're going to just cruise
through this lecture no problem and if
you don't it's not a problem just think
natural numbers all right 0 1 2 3 etc
and that is an instance like if you have
that model in your mind that'll be good
enough ok so what is he saying I'm just
going to show you now in pictures in
some modern language what Turing was
saying so a programs are you can think
of them as transition relations so you
have a state you have some set of
transitions expressed by are so you can
go from one state to the new state and
so if we look at a program you can think
of all of its different executions you
can think of from some particular state
you might have a couple of states you
could go to so that's non determinism
right so we might go this way we might
go that way and the group for up for
your typical program the graph is
unbounded if not infinite right and so
the number of reachable states for
example would typically be unbounded if
not infinite ok all right so what
turning is telling us to do if we want
to prove this program terminating is he
saying find a mapping from states into a
well order ok so here's my
representation of a well order
over on the right so there's just lots
and lots of elements and if you don't
know well what a well order is remember
it's just numbers right so so think of
those dots on the right as numbers like
5 10 20 30 etc and there's a
relationship that holds between them
right 5 is less than 10 for example and
he's saying that for each state we need
to choose a number right and with the
following condition and the condition is
that if you can transition from one
state to another on the left and your
mapping chooses two numbers that greater
than needs to hold between the two
numbers ok that's the restriction and
because it's a well order it's like the
natural numbers and not the reals so
greater than really shows progress right
so you're going from five to four and
and and eventually you're going to hit
zero so basically it's saying choose a
mapping such that you can always show on
any transition progress towards the end
and if you can find a mapping F that
meets this restriction then you're done
ok now i'm going to introduce just a
little bit of notation so i'm saying
that our which is the transition
relation that is the sets of pairs of
states is a sub relation of the lifting
of this function f and i'll give a
definition here so the lifting of f is
the set of pairs of states S&amp;amp;T such that
if you map with f on both s and t
greater than holds so this relation the
lifting of f it says give me all of the
states of your program and i'm going to
build a relation which is terminating
right and it is a get I'm given an F and
ice and I order the states of your
program using F and using the by mapping
to some numbers and then using greater
than from from that set of numbers and
what turning is saying is if you can
find an F such that this sub relation
holds you prove domination ok and that
was 1948-49 to think and then basically
until early 2000 that was what was known
about how to prove termination so if you
took courses and
like in the 70s and 80s and in the 90s
when you would prove programs
terminating this is what you would do
okay so that's the termination basics
that's all you need to know now let's
talk about the advances okay so there's
a couple of difficult so imagine you
want to make a termination prover that's
fully automatic and works for real on
real programs etc there's basically two
hurdles you have to overcome okay so the
first one is imagine imagine that your
grandmother is really good at finding
these mappings right so you can call her
anytime you want and ask I have this
tricky program please give me an F and
we call it or I'm going to call it a
ranking function that comes up quite a
bit so she's good at finding ranking
functions so even when the ranking
function is known checking that
inclusion r is less than the lifting of
f is undecidable and it's really hard in
practice actually right okay secondly
imagine that you could just go to any
like corner store and buy a tool that
checks inclusions finding the f is also
undecidable okay so you basically have
it's like tricky in kind of two
directions right so if we want to make a
tool that solves this problem we need to
sort out both of these problems okay
that comes from there alright so let's
and basically in the literature now
there are solutions to both of these so
I'm going to I'm going to tell you about
them okay so let's go just into a little
bit more technical detail okay so when I
said that our is the transition relation
that shows how states go to other states
what did I mean by that so what I meant
by that was imagine you have you okay
and you is literally the relation that
says when you're in this line of the
program do this command yeah so you is
like the program text and our is you but
with all of the unreachable states
removed so so you star from I right so
so and this is this is saying any any
execution of you any finite execution of
you from the set of initial states
that's a set of that's a set of
reachable states and this makes a really
so we have the relation which is all
reachable States and we're removing the
unreachable States from you so that's
what our is I met tricky to build right
for many programs it would be very
tricky to build a nice representation
for what r is and actually asking
questions about inclusion in our is is
undecidable right because the reason is
is because you're you're when you're
asking about if something is in our
you're actually asking about whether or
not states are reachable okay great so
the trick is when like if you went to
university and proved termination in 70s
or 80s what you would typically do is
you would come up with an invariant so
rather than building this representation
of all the reachable states typically
what you would do is you come over come
up with an over proxima shin which i'll
call queue right so q is you with may be
slightly more states allowed in it right
it's maybe Q is just says it's all
staged such as all states such that X is
less than Y and you've proved that X is
less than Y is an invariant to the
program and now you use that as a
representation for your reachable states
even though it actually includes a lot
more states and the trick is to find a
cue that's sufficient to allow you to
prove termination so the trick is is
that you build an AR of our prime which
is an over approximation so it's
slightly larger perhaps then the real
are but now very easily you can prove
our prime terminating and then if you
can prove our prime terminating you know
the R is terminating because it's a it's
a larger set so as a larger relation and
any sub relation of a terminating
program is also terminating okay so
that's that's basically but that was
like the that's what it's called the
supporting invariant and this is that
the the tricky bit of proving
termination it has been for many years
okay the good news is that the search
for q is basically over right we don't
have to worry about this anymore so
basically slam tools like slam and all
these other tools that do things like
slam can be tricked into find a qi q for
you
and that's now it's magic you can just
go download some tools off the internet
and it will find Q for you and i'll show
you how that's done in a few minutes so
I'm going to I'm going to talk about
this material at a slightly abstract
level and then we'll close with some
examples and things should become a
little bit more concrete so basically
that sorted out and we didn't have to do
anything like some other people did that
for us okay so that's the first problem
solved and now the next question is this
how to find the termination argument how
to find the ranking function and so this
is a not the original procedure that
Andre and I came up with this is a
procedure that's a refinement of it so
there's some some papers that do one
thing this is the the latest what what I
do in my tool now called maladies called
t2 and so what we're going to do is
we're going to start off with an empty
termination argument okay so this is the
termination argument this is the if you
will like something like that that
relation we built from the ranking
functions but we begin with the empty
relation and okay so sorry so this call
here this is basically a call to slam
and i'm going to show you what that
looks like in a moment okay so if this
inclusion holds then we've proved
termination okay and the first time
around if this inclusion holds the
program isn't doing anything very
interesting right it's like the empty
relation so it's this isn't a very
interesting case but so it's pretty much
guaranteed that this this is going to
fail the first time so typically it
won't hold and then we go into the loop
okay so now if it doesn't hold what do
we do we find a counter example and I'll
show you what that looks like in a
moment it's a some path through the
program right so it's some state and
another state that's that's in our but
not in the termination arguments not
allowed by the termination or even and
you kept back and typically be
represented as a path from the one state
to the other state and then what we do
is we add that into the set of counter
examples we've seen so far and then we
find a new termination argument based on
the counter examples we've seen so far
so so in some sense where pot where we
come up with the termination argument we
attempt to prove it and it turns out
that's a question
we can post slam and it finds the
supporting invariant and does whatever
it does to find that and then if that
succeeds and we're done and if we fail
then we get a counterexample to it and
we add that to our set of counter
examples and then we synthesize the new
termination or argument in try again
okay so basically we start off with the
empty relation maybe we get a counter
example we ought so this is this is
interesting so this is something that
really unlocks our ability to prove
germination it turns out that and this
is work from up from Andre up in the at
the top of the room that the search for
linear ranking function so if you have a
program if you have commands that all
expressed using linear arithmetic and
you want to find a measure of one of
these functions f that's expressed only
in linear arithmetic then that's
decidable and actually quite easy and
it's using something called Farkas lemma
so we do some trick using Farkas lemma
reduce that to a question that we can
solve with an off-the-shelf smt silver
like is m3 which is something that comes
from Microsoft Research and it fine
automatically finds our ranking function
or our measure and then we plug that in
okay so we just add that ranking
function in and try again and maybe this
doesn't hold so maybe we get another
counter example maybe it's a real kind
of simple and we hand that back to the
user maybe it's not maybe if it's not
then we just find a new ranking function
we keep going okay so now let's look at
some examples so notation so the star
means non deterministic choice so you
don't know this is like user input right
so when x gets star means we know
nothing about X it could be any value
okay and so if we're going to do a proof
for this program we have to consider all
possible values that X could take and
another thing is that we're going to
assume that programs are that variables
range overall numbers not they're not
like finite finite width so they're not
like 64-bit or 32-bit so we're going to
consider all integers okay and the
question is does this program terminate
oh who said no okay well why not
it was 14 so if it's minus 1 we won't go
into the loop so you're halfway there so
now if it's positive visit terminate
it's gonna get more and more awkward
longer we wait throw an answer let it up
yes it permanent okay great hey you can
add why well because she did if X is
negative it just does not start yeah in
other ways it works into it gets
negative great so your ranking your
grandmother told you X or its minus X
right yo XX is going down so yeah give
me a state and ask what's the value of x
and that that's the function that's
going to go down okay Oh funny all my
friends on skype so okay so I promised
you that the check of the so I have a
termination argument and the checking of
the inclusion of that termination
argument can be expressed using
something called slam so I'm going to
show you how we do that so we're given
that program and given I'm going to
start off with the termination argument
empty which I'm going to represent this
false I do the following program
transformation which I put up in red and
this introduces an assert ok and this
assert will fail if and only if this
inclusion doesn't hold okay so i can put
so if i have a different termination
argument if i have t then basically what
i do is i replace false this is certain
false i replace with the expression of
tea and I'll show you what that looks
like in a moment okay so the idea is
that there's this new variable called
copied and it's initialized to zero and
the program is going to execute for
however long it once yeah and imagine we
we come to here and we ask is copied
equal to 0 yes it is 0 and so this is
again is non-deterministic choice so
this by the by the way is like them by
far the most important point of the talk
like does it matter if you know how to
prove termination doesn't matter if you
understand my talk if you're doing
anything formal with programs during
your PhD non determinism is your friend
right so it's something that you did
very hard to execute but if you're doing
proofs of programs it's absolutely
crucial it's it's a great great
technique and
a little counterintuitive if you've only
written programs they're not proved
programs okay so the trick is is that we
don't know if we're going to take this
transition or not if we go into the loo
if we go into the conditional or if not
so imagine we don't okay so we come to
the alts we X we don't go into the elds
case and then we continue on so we could
basically execute this program just like
the old program no problem right because
we can take we could continue not to
take the transition into the
non-deterministic choice so imagine that
we're executing and we do take this
choice so we copy the valuations of the
variables x and y into some other
variables that we've introduced and then
I said copied to one and so basically
what I've done is I've taken a snapshot
of the program so I have allowed the
program to execute any amount of time
and non deterministically at any point
during the program's execution I could
take a copy of the other values of the
variables ok so then imagine we do that
and then we come here and we leave and
we go back and we come back around and
now copied is equal to one so we're
going to go to the elds case and then
we're going to assert false and then we
exit right but actually assert fails and
we can't prove that the assert won't
fail right so the cert does fail thus
this inclusion doesn't hold right and so
what I did is I basically allowed the
program to run any amount of time grab a
state and then the next time around in
the loop I asked is the old state and
the new state is the in some
relationship in this case the
relationship with was false and no it's
not in that relationship so we're done
ok so what I can do now is and that's
what the counter example looks like so
we we are kind of at this step here the
inclusion didn't hold we get a counter
example so the counter example is that
path through the program and the
termination argument i'm going to add is
X goes down so the ranking function or
the measure is X and how I express that
is by the old value of x is greater than
the new value of x so that's saying the
the function which is X on the old state
and the new state that goes down and I
add that as an assert and now this is
cert using the tool like slam we can
improve
this is certain won't film and so thus
we prove germination and I'm cheating
slightly I have to say that also X is
positive but I want to get into the
details but um but so that's that's how
things go so that's the the next that
step so we would have added that
termination argument into our set that
that that counter example we would have
added that into our set of counter
examples and then here we use some that
constraint solving techniques that I
asserted made oblique reference to
define the termination argument X and
then I add that in and then now I asked
does the inclusion hold again and the
second time around that inclusion will
hold thus we're done and we proved
termination so that's how that's how t2
or terminator works okay so let's look
at some oh and I should say this so so
this assert is representing they be the
lifting of F where F is the function
that says give me the state of the
program and I ask what what is the value
of x and the state okay so let's look at
a more complicated example does this
program terminate
others guesses nice yes why correct well
if so if Y is greater than zero then in
what is s so I can continue looping
without decreasing why and it is way
another the condition of the movie to
propose so some people will find you
using their everyday lives why it blows
away X so so imagine X is positive and
then you go into the Y minus minus case
you blow away x but the thing is is that
you can only do that a finite number of
times because Y is some value so so the
the termination or en I'm and by the way
the aim of this talk is to sort of
introduce you to the topic Sydney to the
literature so it's a little bit informal
so I haven't described in formal detail
with a lexicographic ranking functions
but I'm using one here so basically the
termination argument is a little bit
more complex it's what we end up finding
is X goes down and why doesn't go up or
Y goes down so basically it's try the
ranking ranking function X and if that
doesn't work then try why but when X not
I'm sorry try why and if why doesn't
work try x but make sure that that it
doesn't screw y up right so if why
doesn't strictly go down and make make
sure at least doesn't go up and so this
is a slightly more complex ranking
function and this is an example of a
ranking function that is not going into
the natural number so i remember i told
you if you don't know what a well order
ordinals are just think natural numbers
sometimes you have to do something a
little bit more sophisticated and this
is an example where we're doing this
we're actually have a ranking function
that's going into pairs but it doesn't
really matter too much so the the point
is is that so how does this go so it's
going to first start off with the empty
termination argument as we did before
it's going to fail we're going to get a
counter example and the counter
Temple is going to visit through the
loop twice visiting either the X minus
minus or the x- month there are the Y
minus minus case and we'll get from that
case we'll get the ranking function
let's say we visit the X minus minus
case then we'll get the ranking function
X so we'll say oh ok so the termination
argument we're going to try as X goes
down and so then we try and prove that
but actually that fails right because
it's not always true that X goes down so
the next counter example were going to
get goes through the other conditional
now we get the Y goes down and in that
case so go back to our algorithm here in
that case now we have to counter
examples in the list of counter examples
pie capital pie so now that the finding
of the termination argument is looking
for one that works for both
counter-examples simultaneously and what
we're going to get is why goes down but
if it doesn't go down at least doesn't
go up and X goes down yeah and that's
the termination argument we find and
that will end up holding so that's how
we prove that program terminating ah so
now remember I said that slam finds the
queue for you right now I'm going to
explain that in a little more detail by
the way how long is this hook an hour
yeah I don't get so does this program
terminate yeah why because if lays maybe
didn't just don't drink the big flames
you fix bulletin in agreement you know
so you use so these supporting variances
q gears y+ right so you did you you look
at code and you said okay this is a loop
X positive x goes down and you're like
it must be the excuse going down right
otherwise it wouldn't terminate so
you're like what is it we need to hold
of of Y such that we know that X always
goes down oh why needs to be positive
and then you looked and you said oh the
loop is only entered into if Y is
positive and no one's modifying why
during the loop so therefore you
basically proved my induction than wise
positive right because you said oh look
it's true when we go in and no one
touches why
that's why is always positive and so why
is the supporting invariant why is the
queue right that I use so it's like if
you were to do have done this proof by
hand in the 70s what you would have done
is you would have said oh first of all y
is positive and you would prove that my
induction and now you get to take the
loop and assume y is positive on the pre
in the post and now showed oh well that
for therefore X goes down okay so what I
meant by slam computes that
automatically is that if i put this
termination argument in this is the
right termination argument that X goes
down we don't have to talk about why but
somehow slam or tools like slam are
going to be able to approve that that
assert can't fail and so if you look at
the internal details of how the tools
work they're basically designed to find
supporting invariance to show that this
er can't fail and these tools do not go
by enumeration right they don't say 0 x
and y they could both range over all
possible integers so now let's case
split on all of them they don't try 0 00
01 02 03 and then you like 11 12 13 they
that's that's the nightmare it's not
going to work so what they end up doing
is they have various strategies for
guessing inductive and variance to show
what it is they're trying to show and so
the tools they're also undecidable right
this part the problem of proving that
the assert can't fail is an undecidable
problem but they have strategies that in
practice work and so they will be able
to prove that the assert can't fail and
it will guess somehow an inductive
invariant and that's a whole different
talk and again if you want to hear about
how those tools to it you get me on the
whiteboard you won't be able to get me
to stop but I won't tell you okay we're
in this talk this method not the time to
tell you but so basically those tools
automatically find the inductive
invariant the Q and so that's why I said
there are two problems and one of them
isn't a problem anymore and we didn't
have to do any work now someone else did
that work right and that's what I meant
by that goes get there
okay so that's that's that basically
sort of that so this was a the first
page of paper that Andre and his former
advisor ondrea's wrote that for the
first time so I mean people had worked
on termination proving before but it was
really only for three or four line
programs but this was the first paper
where people showed that it could work
for industrial sized programs and this
is this generated a lot of excitement
and it introduced terminator and the
real point was that we applied it to 23
Windows device drivers okay so this is
the 23 and these are the the number of
lines of code so some device drivers
have thirty thousand lines of code many
of them are sort of in the 5 to 10 k
range and we found a number of bugs
what's amazing about these bugs is that
these device drivers are device drivers
that we've been handing out as good
examples of device drivers to other
people for years since like 1993-96
basically windows and T started right so
these are like what we call the sample
device drivers they're real device
drivers like parallel ports cahsee
keyboard floppy firewire etc but they're
also device drivers that we hand out the
source code to and then typically if you
are like working at a company like
logitech and you're writing a device
driver what you do is you copy and paste
one of these sample drivers and then
modify it and these termination bugs
that we found worry have been in the
device drivers for quite a while and
people are hitting them it turns out we
didn't know them oh and one of them is
in this coat so I'll show you that bug
okay so so you'll remember this this
code here so it turns out that entry so
it turns out the entry is going to is
walking over a cyclic doubly linked list
okay and I've only drawn the forward
pointers so this is read Q and this is
read q flink so entry starts off at read
q Flinx that starts here and it's going
to on every iteration go forward one and
it's going to do that while entry is not
equal to this one here okay so to
understand how this bug work so imagine
that entry is pointing to this note here
the red one
and what the device drivers doing is is
calling something called remove entry
list which removes a node from a cyclic
w linked list so how it does that is it
makes the it goes to the previous
pointer and makes that nodes forward
pointer point ahead one and it goes to
the forward pointer it makes its
previous pointer point back one more
right so here I'll just execute that but
member i'm only showing you the forward
adjust so it looks like this that's what
it does right so it goes to the red
nodes previous node and makes its
forward pointer point ahead and vice
versa for the back pointer okay and then
we do something right and so this this
this initialize list head what this is
doing is its is it's creating a new so
it's assuming that you have allocated a
node and it's creating a new cyclic
doubly linked list this is going to make
its forward pointer point back to itself
and then back pointer to point back
yourself again and and unfortunately
entry and this expression being passed
to initially Lou said alias okay so that
actually has the effect now up here on
the screen of making the red node point
to itself and that's entry so if you
look now at entry gets an entry arrow
flink that's not going to do anything
because it points to itself okay and
entry will never equal read q it can't
write because it's now we have two lists
and entry is its own empty cyclic doubly
linked list so we're walking the wrong
list now so we can just walk this
forever and we're never going to hit
this node over here so now we've we've
hung the Machine never friend in the
windows kernel team that I asked if bugs
are real nice yes it's real and then
makes this point so when a machine
crashes when you violate a safety
property usually bad things happen and
you know right away the bad things have
happened right but if you're violating a
liveness property typically you don't
know maybe you should just wait a bit
longer and so what we were seeing in the
field is that people for years have
their machines have just been hanging
and they were just resetting them and we
weren't learning about them whereas if
the machine crashes we hear about it so
often the machine later versions of
Windows when they crash they would like
upload a little bit of information about
the crash and so we've learned about the
crash and we we could diagnose who's
causing the crashes but these hangs we
weren't we weren't we don't really know
anything about them okay and we found
some proofs turns out there also some
cases where we couldn't prove or
disprove anything and then that's been
the work that's been happening from that
point on so we have paper that describes
a better technique for handling heap
technique for making things faster a
technique for handling non non linear
ranking functions supporting threads so
actually supporting concurrent programs
and there's an article in the Scientific
American about this work this paper here
applies it to the similar techniques to
these crazy non-blocking algorithms
right these like flock free data
structure algorithms so it turns out to
be non-blocking is really a liveness
property so when you write one of these
crazy non-blocking algorithms you want a
liveness property to hold and so we have
a paper on on how to prove that using
Terminator style techniques this is the
paper that handles recursion this paper
shows how you can prove all properties
in a temporal logic of ltl linear linear
temporal logic so any property express
an LTL it turns out can be reduced via
the technique that's known to something
called fair termination which is a
cousin of termination and supporting
fair termination and this approach is
really easy to do so we have a paper on
that this handles another logical CTL so
here you can say in the simple logic you
can say things like whenever X is ten
that in the future ex will be 20 and
it's talking about all of the states
reachable from X equal 10 so you sort of
think of the program programs execution
of the as a tree and you can talk
about properties that hold on the tree
that represents the execution of the
program I'm basically a F is
determination so the trick we pull in
this papers to basically support AF via
the same trick that I showed you for
termination so it turns out the
termination is in this logic is just
expressed by AF false this another paper
oo right and so this so this paper is
applying these kinds of techniques to
biological systems so it turns out that
turns out that biologists particularly
the biologist studying genetic like
things like diabetes skin cancer
leukemia their unjust trying to
understand how cells work and how they
interact and that's done via genetic
regulatory pathways and so biologists
have models of how the various pieces of
the body work and it turns out those are
basically big concurrent programs and it
turns out the big question they're
always wanting to know something called
stabilization which is very very close
to 'some which is very very close to
termination so basically they want to
know would the system always eventually
reach a state and then stay in that
state so it's all just almost like
termination and so the same techniques
work for proving those kinds of
properties so together with a biologist
who works in the lab we've developed a
system for biologists to model their
genetic regulatory pathways representing
various kinds of disease and then they
can search for drug targets they can
like search for changes in the model
that they think a drug chemically could
could cause and then show that that
would give stabilization in the case of
disease and thus show that that would
cure the patient and so this is
something something we've been doing
recently oh and then the other thing I
want to say is so you remember that when
we looked at this code that had the
cyclic doubly linked list like that kind
of just came out of nowhere right I just
told you oh that's a cyclic doubly
linked list so it turns out when you're
trying to prove termination
understanding what native structures are
is absolutely crucial and there's a
whole other line of work on that and so
here are some papers on how we've sort
about sort of that problem out so that's
actually in some sense a much trickier
problem improving termination so I've
been involved in another project called
Slater that takes in C programs and
tries to understand what the data
structures are by doing analysis so
we'll say 0 X at line 50 is always a
pointer to well-formed cyclic doubly
linked list and it talks about all the
aliasing relationships between all the
pieces of the heap and that's a whole
different line of work you can ask me
all about that too okay so i'll conclude
now so so the previous wisdom like if
you would ask someone in the 80s 70s 90s
hey do you want to work on the area
program termination they would have fits
thought you were nuts yeah because it
was the halting problem and everyone
told you that was a problem you want to
stay away from and one of the trends you
see in computing in the same in the past
ten years is basically nowadays the
perspective is that undecidable problems
or NP problems are the only interesting
problems left right like so sat smt
proving programs these kinds of these
are the kinds of the areas where people
are are are now looking into and try to
do science and the linear problems or
decidable problems are other sort of the
easily decidable problems are in some
sense no longer research so that's sort
of a change from from the old ways that
people do things the problem now it is
is that people think the termination
problem is solved so I want to give you
one to leave you with a couple of things
that can't be done currently so
currently all all program analysis
engines both termination liveness safety
struggle with complex data structures
things like skip lists or complex tags
alright another thing that's tricky is
programs that mix infinite state with
bit vectors so if you have programs that
operate over lists but don't really do
very complicated things with bit vectors
that's fine and if you have programs
that do things with bit vectors but
don't really build up data structures
that's fine but if you have programs
that you do both you run into trouble
currently with today's tools another
thing is that all these tools typically
require
source code right they don't really
understand binaries and it turns out to
be trickier than you might think to
analyze programs that are actually in
the binary like x86 turns out nonlinear
systems or something people are really
still struggling with it turns out that
proven termination of concurrent
programs is tricky so we know how to do
either extreme we know how to prove
termination of the craziest fine-grained
concurrent programs and the reason is is
because the programs are so hairy
they're written by such a crazy expert
that basically the code is the proof
every possible weird case the programmer
has written a conditional to handle it
so you just walk over the code and it
tells you all the cases you have to
worry about and then the kind of code
that like takes one lock to protect a
whole list that's no problem so the
tricky bit is these like like hand over
hand locking or sort of like like mild
grain concurrent programs proving
termination of those programs is is
tricky and there's a a technical reason
for so the technical reason is that when
you prove programs typically concurrent
programs typically what you want to do
is you want to only reason about one
thread at a time so there's a technique
called relied guarantee reasoning that
you use for that and the problem with
rely guarantee and termination is that
the silver bullet of rely guarantee
which is that the circular proof rule is
unsound for termination it's only
sounded for safety so basically with
safety you can prove something about
this thread and assume but while doing
it assume it holds of the other thread
and then when you prove it of this
thread you can assume it holds of this
thread and for safety it turns out that
sound but for termination or liveness
that that's not sound and so you're not
allowed to use that rule for liveness
and thus it's tricky to prove formation
and that's the an area of current
research oh and then another thing is
that so we know how to prove termination
now see programs but proving termination
of java programs or proving termination
of camel programs for things like more
complicated programming structures like
higher-order functions together with
mutable state that's a little tricky and
then the final thing is that these you
see increased scalability and
performance and precision of these tools
but we
a long way to go so it's that's not
quite time to just put these tools in
Eclipse and just declare our success
right like we did your average
programmer writes his average program
and runs today's termination perverse
things aren't going to go well so it
only works really well on sort of niche
kinds of programs like device drivers or
these models of biological systems or
fine grain concurrent data structures
etc okay so there's a web page that has
many research papers as my contact
details there's the ca-siem article that
you can read the kind of goes through
this material at this level if you want
to read about in a lot more technical
detail than read the other research
papers I'm a so i'll give my pitch now i
am a researcher what is a job at
microsoft research do no one knows like
we just kind of hang out and think about
things right like why don't have to
teach i don't really have to do anything
for anybody so i'm pretty free to do
what i wanted to do and so if you want
to do an internship on this kind of
thing then you should email me and we
can talk about it because i have lots of
time to work with with people who want
to do that kind of thing and then when
you finish your PhD if you want to post
doc or if you want a researcher position
in the lab that's really nice place to
work because you get to do whatever you
want to do get paid really well to do it
you don't have to write grants don't
have to teach so it's a wonderful life
alright thanks very much does this
domination prove itself terminate always
on it doesn't turn and it doesn't
terminate for a couple ways the
germination argument just grows and
grows that's one way yeah and the other
way is that the checking of the
inclusion might not terminate so yeah we
could just keep fine you could keep
adding something to tea and the other
way is that inclusion might just go to
lunch I never come back because that
that's that problem is also undecidable
so the tool that we call it depends on
what we call
also we call like for example tools that
do abstract interpretation are designed
to terminate but they're very in precise
so they'll come back with they don't
really they can't really give you
counter examples so we needed tools that
find counter examples and those tools
often will just go go on forever and
refinement yeah exactly yeah so that's
what we typically use and those tools
can go I mean they frequently do go go
to watch okay what do you do yeah I work
on a sub store ification but you need to
the language so I don't be tackled
damnation shift and I went from deciding
if the program two minutes ago and you
consider this as a problem for trying to
terminate the program faster improving
the code OIC so yeah there's some people
who work on I you can turn this
technique pretty easily into something
that tells you the asymptotic complexity
of your program so it'll or tell you the
like worst-case complexity of your
program so basically the ranking
function that we find all of us is what
you need to tell you how the complexity
and then from there it might be you can
just see now where the problem is and
you can fix it there's another thing
that people are doing is they are taking
programs and they are discovering under
approximations to the precondition that
you would need to guarantee termination
so but I haven't seen people suggesting
improvements formally but I've seen
people doing things kind of close like
they put a lot of programs don't
terminate like string like string Len
from C right doesn't terminate all right
if you give it a badly form string it
won't terminate but it terminates all
under reasonable preconditions
so you could ask what is the
precondition under which he terminates
and you can using some tools you could
automatically infer that or for larger
programs and then you could ask oh like
what is the complexity oh it's the
length of the string and then you could
imagine now taking the information and
somehow improving it but yeah feeis and
so the thing is that this technique of
program synthesis become a little bit
more hot recently so maybe some some
crossover between those techniques but
you could use but why is it harder for
binary code enforced see goat with so I
you need variables right but with
binaries its kind of even a hard to
trick figure out what like like we in a
program will write X right next just
kind of hangs around but in a binary x
is sort of slipping into memory and
slipping back out and you're having to
like constantly observe like you can
track of what the variables are is
tricky so if so if you can work that out
then you're here intermedius book it
would be easier it will be easier though
I haven't looked into its much detail
but it would be easier yeah and then
especially with like weak memory and
stuff then now things get trickier also
right yeah he's in the ring with static
analysis and seen superclusters
languages I mean what about memory type
safety box in there so are you asking
there are any benefits to our hybrid
solution combining both static and
dynamic runtime analysis potentially yes
I mean this is a very static approach
right so you could imagine that we might
fail to prove termination but we provide
some information you could imagine while
the program is running if it looks like
it's not terminating than trying to
prove termination of it you can imagine
collecting up the path that scene and
only proving termination of the paths
it's visited not the pads it isn't
visited yeah so you can imagine various
things between so I know that at some
point the wah
you know like in the old days of like
windows for example you would start
something up and it would just sort of
hang and I know and sort of newer
versions of Windows they have like some
sort of cancel button so you can be and
you could imagine hooking onto that and
then saying oh now do you like before
killing the thread can you guarantee
that can you show that it's gonna make
progress or is it a little just stuck in
a loop it would be an option for device
driver you could imagine you can imagine
trying to back it out you can imagine
seeing that it's actually is making
progress and then just letting it go or
start proving non termination that's a
slightly different than proving
termination and then saying we're never
going to get out of here and then trying
to back it out by um figuring out which
resources it holds on to and trying to
release them yeah just convince the
first message about whether whether your
termination proven terminates if you get
into one of these non terminating
situations is that like is there
anything you can do about that like if
you detect it somehow like if you have a
timeout on your inclusion checker do you
just have to give up one or is there any
kind of like continuing with Luigi's
precision you could do so there's other
things you can do so there's another
there are other techniques for proving
non termination and it turns out like
for example there's a paper by some
researchers at MSR bangalore where they
combine termination and non permission
proving and they actually help each
other out so they first try and prove
formation a little bit and then they if
they don't right away then they go to
the non termination proven it turns out
the non termination prover gives them
more information and so you can go back
and forth so that's that's one one way
you can help it another thing is in
Prince like in practice like when you
like like what I used to work at
verifying circuits at intel and i would
run these kinds of tools on you know
like circuits thorpe are like any
informant processor and you can see from
the output the spew of the tool whether
or not it's going to converge right
because you can just see it's like oh i
see what's doing its you know
trying x equals one and strang x equals
2 so some heuristic is broken and so you
can just tell its back ramic progress
and so for these what you see is it
tried the ranking function X 0 now let's
try the ranking function X plus 1 now
it's trying X plus 2 is obviously you
can look at the code you know it's
obviously not going to head towards it's
not going to converge onto something
seemed to kill it so there are going to
be here 06 you can use to decide that
you're screwed you're screwed okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>