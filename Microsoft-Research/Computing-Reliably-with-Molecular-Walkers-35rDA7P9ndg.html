<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Computing Reliably with Molecular Walkers | Coder Coacher - Coaching Coders</title><meta content="Computing Reliably with Molecular Walkers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Computing Reliably with Molecular Walkers</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/35rDA7P9ndg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
hey great welcome back to the afternoon
session by the way my name is Andrew
Phillips I leave the bio computation
group here at MSR Cambridge is my
pleasure to welcome professor Marta via
Tosca she's traveled all the way from
Oxford today to give this talk so we
appreciate that monitor is professor of
computing systems at Oxford University
and she's a fellow of trinity college
oxford she's won numerous awards
including the milna lecture I'm
recognition recognition of her work and
she's also a fellow of the british
computer society as she's a world expert
in probabilistic verification and she
led the development of the prism public
model checking tool which has been used
internationally to verify range of
systems from computer communication and
security protocols to power management
systems and more recently biological
systems and today she's going to talk to
us about some of the work she's been
doing in reliably computing molecular
Walker's thank you good afternoon it's
very nice to see you all here and um
such a help today so what I'm going to
talk about is what I've been doing for
the last three years but it started
about ten years ago when the prison
probabilistic model ticketed andrew has
just mentioned started to be used for
verifying biological systems now from
biological systems we have moved to DNA
computation and what I'm going to talk
about is how you can compute with DNA
but I will focus on molecular walkers
and I suppose I need to introduce the
topics what does it mean to actually
compute with molecules and specifically
with molecular walkers so first of all I
would like to get you to think about how
we compute these days on computers we
compute and then micro scale but
molecules DNA
are all at the nano scale we are talking
about 10 to the minus 9 and I'm sharing
you examples here of two types of
molecules that I've worked with here is
the human fgf protein and the other one
this is well known to everybody this is
the DNA molecule which stores the
genetic code its bliss it's two
nanometers but the length can be huge
you can create strands of DNA which are
which consists of thousands and
thousands of these so-called base pairs
what we also know is that DNA can
hybridize that is it can form into a
helix the helix structure Criken boxin
have discovered it and also so did
rosalind Franklin so this is DNA but of
course the primary focus of our DNA has
been biology has been in biology to try
to explain the secrets of life but now
what we want to do with it is one to do
molecular programming molecular
programming involves the application of
computational concept and also design
methods to nanoscale devices and
computing devices and nanoscale robots
biochemical systems and now molecular
programs are networks of molecules they
are networks of molecules and what these
molecules can do is that they can react
for example hybridization is an example
of a reaction between two single strands
of DNA they can also interact they can
move now the key observation is DNA we
know it's those genetic code so it is
very useful for storing information but
DNA is also programmable we
can program it in a sense that we can
control the molecules to actually
compute to deliver to us the results
that we worked and this is what I going
to talk about today now this computation
also proceeds autonomously it's just
autonomous and of course from my
perspective I'm a computer scientist and
I imagine you also computer scientists
this is a very exciting new field and a
field in which because this is molecular
programming won't do programming what we
want to have is programming languages we
also need new design environments and of
course we all have to work with
experimentalists because you need to
prove you need to prove that these
devices work in real life ah so you
might ask what is a molecular program
well in molecular program if you
remember your chemistry maybe it studied
chemistry for your a levels or during
the degree this is simply a set of
reactions you choose some species and
you d species react together they can
bind they can unbind this is one example
where you have species a b c and d this
is also known as a chemical reaction
Network which has been studied in
chemistry in theoretical chemistry for
some time so in effect here we are
computing with chemistry but how does
DNA come in well there is this one
important fact which has been
established both theoretically and
experimentally and that is that any
finite crn can be implemented with gio
dang voltages any finite crn so you can
compute it using a reaction chemical
reaction networks biochemical reaction
networks and you can then implement them
experimentally
using DNA so he our DNA is used as an
information processing material okay we
are using it as a material to build
artificial devices so this is a little
bit different from biology you want to
build artificial devices and we want
these devices to compute and there are
several technologies that exist the one
that is well known and look like a burly
and Andrew Phillips haven't all that our
supporters is called DNA strands de
plata displacement systems ah ok so how
do we compute with DNA and in particular
how do we compute with DNA walkers well
first of all digital circuits as you
know digital circuits computer boolean
functions using land or and games so
they work with bits zeros and ones they
really represent low and high voltage
but this is a discrete this is a
discreet places where you start with
some configuration of zeros and ones and
you produce some other output of zeros
and ones and we also know that
verification which is my field of
research is very well established as a
design methodology to ensure that these
circuits are could behave correctly and
compute the correct results now DNA
computation is different you need to
think this is one form of DNA
computation it has been described as
computing with soup and what that means
is you legit you take a test tube and
you put into that test tube lots of DNA
molecules you have to design them in
such a way that they can bind in the
correct order and produce the result you
can then observe the finished result by
something like fluorescence and this is
an example from a page
hair by lulu and Eric Winfrey where they
have designed a DNA program which
consists of hundred and thirty strands
and and it can compute a square root of
a 4-bit number okay so notice the inputs
here are strands and the outputs that
are produced not also strands they are
non zeros and once their specific DNA
strands now this is slow okay this is
slow and of course doesn't do much but
this is a proof-of-concept it completes
in about 10 hours but I'm going to show
you how we can do this type of
computation faster now the second
example that I have of what DNA can do
is DNA can fold into structures okay it
can fold into nano structures and people
have been very inventive in trying to
show what kind of structures this is
known as DNA origami following rather
bonds and this is one example I've also
seen a map of china now people have made
boxes etc now this is also programmable
in a sense that you can choose your
design okay you put it in a test tube
and it falls just like this it forms
from one very long circular DNA strand
which is pinned together in place by
short strands which we call staples and
i'm working with angio turbo field at
Oxford and in turbo field lab they build
these kinds of structures this is the
actual picture from the afm atomic force
microscopy and this is the time which
has been designed like
you can see there is the single circular
strand and it is pinned down with these
staples okay so this is an origami tile
and to give you an idea for how it works
here is it vidiyum which will show you
the process so this is the single
circulus strand which we call a template
strand and it's in solution so in
solution you'll have lots of dates but
you also put in staples and these
staples can bind because they rely on
hybrids that hybridization they bind to
specific sections of of the template by
Crick and Watson base pairing so this is
of course not the real picture this is
an artist's impression I showed you the
real picture and now you have the tile
okay there you are so in the design that
i showed you we have 76 staples okay 76
staples and about two and a half
thousand base pairs in the template okay
ah but now what we can do and this is a
gain some work that comes from turbo
field lab what we do is we take an
origami tile and on that origami time we
can print tracks prints prints in quotes
and what that means is that we put
single DNA strands we attach them to the
tile and we make them into tracks and
then you have another DNA molecule and
that molecule starts by being attached
at the beginning of the track and then
you experimentally force it to detach
and attach to the next track and this is
what a molecular walker and I'm talking
about DNA walkers because I'm talking
about the technology that was developed
in angio turbo fields lab and it is all
made from DNA it can also carry cargo so
the idea is that this is an inner robot
which will actually deliver something
you know directly Institute at the at
the nanoscale now ought to share you
this is a 2011 paper and what you can
see here is a real-time video but this
is the time in seconds this is a
real-time video of the origami tile and
what you notice is that this is a random
process so this Walker doesn't jump
immediately it's a random process it
just looks for a place but then jumps
back and forth until it irreversibly now
jumps to the next position at around
four hundred and fifty seconds so
and then here just okay so this is how
we do computation with molecular walkers
so the walk is stepping action in more
detail is as follows so first of all on
this DNA tile we print these tracks that
is be attached single DNA molecules and
you can form them into branching
circuits so it's a decision tree
initially they are all blocked that
means you attach the DNA strands so that
no other strand can attach to it at the
top okay then they are programmable in a
sense that you can selectively decide
which sections of the track to unblock
you unblock them by adding specific
enzyme that will cut these sections so
we started off with this kind of circuit
but these were unblocked and these two
branches were blocked and now we have
adopted that okay now it the walker is a
molecule which carries a quencher and
the idea is that this quencher will be
used to signal that it has completed the
computation but you can attach true or
false you know depending on this is not
false fluorescence you can attach
different color to detect whether it got
to the true ok I have detected cancer or
to the false note no I haven't detected
anything but they have completed my
computation and then the Walker itself
ok in this random process in this random
process you again use certain enzymes to
make it detach from its initial position
and then move on to the next position
but as I said you know it it's a random
process and in fact the observations
show that it can jump over one or even
two
anchors but not three not sleep okay so
this is more like the computation that
be I used to because it is a decision
circuit it is a decision circuit which
you can also program and in fact DNA
Walker circuits that we have studied
circuit switch which we derived from
experiments in turbo field lab and in
those experiments from which the video
comes what they did is they had these
so-called single Junction and double
Junction binary trees okay so binary
trees so in general this I mean this is
a proof of concept so of course in
general you can compute on any branch in
you know binary tree but in fact there
is no reason to actually force the
computation into a binary tree and this
is an example that I'm sharing you where
this circuit starts here in this initial
position and computes exactly the same
function is that circuit but it does it
more reliably and it also does it more
efficiently how do we know because we
have employed quantitative probabilistic
verification in order to establish this
now this technology that I showed you is
only a single use technology okay so you
build this device you use it once you
cannot reuse and and it also burns
anchors so the walk I cannot walk back
now they are in Android hyperfuse labs
they are now working on a technology way
you do not burn anchors
therefore you will be able to be used
their computation now unlike the
computation in solution this computation
is different because the reactions in
solution happen in a well-mixed
situation that computing with soup where
we can rely on something like mass
action kinetics to tell us how about the
dynamics about the dynamics of the
process but here the actual rates are
localized because the Walker has to jump
from one position to the next position
so in fact we had to fit the border to
experimental data to actually derive the
rates ok so why DNA programming well our
DNA is very versatile it is also easily
accessible it's cheap and it's easy and
cheap to synthesize as well so you just
design you know the sequence of base
pairs and you can actually order it and
it gets delivered it is also very good
for bio sensors ok because it can
connect he can interface to biological
systems to chemical systems and it can
use its programmable so it can be used
to identify a specific substance for
example is this you know a dangerous
molecule and then if you deliver a
medicine in a box you can actually
control the release of the opening of
the box and you can treat it this is
sometimes known as the doctor in this
set but of course for come as computer
scientists the nano scale offers great
opportunities to defeat Moore's law ok
we can move to the nano scale and we if
we can actually build devices are
reliably using some kind of combinations
of DNA circuits origami etc then you
know we can move
field of computer science forward now
what I have been focusing on is how the
field of quantitative verification can
actually help in ensuring that for
example these biosensors work reliably
that is can we find banks in the same
way as you can use model checking to
find bugs but also can you compute how
fast the method it so how fast would the
warp it with a particular design work
notice thats the cast assist is
essential we've seen it on the video and
the reliability of the computation is an
issue because the war pet can not only
jump over one or two and bridges what it
can also do it can actually jump off if
you have several times in a solution it
can jump from one time to another so
reliability of the computation is an
issue but we want to use that technology
for biosensing so what I'm going to talk
about now is a quick tour of what we did
focusing mainly on the molecular walkers
computation and this can be described as
modeling verification and synthesis for
DNA walkers so this lecture is
concentrating on DNA Walker circuits and
I say a little bit about what
probabilistic model chicken is what
prison can do and what you can use it
for and you know what you can use it for
when you apply it to DNA computing we
have actually used it to find a bug in a
DNA program we have analyzed reliability
of molecular walker circuits and we have
also developed techniques that allow us
to actually synthesize
rank parameters for the workers so that
we can guarantee a specific level of
reliability or performance so the
question that's driving this talk is
what what good is you know probabilistic
verification in this context so modeling
okay what does modeling me now if you
are familiar with you know molecular
structures say biochemical reactions or
you know Ciaran's you would probably be
familiar with the deterministic approach
for they modeling so we assume you know
is assume in your suit you have n
different molecular species which react
you then assume that you have a fixed
volume constant pressure and temperature
and then with a continuous deterministic
approach you can write down in quite a
mechanical way functions Oh des ordinary
differential equations which are tell
you how the average concentration
concentration of each molecule you know
develops over time so we can analyze its
dynamics but there is an alternative
approach and other produce known as the
discrete stochastic approach so what we
do with the Eau de approach is we simply
approximate the numbers of molecules
with a real valued function okay but
with a discrete stochastic approach we
take this soup okay and you consider
discrete States in that soup and each
discrete state is then a vector which is
as wide as the number of species
and each component of the vector is the
number of molecules of that species and
then are the from these states evolved
because the molecules if there are
molecules that are close by in in the
state vector then they can react and it
can evolve and you move to another state
so what we do is we obtain discrete
state stochastic process and in fact if
you model the same system are using
either o de so you know discrete
stochastic modeling you may get
different answers and this is well-known
well-known folklore information which is
very easy to explain but I'll explain if
you ask me a question afterwards so what
we do with the discrete stochastic
approach is we view this system is a
system you can think about it as a
transition system where the states are
these vectors Jake is why does the
number of species which have you know
population counts of each molecules and
the transitions corresponds to reactions
now it's a stochastic approach because
thanks to Gillespie there is a way to
actually describe its dynamics
probabilistically as a function as a
function which describes the probability
of being in a particular state showing
this in a particular discrete vector at
a specific time now stochasticity
stochasticity is very important in the
case of molecular walkers and this model
is particularly good of for when we want
when we have to handle small numbers of
molecules if you have large numbers of
molecules you can just deal with average
concentrations and the approximation is
very good
but when you have low numbers of
molecules and in fact in particular a
DNA Walker it's just a single molecule
then then we need a model like this now
it also happens that if you can put
these assumptions on the volume then the
model that you get is a stochastic
process but it's a process which is very
well known and it is known as a
continuous time Markov chain and in the
continuous-time markov chain rates only
depend on the states they do not depend
on time so for our the more computation
we can work with this type of model but
unfortunately for modeling of the
origami folding we have to go beyond
this model we can still work with city
MCS but we have to work with are called
inhomogeneous CT mcs we're in
homogeneous CT mcs allow you to have
rates that depend on time now because we
have obtained ctmc we can now apply for
a ballistic verification techniques and
this is just a picture of what this
means you know concretely so you may
have these reactions so a and B can bind
and unbind this is a reversible reaction
and here is another one which can
disappear what I derive is a continuous
time Markov chain where each state this
is the number has we are starting in the
state which is just 2 a's 2 b's and 0
abs okay and this is the full ctmc i'm
showing you all the transition assuming
i'm starting with 2a
and to be molecules now because this is
in solution I can rely on mass action
kinetics and Max action kinetics tells
me that the rate of moving to the next
state are proportional to the numbers of
molecules that are participating in the
reaction now so this is this for ctmc
but just two and two molecules but in a
real test tube in a soup you can have
billions ok you can have billions so the
principles I exactly the same but you
are going to have an absolutely huge
continuous time Markov chain which is
the main challenge so what are we want
to do is we want to take our DNA program
and that DNA program in solution is
going to be described by a set of
reactions you also need to specify the
initial conditions going to decide how
many molecules of each species you have
and you obtain then the continuous time
Markov chain well you also give into a
probabilistic model checker such as
prism you give it a specification and
the specification is then expressed in
temporal logic but this temporal logic
is also probabilistic because in a
probabilistic system and just you know
in this we want to talk about the
probabilistic evolution of the states
over time so what this formula is saying
informally is that the probability that
eventually f means future eventually by
time T I reach a state where I've failed
ok so I failed for example to detect the
given molecule so that probability is
less than point Oh
okay if it is my biosensor okay you
would want this probability to be small
if it has failed you know in some sense
you would want this probability to be
small the review input a model you know
or a description of the bottom of that
DNA program and that property what you
would get out of prison is either the
answer yes this biosensor satisfies that
property or not if it doesn't okay that
means it you know has a flaw which you
would need to fix but you might also
obtain quantitative results k
quantitative results means that you
would be plotting the probability or
maybe I'm not talking here you can also
talk about rewards and expectations
against the parameters of the model or
the property and the prism is a
probabilistic model checker that was
developed in my group we've been working
on it since 1999 and fortunately for
this field it supports ctm CS and also
supports a logic called continuous
stochastic logic and with that logic you
can express the properties that I've
showed you before it also supports for
other models but they are not relevant
in this case and it is now connected to
visual DSD it is a back-end to visual
DSD so for example if you are using
Andrew Phillips is visual DSD you can
output prism models of the you know DNA
DSD strand displacement programs now for
the property specification and giving
you here a couple of more properties
that you could check the first one is
the probability of deadlock it turns out
that molecular Walker's can dead
and I'm going to show you how so you
want the probability of eventually
reaching deadlock to be small and
another example is what is the maximum
probability of the Walker eventually
finishing in say 10.5 time units um this
probability to be high but you want the
maximum probability we're here and we
filter over all the possible initial
states and this is something that prism
can compute for you if you give it a
specification description of a DNA of a
became equal reaction system or in a
ready na program but you can also plot
these quantitative results so you can
have parameters again instead of
specifying the band you can just simply
say ? that means prison will return with
the probability and that probability can
be plotted against different parameters
in the model or or the formula so what's
involved in quantitative probabilistic
verification well if you are familiar
with conventional verification model
checking it deals with transition
systems and temporal logic but it
doesn't have probabilities here the
transition relation is probabilistic so
what we need to do is we actually need
to work with matrices matrices which
give you the probability of moving from
one state to another okay so we may have
these absolutely huge matrices if you
wanted to represent say billions of
molecules so in in addition to employing
conventional graph based analysis what
we also have to do is we have to do
numerical computation we actually have
to compute the probability we also want
to compute the rewards which involves
computing expectations and that our
employees linear equation solving and as
a numerical
methods but there is also another an
alternative which is known as
statistical model checking which relies
on simulation that is invoking
simulation runs a large number of
simulation rounds of the system checking
each run against the problem property
and then estimating the probability are
you know that it holds so this is a
statistical method used you know in
machine learning as well as so the state
of the art is actually hasn't changed
much in terms of the largest size of the
model that we can deal with because of
you know the early design of prism
allowed us to represent these large
matrices very compactly but there has
been apart from statistical model
checking there has really been no other
development but we are moving towards
compositional towards compositional
verification and this composition of
verification the idea is that you can
give an ad a large model into components
and then put the results to get so prism
is based on symbolic implementation by
symbolic implementation I don't mean
satis empty I mean binary decision
diagrams prism is able to store these
huge matrices of something like 10 to
the 10 states very compactly using a
variant of binary decision diagrams
which is known as multi terminal
decision diagram so if you know about BD
geez then they have 0 &amp;amp; 1 is nodes MGB
geez can have real numbers as nodes but
if you store a matrix and if there is
regularity in the system this is the
same as for conventional BDDs then this
matrix can be stored very compactly what
you can then do is you can actually
perform numerical computation with that
matrix typically iterative techniques
because with iterative techniques you do
not change the matrix you just simply
multiply the matrix by the vector so the
limitation there tends to be the size of
the vector B which has to be full rather
than the size of the matrix but
simulation based methods which is
statistical model checking they do not
actually build the state space you can
store the syntactic representation of
the model so you can have billions
please what you need to do is to decide
the precision with which you want to
obtain your answers and also the time
bound okay and then you generate a very
large number of runs depending on the
precision and you can obtain an estimate
of the probability with confidence
intervals so generally speaking these
methods are less precise than the
numerical solution methods but they can
handle much larger systems okay so
historically speaking we started working
in prison in 1999 we released it in 2001
and at the time we were working with
networking protocols and randomized
distributed algorithms this was the
focus and it wasn't me who actually
realized that you can use prism at
modern molecular networks it was Murphy
colon and her group real nice bit and
they actually developed a model of a
molecular
knurling network no molecular signaling
networks is something with biologists
tends to work on because they want to
understand how you know sort of
different aspects of our body work so
you know we then worked with biologists
in order to develop a scientific
understanding of another molecular
signaling network which is called fgf
and with that we managed to produce
predictions which were then
experimentally validated in the lab so
the objective of that first work was to
really help biologists to understand you
know to to have some rigorous analysis
of the molecular network so that they
can come up with some crucial insight
they don't really know how these
networks work because they cannot
observe them okay it cannot observe and
they have guesses they only have
hypotheses and what we can do is we can
put in hypothesis in a prismo de develop
a prediction and then we get an answer
okay but since 2012 thanks to look like
a dirty who put me onto it we have been
working with DNA computation and the
difference is the DNA is used as an
information processing material so what
we are doing is we are working with
experimentalists but these experimental
East's are simply using DNA in order to
devise such devices and you know fabric
computing computing machines and and
robots okay now scalability
unfortunately still remains a huge
challenge okay so just to give you an
example of what we have done is this
a DNA transducer which that was
formulated by look up a deli and it is a
DNA program which works with these
double strands with this overhang which
is called a toehold and also single
strands and for example this toehold can
attach to that toehold in this place
this single strand this is what DSD DNA
strand displacement is now if you have a
transducer transducer just simply takes
in a strand of some type and produces a
strand of another time through this kind
of hybridization reaction you can put
them together into cascades but of
course all these cascades are then mixed
together in the same soup okay and what
can happen is then you have to be very
careful about the design so that you do
not cause crosstalk which is unwanted
interactions from one transducer to
another transducer which is further down
in the Cascade and in fact the water
transducer floor which buca discovered
himself but we can now discover it
automatically in prison and what it is
is it's a computation which leaves every
active gate that is something with this
toehold exposed which can undesirably
react with another molecule from you
know some other part of the gate another
gate and this can be established by
analyzing this DNA computer program
which we then model in crisp and visual
TST and put the prism and as checking
for them okay so there are two types of
deadlock one type of deadlock is correct
computation okay I finished with the
computation has finished correctly but
the other one is incorrect
and you can also show the probability of
each deadlock and the two probability
plots are slightly different so this is
computing in solution where we could
rely on mass action kinetics but for DNA
Walker circuits we can not do that
because the reactions are localized so
the DNA strands actually react with
whichever strand they find in along the
track okay along the track so what we
had to do in this case is I'm just
showing you if you are interested we
also studied expressiveness of DNA
walkers and it turns out that they can
compute exactly the boolean functions
and this is the one specific technology
but there was one problem and that is
these circuits have to be playing okay
and the intuition I think it should be
clear to you that the tracks of the waka
cannot cross because this will not
compute the correct boolean function and
in fact what we did is we came up with a
way to transform this is export which
has a non planar graph okay we to
transform these crossing lines using
gadgets okay and gadgets have a join
okay a giant note and then a trivial for
note so it's just joins to reroute you
simply be root the walk but by reduction
23 CNF nek CNF formula you know can be
represented by three CNF so by reduction
23 CNF we can show that this technology
can compute all boolean functions but
this technology is also very
reliable okay very unreliable so for
example experiments show that only
eighty-seven percent of walkers follow
the correct path so they can jump to
another track they can jump over one or
two and courageous they can even jump to
another time which you can prevent by
for example attaching the times to a
surface but what can happen is that if
they jump over true they can actually
did so notice that because they jump
they can jump over to but not three even
then jumps backwards to that one which
is reachable okay it's within the rules
because it just jumped over so it's okay
it was attached then this deadlocked
okay and we can actually check for bed
look okay but what we had to do first is
we had to develop a model so we have to
devise a ctmc model but that model could
not rely on you know so published
information about you know kinetic
constants we actually had to fit the
model the rates of the model to
experimental data and and this is an
example so in the experiments of the war
pair that i showed you the video today i
showed you they device single Junction
and double Junction circuits so we
developed and model based on simplified
stepping process that I showed you we
fitted it to the single Junction circuit
then we made predictions from the devil
for the double Junction circuit and we
compared it to experimental data for the
double Junction and we have
reasonably good alignment it reasonably
good so status is just another name for
Anchorage's so what we were able to do
is we were able to confirm that the
reactions happen how okay by showing the
probability of reaching the end by going
on the outer paths okay is better this
is a more reliable then when it takes
the inner part because it the
probability of reaching one of these
states among the inner path is lower
okay and we could also formulate design
rules to improve efficiency but we could
also do more okay and what we can also
do is to take the model of the DNA
Walker but now consider some rates in it
as parameters parameters it is an
unknown value but you only specify the
interval of that value okay so you take
a parametric model and then you give it
a reliability property which is
expressed in this probabilistic temporal
logic or a performance property and you
ask yourself a question what are the
values of that parameter that actually
guarantee that the property holds and
this can be done by computing
partitioning the parameter space into
the green regions okay in the green
region that means that this parameter
all the values in this region satisfy
the the property the red region means
they definitely fail the property and
uncertain the yellow one which at the
moment this is quite a large region but
you can improve
precision of this answer by doing
parameter by doing it refining and we
also involve sampling and if you are
interested there is a recent paper about
this that you know maybe you can you can
look up okay so what we did with this is
we could actually look at to reliability
properties okay and ask for the
conjunction and what this is is you want
the probability of correct finish to be
above some level okay but the
probability of incorrect finish to be
small okay and you have the conjunction
specify the conjunction of these two and
what you can compute is these are the
values that guarantee the satisfaction
of the property within it you can also
optimize ok so this is what we have done
and just to sort of summarize its we've
hit some successes so i can show i can
tell you that we don't have to find
dancing DNA programs we can also
guarantee the reliability level in
performance of a walker computation we
have also improved the computation
computational performance of
probabilistic verification by employing
you know certain techniques but the
scalability is limited so we have in
soup we have billions of molecules but
DNA transducer we can only model six or
seven molecules that's the limit okay
for DNA Walker circuits we have to
resort to statistical model checking
because it is physically impossible to
construct the matrix the specs bit and
for DNA origami folding we could only
use simulation so it's only been
explored using simulation
this is not as ctmc this is an
inhomogeneous ctmc so this brings me to
conclusions and I wanted to say you know
that from my personal perspective this
is a very exciting area and you know
very exciting field and I hope that you
can sense my excitement about that there
are many many open problems and there
are many many open issues to do with
verification for example
compositionality can we synthesize
Walker circuit layouts and can we offer
the parameter and all the model
synthesis for more complex models okay I
mean for example origami DNA I Riga and
I wanted to finish off by saying thank
you to my collaborators my group and my
fondest and ask you even know about phd
comics do you know does anyone yeah okay
so did you know that whole gay he came
to oxfords he came in 2008 this was the
day after Obama was elected for the
first time and do you know that I'm
there okay so this is an eternity
college it's Trinity College Oxford it's
not as grand as Trinity College
Cambridge so did you get the joke does
the food pop up magically from the table
no not at trinity at christ church
because harry potter was stupid
christchurch and okay the yeah you can
find the cartoons and the second
desserts okay so dinners at high table
you're finished with
can't desserts okay so thank you for
your attention so we have time for
questions so when I look it from a
computing perspective we think do with
computing should have the kind of
storage and and the processing so I got
a very clear idea from your problem you
address thinks about combination sexual
slavery but there is still secret
exactly so the thing is liquid
confidence I understood even with
combinational circuits we need to first
find and gates and or gates and then you
create NAND gates or not gates and with
that you can build process so what I
understood that you have X horse but I'm
not really sure whether you have buffers
so that we can realize no that's the
next topic yeah hopefully that's the
next topic in my group I mean from the
verification point of view yeah now
you're absolutely right I've only showed
you you know we can only do
combinational circuits we do need memory
expect you know I'm just you must know
in the future perspective how do we plan
to interface this with three of our
systems to some extent how we interface
this with you know really yourself data
process you need to have an interface to
loose you can
yes well so this is again something in
some small way people have already used
it on Angie Ellington for example for TB
has used it on paper fluidics so he has
developed DNA programs / chicken with a
print on paper free Dixon's develop that
technology but I think longer term
people are thinking of using it to cure
cancer and therefore injecting it into a
bloodstream but i think they are a long
way oh and especially you've seen the
reliability oh yeah question is more
from us natural either respect as well
how do you see that there is a future
from our endeavors of this direction of
Technology how close are we from from
different wheels applications I suppose
this is I need to quote my collaborator
and I think anja maybe he can also add
well at the moment there are a lot of
proof of concepts so all these are proof
of concepts and I think you know to
quote Andrew turbo field it's another
15-20 years to actually get it to real
applications well the proof of concepts
are different types of molecular walkers
yeah different I've showed you one type
but there are also different types of
molecular walkers I think what we also
need is to develop better technology for
actually observing the behavior because
a lot of what for the molecular walkers
model we just had to do a lot of
guessing but Bailey group at Oxford they
now have a paper where they can actually
observe single single molecule walkers
in real time so yeah we also need this
technology when useful now what you see
as a pencil resemble where is good
health care so medicine really yeah
doctoring the cell so medicines that you
can actually you know delivery in the
bloodstream and entertain spongebob
smart medicines smart therapeutics yes
there's no computational a sheet
processing dimension to it visit evolve
a little bored as as a computer
architecture okay so I suppose no I
think the prince there is separately
from that there is I'm focusing because
I'm working verification so I'm focusing
more on applications you know where you
do need you know verification because
it's expensive you know it's expensive
that you have to use it you know for
biosensors for example so that's the
kind of applications that I'm focusing
oh yeah it's I think we yeah you know I
think we still have some way to go to
actually build computers
boolean circuits that's to build
computers and you know to build robots
mr. head a long way to go experimentally
through maybe I missed how would you get
your mollusk so there are generated to
extract Oh Fred man you think yes so one
way to get a model is to take visual DSD
which is Andrew Phillips's tool and if
is it's happen where you know you'd says
export and you can export it as a prism
modeling language I didn't show you the
prismo dling language but you can also
build models of you know CRN's chemical
reaction networks directly increased so
that's another way and we've done both
yeah what you can also do and that's
another paper so DNA computation is
exactly the same expressive power as
Petra nets so there is also a tall and
you know there is a paper there is a
tool called cosmos which is based around
patroness we have modeled the same
molecular walkers using stochastic Petri
nets
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>