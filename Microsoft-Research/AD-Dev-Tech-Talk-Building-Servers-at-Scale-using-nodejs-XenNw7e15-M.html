<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AD Dev Tech Talk - Building Servers at Scale using node.js | Coder Coacher - Coaching Coders</title><meta content="AD Dev Tech Talk - Building Servers at Scale using node.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AD Dev Tech Talk - Building Servers at Scale using node.js</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XenNw7e15-M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">materials supplied by microsoft
corporation may be used for internal
review analysis or research only any
editing reproduction publication
reblogged public showing internet or
public display is forbidden and may
violate copyright law
hey guys I'm happy to introduce William
Adams who's from our own team or today's
tactic and William is like a connoisseur
of non-microsoft languages he's been
known to develop in Lua and which node
and all other kinds of kind of fancy
things that I don't even know about so
today voluminous team is all have also
built this proxy gateway which is based
in node and Williams going to talk a
little bit about his learnings and node
and how to kind of quickly get web
services up using that please give him a
hand thank you girish how many of you
know anything about node okay how many
of you are doing mass scale web servers
of any kind all rights quasi good
audience so I'm going to speak slowly
because there's not much material no um
first of all if you've ever heard
anything about node there's some magic
around it a lot of people don't
understand what it is I'm going to go
through what is not exactly and then I'm
going to talk about why is it good some
pitfalls of it and I'm going to show
specifically how we use it I'm going to
show some code I'm going to show some
charge stuff like that along the way ask
questions you don't have to save it for
the end so if you see anything that
peaks your interest raise your hand if
I'm not trying to ignore you i'll try to
answer your question all right so using
node web server web services magic okay
so what is node first of all there's
some guys that a few years ago went off
and created this thing called nodejs
they've got a website nodejs org you can
go there and read the history and all
that sort of stuff
but what is it node is an executable
node eggsy there's actually a file you
know it's a program that's all it is
it's just a program it so happens to
embed stuff and I'll go through that
list in the next slide also it's in an
application environment so just like I
is you can put plugins and add-ons and
all that other sort of stuff notice the
same kind of thing it's an executable
and there's a mechanism whereby you can
grab modules that all sorts of people in
the world are developing and kind of
shove them into your environment that
gives you access to those modules when
you're developing your applications okay
this is the same thing you see with
Apache I is node any of these web
application environments do the same
sort of thing in the node environment is
called npm node package manager so
there's websites out there that contain
packages that you can easily just say
npm install a sure and you get a bowl
bunch of stuff that's ready to add your
installed into your environment and you
can then use it that's actually a big
deal because it makes it really
brain-dead simple to add functionality
to your environment without having to go
and compile a whole bunch of weird stuff
okay what is it good for its good for
networking apps it's good because it
works across multiple platforms and by
that I mean not just different flavors
of Windows but truly different platforms
everything from a Raspberry Pi to a home
router to a linux server to of course as
your servers okay and it's good for the
environment why because as I'll show
later it uses typically less resources
to handle multiple transactions with
node than some other approaches so and
I'll get it I'll dive into what that
really means in the next slide yeah
you're actually supposed to use this mic
here I'll give the mic to the audience
so you guys can ask the question asked
was surely a module that's widely used
on Linux would likely be assuming that
it's running on Linux and make calls
into an operating system that isn't
windows and likewise something that
works extremely well and windows
probably makes assumptions that it's on
Windows depends on the exact module if
the module is relying on things that are
within the node environment that's you
know the core environment and know that
core environments everywhere so it's
safe right now all the things like file
access even starting threads simple
things like that that's in node so
that's gonna work everywhere if you want
to rely on something like when C and G
the crypto the new crypto libraries
that's only on Windows you're stuck
right it's only going to be able module
that's going to win on Windows now node
so happens to have crypto built in so
maybe that's not a good an example if
you're going to do a UI library that
uses user32 because you're doing that
for some reason and yet you're stuck
with Windows most of the packages that
are popular work across multiple
environments probably with a leaning
towards Linnet right but there's a lot
of modules that just work everywhere
because they only rely on the core node
stuff plus javascript and that's about
it right
yeah so anyone who's who wants to be
popular will make sure that their module
works in a lot of different places but
you're absolutely right if you do
something I actually have an example of
that that we did if you have something
that's very platform-specific you're
you're stuck to that platform right all
right so what's in the box what's in
that no dot exe well there's a whole
bunch of stuff there's openssl which is
the library that pretty much everyone in
the world uses when they're doing crypto
at least when you're doing it in the
linux environment even in windows
there's v8 which is the javascript vm
that was originally developed by google
and now it's kind of open source there's
the lib for compression there's HTTP
parse which does all the the lowest
level HTTP parsing if you're doing that
in node and then there's this core thing
called lib UV which is where the
eventing threading scheduling low-level
socket low-level file access stuff all
lives in lib UV that's kind of really
lib UV is the core of what I would say
is note the fact that it uses the the v8
JavaScript vm that's glue on top really
the core of it without lip UV you would
not have note because that's where all
the asynchronous processing occurs and
that's really the essence of what he is
node ok so there's lib UV you actually
don't need note at all to use lib UV
it's just a library that Microsoft has
actually contributed to as well you can
just go and use raw lib UV and there are
now a lot of projects that do that
because it gives them the core async
communications mechanism that they want
ok so these are the things that go into
the exit and you notice that I listed
the
the v8's actually see in c++ these are
all written in C and C++ the reason that
is then the reason they they end up here
is because they're written in C they are
so portable and in many cases they've
been around for so many years that it's
really easy to find them in every
platform like if you've ever played with
z lib that's a compression library
that's existed for I don't know maybe 10
or 15 years maybe 20 a long time it's
probably ported to everything from your
watch to your cell phone to your
supercomputer so it's everywhere HTTP
parse it's like one file straight see
not a lot of fancy stuff works
everywhere v8 engine is kind of a pig
it's really hard to compile in a lot of
places but since people are so motivated
to do it it ends up working everywhere
or at least most of the place that
you're interested in doing this kind of
application openssl has been around for
thousands of years everyone uses it so
it compiles everywhere that's pretty
much the core of what is note what also
comes with is the NPM install package
which we briefly talked about that means
that if you go to the nodejs org website
and install node you can get the NPM
package installer and just start saying
and cam install this that is that just
to play with stuff right so a lot comes
in the box you can get up and running
really easily blah blah blah what does
it look like so this is an example of a
very typical hello world server written
in node this is JavaScript code okay if
you don't know what JavaScript looks
like it looks like C or C sharp probably
looks closer to c-sharp actually because
it uses var and curly braces other than
that these are all standard C kind of
looking languages right curly braces
variables blah blah blah okay
and the only thing that's going on here
is at the top you say it says bar HCP
require ball wha it's going to use the
HTTP module okay second line is create
the server HTTP dot create sir that's
just calling a function anonymous
functions that's a javascript thing lots
of languages have that you could pull
that function out and make it a separate
function if you don't like doing the
anonymous function sort of thing doesn't
really matter okay what happens here is
when you say create server you handed a
function who has a signature that says
request and response your function is
going to be called you're going to be
handed a request object which has the
headers this is hdb so the headers which
contains also the resource the verb that
they're looking for whatever and you're
also handed a response object where
you're going to write back your response
right great in this particular case i'm
doing right head 200 okay here's a
header content type text plain the body
hello world and i'm going to listen on
port 11 13 1337 and then i log to the
console this is how i run it know that
XD server ojs now my server is up and
running listening on port 1337 if anyone
connects to it I'm just going to an back
hello world that's the content okay so
two three four five six lines of code
you've got an HTTP server that's very
simple right you don't have to deal with
that your function is called
appropriately when you say create server
that's creating the event loop the
magics happening there right I you don't
deal with the garbage collection you
don't deal with opening closing sockets
accepting nothing you just say he's
going to hand me a request I'm going to
spew into the response done beyond that
you don't know how it happens in fact
this same server can handle 10,000
concurrent connections with
you changing a lick of code right or one
connection you don't know you don't care
it just will right that's the whole
magic here if there's any magic right
yeah um it depends you can you can get a
you can use the clips if you wanted to
and there's plug-ins for that to support
node specifically so any environment
which would support javascript visual
studio we have a lot more support now
than we did before because it's not just
JavaScript for the browser people are
using for other stuff you can just use a
plain old text editor if you're bent
that way I am so I just use text and
most of my debugging is print you know
printf otherwise you can get a very node
specific IDE that's specifically for
node a couple of those are laying around
but eclipse visual studio and a good
editor like sublime text or something
like that that's what most people do
right more questions so far already so
there you go that's your basic server in
node and very specifically an HTTP
server okay all right so what did we
what's going on here what are the key
benefits or aspects of node one of the
primary things to realize is that it's a
single threaded which is kind of a funny
thing to think about when you consider
what do you mean 10,000 concurrent
transactions with a single thread how
does that work right and this is kind of
cord to the architecture it's io a vent
this is a key aspect which is a switch
from if you've used a patchy in the past
for example or even is for the longest
time we used to think being having a
bigger machine was the way to get higher
throughput in connections right it's
like well new connections spin up more
threads this is the way the Linux world
used to work is the way we
and I used to work later on we came and
said oh I Oh completion ports and things
change but basically it's a shift from
per thread per one thread per connection
to saying well wait a minute most of the
time those threads are just waiting and
the context switching you're doing in
the kernel to go between those threads
is killing you they're blocking threads
you have to contact switch and that
kills your perv so note comes along now
note isn't the only thing that does this
but no comes along and says I'm going to
be event driven since i'm waiting most
of time anyway there's no point in me
having multiple threads i have one
thread and all the things that would
block i'll put on a queue and then as
they get unblocked i will service them
right so the whole core of what live UV
is doing for you is running an event
loop a scheduler that's basically saying
oh you were about to read from this
socket you would block so I'm going to
put you on this list over here and then
if you're in the linux world it'll do a
select it doesn t pull it's not select
and it'll say tell me when that thing
has something tell me when it's ready to
be read from ok meanwhile i'm going to
take the next task and i'm going to go
execute that until it blocks right and
when it blocks it will put it on the
list and say tell me one then something
happens to that so it's just kind of
this round robin loop that's going is a
blocking ok put it on the list oh it's
not blocking service it you know that's
what's happening in the event loop right
that way I if you're not as long as
you're not cpu-bound you're just going
to turn through that thing really fast
yeah microphone
can you hear me now oh okay great so
isn't that just moving the task
switching from windows or like windows
task scheduler to that node that
schedule is the same thing so then where
is performance gain then ah so let's
think about how the windows kernel works
ok preemptive multi blah blah blah right
preemptive multitasking is a killer
because it just interrupts you whenever
it feels like it you don't have any
control over that right so you're going
to if you did it per thread and you're
blocked you know you're waiting for i 0
whether you're doing anything or not
it's not until the next time cuanto or
maybe the scheduler is really smart net
says all your blocks so I'll switch to
the next guy well context switching of
threads is kind of expensive because you
have to take the stack you know of that
thread and go oh now that one now
execute oh it's blocked ok save the
stack ok next one you know stats for
threads are pretty darn heavy right I
mean it's not a small thing so context
switching of a thread in the OS is an
expensive operation in node a threat or
a task is nothing more than a little
tiny bit of memory it's just an object
it's just a pointer so I'm just going to
go it done that one that's my context
which is switching a pointer done
there's no stack because I'm only a
single thread I never swap out my stack
right the thread stack so that's why
context switching a node is that because
you're not really context switching in a
pre-emptive multithreading sort of way
right so now you get the question of
well is your scheduler and node smarter
than my scheduler in the OS well yes for
this task it is because the only thing
that will switch you is you're done with
the task or you're blocked on Io and I
know exactly when you're blocked on Io
nothing else is going to get you active
again other than the fact that you have
i oh operations ready right so it's very
targeted is a very targeted scheduler
yes aha we'll get to that so I'm going
to ignore you for now and we'll come
back to that if i don't answer it then
we'll come back and you can ask it again
alright and i actually talked about it
even on this slide so I Oh event-driven
that's a key thing just remember that
this node thing is designed for things
that are IO bound right its network web
application servers you're probably not
going to use node as the quarry venting
loop of a game it's not good at that
because it's waiting for i 0 games are
driven by a clock you could use a bike
for that but your frame where it's going
to get kind of weird because you're
going to also share with you know the
i/o that's supposed to be going on
that's not actually going on and games
don't have 10,000 concurrent connections
unless it's the game server and it's a
you know multi-user environment all
right async io by default all of the
socket and file stuff if you use the
node core libraries are all async by
default so you can screw that up but by
default everything is a sink so you
don't really have to worry about it when
you say socket receive then that's going
to be a sink you don't just like the
magic we saw in the first thing you
don't worry about it it just kind of
happens all right that's a huge benefit
because doing async io correctly is not
always the easiest thing to do doing it
correctly optimally across multiple
platforms that's what that's a big task
right so lib UV kind of takes care of
that and that's a that's a fantastic
thing what is it actually built for
short-lived transactions ones that are
not CPU bound hi concurrent connections
there's this problem known as the 10k a
problem which is can I have my server
host 10,000 concurrent connections at
the same time that doesn't mean 10,000
responses at the same instance you
and do that but 10,000 concurrent
connections right can I do that at all
right some environments you cannot if
you're spinning up ten thousand threads
for example it's going to be quite
challenging your server will be brought
to its knees and and not really do much
work actually so it's good for high
concurrent connections but short-lived
transactions okay leverage is JavaScript
for high level modules most of the stuff
that you do NPM install is straight
JavaScript code we have code that's
actually c++ and java script but most of
the stuff you see is just straight
javascript code that works great because
javascript code is pretty easy to write
a lot of different kinds of people can
write it there's not a lot of
compliation that goes on so that's a
good thing you can gain access to see
standard C libraries through an
interrupting I'm going to show some of
that and it supports numerous platforms
okay benefits of JavaScript I already
said it's easy to write one of the
benefits that some people gain is that
you can run some of the code in the
browser and some of the code on the
server and it's the same code because
it's JavaScript the v8 engine is pretty
much the same thing that they used in at
least the Chrome browser so javascript
is JavaScript on both ends if you can
run it there you can probably run it
here depending on what modules you're
using right this makes for very
interesting applications and makes
people who are doing stuff that spreads
across the two i'm pretty happy because
it's only one language to learn
javascript right so any questions pause
for effect all right go ahead yeah no
problem Bravo so yeah you can use type
strip CoffeeScript whatever you want
right because these are all just
preprocessors so as long as they see you
javascript in the back end
it's going to work right and that's a
great thing there's another thing called
a sm j s which is nothing more than a
very restricted set of javascript people
are now writing compilers that spew
asm.js is at the back end llvm is a
front end to that will for example
wheels Q&amp;amp;AS MJS at the back end what
does that mean any language that front
ends using llvm which is the stuff that
apple support so i can write a see
compiler an objective c compiler a pearl
compiler whatever i want and it'll spew
that j/s files which i can essentially
use in node well that's fantastic isn't
it because I can essentially choose
whatever language I want as a front end
because it's done this few JavaScript
which is going to work a note how cool
is that all right so even if you're not
writing JavaScript directly since the
world supports javascript and all sorts
of different ways you still get a
leveraged node even if you're not
specifically sitting there as a script
kiddie writing JavaScript code yourself
right I think that's a pretty good thing
okay multi-platform I mentioned briefly
multi-platform for us and I'll get to
our application in a couple of slides we
needed to be able to have a run time
that would work as seamlessly in the
cloud as on a desktop and your home
router okay there are very few pieces of
technology other than just writing
straight C code that allow you to spread
across all of those things so the code
that I run on the desktop machine for
example we call it the connector in our
case that piece of code I can run it on
my desktop windows-based desktop my
Raspberry Pi my asus router it'll work
on all of those environments without any
code changes whatsoever because it's all
just straight JavaScript node sort of
stuff
that's a pretty important aspect for us
because it means that as a dev team I
can get platform reach without having to
hire more devs that are very platform
specific I don't have to hire an asus
router dev I just have to the same guy
who wrote the code that runs on the pc
is the same guy is going to run it on
that asus router it's as simple as that
right and for us that's a benefit ok
consoles game consoles all that sort of
stuff it's all fair game note is kind of
piggy though because it's a few
megabytes so you're probably not going
to find it running in a light switch
anytime soon because it is a few
megabytes but you know these things
change ok some limitations node is all
singing and dancing yeah well a
single-threaded has its benefits but
single-threaded also is a killer because
as soon as you do compute bounds stuff
you're dead ok since it is single
threaded and you're not preemptively
booted from a long-running transaction
you will block your whole service if you
do anything that's blocking including
cpu-bound stuff right if you use any i/o
libraries that are not asynchronous and
you have a blocking call calling sequel
server in a synchronous way you're dead
right your performance is just going to
go down the tube so it's a limitation
you have to be aware of they have a
concept of being able to deal with child
processes so you can in fact create
multiple threads and there's lots of
different ways of running multiple node
instances within an environment behind
is or or anything else but that's more
and more and more by default the default
environment where most people work where
they're not doing child processes and
all that if you become cpu-bound you
will kill your server right it won't
fall over and die but you're going to
kill your performance ok does that
answer the question or did you want to
spin on it more
doing crypto if you do a lot of crypto
like let's say we wanted to use node
straight up as the front end for acs for
example something we should know about
acs does a lot of crypto work so you're
not going to get very high throughput
through a system like that it would be
better if you use node to front end the
requests hand off the CPU bound stuff to
another process and then feed the
results back right yeah and I'll get
into that in the very end of the slides
but basically you're going to run
multiple instances of node and you're
going to front end it by something else
that's going to handle the load
balancing across those multiple
instances so you could if you have a
quad core machine run for node for node
xes front end that with is if you want
let is load balance across those four
and you'll get maximum cpu utilization
right so all right no buffering if you
have to actually respond now this is
changing somewhat but you need to reach
you're responsible for reading for
grabbing stuff out of your network
buffers as quickly as possible there's
not a long queue this is not 0 mq right
this is not AI is there's not a heck of
a lot of support here for buffering up
the requests that are piling up behind
your accept calls so you have to be
quickly pulling stuff off and putting it
in buffers yourself if that's what
you're going to do you also have to be
very careful about garbage collection
which is notice a garbage collected
environment javascript is a garbage
collected language so like c-sharp it's
really easy to create strings and all
sorts of stuff but you're creating GC
pressure when you do it so you have to
be extremely cautious now this is the
same thing I would say to anyone using C
sharp so there's no difference but you
have to be extremely where because it's
so easy to create objects using these
environments that this will kill your
performance because the GC is going to
kick in
it's going to take however many
milliseconds it takes and there goes
three or four transactions per second
right so there's things to be aware of
it's a sink aware but not enforced means
that you all the core calls are in fact
a sink like I said the socket called the
file system calls the built-in calls are
all async but there's nothing that
prevents you from standing up a library
that makes a synchronous call on your
own right so if you do that you're going
to kill performance so it does not
enforce it has no way of enforcing this
async model it makes it really easy to
use it but there's nothing the
environment does to prevent you from
doing synchronous stuff just like it
can't prevent you from doing cpu-bound
stuff right all right questions okeydoke
so use case I talk about our application
it's called the application gateway and
the scenario is basically you've got
your iPad or your phone or your whatever
device you have and you're sitting in
the cafe somewhere and you want to get
at MSW or toolbox or ms library or even
stuff that's at your home okay and when
I mean sitting anywhere I mean anywhere
in the world right and your resources
are located anywhere in the world
possibly here in redmond but possibly
somewhere else so we want to support
hundreds of thousands or millions of
users doing this in a very scalable way
we don't want to have we don't want to
support thousands of servers to do this
right we want to have very low resource
requirements and that's about it ok so
in order to do this and just to see what
our app looks like schematically it's
roughly this we have this thing called a
router and this is where we use node in
two places here and here so there's this
thing called a router and this lives in
Azure and it's exactly what you would
think it is it's a router you connect to
it it tells you where to go to get your
stuff
we authenticate with azure ad in the
first place that we know who you are and
what you have access to we have this
thing called a connector that sits on
your box somewhere in your network and
that's how we essentially do a reverse
proxy to get to your stuff okay the
hotspots in this diagram is certainly
here at the router every single packet
of data that flows through the system
goes through that router okay per user
data goes through a connector so there's
many thousands of these deployed there's
one of those now that one looks like
this each there are in fact right now
three router instances one in Europe one
in us and one in Asia those three
routers talk to each other they share
information about what's connected to
them at different places in the world
which users are located where which
browsers are connected where so they're
constantly sending data to each other
forwarding packets they're acting
exactly like you would expect the
hardware router to act okay but it's all
in software all right this is all kind
of front ended by Akamai Akamai's what
we use it for traffic management so
Akamai you come in to your URL and says
oh I know of these three instances he
doesn't look busy i'm going to hand him
the package so Akamai allows us to land
people on a router that's closest to
them geographically so if you're sitting
in Singapore and you try to get your
stuff in redmond there's going to be a
connection that goes like this right at
least for the initial connection and if
you're sitting in redmond and you're
getting stuff in redmond you're going to
hit this and that's it all right so this
this architecture both is the router
it's a mesh to proxy is lots of
different things okay
in order to construct this there's a
couple of things we have to do or three
things we have to do the core foundation
of the router piece itself stands up
port 80 and looks like an HTTP endpoint
you go and talk to it you do rest calls
and various HTTP stuff URLs ok so it's
an HTTP endpoint https most web servers
do that nope no big deal all right but
there's a secondary component which is
that mesh the fact that I had three of
them connected and I can have any number
of them connected around the world
hopefully will scale up to tens not
thousands that's a UDP connection I have
to know I know of all my nodes in my
mesh and I can talk to them I I do talk
to them on a regular basis send
heartbeats and that's done through UDP i
also have a tcp connection to all of my
peers and then mesh because when I need
to send the routing table because a new
guy shows up I actually use TCP and that
is not https space it's just a TCP
socket I send a well-known packet they
get it they do what they're supposed to
do and life goes on ok so here I have
three things that I'm doing with it with
my web based application not just the
regular HTTPS flow right on top of that
part of what I do is I get tokens from
agile Active Directory compact tokens I
actually crack them and I look for
information inside i'm looking for the
username you can argue that you
shouldn't do that you should use a a CS
or ego SGS yes yes yes but we do in fact
do this we've been doing it for the last
year so I have to write some low level c
interop code as well these are different
modules that I use that are out there in
the world and how what we use them for
within the context of this service
nothing super exciting here you know
this is probably the most interesting
one
this deals with going off and getting
resources so I can easily make HTTP
requests out from my router okay so this
is this is what goes into our particular
usage of node if I wanted to construct
this using IAS for example I could
probably do it most typically what you
want to do for the front end part of it
is you'd say well use just time to HTTP
is you'll get a queue of stuff for all
the HTTP requests great now HTTP dot sis
isn't going to help me much with the UDP
flow for the mesh or the TCP flow for
the mesh so I'm writing that on my own
right I'm rolling my own code and has
nothing to do with my HTTP dot sis code
at all and somehow I've got to make
these two work together right when you
use node node gives you multiple levels
of access I can access the sockets I can
access the higher level protocols and
the async flows are all the same I don't
have to do any magic for any of that so
being able to deal with these three
different kinds of protocols all using
the same framework is really beneficial
to me right because I don't have to
learn a whole bunch of different
technologies to do this to throw on top
of those three protocols we're now
supporting WebSockets soon enough we
might support speedy which is just
another another socket thing and any
number of protocols that may come along
down the line node makes it pretty easy
because someone has prototyped that
protocol probably a node already so you
just go pick it up and use it right and
it'll fit into the same exact framework
you don't have the protocol you don't
have to create the protocol on yours on
your own and then try to shoehorn it
into some other environment like HCPCS
which would be kind of challenging so
that's that's pretty much what we use
within the router itself
I'm going to show you a bit of code is
to just for shits and grins if it comes
back at done broke it no okay are you
guys still awake uh so I'll try to put
you to sleep then alright so let's take
a look at a simple bit of code so i
talked about the mesh nature of our
service meaning i have multiple
instances of our router located around
the world now kind of talk to each other
okay the way that works is and I know
this isn't going to make too much sense
because it's just like oh I chart of
code on the screen what am I looking at
this is a mesh instance here's my name
here's a function that gets called
whenever I receive a message okay this
is all JavaScript code right if I start
the mesh right
I create a UDP socket whenever there's a
message you know hand it to me because I
have a non message thing here i create
the TCP socket if you will right I'm
both a server and a client for TCP
because I can send and receive I'm
appear right and i have this function
that i'm going to call on a timer one of
the aspects of our service is we send
heartbeats to see if our peers are alive
if they miss a couple of heartbeats
which is like 50 some odd seconds we'll
kick them out and say they must not be
around the nashville week reconfigure
itself and say he's no longer with us
route around him ok this function does
that it's on a timer if it receives the
message before the timer times out and
says all ok ok i was going to kill you
off but you seem to be here so i'm not
going to kill you all right i can cancel
the timer but here you see the UDP
socket i create it there's a
configuration that tells me which port i
want to use there's other things I could
configure but that's all I do here
there's a function that gets called for
the hell oh there's the timer ok now in
node I said I Oh event driven a timer is
considered an i/o event forget the aisle
part the timer is an event a socket
being ready to ret be read from is an
event a file being ready to be read from
as an event so in UNIX where everything
is a file handle including the random
number generator event serve everything
IOE vencer everything in Windows it's
slightly different but the lib UV
library makes everything with the same
anyway right this is a great thing so
I've got timers here I don't there's no
even though at the the very lowest level
of node you have to say okay well how do
i create a timer and windows at this
level I don't care right that's already
been dealt with somewhere down in lib UV
so all I have to do is say
create timer right and I handed a
function and it just kind of deals with
it even though windows timers are
completely different than unix timers
are and their handles completely
differently but there you go that's it
that's all there is to setting up my
mesh great my UDP socket my tcp server
and my timer function the rest of this
the rest of the code in this particular
file has to do with well what happens
when you win the on timer message fires
what happens when i get a UDP message
and these are the two different message
types hello and data that sort of stuff
ok at that point I'm just writing
JavaScript code and I'm doing my thing
alright any questions yeah microphone so
on you're actually opening the UDP and
TCP connections what it's the reason why
you chose a UDP to be opened so look at
k blue using open for UDP is kind of not
real because you're not really UDP is
not a connected protocol right it's just
kind of sitting there are you doing is
setting up the socket that's going to
talk UDP so every once in a while i'm
going to talk UDP I don't want to have
to construct the socket object every
time I want to send a message so i
create the socket object and then
periodically i'm going to use that same
socket object to send messages right you
saw the one with the tcp as you all
right what's that you can use the TCP
sockets and use keep reusing the same
socket no you don't really want to do
that when you now TCP is different right
TCP is an actual connection you have to
end and that's an established connection
so you don't want to you're not gonna
use that same socket for UDP traffic
it's like no that's done right two ports
are locked and that's it so you have to
separately say oh I'm going to talk UDP
so I'm going to create a separate socket
for that right that makes sense I mean
you can't really use the same socket for
two different protocols because when you
set the socket up in the first place you
say which protocol are you using okay
any more question yeah that tends to be
an operation that's not universally
supported that great for asynchronous
i/o across operating systems uh it does
as good a job as you could do right with
that OS so with windows for example we
completely support asynchronous calls on
file operations depending on the UNIX
that you're using it may be good or bad
depending right so they do their best
and they use whatever standard
conventions are in Linux most most
frequently it generally works right now
files of course in linux and unix means
completely different things and does in
windows because everything is a file
handle but for actual data files you can
probably get a synchronous
communications and if anything if it
can't do a sink at all it's going to
block right or it'll do chunking where
it'll say well i'm going to read 10k at
a time and then i'm going to in the time
slice so i'm going to give up for a
little bit and then come back so I'll
simulate whatever would it ever like
have a background thread that did the
blocking read and then no not unless you
explicitly do it now an implementation
of course is free to do that like
someone could take the lib UV and say on
this particular on AIX version 6.3
here's how we're going to handle you
know non-black and file i/o and you see
this a lot of times actually when you go
to windows where you say well how am I
going to handle a sink sockets not going
to use select I don't have a pole I
should be using i/o completion ports so
there's a whole bunch of plumbing in
there that's very aisle completion port
specific for windows right so what you
would find is that per platform someone
is going to write code that makes it
work as best as it can for that platform
it has to shoehorn its way into a fixed
p I because lib UV has a fixed API that
everything above that is expecting so
they do their best to make it fit and
you get what you get right any more
questions all right so this is one piece
of code we have this other piece of code
which goes and cracks our PS tokens and
there's a couple of things we had to do
for that first of all we had to expose a
couple of low-level calls from openssl
that were not exposed because there are
a couple of crypto functions that we
needed that weren't there so we had to
expose those and then we have to go and
actually write the rps cracking code we
chose to write that code in JavaScript
because I had originally written that
code in Lua and it's a pretty
straightforward port from Lua to
JavaScript so we just kind of ported
that straight across so this part right
here I'm not going to bore you with the
actual details because it doesn't matter
but just know that this is C code or C++
code whichever whatever you want to
think about it okay so you've got
templates and you've got you know your
standard function parameters and all
that kind of looks like javascript but
it's not this is actually see code
here's doing an RSA cipher object and
blah blah blah blah blah okay this is
all the code related to doing some
crypto stuff that I needed to expose
right this little tiny piece of code
actually I have to compile when I
compile node from scratch I have to
compile this module as well because I'm
going to include it in my node XZ my
version of node eggsy so it's just a
piece of code that has to be there okay
separately I have this JavaScript code
which makes reference to that piece of
code that I built which includes the
shim to allow me to access it from
javascript side okay and then I go off
and the risks of this file is actually
the RSA or the RPS cracking token
cracking so knowing how to read data
blobs and decrypt a ticket and blah blah
blah blah blah blah blah ok so this code
is all JavaScript and it's there's
nothing spectacular about it you're not
going to get any major speed ups by
writing this code in C because it's
jaded code anyway so it's already fast
all right the interop is where things
are slow if anything so that's why you
write a nice fast interrupt layer but
besides that it's just code right
writing in whatever language you want ok
so that's your that's typically how you
embed some piece of functionality so if
you had some device that you're you're
trying to get access to like you had a
hardware key store or something like
that that has a standard C library you
would write some amount of glue code to
access that C library and then you'd
write or a shim and then you'd write
some amount of JavaScript code that
makes it look and feel like javascript
in the way that you want to use it right
and that's how you integrate stuff this
could have been done as a completely
separate module if you will or you can
just compile it into the application
proper and that's just a matter of how
you want to distribute your your code in
the first place ok any questions
file system do you have to learn to do
to make some native code in there um
there's a there's a couple things you
can play with JIP if you heard of that
one JIP is what well one of the ones
that you can use you can pretty much do
whatever you want but if you're going to
if you just went to their website the
node website right now and you
downloaded the thing the easiest thing
for you to do is to install Python and
then use the make system that they have
based on that right which is Jim besides
that if you didn't like all that you
could do it all in visual c or c make or
whatever you want really so anything
that can compile but out of the box
python with JIP so kanode can I build a
dll in visual studio and node can load
that and call it uh yeah you can't warm
to an interface yeah yeah because you're
just going to export some functions and
then there's a way of saying here's the
fun here's what that function looks like
here's how you set the parameters into
the v8 vm so at that point you're just
talking about how do i interact with v8
which is the javascript vm how do i get
a function call to show up you know and
thats I how do i do the marshaling
that's all it is right and that pretty
much has nothing to a node that's just
v8 right which is not my best love thing
but there you go alright I will finish
out my slide where router instance ok I
think I talked about all these things
already so what are the great benefits
quick prototyping modules support I get
a focus on the application logic and not
so much on the low level stuff that has
been done a billion times flexible
network fabric and typologies like I
showed you UDP tcp HTTPS WebSockets it's
all
pretty easy to get all of that stuff in
there without having to change your
application to accommodate every single
time right things to look out for I
talked about some of these garbage
collection system great I can be a
brain-dead programmer and everything
just works I never have to do with
memory again but you all know the
pitfalls are doing that with C sharp
same here it's just JavaScript instead
of C sharp so don't don't do stuff
that's going to be really painful for
the garbage collection system and
leverage when you leverage modules there
are literally thousands of modules out
there in the world they're not all good
and they don't all adhere to the node
way for example the low-level HTTP
parser was written in C does zero
allocations really blazing fast you know
it's perfect thing but then there's all
these things that are based on top of it
and you don't know what they're doing if
they're just start throwing the strings
left and right you kind of blew all the
benefits of getting the low level stuff
written with zero allocations so you
want to look at the library's usually
you only use stuff from people that are
you know very experienced at it and
their modules are proven to be really
good that sort of thing but this is a
different kind of way of thinking and
working for microsoft because typically
we've been very much like well i got a
bill to myself and in this world is like
well why would I why would I waste my
time building a module that already
exists right so for the node world it's
used something that's already been done
rather than building it yourself because
then you keep going on your application
and not wasting your time on that sort
of stuff right alternatives I'm almost
done the alternatives are numerous right
node plus other stuff you can front end
I think I said this in the very
beginning you can front end node with I
is if you wanted to because sense node
is you know compute bound you can have
multiple instances of node they could be
front ended by an IAS server that round
robins across
based on their load you can do the same
thing with engine X if you're using
Linux you're probably going to use
engine X which is the new you can call
it the new a patch it has nothing to do
with Apache but it's like the new kid on
the block that is taking the performance
crown okay so you could front end your
node processing with engine X both cases
here they deal with the lowest level hcp
stuff so they get this the sockets in
they parse the headers they hand to the
request node then processes from then on
in that case you're not using nodes HTTP
parser you're using engine X HTTP parser
or with is using the HTTP parser right
so that's the way to go if you have if
you don't want to be using note at all
but you're using scripting or other
things the Django is Apache whatever
right any questions yes for us to use
yeah please repeat for use how easy was
it to get the clearance from LTA or some
legal department in Microsoft to use no
GS and some other libraries because you
encouraged to use existing library which
is good thing but often quite a
challenging together Wow than clear than
pool okay I'll say some fluffy stuff and
then I'm going to point it Blaine who
actually did the work so the fluffy
stuff is we as a company or kind of
changing I alluded to this a little bit
we used to get value and our IP was
based on us creating all these things as
a services company that's not as
important what's important is getting
the service out there right so our IP
around creating this environment isn't
as important as getting the service up
and running so Blaine was the dev who
did all that that work what does it take
there
it's fairly easy we have folks in LCA
that are already familiar with this
community with many of the modules it's
just a matter of obtaining the forms
from them filling them out giving them
the links and the licenses and you know
a few days later it's done yeah now real
easy we kind of on some of this stuff we
were first so we got the battle scars
for it but the process is much better
now and you have a juror for example in
general has a node SDK and they're
totally into node stuff they distribute
node modules all the time and we use
node modules so I think this is getting
easier and easier you know I think
you'll find more resistance from your
engineering group then you will find
from LCA right because we're manly man
we don't like to do things like use
scripting languages and stuff like that
so that's a bigger hurdle of the face so
questions I think that's it the rest of
this stuff so here's a bunch of links i
believe the slides get handed out so you
can click on these things if you want
but there's there's no jst org is the
primary org that has all the nodes stuff
you can get the latest releases there
they're actually not the best place to
get all the really useful information
the all of those other links there are
things related to microsoft and node
which is kind of interesting we have our
own nodejs developer center if that
helps answer the question of how how
node centric are we these days and then
various other things so you can take a
look at those links all you want that's
it I hope you understand the magic of
node and go for it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>