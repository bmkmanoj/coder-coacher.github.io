<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Privacy-Free Garbled Circuits with Applications to Efficient Zero-Knowledge | Coder Coacher - Coaching Coders</title><meta content="Privacy-Free Garbled Circuits with Applications to Efficient Zero-Knowledge - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Privacy-Free Garbled Circuits with Applications to Efficient Zero-Knowledge</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-yha2MEIsfs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
vixen visiting us from iris University
and so Tyra's worked on both the theory
and practice of secure computation and
today he's going to tell us about
privacy freak output circuits I think a
particular application type of yeah
alright thanks for the introduction so
yeah my name is tor fredriksen and very
happy to be here I'm glad you invited me
giving me the opportunity to come and
speak a little bit so today I'm going to
be talking a little bit about privacy
free coupled circuits with applications
to efficiency or knowledge this work was
done when I was a PhD student at Aarhus
University and it's a joint work with
Darius Babu's Nelson and cloudy orlandi
all right so this actually is part of my
my job interview i'm going to start
selling you guys a little bit about
myself and about my education research
work and and so on after after that i
will continue with some motivation of
the topic of this talk which is piracy
free garbled circuits and we move on to
a bit of preliminaries some formal
definition of garbled or semi formal
definition of garble circuits and
security assumptions we work with in
this way then we'll go to the main part
and actually give our main results I
will continue just giving a small sketch
of how we prove this in in the paper and
I will end up with some concluding
remark remarks regarding benchmarks and
future work some of which has already
been done and some recap so this paper
was published last year at your crypt
and it's been on a print for a bit
longer than than that so you might have
seen it a little while ago but yeah all
right so let me just start giving a
little information about myself so first
a little bit about my educational
background I'm not a percent Danish my
family traces back to Denmark back to
the 16th century
at which point they came in from
northern Germany so not that far away
but despite that I managed to actually
do a high school I have a high school
diploma from Lester high school in
Massachusetts he in the United States
unfortunately that's not sufficient to
get into University in Denmark so I also
had to do an International Baccalaureate
which i did in calling Denmark then I
started studying computer science at all
whose University in Denmark were
finished my bachelor in 2010 then I
continued on with my masters which I
finished in 2012 with the yes / boost
Nilsson as my advisor after my Master's
he managed to talk me into doing a PhD
as well which I finished last summer in
2015 during my PhD I managed to spend
six months abroad studying at the
University of Bristol where I work with
the Nigel smart group and yeah so my PhD
is in cryptography with in computer
science in particular secure computation
if anyone should be in doubt after after
this talk my experience in computer
science goes back to two thousand eight
where got my first programming job for
jewelry company in the Philippines where
I basically make some flesh software
which allowed users to design their own
wedding ring so it was basically
something you know you select the
surface with layout of stones and then
generate sort of an image of what it's
supposed to look like and then they can
audit from from the company after that
up to a couple of years and just focused
on my studies and then 2010 I got a
full-time job as a student programmers
during the summer for a research project
called at a glance this is a research
project with in human-computer
interaction so nothing at all regarding
cryptography but it's a very interesting
project that was about making it
possible to do overviews for the
emergency staff a larger public events
such as festival sporting events and so
on so what's in software that integrated
for example smart phones gps
surveillance cameras and
so on made it a lot easier for the
response staff to respond to emergency
coordinate with the different groups of
emergency staff such as security medical
social workers and so on and I yeah and
I've been helping at that project for
four years fortunately after the first
year they ran out of funding but the
last two years I did it as a volunteer
whether then after that while I was
doing my Master's I started as a
teaching assistant in the University
where I started seeing in computer
machine architecture for undergrads then
I continued doing TN while I was doing
my PhD which involved both software
architecture and many times also tiering
in computer science 101 I also did a
little bit of outreach to primary school
students and I also t8 TAS in how to TA
basically so basically it came up that
they fought the computer science TAS
didn't know that much about human nature
and pedagogical reasoning so they
started making more or less mandatory
that the TAS did a course in how to be a
good ta which I was one of the of the
tas of that course so a little bit later
but yeah then after I finished my PhD I
started working at software engineer at
the Crypt ematic we have been working
since last summer and which is my
current employer and regarding my
research we took a look at the papers
I've had the pleasure of the
co-authoring which is on all of these
except one seemed to have the common
features it all considers to party
protocols in the static and malicious
setting it all works on garbled circuits
and we're talking just that the regular
grapple circuits so of boolean gates
based on symmetric primitives so no
fancy number theoretic we use a bowl I
romantic or anything like that all my
work has been on the practical angle of
the secure computation in particular all
of it
also only works on symmetric primitives
except for a small small amount of
isometric primitives usually OTS which
is only dependent on security parameter
so I have six papers with all these
common features yet they're actually
very different I have one paper I've had
the pleasure of co-authoring which goes
a little bit out of this comfort zone
and considers MPC and she could share a
secret sharing based protocols instead
of garble circuits and secure to party
protocols and this was done while I was
the thing at the University of Bristol
so that's why it's a little bit out of
what I usually did and this paper was
was basically about speed tiny OT and
mini Mac which is equal cheering based
protocols for malicious security and the
paper considered a unifying offline face
these papers have both the
pre-processing an online setting and we
can see that the pre-processing which
didn't was haven't gotten so much
attention that paper was published at
Asia equipped last year a little bit
more about my research I have two papers
on current use of based protocols of
dabble circuits both of these papers
consider the simply setting same
instruction multiple data and contains
GPU implementations of the maliciously
secure garbled circuits both these
papers also consider optimizations of
ensuring consistency of the gobblers
input it's based on circle documentation
and universal hash function both papers
are you see secure and a non
programmable random Oracle so might ask
what's the difference between these two
papers because they all sound a lot the
same the difference is is the first one
it's not that efficient with the
consistency of the gobblers input it was
very much an implementation paper and
actually did not contain any proofs so
we're omitted isn't the second one by
introducing a you see proof even more
importantly the second paper implements
some new optimizations introduced in
2013 independently by
lindell and brandao and juan cats and
evans wait Scott surround effect three
of the amount of garbage circuits one
needs to construct so basically we
considered that idea which is basically
that once you do current use you have
some circuits you evaluate and in
general you need to take the majority of
the output to be the true output of the
computation but these authors consider
okay what if we just have one good
circuit work can we do then and they
came up with the three very different
approaches none of which had that suited
in the simdi settings so that's why we
took a look okay what can we do in the
simply setting I also have two papers
based on Lego protocols Lego protocols
also consider cutting tubes of garble
gates but instead of doing current use
of entire circuits its current use of
individual gates and these gates are
then soldered together into a
fault-tolerant buckets which build one
garbled circuit which is fault tolerant
so yeah I have two papers in this area
co-authored and both papers consider
moving from the first legal protocol
which required asymmetric operations
proportional to this to the amount of
gates in the circuit into a just doing a
symmetric operations for each gate both
these papers actually having another
contribution which is X or more feet
commitments that just requires an amount
of isometric operations doing set up in
sots and then only a constant amount of
symmetric operations / commitment
difference between these two papers was
that the first legal papers are the
sufficient as the second one and the
first one only introduced a week notion
of these XO homomorphic commitments the
week here means that not all the
commitments you make are completely
binding there might be some that are not
binding so we remedied this in the
second paper and that actually branched
out to an individual to another paper
which was published by itself at TCC
this year
and that considers plane XO homomorphic
commitments furthermore the second label
paper also considers maliciously secure
garbled circuits as a primitive in
itself so considers the idea of
interactive interactive garbling which
is constructing a garbled circuit which
is secure even if the people
participating in the construction acma
licious lee all right so yeah that was a
little bit about me and about my
research about the stuff I've done which
I'm not going to talk about today so I'm
going to give a little bit of motivation
about the the rest of the talk today
which is about privacy free couple
circuits so as you might have noticed
from my research and from the title of
this talk we can see the gobble circuits
which is a primitive introduced by
Andrew y'all back in the 80s and it can
be used in many for many different
things in particular Sakura computation
wit has been the first and the most
famous use of it but it also finds use
it in Fievel outsourcing of computation
key depend message security functional
encryption and also in efficiency or
knowledge proofs and it was particularly
the last one here the officiants your
nose proof we take out the pattern for
this work ok so garbage circuits can be
used many different settings and each of
these settings or well some of them have
different security requirements in
particular the case of the zero
knowledge so the question we asked ok we
have these different settings with
different security requirements if if we
remove some of the requirements can we
then make more efficient coupling
schemes and as you might have guessed
since i'm not very fine to my talk the
answer is yes basically begging 2012 the
Lao Huang and rug away formalized the
notion of garbling schemes and they
consider two vectors of security in
selling of garble circuits there is
consider the secrecy aspect and the
authenticity aspect very abstractly the
secrecy aspect means that a person can
evaluate a garbled circuit without
knowing the true value of the
computation or anything about the
computation while it goes on yeah
authenticity considers it's not padded
considers the setting where the person
evaluating the circuit get some output
which he cannot change in any way to
something else than what's supposed to
be computed so this is very abstract and
our well after I actually formalize
gobble circus a little bit I will mean
what this actually means but basically
what we consider is removing the secrecy
aspect and only consider garble circuits
with which have authenticity right so
that was a little bit about the
motivation that we want to separate the
security requirements actually remove
some of it and see if we can do it more
efficiently so if you like efficiency
then this talk is about how we can do
some capital circuits more efficient if
you don't care about efficiency well
then this talk is about separating
different security requirements of a
primitive so there's something for
everyone here depending on what view you
have all right let me now go through a
little bit of preliminaries so as I
mentioned below quang and rockaway
formalized the notion of a garbling
scheme back in 2012 we consider we have
a function description f which is a
description of garbled circuit or sorry
of a of a of a plane boolean circuit
that is a directed acyclic graph of
gates and we have a computational
security parameter K these are then
given to a probabilistic algorithm
garble which which constructs a garbled
circuit along with which we call f along
with encoding and decoding information
the encoding information is then used
with a bit string which is actually the
plane input to the plane function to the
plane circuit
the encoding algorithm then uses the
encoding information and this plane
input to construct a garbled input this
capital input is then used with the
garbled circuit in an evaluation
algorithm which returns a couple of
output the garble output is then used
with the decoding information in a
decoding algorithm and returns the plane
output of the computation of F and X so
basically this expresses a secure way of
computing f of X and they also consider
we'll just doing it in plane so that's
basically what happens in the non-secure
setting we take F and we take evaluated
on X and get Y out and let me just give
a little toy example of why it might be
be interesting to remove the secrecy
aspect of a gobble circuit because it
seems kind of unintuitive that we
actually want to do something securely
but it's not secret when we end the
setting of computation so consider
outsourcing of computation where we have
a client and a server the client at some
point has a lot of power he's home with
his desktop it's quite a powerful
machine but at a later point he's out in
the field only has his phone with him
and he still wants to compute something
so what happens is at home the client he
constructs a gobble circuit of a
function he already knows doesn't know
the input at this point he learned sense
this gobble circuit to the server then
some time goes by he's out in the field
collecting some data which he needs to
compute on but he only has his phone
with him and that's not very powerful
it's not powerful enough to actually
compute this function so basically he
uses the encoding algorithm to the input
which is what he gallon in the field to
get a gobble input which he then sends
to the server the server then evaluates
the garbled circuit on this gobble input
achieves the gobble output sends this
back to the client which decodes it and
gets the plane output which he gives us
output so in the general setting we have
secrecy here
using on the gobble circuit the server
will not learn anything about the input
X but we might consider the case where
basically X is not secret we only want
authenticity we only want the result to
be correct we don't actually care about
the server learning X this case we can
drop the secrecy and this scheme still
makes sense this is just a very little
it's the smallest example I can like we
can come up with where makes sense to
not have it have secrecy of a guard
circuit so this basically means that in
this setting the server is actually
aware of what the plane input X is
during the evaluation so just to make
things a bit more concrete the function
f which is the circuit we basically view
it in this manner weird as a directed
acyclic graph consisting of fan in two
gates with arbitrary fan out what then
happens during the gobbling is that
instead of having a bit flowing on each
wire in this circuit we go on and have a
key flowing on each one in this circuit
so in the normal setting of a gut of a
and the boolean so if we have either 0
or 1 bit on each wire but in the garble
setting we have a key rather have a zero
key or one key and what happens is that
during the garbling is that each gate
then gets gets encrypted or garbled sort
of say such that the the gate takes us
input the keys and return and output key
in correspondence with what the gate is
supposed to compute so this is basically
what we mean when we have a gobble
circuit we have a boolean circuit where
we move from bits on each wire to keys
on each wire and where gates work on
these keys to return to compute the key
of the output wire more concretely a
normal a normal boolean gate with fan
into we have the bits and then what the
gate actually does is look up in a truth
table and
case we have an and gate where we see
the only point in time where the output
is one with both the left and the right
input is 1 otherwise the output is 0 so
AG applegate contains basically more or
less the same except that it's not bit
that pits that come in its keys and the
truth table is replaced by an encryption
table where the encryption is a dual
encryption double or double encryption
which encrypts and output key on the
first the right hand cookie and then
under the left input key so this
basically means if only have one key on
each wire then I can decrypt exactly one
entry in this table and learn the output
key in correspondence with the semantics
of this gate so that's all nice and good
a lot of optimizations have been
introduced in this in this setting in
particular in particular what is called
row reduction which basically means that
we let one of the output keys depend on
the input keys so instead of actually
doing an encryption of an output key we
define the output key from the input
keys so we just do an encryption of a
sero string instead this allow someone
to remove one of the ciphertext the
reason I'm telling you this is because
it becomes relevant in in our work
there's also another very nice
optimization which was introduced by
Kalashnikov and / Schneider which is
called free XO that allows XOR gates to
be evaluated for free what is done in
order to facilitate this is that we add
the constraint that the XOR the 0 key
and the one key will always be a global
difference Delta so no matter which key
which wire which wire you have in the
circuit if your ex are the zero and the
one key will always get the same value
what this means is that the output key
output 0 key is defined becomes defined
to be the XO of the two input input zero
keys and the output one key is again is
then defined to be the XO of the output
0 key and this difference Delta because
we need to keep the constraint
then to evaluate an xor gate we simply
just X or both the left and the right
key and then because ax or a is nothing
we basically we basically end up
computing X or so if both if we have
both the left one key and the right one
key we ex are these together each of
these contains a delta which then get X
sort out and thus we have the left 0 key
in the right 0 key this is one of those
things that's a little bit abstract to
explain on on slides but if you actually
sit and look at it it makes very simple
and perfect sense but now we have all
these zeros and ones next to us and so
on so it's a little bit a little bit
tricky to to completely explain on just
light but if you look at the Alta bite
it works perfectly and this basically
means that XOR gates now become free
nope no no encryption needs to be done
and no note cipher text needs to be
stored for the garble gate sorry yeah it
does not create a it does not create a
problem that's a little bit of the
security assumptions needed becomes a
little bit more anymore we need
something a bit more in ya wee little
more spice it basically means that when
you do it in practice you need something
that's called circular correlation
robustness if there's a paper that
actually defines that when they look at
the security of this notion it's less
than a non programmable random Oracle
but not a lot less so a way of doing
this double encryption is actually using
a hash function and so using a hash
function on the left and the right key
to construct a pseudo random string and
then one time pad that with the do a
one-time pad encryption with the output
this was this is in the most common
setting at least to the best of my
knowledge and use I think was introduced
by Pincus night as Madame
in 2009 and that's also the point of
departure of the privacy free scheme we
will take this basically means we don't
actually use an encryption scheme we
just use a hash function to to do
encryption so now I can go back and give
you make a little bit more sense of the
secrecy and authenticity yeah no yeah
yeah we basically use the hash function
to derive a one-time a one-time patent
into a one-time pad encryption it's not
formally it's I think the formula formal
formal definition is key to radiation
function because that's actually what it
turns out to be when you use the
different optimizations but in the
abstract setting you would normally
consider it a double encryption scheme
this is just actually the way you would
do it in practice so this goes back to
so now when I've actually introduced and
formalized what a gobble circuit is we
can make a little bit more sense of the
secrecy and authenticity security
requirements so basically secrecy means
that if we're given a key we don't know
if it represents 0 or 1 if I'm only
giving one key for each wire and a
garbled circuit then I cannot figure out
where that says it represents a zero or
one key without any extra information
than just the garble gates that's the
secrecy and the authenticity is that if
I'm giving a given one key on each input
wire to a gate I can only learn the
output key in correspondence with what
that gate should compute so if its end
and I get 21 keys one the one key on the
left and the right should only be able
to learn the output one key and I cannot
compute the outputs a rookie so that's
what you mean where authenticity so it's
the first one we will remove
and to formalize the authenticity a
little bit let's err consider little
game we have a probabilistic polynomial
time adversary and we have a game the
adversary picks a circuit to compute and
an input string to that circuit he sends
that to the authenticity game the game
then gobbles that function and encodes
that input and sends that back to the
heir to the adversary the adversary then
gives a proposed garbled output Y and
the authenticity game then decodes that
wine to get a plain output and evaluates
the gobble circuit on the garbled input
and the adversary then wins this game if
he's managed to find a gobble output
which which decodes to something else
than what was supposed to be computed so
basically he wins if Y is different from
Y Prime
I think that would also work this is the
definition from below quang ninh and rug
away yeah I think so yeah okay so that
was a bit about the preliminaries what I
mean what type of since there are
different types of garble circuits what
types i'm considering here what security
we are considering long em and a little
bit about the optimizations of garble
circuits that already exist because
these come into play in the following so
now let's go through the main part of
what we actually did in there in this
work so let's start by considering an
end gate and let we start by also
considering no free XO so we don't have
a correlation between the zero and the
one key so we just have a pseudo key and
a one key for each wire and we want to
do an end gate so basically what does an
MK 2 well it computes and this means
that if I have either a left 0 or white
0 then in either of these cases i know
the output is going to be 0 it doesn't
matter if the order is 0 or 1 and if I
have left one and the right one then no
the output is going to be 1 so using
using the hash based dual encryption we
basically we basically just look at the
down here at the one case we hash the
left and the one key like we do a normal
couple circuits and one-time pad that
with the output one key so far so good
things like before however using the
observation that in either case if I
know whether or not I have a civil or
one key if just one of them is zero then
I know the output is supposed to be
sealed so I so we compute I have
something left left 0 key and the house
on the right 0 key and we learn the
output and and we use that to one-time
pad the output 0 key so now we see we
only had three ciphertext so we've
without using rolled up
we already removed one cypher text but
we can actually use row reduction we can
we can let the output one key be defined
to be the hash of the left left one key
and the right one key similary since we
don't use free XO we can also define the
output 0 key to be the hash of the left
0 King so it doesn't mind we can
actually remove two of the ciphertext
and what's left is just a single
ciphertext in this car blockade to
evaluate we're given an input key on
each wire and we know if its support if
it's a and because it spreads privacy
free we don't have the secrecy we know
well that represents SEO or one bit so
if it represents a one bit both of them
represents one bit and basically just
hash them and then we have the output
one key if the left one represents the 0
bit we hash it and we have the output 0
key in the last case well we hash it
react so it with the entry of the cobble
computation table and this basically
means that we have now the hash of the
key and the heads of the key they XO out
and what's left is the output key so far
so good so that's an end gate it
generally turns out that there are two
types of gate they're the ones that are
that have them were two bits two of the
output two of the bit is a two of the of
the bits in there computes in the inlet
in the truth table is 1 and 2 20 and we
have the ones where it's either free or
one that's three have the outputs that's
a one and free weights are 0 so we have
have two different weights and it
generally this is the case where we only
have one of the the one bit in the truth
table being one and then the other case
which is well as an even amount of 0 on
once in the troops
table is more or less the same and we
just consider X 0 in this case so like
before if you want to compute extra well
what do we actually know about the
computation of excellent we know that if
I have the left serum and the right 0
then I should learn output 0 similarly
if I know the left one and the right one
then output should also be zero in case
one if just one of if only a single of
the inputs is a one then the output
should also pier one so basically based
on the idea free XO where we XOR out the
Delta in case where we have to two piece
that are one we use the same idea here
and let us simply the ciphertext be the
X awe of all the serial keys and all the
one key so the left 0 the right to the
left one and the right one and then we
define the output one key to simply be
the left 0 X or the right one and the
output 0 to be the left 0 accelerates
you what this means is once we do
evaluation again remember I know where I
have a serial or one key I check if the
left one is zero and the right one is
one well then I know I can simply
compute the output one key by echoing
these two together so far so good if
they're both zero then i know i can
compute the output 0 key if I XO these
together so far so good we still have
two more cases left but then what
actually happens is that in any other
case I acts are the two keys together
and exhale with the ciphertext and that
basically corresponds to indicating the
semantic meaning of the key if I have if
I have both the left one and the right
one being one I XR these together then
they X out this part here and what's
left is actually the 0 key like what we
want for an XOR gate so in this case we
also down to just one cypher text / gate
and if we want to use free Exxon we can
also we can do something similar but not
quite as efficient the idea is the same
like before we look at what we can do if
we have an and gate or rather what what
yeah what we what we know if we have an
and gate we know that if the left is one
key and the right is a one key then we
should get the one key and we also have
the definition that if we have a one key
and export with Delta then becomes a 0
key so we construct the table like
before but this time we can only reduce
out one row we cannot define both the
output 0 and the output 1 key because of
the Delta so we just define the output
one key so far and the Swede use one row
so we have two more rows left in the
table evaluation is basically the same
as before if they're both the left and
the right key is a one key then we
compute the hash of these to be the
output one key if the left is zero we
hash it and exit with the second
ciphertext and if the right one is zero
we hash it and XO it with the other
ciphertext so it's basically the same
except we can only reduce 11 row and not
to like before the XOR gate is computed
for free like in a normal couple circuit
with free XR so we don't have anything
in the table and like in the case of
normal X 3 X on the output 0 key is just
defined to be the XO of the input zero
keys and the one key is defined to be
the XO of the other ones and like before
we XOR them together this is just like
you would normally do in free x or
nothing different here so far so good we
both have a very nice optimized case if
we don't use free XO where we just have
one cypher text in a capital gate and if
we use for your XO we have to get by
with to cipher to expurgate yeah
yeah there's no hashing there's no yeah
there's no way we just have to do X or
so it's also it's cheap the xor gate is
still is a yeah we actually call them
cheap XO it's not quite free the cross
we still have a ciphertext that needs to
be sent but we don't have to do any
heavy heavy computation if we want to
call a hashing heavy in practice at
least in my experience with what we've
done with garbled circuits it's always
the communication that that's the
bottleneck so i would say in practice it
would have a very small significance but
you know in theory it's nice yes exactly
so I mentioned in the beginning that
there's already been some future work in
particular the half gate paper I will
talk a little bit about the half gay
paper later on so if that's all right
with you all right yeah yeah now I just
want to show a neat little thing about
this the way we do gate we were you do
privacy frigates which we call well
large Fannin so in general we consider
we consider double gates with our gates
which only have fan in too but consider
the sailing where we have a large fan in
we have one a compute end of ten
different wires 20 or 100 or whatever in
general the way you would do that is you
know you construct we construct you look
at the truth table of the gate you want
to compute and you encrypt each of the
rows so you know that's an exponential
explosion in the amount of ciphertext
you would do in in the general setting
which is not so nice which is probably
why we are in general you only see
papers where people consider fan in two
of gobble gates
if we consider the reasoning behind the
privacy free gate and let's just
consider for simplicity the example of
fan in four and we consider this to be
an end gate like before we define the
output one key to be the hash of all the
one keys because if we have an M Kate we
know if all the inputs are 1 then the
output should be one and that's the only
case the output should be one and just
for simplicity we define the 0 key to be
the hash of of the of the silky of the
first wire so far so good now what
instead of actually computing this big
beast here we can get away with just
three ciphertext the reason is basically
in an and gate if just one of the wives
is zero it doesn't matter what the rest
is right it should always be zero that's
the output and then we basically just
hash the 0 key of each of the input
wires and use that as a one-time padding
of the output 0 key so you know that's
that's a neat little little observation
so here we have exponential input plus
minus a little bit depending on row
reductions and and here we have linear
plus minus a little bit depending on row
reduction excellent excellent question
excellent question we looked at it a bit
it turns out well hold on let me show
you the next slide because that gives
the reasoning behind the behind this so
here we have a truth table just flip the
round of an and gate we have the output
where one is the only case well we only
get one of all the inputs are 1 and
basically we look at to do these privacy
freak Applegate's of last fan and we
look well we look at the truth table and
we we look at the output and try to find
a feature of the input which uniquely
defines one of the output so for the one
the unique features all of the inputs
needs to be one that's the only
case for the zero we can see the unique
feature for example with the fourth
input is that all these are zero the
output should be zero and then so on and
so on and if you want to do something
that isn't and you need the same
reasoning if it's NAND no problem then
it's the same right just flipping the
output the meaning of the output bit you
can't it can continue doing this if you
have some more exotic gate and you can
continue to look at features for example
if only these two if it should be one
only if it's one here and one here and
that's the only case then you can define
the padding to be when the left left two
is zero so in the input to an input for
serum so basically try to find unique
patterns here it doesn't we couldn't
find an algorithm that clearly captures
this and generalizes it basically the
observation is if we define if we define
the weight of a gate should be the sum
of the output bits if the weight is very
close to zero or very close to two to
the amount of input input the input
wires then we can do this very
efficiently if we were if we have one
that's way the where the way it is to
hear we need to add another ciphertext
in most cases not all of them for the
most and so on it continues and the
worst case is just about half if you
have an equal amount of zeros and one
that that's that's the worst case and
then you're more or less back to the
general general case as before but it's
definitely it's it's an interesting
aspect you can you could continue to to
look at it could also consider multiple
outputs of a gate so we actually don't
have a gate but you have like a gadget
instead and see if there are some nice
ones which have a nice pattern in it but
depends on on the truth table actually
if you want to use arbitrary gates of
Latin
you can do net that's no problem and i'm
going to do you can do everything right
but did we want to do it as efficiently
as possible and so yeah yes yes yes yes
you would that's a good question and we
haven't really looked at it we noticed
that we could only do those with high
very high or very low weight efficiently
and you know we just had okay future
work let's let's let's look at it
tomorrow I'll let someone else look at
it tomorrow but it's it's something
interesting that would be be fun to
continue to look at see what what could
be pulled out there so just a little
intuition about the proofs we have in
the paper and yeah we're some sort that
I have quite a long time for this talk
so that's why I add a little little
proof section it's actually it's not
that that interesting the proof is
extremely straightforward basically what
we had what we have in the papers we
base everything on the notion of
grappling schemes as introduced by
belong and rug away so we have as I
mentioned in the beginning we have this
tube love algorithm algorithms we add
another algorithm which we call
verifiability it's not strictly needed
to do privacy free garble gates but if
you want to use it in practice you would
more or less always have to open up the
gobble circuit you construct if you want
to use it in a malicious setting so it's
basically a convenient one in particular
since the title is privacy free gobble
circuit with applications to efficiency
or knowledge and in that setting you
need it so we add another algorithm and
that's setting and that algorithm it
basically just says that if you have a
gobble circuit that's supposed to be
based on on some circuit and you get get
the randomness used to construct
it you can basically verify it if it has
been correctly constructed it's it in
general it follows from from most of the
schemes quite trivially that you know if
if you have all the randomness used in
the constructions then it's easy to see
if it's been constructed correctly yeah
when you use it in practice you would
have some some commitment that you would
use some commitment in in this setting
no no no you sent to randomness later
later in and then here it's basically
you cannot find some other randomness
that makes that verify that the circuit
yeah and that you cannot that you
basically just have one Random
randomness you can find you cannot find
another randomness that makes you the
circuit verify to something else than
what is supposed to compute
nope nope nope yeah yeah the the honesty
of the server is basically enforced by
the authenticity of the scheme so in the
toy example we don't need the
verifiability but in the Sirinoya
besides yeah the authenticity says you
can find a different output so and
that's basically the only thing we allow
the show what to do in that setting yes
okay so the proof itself consists of two
bad it's a reduction to a what we call a
secure key to aviation function and
basically what we do is we show that if
we use a hash function that's modeled as
a non programmable random Oracle then we
have this secure key derivation function
I will define the secure key derivation
function in a minute and then basically
we look at our protocols based on the
notion of gobbling encoding and so on
and reduce that that that to the
security of the KDF so a secure key
derivation function basically just
models what we want to do in these type
of coupling schemes an adversary gets
access to make three different type of
Curie's to to a game its other sample a
uniform your random key make a linear
combination of existing keys or derive a
new key based on some existing keys then
the adversary can ask the game to leak
some of the keys and in the end the
adversary wins the game if we can give
the game a key which is not compromised
and here compromise means if it's not
efficiently computable from the key
sleek to the adversary so it's very
close to what we actually do what we
actually do because everything we do is
either deriving keys baits on already
existing keys sampling random keys are
doing a linear combination it's the same
in both the
in both it both without freex on with
with free XO yeah it's a little bit like
that we believe and that you could also
do this with circular correlation
robustness but you know when we made
this paper we we wanted to leave
something for future work so we just we
just looked at non-programmable random
Oracle it's straightforward writing the
proof we fought the interesting part of
our paper was not was not the proof it
was basically just it was the idea and
the construction so exceed me in the
free exercise yep leaking like the one
in 0ki but if he if he has that then he
can trivially compute all the other keys
so yeah and then if it does if he asked
that to be leaked then he automatically
compromised all the others yes he can he
just can't ask for 420 for the both keys
on one wire without compromising the
risk because then he can efficiently
compute that is linear combination look
that's yeah the proof is playing hybrid
proof just yeah we first make it into a
game with a bit instead where the
adversary had does the same as before
but then he inputs a bit then he gets a
key from the game that's either the
correct key or a randomly sample key and
then he says okay is it one or the other
that's the first type but then we have
another Hyperwave removed at the right
method and that's basically where the
non programmable random Oracle comes
into play because the basically says if
ya
versary don't have enough entropy and
the keys then it's uniform then he can't
guess then it's indistinguishable from
uniform randomness that's why all the
keys needs to have at least K where K is
a computational security parameter
random bits and then the end we just
showed that in this setting then he has
negligible advantage when HSN on program
for an emoticon yeah yes I mentioned
it's yeah basic just using the fact that
the output of a hash function when
there's enough entropy and the input is
uniformly randomly distributed in the
view of the adversary yeah and so that
was about how we prove that the hash
function is secure secure key derivation
function then the scheme's it's
basically just do a simple proof of FN
in two case without free XO and that
generalizes nicely to free x or because
free XO is just defined from a linear
combination which is all what we already
have in the game and because of the
compromise ation part of the key to be
asian game he cannot do anything fancy
so in this case we basically stand in
between the adversary and then we make
calls to the secure kdf game sample
input keys at random gates as you
remember are constructed as a hash
function on some inputs X or with the
output so we can do that with the KDF
game and we can leak we can astok ATF
game to leak keys on each of the wires
and the gates can also be leaked in the
setting they're constructed in the same
way so we send that back to the
adversary the adversary then since bag
and off of of a key we send that back to
the KDF game so it's enough nothing
complicated nothing fancy extremely
straightforward all right and so yeah
now we'll just give some concluding
remark remarks in particular i will stop
talking a little bit about the half gate
so as mentioned
yeah that the half gates very nice paper
and by so who will rush leg and Evans do
things have been more efficiently than
us so actually a talk with Mike Mike
Russell lake and he said that they were
actually extremely inspired by by our
paper so the half gate approach takes
sort of the idea of the of having
somewhat privacy free gates so they have
in the half gates a half gate approach
they have to to make an and gate they
have two small gates half a gate and
hence the name and each of these small
gates has privacy privacy free either
for the constructor or the evaluator of
the circuit and then they are combined
into an actual and gate so it uses the
idea of having having having some
privacy freeness in order to actually
get privacy so it's a really really cool
idea and really efficient and they they
managed to get the privacy free grapple
gates with 3x or with only one cypher
text using this approach so so that's a
really cool paper and it came as you
might have guessed after our paper so
our paper was an ePrint for quite a
while before we got it got it published
and then Mike and the others were quite
fast at getting the half gates a half
gate idea and both both our papers were
actually presented in the same session
at euro crypt so they were very speedy
at getting the half gay paper written
down and unpublished although but I
think it was a very cool cool cool
session versatility of privacy free and
then how to actually use that to get
secure gates so and also that that
basically also means that the idea was
interesting that someone might manage to
get something out of it and make some
new new work on it all right so let's
talk a little bit about the efficiency
so basically made a little table here in
the case of fan into gates without free
XO with free XO and using the flexeril
approach
the flex our approach was also done by
Mike and some few a few other people
before the half gate it was basically an
attempt to get the best of both world
the best you can get without free XO
while still having free XO it sounds a
bit weird but instead basically what
they have is that instead of having one
global difference between all the keys
they have several and they depend on the
topology of the circuit you evaluate and
they manage to do it more efficiently
create garbage circuits more efficiently
than in the case with free XO because in
their setting they can reduce another
row in the gobble computation table so
yeah at the time of writing these were
the big big free ways of doing gobble
gates so we adjusted them to the 3x or
sorry for you to the privacy free
approach what we have is complexity here
is in amounts of calls to a hash
function all cases except the new half
gate approach it's it's it's three calls
to for construction one call for
evaluation and the sizes is one
ciphertext for without free XO on for
both end and XOR gates and to cipher
text if it's with 3x on and the flexor
is one cypher text for end gates and
somewhere between 0 &amp;amp; 2 cipher texts for
XOR gates again that depends on the
topology of the circuit that's basically
following straight of in them in what
they wrote in the flexor paper we do
manage to optimize flexor a bit besides
just in the N Kate case because in the
flexor pay but it would also need to
compute some calls to a hash function
for XOR gates which we managed to get
rid of because we have the privacy free
thing here so we also managed to
optimize that bit
yes yes on average yeah
in that in that case there we would use
to cipher text friends and and up to two
ciphertext 4x or so some are it's not to
say that we might have overlooked some
some way of doing it but right now it's
not really relevant anymore after after
the half gates came along so flexo was
nice but but but your lasso also have
the generalization for large Fannin
where T here is is a fanon so it's the
same as SP form its linear plus minus
one in in the amount of input wires to
the gate plus one in regarding to
complexity when constructing and minus
one in regarding to the size of the
ciphertext because of the row reduction
approach and I don't think there's a lot
more to say about this this table it's a
bit more abstract it's just to also
include the the general case and I like
the previous one a bit more because
that's what will usually work with the
Fen into gates so we also have a little
little table here where we actually look
at some real circuits and how much how
much we can save using the privacy free
and we see here that in most cases using
privacy free flexor even though we might
use to Sanford sex for its xor gate
actually wins in most cases at least in
regards to to communication
we have the table of calls to a hash
function also for the different
different schemes first here and the
columns who have the amount of and gates
XOR gates the gdr2 that's without free
XO and with free XO and flexor and
that's the average amount of ciphertext
needed per gate and this is the general
general garble circuit not privacy free
and here we have the ones with the
privacy free so and that's that's in
communication and here we have in
computation where the first part here is
in construction and the second is in
evaluation so yeah computation the free
XO winds always all right here we have
the savings in the utmost column so I
also have a little table comparing
comparing with the half gates table the
privacy free of the half gates how much
they they approve I'm sorry improve on
average amount of cipher to explicate
and we see it goes from not so much to
up to 250 percent and some settings so
it all depends again on the amount of n
gates and XOR gates in the goggle
circuit which varies a bit from function
to function we wish to compute so that
was a little bit about the complexity or
sorry the benchmarks yeah some
concluding remark remarks so future work
is more applications of privacy free
guarding i showed the toy example and i
mentioned also the point of departure is
using in stevenage proofs which is based
on an idea by a very cash bomb and
orlandi from 2013 which is where really
shines the privacy free case where the
optimizers a lot but you know there
might be other cases where we can use it
in the real world can the privacy free
idea be used in fully secure grappling
schemes
yes we saw the half gay paper that's
using some of the ideas here to get
fully secured Applegate's and also can
get more fish in privacy free schemes
yes again the half gay paper solve that
question as well the fact in fact the
first one has also been solved a little
bit carsten bomb has done some work on
combining both fully secure garble
circuits and privacy free garble
circuits for secure computation
basically looking at the function you
wish to compute and cutting it up into
pieces looking at if parts of the
function can actually be done in a
privacy free manner so trying to combine
those to use even less ciphertext to
compute for this is secure two-party
computation it's a it's it's not
published yet it's an ePrint from from
this year it's only been on a few months
I think so it's just a nice view of you
know pulling it into the malicious
malicious sorry not just the militia
setting but the secure computation
setting so little bit of a recap what
I've talked about today is the notion of
privacy free guarding sure how to
implement this both with free XO and
without free XO and the paper you can
read about deflection but that's again
let's has been sort of surpassed by the
half gates we show that we can do this
more efficient than a fully secure
garble gates which is again still the
case even after the half gate paper so
it seems that there's actually a
difference in complexity depending on
whether you just want secrecy on whether
you want secrecy and authenticity or
just authenticity because it's the same
case in in the half gate paper for the
privacy free it's done strictly more
efficient than if you have both secrecy
and authenticity we showed a nice little
observation that this generalizes nicely
for large fannin and I quickly and
briefly sketched the proof idea of
showing this in a non programmable
random or
so yeah was published at yer equipped
last year but the full version is on e
print and yep that's that's basically
what I have thank you and are there any
questions yeah in that case it would we
haven't haven't looked at it and yeah
yeah that's true maybe maybe it makes
sense if you use some do something more
information theoretically based where
you just know okay yeah yeah and we
haven't looked at it that's that's what
I can say again this work was actually
motivated by the Vice piece of specific
setting but yeah I guess if we want to
stick to just have secrecy to not be
possible to brute force if so then you
would still need a long long key unless
you use some information theoretic
coupling I would I would say not to say
that that's not possible I information
theoretic gapping schemes out there but
they only work on very shallow circuits
but you know something something to look
at yeah
that's that's a good question I've never
actually done any look on snacks so I
cannot really give a good good answer to
that the way it's used in the zero
knowledge proof it's of non algebraic
statements and it is it is interactive
so we don't get the non interactivity of
snacks for example but honestly I don't
know if no I never I never done any any
work on snacks yeah again you're coming
with a lot of different things to it to
it to look at anything I will just
before I forget it actually note it down
yeah yeah yeah
sorry even though yeah you do ot
extension then then you only do over the
security parameter here when you do like
a few hundred sedo tees and you can
actually now nowadays you can actually
extend them on demand so just do it if
you and I want to do some protocol that
requires OT we just do a few hundred OTS
once then we save the seats sort of
coming out from these OTS and then we
can later to extend them on demand was
published at crypto two years ago a way
to do this by the people in Bristol but
that's a good
alright</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>