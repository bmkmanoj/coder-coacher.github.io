<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>New Techniques and Models | Coder Coacher - Coaching Coders</title><meta content="New Techniques and Models - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>New Techniques and Models</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MIFbzXOZQo0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
thanks for the introduction this is
joint work with Vladimir Kalashnikov is
here so i'll be talking about improved
all the extension for transferring shots
tickets so so i guess we all know about
the secure computation by now there is a
alice with with our input X then there's
Bob with improvised it's the stupidest
secure computation they want to engage
in a protocol such that they only learn
respect to outputs but they don't learn
anything else other than nothing else is
leaked hey so this is the most general
problem in cryptography and it's it's
it's an area which is moving fast from
theory to practice and as we as we will
see in many talks are in this workshop
so this is the major research effort
which not only improves the asymptotic
but also focuses on concrete efficiency
and even the even when the first talk we
saw this work which are just this
implementation as well as systems issues
in this area it is like a quick look at
the state of the art so on the theory
side we have really amazing results so
you can do MPC to party secure
combination say with constant overhead
so this is independent of your security
parameter independent of I don't know
pretty much everything so it's constant
overhead over the size of the circuit
that you are evaluating so that's it so
this has been done for JM w by Casso 8
and also now there is a very recent
paper you can also get optimal
communication as well as their own
complexity so here optimal means it's
just length of your input does not
depend upon the circuit sighs and this
you can do using like tools like fully
homomorphic encryption indistinguishable
day office kitchen so there are several
new results coming they're just two
rounds for any number of parties and we
also have Aram base secure function
evaluation well you know you don't have
to go through the circuit based
paradigms so you can you can run you can
get your function evaluated in its
actual running time on the practical
side we have had
a lot of really cool optimizations about
yoga basically a free eggs or technique
gobbled row reduction point and permute
and flexible eggs or later in the day
and then also been like very very good
implementations a lot of tricks there
and so now you can you can garble an aes
circuit in 637 microseconds amazing but
also a lot of optimizations for JM w
this was kind of the GM w come back that
was referred to in yoga stock so ZM WSV
as we saw stick so it's one paradigm
which which easily adapts to the
multi-party setting and this talk my dog
can also be viewed as a GM w come back
kind of thing there are also other
hybrids such as you know you can you can
get some techniques from yahoo and GM w
put them together and get some get some
more optimization so that's also there
so so anyway the main point of the slide
is that although we have had a lot of
really cool results the theoretical
results in the last five years let's say
last two years our implementation still
rely on yahoo and GM w from 1980s right
so so one reason is that well these are
all theoretical results constants are
very high but there is also some kind of
hierarchy of efficiency here which we
need to take into account so we just say
fhe is greater than greater than p ke it
stands for public key encryption and
symmetric encryption and then the
one-time pad where where greater than
means that the cost of villages is and
will probably always be by orders of
magnitude bigger than the cost of
alice's so this is just something in
that is even when when you implement
things in practice and the topic of this
top coat the extension is motivated by
this major gap in efficiency between
public key primitives and symmetric key
parameters so i will detail on that more
as we go so will motivate the the
problem of introduce and motivate the
problem over the extension and so in
this talk i will will briefly explain
shiet sot extensions
solution and how we provide a new
framework for it and then improve both
in asymptotic as well as concrete terms
hey so so this is a slide about the big
gap between public key encryption and
symmetric key encryption so public key
parameters when I say publicly promoters
I mean like primitives like key
agreement oblivious transfer secure
function of elevation the parties do not
have any shared secret in advance let's
say and symmetric key primitives are
like pseudo-random generators hash
functions etc so so public approval is a
harder to implement heuristic Lee we
have we have very few candidates they're
all algebraic in nature yeah I don't
know ddh I'll say for a long time and
then we had lwe they are usually more
expensive to implement simply because
the there are the better algebraic
attacks known against these these
candidates schemes so your parameters
have to be much bigger if you want to
defeat state-of-the-art attacks whereas
for symmetric key parameters it's very
easy to implement heuristic Lee you can
have the competition's I don't know
every year and you can get great hash
functions which are just impossible to
big so they are much cheaper in practice
to get so it so this kind of phenomenon
also has some backing from theory which
says when there is this great result by
bugga bug reso and rooted it says
loosely speaking public key primitives
cannot be black box reduced to secret
key promoters in a very practical the
meaning behind this is like a big factor
of like three to four orders of
magnitude difference between publicly
primitives and symmetric key primitives
and this is only mid I don't know bigger
because now nowadays inter provides AES
new instruction set inside the chip so a
is becomes even more faster so so so
from this size say that instead of the f
is pretty bad you know the public key
parameters in secret to notice there is
like an inherent gap right so what is
the next best thing that we can do so we
know that you know you cannot get public
eeprom this from symmetric cameras but
maybe we put some public key properties
on the other side and maybe this is
possible right so this is known as the
extent extending primitives so so I
think I mentioned in the stock extending
public key encryption is very easy it so
you just encrypt the pillow to the
symmetric key so you one public key
operation and then the rest is all
symmetric key encryption so yeah it's so
so incurred the payload of the symmetric
key is also medical operations then then
your incal symmetric key with the public
is like 11 public key encryption this
has had like a huge practical impact on
everyday use of encryption and natural
question is okay can we also do this for
other parameters which say oblivious
transfer so so let me explain the
problem of oblivious transfer so you
have you have a sender with two inputs X
0 X 1 and there's a receiver with the
selection selection bit higher at the
end of the protocol Alice does not know
anything about what what there is the
what the what Bob selection bit was and
Bob this is exactly X sub R it does not
know X sub 1 minus side so it is like is
one of the simplest non-trivial
primitives it's very powerful so so you
can so in yahoo you have this leg direct
interpretation where you just select one
out of two things so you select one out
of two garbled keys and this others
particular function evaluation in zmw
the interpretation is slightly different
so here you look at the oblivious
transfer as a as a mini protocol which
which allows you to evaluate and gates
so so in JM w evaluate each and gate in
the circuit using using an OT protocol
so let's look at the cost of various
transfer so we saw there's no no black
box reduction for moti to water
functions but but like the public key
encryption extension right so here if
you have woodys on short strings then
you can get Otis on long strings this is
this essentially the same as the public
key encryption extension it's so here
you want you want you want to do OTS on
x0 and x1 which are very long
so you just do a booty on the short
string which is a seed to a
pseudo-random generator and you just
send the mast pads in the clear and then
you just to use is allowed to retrieve
one of the two seeds so that is odee
length extension the more non-trivial
problem is the OT instance extension so
where you start with a few number of
seed ot's and then you want to get like
many many Ortiz so the surprising result
here is the OT instance extension is
actually possible and you only need an
additional n symmetric key symmetric key
operations and this this kind of result
has had a huge impact on on on sfe so
let me do a quick literature survey or
note the extension so as you know they
said the first 30 extension was done by
beaver in a very very simple and elegant
construction but it was the non black
box use of a pseudo-random generator so
this kind of inefficient and practice
this was later improved by you shy
clearness semen padang shall call the I
knp construction so so they made black
box use of a hash function so it's like
you can either look at the work as being
in the random Oracle model or a special
type of hash function on ass correlation
robust hash function and it is the red
it's the most practical otay extension I
mean there are of course other schemes
which build on top of it with that there
are also been other results which which
improve the efficiency of OD OD
extension for the militia in the militia
setting and there are also other results
which which help us improve our
understanding about about about
feasibility results for OT extension
like how many see duties do you need
whether you can do adaptive security and
stuff like that so in this work we will
focus on improving semi honest I knp so
the next part of the talk i will be
giving a brief overview of a Shia tells
OD extension construction and I will
actually use lights from you
I stock a crypt or 2 10 years ago or
something so the I can't be our strategy
is this okay so I need to perform n
number of booties it's a strings of
Sunland right then the first and the
main step of the reduction is to is to
look at I mean it's 2 b's to perform k
instances of what is now so here we
wanted to do n instances of woody's
selections but now you do only k
instances of woody's but the string
length is very large right and then you
can in your second step is the length
extension step which we saw earlier so
so now you can make all these long
strings into short strings that is easy
so let me describe the first the main
reduction so so here the receiver picks
a random n by K matrix which is called
let me call it as T and then the sender
picks a random cable selection vector
which is call this it's so so the
receiver is now going to flip start
preparing the inputs for do tease so the
first input of every path so it has it
has k pairs of strings swings out of
length n and the first input in every
pair is going to be the corresponding
column of T so T 1 there is the first
column of tea the second the second
string in every pair is going to be the
first string masked with the receiver
selection bit I should become clearer
soon so that's it so the first the first
column is always the receivers random
matrix column and the second column is
the that column masked with the receiver
selection bit so anyway so the OD is
carried out so so the sender pics
chooses one out of these two columns
it's going to obtain this matrix which
will call it SQ so so it will obtain one
one column from each of these two
columns like so so let's let's first ask
you what is this matrix you how does it
look like and so we look
the at the aight column of the matrix Q
and then so I'm going to argue that the
ID column the I true sorry the I throw
Qi is the value is going to depend upon
the receivers selection bit odd I so
that so if if at i equals 0 then the two
bits in in in in each Paris are going to
be identical because that is just 0rs0
so you exalt with that I so you still
get the same bit so in this case the I
throw is just going to be doesn't matter
which one you select it's going to be
the same it's going to be TI where TI is
the hydro of tea and when are i equals 1
you can see that it flips depending
depending upon the value of s whether s
is 0 RS is once so it becomes ta xrs and
the observation here is that the
receiver knows TI but it does not know
anything about the sender's input s so
in the first case it will know qi but
will not know qi x RS and in the second
case it will know qi x RS which is TI
but it will not know anything about qi
so so you essentially set up your
correlations in the right way so so now
all you have to do is just you have to
make sure to destroy the correlations of
course the different rows so so use the
random Oracle or some suitable hash
function H and so you're going to
generate your message of Qi or edge of
Qi exhaust so these are going to be able
to mess and then the receiver side the
unmasking is is straight forward in the
normal number so let's look at the ik
and because so so the main reduction
which I saw earlier so here you just see
that there is it is just ending excise 0
masked with edge of Qi so it's the
length of X I 0 which is which is l
let's say so the OT NL is an instance
authority on on strings of length at so
the main reduction which are just
described is going to cost just to NL
bits it's just masking the
masking the inputs and then sending them
and well as the length extension which
is that in the original strategy slide
that costs to NK buds so this is again
standard standard reduction so if you
look at the communication cost of the
resulting SF even when you try to plug
in i can pick construction you see that
ok if we want to use in yahoo then you
your the strings that you want to
transfer or actually keys so in this
case your l equals key and when l equals
k you can see that the main reduction
and the length extension have the same
causes it's both too in case so seems
kind of nice that is when you want to
use it in g MW here l equals 1 so it's
just one bit and you see that the cost
is there for the main deduction is 2n
whereas for the length extension is 2
and k it's like you know something is
wrong right so the main reduction was
the non-trivial part but then it cause
it goes really low as well as the cost
of the OT extension is dominated by the
length extension which is 20 so this you
know maybe gives us some hope like maybe
there's something we can we can improve
here at least for the case when l equals
1 so the next part of the talk talk
about my work which is which is it
providing a new framework for I KMP so
we start by taking a closer look at the
I K&amp;amp;B construction so we saw that the
receiver is going to choose this matrix
T and then it's going to is going to
prepare the inputs for the OT by by
using 11 input as the column from T and
the other input as the column in TX all
with that so it's kyle separate these
two matrices is called this matrix is t
this matrix is you right so in effect we
can see that the matrix U is just TX or
a matrix R which is just the selection
the selection vectors column wise and so
this is actually the TN your secret
shares of this of this matrix I now if
you look at it row wise you see here
if you look at if you look at the matrix
otherwise we see that Vanara equals 0
although well although all the rows that
have the same bits it and I are equal so
it's all all of them at once so you see
that there is like this robot encoding
which is going on right so 0 is going to
0 to the k1 is going to 1 to the K so so
at some basic level I can p is using
repetition encoding so this raises the
question okay can we use other other
more efficient encodings because their
petition coding is a very low low rating
coding and so the first first
modification that we have to make is
that okay now now we want to use better
codes so we want we no longer can use
you know re being either 0 or 1 so we
want direct to come from a bigger domain
so let's say comes from the domain 1
through m and then we are going to use
some some code C let's not fix it right
now so this code C is so earlier it was
02 02 the case so now we want RA to go
to see fri and this will be in 0 1 to
the K and so this is what so so the
receiver gets the r1 through RN these
are all M bit strings I mean they come
from Allah the domain 1 through m so
first creates this matrix C C of C 05 in
this way then we just follow in the
footsteps of I can be so we asked the
receiver to secret share this sea of
fire into T TX or you and again the
sender is going to pick one out of the
two columns see the T column with a you
color and once again we look at a
drovers we look at what what the how the
matrix that that the center receives
looks like and we see that in this case
with the with a slightly more
sophisticated thing we said we see that
Qi will be TI eggs or sea of our I bit
by standard with us so just as a sanity
check let's see what what happens when
Co far is like the repetition code so
when CFR was the repetition code
if I equals 0 then CEO of our i equals 0
0 0 to the K and 0 to the Kaiba to a
standard with that is just 0 so it's
just TI so it's the same as before to y
equals TI and when see when see how far
I is when our i equals 1 then see how
far i is 1 to the K and bitwise Android
with us is just s so it's TI xrs so the
same as before is just you just added
the extra layer of encoding here and the
sender sends they call the different all
possible all possible mass but now
there's no there are a total of em
inputs and he must he uses them mask to
mask all of them and then the receiver
once again unmask using ti it only has
ta does not have anything I'm doing one
of the penalty yep so this is a very
short security analysis so at least in
the main reduction you have perfect
security against malicious center and
since the sender does not does not
receive anything it's just it's just
sending stuff I mean it does receive
something from the OT but those are all
random independent shares and you get
statistical security against the semi
honest receiver and this is because
there's is there's no loss in security
analyst unless the random Oracle is
queried on exactly one of those points
it's the same analysis as i can t and
the loss in security comes i mean it's
it's M times to the negativity where m
is the number of far is the is the
number of master you had number of cover
of one out of em selections right and d
is the minimum distance of C so so what
we saw that we have now got one out of
MOT and the cost of one out of MOT is 2
and k plus manl so so previously i KN
piece cost was too and k plus 2 ml so
now we made at em manor and then we have
the standard reduction well if you want
OT or an instance over T&amp;amp;L beestings
then you can you can
use what this is standard one out of 20
t you can you can get it from one would
of MOT now you have lesser number of
instances but the strings become
slightly longer and then you have this
equation for the communication so so now
what we are effectively done is that we
have introduced another variable m and
now we can optimize like using the best
the best value for M and so so this this
will be the final cost for one order to
woody so this is this is how you even
though you the construction for one out
of MOT you can you can transform it into
one out of 20 to using standard
techniques so in terms of concrete
efficiency use the hard part codes for
for the encoding and this will give you
a factor to improvement directly for one
out of 20 tea and also for GM w and
there are also some additional
optimizations which are which you can do
in the in the length extension side to
give you a factor 3.5 so here I haven't
said so you also get an improvement for
one out of MOT directly if you use our
constructions that will be like factor
five improvement something the
asymptotic communication cost is also
you can make it a can get a log K
improvement but this this is improvement
only over I can't be there rather I mean
when you're talking about asymptotic
cause there are much better
constructions but those are purely as an
erotic not not necessarily concrete so
in conclusion so we started by saying
the problem over the extension is
motivated by this huge huge gap in
efficiency between public key parameters
and symmetric key parameters and oda
extension Adams to bridge this gap and
so have a huge impact on the
practicality of sfe especially when
you're doing secure computation over the
billion input size like when this size
of the inputs is like billion bits or
more and in this talk we give propose
the coding theoretic framework for for I
K&amp;amp;P and so this can be instantiated
either with random Oracle or some new
type of hash functions which we call as
good correlation rubber / functions and
us so using the appropriate code you can
get the improvements for JM w 40 for 10
to 20 tea for one out of MOT and this
also brings back the issue of the GM w
come back because there have been some
recent results which have a show that JM
w I mean although it has been thought
that yeah outperforms jam w very easily
because because of latency issues and
stuff but but some some experimental
results and some more additional
optimizations have shown that you know
tmw can be competitive maybe even
outperform yeah thank you what is the
right value of it and it's so you so if
you put m equal scale you get somewhat
close but it will not be exact but so
gay lucky or something like that but but
when you're doing concrete values you
just have to choose the value of M so it
does not necessary at all the right
value of M for this value of N and K so
something like that so weird like for k
equals 1 28 we think we use some values
of N equals 94 k equals 1 28 we had to
use n equals 9 or some M equals 9 or
something that is there is no direct
correspondence bit but for the
asymptotic improvement like M equals K
or something should give you so you put
m equal scare you get an overlock a
directly but there is also this other
the log k shows up there and there's a
la blockade the so it's not it's not
very clean if you are not counting the
cost of the seed of these right so
because you know my pc dos equis paper
expensive if you increase m this
discounts the sea dog is right so that
the two in case the zero tease oh the
MLL is the main reduction to in case is
the same as I can be
to NK so there is still the 2k but n now
reduces you you just have to do lesser
number of OT instances on slightly
longer strings what we can potentially
hope what you have w to be better than
yahoo com traditional or
I think both I mean for example this
work you show that you know if if you
only need to do Otis on like one bit
Otis then you do not necessarily have so
in yahoo for example when the strings
when the when the circuit is small and
wide and you have a lot of inputs you
will do a lot of Ortiz and these votives
are on 128 bit strings so these are keys
right whereas whereas in GM w if you
want to do the same thing you just have
to do it is on one bit strings and for
example that is where you can infer a
apply our results and then you can get
like factor to factor full efficiency
provide directly the center's you yeah
so now you have to be now you have
encryptions your force architects for
every game they're big relative so even
if it's not a fairly precise also the
size of the circuit course if is a deep
circuit you have lots of ping-pong when
you're far away that it won't be good
the association of online offline page
MW can pre-purchase all their teeth
before you think what's unknown intended
yeah if it's too deep yellow to make the
rounds effective educator brings a
certain okay when you have a solution
where they fish yes
we gave me yeah once you pre-process
duties OT collection is just information
30 can you combine your technique with
our communications we was talking about
how to check on tour this new encoding
that's my business with what with the
transpose matrix personnel about it over
there the fact that you were using
random so he does so the random thing is
also are the additional optimizations
which I just did not elaborate upon but
that you can do that is just inside the
ot ot extension itself but the the
transfer paper Richard mentioned is
emphasized so roughly our students were
about three times
well yeah right so the cost of Yahoo is
that you have to encrypt the garble
table he and Jim wo with the hybrid
don't there's no garbled table yeah this
is a different work right so where you
do information to take Yau so this is
like short that the circuits you can
just do it information theoretically you
don't need encryptions of encryptions
and so so for every every three levels
you just need to do one OT so 11 level
of OTS so there you get like factor 3
improvement for example directly right
then concrete options when you run when
you have all this data what pushes don't
you for any function so that I think
that's gonna be a very long that's a
very good progress so let's tan catch it
again our time Erickson from post
University and he's gonna talk about me
Lego this is the condition from generous
I heard it's a good paper alright thank
you for the introduction so I'm to a
fredrickson this is a joint work with
Thomas pale yeah cops in years / boost
Nilson Peter Sebastian or halt and
Claudio orlandi so what I will be
talking about today is the mini Lego or
efficient secure two-party computation
from general assumptions so what I will
go through today is a little bit of an
introduction which would be quite short
since most of the stuff i will introduce
we have already heard at least once
today this morning then we'll go for
your fruit through a few tools we need
and then i will give an overview of the
legal Diggle construction and then give
a bit of details and i will end up with
some conclusion about practical
efficiency and future work
so first of all as we all know a secure
computation can be based on many
different things such as secret sharing
homomorphic of semi and fully
homomorphic carpal circuits and so on
some of these approaches are secure in
the passive settings are secure the
active setting and some can be made
secure in the active setting and I
apologize for all the papers I have
forgot to put up here on here so anyway
the setting of what I would be talking
about today is based on yahoo scalpel
circuit and the current use paradigm
professor lintel talked about earlier
today this would be used in combination
with XO homomorphic commitments to yield
a UC secure OT hybrid protocol for
secure two-party computation so first of
all a little little outline we already
talked about capital circuit so i will
quickly remind you what this again we
have to party functionality where each
party has some inputs with a bit and one
party or both party wish to learn the
output for simplicity we can assume that
just one party learns the output since
we have several result generalizing this
to the case where the other part should
lend the output so the function will be
work will be looking at will be working
on on bits and thus we can express it as
a boolean circuit which is a bunch of
wires and a bunch of gates the circuit
could then be garbled by having one
party in this case we can assume it's
Alice select random keys for each of the
wires where key represents either 0 or 1
and then she can gobble each of the
gates using these keys this will in the
end yield a complete garbled circuit and
it's possible in the end to associate
something we call the output decryption
table for the output wires such that the
person evaluating this carpal circuit
can translate the keys he learned from
the evaluation to some actual bits so
with this in mind the passively secure
protocol it's quite simple we have a one
party in this case Alice cobbler circuit
she sends this garbled circuit to bart
along with the keys corresponding to her
binary input for this circuit allison
Bob can then execute an oblivious
transfer you know where Bob inputs
bits for each of the of the wires for
the circuit and as inputs the keys in
such a manner the Bob will in the end
learned the keys in correspondence with
his binary input thus he will have a key
on each of the input wires for the
garbage circuit and he can evaluate it
all the way down and use the output
decryption table to learn the actual
output so this is only secure in the
passive case one very straightforward
attack is the fact that nothing makes
sure that Ellis actually gobbles a
circuit computing the functionality that
parties have agreed on si si good for
example gobbler circuit where if barb
first bit is zero it outputs garbage oh
if his first bit is one then it actually
computes the function so one way of
making this scheme secure is by using
the cotton tubes paradigm where which
basically means we do the passive well
in very broad terms means that we do the
passive protocol several times so in
this case we have a corrupted Alice
construct many couple circuits some of
them might be constructed correctly and
some of them might be constructive
wrongly wrongly meaning that they
compute a different function or they are
not possible to evaluate at all Alice
then commits to all of these grapple
circuits towards Bob Bob and Bob selects
a random challenge of selecting for
example half these garble circuits to be
verified with this challenge Alice opens
the scalpel circuits and Bob can then
check that the garbled circus are in
fact correctly constructed if that is
the case then he believes alice is a
nice person and continues with the
protocol in which Alice can send the
keys and correspondence with her binary
input to the remaining garble circuits
and again they can do oblivious transfer
in order for Bob to learn the keys in
correspondence with his input in the end
he can evaluate the remaining circuit
circuits and he takes the majority of
the output to be the actual outcome of
the computation so this is the overall
idea of achieving active security of the
house capital circuits using the cotton
tues paradigm
I'm abstract away a bunch of different
issues here because as Professor lentil
mentioned earlier I want to introduce
currant juice we also introduced a bunch
of new issues but such as this selective
bit attack consistency of input and so
on but this is just so I will not talk
about that this is just to give an
overall idea of the cotton shoes
paradigm of garble circuits so what can
we say about this well it's a it's
relatively simple we don't really
introduce any significant new
cryptographic primitives or anything
like that we use basically statistics to
make sure that what happens is is
correct at least on top of the security
of the passive protocol and it's also
quite fast also in particular since we
don't introduce a lot of new fancy stuff
unfortunately it's the speed of both in
practice and innocent Alex is quite bad
we get an increase in complexity of 0 s
ways it's a statistical security
parameter so we need to guard many
circuits in order to actually make sure
that this approach is secure now the
idea of legal uses it takes departure
and trying to optimize this which means
that we reduce the overhead from oh of
air from 0 of s 2 of s lock the circuit
sighs so this basically means the larger
the function we wish to compute the less
amount of capital gates do we actually
need to make alright so that was that
was a little bit overview two things
we're going to need before we we
actually show how to show the actual
legal approach is the idea of the free
XO which was also covered earlier today
so instead of having random keys on each
wire in the circuit the keys are
constrained the sero keys will be random
and the one keys will be defined to be
the 0 key X or the global difference
which we call Delta here this global
difference will be the same for each
garbled circuits from this it means that
if we encounter
in an xor gate in in the circuit the
output of that xor gate is then defined
to be the XO of the 20 keys entering the
gate so not all one so we will need some
kind of circular security here in the
same manner the one key of the output of
an XOR gate is defined to be the 0 key X
or Delta so this basically means once a
nap once Bob evaluates the garbled
circuit if he encounters an XOR gate he
simply takes the XOR the two keys he
have and and that ends up actually being
a the correct output in correspondence
with the XOR function which can be
checked by by just writing out the truth
table in the cases the other thing we're
going to need is Excel homomorphic
commitments so in an engine in general a
commitment scheme in a general
commitment scheme we have one party
Alice put a message into a box the box
is then locked with some sort of key the
boxes into ba-bop then they can do
whatever they want to do and at a later
point in time Alice sends the key to Bob
Bob can open the box and find the first
message so that's general commitments in
the case of X altima morphic commitments
we assume we have one just a single
commitment so Alice might put another
message into another box locks it with
another key sends this other box to Bob
then at a later point in time she
actually wants to open to the XOR of the
two messages m1 and m2 so it takes both
the keys dozen operation on them since
this to bop bop takes the boxes thus an
operation on them and uses the geese and
what comes out would then be the XO of
the message m1 and m2 so it's basically
what the name suggests its commitments
with a homomorphic property with respect
to the XO operation alright so that was
a little bit about yeah
how about the security yeah yeah yeah
yeah yeah so that that's just the
overall idea all right so with these
tools mind and I can introduce the idea
of the legal approach so instead of
having a let's go up on many couples
circuits we had her garden many gates in
particular it will all be engaged since
we have since we use the free XO
approach it means that we can also do
not and end and a not can give us an end
which is a universal gate so this is
sufficient so just assume we only do and
gate so far so Ellis makes many and
gates these gates well like in the
normal garbage circuit consists of a
capital computation table but it will
also consist on X or homomorphic
commitments of the zero keys of each
wiles in this gate this means that we
will have the gout for each gate will
have the garble computation table and we
will have an XO homomorphic commitment
to the left 0 key to the right 0 key
into the output 0 key and again as Alice
might be corrupted some of these gates
might be wrong so they might not compute
the ant functionality or they might not
compute at all what happens is then she
Alice sends a commitment to all the
garbled since all the garble gates the
computation tables and the commitments
to Bob Bob chooses a challenge so for
example he chooses half of these gates
to be a verified Alice opens and Bob
checks that they are in fact correctly
constructed if that is the case then he
thinks alice is a nice person and want
to continue to play with her it discards
the gates you have already opened and
thus have a bunch of garbled engaged
remaining along with extra homomorphic
commitments to the zero keys now what
then happens is is that instead of
constructing many couple circuits he
construct many fault-tolerant gates so
he selects some of these garbled gates
at
and them and puts together into a bucket
which can be viewed as a fault-tolerant
gate so this is basically the bucket is
more or less a subcircuit just computing
one gate where it takes the majority of
the outcome of the gates inside so this
basically means assuming only a minority
of the gates in the bucket I a badly
constructed the bucket will evaluate an
end gate correctly and since we do many
couple gates and we construct these
pockets at random except with very small
probability in fact MacLeish able
probability we will only have a minority
of bad gates in each bucket so Bob does
this for all the garble gates gates he
had left and ends up with a whole bunch
of these fault tolerant pockets he then
combines these pockets into a
fault-tolerant gobble circuit so he puts
these pockets together to form a gobble
circuit League upper circuit there is to
compute and then does some sort of
soldering in order to connect the wires
of each of these pockets finally he
completes another kind of bootstrapping
process for the input wires which we
called the input soldering to make sure
that each wire is actually has a key
from the beginning then he has a
fault-tolerant circuit consisting of
these buckets should he be mentioned
that XOR gates and not gates can be
injected into the wires here so in the
end they can do as in a normal gabble
circuit where Alice sends the keys and
correspondence with her input and Bob
can learn his keys through an oblivious
transfer thus at the end Bob will have
the keys for each of the we have one key
for each of the input input pocket or
each of the inputs for this capital
circuit and he can evaluate it shut down
and thus learn some output keys which
you will in this case sent to Alice so
in this case unlike the normal case we
assume alice is the person who actually
learns the output
functionality all right that's the
overall idea and that was very abstract
and so I just said we do some magic
soldering in order to make these pocket
and then magically solve those pockets
together so let me go in a little bit of
further detail in regards to that first
of all consider considered the case
where Bob makes a bucket so he has a
couple of of garble gates and he wants
to solve the least together into the
fault tolerant pocket so this means that
he won't actually know the keys you will
know the commitments to this year okies
in each pocket along with the gobble
computation table what he does is to
designate one of these pockets as the
head just assume the first one and then
what happens next is that we will use
the extra homomorphic property of the
commitments so he will ask alice to open
the XO of the 0 key of the left wire of
the head pocket and the 0 key of the
left wire of the second and of the third
pocket so this basically means the head
will have or act as sort of a pivot so
what he will learn here as I said is
it's the XOR of the left 0ki of the head
and XO with the left's yoki of each of
the independent each of the gates in
this pocket this will also be done for
the right keys and for the output keys
all right let me clean this up a little
bit it's getting a bit messy so let me
show you what Bob knows this is what he
knows he has the gobble computation
table for each of these free gates and
for each of the the wires of the the non
head gates in the bucket he has
associated that wire Saraki exhort with
the corresponding wire saraki of the
head of the pocket this is this is one
of those things it's it's not
technically that complicated but really
hard to just get your head around it I'm
trying to portray it as good as I can
but all right so just repeat I'll just
repeat it one more time each of the
remaining two buckets will have the sero
key corresponding with that gate exhort
with the serial
of the head of that bucket so this
basically means that the key is getting
into this pocket will and the keys
coming out of this pocket will actually
be the keys of the head gate in this
pocket so this means that if Bob is
evaluating the pocket what he will get
into it is either the left 0 key or the
left one key the right to hear the right
one key depending on which value is
actually supposed to get into it so this
means that the head he can just evaluate
directly he has one key on each of the
input wires to that hit no problem now
here comes the fun thing and this is why
we need the free XO approach to evaluate
the other gates in this pocket he takes
the keys he get into the pocket which
are the keys for the head gate and XO it
with the openings you know so this
basically means that the 0 key of each
of the wires in the head gate disappears
it exhausts out we have we will indeed
in both cases consider the left wire
here at the left 0 key of the head gate
and the left left yoki of the head gate
here that those two will disappear and
what will remain will be the left 0ki
this particular gate either alone or
exhort with Delta if what gets into the
bucket is a 1 it's supposed to be a one
key so basically it's it's just making
making the zero keys related to the head
disappear and then what we rains will be
the same semantic it will have the same
meaning its key but it will be based on
the sero key on each of the wire in the
remaining gates in the bucket and this
follows directly from from the free XO
approach so this means that in the end
here Bob will have a key for each of the
input wires to remain in gates in the
bucket and he can dust valuate them
regarding the output of each of these
gates the same approach follows we have
we have the 0 key for the head of the
bucket and the 0 key for the
to these gates open down here by Ellis
again he takes the output of this bucket
and the 0 key from the head would get X
or sorry and the 0 key from this bugger
will then get X or out what will remain
will be the sero key of the head perhaps
exhort with one if the output of that
gate was supposed to be a one so it's
basically masking with the serial keys
from the head and then making it
disappear in the end so this means if
all these gates have been constructed
correctly in the end we will have the
same key for each of these gates and
thus we can take the majority to be the
actual output of that pocket alright so
that was that was constructing a bucket
now we also need to put the buckets
together the principle is the same again
we have the output of the top pocket
here to be the 0 key of the head exit
with one if the output was 21 and
justice 0 ki if it was supposed to be a
0 then we have a new pocket and we wish
to solder the output of this top pocket
to the left wire of this bug in the same
man as before we ask alice to open the
XO of the the 0 key or the of the head
of the the left 0 key of the head of
this pocket down here exo's with the 0
key of the of the head of the of the of
the top pocket the 0 key of the output
of the top pocket x or south what
remains would be the 0 key of the other
of the bucket J and perhaps the eggs off
with Delta if it's supposed to be a 1
alright the final part is it's the input
soldering and this is a that's again the
idea is the same each of the inputs to
this fault-tolerant circuit will either
be a will either be given directly by it
Ellis or will be come as part of some
sort of OT what will we do then do is
that we will have the input to this is a
this input soldering being the left
left 0ki of the of the head here and
then what we do is as pop is to have Bob
ask alice to open the left 0ki of the
head except with the right 0ki so this
basically means now it has one key for
the left while he can take this XO with
this the left 0 ki x us out and what
will remain will be the right 0 key or
the right one key depending on whether
or not what he got in was 0 or 1 now he
can evaluate the head directly and since
aunt is the identity function 0 and 0 is
0 1 and 1 is 1 this will work directly
the rest of the soldering of that pocket
is just like before so that was that was
the overall idea and how how we actually
construct this altering of each of the
abdicates in the pocket I'll just give a
little conclusion so practical
efficiency well we get compared to the
general current use of garble circuit we
get better at synthetic complexity we
reduce the amount of garbage gates we
make with a factor log of the circuit
size however we need these extra
homomorphic commitments and many of
these eat for each of the of the garble
gates so this means that unless we
construct a humongous circuit it will
actually depend directly on the
efficiency of how we can do X or
homomorphic commitments so in the
original approach to Lego which is by
Nelson orlandi from 2009 in fact it
wasn't XO homomorphic commitments that
we use it with peterson commitments
which is additively homomorphic so in
that paper public keys operations were
used in the one we have here we actually
construct the XO homomorphic commitments
from an error-correcting code and
oblivious transfer which makes it
possible to base the extra homomorphic
commitments or non number theoretic
computations again generally
oblivious transfer is based on public
key and exponentiation and so on but as
we have heard a little about this
morning and it can be it's possible to
construct a bunch of these using what we
call the ode using the OT extension
which makes it which makes it actually
quite nice and quite inexpensive
assuming we need to do a lot of all teas
which is actually what we need in this
case and since since since we're
actually able to do EXO homomorphic
commitment and not just additively
commitments it means that this will work
with any free x or gabbling schemes so
point I'm commute can be used as along
with double row reduction and all those
optimizations finally a little bit about
future work it turns out that even
though we make these XO homomorphic
commitments based on just oblivious
transfer and error correcting they are
still the constants are still quite
large in fact it turns out to be around
effective 40 in these commitments which
is of course not that nice so future
work will include seeing if we can use a
better code if we can make if we can do
some way of actually making these
significantly smaller another
interesting thing to look at is smaller
replication factor in the buckets so
right now we are still in the we need a
majority of the gates to be good but as
recent research have have shown there's
a ways to do it at least with the
circuits where just one of the of the
gates or sorry one of the circuits are
correct so we'll also be interesting to
see if we can do that there and get some
optimization there so hopefully in the
end it will we can continue working on
it and hopefully in the end it will be
competitive with the general approach so
I'll just end up with a small table of
the different approaches for this yeah
and that's it thank you
yes thank you a few questions find out
how your algorithm is 62 in privacy is
it can you show the little justification
of how the adversary cannot fix or
different outputs together and get some
information because you're the same mass
you mean the free XO approach or what so
that's the free x approaches from 2008
and the it has been some future work
looking into the security orbit I cannot
remember the authors but there was
something that was a paper showing that
it is secure assuming circular
correlation a circular correlation
robustness but that's that I don't have
anything to do with that this is just
some previous work that that we use in
that manner will be more sorrowful
defense when they were first proposed
they were implemented
dresser and I'm cooking better food
again later on okay
yes whatever is good there one by
passion and cramer at least at least
what there's one by Shannon Kramer that
gives the demands we need unfortunately
we need to have some quite strict
demands on that code we need as it needs
to have the it needs to allow some
leakage of code words without giving
away what is actually encoded amongst
other things and it also needs to have a
relatively large randomization so this
is why it ends up actually being quite
quite large constant but we're currently
looking at at optimizing it and it seems
that it will be possible to do with just
a random random encoding using a random
matrix to encode as we will not directly
need to do decoding listening tour again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>