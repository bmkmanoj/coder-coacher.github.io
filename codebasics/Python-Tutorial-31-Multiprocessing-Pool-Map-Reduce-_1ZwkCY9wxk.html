<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Tutorial - 31. Multiprocessing Pool (Map Reduce) | Coder Coacher - Coaching Coders</title><meta content="Python Tutorial - 31. Multiprocessing Pool (Map Reduce) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/codebasics/">codebasics</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Tutorial - 31. Multiprocessing Pool (Map Reduce)</b></h2><h5 class="post__date">2016-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_1ZwkCY9wxk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello friends welcome to coal business
coding tutorial in this tutorial we are
going to learn about multi processing
pool here I have a program which is
calculating the square of all the
numbers in this array so I have this
array I am going through the array here
and then I'm calling this function which
is just a very simple function
calculating the square of the number and
I append the results and I'm printing
the results so if I run this program the
program works fine absolutely no issues
now let's look into internal details on
how Python will execute this program
using the CPU on your computer so let me
show you our diagram here here this big
yellow block is your CPU and it is
having four cores these cores are
nothing but processing units present on
your CPU or central processing unit
nowadays most of the computers comes
with multiple cores so it is very likely
you will have multiple cores you might
have two cores or four cores based on
the kind of configuration you have but
let's assume you have four cores here
when you execute that program the your
OS is going to select one of the course
and this core will execute the entire
program now the problem here is that you
have three other course sitting idle now
when you are running multiple programs
on your computer most likely they will
be doing some work but let's say if they
are not doing some work then they are
sitting idle ok now this program is
pretty simple you have fine numbers in
you're calculating square so it is not
very computationally intensive but if
you are doing heavy image processing or
heavy computation then giving all
workload to one core might not be a good
idea I mean if you can somehow paralyze
your work and divide this input
do this multiple cause it would be
better okay so I'm going to show you how
you could do it so let's say you have
input you have four course and somehow
if you can deploy your core on if you
can deploy your code on all the course
and then let's say if you can divide
your input between all this course so
here I have 1 2 3 4 5 so I just divided
the all the numbers between the course
so I have more numbers than the number
of course so this guy is getting two
numbers okay but essentially you are
dividing the work equally between all
this four units and let's say they
calculate the results and here are my
results and in the end you aggregate
those results back into one output
okay now difference between this
approach and the previous approach is
that here you are utilizing all the
course of course you have to do some
division of work and then aggregation
but you are utilizing all the processing
power that you have any computer okay
this is called parallel processing and
this process of dividing the numbers the
input between multiple course is called
map versus the process of aggregating
these results back is called reduce so
if someone talks about map and reduce
this is what it is it's not a rocket
science pretty simple concept map means
you divide work between multiple units
reduce means you aggregate those results
back into one common or single output
okay so let's do this exactly this thing
using multi processing pour okay so I'm
going to exit out of that presentation
and I'm going to import pool so from
multi processing import pool
and Here I am going to create an object
of poll class and I will say that the
method that you want to use is P dot map
when you do map it will divide the work
between multiple course okay
so the first argument is a function that
you want to execute which in our case is
f and the second argument is your array
input okay now this alone is going to
divide the work equally between all
available course on your CPU okay and
it's also gonna give you back the result
so see now my program is pretty simple P
dot map array and this function results
the aggregate result back when I run the
program I get the same output okay
although visually I don't see any
difference internally it has divided the
work equally between the course okay now
let me show you how it can speed up the
process so if I am going to measure the
performance here is not going to be very
different because the tasks that I'm
doing is quite simple so let me do some
some heavy lifting I'm just going to
make something up so for X in range 100
some plus equal to X cross X and some
I'm just I'm just making something a
pocket um and this goes back and I'm not
going to print result because it's going
to be too much so here okay so here let
me do this instead of the array let me
supply huge array with like less a
10,000 elements okay and just to make it
even more computational intensive I'm
going to increase the range over there
and I'm going to measure the performance
of this program so let me import time so
that I can measure the performance so t1
is equal to time so when you do this
it's going to take the current time and
at this point by the way when you do
pool you have to do pool dot close and P
dot join that way this will return only
if all the workers which you created
using this function are done exhibiting
the code okay now let me pin the so here
what I'm saying is pool toke how much
time did it take oh well pull took time
dot time so here I am again taking the
current time stamp and then subtracting
t1 so this way I get the time distance
between this line in this line so you
are measuring the performance of your
pool code okay and in the second section
of my code what I'm going to do is I'm
going to do this in a single loop so for
X in range same number so I'll just copy
paste and then I am going to I need to
aggregate the result okay
so result is this and result dot append
F dot X okay pretty straightforward
and then I will say print a serial
processing took so this is see the
processing time the time now I need to
take another time stamp here t2 okay
fairly straightforward this time is the
time between this line here and here so
I am measuring performance of this code
versus this code and I am comparing them
let's run it so you can see here that
pool is taking less time it took point
fifty one second which is like half
second and this took almost double which
is almost one second okay
you can see it and as you're processing
load increases let's say I add one zero
here as you're processing load increases
pool is gonna perform better and better
so pull took 2.83 and this guy has not
returned yet I will see how much time it
takes is going to take considerably long
time so you see nine point five second
versus two seconds so using pool will
speed up your processing time because as
I said you are dividing tasks your work
between all multiple units okay next
thing we want to talk about is pull has
an argument called process X so
processes if you just say processes
equal to let's say three okay
if you do that it's gonna create only
three processes at the same time so
again for the output you don't see any
result but internally at a time it will
create only three processes okay so that
was all about pool in Python I
hope you are having fun time learning
multi processing and multi-threading in
Python please don't forget to subscribe
to my channel and also remember to
listen to my Python multi-processing our
playlist ok thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>