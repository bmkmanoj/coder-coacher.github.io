<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Decorators Tutorial | Coder Coacher - Coaching Coders</title><meta content="Python Decorators Tutorial - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/codebasics/">codebasics</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Decorators Tutorial</b></h2><h5 class="post__date">2016-12-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nYDKH9fvlBY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">dear friends we are going to look at
decorators in Python today now when you
read about decorators online it sounds
like a complex concept but it's really
not that complex and the goal of this
tutorial is to explain decorators in a
very simple easy way ok so the way we
are going to start this tutorial is
first let's discuss what problem
decorators will try to solve right like
what is really the need of decorators
here I have two functions calculate
square and calculate cube and what these
functions are doing is for example let's
look at this function first this
function is taking an array of numbers
as an input it's just iterating through
the array and calculating the square of
that number and putting that into a
result calculate cube does the same
thing but instead of square it is
calculating a cube okay very very easy
functions and Here I am calling those
functions for a range of 1 to this
number now often you have a need of
measuring the performance of a function
and by performance I mean how much time
does every function take to execute and
in order to measure the timing you have
to use the time module I mean this is
one of the ways I usually like to do
that where I will take the start time so
what this will do is when function
execution it is at this point it will
take the start time and once you are
done you will take the end time and here
you will say calculate square talk how
much did it take so it takes
n- start in 2000 so this will give you a
result in seconds and i am multiplying
it by thousand just to produce a result
in millisecond so this will say okay it
took this many millisecond all right and
we do the same thing for this function
because you want to measure the
performance of both of these functions
okay okay and I am calling these
functions here down below okay pretty
straightforward when I run the program I
see the performance that the first
function took 14 milliseconds the second
one took 19 now the problem with this
code is that let's say you have a
complex software project when you have
returned 200 functions so in in order to
measure the performance of all those 200
functions you have to write the start
time end time the exactly same line of
code in every function now this is not
good you see like these lines are
getting repeated start and both of these
lines are getting repeated in every
function that you want to measure the
performance second problem is that there
is a logic in this function now that
logic is combined with the timing logic
okay so the main logic of this function
is to calculate square now you are
cluttering that logic with the timing
code and it makes code less readable
there has to be a better way of doing
this and that better way is basically
decorator so decorator allows you to
wrap your function in another function
so let me show you how you do that so
first I am going to remove this timing
code all right so this perlier timing
code which I am removing now and I want
to have a function which has just the
logic that that function is supposed to
do so this function looks now much clean
so in order to do our decorator first
you need to define the wrapper function
so I am going to call my wrapper
function time it and that wrapper
function will take function as an
argument now functions are first class
objects in Python what I mean by that is
you can pass function as an argument to
a function you can return function air
as a return value from another function
okay you will understand this as we
continue writing our code so in this
function I am going to define another
function okay and call it a wrapper so
notice that Python allows you to write
nested function so you can have one
function inside another function and
what this function is doing is it is
taking the positional arguments which is
your star arts and your keyword
arguments and then it will start the
timer here and then it will call the
function that was passed as an argument
so I'm going to call function here with
argument and keyword argument and then I
will measure the end time and in the end
you will say function dot underscore no
score name so this underscore underscore
name will return you the name of that
function okay and this function took how
much it took well and - start so this
piece of code is same as what we wrote
before you want to measure the time of
function in millisecond that's why you
are doing this okay and of course you
want to return the result
all right and what so here this is my
inner function okay
and here my function ends and at this
point I want to return this wrapper
function here so again I'm returning a
function from another function that's
why this function is called a
first-class object you can treat it just
like your normal variable you can return
it you can pass it as a function
argument and so on okay so let's let's
first run the program and I will give
you more details on on this time it
function okay so let's run it okay so it
looks like there is a problem oh yeah I
forgot to decorate it so I created this
timing function now what you need to do
is decorate these other functions okay
so the syntax is you have to say at so
before this function line just say at
and just say time it okay
so let's run this program now cool so
you can see that now it is saying
calculate square took this many
millisecond and calculate cube took this
many millisecond so you see the beauty
now that any function that you want to
measure performance off now once you
have defined this code you can just put
this tag at the beginning and it's going
to measure the performance so this is
really good it makes this code much more
readable and then all your timing code
is restricted into one function okay now
I'm going to show you how all of this
actually worked by debugging it I have
put a breakpoint here in this function
and in my py sham I will start my
debugging session okay so now in order
to go inside I will place f11 so when
you do this you notice that when it
called calculate square function it
it didn't it didn't go to here at the
first line of this function because it
realized that this function is decorated
it needs to call time it first because
time it is a wrapper so it went here and
from here you can just do f10 to go to
the next line
now here this funk is actually calculate
square so when you go inside that you
notice that now the flow is coming here
okay so it will go here then eventually
it will come to result okay you can see
that it calculated the result is here
and then when you press next you see it
came back here
f10 pan so again it is here and f10 okay
so you now kind of get an idea on how it
all worked
cool so again just to recapture the main
highlights decorator acts as a wrapper
to your original function and it and you
can do things like timing your function
or even logging certain lines at the
beginning and end of the function so
these are like some of the common use
cases of using decorators so I hope you
guys had a fun time learning decorators
and I hope that I have made it little
simple if you have any question please
don't hesitate to put it in the comments
box below thank you for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>