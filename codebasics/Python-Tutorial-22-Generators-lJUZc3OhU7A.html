<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Tutorial - 22. Generators | Coder Coacher - Coaching Coders</title><meta content="Python Tutorial - 22. Generators - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/codebasics/">codebasics</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Tutorial - 22. Generators</b></h2><h5 class="post__date">2016-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lJUZc3OhU7A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to coal basics coding
tutorial today's topic is generators in
Python and here is the list of items we
are covering in this video ok let's
begin with what is generator generating
is a simple way of creating an iterator
now if you don't know what I traitor is
then you can go and watch my last
episode on Ike laters in this video as
well we are going to cover the AI
traitor or real quick so let's say you
are defining a remote-control class
which when you say remote-control next
it gives you the next TV channel so in
order to do that you can use this yield
statement here so what I'm doing is
forced returning CNN then returning ESPN
so these are the list of channels that I
have on my TV and by calling this remote
control next I traitor I am basically
going through this channels one by one
now this yield statement sounds similar
to return but it's not exactly return
because the difference between return
and yield is that when you return the
function basically returns and it
destroys all its local variables and so
on vs here you will see in a moment that
it kind of preserves the state of last
execution so if I say I TR equal to
remote control C normally if I had
return statement here if this was return
CNN I TR will get CNN assigned to it but
here okay
mistake so it should be remote control
next so if I say idea here it is telling
me idea is a generator object so it is a
generator which is basically it's
creating an iterator for you when you
have I traitor the common property of I
traitor is you should be able to do next
on it so when you say next you get CNN
when you do when you do next again you
get ESPN this way when you call next it
returns the first yield then it
remembers that it was here last time so
when you call next second time it is
going to return ESPN this could be
useful if you have a long list of values
and you don't want to return them in one
shot because if you return them in one
shot it requires lot of memory and also
you have to process those values here in
this function versus with yield you can
produce your first result which is your
which is CNN in this case and you can
just immediately return it then you can
produce the next result result return it
so it has a benefit of saving memory as
well as getting a quick processing you
can also do this so for C in a remote
control next
prynt see our if you recall from i
trader episode you already learned that
that for loop works on generators so
here remote control necks is giving you
a generator and generator has an ability
to be compliant with the for loop so
that for loop can i trait over each of
these values okay our next thing we are
going to cover is a Fibonacci sequence
we are going to produce that using a
generator now before we go into details
let's see what a Fibonacci sequence is
real quick
our Fibonacci sequence is basically a
sequence of numbers where you basically
keep on adding initial two numbers to
get the third number so in this case the
initial two numbers is 0 1 so add 0 plus
1 is 1 1 plus 1 2 1 + 2 3 2 + 3 5 and so
on so this is call a Fibonacci sequence
and what you want to do here is produce
Fibonacci sequence using a generator so
we are going to write our generator
function let's call it fib and the first
two numbers in Fibonacci sequence are
always 0 and 1 so I just initialized a
and B to be 0 and 1 so a here is 0 B is
1 and I'm just going to have an infinite
loop here and on each iteration what you
do is you
healed first number okay and then your a
and B becomes a becomes B so in the
skins index a is now becoming b and b
will become a plus B right that's what
it is up and then what you're going to
do here is this is your main code so
here in this main code you will say for
F in fib
now notice what will happen if I just
keep on calling this for loop since
there is an infinite loop here it will
never terminate so I want to produce
Fibonacci sequence under certain limit
so here I would say if F greater than 30
then break I want to just see Fibonacci
or less I I want to see Fibonacci
numbers between 0 and 50 okay so all
right so let's do this
and then
print F alright let's quickly run this
excellent so you see here I got the
Fibonacci sequence 0 1 1 1 1 2 or 2 &amp;amp; 1
is 3 2 &amp;amp; 3 is 5 and so on and it
terminated when it the village is number
exceeded 50 because 31 34 and 21 is 55
so that's why it exceeded if you want to
print like numbers until 100 then you
get this so the way this works is we can
set up a breakpoint and see how this is
going so we're okay let's debug it using
this thing here and initially it will
come to this guy
let's see if I do f11 to go into that
okay so I am inside this function now I
will just keep on pressing this button
to go to next line as you see a zero
base one yield so when I do yield
so from yield yield is short of like
return so it came back here and when you
look at the value of f it is zero
good go to next statement and again you
do next or I would rather step into it
so when I step into it it remembers that
it executed this statement last time so
then it resumed legs execution from this
point so a was 0 B was 1 so the next
thing that's going to happen is it will
be 1 and B will be 1 and again I am
going to return e e so the value of a is
now 1 so when you so you see f is 1 now
okay and if you look at your pencil
one so if you don't mix next you see C 0
and 1 cor printed here so I will again
go inside this
and is now one and B's 2 is turning a
which is one
so if you just do f10 it will not if you
just do actin it will not go inside this
function if you want to go inside the
function then you have to do f11 all or
use this button okay so you kind of get
how this works right okay now the
generators are better compared to
class-based I traitors because you
noticed here is the missus terminate
execution here so because you notice
here is that we didn't need to implement
ITR or next methods if you recall from
my last video if you are writing a class
based hydrator then you have to write
next and ITR method here you don't need
to do that our second thing is you don't
need to raise top iteration because it
will do it automatically for you if I
open idle once again and let me show you
the same example just to kind of
highlight what I'm what I mean by it you
don't need to raise stop by iteration
so here IPR is remote control and
matched IPR so you see it's stop
iteration here it automatically raises
it for you you didn't raise it here
right so these are the benefits of
generators ah so that's about it and
thank you very much for watching this
video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>