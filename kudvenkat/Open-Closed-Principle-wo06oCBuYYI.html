<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Open Closed Principle | Coder Coacher - Coaching Coders</title><meta content="Open Closed Principle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Open Closed Principle</b></h2><h5 class="post__date">2018-01-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wo06oCBuYYI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome back this is part
4 of the solid design principles
tutorial in this session we will discuss
open closed principle implementation
guidelines of open closed principle and
will implement this principle with a
simple example please refer to the
previous parts of the tutorial before
proceeding in the first session of solid
principles introduction we have
understood that o in the solid is
acronym for open closed principle which
is also known as OC p and the
object-oriented programming the open
closed principle states that software
entities such as classes modules
functions etcetera should be open for
extension but closed for modification
which means any new functionality should
be implemented by adding new classes
attributes and methods instead of
changing the current ones or existing
ones
Bertrand Mayer is generally credited for
having originated the term open closed
principle and this principle is
considered by Bob Martin as the most
important principle of object-oriented
design let's now take a look at the
implementation guidelines of this
principle the simplest way to apply open
closed principle is to implement the new
functionality on new derive sub classes
that inherit the original class
implementation another ways to allow
client to access the original class with
an abstract interface so at any given
point of time when there is a
requirement change instead of touching
the existing functionality it is always
suggested to create new classes and
leave the original implementation
untouched now you may be wondering why
we need to follow the open-closed
principle let's approach this argument
with a counter stating that what if I do
not follow open-closed principle during
a requirement enhancement in the
development process he
in that case we end up with the
following disadvantages if a class or a
function always allows the addition of
new logic as a developer we end up
testing the entire functionality along
with the requirement also as a developer
we need to ensure to communicate the
scope of changes to the quality
assurance team in advance so that they
can gear up for enhancer regression
testing along with the feature testing
obviously this is a costly process to
adapt for any organization not following
the open Crozier principle breaks the
single responsibility principle as well
since the Klan as a function might end
up doing multiple tasks from this we can
state that both single responsibility
and open closed principles are highly
dependent on each other
also if the changes are implemented on
the same class maintenance of the class
becomes difficult since the code of the
class increases by thousands of
unorganized lines I hope that these
counter facts helps in understanding on
why we need to follow the open closed
principle let's now switch to visual
studio and bring up a console
application to demonstrate how we can
implement open closed principle to save
some time I have already created a
console application let's take an
example requirement which states that we
need to compute bolus of an employee in
a typical scenario as a developer we
tend to create an employee class with ID
and name as the properties of the
employee and then we tend to create a
method to compute the bonus of an
employee this code works great and we
will be able to see the output in the
console once we run this application
let's run this application notice that
the employee John has been awarded a
bonus of 10%
let's stop this application let's say
now there is an enhancement or a new
requirement to differentiate bonus for
permanent and contract employees in a
typical scenario we tend to
modify the class by adding an employee
dye property and enhance the current
method to account for the employee type
while computing the bonus let's see how
we need to achieve that requirement
let's create a new property public
string employee type and then let's add
this employee type in the constructor
string employee type and assign this
value with this dot employee type equal
to employee type while calculating the
bonus we need to verify if the given
employee is a permanent or contract
let's say if this dot employee type
equal to permanent the bonus would be
10% else the bonus would be 5% which is
applicable for the contract employees
let's switch to the main program and do
the necessary changes over there look at
that it's already throwing an error to
pass the employee type so let's pass
permanent as the employee type let's
also create a new employee called jason
genius named jason with employee ID 2
and who is a temporary employee
let's also print the employee bonus of
Jason as well let's change the employees
on to employee Jason and let's calculate
the employee Jason bonus with a
different salary let's run this
application notice that the bonus of
John and Jason are computed based on the
requirement as a developer we are happy
as the code is working as expected but
remember we have changed the method to
support the new requirement
further if you need to add more
requirements in future we end up
enhancing the same method to support new
requirements hence we can say that this
class is not closer for modification and
we end up with all those issues that we
discussed in the beginning of this
session for not following the open
closure principle now if you are
wondering how to address this issue it's
very simple let's see how we can achieve
that the first thing to change is to
make the employee class as an abstract
class and leave the implementation of
the bonus to the derived classes this
helps in extending the class for further
enhancements without touching the base
class please note that depending on the
situation we need to opt for an
interface or an abstract class in this
situation I am choosing an abstract
class which fits the requirement let's
change this class to abstract class
abstract class employee
let's also remove this employee type
from the constructor as well and let's
make this calculate bonus as an abstract
method abstract decimal and let's remove
this implementation and move this
implementation to the derived classes
notice that we have got a structure of
an abstract base class so as per the
requirement we need to create a
permanent employee and calculated his
bonus let's see how we can do that let's
create public class permanent employee
and let's inherit this abstract employee
class let's fix these issues by
implementing the abstract class in this
situation we need to return the bonus of
permanent employee which is salary dot
10% of it which will be
hot one let's also create a constructor
for this permanent employee
notice that we have created two
constructor and the second one consists
of input parameter and we are assigning
those values using the base class let's
switch to the main program and do the
necessary changes instead of creating a
new employee we will create a permanent
employee class in this situation for
Jason it will be a temporary employee
class let's knock off this employee type
let's run this application notice that
the bonus of employee John and Jason
remained unchanged also we can see that
the employee class is now open for
extension and closed for modification
adhering to the open closure principle I
believe now you have a good idea on
implementing the open closer principle
in the next session we will focus on
Liskov substitution principle thank you
for listening and have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>