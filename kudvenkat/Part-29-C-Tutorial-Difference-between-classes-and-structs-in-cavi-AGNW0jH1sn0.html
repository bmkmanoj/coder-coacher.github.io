<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 29 - C# Tutorial - Difference between classes and structs in c#.avi | Coder Coacher - Coaching Coders</title><meta content="Part 29 - C# Tutorial - Difference between classes and structs in c#.avi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 29 - C# Tutorial - Difference between classes and structs in c#.avi</b></h2><h5 class="post__date">2012-06-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AGNW0jH1sn0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to presume technologies I
am venket this is part 29 in this
session we'll be talking about the
differences between classes and
structures in part 28 of this video
series we have understood that
structures very much similar to classes
we use trucky were to create a structure
whereas to create a class we use the
class keyword just like classes
structures can have fields properties
constructors and methods but however
there are several differences within
classes and structures which we will be
exploring in this session now a
structure is a value type whereas a
class is a reference type okay whatever
differences are there between a value
type and a reference type all those
differences are also applicable to a
structure and a class okay we haven't
spoken about all the different types of
value types and reference types that are
available in dotnet so I thought we will
be talking about the differences between
you know value types and reference types
at a later stage but since we know that
a structure is a value type that has a
class as a reference type I thought this
is the right time to actually talk about
the differences between value types and
reference types okay though we will be
talking about the specific value types
and reference types in a later session
for example there are several value
types within dotnet examples include the
built-in data types like end fluid
boolean etc structures or value types
and enums which we haven't spoken about
those value types okay similarly if we
come to reference types examples include
classes we have spoken about classes in
the last session and other examples
include interfaces delegates etc again
we haven't spoken about interfaces and
delegates which we'll be talking about
in a later session so structures being
value type they are stood on the stack
whereas classes are stored on the heap
so what do we mean by the stack and heap
now when we run a program in dotnet you
know the variables and objects that you
use within that program are actually
created in the memory and they are there
in the memory
program executes so the physical memory
of the computer is logically divided by
dotnet runtime into something called a
stack and the heap so if you look at the
slide let's say for example if I have a
simple program you know here you can see
a simple program I have a simple
customer class which has just gone to
properties ID and name let's say I'm
going to write a very simple program
here in the I is equal to 10 let's say
if I is equal to 10 let's say int J is
equal to 20 and I want to create a
customer object new customer and let's
say C 1 dot ID is equal to 1 2 1 0 1 C 1
dot name is equal to mark ok this is a
very simple C char program you know just
to demonstrate how these variables you
know the integer variable and customer
object gets created in the memory so now
what happens is we know that integer you
know structure value types okay actually
if you look at this end when I hover my
mouse over that you can see that this
end is actually a structure system dot
in 32 then what is this end it is
nothing but a keyword or an ally as for
system Lord in 32 structure it's just
another name and this is to give us the
language specific syntax actually
instead of saying end you can also say
system dot int 32 this is perfectly fine
okay but we are used to other
programming languages like C C++ where
we just say end so int end is just an
ally as for the structure system dot n
32 so you can either say system version
32 or just end the main one and the same
okay so since this I and J are actually
integers and their structures their
value types so how they get stored in
the memory is like
you know value types stool the values on
the stack where they are declared but
whereas on the other hand we know that
customer is actually a class and we know
that a class is a reference type so for
a reference type you know you have two
things one is the reference variable
here c1 is a reference variable it's not
an object by itself and then the object
itself is a customer object so what
happens when you say customers c1 is
equal to new customer and then c1 dode
ID is equal to 1 0 1 c1 that name is
equal to mark what's happening here is
the c1 object reference variable gets
created on the stack and the actual
object is created on the heap when those
fields - in the respect to values so
when we talk about an object that there
are two things involved one is the
object reference variable and the other
one is the object itself so objects are
different from object reference variable
they are not the same object reference
variables in this case c1 is just a
pointer to an object in the memory on
the heap rather so object reference
variables are stored on the stack
whereas the objects themselves are
stored on the heap okay so let's go back
to the differences between you know
classes and structures so structures are
stored on the stack
whereas classes are stored on the heap
value types hold the value in memory
where they are declared
but reference types hold the reference
to an object in the memory we've just
seen that value types you know I and J
are value types they hold the value
where they are declared
but for reference type the reference
variables are stored on the stack but
the object itself is tooled on the hape
alright value types are destroyed
immediately after the scope is lost
whereas for reference types only the
reference variable is destroyed of the
scope is after the scope is lost
the object is later destroyed by garbage
collector we'll be talking about garbage
collector and garbage collection in a
later session but let's understand this
point what happens to the variables and
objects that we are creating now if you
look at this program the scope of this I
variable
is the entire this main method you know
this variable has to be aware be
available you know until the run time
complete executing all these lines okay
but whereas this variable needs to be
available only within this F block okay
which means this J variable will be
destroyed as soon as the runtime
finishes executing this line okay let's
say for example if I have another code
of line here console dot write line
maybe hello okay so what happens is this
J variable is destroyed for example when
when we run this program what's going to
happen is in the memory you know
I is created which is initialized to ten
J is created which is initialized to
twenty customer object c1 is created an
object is stored on the heap okay so all
these are created in memory when this
code is running okay so now I will live
longer in the start longer in the memory
than J because the scope of J is only
within this if block as soon as the
control reaches you know this line here
then it it removes this J from the
memory but whereas I will still be there
so value types are immediately destroyed
as soon as this group is lost okay when
the runtime comes you know execute this
line even I is destroyed but what
happens to customer object you know when
we talk about reference types there are
two things object reference variable and
the object itself for this customer c1
object reference variable there is an
object on the heap so if you look at the
scope of this reference variable it is
with within this if block so in the
runtime X finishes executing this line
the reference variable scope goes out of
scope so this reference variable goes
out of scope so what's going to happen
is this reference variable get destroyed
okay this will be removed from the
memory but the object will still be
there on the heat okay so when will this
object be destroyed it will be destroyed
when the garbage collector
runs behind the scenes and it sees that
it doesn't have any point to do it and
it considers this as the garbage and
removes it from the heat however we'll
be talking about garbage collection in
detail in a later session so remember
that the the value types okay are
destroyed immediately after the scoop is
lost whereas for the reference types
there are two things object reference
variable and no objects for reference
types only the object reference
variables are destroyed immediately
after this group is lost but no objects
remain in memory until their garbage
collected okay said so that's one very
important difference between a value
type and a reference type so let's go
back to the other differences so value
types are destroyed immediately after
the scope is lost
whereas for reference types only the
reference variable is destroyed of this
cluster the scope is lost but the object
is later destroyed by the garbage
collector when you copy a struct into
another struct a new copy of that truck
gets created and modifications on one
struct will not affect the values
contained by the other struct
this is another important difference
between value types and reference types
what will happen when you copy a value
type and what will happen when you copy
a reference type let's look at that
example so if you look at this one let's
say for example let's get rid of all
this now let's say I have into AI is
equal to 10 and int J is equal to I so
at this point what's going to happen is
in the memory okay it's going to create
two variables I and J since I and J are
structures because they're integers okay
they're created on the stack so I is
initialized to 10 J is also initialized
to stand and we get two different
variables so we are copying this
structure into this one so what's going
to happen for J a new copy is created of
type integer and that value is copied
over so if you look at what happens in
the memory this is what will happen it
will create a variable I is equal to 10
and J is equal to 10 okay but now the
say I increment J is equal to J plus 1
so we are incrementing the value of J by
one so what will happen to J that will
become 11 and then if I print the values
so console dot write line and we'll say
you know I is equal to whatever is the
value of Phi and J is equal to whatever
is the value of J so I comma J so now if
I go ahead and run this program what's
going to happen I rally will be 10 and J
value will be 11 so operations on J
modification to the value of J will not
affect the value contained by I because
why when you copy value types okay you
get a copy of that object
so obviously operations on one variable
operations on one variable here and here
J you know will not affect the value
contained by Y because they are two
different copies okay so obviously when
I run this program I value will still be
10 whereas J value will be 11 but on the
other hand let's go ahead and see what
happens when we copy a reference type
you know a class is a reference type so
I'm going to create a customer object
customer c 1 is equal to new customer
and then we are going to initialize the
customer object ID to 1 0 1 and customer
name maybe to mark
okay so now what I'm going to do I'm
going to create a customer to object and
to this one I am going to copy c1 so
what's going to happen just like how we
have copied I into J we are copying C 1
into C 2 here these are value types you
know Jay and I are value types that are
C 1 and C 2 are reference types okay
so when I copy a reference type into
another reference type okay so what's
going to happen is this is what is going
to happen it will not create a copy of
the object it will only create a copy of
the reference variable so we get two
reference variables C 1 and C 2 and both
of them actually points to the same
object so obviously now if I make
changes to these values either by this
variable you know by C 1 or by C 2
operations on this variable will affect
the values contained by this similarly
operations on C 2 will affect the values
contained by C 1 let's see what we mean
by that
okay now C 1 that ID is 1 0 1 C 1 dot
name is equal C 1 dot name is Mark so
obviously both now C 1 and C 2 are
pointing to the same object so when you
say a they'll see one dot ID or C 2 dot
id8 will be 1 0 1 similarly see when
that name or C 2 dot name will be mark
but on the other hand let's say when I
say C 2 dot name is equal to Mary now if
I go ahead and print so console dot
write line maybe C 1 dot name is equal
to whatever and C 1 and similarly C 2
dot name is equal to whatever in C 2
so see one dot name comma C - dot name
so now we are changing the value of the
object you know we are changing this
value from mark to Mary using this
reference variable so what's going to
happen this mark will be overwritten
with Mary now if I say C - dot name
obviously it will be Mary but what if I
say c1 dot name it will still be Mary
why because these two reference
variables are pointing to the same
object so if we go ahead and run this c1
and c2 names both of them will be Mary
but whereas in the you know case of inj
they are different why because when you
copy value types you get copies but when
you copy reference types
you only get a copy of the reference
variable both of them pointing to the
same object on the heap
that's why operations on one of the
variables will affect values kind
contained by another reference variable
okay so that's another very important
difference between a value type and a
reference type and obviously between a
structure and a class as well because
structure this value type and the class
is a reference type okay so let's look
at the other differences another
difference structures can't have
destructors but a class but classes can
have distractors so structures can't
have destructors but a class can have
destructors okay we know that a class
can have destructor so this is a public
customer class so how do we have the
destructor destructors will have the
same name as that of your class but with
a till in front of them so my class has
a destructor if it will then build this
okay constructors cannot have access
modifiers so if I go ahead and build
this my class will build successfully
because classes can have destructors but
on the other hand if this is a structure
structures can't have destructors so if
you go ahead and build this we will get
only class and errors stating only class
types can contain distractors so that's
nm and
the important difference structures
can't have destructors but classes can
have destructors another thing another
difference in terms of constructors
structures can have parameter raised
constructors but they can't have
explicit parameter less constructor
whereas a class can let's look at an
example okay so this is a class public
class customer I can say okay I need a
constructor public customer this doesn't
take any parameters if we go ahead and
build this it will successfully build
why a class can have an explicit
parameter less constructor okay but
whereas a structure can't have explicit
parameter less constructor so this is a
constructor but let's make this a
structure just with the struct keyword
and we know that structure cannot have
parameter less constructor so if we
wouldn't build that we will get an error
structures cannot contain explicit
parameter less constructors so that's
another difference in terms of
constructors and destructors for
structures okay and it actually makes
sense because a structure doesn't have
the concept of object reference variable
and objects that's why they don't need
to have a parameter less constructor and
a destructor but whereas a class need to
have them okay
structures can't inherit from another
class whereas a class can okay
structures doesn't support class
inheritance but boot structures and
classes can inherit from an interface so
structures do not support implementation
inheritance but they do support
interface inheritance but various
classes of would move implementation and
interface inheritance okay and examples
of structures in the.net framework we
have already seen in 32 system content
32 system double which are actually
structures but the inter keyword double
keyword you know that we see in the
seizure programs they are actually
elias's you know to be structures just
to give us you know a flavor of the
language you know a programming language
kind of a syntax
all right another other I mean there are
two things to keep in mind a Class A
distract cannot inherit from another
struct meaning a structure cannot act as
a base structure for another structure
or a class because structures are field
types what do we mean by field types for
example if we mark a Class A field let's
say this is sealed class public class
customer and I'm saying this is a sealed
it class now if you market class as
sealed let's build this so build
solution on the status power you can see
will succeeded the only difference is we
mark this class as sealed now when you
market when you market class as sealed
now you cannot use the class as a base
class for any other for any other class
now what I'm trying to do I'm trying to
use you know I'm trying to make this
program class and hit it from customer
class now what's going to happen if I go
ahead and build this it will give an
error program cannot derived from sealed
type customer so this program class
cannot derive from that but on the other
hand if I remove that and go ahead and
build a solution it will successfully
build so remember you use seal the key
word to prevent your classes from being
inherited by another class we use the
sealed keyword in fact that's a common
interview question that that they will
generally ask you how do you prevent
your class from being inherited by
another class or what is the
significance of the sealed keyword okay
and structures are inherently sealed
types so that's why they cannot act as a
parent type for a class or for another
structure okay all right so we have seen
these differences so here you can find
some additional resources for asp.net
and C sharp interview questions that's
it for today thank you for listening
have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>