<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bridge Design Pattern | Coder Coacher - Coaching Coders</title><meta content="Bridge Design Pattern - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bridge Design Pattern</b></h2><h5 class="post__date">2018-01-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AvszFRYvvt0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome back this is
party a Dean of the design patterns
tutorial in this session we will discuss
what is bridge design pattern
implementation guidelines of bridge
design pattern and we'll take a look at
a simple example to implement this
pattern please refer to the previous
parts of the tutorial before proceeding
as per the Gang of Four definition the
bridge design pattern decouples an
abstraction from its implementation so
that two can vary independently which
means the pattern is used to separate an
abstraction from its implementation so
that both can be modified independently
this pattern involves an interface which
acts as a bridge between the abstraction
class and implementer classes by
decoupling an abstraction with bridge
design pattern both type of classes can
be modified without affecting each other
the bridge design pattern is part of the
structural design patterns as the name
suggests it acts as intermediary between
two components let's now take a look at
the implementation guidelines of the
bridge design pattern we need to choose
bridge design pattern when we want to
avoid a permanent binding between an
abstraction and its implementation and
when we need both the abstraction and
their implementation should be
extensible by sub classing and when the
changes in the implementation of an
abstraction should have no impact on
their clients that is their code should
not have to be recompiled and we choose
this pattern when we want to share an
implementation among multiple objects
and last but not the least we want to
hide the implementation of an
abstraction completely from clients
let's now take a look at the
representation diagram of bridge design
pattern bridge design pattern consists
of abstraction refined abstraction
implementer and concrete implementer the
abstraction defines abstractions
interface and
find abstraction extends the interface
defined by the abstraction abstraction
also maintains a reference to an object
of type implementer and the implementer
defines the interface for implementation
classes the concrete implementer
implements the implementer interfaces
and define sets concrete implementation
with all this theory you might be
wondering that this is a very
complicated design pattern and I would
say that it is certainly not to make it
simple to understand let's take an
example and see why we need to convert
that example to implement bridge design
pattern now let's assume that we need to
draw different shapes such as triangle n
square and fill them with different
colors our typical approach should be to
create an interface called shape and
implement it to triangle n square let's
say now we want to fill them with blue
and green colors as a typical programmer
we take the next step of creating
different classes of triangle and square
with colors now if we need to fill them
with red and blue color we create red
rectangle red triangle blue triangle and
Blue Square and red Square and etc this
approach works fine however it
complicates the extension as things are
tightly coupled here and we would want
to decouple the abstraction with the
implementation let's see how we can
represent this using bridge pattern
implementation now notice that the shape
has been moved to abstraction and we
have a refined abstraction of triangle
and square associated with this we have
an interface called color and its
implementation of concrete classes which
are red and blue this is a familiar
example which is floating around the
internet in various articles however
this example simplifies to
the bridge design pattern with the
representation diagram which we
discussed earlier now let's switch to
visual studio and see how we can achieve
this using another simple example to
save some time I have already created a
console application let's assume that
our requirement is to process payment of
a customer who has either opted an
option of credit card or net banking
payment during his purchase process
now when I say purchase process I'm sure
that all of you are familiar with the
purchase on an e-commerce website where
we choose the product and add the
product to Shopping Cart and proceed
with the payment typically we are
provided with multiple payment options
such as net banking credit card payment
and many more for this example let's say
we have credit card and net banking as
the payment options are the payment
choices to proceed with payment let's
start building our code with a simple
interface which is the implementer in
our scenario and it's call it as I
payment system the I payment system will
have a method to process the payment and
in order to process the payment there
will be many payment gateways let's
choose some of the payment gateways as
Citibank payment gateway and IDBI
payment gateway let's create two more
classes right click and new item and
choose a class and call it as Citibank
City payment system
let's implement the interface I payment
system over here now to make it simple I
have copied the things from my notepad
if you notice City payment system is
inheriting the I payment system and
processing the payment to simplify the
thing we are just returning the console
dot write line and printing that this
process payment is using Citibank
gateway for given payment system
similarly let's also create another
class and name it as IDBI payment system
right click on this project
add new item choose a class and name
this class as IDBI payments system let
me replace this code with the one which
I have in my notepad notice that I am
implementing the I payment system and
doing the similar step what have done
with the Citibank payment system except
that instead of using I City Bank
gateway we are just printing it as using
IDBI payment gateway for the given
pavement system now we have created
implementer interface as well as
concrete implementers for the given
interface though we are processing
payments using different payment
gateways a point to note here is that
for the end customer the only thing that
matters is whether it's a net banking or
credit card or debit card payment which
means we you we need to use this payment
gateways and bridge them with net
banking or credit debit card payment I
hope now you are able to envision why we
need bridge design pattern here to
summarize we have payment gateways that
are internal representation to the
system and net banking or credit debit
card payments which are the higher
abstraction exposed to the end customers
or the clients and to maintain this
bridge pattern place a significant role
to connect these things in runtime
now let's proceed and create those
classes of abstraction and refined
abstraction implementation which are our
credit card payment and net banking
payment let's right-click on this
project and new item choose the class
and name this class as payment and this
will be our abstract class to make it
faster let me copy the code from my
notepad now this abstract class will
have an abstract method called make
payment let's create those refined
abstractions to implement this make
payment let's create a class add new
item choose a class and name this class
as card payment card payment is the
refined abstraction of the abstraction
class to make it faster let me copy the
code from my notepad notice that the
card payment is implementing the
abstraction class payment let's create
another class and add add new item name
the class's net banking payment to make
it faster let me also copy the net
banking payment implementation from my
notepad and notice that we are also
inheriting the payment abstraction and
implementing the make payment method now
that we have created this refined
abstractions and implemented the
abstract methods for our convenience and
for our representation purpose I have
moved these interfaces and classes to
the corresponding folder structure of
abstraction refined abstraction
implementer and concrete implementer
folders
however it's not mandatory to follow
this structure our next step is to
invoke the corresponding payment
gateways in runtime from this make
payment method in order to achieve that
we need to bridge the high payment
system
based on the representation diagram the
attraction class which is the payment
nor case will hold the reference to the
I payment interface and these refined
abstractions which are net banking
payment and card payment will invoke the
interface method of the I payment which
is processed payment let's go ahead and
implement that let's go to the
definition of payment and let's create a
reference to the I payment system public
I payment system and let's call it as
underscore I payment system let's now
switch back to the net banking payment
and use the underscore I payment system
and invoke the process payment let's
pass the string as net banking payment
let's also do the same thing with card
payment let's just copy this stuff and
let's switch to the card payment and
process the payment and call it as pass
the input string gas card payment notice
that we are able to bridge the interface
and decouple the abstraction
implementations let's see how we can use
them in the client which is the main
program in our case let's switch to the
main program let's say a customer is
doing the payment using a card payment
so let's create payment and let's call
it as an order equal to new card payment
now depending on the payment gateways
availability we are going to process it
through respect to payment gateways
let's say in this case we have Citibank
payment gateway available then let's say
order dot I payment system which will be
decided in run time equal to new city
payment system that means Citibank
payment gateway is available highly
available at this moment so the payment
will be processed through the Citibank
payment gateway and the customer will be
making the payment through this payment
gateway hence we will invoke order dot
make payment the make payment internally
will assign the city payment system and
will invoke the Citibank payment gateway
let's run this application and see the
output
notice that the application says it's
using Citibank payment gateway for card
payment similarly we can assign the IDBI
payment system based on the availability
now let's say we have IDBI system
available in runtime
so the simple way to decouple is to
create a new IDBI payment system and
let's run this application again
notice that we have ID be a payment
gateway for the card payment now let's
do the other way and switch the order to
use the net banking payment system so
let's say payment order order equal to
new net banking payment the I payment
system could be still be used as
Citibank payment gateway in this
scenario let's run this application and
see the output
look at that we are using the Citibank
payment gateway for net banking payment
instead of card payment
let's stop this application I hope now
you are familiar on how we have
decoupled the abstraction from its
implementation with this we have
successfully implemented the bridge
design pattern thank you for listening
and have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>