<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 33   OneWay Message Exchange Pattern in WCF | Coder Coacher - Coaching Coders</title><meta content="Part 33   OneWay Message Exchange Pattern in WCF - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 33   OneWay Message Exchange Pattern in WCF</b></h2><h5 class="post__date">2014-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6ZyZum252Z4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is part 33 of wucf video series in
this video we'll discuss one-way message
exchange pattern and WC app this is
continuation to part 32 so please watch
for 32 before proceeding in a request to
apply pattern the client sends a message
to the WCF service and then waits for
the reply message even if the service
operations return type is worried in
case of one-way operation only one
message is exchanged between the client
and the service the client makes a call
to the service method but does not wait
for a response message so in short the
receiver of the message does not send a
reply message nor does the sender of the
message expects one and two make an
operation one way all we do is we set
this is one way parameter to true let's
look at an example now we'll be working
with the same example that we worked
with in the previous session so here
we've got a service contract and these
two operations in a follow request reply
message exchange pattern now to speed
things up here within the notepad I have
two operation contracts that are one-way
so let's paste them here so one-way
operation one-way operation which is
going to throw an exception now let's
flip to the service implementation file
and then implement both of those
operation contracts and to do that
simply click on the service and then
you'll get an option to implement
interface I sample service so these
stubs to implement those operations
should be generated so n one-way
operation what are we going to do we are
simply going to make the thread sleep
for two seconds and then we'll return
the control after that and what is this
one-way operation going to do it's going
to throw and not implement it exception
so straightforward implementation there
let's go ahead and run the host so the
host is running now let's flip to the
Windows client application and let's
update first this service reference
so that the new operation contracts will
become available for the client and if
you look at the vendors form I have
already placed two buttons here one way
operation and one way operation throws
exception so basically this is going to
call our one way operation and this is
going to call the other operation which
is going to throw the exception so let's
double click on the button to generate
the click event handler and to speed
things up I have the client code here so
let me copy and paste that within this
button click event handler so what are
we doing here it's again straightforward
so we are adding you know this string
saying one-way operation started at the
date and time at which the operation has
started to the listbox and then we are
in working the one-way operation and
then we are again appending this string
one-way operation completed to the
listbox and then finally an empty string
so straightforward implementation there
and let's do one more thing here you
know just before we invoke the one-way
operation let's actually disable the
button button one-way operation dot
enable equals false and then immediately
we will enable it okay all right and
similarly let's click on the other click
event button control to generate a click
event handler and then copy and paste
this client code
again this is straightforward code very
much similar to you know the code that
we have in this click event handler and
all we are doing here is you know we are
invoking the one-way operation that's
going to throw an exception okay cool
so let's go ahead and run the client
application now if you recollect from
the previous session you know in a
request to apply pattern what's going to
happen the client makes a call to the
service and then the client is blocked
or the client is waiting for the
response to come back from this service
okay so makes a call and wait for the
response so there's a request and reply
so that's why when we click this button
look at that it's disabled and blocked
until a response is sent back okay and
again if there if at all if there is an
exception in request reply message
exchange pattern that exception gets
reported right away okay and if the
server the communication channel is
faulted you know we get that error again
right away saying that the communication
object is in faulted state because you
know the messages are exchanged in both
directions so there's a request and a
reply now let's look at one-way
operation let's run this Windows client
once more and then look at this when we
click one-way operation what's going to
happen it's going to call that one-way
operation so here between the client and
the WCF service there's only one message
exchange so the client is going to send
the message to the WCF service okay and
then you know the client will simply
continue processing so what happens when
we invoke that one-way operation you
know the call is going to get to the WCF
service and then if the WCF service is
busy processing other requests that call
will get queued at the WCF service
waiting for it to be processed in a
meantime as soon as that call gets
queued at the WCF service the client is
unblocked and it can continue processing
with whatever it has been doing so the
client is not blocked in on a one-way
operation it simply fires the operation
once the operation is queued
you know the client can continue doing
whatever it has been doing before okay
so look at that that's why when we click
this button look at that one-way
operation started that's really no time
difference let's click it once again
look at that
you know 23 seconds and 23 seconds it's
happening at the same time but if you
look at the one-way operation itself you
know that one-way operation should at
least take with an hour WC of service
the one-way operation should at least
take 2 seconds but if you look at our
client here look at that
it's a started at 1650 143 and completed
also at that same time and notice that
the button is not being disabled at all
even for a second that's basically
because once the call gets to the WCF
service you know the client is relieved
in one-way operation because it's not
waiting for a response message to come
back so obviously that has got an
implication as well meaning a federally
there are so false
you know while processing the request
those doesn't get reported to the client
okay so the WCF service calls an
operation you know and forgets about it
if there are errors you know so false
processing that request you know that
doesn't get reported to the client and
if at all if there is an unhandled
exception and if the silver channel is
faulted you know that again doesn't get
reported back to the client the client
doesn't know about it until after
another call you know on the subsequent
call you know it finds out that the
server channel is faulted and at which
point the client channel also gets
faulted and obviously you know the same
instance of the proxy class will become
useless let's actually look at that in
action so let's clear all these messages
let's you know invoke this one one-way
operation throws exception if you look
at the implementation of that method
what is it doing it's simply throwing an
exception so once we click this part and
look at that it doesn't say anything
about the exception it says that you
know it started and completed because it
has sent a message to invoke that method
and that's it it's done okay and then
obviously at the WCF service there is an
exception
so when there is an exception and
obviously this is an unhandled exception
so and we are using TCP protocol so
what's going to happen because of
sessions are involved there so the
server channel is going to get faulted
and the client is not aware of that okay
so when we click this button again
one-way operation throws exception look
at that we get a message but that says
the socket connection was supported
because the server channel is faulted
and the client is not aware of that okay
so now what happens you know as a result
of this the client channel will be
faulted at this time and then if you
click this button look at that we get
that error the communication object
cannot be used for communication because
it's in faulted State okay so the Falls
doesn't get reported straight away and
in a similar fashion if the silver
channel is faulted you know we don't get
to know about it until you know until we
make another call okay so those are the
implications and obviously if the
operation has to be one way you know the
return type has to be wired and you
cannot use any output parameters or
reference parameters okay because you
know it's a one-way operation so the
method is not going to return anything
and in a similar fashion you cannot
initialize output variables or reference
variables because you know output
parameters basically they are used to
return something to the caller but here
the caller is not expecting anything it
has to be a one-way operation that's why
we cannot include written types
reference parameters or output
parameters okay and what's going to
happen if you do that obviously let's
actually look at that let's close the
service source that's running let's
specify a return type here so since we
are specifying the return type let's
actually return a string within the
implementation we are specifying the
return type so that should match you
know the return type within the service
contract so let's say that is string as
well now let's actually run this and see
what's going to happen we will get an
exception look at that when it's trying
to host
you know we get an exception and what is
it saying invalid operation exception
and operations marked with is one way
equals true must not declare output
parameters reference parameters are
returned values and that makes sense
all right now let's look at the concepts
that are involved with this require I
mean one-way operations so as messages
are exchanged only in one way
false doesn't get reported straight away
to the client and clients are unaware of
the server channel Falls until a
subsequent call is made an exception
will be thrown if operations marked with
each one way equals true declares output
parameters reference parameters or
return values and are these one-way
calls
same as asynchronous calls you know they
appear to be but really they're not
asynchronous calls when a one-way call
is received at the servers and if the
service is busy serving other requests
then what happens that call gets queued
and the client is unblocked and the
client can continue executing with you
know whatever it has been doing okay but
you know behind the scenes the WCF
service is going to process them but
then keep in mind
one-way calls can still block the client
if the number of message is waiting to
be processed has exceeded this server
queue limit so you know if we keep on
clicking this button one-way operation
you know at the moment it's in faulted
State but if we keep on clicking it
what's going to happen you know we're
going to send messages to invoke that
one-way operation so all of them are
going to get queued at the WCF servers
now we can configure the DBC of service
to specify the queue length okay so
let's say if we set the queue length to
for example 10 and if we are trying to
peel another message what's going to
happen that will not get queued and at
that point the client is blocked okay so
these one-way operations are not
asynchronous calls they just give an
appearance to be asynchronous
but they are not that's it for today
thank you for listening
have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>