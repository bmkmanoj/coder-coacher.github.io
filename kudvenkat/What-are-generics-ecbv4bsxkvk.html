<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What are generics | Coder Coacher - Coaching Coders</title><meta content="What are generics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What are generics</b></h2><h5 class="post__date">2011-11-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ecbv4bsxkvk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to prism technologies this is
Prasad jeera curry today we will be
talking about one of the very important
interview question what are generics or
what are the advantages of using
generics before we can understand that
let's try and understand what arrays are
and water dotnet version 1.0 collections
are we will basically try and understand
the advantages and disadvantages of both
these concepts let's look at an example
of using arrays for example if i have to
create an integer array I will say end
numbers equals new integer and I am
basically initializing the size of this
particular array to three so numbers of
0 equals 1 0 1 since the size of the
array is 3 I can only hold 3 elements
inside that ok so we created the array
of type integer we have set the size to
3 and we have stood 3 elements into this
collection and if I want to print these
elements out of this collection I will
retrieve them using the for each loop
and then print them out so
console.writeline
high so what is this program doing
creating an array and then populating
them with these values and then we are
trying to clean them out so if we go
ahead and run this you will see the
output 1 0 1 1 0 2 1 0 3 as expected
okay now let's understand the advantage
of using arrays arrays are strongly
typed meaning since this array is an
integer array you can only store
integers into this collection if I try
to store an element of a different data
type for example a string we will get a
compiler error because this is an
integer array and you can only store
integers because it because arrays are
strongly typed so we already have an
error if you look at the error list
cannot implicitly convert type string
because arrays are strongly typed so a
very great advantage of using arrays is
they are strongly typed because of which
indirectly we have two advantages one we
don't run into any runtime errors
you know because you are forced to
initialize this collection with elements
of integer datatype alone in this
specific case if you try to store
elements of any of the datatype you know
even if you do that accidentally that
will be flagged as an error by the
compiler so we will come to know any
errors like this it compile time itself
and another advantage is performance we
will better understand this when we talk
about dotnet version 1.0 collections
okay so one thing that we have to
understand at this time arrays are
strongly typed and it is definitely a
very great feature that array says but
arrays has downsides as well one is once
you fix the size of an array they cannot
grow in size for example here I said the
size of this array is 3 if I try to
store a 4th element to this particular
collection now when I go ahead and
compile this the application will
compile without any problem so if you
look at in the status bar build
succeeded but when I actually run this
we get a runtime exception
so it says unhandled exception index out
of range exception that's and that makes
sense because the size of the array is 3
but you're trying to store a 4th element
you know whose size is 3 so so these
this arrays cannot grow in size once
initialized and these errors could
appear at runtime there is no way to
capture these at compile time ok so this
is one disadvantage another disadvantage
in order to assign elements to this
collection to arrays the only way you
have is to use these integer indexes
there is no other way but whereas with
the.net version 1.0 collections
we have several convenient methods which
we will see Justin just in a bit so if
you look at this so arrays are strongly
typed meaning you can only add one type
of elements into this collection and
what are the disadvantages they are you
know integral index based 0 index based
and they cannot grow in size
automatically once initialized to a
certain value now let's go ahead and
look at dotnet version 1.0 collections
now we have several classes in dotnet
1.0 collections like gorillas hash table
stack and queue basically let's examine
how ArrayList work so let's say I want
to create an array less now all dotnet
version 1.0 collections are in system
dot collections namespace so you will
have to use this namespace so ArrayList
let's say for example numbers is equal
to new ArrayList and I'm setting the
size of this collection to 3 let's say
numbers now in order to add elements to
this collection I can use an integral
index if i want but i can also use this
convenient method like add let's say
what you want and if i want to add
multiple elements i can go ahead and do
that 1 0 2 1 0 3 etc if I want to print
these numbers what I can do is I can
make use of before each loop
all right so now if I go ahead and run
the output is exactly similar except
that now instead of NRA we are using
collections that are present in dotnet
version 1.0 now look at this these this
collection this ArrayList collection
numbers you know I have set the size to
three if I try to add a fourth element
what happens let's go ahead and see that
now let's say I'm adding a fourth
element now if I go ahead and run this
it compiles and runs successfully in
spite of the size being three I am able
to add a fourth element to this
collection successfully without a
compilation error or in run time error
so that's one of the greatest advantage
of using collections dotnet version 1.0
collections the reason why I keep on
saying dotnet version 1.0 collections
because in dotnet version 2.0 generics
are introduced so to differentiate and
both of them are basically collections
so to differentiate between these two I
refer to ArrayList hash-table stack and
queue as dotnet version 1.0 collections
alright so we have already known that
dotnet version 1.0 collections they can
grow in size automatically that's one of
the advantages of using these
collections they can grow in size
automatically and they're convenient to
work with as well you don't have to rely
on integral indexers like how we worked
with arrays you know that way definitely
works but you are not limited to just
using that way you can use this
convenient methods like add you know and
if you want to remove elements from you
can say dot remove I mean if you want to
remove an element at a specific location
then you can make use of remove where
otherwise if you know which element you
want to remove you can remove that
element as well similarly if you want to
add an element we say add if you want to
add a range of elements then you can say
I had range similarly if you want to
remove a range of elements from the
collection you can make use of remove
range so we have these convenient
methods basically to work with
collections you're not limited just you
say
those integral indexers like how we are
limited with arrays but what is the
downside of using these collections the
downs arrays these collections none of
these collection classes and systems or
collections namespace are strongly-typed
meaning if you look at this when I say
add this ArrayList hash table stack and
queue all dotnet version 1.0 collections
they operate on the object data type
okay now we know that in dotnet all
types directly or indirectly inherit
from object type so based on that fact
you can add any element of any data type
to this collection for example here I'm
adding an integer and somewhere down the
line if you want to add an element of
type string it will still allow that
because it operates on the object data
type for example let's say plugin okay
now if I go ahead and build this it
happily compiled but when I actually
wrap this program it works until one
zero four but after that you know it it
tries to take this word and convert it
into integer and it and we get an
unhandled exception invalid cast
exception and that makes sense because
we cannot convert the string into an
integer okay so this is the problem with
collections since they operate on the
object type you know users can
inadvertently add data types of you know
different types altogether for example
they can add strings integers de times
etc but when we actually try to retrieve
those elements into one element like
this it will give us an invalid cast
exception and these are hard to find at
compile then there is no way to detect
them because they operate on the object
type and and it accepts any data type so
they are not strongly typed and because
of that we have these hard-to-find
runtime errors another disadvantage of
using these
collections version 1.0 collections is
that since they operate on the object
data type as we have already seen from
the intelligence you know this ArrayList
they operate on the object data type now
this one zero one is an integer meaning
a value type and since it is expecting
an object this one zero one is now
converted into this one zero one which
is an integer which is a value type is
actually converted into a reference type
so converting value types in the
reference types is called boxing so
boxing is happening here unnecessarily
and there is that overhead involved and
then when we actually retrieve those
elements out of this collection try to
print them we try to store this object
you know the boxed value one zero one
which is an object form or which is in a
reference form now into a value type so
unboxing is happening so boxing and
unboxing happens when you add and remove
value types to.net version 1.0
collections because they operate on
object datatype and this will have a
negative impact the performance
unnecessary box anymore and then boxing
all right so because these dotnet
version 1.0 collections lost they're
strongly type the nature we have these
disadvantages you can inadvertently end
up adding elements of different data
types which will present with present
you with runtime errors hard-to-find
runtime errors and another one as an
unnecessary box and unboxing happens
when you add a value type to any of the
dotnet version 1.0 collections and
because of which there will be a
negative impact on the performance in
order to solve all these problems
associated see the problem with that is
is they cannot grow in size
automatically and they they the only way
to work with them is to use those zero
based indices indexes but whereas we've
gotten version 1.0 collections you know
you lost that strongly-typed
nature now generates actually combines
best of both worlds now they are
strongly typed like arrays meaning
they're type they're type save meaning
there is no more
danger of inadvertently adding elements
of different data types and you don't
encounter any runtime errors because of
type mismatches at runtime so that's a
good feature there types of like arrays
and they can also grow in size
automatically even if you have set an
initial size like RLS like dotnet
version 1.0 collections and these
genetics also have these convenient
methods like add add range remove remove
rangering add methods which are very
convenient to work with now let's
quickly look at an example of how to use
collections from generics before we do
that I told you in dotnet version 1.0
collections we have ArrayList hash table
stack and queue and for every class and
sister blood collections in dotnet
version 1.0 collections we have a
respect to counterparty generics for
example for ArrayList we have a list of
T now this T is the type of element that
you want to add to this list let's look
at an example and that will make it
clear but before that you know for
ArrayList it's a list of T for hash
table it is dictionary for stack stack
of tqq of T now let's look at an example
now if I want to create or if I want to
use generates there is a namespace for
that using system dot collections dot
generics you have to import that
namespace now if I want to use a list so
I will say list and you have to specify
the type for that so list off look at
this T T meaning the type of an element
that you want to store for example if I
want to store integers I will say a list
of end if I want to store strings I can
say list of string but in this case
integer so list of end and I can say new
list of integer and then look at this if
you want you can specify an initial size
for example let's say I want to hold 3
elements but you're not just limited to
adding 3 elements you can add as many
elements as you want so I am adding
one two three four elements and look at
this this is already flagged as a
compiler error cannot convert from
cannot convert from string to integer
because it knows look at the add method
the intelligence shows you can only add
an integer element to this collection
because generics are strongly typed like
arrays but here we're trying to add a
string so we get a compiler so these are
strongly typed like arrays so we got the
benefit and since the size is three here
and I'm adding a fourth element but I
still don't get any compiler or runtime
error so if I go ahead and run this it
will work without any problems so
generics can grew in size automatically
even after initializing to a specific
value okay so just like collections okay
and another advantage you can use these
convenient methods add remove remove at
etc so in short generics basically have
best of both the worlds okay now if you
want further information you can visit
our website at present a calm and for
most valuable you know asp.net and C
sharp interview questions which are very
frequently asked and most of the
interviews you can refer to these sides
until next time have a good evening
I will see you later thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>