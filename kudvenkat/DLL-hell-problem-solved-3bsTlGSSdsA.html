<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DLL hell problem solved | Coder Coacher - Coaching Coders</title><meta content="DLL hell problem solved - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DLL hell problem solved</b></h2><h5 class="post__date">2012-07-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3bsTlGSSdsA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to prism technologies I am
venket this is part 7 of dotnet Basics
in this session we'll understand how the
ll help problem is solved in dotnet now
to understand this session properly I
strongly recommend watching paths 5 &amp;amp; 6
how dotnet finds the assemblies during
program execution and DLL hell to
quickly recap what we have seen in part
6 DLL hell is a situation where we have
two applications a1 and a2 and both
sharing an assembly shade or DLL and
let's say we have a new version of
application a2 and when I install that
new version of application a2 it also
copies over they shared a new version of
the shade assembly and that new version
of the shade assembly is not
backward-compatible as a result of which
application a1 fails this is known as
DLL hell let's quickly simulate this
problem in code and then we will see how
to solve this DLL help problem by
strongly naming the assemblies now if
you look at this solution that I have
right here I have two console
applications a1 and a2 and a class
library project both of these cons well
applications are making use of this
class library project so if you look at
the class library project itself I have
a very simple class here which is called
a sample and within this class I have a
static method called get message 1 which
returns a string so all this method does
is returns the string and this class
library assembly is being used by
application a 1 and a 2 and you can see
that in the references so even an
application a 2 it's making use of the
class library so how are we using that
class library assembly in a1 and a2 so
within a 1 what are we doing we are
actually invoking the sample class that
is present in class library assembly and
we are invoking this get message 1
method
and printing the message returned by
this ket message one and we are doing
the exactly same thing even in a two
application okay
so let's build the solution let's open a
one project in Windows Explorer get into
the bin debug and within this directory
as you might expect we have the
applications executable a one dot exe
and the assembly on which this
application depends upon which is class
library DLL so copy those assemblies and
let's move them to my application folder
so I've created a folder called my
application and I want to move both of
these into this folder so a1 dot exe and
class library and along the same lines I
want to also move application a2 and
it's dependent assembly which is nothing
but class library DLL again so a2 dot
exe and class library dot DLL so both of
these applications are depending on this
class library DLL so let's copy that
into my application folder ok so if you
look at this these two applications rely
on this class library lab so if you look
at the presentation we exactly have the
same situation two applications sharing
this assembly and if you look at this
both of these applications now I run
this application a 1 it works fine
prints that message as expected
similarly application a 2 it also works
as expected
why because both of these us are
executables have the version of the
assembly they need now let's say or a
period of time application a2 has gone
some upgrades as a result of which we
have a new version of application a2 and
as part of the upgrade process they also
changed you know the class library
assembly may be you know let's say this
is a new version of class library
assembly that we have so they change the
version number from 1.0 to 2.0
and within the assembly they also have
changed the method name from get message
want to get message to now from this is
a breaking change if there is already an
application that is expecting get
message one method to be present within
the sample class those applications will
now start failing when you copy over
this assembly let's see that in action
okay so let's build this assembly and
let's go into the console application a
to and let's make okay this one is going
to make use of get message one remember
we are having a new version so this is
the new version of a two and the class
library so when I build this project and
let's go into the bin directory of this
application copy the application and the
class library into our my application
folder
copy and replace that now look at this
we installed a new version of a to
application as a result of which it
overwritten the class library dot DLL as
well and now when we run a two it works
fine there is no issue but the existing
application which is a one it fails it
will not find get message one because
why this class library DLL contains get
message to method right now get message
one is removed and the change for this
assembly is not backward-compatible and
it has been accidentally overwritten by
the installation of this new application
a - as a result of which your existing
application a one stopped working so
this is nothing but DLL hell ok so now
let's get rid of all of these and let's
see how to solve this problem
ok so let's put it back to how it was
before so let's go to assembly info dot
CS of class library so let's make it
version one like how it was before and
let's call this method as you should get
message to one and let's build this
class library assembly change a to two
back what it was kept message one
okay now let's strongly name this shade
assembly and how to do that very simple
we use the strong naming tool first to
generate the key pair the private and
public key pair once we have that key
file we then use the assembly key file
attribute and then strongly named this
assembly and if you're new if you're not
sure how to do that we already have a
video recorded on that so please check
that video because we'll be will not be
covering you know the complete details
of strongly naming in assembly here
alright so I already have the key file
which is generated using the strong name
tool and it is present in the C Drive
that's the name of the key file so let's
copy that let's get into the assembly
info dot CSO for class library assembly
and within that
we use the assembly keyfile attribute so
assembly assembly keyfile attribute and
to the constructor we pass in the name
of the key file that contains our
private and public key pair all right so
now let's rebuild the solution so
rebuild the solution so what what will
this process do it has strongly named
this class library assembly all right so
now let's remove these references which
were already there so I'm removing these
references and let's clean the solution
now you might be wondering what clean
solution will do clean solution will
basically delete all the assemblies that
are there in the bin folders of
respective projects so if you get into
the bin folder of any project you
shouldn't be finding any assembly they
would have been deleted now this is just
the visual stood a visual studio host
file which will which we'll talk about
in a later session but you don't find
the executable or the DLL so if you go
back to the class library even that
should have been deleted by now when we
said clean project so clean project
basically deletes everything the
assembly is from the respective folders
okay so let's rebuild the solution
obviously we'll get errors because why
application a1 and a2 are referring to
this class library assemblies but we
don't have a reference to those
assemblies yet so let's set the
references now so application a1 wants
to use the class library assembly which
is present in a one folder so class
library bin-debug
class library and along the same lines
we want this we want to set a reference
to application a2 as well ok so now
let's go ahead and rebuild the solution
once again so now everything should work
without issues okay now the only
difference between the first time and
this time is that this time this class
library assembly is a strongly named
assembly all right so now let's open
this folder in Windows
get in the bin-debug so you have this a1
dot exe and the class library assembly
let's copy these and move them into our
my application folder so I paste them
here and along the same lines let's open
application a to open it in Windows
Explorer we are doing the exactly the
same thing except that a1 and a2 I mean
the class library assembly right now is
strongly named copy and replace so now I
run a one it works fine as expected a
two works fine
now let's do the breaking change but
before we do the breaking change mind
you guys this class library is a
strongly named assembly so this can be
installed into the GAC global assembly
cache ok and again we have seen how to
do that in the previous sessions so
please watch those in detail if you're
not sure on how to do that so I want to
install this assembly into the gag so
let's go into the visual studio command
prompt and we use the GAC utility tool
for that sokak youto - I for install
copy the path which is C colon backslash
my application and within that we have
this class library door DLL
and placenta so what should did this -
they shouldn't solve this class library
assembly into the dag so since this I
mean we have built this assembly using
dotnet Visual Studio 2010 and we have
dotnet framework 4.0 you know the
location where this assembly is
installed is actually C Windows
microsoft.net assemblies
remember if you have dotnet framework
4.0 installed on your computer you have
two versions of the GAC and we have
spoken about that again in our previous
sessions okay
so let's go to C colon backslash R
endows microsoft.net assembly and within
that if you go to gag MSI l you should
see a class library folder there within
which we have this is built using
version 4.0 of dotnet and the version of
the class library assembly is 1.0.0 and
this is the public key token and if you
open that folder you should see class
library assembly very good okay now
let's go ahead and do the breaking
change that we want to do now let's say
there is a new version of a2 and a2 has
changed some of the things in this
assembly let's say they changed they did
the exact same thing they changed this
method name from get message one to get
message two and obviously they need to
change the version number as well so
assembly version right now is 2.0 and
let's build this assembly
and let's open this and obviously it is
expecting get message to let's build
this application a to okay let's go
let's open this in Windows Explorer then
diba copy the application and the DLL go
into my application folder copy paste em
so now as you might expect it did the
same thing it overrode a to dot exe and
class library dot the area now this is a
version 2 of class library and remember
since this is strongly named you can
install this as well into the gap now if
I want a one dot exe look at that a one
dot DXE will still work look at that
it's working and a two dot exe will also
work because why if you remember how
dotnet runtime environment finds
assemblies during program execution it's
very simple it searches the version it
requires and if it's a strongly named
assembly it checks the gag and if it
finds it there it pulls it from there
and then uses it if it's not found from
fine I mean if it doesn't find it in the
gag and if there is a configuration file
and if you have specified a specific
location to search for in the
configuration file it searches for that
location if there is no configuration
file then it searches in the location
where the executable is present and if
the assembly is found there it uses that
so please check that video part and you
will understand that in a great detail
ok now since we installed version 1 of
this assembly inside the gag so this a 1
dot exe will find that assembly it
requires in the GAC and user set but a 2
dot exe will not find what it requires
in GAC because it is present only here
if you want you can install this also
into the gag ok so once we install this
assembly into the deck what's going to
happen both the versions can live side
by side let's actually do that so if I
say gakuto and store
this assembly also into the gag what's
going to happen even this version two of
this class library assembly gets
installed so if we go back and check the
C column windows microsoft.net and
assembly folder gak MSI l you should see
within class library two assemblies one
is version 1.0 the other one is 2.0 and
even if you delete this assembly from
here your application let's close this
both application a1 and a2 should still
work so a1 is working a 2 is also
working so how are they working because
both of these applications what what is
the resolution algorithm used whether on
time environment it first such as the
gap if it's strongly named assembly that
it is looking for and within the GAC you
have both assemblies class library
version 1.0 and version 2.0 so strongly
naming the assemblies solves this DLL
hell problem there is no accidentally
you know there is no chance of
accidentally over writing the assemblies
because why different version of the
assemblies can live together side by
side and this is called a side by side
execution in fact okay so strongly
naming assemblies solves DLL hell
problem on this slide you can find
resources for asp.net and C sharp
interview questions that's it for today
thank you for listening
have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>