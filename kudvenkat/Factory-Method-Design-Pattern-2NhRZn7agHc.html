<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Factory Method Design Pattern | Coder Coacher - Coaching Coders</title><meta content="Factory Method Design Pattern - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Factory Method Design Pattern</b></h2><h5 class="post__date">2017-08-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2NhRZn7agHc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome back this is part
9 of the design patterns tutorial in
this session we'll do a quick recap of
simple Factory and we'll discuss how we
can enhance a simple Factory
implementation to factory method pattern
please refer to the previous parts of
the tutorial before proceeding now if
you recap the previous example of simple
Factory we have extended the employee
manager to use the subclasses of contact
and permanent employee manager to
compute bonus and oddly pay based on the
employee type from this implementation
we can conclude that simple Factory
abstracts the creation details of the
product and simple factories refers to
the newly created object to an interface
any new type creation is handled with a
change of code in the factory class and
not at the client code now to summarize
depending on the business requirement if
you are just looking for creation of the
object the simple Factory is sufficient
enough to address the requirement now if
you foresee any requirement changes in
future and those changes are not just
confined to the creation of the object
and further if you need to extend the
creation logic to a business level
abstraction which is specific to either
permanent or contract employee manager
then we need to extend the simple
factory to factory method pattern you
may be wondering how different is simple
Factory with respect to factory method
pattern let's take a look at the
illustrated diagram if you compare the
simple factory with factory method
pattern you may notice that the factory
is replaced with abstract concrete
Creator which is responsible in creating
the concrete product EA and concrete
product B the tax of the products now
just because we named the creators as
abstract please note that it doesn't
mean this is the abstract Factory if
this is confusing at the moment don't
worry
we will address this with a business use
case let's so take a look at the
business use case if you recollect the
previous session we have already
addressed point number one as part of
the simple factory implementation now
let's say we need to compute house'll
events which is specific to permanent
employee
and we need to compute medical events
specific to contract employee then the
current simple factory implementation
gets little tricky and complicated let's
see how we can address this by extending
our previous example let's bring up the
visual studio and work on the portal
solution that we have been using in our
previous sessions let's open the
employee portal MDF file open table
definition of employee table
let's add house elements which is the
simul and medical allowance which is
also a decimal type let's click update
let's update the database the employee
table schema changes are updated
successfully now let's expand the models
and open employ model dotty DMX right
clicks on the model and let's update the
model from the database let's choose
refresh expand tables choose employee
let's click on finish notice that the
house relevance and medical allowance
are updated successfully let's save the
changes now let's switch to permanent
employee manager and let's address the
requirement of computing house allowance
since the house elements computation is
specific to permanent employee we are
not going to add this at the interface
level of I employee manager instead we
are going to write the implementation at
the permanent employee manager class
itself let's create a new method public
decimal get house elements and let's
return the 11 SAS 150 dollars per month
now let's switch to contact employee
manager and let's suggest the
requirement of computing medical events
specific to contract employee let's
create a method public decimal get
medical allowance and let's return the
monthly medical allowance for the
employee has 100 dollars let's switch to
the employees controller and let's
inspect the code add employees
controller which uses the
simple factory you may notice that the
simple factory returns the I employee
manager from the employee manager
factory which computes the bonus and pay
for the employee we have not exposed the
house'll events and medical events
through the I employee manager hence we
need to compute these values at the
point where the simple factory is
creating the I employee manager let's
switch to the employee manager Factory
now changing the simple factory which is
in our case employee manager factory to
accommodate the changes is complicated
and we end up violating the principles
of creational patterns so we can solve
this issue by providing another layer of
abstraction which takes care of
computing the common interface
operations as well as specific
operations related to permanent and
contact employee let's see how we can
achieve that let's create a new folder
under the existing factory folder and
let's name this folder as factory method
let's so add all the classes related to
factory in the third implementation
under this folder let's create a class
called base employee Factory and let's
declare an abstract method that takes
care of creating the respective I
employee manager public abstract
I am floor manager and let's name this
abstract method as create let's also
change this class to abstract class
let's resolve this issue by using the
dot managers let's enhance this base
employee Factory to accept employee
object model so that we can compute the
bonus all the pay and
the specific operations let's create
protected employee and let's declare
this employers underscore UMP let's just
solve this employee declaration using
web ball web dot models and let's create
a constructor base employee factory
constructor which acts EPS employee as
the input parameter and let's assign
this EMP to the declared underscore EMP
now that we have an abstract Factory
let's go create concrete implementation
factories for permanent and contract
employees let's right-click on the
factory method folder add new item and
choose a class and let's name this class
as permanent employee factory let's
invert the abstract factory that we have
created earlier base employee factory
and let's resolve these issues by
implementing the constructor as well as
the abstract method that we have
declared in the abstract Factory let's
enhance the create method and let's
remove this default exception
implementation and replace this by
computing the house'll events which is
specific to permanent employee marriages
let's create permanent employee manager
let's name it as manager equal to new
permanent employee manager now let's
compute the employee dot house'll events
equal to manager dot get house'll events
returned the manager object let's do the
similar steps and implement contact
employee factory right-click on the
factory method folder and new item
choose the class and let's name this
class as contract employee factory let's
invert the base employee factory and
let's implement the constructor as well
as the abstract method let's enhance
this create method and let's remove this
default exception and replace this by
computing the medical Elevens which is
specific to contact employee let's say
contract employee manager manager equal
to new contract employee manager let's
compute the employee dot medical
relevance equal to manager dot get
medical allowance
let's return the manager object let's
now switch back to the base employee
Factory you may have noticed that we
have implemented the operation specific
to contact and permanent employees in
their specific factory methods the next
step is to compute the Bowl is an hourly
pay which are common for both contact
and permanent employees we can achieve
this by leveraging on base employee
factory let's create a new method in the
base employee Factory and call this
method as applies Ally let's create
public employee apply salary
the third and let's compute the bonus
and base pay using I employee manager
manager is equal to this dot create the
abstract create method will take care of
returning the corresponding I employ
manager interface let's compute
underscore EMP dot bonus equal to
manager dot get bowlers similarly
underscore employee dot hourly pay equal
to manager dot get pay let's return back
the employee now that we have segregated
the operations on employing to respect
to factory classes let's so integrate
the factory method implementation let's
create a new employee factory manager
class under this factory method and
let's return the respective factory
objects based on the employee type so I
click on the factory method add new item
let's choose a class and name this class
as employee manager factory and let's
create a new method under the employee
manager factory which returns base
employee factory let's call this method
as create factory which acts EPS
employee object EMP Lexus all this issue
by using the dot models and let's create
base employee factory as the return
value let's assign null value to this if
EMP dot employee type ID equal to one
which means it's a permanent employee
manager or a permanent employee
let's return then let's assign the
written value equal to mu
permanent employer factoring and let's
pass the employee object let's also say
else if employee dot employee type I'd
equal to two which means it's contact
employee let's assign the written value
equal to new contract employee factory
and that's passed the employee object
now let's let's just sign and return
this written value written written value
let's now integrate the changes in the
employees controller let's open the
employees controller and let's replace
this simple factory with factory method
implementation let's use the dot factory
dot factory method and let's move to the
create and instead of using the get
employee manager we are going to create
the factory and pass the employee object
which returns first base employee
factory which is base employee factory
instead of using I employee manager
let's all let's remove this goal and say
employee factory dot apply salary which
takes care of applying the bonus as well
as all we pay as well as rest of the
operations related to the permanent and
contract employee managers now let's
compile this application this
in this application let's switch to the
list view of the employee and add the
house elements and medical allowance
columns to the list view let's open the
index dot HTML let's scroll down and
let's add mode item dot house 11 and
let's also add item dot medical elements
let's also add the headers to these
columns over here and say I just copy
this same model dot house all of us and
let's also say model dot medical 11th
let's not run this application let's
choose employees let's create a new
employee let's name this employee as
Michael job description as manager
number as a two three four five
department as ID let's click on create
look at that the new employee Michael is
created as permanent employee and his
house allowance is computed as well
let's do it one more time this time
let's do with a debugging on let's
switch to the code let's go to the
employees controller and put a
breakpoint before creating this employee
let's go back to the ie and let's say
let's create another employee called
Jason job description as contact
employee number as C 3 4 5 6 Department
as development and let's choose employee
type ID as contract let's click on
create
let's press f11 during the factory
creation notice that employ type ID is
true we are creating a contract employee
factory let's step into the code let's
look at that the employee object is
assigned and the contact employee
Factory is created now let's return the
value and click on F Levin applies Alvie
if you inspect the code the apply salary
method is creating the I employee
manager which is further computing the
bonus and hourly pay and returning the
employee object let's run this
application look at that new employee
jason has been created as a contract
employee that medical earns as hundred
with this we have successfully addressed
the business requirement by enhancing
the simple factory to factory method
pattern now let's revisit the Gang of
Four definition about factory method
pattern as per Gang of Four destination
we define an interface which in our case
is an abstract class for creating an
object but we let the subclasses decide
which class to instantiate which is in
our case our permanent and contract
employee factories and hence we can see
that the current factory method lets a
class prefer its instantiation it uses
two subclasses in the next session we
will discuss and learn the abstract
factory pattern please feel free to post
your comments and feedback in the
comments section thank you for listening
and have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>