<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 42   C# Tutorial   Custom Exceptions in C# | Coder Coacher - Coaching Coders</title><meta content="Part 42   C# Tutorial   Custom Exceptions in C# - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Part 42   C# Tutorial   Custom Exceptions in C#</b></h2><h5 class="post__date">2012-06-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9qHb-2Edg7o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to prism technologies I am
venket this is part 42 custom exceptions
in this session we will learn when to
create custom exceptions creating a
custom exception from the scratch
throwing and catching the custom
exception that we create
now to understand custom exceptions
probably you should already have a good
understanding of inheritance exception
handling basics and inner exceptions if
you want to learn more about these
concepts
please watch parts 21 40 and 41 of this
video series now when do you usually go
for creating your own custom exceptions
why is there a need to do so because if
you look at dotnet itself dotnet
provides us with so many exceptions you
know we have file on phone exception you
know index out of range exception or net
provides us with so many exceptions so
what is the need for us to create our
own custom exception that's what weíll
answer in a bed but to find out all the
exceptions that are already available
within the dotnet framework what you can
do is you can go to the debug menu and
select exceptions button this window
will show you all the available you know
not net exceptions already and to get to
this window another keyboard shortcut is
alt ctrl e for example you know we know
that if we are trying to read from a
file and if the file is not on we
usually throw a file not found exception
so if I want to find that file not found
exception go to common language runtime
exceptions and we know that any classes
to do with system IO are present in
system dot IO namespace so if you see
here system dot IO dot file not found
exception ok
so similarly there are so many
exceptions within that framework now
there might be scenarios where one of
these exceptions that are already
available may not be adequate enough to
describe the problem that I have let's
look at an example now let's say I have
an asp.net web application and the
requirement of this application is such
that it should only allow us you know to
log in one time named browser
if I am already logged in in a browser
window and if I try to open another
browser window and if I try to again log
in there it should do an error message
saying you are already logged in and to
serve this purpose and to describe this
problem adequately enough we don't have
any exception that's already available
with the door and framework so this
could be one of the classical examples
when you want to design your own custom
exception okay
and to do that we have certain steps and
it's very easy to do that okay so let's
look at step by step of creating our own
custom exception okay so to create a
custom exception and we know that an
exception is nothing but a class for
example if you look at the exception
class itself you know it's a class by
itself okay and we know that all
exceptions within the dotnet framework
directly or indirectly inherit from the
system load exception class system load
exception class is the base class for
all other exceptions that are already
available within that framework now if
you want to create your own custom
exception class and if you want all the
features that an exception object having
then you make your custom exception
class inherit from that base exception
class this way you don't have to provide
any of that functionality you inherit
all that functionality basic exception
class that's why when you're creating
your own exception class the first step
in doing so is to create a class that
inherit from the exception class so
public class and we want to name our
class as user already log then and we
want to make this class inherit from the
exception based class okay now you know
that you know we know that we have file
not found exception for example look at
that and file not found exception by the
way it's in the system namespace we have
to input that so system dot IO and now
if I try to
look at the file not found exception for
example so file not found exception if
you look at this file not found
exception or you know index out of range
exception so all the exceptions
basically end with the suffix exception
okay so what's the advantage of that
basically just by looking at the name of
the class you can say okay this is an
exception class okay so even your
exceptions you know if I say use it
already lock then okay is this a regular
class or an exception class so just to
identify to differentiate with that we
can you know it's it's it's a common
convention to actually end your class
name with the exception suffix this way
by looking at the name of the class you
can say okay this is an exception class
just like file not found exception or
you know index out of range exception or
invalid operation exception use it
already logged in the exception okay so
follow that convention even if you don't
do that you know if you omit this
exception you don't get any compile time
error but you're slightly deviating from
the design guidelines of creating a
custom exception class alright so I mean
to create your custom class at the
minimum this is what you have to do
you're done creating your custom
exception class okay now let's say for
example if you want to through a file
not found exception how do you do that
you use the through keyword through new
file not found exception okay similarly
now let's go ahead and run this fast
when we run this what happens you know
we'll get that system that I will not
file not found exception okay now
similarly if you want to throw your own
exception what do you do you say user
already logged an exception and when we
run this you get that exception
okay but the difference is if you look
at the file not found exception if I
want to customize the message that we
shoot the end user I can do that by
using one of the constructors okay I can
pass in a message to this file not found
exception and let's say for example file
XYZ is not found when you do this what
happens this message will be shown you
know as part of that exception object so
file XYZ is not far now
is it possible to do that kind of a
customization for my exception class no
because why your constructor does not I
mean your exception class does not have
any constructor you didn't provide any
constructor if you don't provide a
constructor we know that dotnet runtime
environment automatically provides a
default parameter less constructor and
that's the only one which is available
now so if you have to provide you a
class the flexibility of passing in a
message so that the developer can
customize the message they pass in to
you because your custom exception then
you have to provide that constructor and
do that it's pretty simple okay let's
finish this all right
so public user already logged in and to
this I pass in the string parameter and
let's call that message now if you look
at the exception class we know that the
exception class also has this is if you
look at this now our class our user
already logged an exception custom
exception class is actually inheriting
from the exception base class okay so
and if you look at the exception based
class if you right-click at that and say
go to definition if you look at the
exception based class it has a
constructor which takes in a string
parameter so now all you have to do is
invoke the base class constructor using
the base keyword and then invoke this
overloaded version passing in the
message so now what are we doing
we are communicating from the derived
class to the base class okay using the
base keyword okay so now if you look at
this one we get a red squiggly here
because once you provide a constructor
to your class the default parameter list
constructor provided by dotnet framework
is taken away so if you want also one
users to be able to create up just
without passing any message they should
be able to create user logged an
exception if you want to provide that
capability then probably have another
constructor which doesn't take any
parameter now here we don't want so what
we are essentially doing here is
constructor overloading again we have
covered that in a separate session
please check on you know that specific
part and constructor overloading okay
now if you look at this constructor it
doesn't take any parameter and in the
exception base class we already have a
constructor which does not take any
parameter so from your derived class
just invoke that specific constructor
you know that's one of the overloaded
base class constructors okay so now what
have you done until now you have
provided two constructors to your class
okay one which does not take parameter
one which takes a string parameter now
if the user wants to customize the
message all they can do is okay user is
logged n no duplicate sessions allowed
you know you can basically customize it
the way you want
okay so now if we run this you should
see that custom message alright now in
part 41 we have we have learned about in
that exceptions what is the advantage of
using inner exceptions inner exceptions
basically allow us to track the original
exception okay so if you're not sure
about any exceptions I would strongly
encourage you to watch this part 41
before continuing with the session so we
know that inner exceptions basically
allows us to track the original
exceptions now if you look at your class
it's not possible you know for this
exception to track the original
exceptions okay so if you want to
provide that capability
for your custom exception class then you
need to provide that overloaded version
okay of constructor if you look at the
base class it has got another
constructor look at this constructor it
takes in a message as well as another
parameter of type exception okay and
basically this is the original exception
and you can pass that as a parameter
okay so let's go and provide that
constructor as well so public use it
already logged in exception so the first
parameter is of type string and the next
parameter is of type exception and this
one is going to be in that exception and
what you do here you call the base class
constructor passing in the message and
inner exception we have already seen
that this base exception class has that
constructor so call that overloaded
version of the base class constructor
and pass in the respective parameters so
now we have provided another constructor
as well so now using your class it's
also possible to track in our exceptions
okay so if I try to go ahead and create
a
an instance of this class look at this
there are three overloaded versions now
you can see that in the intelligence
here all right now another important
thing to keep in mind now this class it
works but it only works within the same
application domain now what's an
application domain we will talk about
application domains when we talk about
removing web services and WCS okay
basically if there are two applications
and they want to talk with each other
let's say for example I have application
a1 and application a2 now if I want
application a1 to talk to application a2
then the objects that you create with an
application a1 has to cross the brown
boundary of the say one application and
reach application a2 boundary now when
you have to move objects across
application boundaries those objects
need to be serializable okay
so we'll talk the concepts of
serialization serialization is nothing
but breaking down that object into
packets that can be transmitted over the
network so if you want to move your
object from one application domain to
another application domain over the
network then the class has to be
serializable ok so if you want custom
exception class to be removable or
serializable then the first thing that
you have to do is to decorate this class
with serializable attribute and then if
you look at the base exception class the
base exception class has an overloaded
constructor for serialization purposes
which takes in serialization info and if
you look at the intellisense the
serialization info class is actually
present in system toward runtime dot
serialization namespace ok so if we have
to use that object we have to import
that namespace and then invoke this
constructor from our class
so let's provide that so first of all
let's go ahead and import system dot
runtime dot serialization namespace and
then we need to provide a constructor
for our class which supports
serialization so use it already lock
then so if you look at the base class
what is the first parameter it has to be
serialization info and the next
parameter is of type stream streaming
context so serialization info and let's
call that as our info and the other one
is trimming context and let's call the
object reference variable as context and
then what we need to do we need to call
the base class base exception class
constructor passing in these parameters
so info and a streaming context all
right so our class at this point our
exception class is almost equivalent to
any other exception class that's
available within the dotnet framework
you have provided all the constructor
overloaded construction constructor
versions which the end user can use for
variety of different purposes and
obviously so if you want to call any of
these constructors it's possible and if
you want to handle this exception so if
we want to through it we threw it in the
try block using the true keyword and to
catch that you can use you know user
already logged in exception may be e^x
and console.readline e^x . message and
if you pass any inner exception you know
when you're throwing this you can also
track that in our exception look at this
if I say comma you can actually see one
of the overloaded constructors you know
taking in a string parameter and the
other parameter is of type in our
exception okay all right so when we run
this now you should see only the message
of that exception rented
ok so let's quickly review what we have
seen so far so creating custom
exceptions what are the steps create a
class that derived from system to the
exception class and as a common naming
convention and the
named exception suffix because all net
exception exceptions and with exception
suffix and if you want your exception
class to conform to those standards then
name your class so and we provide a
public constructor that takes in a
string parameters this constructor
simply passes the string parameter the
base exception class and what does this
provide less it provides you know the
flexibility for the user to pass in the
message that they want into your
exception comes class and if you want to
track inner exceptions you basically
have to provide you know that overloaded
version of the constructor and similarly
if you want your exception class to be
working across application domains then
you need to mark your class as
serializable and remember that it is
also possible to provide your own
customs utilization if you look at this
example we are using the default
serialization that's provided by the
base exception class by invoking by
providing that constructor which
supports that base class utilization but
on the other hand it is also possible to
provide your own custom serialization so
we'll be talking about serialization and
customizing serialization in a later
session in detail that's it for today
thank you for listening have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>