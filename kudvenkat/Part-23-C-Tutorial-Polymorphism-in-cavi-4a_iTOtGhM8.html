<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 23 - C# Tutorial - Polymorphism in c#.avi | Coder Coacher - Coaching Coders</title><meta content="Part 23 - C# Tutorial - Polymorphism in c#.avi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 23 - C# Tutorial - Polymorphism in c#.avi</b></h2><h5 class="post__date">2012-06-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4a_iTOtGhM8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to prism technologies I am
anchored this is part 23 polymorphism in
c-sharp in this session we will learn
overriding which will methods and
polymorphism let's look at an example in
part 3d 1 we have seen inheritance in
that session we have learnt that a base
class reference variable can went to a
chase class object this concept actually
forms the basis for polymorphism if you
haven't already watched my video on
inheritance I would strongly encourage
you to do so we will continue with the
session all right so in this example I
have already written a simple class
called employee which has got two
properties first name last name and an
oem method printable name which will
basically concatenate first and last
name and print a full name now let's say
we have three different type of
employees in our organization part-time
employees full-time employees and
temporary employees okay obviously any
type of employee will have the first
name last name and we should be capable
of printing there so lamp so all the
school is common to every employee so we
have that in the base class let's go
ahead and create the respective child
classes first may be part-time employee
public class part-time employee so this
class inherits from the employee base
class similarly we will have you know
maybe full-time employee which also
inherits from employee class and
similarly we will have temporary
employee as well temporary employee so
if you look at the examples over it's
pretty simple I have an employee based
class part-time employee full-time
employee temporary time our temporary
employee
all of them inherits from the employee
base class now let's say now from
inheritance we know that all of these
cool will be available even to the tails
lasso if I create a part-time employee
object print full name method will be
available to this part-time employees
lieutenant way and temporary employee
okay now let's say in my main method I
want to create an array of employees you
know so let's call this employees is
equal to new array of employees okay I
want to be able to create four different
types of employees now since this is an
array in the first element of this array
I want to create you know the type of
the object is employee okay and then
maybe in the second one employees of one
is equal to new part-time employee now
is this possible absolutely in the
inheritance session we have seen that a
base class a reference variable how this
employees is just a reference variable
so a base class reference variable can
point to you know a child class object
based on that concept we can assign a
tailless object to a base class
reference variable because a child class
is a specialization of its base class
meaning a tail class has all the
capabilities of its base class plus
whatever are the additional you know
features that the change class has
similarly employees of two is equal to
new full-time employee and similarly
employees of three is equal to new
temporary employee so now all we have
done as we have created an array of
employees
and then to each element we have
allocated assigned a different type of
employee object since these classes are
all related by inheritance to the parent
class reference variable you can assign
another respect to change less objects
without any issues now let's say if I
use an added to loop through each
employee object so for each employee
maybe II in employees are a because if
you remember you know though this is a
child class object since this class
these classes are inheriting from the
employee class you know all the cool
that is present in the employee class is
available to the respective classes so
that fact allows us to you know assign a
tail class object to a parent class
reference variable and also allows us to
invoke any of the parent class method so
in the parent class employee we have
printful name so I'm going ahead and
printing that now look at this the
respective child classes doesn't have
printful name method okay so obviously
the parent class has it that will be
invoked so let's go ahead and run this
program
and remember and the employees array we
have four different type of employee
objects if I go ahead and run this as
you might expect you know the printful
name is called for each object and since
the child objects doesn't have their own
version of printful name the parent
version is called which prints just the
first name last name because they are
initialized to the first name and last
name now let's say I have a requirement
my manager said okay that's fine
we are able to print a part-time
employee full-time employee temporary
employees first and last names but what
I want is along with the first and last
names if he is a part-time employee I
want you know an indicator a visual
indicator like - part-time and it is a
full-time you know start would should be
as shown in this pad okay so how do we
do that okay
when we will actually have you know the
respective in the respect to class we
will have a print full name method as
well if I go ahead and implement that
for part-time employee
so for part-time all we have to do this
all right to the first and last name I
want to concatenate part-time string
just like that similarly for the
full-time employee and for temporary
employee and this is going to be
full-time and this is going to be
temporary okay
so now each class has it has got it soon
you know specialized specialized method
or overridden method but now what
happens is if you have the same in the
child class I'm having a method name
which is very much similar to the parent
class if we do that do that in the last
session difference between method you
know in the last session when we spoke
about inheritance we have seen that it
will actually hide the method and method
hiding session we've seen that so if the
method in the child class has the same
name and same signature as the method in
the parent class this literally hides
the method in the base class okay but
now since we are using a base class
reference variable even though you have
a specialized version
in the in the child class the base class
in our method will be called so if you
look at this if I go ahead and run this
you will actually look no difference in
the output and if you look at will get
three warning messages
one for each specialization you know one
forty two derived class so for part-time
employees and time employee and what
this basically is saying is you know
this printful name method is hiding the
method that is present in the base class
because they have same name and
signature and if you're hiding is
intentional then use a new keyword
that's what this message this warning
message is saying so if I won't really
hide that I can use a new keyword but
but that's not our intention our
intention is basically to override the
definition that is provided by the base
class and to do that you have to use the
override keyword but before we do that
we have to mark the method in the parent
class as virtual and then and I will
tell you the reason why you have to do
that at the moment you mark and method
as virtual in your parent class it
basically indicates to the derived class
any derived class can override the
method you know the virtual method if
the derived class wish to do so okay
otherwise they can leave that if they
don't override then the base virtual
implementation will be available to the
derived class so basically what I can do
is look at this if I just delete this
implementation and if I type just
override and then if I press space look
at that the intellisense shows me there
is a method called print' full name
which can be overridden and if I just
select that automatically the signature
method will be inherited okay so public
override wide print full name and what
do we want to do since there's a
part-time employee we want to print the
first last name along with this -
part-time part-time you know string
literal similarly instead of wild we
want to I'm sorry instead of alright I
mean we have to use the override keyword
here and for the temporary employee as
well so what what changes have we done
until now in the base class we mark the
method as virtual and respective derived
classes we are overriding the
implementation so if we go ahead and run
this program now do the reference
variable is of type parent at runtime
you know the runtime actually checks ok
what kind of object do I have if it is a
part-time employee and somebody is
calling the printful name then I want to
invoke the overridden printful name
method in that respect to change the
class which will make these respective
overridden methods the respective
classes to be invoke ok at runtime and
that's nothing but a polymorphism okay
polymorphism basically enables you to
invoke derive the class methods through
base class reference variable at runtime
that's nothing but polymorphism so if I
go ahead and run that we will get the on
to test we have expected so first name
last name and for part-time employee we
should get part-time full-time and
temporary but on the other hand look at
that for example let's say for a
temporary employee I am not providing
any implementation I am NOT who and
writing the method in the base class if
I do that then what happens is since
this temporary employee object doesn't
have any overridden method method the
base class
you know virtual method implementation
will be used for this last employee so
if we go ahead and run that since
part-time and full-time employee classes
has the overridden methods the
respective overridden methods will be
invoked whereas for the temporary
employee we don't have the overridden
method so the base class virtual method
implementation will be used and
similarly for the first employee it's
the employee
object the base class type itself so the
virtual implementation will be used this
is nothing but volume autism so if
somebody asks you what is polymorphism
you know you can just say that in one
very good statement polymorphism enables
us okay to invoke derive the class
methods using a base class reference
variable at runtime
that's polymorphism okay so let's go
back to the slides
so polymorphism is one of the primary
pillars of object-oriented programming
polymorphism allows you to in derived
class methods through a base class
reference during runtime in a base class
the method is declared virtual and then
the derived class we will write that
method and this virtual keyword in the
base class indicates that it can be
overridden by any derived class and on
this slide you can see additional
resources for a speed or net and c-sharp
interview questions that's it for today
thank you for listening have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>