<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Strong naming an assembly | Coder Coacher - Coaching Coders</title><meta content="Strong naming an assembly - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Strong naming an assembly</b></h2><h5 class="post__date">2012-07-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/p6u7n_BPcVw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to prism technologies I am
venket this is part three of dotnet
basics in this session we will learn how
to strong name and assembly that is the
process of signing an assembly with a
private and public key pair now in
dotnet the assemblies can be broadly
classified into two types week named
assemblies and strong named or some ways
okay let me give an example now if you
look at this program this is a very
simple seizure program all this is doing
is printing this message on to the stand
so now to print this message on to the
console we are using the console class
now where is this console class coming
from it is coming from the system
namespace and where is the system
namespace present it is present in the
system assembly and where is the system
assembly okay it's nothing but the
dotnet framework assembly when we
install dotnet on this machine two very
important components get installed one
is the dotnet framework class library
and the other one is the runtime
environment which is nothing but CLR and
you know within dotnet framework class
library we have several assemblies so
when I install dotnet where does these
assemblies get installed they get
installed to a special location called
the GAC GAC global assembly cache so
within this global assembly cache we
have all the dotnet framework assemblies
however that is slightly different for
dotnet framework 4.0 assemblies which
we'll be talking about in a great detail
later okay now the path for GAC is
basically C Drive operating system
directory and then assembly folder so on
my computer it's C colon backslash the
operating system you know directory and
my machine is Windows on some of the
missions it could be win NT you know or
some other name so C : operating system
directory and backslash assembly so this
folder is called GAC it's given a
special name because all the dotnet
framework assemblies reside in here so
if you look at the assemblies here
within this CAC
okay all these assemblies are strongly
named now how will we distinguish
between a strong name decimally and a
week named assembly we'll come to that
in a bit but but trust me these are
strong named assemblies now if you look
at an assembly any assembly within
dotnet the assembly name basically
consists of four parts
what are they the four parts are if you
look at the presentation the simple
textual name which is nothing but this
name for example if you take the system
assembly so this is the name of the
system assembly so the simple textual
name is just one part of the full
assembly name and then the version
number okay
what's the version number is it 1.0 dot
0 dot 0 or 2.5 what is the version
number and if you look at the version
number itself it can be again divided
into four parts we'll talk about that in
a bit and then the third part is the
culture information okay most of the
assemblies in general of language
neutral we'll be talking about culture
also in a bit and then finally public
key token okay
not all assemblies will have public key
token only if it is a strong named
assembly will it help so that's the way
to identify whether if it not simply is
a strong named assembly or a weak name
does only if an assembly has this public
key token then it is a strong named
assembly all right let's talk piece by
piece here all the four different parts
that form the name of this assembly so
this is a simple textual name basically
it gets the name of your project okay so
that's your simple textual name and then
we have the version number if you look
at the version number it has the version
number can again be divided into four
parts the version number can be again
divided into four parts if you look at
this we have one dot 0 dot 0 dot 0 okay
so basically 1.0 version of this
assembly ok and if you look at these
four parts the first part is called a
major version the second part minor bill
number and revision number now typically
any software will go under it will
undergo a change over a period of time
and then when we introduce new features
of fixed boxes depending on the
significance of the chain
and we either change the major' number
or the minor version number if the
changes that we are making to our
application are huge then probably will
change the major version number
otherwise we usually the changes are
small then probably we just change the
minor version number that's why you
might see applications you know
application version 1.0 or version 1.5
or 2.5 etc okay but most of the time the
bill number and revision number are
defaulted okay let's look at how to
change the version about for example if
you look at this project it has got a
very simple project and you know when we
compile this we get an assembly and if
we go into the bin folder of this
project you should see that assembly and
if I right click on that and if I go to
the properties or in the previous
session we have seen how to use the ILD
azzam tool ok to change the assembly
version I mean to check the assembly
details so if you go into the details
here you should see that the version of
this assembly is 1.0.0 this is actually
a file version if you want to check the
version of the assembly it's better to
use the il Dasom tool and it's very
simple to use the il decima tool which
we have seen in the last session and to
change the version number of this
assembly all you got to do is every
project within dotnet has called this
assembly info dot CS file so you expand
the properties folder get into assembly
info dot CS file and if you look at
there is an attribute called assembly
version in this file and this is the
major version this is the minor version
so for example let's say mine is a 2.0
version
I just put number 0 there build my
application what happens this
information will be returned into the
manifest of this assembly ok
but we have seen what is a manifest in
the previous session ok and to check if
it has been written properly we can use
the il desam tool and we discussed how
to use il desam tool in the previous
session so basically this is how you
change the version number of an assembly
using this assembly version attribute
now usually we change the major
you know the minor version depending on
the significance of the change but on
the other hand usually the build and
revision numbers we can default that to
a strict like that and when you compile
your application
you know the compiler basically assigns
to build and revision numbers okay
that's how we change the version number
and the next part of the assembly name
consists of the culture information now
most of the time you know the assemblies
are language neutral okay
especially when we are globalizing your
applications that we've that's when we
provide culture specific information
okay now to change the culture of an
assembly so if you look at the CAC which
is nothing but this particular part see
windows assembly in the GAC you see this
culture most of these assemblies are
actually language neutral but there
could be some assemblies with the
language you know here the language is
English so the culture is English here
similarly for other assemblies you might
have different cultures as well alright
so when when you specify a culture then
that assembly becomes a satellite
assembly now we will talk about
satellite assemblies in a later session
so let's not worry about them right now
but for most of the assemblies the
culture information will not be there by
default I mean if you want to specify
the culture information you use the
assembly culture attribute so here we
have the assembly culture attribute we
use that for example if you specify
anything apart from an empty string here
then this assembly is like a satellite
assembly which contains resources
specific to that culture but most of the
times the assemblies are language
neutral meaning main assemblies which
contains the main application code plus
the resources for you know basically
neutral culture okay so assembly culture
is usually empty all right and the final
important part of the assembly name is
the public key token so if you look at
the gag there is a public key token here
that is generated so how how did we get
this public he took and what's actually
happening here now in order to get the
public key token
you need to sign your assembly with a
private and a public key pair okay so
obviously if I have to sign the assembly
with a private and public key pair I
need the key file which contains those
keys so how do I get those keys now it
turns out within dotnet framework we
have a tool called a strong naming tool
we can use this particular tool to
actually generate the key pair and again
to use that tool we we go to the visual
studio command prompt because it's a
command-line tool okay so let's go to
start all programs Microsoft Visual
Studio 2010 Visual Studio Tools and
Visual Studio command from 2010 right
click run as administrator and here we
use that tool SN dot exe strong name dot
exe so SN dot exe and use the switch - K
to indicate that you want to generate a
key pair and then give the name I mean
specify where you want this key file to
be generated for example I want this
file to be generated may be my strong
keys and key files basically has an
extension of dot s and K so specify the
extension now when I press ENTER it's
going to write the private and public
key pair to that location so if I
navigate to C Drive now I should see
that key pair so somewhere here I should
see my strong keys so if I sort this by
date modified so my strong keys dot s
and K okay that's present in the C Drive
so let's copy that and then with an
assembly info dot C s file we have an
attribute called assembly key file
attribute which we use to strongly name
this assembly so how do we specify that
so I want to sign this assembly using
that attribute and to the constructor of
this assembly key file we pass in the
path of our
keyfile which is present in c colon
backslash and then specify that now if I
build the solution or this project
what's going to happen okay by the way
we have to escape that with another
backslash so let's rebuild again so when
we rebuild this rebuild all succeeded
what happens is this assembly is now
signed with a private and public key
pair this file basically contains these
two keys which will digitally sign I
mean which will sign this assembly with
this private and public key pair now
this assembly will have all the four
parts now how to look at those details
we'll know we'll talk about that in our
next session when we actually deploy
this assembly into the gap keep in mind
only strong named assemblies can be
deployed in to get now we spoke about
you know that in dotnet we have two
types of somebody's two types of
assemblies weak named and strong named
assemblies only strong named assemblies
can be deployed in to GAC can be copied
in together if you try to copy a weak
named assembly you will get an error
it's not possible
and then strong named assemblies are
guaranteed to be unique so they solve a
major problem called DLL hell okay so
but week named assemblies are not
guaranteed to be unique and and there is
a chance for DLL hell problem okay so we
will talk about what is DLL hell how to
solve it and what is GAC in a greater
detail in next session and how and when
to install an assembly into GAC we'll
talk about all these details in a very
great detail in the next session in this
session what we need to understand is
that an assembly consists an assembly
name basically consists of four parts
simple textual name version number
culture information and public key token
okay
an assembly is said to be a strongly
named assembly if it has got the simple
you know if you look at the next slide a
strong named assembly should have all of
the following it should have that simple
textual name the version number by
default most
the Assemblies have them in fact all the
Assemblies have them okay the difference
between weak named as someplace and
strong named as some places that week
named assemblies are not signed with a
private and public key pair and hence
that don't have a public heater okay and
whereas a strong named assembly is
signed with that private and public key
pair and strong named assemblies are
guaranteed to be unique so the assembly
is not signed with a public/private key
pair the assembly is weak named and not
guaranteed to be n unique and may cause
DLL hell but whereas that's not the case
with strong named assemblies and as I
told you in the next session we will
actually talk about what is gag how when
when we install an assembly into Jack
and the problem of DLL hell and the
solution to that on this slide you can
find resources for asp.net and C sharp
interview questions that's it for today
thank you for listening have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>