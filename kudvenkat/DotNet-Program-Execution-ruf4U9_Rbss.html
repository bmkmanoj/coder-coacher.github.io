<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DotNet Program Execution | Coder Coacher - Coaching Coders</title><meta content="DotNet Program Execution - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DotNet Program Execution</b></h2><h5 class="post__date">2012-07-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ruf4U9_Rbss" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to presume technologies I
am ring cat this is part one of dotnet
basics in this session we'll understand
how a dotnet program executes and to
understand this better we will compare a
pre dotnet program execution with dotnet
program execution now even before dotnet
came into existence we were developing
applications using programming languages
like maybe six C++ etc okay now when I
use vb 6 and develop a an application
you know let's say a pre dotnet
application and compile that using the
language compiler we know that an
assembly gets generated and by the way
assemblies have an extension of dot DLL
or dot exe depending on the type of
application that we are creating which
we'll talk about in a bit now so this
assembly is a native code or a machine
code format why in the first place do we
need to compile an application because
the operating system can only understand
zeros and ones they can't understand
high-level programming languages like C
C++ C sharp etc they are meant to be
used by programmers so programmers use
these high-level languages they
developed the application but whereas
you are underlying you know your
computer systems can only understand
zeros and ones so if your program has to
execute on top of that operating system
somebody in between has to convert that
high-level programming language into
zeros and ones which is nothing but the
machine code which that underlying
operating system can understand and to
do that we take the help of compilers
because it's practically impossible for
human beings to code using zeros and
ones that's why we have these high-level
programming languages ok so the problem
with this style of application execution
is that this application now look at
this I have a vb6 application a program
I compiled that I have this assembly
generated basically we deploy the
assembly on to a system to get executed
ok so this assembly is a native code
meaning this code this mesh
that is generated is native to that
operating system upon which this
application is compiled if I take this
program and try to run it on another
operating system for example in this
example let's say this is Windows
operating system now if I take this
assembly which is compiled on this
Windows operating system and if I try to
run it on a Linux or a UNIX operating
system it will fail to run why because
this code this machine level code is
native to that operating system upon
which it is compiled okay that's the
reason why it's called as native code
and some people also call it as object
code all right so that's the problem
with you know pre dotnet applications
the applications are not portable now
let's look at how a dart net application
executes okay now with the dotnet you
have the choice you know to pick your
programming language okay dotnet
supports several programming languages
like C sharp B be C++ and J shot out of
the box but there are several other
languages as well okay if we have a
compiler implemented within dotnet you
can use any programming language that's
why I have this other S box here okay
but these four sin shall be BC plus plus
and J sharp are the common dotnet
languages that are being used today so
when I use any of this programming
language and develop a dotnet
application and then when I compile a
dotnet application okay we get an
assembly here as well but this assembly
does not contain native code instead it
contains intermediate language so okay
that is the difference between a dotnet
assembly and a pre dotnet assembly okay
before dotnet you know the the
assemblies are in native code format but
with dotnet the assemblies are an
intermediate language format but keep in
mind the operating systems can you know
understand only zeros and ones so if you
run this assembly directly on top of the
operating system will the operating
system understand that no it will not
and it will fail to run that's why there
has to be somebody in between who will
convert this intermediate language into
native
which this operating system can
understand and who will do the job for
us the runtime environment called CLR
common language runtime environment and
how did the CLR come on this machine now
when I install dotnet on a computer
there are two important components that
gets installed okay one is the dotnet
framework class library and the other
one is the CLR the runtime environment
common language and time okay so this
CLR is the heart of dotnet program
execution so when the program tries to
run we know that intermediate language
cannot be understood by the operating
system so this assembly actually you
know it doesn't run directly on top of
the operating system okay there is a
layer in between called CLR within the
CLR this assembly tries to execute and
within that CLR we have another
important component called JIT compiler
which takes in intermediate language as
the input and M it's native code it
generates native code and this code can
be understood by this operating system
okay so if you look at this within
dotnet program execution we have two
steps one from source code to
intermediate language stand by the
respective language compiler okay from
source code to intermediate language
done by the respective language compiler
and then step to intermediate language
is converted into native code by the JIT
compiler and the JIT compiler is
residing on siela and what is CLR CLR is
the runtime environment for dotnet
applications and how did it get in there
when I installed artnet frame I mean
dotnet on a computer we have two
important components gets automatically
installed one is the framework class
library and the other one is the runtime
environment okay now what is the
advantage of executing a program like
this the number one advantage is
portability now let's assume this
operating system is vendors so on top of
this Windows operating system I have CLR
so obviously when this program executes
the CLR on on top of this Windows
operating system will take that
intermediate language okay at the time
the program is executing
JIT compiler will convert that
intermediate language into native code
which this underlying Windows operating
system can understand okay and along the
same lines let's say for example I have
UNIX operating system if this operating
system is uniques then we have a runtime
environment that is installed on that
operating system which is suitable for
UNIX which will convert the intermediate
language into native code which the
underlying UNIX operating system can
understand so what I mean to say here is
as long as the platform has the CLR
implemented on any of those platforms
your dotnet program can run okay because
the CLR the JIT compiler within the CLR
on top of that platform will take up the
responsibility of converting
intermediate language into native code
which that underlying operating system
can understand so this way dotnet
applications are portable from one
platform to another platform so this is
like this virtual environment which is
providing us with that capability not
only application portability and another
very important feature provided by CLR
is garbage collection now if you are
from a vb6 or a C++ background you know
usually when we are developing
applications let's say for example I
have a customer class I create an
instance of that customer class so what
happens memory gets allocated to that
object now after I am done using the
table jekt as a programmer address
I am responsible for D allocating the
memory for that object otherwise what
happens you know memory overflow
exceptions because you didn't clean the
object the objects tend to remain in
memory at some point the application is
going to break okay and often you know
novice developers tend to forget
cleaning up memory okay which will which
will present us with hard to detect
runtime errors or memory or flow
exceptions etc okay but whereas with
dotnet you don't have that headache
anymore okay you as a programmer create
objects use them and forget about it who
is going to clean those objects
afterwards garbage collection ok your
runtime environment has another
important component called garbage
collector
which will clean the objects that are
not in use we as programmers are not
responsible for memory management but
but before dotnet we were responsible
for memory management and we often used
to forget and present us with this
memory exceptions but with dotnet we
don't have that problem anymore right
now okay so if you look at CL are two
very important advantages that we have
discussed so far one is portability
application portability and the other
one is automatic memory management which
is also called as garbage collection
besides these two there are several
other benefits as well which we'll be
talking about in a later session so
there are a few points that we need to
recap you know so we know that when we
compile a dotnet application
intermediate language is generated and
different people call it with different
names you know some people call it as MS
il standing for Microsoft intermediate
language some people call it as SIL CIL
common intermediate language okay and it
is also often referred to as managed
code why do we call intermediate
language as managed code look at this
here who is managing how this program
runs your CLR okay so this intermediate
language which is the bright product of
compiling a dotnet application so this
intermediate language runs inside the
CLR and your CLR manages how this
application runs within that virtual
environment okay provides memory
management for example okay that's why
your CLR is managing that intermediate
language and hence it's called as
managed code
so it's also called as managed code and
on the other hand here we don't have any
kind of environment here in app read or
NetApp Legation this code directly runs
on top of the operating system okay so
there's no one managing those objects
there we as programmers are responsible
for that okay so this native code is
also called as unmanaged Cole
whereas intermediate language is called
as managed code okay and we have seen
Assemblies have an extension of dot DLL
or dot exe depending on the type of the
application for example if you look at
this very simple solution that I have
here it has got one project called
introduction to c-sharp and this is a
consuela application so if I right-click
the solution and then build solution and
then if I right-click on the project and
say open folder in Windows Explorer when
I say build what happens the source code
in this program gets compiled into an
assembly so when I open this folder by
right click on that and say open folder
in Windows Explorer and if I get into
the bin debug directory you see there a
dot exe this is nothing but the assembly
ok so since this is a console
application I get a dot exe but on the
other hand I can also add another new
project and if you look at this in this
console application we are using c-sharp
programming language now I can also
develop another project in the same
solution and I can choose a programming
language of my choice for example I want
to develop a visual basic program I can
do that instead of visual C shop I will
choose Visual Basic and then let's say
I'm developing a class library project
and click OK now you look at this it's a
VB project so it's possible within
dotnet you can use different programming
languages and now when I build this
solution and if I right click on this
class library project and say open
folder and Windows Explorer and if I get
into the bin directory and then debug
look at this we get a dot DLL so
basically the point I'm trying to prove
here is that depending on the type of
the application you are creating you get
DLL or a dot exe but they are nothing
but assemblies both of them for example
if I create a Windows application I get
another dot exe but whereas when I
create a web application I get a dot DL
okay irrespective of whether it is a dot
DLL or a dot exe both of them will be
intermediate language format if it is a
dotnet application but whereas pre
dotnet a vb6 or a C++ application before
dotnet when you compile that you still
use to get an assembly which is nothing
but dot DLL or dot exe but those
assemblies are in native code format
whereas dotnet assemblies are an
intermediate language format okay so
dotnet assemblies contain higher whereas
pre dot net assemblies contains native
code which is also called as machine
code or unmanaged code and the dotnet
application basic execution consists of
two steps okay one is the compilation
itself source code - intermediate
language and from intermediate language
- native code a platform specific native
code and who does that
JIT compiler and where is the JIT
compiler present it's present in the CLR
and what is CL are called as it's the
dotnet runtime environment so dotnet
runtime environment provides several
benefits garbage collection is one of
them application portability is another
advantage you know besides these two we
have several other advantages as well
which we'll be talking about in a later
session and dotnet supports different
programming languages which we have seen
c-sharp BBJ shop and c++ so if you look
at dotnet you know c-sharp vb c + + + j
sharp now except c + + - r vb + c sharp
you know they can only generate managed
code but whereas c++ can generate both
managed as well as unmanaged core
meaning native as well as intermediate
language
why have they given this flexibility for
c++ because before dotnet there were
several applications that have developed
in c++ for backward compatibility
you know from dot and applications to
predominant applications they have
provided us with this flexibility so if
there is ever an need for
you are not in the application to
generate native code then C++ is the
programming language that we have to be
using okay and another important thing
to keep in mind is that when you
basically run a dotnet application okay
we know that this intermediate language
now if you look at this the Assembly for
example if you take this project if I
open the folder in Windows Explorer
going to the ban if you look at this
assembly we know that a dotnet assembly
contains intermediate language okay so
this assembly contains intermediate
language when I run this program what
happens this intermediate language
within this assembly is converted into
native code by the CLR so where is that
native code stored it is stored memory
for the lifetime of the execution of
your application but when you close your
program what happens to this native code
is it stored anywhere no it is just
thrown away
okay so when I run my program again
what's gonna happen this assembly will
be loaded into CLR and the JIT compiler
will convert the intermediate language
into the native code and then the
program gets executed so every time you
run a program you know it has to convert
the intermediate language into native
code so obviously we have seen the
advantages of this two-step execution
model or this virtual environment
execution model within dotnet but what
are what is the disadvantage the
disadvantage is when you first learn a
dotnet
application because of this extra step
compilation or intermediate language
into native code okay
we'll take a little time and that's
almost negligible so when you run it on
an application first time it might be a
little slow but as you continue to use
it it it will be faster but the first
use it will be a little slow why because
there is that extra step of JIT
compilation just-in-time compilation
okay now this kind of a program
execution model is actually very much
similar to Java if you are a Java
programmer
then you might be you know your
we're for Java the runtime environment
is called as JVM Java Virtual Machine
okay and instead of intermediate
language in Java we have bytecode so
when you compile a java application what
happens byte codes are generated and
those byte codes run on top of the JVM
Java Virtual Machine which will convert
the byte codes into native code which
the underlying operating system can
understand
so in dotnet we are essentially
following the same approach the virtual
execution model alright
on the slide you can find resources for
asp.net and C sharp interview questions
that's it for today thank you for
listening have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>