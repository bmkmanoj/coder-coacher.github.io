<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 92   Significance of Thread Join and Thread IsAlive functions | Coder Coacher - Coaching Coders</title><meta content="Part 92   Significance of Thread Join and Thread IsAlive functions - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 92   Significance of Thread Join and Thread IsAlive functions</b></h2><h5 class="post__date">2014-03-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fjvMr12TU1Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this part 92 of c-sharp tutorial in this
video will discuss the significance of
threaded join and thread dot easily
functions with an example thread or join
blocks the current thread and makes it
wait until the thread on which join
method is invoked completes join method
also has a overload way we can specify
the timeout if we don't specify the
timeout the calling thread waits
indefinitely until the thread on which
join is invoke the completes this
overloaded join method way we can
specify the timeout returns a boolean
true if the thread has terminated
otherwise false join is particularly
useful when we need to wait and collect
result from a thread execution or if we
need to do some cleanup after the thread
has completed either live returns
boolean true if the thread is still
executing otherwise false let's look at
the usage of these two functions with an
example let's flick to visual studio at
the moment here we have got two static
functions thread one function and thread
dual function within the main method
let's actually print a message saying
main started
and then the main function is going to
create a worker thread let's call it t1
and let's make this thread execute this
thread one function so program dot
thread one function and then let's start
thread one in a similar fashion let's
create another thread and make that
execute thread to function and finally
let's print this message stating main
completed alright let's go ahead and run
this now okay look at the order in which
these messages are printed so first line
is going to be main started and then it
prints thread one function started
that's basically because we created
thread one this thread 1 is going to
execute that function so it printed that
message there and notice that next we
get main completed and then thread to
function started so what is happening
here now main function here this main
function you know when we run the
program we get one thread for three
that's our main thread you know that's
going to print this message and then the
main thread is now creating two
additional threads that is thread 1 and
thread 2 so once the main thread creates
an additional threat that is thread 1
and once it starts executing thread 1
function you know the main thread will
not wait for that thread one to complete
it will proceed to the next line so here
in the next line it's creating another
thread and then starting that thread
again here at this point the main thread
will not wait for a thread 1 or thread 2
to complete the work you know main
thread once it start starts the worker
threads it's going to proceed by default
to the next line you know in order to
execute that ok so sometimes you know
we may need to make the main thread wait
while worker threads are doing their
work you know probably because we want
to collect the result you know of the
worker threads and then based on that we
want the main thread to do something so
those are some you know situations where
we want the main thread to wait until
you know the third one and thread to
completes that's when join is
particularly useful okay so look at this
if I run this program once again you
know we get a different output look at
that main started thread one function
started thread two functions started and
then main completed okay so every time
we run this program these statements are
not guaranteed to be printed in any
particular order okay so that's the
nature of multi-threaded programming so
basically if you want to force the main
thread to wait until these worker
threads complete their execution then
you will have to use join method so now
let's say you know we started thread one
and thread two now if we want to force
this main thread to wait until the
thread 1 and thread to complete all we
are going to do is thread 1 dot join now
you know once this line is executed the
main thread is going to suspend its
execution and wait for thread 1 to
return from its method ok so once you
know this line has completed its
execution
we know that thread 1 has returned so we
can basically say thread 1 function
completed
similarly do to join now again the main
thread is going to wait until they're
the two completes its execution and
returns okay now let's go ahead and run
this now no matter how many times you
run this program you're going to get the
same output so thread one function start
at thread two functions started thread
one function completed thread to
function completed and then main
complete it okay so here we are
basically for saying the main thread to
wait until thread 1 and thread to
complete by using the join method right
now let's actually put you know some
sleep time here actually let's make this
thread sleep for 5 seconds so thread dot
sleep and let's specify the time in
milliseconds 5,000 milliseconds is 5
seconds and let's say thread one
function is about to return okay so
basically that 5 seconds have elapsed
and it's about to return that's what is
the message we're printing here all
right now let's go ahead and run this
and see what we get
so thread one function started thread
two functions started so you know the
main thread is waiting for you know
thread 1 to complete and then once
thread 1 has completed then you know it
it finished thread 2 you know that's
what is the message that's printed and
then main completed okay now there is
another overload of this join method way
we can specify the timeout so basically
there are three overloaded versions you
know the second overloaded version we
can specify the timeout value in
milliseconds so what is this timeout
that's basically the time that we are
willing to wait until you know the
thread completes its execution so for
example here if we specify thousand
milliseconds then the main thread is
going to wait only 4,000 milliseconds
that is one second until this thread one
returns
if thread 1 doesn't return within that
time out value then the main thread you
know well will continue to execute from
the line after that ok and one more
thing to notice here on this overloaded
version way we can specify the timeout
returns boolean that is true or false so
it returns true in case of the method
has completed execution and if it has
returned
otherwise false so let's basically say
if T 1 dot join you know of thousand set
milliseconds then we know that thread 1
function has completed else let's print
a message saying thread 1 function has
not completed in one second ok so let's
go ahead and run this and see what
output we get so look at that thread one
function started thread two functions
started thread one function has not
completed in one second and so it
continued to the next line thread to
function completed main completed and
then after that you know thread one
function you know came out from sleep
and then you know this message is
basically printed at that point of time
ok
all right let's change this function
slightly so here we are saying thread to
function completed but before we say
main completely let's actually check you
know whether if thread 1 is still alive
or not meaning whether if it is still
processing or not so T 1 dot is alive so
basically this method is returning a
boolean and that boolean indicates the
execution status of the current thread
whether it has been completed or it is
still processing if it is still
processing then it is going to return
true otherwise false so if T 1 dot is
alive
we know that thread 1 is still doing its
work
so let's actually print a message saying
thread 1 function is
still doing its work else if it's not
alive then we know for sure thread one
has completed so let's print that
message right here let's go ahead and
run this
so thread one function started the two
functions started thread 1/2 function
has not completed in one second thread
to function completed and then you know
it checks this ISA live actually
returned false there I mean true there
and as a result thread one function is
still doing its work that's what is the
message printed and then it prints main
completed and then after that line is
printed you know
thread 1 function has finished its job
so it's going to print that message
there thread one function is about
written now let's say we want to
repeatedly you know check whether if
thread 1 is alive or not maybe every 500
milliseconds and in order to do that
let's actually put this in a for loop
so for int I is equal to 1 let's say I
less than or equal to 10 I plus plus now
if T 1 dot is alive if it is still alive
let's bring this message thread one
function is still doing its work and
then let's make the current thread sleep
for maybe 500 milliseconds okay if it is
not alive meaning it has completed
execution then in that case print this
message thread one function completed
and then maybe break out of the loop
because there's no point in checking we
know that it has completed execution
okay with this change let's go ahead and
run this and see what output we get so
thread one function started thread two
functions started look at this here it's
in that loop it's checking and then look
at what we get thread one function is
about to return thread one function
completed and finally main completed so
basically the idea here is to understand
the purpose of ISA live
a threat or join and we have seen the
usage of therm with the help of this
example that's it for today thank you
for listening
have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>