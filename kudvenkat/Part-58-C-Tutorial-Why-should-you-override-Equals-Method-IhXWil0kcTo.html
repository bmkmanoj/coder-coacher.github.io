<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 58 C# Tutorial Why should you override Equals Method | Coder Coacher - Coaching Coders</title><meta content="Part 58 C# Tutorial Why should you override Equals Method - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 58 C# Tutorial Why should you override Equals Method</b></h2><h5 class="post__date">2012-07-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IhXWil0kcTo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to prism technologies I
drank it this is pad 58 in this session
we'll understand what is equals method
and the reasons to overwrite that let's
say I have two integer variables I and J
mode carrying value 10 so in the I
equals 10 and J equals 10 let's say I
want to check if these values are equal
and there are two ways to do that one is
i equal to j so obviously we are using
the comparison operator and the other
way to check that is to actually use AI
and look at that when i say dot you see
that there is a method called equals
okay so where is that equals method
coming from okay now we know that with
no net everytime directly or indirectly
inherits from system or object and if
you look at system data object so if you
look at the system that object type and
I right-click and select go to
definition you see that there is an
equals method okay so and and if you
observe it's a virtual method meaning it
has some default implementation okay so
what what is the use in this equals
method it basically checks the Equality
of values for example here I is carrying
a value of 10 J's Carrie is carrying a
value of 10 so are those values equal if
they are then that method returns true
and look at this it's virtual meaning it
has a default implementation in this
system good object class and if the
derived types want to override that
that's possible okay but for value types
we don't have to necessarily do that
okay let's understand that a bit more so
but understand you know for the time
being this equals method is actually
coming from system object and keep in
mind system object actually provides you
know the equals method get' hash pool
and then to string method which we have
seen and as well get type so if you look
at this equals get type
get hashcode and to string all these
four methods actually will be present on
any type with Internet framework because
every type directly or indirectly and
headed from system object okay so now if
I want to compare the values of I to J I
can use the comparison operator I can
also use the equals method now look at
this but we learn this okay both of them
returns true okay I is equal to J PI dot
equals see both of them returns true and
along the same lines let's say for
example enums we know their value types
let's say I have an enum called
direction for example so public in um
let's say direction is the mm and
obviously we know the directions east
west north and south so let's say East
equals one
West equals two north equals three and
South equals four okay now I can create
a variable of you know type direction
enum let's say direction let's call this
direction one let's say that's east and
along the same lines let's create
another direction and let's say this is
direction too now just like how you're
comparing you know integer types you can
also compare enums in spite of their
underlying values you know we know that
the underlying values for these enums by
default is an integer if you don't know
what items are and when we should be
using enums we have a video recorded on
that so i strongly suggest you know
checking that video first so direction
one dot equals direction to okay so now
if we run since enum is also value type
and values you know basically equal to
operator and equals method both of them
returns true because they are the same
but on the other hand if you just say
okay instead of East
save vest and obviously both of them now
should actually return false so both of
them return false and that makes sense
now
this equals and you know the equals
method and equal to operator both of
them work as expected if these are
simple types but however when it comes
to reference types let's say for example
I have a class okay let's say I have a
class called customer and this class has
got two public properties let's say
public strengths maybe first main let's
make this an auto implemented property
with a default get them set accessors
and along the same lines
let's have last name alright a very
simple class that we have here let's
create an instance of this customer
class so customer c1 is the equal to new
customer let's see 1 dot first-name
sequel to Simon and maybe see one dot
last name is equal to 10 all right
and then let's create another customer
object customers see do but I'm not
going to name this but I'm just going to
say ok c2 is equal to c1 so now with
this good you should have understood all
delay you know there are two object
reference variables here but the object
itself is one okay if you're not sure
about the object reference variables and
objects you know the difference between
them I strongly encourage you to check
the video on classes introduction in the
series ok now if you look at this in
this example we have two object
reference variables c1 and c2 okay these
two reside on the stack whereas the
object itself the customer object is 1
ok so both of these reference variables
are pointing to that object ok so we
have two different object reference
variables by the object itself is 1 ok
now let's see how these are going to
work
so when I say C 1 is equal to C 2 and
similarly C 1 equals C 2 now if you look
at this technically and we run this both
of them returns true and that makes
sense because look at this actually in
c-sharp when we are comparing reference
types there are two things that we were
talking about equality here one is the
reference equality or the object
reference variables pointing to the same
object that is the same references are
they pointing to the same object in that
case if they are pointing to the same
then we say the references are equal and
obviously when references are equal the
values will also tend to be equal
because it's the same object
okay now whether you say c1 dot first
name or c2 that first name you end up
getting Simon why because both of them
are actually pointing to the same object
so when two object reference variables
are pointing to the same object
operations on one variable will affect
the values contained by another variable
why because they point to the same
object okay so the point to keep in mind
here is if two reference variables fall
into the same object we have reference
equality there and at the same time
values equality as well because the
first and last name of c1 is the same as
first and last name of c2 they both the
first name assignment the last name is
tab so when references are equal the
values will automatically become equal
at the point to the same object okay so
here it returns true in both the cases
wishes you know very much valid but on
the other hand let's say I'm going to
create another instance of this another
new customer but this time what I'm
going to do is I'm creating another new
object altogether okay now c1 and c2 are
pointing to two different objects
together so obviously they are not
pointing to the same object they are not
referring to the same object so the
reference equality which is this double
equals will be false
but if you look at the values that are
carried by Siwon Simon is the first main
Thanh is the last name similarly for C -
Simon is the first name Thanh is the
last name ok so the value equality is
there but there is no reference equality
why because these two reference
variables are now pointing to different
objects on the heap okay so the point to
keep in mind if reference equality is
true then obviously the value will value
equality will also become true but on
the other hand value equality does not
guarantee reference equality and
remember when it comes to reference
types by default the double equals
comparison operator you know gives us
reference equality whereas the equals
method you know should be giving the
value equality but now when I run both
the reference equality and value
equality returns false which doesn't
make sense here because why will gets he
do you know the first and last name are
same as that our first and last name of
Siwon okay so the value equality should
be true but reference ability is false
and that makes sense because they are
two different references to objects all
right so this is the reason when we
actually have to override the equals
method to ensure we get what we expect
okay and the reason why we get false is
that because of the default
implementation because you know the
default implementation that's coming
from base class design now what property
is to check for the equality okay that's
when we will override that inherited
virtual equals method from system object
so let's see how to array that and it's
very simple to override so override what
we want to override the equals method
and look at that the moment I select
that I get the signature of the method
now what we need to do first of all look
at this what we are passing in is the
object type we are not passing in the
customer object if you remember this two
string I mean sorry this equals method
is actually coming from system object
type
okay so system the object if you look at
the signature and system to object what
we are passing in here an object type so
that the signature has to match the
signature because why we are overriding
that okay so now the past in parameter
to compare you know should not be now so
what you need to check
so if object the past in parameter if it
is now then are they equal no they are
not equal so what should you do you
should return false and similarly you
know if they don't pass in customer
object okay or any type that is derived
from customer object if they don't pass
and that then it doesn't make sense to
compare you cannot compare a customer
objects first name with maybe an
employee names in ROI a ID okay but you
know you have to compare to customer
objects together okay it can be customer
type or it can be any other type derived
from customer class because let's say
for example you have a customer class
from the customer class there might be
you know banking customer or corporate
customer and retail customer
okay so inherited types can also be
passed in because why you know inherited
types are again your specialized types
of your base type okay again if you're
not sure about inheritance please check
the video tutorial on inheritance in
this video series okay so another check
let me need to pass and if the passed in
object is not the customer type or if
it's not an inherited member of the
customer type then we want to return
false why because you cannot compare it
otherwise okay so if that object is
customer if that's customer fine but if
it is not customer then what we need to
do we need to basically return false so
if the person object cannot be typecast
it to customer or if it's or customer
type then just return
Falls and finally what we need to check
the past in objects first and last name
should be equal to this instance of
first and last name so we want to return
this dot first name should be equal to
past in objects first name but if you
look at that past in object doesn't have
first name property why because that is
system that object it's the base type so
what we need to do we need to type gas
this to customer type okay if we are not
able to do this then it would have
already returned false so we wouldn't we
wouldn't get we would never get to this
line so customer dot first name so they
should be equal and along the same lines
the last name should also be equal so
what you can do just copy that that's it
so if they are equal then return true
otherwise written forms okay so now if
we run this for the value equality since
we have overridden that it still you
know returning false let's see why okay
we have Simon tan both of the values are
equal let's look at the implementation
okay the first name should be equal to
the first name of the passed in object
similarly the last name should be equal
to the past ten last name so it looks
fine but for some reason we are still
getting false so let's see why let's put
a breakpoint and let's debug that okay
let's put a breakpoint against this one
run this okay so we got there
let's press f11 so we get into the
override
so object is not now because we passed
in the customer object so let's press
f10 so object ease of type customer so
obviously we don't get that and look at
this this dot first name what's the
first name Simon and similarly the
objects oh look at that the past in
objects first name properties now let us
see why it is now okay look at that
that's the problem here see one dot
first time because we copy pasted this
code here that's why that's why see when
that first name and see one dot last
name it should be c2 dot first name and
c2 dot last name so let's correct that
so this is how you know when you copy
copy paste code you should be extremely
cautious you know these are the blenders
of copy-paste so now if we run that we
should get the value equal to true but
however there is a slight issue here the
issue is if you look at this there is a
green squiggly and we know that within
dotnet framework if it's a green
squiggly then it's a warning and not an
error and if you look at the warning it
says okay the customer class overrides
object dot equals but doesn't overwrite
object or get hash code so if you look
at system dot object class it has equals
method and at the same time it has get
hash code okay so in your class if you
are overriding equals it's also
recommended that you override cat cash
cool otherwise the hash codes are not
guaranteed to be unique that's why it's
a very good practice to actually
override the get hashcode method as well
and it's very simple to override that
okay so let's see how to overwrite the
get hash code so that we get rid of this
warning and to do that overwrite and
then plus space and you have that get
hashcode method just select that and you
get the you know syntax of the method
and what we need to do here is return
the hash code if you look at this
property in this class it has got two
of these first and last name so return
the hashcode of these two properties and
that should be it so rhythm this dot
first name don't get hash code and that
with this dot last name dot get hash
good that's it
so now if you rebuild your solution you
should have got rid of that warning so
that's gone now you don't have any
warning now and obviously run this you
know for the reference equality we get
false but for value equality we get true
so obviously if you want the objects to
be comparable in a proper way
you have to override the equals method
and when you are overwriting the equals
method keep in mind you have to check in
the past an object is now R and if you
can typecast the object to the type that
you are comparing against in our case
this is customer so we should be in a
position to type class that to be of
type customer and then compare the
properties that you want to check for
the equality and return true or false
depending on equality all right on this
slide you can find resources phrase we
don't need an C sharp interview
questions that's it for today
thank you for listening have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>