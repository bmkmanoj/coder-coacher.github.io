<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 55   C# Tutorial   Late binding using reflection | Coder Coacher - Coaching Coders</title><meta content="Part 55   C# Tutorial   Late binding using reflection - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 55   C# Tutorial   Late binding using reflection</b></h2><h5 class="post__date">2012-07-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/s0eIgl5iqqQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to pledging technologies I
am venket this is part 55 late binding
using reflection if you haven't watched
part 53 reflection basics I would
strongly encourage you to do so before
continuing with this session now in this
session we'll understand what early
binding and late binding mean and the
difference between the two approaches so
let's start with an example as usual
okay so if you look at this code here I
have got a customer class and within
this customer class we have a get full
name method and the written type of that
matter is obviously string and it takes
in two parameters first name and last
name so what this method does is
concatenates them together and return
the full name of that customer so now
let's say if I want to use this customer
class the way we do it is okay customer
c1 is equal to new customer so we are
creating the instance of that customer
class and then if I have to invoke the
method get full name we say c1 get full
name passing in the first and last name
let's say the first name is praveen and
the last name is Tech okay and we know
that this method returns a string so we
use a string variable to hold the
returned value so let's say string full
name is equal to that and what we do in
order to print it we use the console dot
readline method sulu name is equal to
and then we pass in the full name so if
you look at this it's pretty simple and
we have been doing this kind of coding
all this while so if we run this now as
you might expect it will print the full
name okay so what is this this is
nothing but early binding okay at
compile time we have the information
about this customer class we know about
that class so we are creating that
instance you know instance of that class
now let us say when I am invoking this
method by mistake instead of get full
name if I just put an S there you know a
typo and if I look at this one I already
got a red squiggly indicating that you
know Kuster
ma does not contain a definition for
kept full names okay so if you make any
spelling mistakes in a dues will be
flagged at compile time itself
not only that instead of you know that
this get full name method if you look at
that when I highlight mouse over this
method the intelligence clearly shows me
this method is going to return a string
datatype and it's going to expect two
string parameters now instead of a
string parameter here if I pass in
something like an integer ten for
example even that will be flagged
immediately at compile time as an error
okay so the possibility in early binding
you know all the errors in any spelling
mistakes or tightness matches in terms
of passing and parameters or the return
values all of these are detected at
compile time itself so the probability
of you know runtime exceptions because
of type mismatches and spelling mistakes
is very less in early binding in fact
it's not possible if you misspell that
your program will not even compile so
forget about running it okay so most of
the errors can be detected at compile
time itself in early binding okay but
when we look at the late binding that's
when you'll understand the problems of
late binding and we will see what late
binding is in just a while but for the
time being what you need to understand
that is that you know when you have the
knowledge of the class for which you're
creating an instance at compile time
then you usually use early binding and
99.99% of the scenario and in reality we
use early bionics and it's very rare
that we use late binding first of all
let's look at an example of using late
binding and then we will discuss the
difference between early binding and
late binding okay so this is pretty
simple this is laid by early binding
let's comment and keep this code okay
now how we do late binding first of all
we will do late binding only when we do
not have the knowledge of the class for
which we are creating an instance at
compile time let's say that this
customer class itself is not there at
compile time so if I comment that you
know obviously it's as good as saying we
don't have
the customer class at compile-time so
let's keep it commented for the time
being okay but what I want to do
basically is I want to invoke this class
in spite of not being available at
compile time you know at runtime and I
run this program I should be able to
create an instance of this class and I
want to be in a position to invoke this
method but now if you try to create an
instance of a class about which you
don't have information at the compile
time look at this I have a red squiggly
indicating that the type or namespace
name customer could not be found
are you missing a using directive or an
assembly reference and that does and
that makes sense because there's no
customer class here so what are you
trying to do so in situations like this
way you don't have information of the
type which you want to instantiate you
know it's not available at compile time
then you are late binding if it's
available we go for early binding so
let's see the cool for late binding now
first of all you will have to load the
assembly which contains your class now
obviously this program you know this
project when I compile that it will be
compiled into this assembly introduction
to c-sharp okay
so ultimately we'll have our class
within the same project so we need to
load this assembly and to load the
assembly we can use the assembly class
and by the way if you want to do any
reflection all the reflection related
classes are present and system works
reflection namespace so let's go ahead
and import that and then with this we
have an assembly class so assembly let's
call this executing assembly because our
class is also going to be present in the
same assembly and this is the executing
assembly in the sense when we run this
program this the cool within this
assembly gets executed so executing
assembly is equal to what I want to do
is I want to load the assembly and to do
that we have this method assembly dot
get executing assembly there's a method
called get executing assembly and then
what this method basically does is it
looks at the program okay
the program is currently executing and
this is the assembly you know when this
method main letter gets executed where
is this main method present it's present
within this project so obviously within
this assembly this main method is
present and our customer classes is
going to reside in the same project so
we are loading the current executing
assembly okay
so once I have the executing assembly
within that assembly within this
assembly we have two types in the sense
two classes what are they
main class and customer class but what
we want to do here we want to load the
customer class and instantiate that
dynamically at runtime so we need to get
the type information about that customer
class and to do that the maybe you do it
is we use the executing assembly dot get
type so there is a method now if you say
get two types it will return you the
type array but we want the type just one
type which is nothing but the customer
class so get type and then if you look
at that it is expecting the name of the
type so let's pass in the name of the
type now if customer class is going to
reside in this assembly then the fully
qualified name of this class is presumed
dot customer so we need to pass in the
fully qualified name soup regime dot
customer if you don't pass in the fully
qualified name then you risk a null
reference exception we look at that just
in a bit okay so if you look at this ket
type what is this method returning back
this method is returning it type back
and we have seen this in part 53 so type
and let's say what is this type customer
type we know that we will get a customer
type back now look at this I don't have
this customer class but still if I
compile this
it will happily build without any
problem because look at this we don't
need to have that customer let's compile
the met runtime it check
this assembly okay this is this type is
there then it loads that into this
otherwise it would be now okay so
alright so the second step is to get the
type now not only that once we get the
type we need to get the method okay
which we want to execute but before that
we need to create an instance of this
particular class look at this when I say
get type I get the type of this class
which is nothing but the customer class
so once I have the type I need to
instantiate that and to do that the way
we do it is we use you know activator
there's a class called activator class
within the system namespace activated or
there is a method called create instance
and this method okay we want to create
an instance of this customer type so we
pass in the customer type and this
method will create an instance for us
look at that that returns an object back
because you don't know the type at the
time beings you have to use the object
type so we will call this object
customer and stands see photo create
instance so we got the customer instance
we have the customer type we have the
customer instance the next thing to do
is to get the method information that
you want to exceed we know that the
customer class is going to contain get
full name method so we want to get the
information about that method and to do
that you can use the custom because the
method is present in the customer class
okay customer type so on that type you
can say customer type not instance so
customer type dot get method look at
that what is this going to return this
is going to return a method info object
and remember we have spoken about this
in part 53 so if you haven't watched
that video I would strongly encourage
you to do so before continuing with the
session all right so this
get method okay method is actually
expecting the name of the method that
you want the information about which in
our case is get full name so we need to
pass that in here so get full name
that's the name of the matter you just
need to pass in the name of the method
so get full name so what is this going
to return this is going to return an
object of type method info so we need a
reference variable to hold that so
Method info and let's call this as now
just to give it a meaningful name get
full name method alright so we have this
method now so we have got the instance
of the object we have the method itself
that we want to invoke but there is
another thing that we need to do before
we actually invoke this method what is
that this method actually expects two
parameters first name and last name so
we need to create those parameters as
well and if you look at the parameter
types there string types okay
so let's create a string array to hold
both of these parameters and to do that
let's create a string array and let's
call that as parameters is equal to new
string array and since the size is two I
mean we have two parameters let's make
the sizes two and parameters of zero
that's the first name parameter so you
can pass in your first name there may be
the first name I want to display game
and similarly we want to pass in the
second parameter and maybe we'll call
this technologies alright so we have the
parameters we have the method that we
want to invoke and we have an instance
why we need instance because this method
is an instance method and not a static
method if it's a static method we might
not require the instance we might just
require the type okay
but since this is an instance method we
require the instance as well that's why
we created the instance of this customer
type using create instance method
alright so now last
step is to invoke the method and this is
what is interesting now usually in early
binding to invert the method what we
will do we will say object dot the
instance method but here you cannot say
customer instance dot get full my
because this is of type object this is
not your customer class if customer
class don't even exist at this time now
it is at compile time you don't have any
information about it whatsoever all
right
so there should be a way to do that and
the way to do that is the method that we
want to invoke is this capsule name
method so this is the method and then on
this method there is a method which we
can call the invoke so I want to invoke
this method now if you want to invoke
that method since this is an instance
method it requires an object using which
it can actually invoke this method so
where is that object you have to pass
the 10 and remember we have created an
instance of our class so we pass that
object 10 and the next thing look at
this guy's and it's pretty simple to
understand to execute capsule name
method it requires two things one the
instance of the class and two the
parameters that it needs okay so those
two things we have to pass and to invoke
this method so we want to invoke this
method but it requires two pieces of
information one is the customer instance
I mean the object itself and the other
one is the list of parameters that it
requires which are nothing but these so
pass it the parameters and and see your
intelligence tells you that okay look at
that the first one is the object that we
have to pass in and the next one is the
parameters our object array now it's
interesting to notice here it is
expecting an object array and not is
triggering and that makes sense
because you never know what are the
different types for other methods going
to be
okay and from inheritance session we
know that you know every type directly
or indirectly inherits from the system
object type so now this will be casted
to the parent type all right so that's
why since since you know string directly
or indirectly inherits from the system
object type you can pass in a string
array object array okay alright and if
you look at the in work methods return
type you get this again it's object but
in our case what is the return type of
get full name it's a string okay but
again string directly or indirectly in
inherits from system to object so it's
okay so what you can do so when this
method gets called what are you
expecting back you are expecting a full
name back so create a variable maybe
string full name so this variable is
going to receive whatever this method is
going to return back but if you look at
this this method returns an object and
you're trying to convert that to a
string that which is not possible okay
implicitly so you need to do an explicit
cast so string okay so we have our full
name now all that is left out is to
print that full length control dot
readline full name is equal to full name
look at this the amount of kouddous is
like four to five lines of code but it's
pretty simple I mean if you logically
understand that you know go from the
reverse if I have to invoke a method
dynamically you know whether you want to
invoke a method using early binding or
late binding all you need is okay the
instance to invoke it and the parameters
okay I don't care how you get them but I
need both of them to execute that method
so if I have to get the instance of the
customer class what we need to do we
need to first Lieut the assembly which
has caught that class from that assembly
we need to get the type of the customer
class and then we need to create an
instance of that customer class so
basically these three steps is to create
an instance customer class and
then this step is to get the method
which we want to execute and this step
is to prepare the parameter that this
method expects and finally invoke the
method passing in the customer instance
and the parameters list and then
typecasted return type to what you are
expecting in our case it's string time
and then finally print it out that's it
okay it's a little bit of code but
definitely late binding code is a little
complex than early binding so obviously
now if we run this okay there is an
unhandled exception which is bad so
let's see where we are getting this an
unhandled exception it's saying value
cannot be null and it says the error is
at line number 13 let's see end and fix
the issue
so line 13 so control g13 let's see
where is that so for some reason here we
are getting in at an error and obviously
it makes sense because we don't have
this class yet so what you need to do is
uncomment this because at runtime this
needs to be available right look at this
so you are expecting some assembly and
class to be present at runtime if they
don't obviously you'll get another
reference exception so now when we run
this you should say presume technology
is the full name okay but on the other
hand look at this guy's
if you misspelled the name of the method
okay and if you build this it will build
without any problems so bill succeeded
but when you learn it at runtime you
will get a null reference exception why
because get full names you know when it
tries to get that method it will be now
and you're trying to invoke call and
invoke method on a null object so
obviously you will get a null reference
exception so that's why these names you
know you shouldn't be misspelling or
passing in the wrong types not only
names even if you pass in a wrong type
instead of a string parameter if I pass
in an integer parameter you know the
code will compile but in runtime
when you try to pass those in we will
have problems runtime errors okay so
that's about late binding but keep in
mind guys late binding you know it has
got first of all it's complicated number
one and number two it has got
performance issues as well because it
has to load an external assembly resolve
the type create an instance of that at
runtime and a lot of things has to
happen and obviously late binding is
much slower than early binding so 99% of
the time prefer early binding / late
binding because it has got much
performance and not only that in early
binding we can flag out any compile time
errors like misspelling mismatches or
type mismatches but in late binding will
not come to know about them until you
actually run your application so if you
look at the code for early binding on
the slide you can see that it's just
realizes it's pretty simple and
straightforward but late binding has got
a no significant amount of work to be
done and if you look at the differences
between early binding and late binding
early binding can flag errors at compile
time with late binding there is a risk
of runtime exceptions
early binding is much better for
performance and should always be
preferred over late binding use late
binding only only when working with an
objects working with objects that are
not available at compile time all right
on this slide you can find resources for
asp.net and C show up interview
questions that's it for today thank you
for listening have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>