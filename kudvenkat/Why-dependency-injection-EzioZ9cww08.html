<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why dependency injection | Coder Coacher - Coaching Coders</title><meta content="Why dependency injection - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why dependency injection</b></h2><h5 class="post__date">2017-08-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EzioZ9cww08" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is part 33 of angular 2 tutorial in
part 32 of this video series we
discussed what is dependency injection
and how it is implemented
in angular in this video we'll discuss
why should we use dependency injection
and the benefits it provide so let's
understand this with a very simple
example let's say we want to build a
computer in reality to build a computer
we might need several objects like
processor RAM hardest Drive etc to keep
our example simple let's say we just
need a processor object to build a
computer so our computer and processor
classes are as shown right here notice
at the moment we are not using any
dependency injection computer class has
a dependency on the processor class so
to build a computer we need a processor
object and a computer class itself is
creating an instance of the processor
class using the new keyword this is the
programming style that most of us are
used to and it is easy to understand as
well but there are three fundamental
problems with this piece of code so
let's understand what these problems are
and how dependency injection solves them
this code is difficult to maintain over
time in just a bit we'll understand why
this code is difficult to maintain with
an example now if you look at this
computer class it has a dependency on
the processor class and here the
computer class is creating an instance
of the dependency that is an instance of
the processor class itself now this
processor instance is local to this
computer class so we cannot use this
processor instance to share data and
logic with other objects so to
generalize this we can say instances of
dependencies created by a class that
needs those dependencies are local to
the class and cannot share data and
logic again if this is not clear at the
moment don't worry we'll understand this
with an example in just a bit and
finally this piece of code is also hard
to unit test and we'll understand why in
just a bit so let's understand these
problems in detail one by one and also
see how dependency injection can solve
them first let's understand why this
code is difficult to maintain over time
at the moment this is how a computer and
processor classes looks like notice at
the moment the processor class
constructor does not have any parameters
and within the computer class to create
an instance of the processor class using
its empty constructor so everything
works no compilation errors whatsoever
now let's say our requirements have
changed and for us to be able to create
an instance of this processor class we
need to tell it the speed one way to
address this requirement is by
introducing a parameter to the processor
class constructor so we are passing
speed to the processor class constructor
the moment we make this change the
computer class breaks because here we
are creating an instance of the
processor class using its empty
constructor and at the moment the
processor class does not have any empty
constructor to be able to create an
instance of the processor class we will
have to supply a value for this
parameter otherwise we get a compiler in
error so every time the processor class
changes the computer class also need to
change and here we have shown a
dependency on only one object that is
processor but in reality to build a
computer it may have dependency on
several other objects like memory hard
test drive etc so those dependencies in
turn may also have other dependencies
and anytime these dependencies change
the computer class may also need to
change
hence this code is difficult to maintain
over time here is that same piece of
code that we have seen on the slide at
the moment the processor class
constructor does not have any parameters
and within the computer class we are
using the empty constructor to create an
instance of the processor so all works
no compilation errors or
now the moment we introduce a parameter
to the processor class constructor we
get a compiler shanira notice we have a
red squiggly indicating that we have an
error so every time the processor class
changes the computer class also need to
change
hence this code is difficult to maintain
over time now let's see how dependency
injection can solve this problem but
before that let's understand why do we
have this problem the reason we have
this problem is because the computer
class itself is creating an instance of
its dependency in this case an instance
of the processor class instead if an
external source can create an instance
of this processor class and provide it
to the computer class then this problem
can be very easily solved and that's
exactly what dependency injection does
and on this slide right here we can see
the same example rewritten using
dependency injection notice with
dependency injection the computer class
itself is not directly creating an
instance of the processor class instead
it just specified it has a dependency on
the processor class using its
constructor now an external source that
is the angular injector in this case is
going to create an instance of the
processor class and provide it to the
computer class when required because now
we have an external source that is
creating and injecting the dependencies
required by the computer class whenever
those dependencies change the computer
class need not change and here we have
another example notice here we have
changed the dependency that is the
processor class by introducing speed
parameter but notice the code within the
computer class has not changed in any
way
so bottom line with dependency injection
we have an external source that is
creating and injecting dependencies when
required so when these dependencies
change the computer class need not
change here is that same example notice
at the moment we are using dependency
injection we discussed what is
dependency injection and
it is implemented in angular in our
previous video for you to understand
this example better please first watch
that video now notice when the
dependency that is the processor class
changes we don't have to change the
computer class because now the
dependency injection the computer Clause
is not directly creating an instance of
the processor class so that is one of
the benefits of dependency injection
when the dependencies change the
computer class need not change now let's
understand the second problem instances
of dependencies created by a class that
needs those dependencies are local to
the class and cannot share data and
logic so if we relate this to our
example the processor instance created
by the computer class is local to that
computer class that means we cannot
share that processor object with other
objects sharing a processor object
doesn't make much sense so let's
understand this with another example now
let's say we have a service called user
preferences service that keeps track of
user preferences like color font size
etc now what we want to be able to do is
share this user preferences data across
all components within our application
now in the component class if we create
an instance of this user preference
service class using the new keyword like
we did in the computer class then that
component is going to get a local
instance of that user preference service
and the data it has cannot be shared by
other components so for example if we
have 10 components we end up creating 10
instances of this service one for each
component and that instance is local to
that component which has created it so
the data and functionality it has cannot
be shared by other components now let's
see how dependency injection is going to
solve this problem with DI the angular
injector provides a single term that is
a single instance of the service let's
understand this with an example let's
say we have a component called component
1 which needs an instance of
user preference service now the
component itself is not going to create
an instance of that service because we
are using dependency injection so the
angular injector is going to create and
inject the service instance into
component one so the first thing the
angular injector does is alright you
need an instance of user preference
service so first let me check if I
already have an instance in this case it
doesn't because this is the first
component that has requested it so the
angular injector is going to create an
instance of the user preference service
and inject that into component one now
we have another component component two
which needs an instance of user prevent
service so the angular injector again
does the same check do I already have an
existing instance in this case it does
so it's going to provide that existing
instance to component two along the same
lines if another component requires the
user preference service instance it's
going to inject that same existing
instance into that component as well so
in this case the same service instance
is being shared by all the components so
sharing data and logic becomes much
easier if this example is a bit
difficult to digest please do not worry
in our next video well discuss the same
thing with the working example and it
should be much clearer at that point now
let's understand our third problem why
is the space of code hard to unit test
here the computer class itself is
creating an instance of its dependency
in this case an instance of the
processor class so this makes it
difficult to mock the processor object
which in turn makes a difficult unit
testing computer class at the moment the
computer class has only one dependency
that is a dependency on the processor
but in a real world application it may
have several dependencies and those
dependencies in turn can have other
dependencies with all these hierarchies
of dependencies just imagine how
complicated the unit testing can become
if we do not have the ability to mock
those dependencies with dependency
injection it is very easy to mock
dependencies in fact that is one of the
greatest benefits of dependency
injection now if you're new to unit
testing and mocking it may be difficult
for you to understand why unit testing
can get difficult and complicated if we
don't have the ability to mark
dependencies in our upcoming videos
well discuss unit testing and mocking in
detail so at that point it should be
much clearer so in summary here are the
three main benefits provided by d-i
create applications that are easy to
write and maintain over time as the
application evolves easy to share data
and functionality as the angular
injector provides a single term that is
a single instance of the service easy to
write and maintain unit tests as the
dependencies can be very easily marked
thank you for listening and have a great
day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>