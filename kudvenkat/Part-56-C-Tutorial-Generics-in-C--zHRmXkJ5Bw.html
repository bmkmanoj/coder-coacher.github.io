<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 56   C# Tutorial   Generics in C# | Coder Coacher - Coaching Coders</title><meta content="Part 56   C# Tutorial   Generics in C# - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 56   C# Tutorial   Generics in C#</b></h2><h5 class="post__date">2012-07-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-zHRmXkJ5Bw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to prism technologies i'm
venket this is part 56 generics in this
session we'll understand the basics of
generics and the advantages of using
generics now general exit introduced in
c-sharp 2.0 generics basically allow us
to design classes and methods decoupled
from the data types which will allow our
code to be reused with any data type
let's understand what we mean by this
with an example now here you can see a
very simple calculator class which has
got an R equal method and if you look at
this method it's very simple all it's
doing is it's taking in two values of
type integer comparing those two if
they're equal it returns true otherwise
it returns false now let's see how to
use this method let's say boolean equal
is equal to since the method is a static
method I can just use the name of the
class instead of creating an instance of
that let's say for example if I pass 1
comma 2 they are not equal and then if
equal we want to say the numbers are
equal otherwise not equal very simple
code if we run this obviously since
these are not equal it will print not
equal that's fine but then the issue
here is if you look at this calculator
class and this are equal method now this
are equal method is actually tied to the
data type now let's say the user wants
to compare two strings if they are equal
or the user wants to compare two
characters if they are equal now can he
use this method he cannot because this
method only works with integer data type
so your method is basically now tightly
coupled with the data type that it
operates on okay so if I make this
method let say for example I want to
compare two strings maybe a and B look
at at the moment I do that you already
have a red squiggly there indicating a
compiler error okay so obviously the
error message it makes sense the best
overloaded method for calculated are
equal
intercom I ain't has some invalid
arguments so it's expecting integer
arguments but you're passing string
arguments into this method so obviously
it doesn't compile so how do I make this
method operate on any data type because
you know the logic is pretty simple if
they're equal written true otherwise
returns false so it need not be tied to
any type okay so how can I do that one
way to make this method operate on any
data type is just replace this integer
with object data type okay the moment we
do that look at that the error goes away
and look at this this is a and B they're
not equal if I run this obviously it
will say not equal but on the other hand
just to make sure it's working as
expected and they I run this okay they
are equal so now if you look at this
this method is reusable with any type
it's not now tied to any type but the
problem here is you know and why have we
in the first place how are we able to do
this if I convert the data type from
integer to object then I'm able to pass
strings I'm able to pass integers how is
that possible you know we know that
within dotnet framework every type
directly or indirectly inherits from
system to object so obviously you can
you know since string the integer you
know any type you take for that matter
you know directly or indirectly it
inherits from system object so you can
pass the type as an inherited type into
this method that's how it works but then
the problem with this there are two
issues with this way of coding one is
let's say for example if I pass 10 and
10 integers now when I actually run this
program at runtime what's going to
happen is this 10 we know integer is a
structure which means it's a value type
so at runtime this value type needs to
be converted into object type you know
object is nothing but a class look at
that the intellisense class system to
object but but whereas integer is
actually a structure a value type so at
runtime this value type needs to be
converted into reference
which is nothing but your class so
converting value types to reference
types is called as boxing so boxing is
happening unnecessarily here just for
the purposes of comparison okay so
because of this unnecessary boxing and
unboxing what's going to happen is the
performance is going to be degraded
that's one problem another problem with
this method look at this now if somebody
is calling this method okay now the
reason why they call this method is to
determine if two values of the same type
are equal or different for example I
want to compare it to integers are equal
or if two strings are equal or if two
characters are equal but since now you
made this type of object you know users
can say okay I want to compare if 10 is
equal to a B now this doesn't make sense
you shouldn't be allowing that in the
first place but here our code will
happily compile because what is the type
that we are dependent upon object type
so you will be able to pass in anything
for the first parameter and anything for
the second parameter okay so now this
method is no longer strongly typed we
lost that you know we lost the strongly
type nature of this method number one
and number two because of boxing and
unboxing there is performance recreation
so to solve both of these problems we
can actually make use of generics okay
so the best way to make this method
independent of the data type is to use
generics let's see how to do that so
obviously you know we don't want to be
doing stuff like this let's say I want
to compare a B with a B and determine if
they are equal okay so let's see how to
correct that so now instead of object
type what I can basically do seeds using
generics is very simple okay all you
have to do is put an angle bracket C I
want to make this method generic now
generic meaning I want to make this
method independent of the type it
operates upon
okay so what I'm doing here is I'm going
to say some type I don't know about the
type okay
and the parameter that the user is going
to pass M is going to be of this type T
okay so what is this T we don't know it
could be integer string enum whatever it
will only be known by the calling client
okay when somebody calls this method
that's when they specify on what type
they want this method to operate on and
then here we have to do a slight change
because this is a type you cannot
directly compare them like this instead
you have to use the equals method which
system that object provides to every
type within the ordinal framework okay
so T I mean we know that one is value
one the other one is value two and both
of type T okay so f value 1 dot equals
value 2 okay
return value 1 dot equals value 2 if
they are equal it will return true
otherwise it's going to return false now
look at this there is no hard-coded
logic here you know we are not telling
on which type this method is going to
operate upon all right now if you look
at this one now what you need to do here
is basically specify the type now let's
say I want this method now to operate on
the string type look at that the moment
you do that
the moment you specify look at this 4
are equal you are saying the type is
going to be string so obviously for this
T it's going to be string which means
value 1 and value to both of them have
to be strings but if somebody tries to
compare integers and strings let's say
if somebody tries to do that we
immediately get an invalid arguments
compiler error because it's expecting
string comma string but you are trying
to pass an integer and string which will
not be a lab so we got that strongly
typed in nature back ok that's one thing
and here boxing and unboxing will never
happen let's say for example if I want
to compare two integers okay now then
the moment I open this look at that
ok now it's going to operate upon
integers
it's not system don't object individual
is a value type is going to stay value
type during that comparison it's not
going to be converted back and do you
know a reference type box it will not
happen so we got that performance gain
as well so now let's say I want to
compare 10 comma 10 which are equal if
we run this obviously they are equal so
now your code is actually type
independent so generics are nothing but
this okay generics make your code type
independent and that way you can reuse
your code with any type and obviously
when you use generics you know you get
that strongly type nature number one and
you also have that performance gain from
unnecessary boxing and unnecessary you
know unboxing okay
generics actually are extensively used
with the collection classes that are
present in systems or collections for
generic namespace you know which will be
which will actually be talking about in
the next session all right now if you
look at this one here we made this
method generic okay it's also possible
to make classes generic instead of
saying okay I want this method to
operate on any type you can say this
class basically can operate on any type
which means all the methods in this
class are going to in a way operate on
that type for example instead of
specifying this T here what you can do
is you can specify that T for the class
itself so now you're making the class
generic so instead of specifying the
type here you specify that on the class
maybe I want this class to operate on
the nth data type okay the moment you do
that here look at that this method is
when I expect into your data types look
at the intellisense all right so now if
we run as you might expect the output
will still be the same except that in
this case we made this class generic in
a previous example we made this method
generate okay along the same lines you
can also make interfaces generate
delegates generate
so let's go back to the slides so
obviously generates that extensively use
recollection classes available in the
generics namespace which we'll be
talking about in the next session and we
have seen one way of making the are
equal method you know basically operate
on anytime is to use the system load
object type but what are the
disadvantages of using so your are equal
method is no longer type safe and
performance digression degradation due
to boxing and unboxing and obviously the
best way to make a class or a method or
an interface
you know operate on any data type is
basically to use generics using that
specific type T now you might be
wondering does it have to be T always
now you can give it any meaningful name
you want because you know here it since
it's a type that we are talking about it
makes sense or I specify the T generally
the naming convention is to use T but
you can of course give it any name that
you want all right so on this slide you
can find some resources phrase without
net and c-sharp interview questions
that's it for today thank you for
listening have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>