<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Facade Design Pattern | Coder Coacher - Coaching Coders</title><meta content="Facade Design Pattern - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Facade Design Pattern</b></h2><h5 class="post__date">2018-02-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ah3ig3ysLZA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome back this is part
21 of the design patterns tutorial in
this session we will discuss what is
facade design pattern implementation
guidelines of facade design pattern and
we'll take a look at a simple example to
implement this pattern please refer to
the previous parts of the tutorial
before proceeding as per the Gang of
Four definition facade pattern states
that we need to provide a unified
interface to a set of interfaces in a
subsystem facade defines a higher level
interface that make the subsystems
easier to use this pattern falls under
the category of structural design
pattern
the term facade is derived from French
facade which means frontage or face if
facade is generally referred to the
exterior appearance of the things and it
could be a building or any other form of
representation now to elaborate this we
can say that facade design pattern
provides abstracted view of subsystems
by hiding its complexity it wraps the
complex subsystems with a simple
interface this interface is responsible
for calling functions of existing
subsystems let's now take a look at the
implementation guidelines of this
pattern we need to use the facade
pattern when we want to provide a simple
interface to a complex subsystems
subsystems often get more complex as
they evolve most patterns that we learn
till now when we apply them result in
more and more smaller classes this makes
the subsystem more usable and easier to
customize but it also becomes harder to
use for clients that don't need to
customize a facade can provide a simple
default view of the subsystem that is
good enough for most lines also we need
to use this pattern when there are many
dependencies between clients and the
implementation classes of an abstraction
in this scenario we introduce a facade
to decouple the subsystem from clients
and other subsystems thereby promoting
subsystem independence and portability
we do need to use this design pattern
when we
want to layer the subsystems and use a
facade to define an entry point to each
of this subsystem level to this point if
the subsystems are dependent then you
can simplify the dependencies between
them by making them communicate with
each other
solely through their facades let's now
take a look at the representation
diagram of facade design pattern notice
that there are many subsystems
interacting with each other and each of
them having their own implementations
you may be wondering why we end up in
this complex subsystems to answer that
we create subsystems by following design
patterns and principles to structure a
system into subsystems which helps
reduce complexity till now we have
discussed and understood that a lot of
design patterns which helps us develop
large-scale systems depending on the
requirement after lot of these smaller
capable systems when we envision and
expects clients to invoke these
subsystems it becomes a tedious process
hence the common design goal is to
minimize the communication and
dependencies between subsystems one way
to achieve this is to introduce a facade
object that provides a single simplified
interface to more general facilities of
a subsystem and then clients will
interact with this facade object to get
their expected method return details
hence we can say that facade knows which
system or which subsystem classes are
responsible for a request and it
delegates those clients requests to
appropriate subsystem objects whereas
the subsystem classes implements their
subsystem functionality to handle work
assigned by the facade object these
subsystems have no knowledge of the
facade that is they don't keep any
references to the facade object but they
serve all the requests which are
requested by the facade object now the
clients over here communicate with the
subsystem by sending the request to the
facade which in turn
we forwards them to the appropriate
subsystems objects although the
subsystem objects performs the actual
work
the facade may have to do the work of
its own to translates its interface to
subsystem interfaces and the clients
that use the facade don't have to access
it its subsystem objects directly I'm
sure at this moment you're still
wondering that there are many other
design patterns that can be used as a
replacement for facade design pattern
and of course you want to know more
about those comparisons we will
certainly dedicated separate sessions on
discussing those comparison of design
patterns and their usage guidelines in
our upcoming sessions for now let's
focus on the facade pattern and see how
we can implement this with a simple
example let's now switch to the visual
studio console application program and
see this in action to make the things
faster have taken a simple shopping card
example to demonstrate this pattern I
have already created a class library
called shopping cart which has the
interface implementation and model
objects most of us are familiar with any
e-commerce applications in any
e-commerce portals we search for an item
that we are looking for and add those
items to the cart and then we place the
order to get our product items this is a
very high-level representation of an
e-commerce application however
internally there are many subsystems
which are responsible to make purchases
on e-commerce platform let's say for
example we have five sub systems which
are cut order etc subsystems that are
responsible to create any online orders
for the representational purpose I have
created those five sub systems as
interfaces which are I card I tags i
order i've allen and i address i have
also created those respective models to
interact with these interfaces which are
address cat cat item and product let's
say the iCard interface or the cards of
system need to follow some steps before
adding an item to the cart
for example the cart need to get the
item details first and then check the
availability of the item and once it is
available we log the items in stock and
then once all of these operations are
complete then this subsystem is
responsible to add the items to the cart
however the end points doesn't expect
these methods to be invoked and they
need a simplified version of a method
which perform these operations once the
items are added to the cart
we need to invoke the PAC subsystem so
that it gets the tax by state and apply
the tax on those items before deriving
the final price of those items and once
this step is complete the next step is
to assign the address to the cart and
verify if the user has enough balance to
purchase and proceed with the purchase
of the order as I stated earlier we all
know that the inclines doesn't care
about these details and they are only
bothered about creating the card and
placing the order I hope now you are
able to correlate and understand that we
need to create one more layer or a
facade that serves the requests of the
clients in order to achieve that I have
created a shopping facade library where
the end-users are presented with only
two methods which are Add to Cart and
place order I have also done this
implementation in this user order which
inherits the I user order let's now
switch to the main program which is our
own client and see how the client is
invoking the force add layer let's
expand this facade demo and switch to
the main program notice that we are
creating a user order and we are adding
items to the cart by passing the item ID
and the required quantity once it is
added to the cart the next step of the
Klein tool is to place the order now
let's switch to the add to cart method
and see what are the operations that add
to cart
is performing let me switch to the user
order notice that in step one we are
invoking the cart subsystem details
which internally invokes the gate item
details method and once we have those
item details we are also checking the
item availability depending on the item
availability and once the step two is
passed we are locking the item in the
store and then we are proceeding by
adding the item to the users cart once
these operations are completed
internally the Add to Cart is going to
return the cart ID to the end client and
then the end client invokes the place
order method similar to the Add to Cart
method the place order method abstracts
all the subsystem methods and places the
order by performing taxation rules
verifying the user balance or the user
valid balance and it also checks if the
user valid balances greater than cart
price then it proceeds by assigning the
address details of the current user and
then once all of these criterias are
accomplished the users order are placed
and the order ID which is returned from
this place order detail is returned to
the end client a point to note here is
that I am just representing all these
methods at a high level to show the
complexity of these subsystems of course
I have not implemented these methods in
detail except that I am printing them
details of these methods invoked in each
of these subsystems
using console dot write line as you all
know our idea is to and just understand
the facade implementation and not to
focus on the real implementation of
these subsystems now let's run this
application and see the output
notice that in the output client invokes
the facade methods of add to cart and
place order details which internally
calls many subsystem methods to achieve
this functionality I hope now you are
very much familiar with the facade
design pattern also I would like to
mention that this sample code is
available in our
blogsite for your reference in the next
session we will discuss another
structural design pattern till then
thank you for listening and have a great
day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>