<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 16   Difference between optimistic and pessimistic concurrency control | Coder Coacher - Coaching Coders</title><meta content="Part 16   Difference between optimistic and pessimistic concurrency control - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 16   Difference between optimistic and pessimistic concurrency control</b></h2><h5 class="post__date">2014-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jQarp7R2hhU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is part 16 of link to sequel
tutorial in this video we'll discuss why
is concurrency control required and the
difference between optimistic and
pessimistic concurrency controls so why
is concurrency control required
concurrency control is required to
prevent two users from trying to update
the same data at the same time it can
also prevent one user from seeing
out-of-date data
well another user is updating the same
data let's now understand with an
example what's going to happen if there
is no concurrency control in place john
and mary has a joint account John and
Mary visit different bank branches John
wants to deposit $400
while Mary wants to withdraw $400 so
John with its branch a and Mary visits
branch B at 9:00 a.m.
John asks the clerk at pranchi to tell
him what his balance is so the clerk
logs into his account and tells him the
balance is $1,000 and then at that point
the clerk gets an urgent call
and he goes await word that call now at
branch B Mary asked the clerk to
Delaware the balances so the clerk logs
into the joint account sees the balance
is 1,000 and then Mary wants to withdraw
$500 so she withdraws hundred dollars at
9:02 and then the clerk updates the
balance of the thousand minus 500 is 500
so at 9:03 the balance is updated as 500
now at branch a the clerk returns from
his phone call and the clerk at branch a
is still seeing the balances thousand
dollars because that's what he has
accessed at 9:00 a.m. and the update
that was done in branch B you know the
clerk in branch is not aware of that so
he's still seeing the old balance and
then at 9:04 John deposited 400 dollars
so the clerk updates thousand plus 500
equals 1500 so the balance after the
second update it's 1,500 now is that the
correct balance no the correct balance
should be thousand dollars at the end of
both of these transactions because we
started with thousand dollars Mary
withdrawn 500 and John deposited 500 so
the balance should
you $1,000 but we ended up with $1,500
which is incorrect and why did we have
this problem this is because to users
updated the balance at the same time and
since there is no concurrency control in
place the second update done in branch a
has overwritten the changes made by the
first update in branch Bay this problem
is called as lost updates because you
know we have updated the balance at 9:03
to 500 and then in branch a you know the
clerk in branch it didn't realize there
was an update to the balance field and
then he has accidentally overwritten the
update done at branch B so we lost the
update so that's why it's called as lost
updates problem there are several other
problems related to concurrency which we
will discuss in detail in a later video
session now let's look at what's going
to happen when we have some sort of
concurrency control in place with the
same example so John with its branch a
and may revisits branch pain so at 9:00
a.m.
John wants to know his balance so the
clerk logs into the account once he logs
into account that account is locked okay
so a lock is acquired and then at 9:00 1
when Mary tries to log into her account
and branch B she will not be able to
access that account because there is a
lock acquired so until that lock is
released Mary will not be able to access
that record okay so at 904 John deposits
500 the clerk updates the balance so the
balance now it's 1,500 at 906 the clerk
in branch bay will be able to access
that account because the lock that is
acquired is released and at 906 when
they are able to access the account they
see the updated balance which is $1500
and Mary wants to withdraw 500 she
withdraws 500 updates the balance so the
new balance is 1,000 which is correct as
expected so the lock that we have
acquired here is released only after
John's transaction is finished
after the lock has been released Mary
can proceed with her transaction since
we have a concurrency control in place
we have prevented two users from
updating the balance at the same time
which also prevented lost updates so the
balance is updated correctly as expected
there are two different concurrency
control mechanisms pessimistic
concurrency control optimistic
concurrency control so what's the
difference between these two pessimistic
concurrency model involves locking rows
to prevent other users from modifying
the same data at the same time until
that lock is released by the lock owner
no other user will be able to access
that data pessimistic locking can very
easily lead to performance bottlenecks
in an application because if we acquire
a lock and then if we hold on to that
log for a long time then no other users
will be able to access that record until
we release that log so it can very
easily bring down the scalability of
your application optimistic concurrency
on the other hand it does not involve
locking rows when reading instead this
model checks if two users try to update
the same record at the same time and
then if that happens one users changes
are committed to the database and the
other users changes are discarded and an
exception will be thrown to notify the
user about it we will discuss how to how
linked to sequel implements optimistic
concurrency with an example in our next
video thank you for listening and have a
great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>