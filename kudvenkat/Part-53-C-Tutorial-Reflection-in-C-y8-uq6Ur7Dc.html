<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Part 53   C# Tutorial   Reflection in C# | Coder Coacher - Coaching Coders</title><meta content="Part 53   C# Tutorial   Reflection in C# - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Part 53   C# Tutorial   Reflection in C#</b></h2><h5 class="post__date">2012-07-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/y8-uq6Ur7Dc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to cuisine technologies I
am rankled this is part 53 reflection in
this session we'll learn the basics of
reflection and also understand the
practical use of reflection now what is
reflection reflection is basically the
ability of inspecting an Assemblies
metadata at runtime let's understand
what we mean by this what do we mean by
inspecting an Assemblies metadata at
runtime now understand that whenever you
develop any application for example if
you look at this this is a simple
console application and this console
application consists of the main class
and the customer class now when we build
this solution what's going to happen is
these two classes the customer class and
main class these are compiled into
intermediate language and packaged into
something called an assembly and when
you look at an assembly an assembly
consists of two parts one is the
intermediate language and the other one
is the metadata and what does this
metadata contain it contains the
information about the types within that
assembly for example what is the name
what are the different types here within
this assembly main class and customer
class and if you take customer class
what does it have in it what are the
members of this customer class if you
look at that it has got two public
properties one customer I mean one
constructor and two methods actually two
constructors one constructor which
doesn't take parameters the other one
which takes two parameter so if you look
at this these are the members of this
class so all this information about
these types is actually packaged into
that assembly in the form of metadata
now what is reflection reflection is
actually you know taking that assembly
and then inspecting the definitely to
find out okay how many classes has this
assembly got and how many enemies or
structures has this assembly got and for
each class what are the different
members that each class or enum
structure has gone okay
so doing this inspecting an assemblies
contents by looking at its metadata at
runtime is nothing
in a reflection okay and how is this
reflection useful this reflection is
actually used in several ways and one of
the practical examples is here if you
open up a Windows application let's say
a Windows application or an asp.net web
application when we drag and drop the
button
we know that a button is nothing but a
class okay if you look at this button
control here this is nothing but a class
now when I double click that we have the
button click event handler here and if I
get into the initialize component method
here which is generated you have the
button class and if you look at this
button class it is defined in system
what windows forms namespace and if you
right click on that and say go to
definition and if you look at this this
button class is inheriting from
something called button base when I
right-click on that go to definition
look at that this button base has
several properties defined so obviously
when we compile this you know when when
Microsoft people who develop this button
and button based controls when they
compile this all this information about
the properties methods etc is is also
compiled into the assembly in the form
of metadata and now when we drag and
drop this button and when I right-click
on that go to properties window look at
the properties window all these
properties are now dynamically displayed
here and how is that possible you know
VI using reflection here now we use
reflection inspect the assembly which
contains this class find out what its
properties are pull out that information
and display them here and you are also
able to change these values okay so for
example reflection is extensively used
by IDE designers and and UI developers
so if you look at this when you drag and
drop your button on a bin forms or an
asp.net application the properties
window uses reflection to show all the
properties of the button class so
reflection is extensively used by IDE or
UI designers you know ID stands for
integrated development environment which
is nothing but visual studio is an
example for one of the IDE s
all right another practical use of
reflection is lead binding you know
don't worry about late binding we'll be
talking about you know late binding with
an example in a later session but
however we'll really understand what
late binding is here now look at this
for example if you take this example
here you know we have a customer class
forget about what this class is doing
but we have a customer class now if I
want to create an instance of this class
I will say customer c1 is equal to new
customer so what are we doing here we
are creating an instance of this
customer class but at compile time
itself I know you know I have knowledge
about this customer class so at compile
time you're able to create an instance
of this customer class so this is called
as early binding but on the other hand
you know there might be situations where
at compile time you might not have the
knowledge of the class you know for
which you have to create an instance ok
so you you can only do that at a runtime
maybe because you don't have the
assembly available to you until at
runtime ok or for some other reason you
don't have any knowledge you know at
compile time about the class for which
you are going to create an instance so
at that point of time you have to create
an instance of that class at runtime
dynamically and when you do that you are
actually doing late binding and one of
the ways to achieve late binding is
using reflection at runtime you check
and assembly you load and assembly
dynamically and then you check the
decimal ok the class that I'm looking
for is that existing in that assembly if
yes create an instance of that class and
then if you want to invoke some methods
on that you will then invoke a method at
a practical example of that we look at
it in a later session but for now
understand that late binding is nothing
but creating an instance of a class at
runtime rather than at compile time so
late binding can be achieved by using
reflection you can use reflection to
dynamically create an instance say type
about which we don't have any
information at compile time
so reflection enables use - and
wills asked to use code that is not
available at compile time let's look at
this here in this example this customer
class if I have to create you know an
object at early time at compile time
itself then I need to have this code
available at the compile time itself
otherwise if this class is not there if
this customer class is not there and if
I try to create a customer c1 is equal
to new customer obviously we will get a
compiler error so if you want to do
early binding you should have knowledge
about that class at compile time itself
but whereas when you you know when you
do late binding you don't need to have
information or knowledge about that
class for which you are creating an
instance at runtime all right so so
reflection basically enables us to use
code that is not available at compile
time okay another example of reflection
you know this third example actually
this is another variation of late
binding but this is this is more to do
with interfaces let's say we have one
interface and there are two or three
providers including providers
implementing that interface okay now
what we want to do is we want to give
the flexibility to the end user
depending I mean now the developer has
three opportunities I mean three
implementations of the interface okay
now we want to give the user the
flexibility of choosing which
implementation they want and maybe they
will just use a simple config file they
specify here okay I want this
implementation okay they specify the
name of that implementation that config
file and then our program should read
from that config file and depending on
the name that the user has provided
there we have to load that type from the
assembly and instantiate that again to
do that we use you know basically
reflection all right so we will talk
about the second and third examples
practically in a later session but for
now let's see how to inspect an
Assembly's contents and use reflection
framework provided by dotnet framework
to inspect that assemblies methods
properties constructors etc
let's look at an example which will make
that very clear all right
now if you look at this example all we
have until now is a customer class and
if you look at that customer class it
has got to auto implemented properties
two constructors and two methods one
method which prints the ID the other one
printer name now what I want you to
basically do is I want you to write a
simple function which can list the
customer classes properties feels
constructors methods etc and how do we
do that that's when we use reflection
and remember reflection has got a
specific class in a system type class
this is very very important because most
of the stuff that we do with reflection
is centered around this class type class
and the type class is present in the
system namespace so the fully qualified
name of that is type so this is very
important type D is equal to type dot
get type will understand what what we
mean by this in just a minute so if you
look at this here this method is taking
in the name of the type now if you look
at it what is the name of our class
customer class and within which
namespace is this present regime
namespace so we need to pass in the
fully qualified name of this type
because if you look at that get type
method what is it expecting it is
expecting the type name okay the fully
qualified type name including the
namespace name soap regime dot customer
when we pass in this here now what's
going to happen is this method get type
static method on this type class this is
going to get the type of this class and
this type class you know this type class
provides us with several methods which
we can then use to find the information
about the methods constructors
properties fields etc okay let's see how
to do that first
now so T dot okay if you look at it
let's say for example I want to get the
information about these properties I
want to list all the properties that are
available so how do I do that
t dot get properties look at that and if
you look at the return type of this
method get properties what is it
returning back it is returning back you
know look at the intelligence it's
returning back and the array of property
info objects okay so let's get those
property info objects so property info
but if you look at that
you know visual studio shows okay I
don't have knowledge about this property
info where is this property property
info class present look at that message
there the type of namespace name
property and who could not be found
are you missing a using directive or an
assembly reference now what we are doing
here is reflection so all the classes
okay that that are part of reflection
namespace I mean reflection framework
are present in system dot reflection
namespace so we have to input that but
remember the type class is present in
system namespace system dot reflection
and the moment we do that you know the
red squiggly goes away get property info
so we got all the properties now you
might be wondering okay how do I know I
have to use this property info it's your
intellisense rental essentials okay the
return type of great properties is
property info so you know that property
enforce will contain the information
about your properties now what you can
do you can use a for each loop loop
through each of the property and print
whatever information you want about that
property so for each property
or for each property info because this
is a property info are a let's call
property for each property in properties
what we basically want to do maybe we
want to print the name of the property
so this variable here property dot name
actually you can look in this here there
are several property type is the
property type look at that stuff this
property type is integer this property
type is string so if you want the
property type you can use of you can
make use of that property their property
type okay or if you want just the name I
can just choose just a name so if I
choose just a name that's it
so we did a simple program using
reflection I got the properties now so
when I run this you should see there are
two properties in our customer class
what are their ID and name and if you
want the return type of that property as
well the type of the property you can do
that as well and how do we do that so
property dot
type dot name and then maybe give a
space and then the name of the property
so if we love that you know for ID this
integer in 32 and name a strain okay and
similarly you know once we got the type
within that type type here is nothing
but our customer class within that
customer class we have these two
properties but you can also inspect the
information about the type itself let's
say I want the fully qualified name of
this type it's nothing but pledging that
customer but just to demonstrate that so
T dot full name so maybe console dot
readline and you want to say full name
is equal to or if you just want you know
the name of the class without the
namespace it's possible as well and the
way you do that is you know use the
corresponding property for example here
I just want the name of the class so we
have a property called the name and if
you want the namespace we have name
space so just the name just the name
similarly if you want just the name
space even that's possible so just just
the name space and we are going to call
this name space now if we run this you
should see okay full name of the class
is equal to presume that customer just
the name is customer just the name space
is pro game and then we have the two
properties the return type and then the
names of them okay now if I want to
print the properties okay it's better
actually if you print the heading here
you know maybe properties in customer
class because we will we will be
printing methods as well okay so so far
if you see we have just printed the full
name of the customer class then just the
name and the namespace and then we also
have printed
the properties with their return types
let's say I want to print you know maybe
all the constructors or methods let's
bring the methods fast if you look at
this class have got two methods I want
to print both of these methods and to do
that let's see how we do that so control
the trade line we want method so we will
say methods in customers class okay now
to get properties we use to get the
properties method on the type object
okay to get methods all you do is use
get methods method okay so if you look
at this get methods method what is that
returning back it is returning back
method info array okay instead of
properties in 4a this is returning
method info now is it was I mean is it
required to remember all these return
types and other stuff not really you
just need to understand the flow of the
logic here I mean to get from these we
are using get properties to get methods
we use get method similarly to get
fields we use get fields to get
constructors we use get constructors
okay so it's very meaningful and all you
have to do is how are you amount so with
that method and that method will tell
you what is the return type going to be
here forget methods is going to be
method in for so instead of property
info I'm going to use method in for
array and then give this variable a
meaningful name methods and then for
each method in for and method in this
methods collection what we want to do is
we want to specify you know that a
method will have a return type and the
name so I want to find out what is the
return type of each method within this
class and then the name of that method
so obviously to get the method return
type
so method dot there is a property called
return type dot name so I want the
return type of the method as well as the
name of the method so method name and
just print an empty line here so that
there is a space between properties and
methods so now if we run this look at
that methods in customer class actually
it is showing several methods in the
customer class that's interesting let's
examine actually if you look at this
customer class it has got only two
methods print ID and print name let's
first see if those methods are there so
print ID and print name why do print ID
and white print name those two are there
but in addition to those there is
something called a set name get name set
ID get ID these are nothing but the
accessors for these properties you know
internally underneath the scenes there
is a set ID method and a get ID method
similarly there is a setname method and
a getname method even those are treated
as methods within this customer class
and that's why they are shown here
okay that's fine so set ID get ID get
name set name print ID print name okay
we know what they are and where they are
coming from but if you look at this
there are four other methods to string
equals get hash code get type this is
important to understand because every
type and dotnet actually directly or
indirectly inherits from system object
and if you look at this customer class
look at this when I create an instance
of this customer customer c1 is equal to
new customer and when you look at c1 dot
look at this in addition to print name
and print ID I have equals get hash code
get type and to string method so where
are these coming from these are actually
coming from the system or object base
type okay remember in Garnett every type
directly or indirectly inherits from
system that object and system that
object has defined these four methods
get type get hash code equals and to
strain and all types in dotnet
have them okay so these base types which
are inherited I mean these methods which
are inherited from the base system
object type are also shown as methods of
this last because they are available
within customer class that's why you see
as such a big list here but otherwise
our customer class has just two methods
which is print ID and print name and
similarly if I want the information
about Constructors I can do that as well
and the way we do that is you might have
guessed it by now instead of get
properties and get methods we will use
get constructors and obviously get
constructors will return constructors
info instead of method in for proper
tiempo let's quickly see how to do that
so just copy paste that code to save
them some time methods in customer class
as well of that constructors in customer
class and this is going to be T dot get
constructors and if you look at the
return type of get constructors they
return constructors in so so construct
our instead of method info we will say
constructor in for and then for each
constructor info let's give this
meaningful name constructors for each
constructor in constructors what we want
to do we want to print the constructor
but interestingly you know if you have
the class as customer class obviously
any constructor within the customer
class will have the same name as that of
your class because you know constructors
will have the same name as that of your
class so there is no point in printing
the name of the customer class I mean
the name of the constructor because
invariably they will have the same name
as that of your class so that's why when
you say constructor dot name they don't
really give you much information let's
run this and see what happens
so it says dot CTO our constructor the
last fool
letters of the wording constructor okay
so it doesn't it is it's not really
meaningful I mean it's not really useful
I mean all that you can tell here is
this class has got two constructors
because dot dot ctor is print advice but
that's not really that useful instead of
that if you just say constructor dot to
string but what is different you know
with these constructors is that if you
look at this constructor one constructor
takes in two parameters to initialize
the class properties and the other
constructor doesn't take any parameters
okay now that information is useful and
the dot to string method and the
constructor object will actually give
that information to us if you look at
that okay this customer class has got
two constructors one which takes two
parameters and the one which doesn't
take any parameters so obviously this is
very simple reflection revolves around
the system lor type okay so if you know
much about this type class you almost
know about reflection okay this type
class exposes method like methods like
get properties get methods get
constructors which return method in full
constructor and for property info object
arrays and similarly if you want fields
you will say T dot cat feels and if you
want to know about the method parameters
you know whatever that method dot get
parameters will return you the parameter
in for objects array all right now
actually this type there are several
ways to get a type of a class you know
here we are using the static type on
this type class static method on this
type class but instead of that you can
also simply use you know instead of this
line let's comment that what I basically
can do is I can say type and you can use
something called type of keyword so type
off what is the class that we are
interested in customer class so instead
of time don't get ty you can
ctype off you can use this keyword and
get the type of anytime when you use
type of keyword you have to actually
pass the class name okay you don't pass
it as a string there so now when I learn
the behavior will be exactly similar
except that to get the type of a class
we are using the type of keyword instead
of the get type static method on the
type class and there is another way I
mean at times you might have an instance
of the class rather than the class
itself and as such circumstances you can
use the instance you know of that class
and then use get type on that for
example let's say I have a customer
object like this customer c1 is equal to
new customer or somebody passes in a
customer object to me into my method and
then when that happens if I want to know
the type of that class all I can do is
on that instance I can call get type
method and if you look at the return
type it again returns type of that
object and remember all objects you know
will have the get type method which they
inherit from the base system to an
object class so when I say type T is Z
well do that again here it's the
behavior is going to be exactly similar
except that we are using get type on the
instance of the class okay so what did
we understand in this reflection
reflection is basically the ability of
inspecting an Assemblies metadata and
runtime and what are the practical uses
of reflection reflection is used by ID
is basically to show the object
properties somebody selects them a
classical example is visual studio and
you drag and drop your button control
either an asp.net or a Windows
application you have the properties
appearing in the window how is it
possible using reflection and another
you know major use of reflection is laid
binding we will look at an example of
lead binding in a later session and to
get the type of a specific class or a
structure etc there are three ways one
is to use the static method on the type
class itself type cat eye when we use
the static method you have to pass in
the name of the class including the name
space the fully qualified name
the other ways to use the type of
keyword and finally if you have an
instance of the class on that instance
you can invoke the get type method which
every type in.net inherits from the base
system object class on this slide you
can find resources for asp.net and C
sharp interview questions that's it for
today thank you for listening have a
great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>