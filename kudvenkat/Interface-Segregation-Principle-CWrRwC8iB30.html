<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Interface Segregation Principle | Coder Coacher - Coaching Coders</title><meta content="Interface Segregation Principle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/kudvenkat/">kudvenkat</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Interface Segregation Principle</b></h2><h5 class="post__date">2018-01-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CWrRwC8iB30" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome back this is part
three of the solid design principles
tutorial in this session we will discuss
interface aggregation principle and
we'll take a look at their case study of
interface segregation principle and
we'll implement interface aggression
principle with a simple example please
refer to the previous parts of the
tutorial before proceeding in the first
session of solid introduction we have
understood that I in the solid is
acronym for interface creation principle
the interface segregation principle
states that no plane should be forced to
depend on methods
it doesn't use which means instead of
one big fat interface many small
interfaces are preferred based on groups
of methods with each one serving one sub
module the interface segregation
principle was first used and formulated
by Robert C Martin while consulting for
Xerox let us now understand how the
interface segregation principle was
evolved with the case studying as we all
know that Xerox Corporation manufactures
printer systems in their development
process of new systems Xerox has created
a new printer system that could perform
a variety of tasks such as stapling and
faxing along with a regular printing
task the software for this system was
created from the ground up and as the
software grew for Xerox making
modifications became more difficult so
that even the smallest change would take
a redeployment cycle of an R which made
development nearly impossible the design
problem was that a single job class was
used by almost all of the tasks whenever
a print job or a stapling job need to be
performed a call was made to the the big
job class this resulted in a fad class
with multitudes of method specific to
variety of different lines because of
this design
a staple job would know about all the
methods of the print job even though
there was no use for it
to know about these different interface
methods of a print job to work on this
problem Robert C Martin suggested a
solution to Xerox which is called
interface segregation principle instead
of having one large job class a steeple
job interface or a print job interface
was created that would be used by the
steeple or print classes respectively
this solution has evolved into a C
interface segregation principle which
states that one large job class is
segregated to multiple interfaces
depending on the requirement now if you
recollect the previous session we have
also covered the interface segregation
principle along with the single
responsibilities of the class we
strongly recommend you to refer to the
single responsibility session before
proceeding in the previous session we
have decoupled the user class to achieve
single responsibility of handling login
and registration also we have moved the
error logging and send email methods to
their respective classes or interfaces
after those changes we have achieved
single responsibility from the
respective classes perspective but if
you take a closer look at the same
example from the perspective of
interface segregation we have as well
separated or segregated one big
interface which handles login
registration email and error logging to
multiple interfaces adapting to
interface segregation principle now
let's understand the interface
segregation principle in greater details
with one more example in the beginning
of this session we have discussed that
mr. Martin has solved the issue at Xerox
by segregating the interfaces based on
the usage and not by enforcing the
clients to implement the interface
methods
let's take the same case study example
and see how we can achieve the interface
aggregation principle let's now open the
visual studio and bring up a console
application let's now create an
interface that performs printer related
tasks
right-click on this project a new item
choose an interface and let's name this
interface as I print thus let's make
this interface as public let's add the
task that a printer can perform let's
add a method full print content which
acts EPS string content as input
parameter let's create some more methods
let's just save some time let's copy
this method and change it to scan
content let's also create another method
fax content and the last one which is
photocopy the content these are some of
the typical methods or the tasks that a
printer can perform now let's say in my
office I have HP printer that need to
implement these methods to save some
time I have already created the HP
printer client class that implements the
created interface if you take a look at
this class I have implemented the I
print tasks and doing a simple console
dot write line and returning true have
done the same implementation for all
these methods to make this example very
simple now it's all fine till this
moment the actual problem starts then I
have a Canon mg 2 4 7 0 printer that can
only perform print scan and photocopy
operations as it doesn't have the
ability to fax the content in that
scenario we are stuck implementing all
the interface
methods and we need explicitly and
gracefully handle the method that cannot
be implemented let's right-click on this
client folder add a new item choose
class and name this class as Kannan mg 2
4 7 0 and let's implement the I print us
let's implement the interface now please
notice that even though my can and home
printer cannot perform the fax operation
still it is enforced to implement all
the methods of the I print ask interface
this is one of the major problems that
we encounter in the day-to-day
programming and this is only one part of
the problem which we have discussed here
now let's say there are some
advancements in the printing technology
where it can print a duplex content as
well let's say this I printers can print
the duplex content as well let's
represent it as print duplex content and
let's space the content as the string
parameter again with this new methods
addition all the clients are mandatory
forced to implement the newly added
method as well this is the second part
of the problem both of these problems
can be addressed by segregating one big
fat interface to smaller relevant
interfaces and that solution is called
interface segregation principle let's
see how we can do that to save some time
I have already segregated the related
methods to smaller interfaces that are
relevant to different clients for
example a minimum basic printer can
perform print scan and copy operations
and advance of printers can perform fax
or duplex content printing
based on the level of the printer hence
those methods are separated into
different interfaces I believe now you
have a good idea on how we can implement
interface a creation principle in the
next session we will focus on walk/run
amine solid which is open closed
principle till then thank you for
listening and have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>