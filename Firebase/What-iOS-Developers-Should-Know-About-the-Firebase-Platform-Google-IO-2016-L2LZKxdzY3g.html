<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What iOS Developers Should Know About the Firebase Platform - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="What iOS Developers Should Know About the Firebase Platform - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Firebase/">Firebase</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What iOS Developers Should Know About the Firebase Platform - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L2LZKxdzY3g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well I guess the music stops oh that's
my cue to start hi everybody I hope the
line wasn't too long today this is
firebase for iOS developers I have an
awful lot of content to go through and
not a lot of time to do it in so I'm
just going to get started I'm going to
kind of talk really fast so we're like
the Micro Machines guy if if any of you
remember him so as you may have heard
firebase is a suite of integrated
products designed to help you develop
your app grow a user grow your user base
and earn money and more specifically
we're there to help you do that on iOS
so I know we're at Google i/o and you're
probably going to hear a lot of like
announcements about Android and things
and instant apps and all that fun stuff
which does sound kind of cool but when
it comes to developer tools particularly
mobile developer tools and particularly
firebase we take cross-platform very
seriously we know that a mobile library
is probably not helpful to you unless
it's available on all the platforms
you're developing for and for most of
you doing development in mobile that
generally means Android and iOS so
honestly I'm actually very happy that
this whole cool new platform is built
under the firebase brand because I think
people already know that firebase is
very serious about supporting iOS and
will continue to in the future so I'm
fun fact if I give this talk in Spanish
it looks like I'm just kind of generally
excited about the idea of an operating
system so let's that's my one
internationalization joke for for the
event so thank you I'm going to move on
so out of all these features that we
have available on firebase these are the
ones that are available on iOS so you'll
notice that the only thing that I that
we had to dim out was the test lab which
is specifically being called test lab
for Android for that purpose it just
didn't fit nicely in the slide so really
everything that you can do in firebase
you can do on Android and iOS which is
great so this is kind of supposed to be
a technical deep dive which i think is a
little weird given that some of these
features are brand new to you and you
haven't yet had a chance to even play
with them so really this talk is going
to be a little more about interesting
quirks that I discovered when I just
kind of started experimenting and
playing around with the fire based
platform and a building building my own
app which as federal law mandates
anytime you create a new app with a new
library has to be a to-do app
so um let's move there we go so this is
not like I don't know all the answers to
everything this is more like hey this is
kind of a neat little quirk and I sort
of wrote it down and I thought I'd give
a presentation on all of it so let's
talk a little bit about the setup
process generally speaking firebase
encourages you to use cocoa pods we're
using cocoapods now is sort of our are
generally recommended way to install
stuff probably most of you know this by
now so I'm not going to go into a lot of
detail on it but it's a dependency
manager that vastly simplifies the
process of adding libraries to your app
and if you don't know anything about
cocoa pods we do have a fantastic video
have a little trouble with the clicker
there we go that you can check out with
an incredibly handsome cast so I'll give
you a moment if you want to take a
picture of that URL go ahead and if not
i will post it in these in the google
space afterwards one important note
about cocoa pods is you should generally
only pod install what you need maybe not
everyone knows this i didn't know this
at first but the thing about cocoa pods
is adding a pod actually increases the
size of your app whether you ever
include that code or not so if you have
the choice between installing a massive
uber pod that's got 40 features in it or
installing a little sub speck of that
pod that contains the three features
you're interested in always kind of go
for that sub spec and we've actually
structured our pods to encourage that
kind of behavior so you'll notice in our
documentation for all of our cocoa pods
that we ask you to install their the
individual sub specs that are part of
firebase so you've got firebase core
which gives you analytics and all the
setup work firebase database off
messaging remote config for all of the
various features in fact if you do try
and pod firebase in the hopes that
you're going to you know install is
giant massive everything that's not
going to work we just map that directly
to firebase / core so so keep that in
mind you do have to actually pod install
every explicit feature that you're
interested in adding if you don't know
about pod try who doesn't know about
Padre oh okay like me either there's
like one or two people or maybe
everyone's just afraid to raise their
hand so if you don't know
it's a great way to sort of try out any
library that cocoapods has available it
basically goes out and searches the
repository for a demo or sample app that
it downloads to a temporary directory on
your on your computer and then runs it
so you can kind of check out all the
libraries in action in Xcode you know
you can play around with the code see
what happens when you tweak different
things without having to be like gee I
wonder where this you know what this
thing does and then you have to go out
and find the documentation and find
where the sample file isn't downloaded
and do all that work manually and so
we've made sure that all of our firebase
samples work with pod try so go ahead
and give it a try cocoapods recently
released version 10 congratulations to
the team if you're watching online hi
from an end-user perspective probably
not a lot has changed for you with
version 10 hopefully there's very few
breakages with your pod files unless
you're doing something really fancy I
think the point of the 10 releases it's
really more of a forward-looking release
where the team is really kind of
preparing for the future and wants to
make sure everything can scale in his
production ready and so we're very
excited to be a part of that but granted
you know whenever I give this
presentation there's always one
developer in every crowd who is not
happy with the idea of cocoa pods and
like I really don't want a there they
are all right well don't worry grumpy
cat's we love you too you can still
install all the libraries without
cocoapods if you check out our
documentation down at the bottom there
is an installing without cocoapods
section we're basically what you're
going to do is you're going to download
this giant zip file that is going to
contain all the frameworks available and
there's a step-by-step guide that says
you know for every feature if you want
firebase messaging you need to install a
b c and d and if you want analytics you
need to install dnf and and so on and so
forth for every feature that we have
available so it takes a few manual steps
but you can still do it so don't worry
don't worry cocoapods haters we we still
like you by the way show of hands if
anyone was secretly wishing we'd see
supporting Carthage instead all right a
few good to know just kind of gauging
the gauging the interest in the room I'm
not making any promises about any future
anything
we are almost all on modules now which
is generally nicer when you're importing
things and importing is very simple you
can just import firebase and this will
import all the headers for any of the
pods you have installed there's sort of
a lot of has include magic going on
there we go underneath the hood that
that makes sure this works which I know
kind of sounds like the opposite of my
hey only pod install what you need
advice that I gave you like three slides
ago but here you're not going to
increase the size of your app if you
import firebase and import all the
firebase features you you have installed
that's not going to change the size of
your app maybe there will be a slight
increase in compilation time but I think
it should be pretty negligible I
certainly haven't noticed and it makes
development very easy right you just
sort of have import firebase and then
any feature you want to try out should
just work without without Xcode giving
you an error we have big code support
now yay that's good so you can finally
use firebase for your you know you're
watching TV apps sorry this this took so
long we have a style guide now an API
review for all our developer libraries
that are published as part of the fire
based platform so you should start to
see consistent class names and method
aiming across the different features of
firebase which is good not not all of
them are there yet you know who you are
but most of our features now look very
consistent so almost all of our classes
begin with F IR and for anything that
uses a singleton you'll kind of call it
in the same way and so the idea is once
you've gotten used to using a couple of
features in firebase you should kind of
be able to sort of guess how you'll be
using some of these other features as
well so let's talk briefly about what
does happen when you create a project in
firebase because you're going to go to
the firebase console and you're going to
say hey please create a project and then
you're going to wait a little while and
it's going to be doing some magic for
you and then you attach your iOS app and
then it's going to give you a plist file
that you're going to download and
dragged into your Xcode project after
you've done that you are then going to
call this one magic call for appt
configure which will set up everything
within firebase for you no matter sort
of you know what feature you have
installed this this generally configures
it for you and so what's going on when
all of this happens so when you create a
new project in the firebase console it
does a bunch of work for you on
back end it's going to create you know
OAuth clients and spin up a you know an
instance of the firebase database for
you to use and set up a firebase storage
bucket whether you actually ever plan on
using them or not they're already
available on the back end for you to use
and for each one of these things that it
sets up there's also a constant
available right it's going to be the
address of the database or your OAuth
client IDs or your cloud you know cloud
messenger sender ID all that is the
stuff that gets put in the plist file so
that when you drag it into your app and
you call for appt configure it will then
configure any client libraries that it
sees are installed within your app and
you know it will do that by dragging in
all of these constants that that you've
put into this plist file so there's no
more kind of copying pasting various IDs
from you know the console into your app
you shouldn't have to do any of that
which which is awfully nice so let's
talk a little about these individual
features I'm going to start with my
favorite which is firebase remote config
and this is basically a way for you to
change the look and feel of your app
from the cloud so when you release your
app and you realize oh no I have some
text that's wrong or level five is too
hard or this animation is taking way too
long if you've wired up those values to
use remote config what you can do is
update them from the cloud so you'll
change within you know within the cloud
you'll say you know what this is
actually the value I want to use for my
button text and that will go you know
your your app will download these new
values and it should be available in a
matter of minutes instead of having to
go through the whole well let's release
a new build and you know get it approved
and published and have everybody
download the new version right this all
happens you know not quite
instantaneously but pretty darn quick so
generally speaking how remote config
works on iOS is first you're going to
set up a bunch of default values and you
do this either by passing in in
nsdictionary or passing in a plist
whichever way you want to do it and then
you're going to you know fetch new
values from firebase remote config with
a completion handler these new values
get downloaded and they get placed in
kind of a cached holding pattern on your
device they don't get used until you
call activate fetched at that point when
you call activate fetch these new values
get applied on top of your defaults so
then at some point later when you want
to retrieve these values when you want
to kind of retrieve
value for any of these individual
settings that you've got remote config
will either give you the version that
it's downloaded or the the default
values that you've cipro that you've
supplied and I think the important thing
to take away from this is you don't have
to supply new values for everything what
we would encourage you to do is
basically use remote config for any any
value that you have in your app right
any kind of magic number any constant
any text string all of that stuff
everything you got in that you know app
constant Swift file that we all you
don't have around this stuff should be
set up to use remote config then when
you want to change you know one or two
of those values you're only supplying
the Delta is your only supplying the
stuff that's changed from a rope config
and so you can downloads just those new
values and you have the flexibility to
change any other values in the future
without your having to supply you know
thousands upon thousands of values every
time you know you want to fetch stuff
remote config so that's generally the
way we recommend you use it in case
you're wondering what's up with that
activate fetched call why not just sort
of apply these values right away
generally speaking the ideas maybe you
don't want your app changing mid-run
right if you're you know if you're using
a rope config and you're using values to
say change the layout of your buttons or
like change the text of your buttons it
can be kind of awkward if that happens
right when the user is in the middle of
using your app right you don't quite
know when that fetch call is going to be
complete and so we give that power to
you as the developer and there's a
couple of strategies for how you can
actually make use of this one is go
ahead and activate you know the values
as soon as they're downloaded if maybe
you don't care if the values change in
the middle of your app another option is
to basically you know put up a loading
screen kind of block until load and so
you'll call fetch with completion
handler in your loading screen once the
fetch is complete you're going to call
activate fetched and then you can tell
the loading screen to go away and put up
you know your real view controller and
actually start your app and maybe just
to be safe you go ahead and add a
timeout in case things go terribly wrong
and so this has the advantage of you're
always going to get the latest fresh
values anytime your user starts up your
app but obviously has the disadvantage
of you now how the loading screen that
they have to look at maybe that's okay
if you have other sort of setup work
happening in parallel but maybe you want
your app to start a little faster
and so that's why I actually like this
other method which seems a little
counterintuitive at first but but I
think it's pretty neat which is you call
activate fetched as soon as your app
starts up or you know maybe enters the
foreground whatever makes sense for your
app and this will take any previously
downloaded values that are sort of in
that cache local holding pattern and
apply them immediately on top of your
defaults then you're going to call fetch
with completion handler and you're not
going to actually care about what
happens in your completion handle that's
essentially a no op but what you've done
is you now have new values downloaded
from the cloud that are sitting there on
your device ready to be applied the next
time the user starts up your app so
obviously this has the advantage of
being able to start right away you don't
have to wait for that Network call to
complete but does have the disadvantage
of you might be supplying slightly older
values and then of course you could try
a hybrid approach where you basically
kind of you're allowed to see you know
when this last remote config batch of
data was downloaded and you can see like
is it older than three days well maybe
that's too old for my app so then I will
go ahead and put up a loading screen and
fetch the new values but if it's you
know more recent than three days well
then that's fine I'll fun decide
discussion about localized text every
time I talk to people about hey you can
use a rope config for text people are
always like yeah that sounds great but I
know I'm not really supposed to because
you know we have all these best
practices on these devices for using NS
localized string and you know that r dot
thing on Android so you know you really
want me to throw out these best
practices and use remote config and my
answer is no you can't have the best of
both worlds so I'm sure most of you know
you know NS localized string will
provide the appropriate localized string
for the device that the user is using
and it will sort of smartly fall back to
a default language if you don't have
that language available well you can
take that localized string value and
that's what you would actually pass into
remote config as your default and so
what ends up happening is for your
English users you're going to have a set
of defaults that contain all your
English text and for your french users
you're going to have a bunch of defaults
that contain all your french text and so
then when you realize that maybe one of
your translations is not quite right
it's a little off you can fix it in
remote config with in remote config you
have the ability to create conditions
and these basically are your way of
telling remote config please supply new
Val
use but only two people who meet this
condition sometimes it's you know a
random subset of your audience but often
it could be things like people whose
device language happens to be French so
you might create a condition for your
french speakers and then within remote
config you would supply a new value just
for that condition you would say my
french speakers this is going to be the
new value that you're going to download
you'll notice that for all your other
users the default value here is no value
and this basically tells remote config
please go ahead and just use whatever
default is supplied on the device in
fact you actually just don't send any
value down to remote config when you
have no value here so I don't need to
supply you know text for all the other
you know 12 languages that maybe I'm
supporting in my app and so this will
end up just changing the store text only
on devices where the language is French
so I'm still using NS localized string
and still following all these great best
practices but I still also get to update
my app when I need to using remote
config so that's pretty good at least I
think so so yes in summary you can use
remote config to adjust localized text
don't use it to dynamically localize all
of your texts in the cloud in theory you
could do it maybe that's a fun hack but
don't do it because you're basically
downloading an entire language plaque
pack from the cloud every time and that
that's not that's not cool you get a you
know a disappointed looking emoji for
that and fun side discussion apparently
you can use emojis in your remote config
strings at least I tried it and it
seemed to work I can't guarantee it's
bulletproof but uh but there you go
let's move on to analytics because this
is really the gonna do a time check all
right might need to talk faster this is
really the backbone of what a lot of
firebase is about there's not a whole
lot to say on the client side here
you're basically you know the API
surface is pretty small most of the time
you're going to be logging events
possibly with some parameters and
setting user properties and that that's
about it so probably maybe the most
interesting thing to note is that if you
want to turn on debug mode for firebase
analytics it's actually an argument that
you pass in so you've got to go in and
like edit your schemes and put this
thing in I don't know why but but that's
what you got to do an important note
about testing analytics data is not
being sent all the time sort of it as a
way to keep you know be respectful of
your users battery life and all of that
we're not constantly streaming down
analytics data that that wouldn't be
cool so instead we only send down
analytics data either if it's been an
hour since the last time we sent down
any data or when your app goes into the
background and so when you're testing
this in Xcode you're going to you know
try firing off a few analytics events
and then you're going to hit stop and
then you're going to say hey how come
none of my analytics data is making it
is something wrong well the issues that
you know if you hit stop then your app
quits before it has a chance to send any
of that analytics data so if you are
testing out analytics always make sure
you you know command shift H to go to
the home screen and in the simulator
actually hit the home screen on the
device and that will give analytics a
chance to send its data down to our
servers I'm going to talk briefly about
audiences because they're pretty cool
and we use them in some other firebase
features these are basically groups that
you can define out of things that you
are recording in firebase analytics this
could be you know people who have
reached level 30 in my game or you know
women in Canada between the ages of 30
and 45 who listed baseball as their
favorite sport and have visited my in
app store but haven't purchased anything
yet like they can sort of be as broad or
as narrow as you would like and as
people use your app firebase analytics
will will subscribe them to these
audiences which is used for a lot of
other features including remote config
one other condition you can add for
remote config is you know does somebody
belong in this audience so you can
actually change the look and feel of
your app for people who have you know
reach level 30 in your game and sort of
do all of that without having to
actually kind of touch the code on your
client which is kind of neat it's also
used for notifications and I'll talk a
little about that later click real one
important note about audiences is they
are not retroactive people will create
audiences and they'll go and look at
them in firebase analytics and their
first question is why are they empty did
I do something wrong and so no you
didn't 11 basically the reason this is
happening is in order for us to give you
an analytic service that is free and
scales to thousands upon thousands of
apps with millions upon millions of
users we have to distribute some of that
work on to the clients themselves and so
it's actually the client that is going
to be determining whether it belongs to
a particular audience or not so as
people use your app they will get
subscribe to these various audiences by
by the client
they are using them which means that if
you think you're going to be using an
audience for something you know a few
days or a few weeks ahead of time go
ahead and you know start creating these
audiences so they have a chance to kind
of fill up and propagate as as as you go
let's move on to firebase crash
reporting which i believe is still in
beta but in spite of that it's still
pretty cool it's actually not a whole
lot to say here you sort of add in the
yet you add in the library and then
crashes get reported to firebase
probably the most interesting part here
is you're going to add this script into
your build phases which uploads your
symbols file I think this is probably
standard if you've used other crash
reporting tools but essentially what
this does is this Diop you skates your
your you know your stack trace so that
when you're analyzing your crashes
instead of something that looks like
this well there we go boom where you're
like oh maybe the problem is with method
for 745 25 I should figure out what that
is you know you get something that looks
a little more like this where you can
say oh I guess maybe the problem is with
that crash button was pressed method why
don't even have this method why do I
have a crash button maybe that's the
problem I should get rid of it so that's
sort of what happens when you when you
upload your symbols file when you want
to test your crash reporting it's a
little tricky just in that if your app
crashes and you're running it in Xcode
obviously Xcode will go in and it will
kind of capture that in the debugger
which obviously is what you want right
if your app is crashing while you're in
the middle of development you want to be
able to analyze what's going on right
there in the debugger so if you actually
want to explicitly test that crash
reporting is working by you know sort of
running a crash on your app first thing
you got to do run your app in xcode make
sure the latest versions on your device
or the simulator then hit stop in xcode
so that the debugger is no longer
attached and then run it again from the
simulator of the device and then
generate a crash and then you can run it
one more time and it's on this last run
that firebase crash reporting will
notice that your app crash the previous
time and it will then upload the crash
report and this last time you can run it
in Xcode and you'll actually see a
little console message that says like
crash report finished uploading which is
nice a quick note on logging so firebase
crash reporting also allows you to
record some logs report those directly
to
yeah to the crash reporting tool so that
in addition to getting a stack trace for
any crash you can kind of see what your
user was doing right up to the point
where the app crashed so that you know
you don't have to so you can analyze
this and be like wow my user is using my
app in ways I totally did not expect so
you can do this by explicitly logging
events to firebase crash reporting
either with fi our crash log or f ir
crash NS log the first one just you know
reports to to firebase crash reporting
the second one also spits out stuff to
the console and maybe for some of you
that are doing more sophisticated
logging like you know you sort of
written your own logging method you can
be like oh well that's great I can you
know report all my log messages to crash
reporting with just you know a couple of
lines of code and you know voila all my
logs are now being reported to my crash
reporting tool or if you're using
something like cocoa lumberjack you can
say oh that's great i can add in another
lager that will you know report things
to my crash reporting tool and again
everything that a log will also get log
to to firebase crash reporting or
whatever crashing tool I happen to be
using and this is great but I want to
point out one little cautionary tale
that that Doug another dev dev rel guy
pointed out to me which is that you
might be logging things that you aren't
expecting to actually get reported to a
crash reporting tool right I mean I
print out all sorts of stuff all sorts
of debug info when I'm like you know
when i'm developing I print out a lot
information all the time and stuff
because I'm like oh I'm just going to
see that while i'm debugging or you know
it's just going to stay local on the
user's device so if you are suddenly
magically with a couple lines of code
also reporting all that information to
your crash reporting tool where perhaps
other people in your company can see
that because they have access to to that
panel you know just make sure you're not
leaking information that you didn't
intend to if you're currently using
another crash reporting tool and you've
done this kind of technique also maybe
go home and double-check that you're not
doing this so just a recommendation I'm
gonna talk about dynamic links because I
think they're they're also kind of cool
these are basically links that work the
way you want them to on mobile devices
so the very same link can take users
either to an Android app if they have it
installed on their device or an iOS app
if they don't have the app installed it
can take them to the appropriate place
in the app store or the Play Store and
if you prefer you can also take them to
a website instead if they don't
have your app installed that's sort of
that that option is up to you but one of
the big advantages of dynamic links is
if you have to take users to the app
store first all that link information
doesn't get lost you're basically
fire-based dynamic links can can read in
whatever link brought your users to your
app in the first place and that's
generally good information for you it's
probably a really important signal for
like what did the user click on that
made them so you know interested in your
app that they had to install it because
you can then take that information and
make sure that you're presenting
relevant information to your user right
away instead of just sort of a generic
home screen or something like that so
this is sort of a really good way to
increase retention I encourage you to
kind of look into these if you have any
kind of email campaign or any other way
you're sharing your app through a link
so one question I sometimes get is okay
well so our dynamic links the same thing
as universal links and answers mostly no
but kind of yes a little bit you
probably know about universal links
right it's your way of telling iOS hey
instead of opening this link in safari
well if my app is installed go ahead and
open up my app and pass the link into it
my app will read in that link and know
kind of what important stuff it should
be displaying that you know you were
probably asking for when you clicked on
that link and you do this by placing a
little apple app site Association file
on your website and it generally all
works and this is good you know assuming
you have a website with content that
more or less mirrors what's in your app
so you could use dynamic links in the
same way right you could just say okay
you know if the user clicks on this link
take them to my app and otherwise take
them to you know uh some other website
but generally speaking most people use
them when they want to be a little more
aggressive about driving installs like
if you're creating an explicit hey
install our app button somewhere right
it's dynamic links that will be able to
take your user to the app store make
sure they install your app and when they
open up for the first time it says oh
you know you install their app because
you were interested in cat facts here
are some cat facts for you right away
instead of you know just showing you a
generic sign-in screen games are also
another good example very often you know
there's a lot of there's a lot of games
out there that don't have all of that
corresponding content on their website
you know if this is you and all your
website just kind of has like
list of our games in a jobs page or
something you know this is another
option where dynamic links could
probably be really helpful if you want
to link to a particular replay or a
particular level or something like that
within your game so how do they talk to
your app basically through two ways one
way is through custom URL schemes and so
you're going to kind of add your bundle
ID as you know as your custom URL scheme
if you've done Google sign-in you've
done this before or if you saw my last
presentation about dynamic links this is
familiar to you and you're going to
handle it in an open URL call within
this openurl called the full URL which
is that full giant dynamic link you're
going to pass it into the dynamic link
library and say hey can you turn this
URL into a dynamic link object and
either you'll get back the object which
you can then kind of parse and analyze
and do whatever you need to to you know
to respond to that link or you'll get
back nil in which case well maybe it's a
Google sign-in URL or a facebook sign
and URL or something like that the other
way these dynamic links could get into
your app is through universal links and
to get this working you're going to need
to turn on the associated domains
capability and you're going to need to
make sure you add in this sub domain app
goo GL at head domain basically as sort
of a domain that your app can accept and
this ABCDE will obviously be a code that
is specific to your project when you
create it in the firebase console and
then you know you'll handle it the same
way except that you'll be handling it
through your continued user activity
method instead of open URL and so maybe
you're wondering wait a minute I thought
you just told me that dynamic links
aren't the same as universal link so
what's the deal so the deal is that you
we basically do use Universal links to
send information to your site when they
click on the dynamic link what we do is
we create our own tiny little website
you know with sub domain goo GL and then
we host our own apple app site
association file on there that then goes
ahead and links directly to your app so
it is completely up to you whether you
want to support universal links on your
own site like maybe you do and that's
fine and maybe you don't and that's also
fine and maybe you don't have a website
at all and that's okay too right it
doesn't really matter
so don't freak out about universal links
if you're like oh we haven't gotten
around to setting that up on our website
you don't need to you only need to make
sure that your client is capable of
receiving them which basically means
turning on that one switch and the
capabilities tab of Xcode one last note
on testing dynamic links you can't cut
and paste them into Safari if you do
basically Safari will always act like
your app is not installed I think this
is the same issue with universal links
maybe I'm getting some nods instead what
you want to do is basically paste them
directly into an app like notes and then
you know can you also have the option
then of sort of editing these URLs you
want to try out different things and see
what happens and if you kind of long
press on them you also then have the
option of whether you want to open them
in your app or actually see what happens
if this link goes to Safari so um yeah
if you want to test these links put them
in notes first and then let iOS do its
magic I'm going to move on to 15 minutes
doing right I would move on to firebase
off it lets you sign in from a number of
different sources including Google
Twitter Facebook github or even letting
your users add in their own username and
password that firebase manages for you
so you don't have to add store passwords
anywhere on your server so generally
speaking when you first sign in you're
going to use something like you know
Google Facebook Twitter to sign in the
user and you're going to get back okay I
think this is user you know Google 123
and here's some information that you can
use to verify it and so you will
basically send that information down to
firebase and say this is google user one
two three firebase we'll go ahead and
verify in this end on its end that yes
this appears to be the user that you say
and then you know basically once that's
done you will get back a firebase user
ID and you'll be able to sort of access
this user as a firebase user in in the
client and this firebase user looks the
same for all users no matter how they
signed into your app so you can treat
this object basically the same way and
this user ID will be unique across all
the different sign and providers no
matter what you add and then you also
get you know like a giant random string
that you know sort of gets paired with
the user ID so you can verify them on
future visits and this is cached locally
and rotated out on regular intervals and
all that done transparent to you you
don't have to care
about that but this is nice because then
when your user comes back to your device
you don't then need to sign them into
Facebook Google Twitter etc all you you
know you have all the information there
on your device locally to keep signing
them in to firebase now granted if you
still want to you know post things on
facebook or tweet something or you know
post something YouTube you are going to
still need to sign in to these other
services but if all you're looking to do
is you know sign in your user against
firebase services you're all set
firebase also supports the idea of
anonymous off which i think is is
basically it's pretty cool it basically
allows you to assign in the user
anonymously so you can tell you know
firebase I have this anonymous user and
it will still give you back a firebase
user object and then you can go ahead
and let your user you know communicate
with firebase just the way they normally
do then at a future point if your user
says okay great I'm going to sign it
with Facebook well now you can tell
firebase this anonymous user that we've
been using this whole time is also this
Facebook user and firebase we'll go
ahead and link up those accounts so that
then if this same user signs in with
facebook on another device they'll get
all this information and you know we do
the right thing where if this user also
happen to have created another anonymous
account on that other device and then
they say oh yeah I'm also the same
firebase user firebase will say okay
looks like we've got two different
accounts that you want to associate with
this firebase account let's give you
this information and you can then kind
of resolve them how you see fit that
gets resolved on the client and so the
nice thing about this flow is it lets
you it basically gives you the power to
have your user use your app and all of
its features without forcing them
through a sign-in flow and this is you
know it's great for your users they
often don't want to have to sign in just
to try out your app right there sort of
much more vested in the process if they
tried it for a little bit and they say
oh I actually really like this app now
I'm willing to sign in it's sort of you
know for you makes the whole process a
lot easier to handle that and you know
Apple generally likes this this approach
as well I know they're always sort of
encouraging you to you know can you have
the user try out your app without sort
of sending them into a sign-in flow
right away without sort of knowing what
they're getting into so try out
anonymous off if you haven't it's it's
pretty neat all right I'm going to move
on I'm gonna take a drink of water
sorry this is an awkward pause all right
to firebase app indexing which allows
your apps to show up better in Google
searches so sometimes a question I get
about this is okay so this is like
universal links and my answer is no but
also yes a little bit so app indexing on
iOS is useful if you have universal
links set up where those links point to
your app so we have our website that you
know we've got our website in our app
and our apple app site Association file
that basically tells iOS hey instead of
opening up any of these links in Safari
go ahead and open it up directly in the
app if it's installed and so what you
can do is basically through one call
through app indexing you can let Google
know that your app is using universal
links this parameter that you're passing
in is your itunes ID so you app activate
app indexing with this one call and does
a little work to first you know let
Google know that your app is available
on this device and also what your Apple
App Store ideas in case you know we need
to grab some information like your app
icon and also let's Google know that
you're using universal links install or
universal links are installed on your
site and that you're okay with it
reading that file and so then what
happens is when your site shows up in
the search results Google will look at
that link and say oh wait i know that
link uses universal links right and i
know the apps available on this device
and so I know that this this link is not
actually going to go to a website it's
going to open directly in the app
instead and so it will change the look
of that result to look a little more
happy you'll kind of see your app icon
there and that sort of thing and then
basically based on the assumption that
you have gone or your user has gone
through the trouble of installing the
app in the first place well that
probably means that they are interested
in the content of your app and therefore
this search result might be a little bit
more relevant and so you will often not
always no guarantees get a little
ranking boost because basically we now
know that this is going to go to an app
that the user has installed and
therefore is probably interested in so
then the other question is okay so is
this like poor spotlight and hear the
answers also no app indexing is really
more for web content that you might be
searching for on Google and letting
Google know that
those links will show up in your app
instead right core spotlight is really
about letting spotlight know that you
have content available in your app on
the device and that people can find it
using spotlight and this is not an
either/or proposition right you can you
can very clearly use both of these if
you feel like they're appropriate for
your app and you probably should because
you want your app to be discoverable all
right so let's talk about firebase Cloud
messaging which is our one stop
messaging solution for messaging on on
all platforms so the idea is that you
can use firebase Cloud messaging to both
communicate with Android devices as well
as route notifications through a P&amp;amp;S to
talk to iOS devices and so how does it
work here's the 90-second summary I'm
gonna have to talk and click fast Oh
actually you know what before you do
that forgot why would you want to do
this maybe that's a better question and
so basically part of the reason is that
you only have to write one code path
right you only have to talk to one
service and so sort of that gives you
less code to write their sort of less
code in general I guess that's not true
because we have to write the code but
you don't have to so it's not your
problem so that's good there's other
reasons too you can take advantage of
services like topics your spear clients
can subscribe to various notification
topics about various subjects your
client can say hey I'm interested in you
know events happening in Texas and then
you know if you want to send a
notification to everybody you know who's
interested in in Texas events you can do
that without having to write any server
side code right you simply tell firebase
Cloud messaging send this to be able to
subscribe to the texas topic and it will
go ahead and do that to all the clients
that have told firebase Cloud messaging
that that's what it's interested in it
also lets you use the firebase
notifications panel which does make this
whole process a lot easier and I will
talk about in a minute because it is
pretty cool all right so now here is the
90-second summary of how this all works
generally speaking you're going to set
up you know apns and you're going to
have an APNs certificate that you're
going to use to talk to that server
you're going to set up firebase Cloud
messaging and you're going to have an
API key that's required to talk to that
server you're going to upload your APNs
certificate to firebase Cloud messaging
it will associate it with the same APIs
odiously associated with the API key
your client device is then going to ask
a P&amp;amp;S for a device token assuming that
you know your user has said
yes I would like to receive
notifications a penis will will send it
advice token which you will then send
down or you'll then request a device
token from firebase cloud messenger also
passing down the APNs token so you'll
get back a firebase Cloud messaging
token and firebase will hold on to that
copy of that token and make sure its
associated with the firebase Cloud
messaging token so when you then asked
to send a notification you're going to
send it along with an API key and
firebase will confirm that yes this
matches your app and a token and
firebase will confirm that yes this
apparently is a targeted device and will
notice hey this firebase Cloud messaging
device token is also associated with an
apns device token therefore my target
devices actually an iOS device so I'm
going to take that apns cert to talk to
a P&amp;amp;S I'm going to take that token to
identify the object I want to talk to
i'm going to put that in a new
notification that i'm going to send to a
P&amp;amp;S and then apns sends a notification
to your device so simple right so yeah
here's how you do all of that work on
the client side you do this so I'm I'm
being a little facetious you still need
to do things like enable notifications
and your capabilities tab and register
for the certificate in the first place
and so on but basically this call does
all the work needed on the client to
that hole hey let's request a token from
apns and then give it to firebase Cloud
messaging and get back a firebase Cloud
messaging token there's sort of some
very clever method Swizzle ngoan on
behind the scenes that hides a lot of
these details from you so basically at
this point on your end handling these
incoming messages are just like handling
typical apns notifications because they
are so you know there's very little
custom code you have to write to get
your app to work with firebase Cloud
messaging and now that I've told you
that you're going to go and look at our
documentation Oh actually I'm going to
hold that thought that's right I want to
also point out the first thing that
we're asking you for or that we ask for
from a penis is a silent notification
and that's important because you know as
a developer you want to decide when
you're going to ask for those more
visible notifications with the badges
and the sounds and the whatnot right I
think apps used to kind of ask for these
immediately upon startup but users are
like why do you want to send me
notifications I don't want that and they
would decline you know
in fairly large numbers and so now you
know the best practice is from server
for apps to say hey we would like to
send you notifications for these reasons
doesn't that sound great and the user
says yeah that sounds fantastic and then
you write this code to bring up the the
system dialogue that then request these
notifications so you know don't worry
you can still do that using firebase
Cloud messaging yeah so like I was
saying you don't have to write in a
custom code to actually get firebase
Cloud messaging to work and then you're
going to look at our documentation and
you're going to see this custom code to
connect to firebase Cloud messaging and
you're gonna be like what's that all
about I thought you said I didn't have
to do any of this and the answer is that
you can also send messages through
firebase Cloud messaging directly to
your app if it is in the foreground
without having to go through a P&amp;amp;S or in
addition to going through apns and so
why would you want to do this well
mostly for redundancy click there we go
it also turns out that firebase Cloud
messaging does tend to be a little more
aggressive about delivering medium
priority messages so that it helps too
but really it's it's it's about sort of
redundancy and so what will happen is
within your app when it goes into the
foreground a little trouble clicking
here there we go when your app goes into
the foreground you will explicitly
connect to firebase Cloud messaging and
then when your app goes into the
background you will explicitly
disconnect and that's basically how
firebase Cloud messaging knows whether
or not to use that channel to
communicate to your app and the nice
thing is that firebase cloud messaging
does go through the does go through the
process of D duping those messages for
you so from your perspective it only
looks like you get one so why do I want
to do this mostly for redundancy the
other interesting thing that we've
announced around notifications is the
firebase notifications panel this
basically makes it a lot easier for
non-technical members of your team to
send notifications there will be times
that you're still going to need to write
custom curl calls and server logic and
all that stuff but this does cover a lot
there's two pretty cool things I want to
point out here first is that we can
target audiences to receive these
notifications so I can you know send a
notification to people who have bought
stickers for my in app store in the past
and tell them hey we've got some new
categories of stickers go ahead and
check them out and then we also define
conversion of
so we can see how effective a
notification was basically within
firebase analytics if there are
important events that you really want to
track like these are making a purchase
or subscribing you know to your
newsletter or signing up for a premium
service or that sort of thing you would
identify those as conversion events and
then you can tell firebase notifications
hey I would like to identify this
conversion event as sort of the
successful conclusion of this
notification so then for every
notification you send you can see the
number of you know number of people that
got sent to the number of people who
then opened up that notification or I
guess number of devices because the
person who have multiple devices and
then the number of times that
notification led to a conversion event
that's really useful in case you're
wondering if your notifications are
actually being helpful or not right are
they being spammy or are they actually
sort of being helpful to the users that
you're targeting and so you can kind of
look and see you know how many of them
are being opened how many of them are
being acted upon and it can kind of help
you realize either like I need to target
my messaging a little more or I'm doing
a good job so that was a lot of stuff to
cover and I haven't even covered a whole
bunch of other features yet like
firebase storage and AdMob and and other
things like that and normally it's at
this point that would be plugging route
85 which is my little show on the Google
Developers YouTube channel but I'm not
going to do that we've started a brand
new YouTube channel just for firebase so
em it's not called firebase developers
is just called firebase but you can find
it at youtube.com slash firebase where
we will probably be hosting a whole
bunch of screencasts on how to get
started with some of these features on
both on iOS and Android you know as we
start building out these libraries and
adding cool features and adding new
stuff they'll they might get out of day
pretty fast but that's okay it keeps me
in a job keeps me employed so if you
want to find out more this is where you
can find firebase this is where you can
get some nice health and support we've
got our YouTube channel we've got our
twitter feed and with one minute
remaining i'm going to say thank you
very much I'll take questions down here
thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>