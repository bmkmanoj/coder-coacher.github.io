<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Progressive Web Apps on Firebase - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Progressive Web Apps on Firebase - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Firebase/">Firebase</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Progressive Web Apps on Firebase - Google I/O 2016</b></h2><h5 class="post__date">2016-05-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SobXoh4rb58" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everybody so I have some good news
and I have some bad news the bad news
Google i/o is almost over we're all
gonna have to go back to our day-to-day
lives very soon the good news is there's
still enough time for me to tell you a
bit more about progressive web apps that
doesn't that's what it doesn't really do
it for me there's still enough time for
me to tell you about progressive web
apps yeah now I'm really excited about
progressive web apps because I love the
web the web is the biggest most
important distribution platform on the
Internet it democratizes content and
lets anyone publish their content
publish their idea to anyone else with a
super low barrier to entry
but of course Mobile is very important
and the web experience on mobile hasn't
always been great but progressive web
apps are here to help us bridge the gap
between where we wish mobile web was and
where it is and you may have heard a lot
of things about progressive web apps all
these technologies that go into it all
of the different things that make it up
but really progressive web apps boil
down to two key ideas you need a
first-class mobile experience for your
site that means that if I'm looking at a
site on a phone it feels like it belongs
on that phone it has nice big touch
targets it feels like it belongs on the
system and the other thing that's kind
of unique to progressive web apps and is
available for the first time to web
developers is that you need a
first-class connectivity experience so
whether I am at home on blazing fast
Wi-Fi powered by Google Fiber or I'm in
a subway somewhere with no connection at
all I should still be able to get access
and benefit from web applications and
really that's not something that's been
possible for a long time but really
progressive web apps it's not some
separate thing it's not some totally
separate system that now we're buying
into and before I built web apps but now
I build progressive web apps progressive
web apps are just a new set of practices
and technologies that help us build good
web apps and of course picking
technologies for building web apps is
pretty hard there's tons of things
out there it's hard to know exactly what
to pick who to use why to pick that's
this stack over another stack and as you
might notice from my shirt I'm a big fan
of firebase firebase is an integrated
suite of products that help you develop
your applications grow your user base
and earn more money and for web
applications firebase can save you a lot
of time and hassle of choosing what's
the right way to do X or what's the
correct thing to do for y so let's say
that I have an idea I want to build the
world's first 100% emoji powered team
collaboration app I'm really excited
about it and then I go to Jake Archibald
to talk about service workers and
realize that maybe it's the world's
second 100% emoji powered team
collaboration act so I need to move
quickly I need to be able to build
something and get it out there so the
emo joy doesn't run away with all the
users that I want so I might integrate
with firebase off so that users can
easily sign in using their Google
Facebook github Twitter or email and
password credentials and get into my app
quickly and then I need a place to put
all that application data so I'll use
the firebase real time database so that
no matter what client is access whenever
any user changes data in my system it's
instantly synced to all other connected
devices without me having to write
complex polling logic or anything else
firebase off and firebase database make
it really easy to quickly build powerful
web applications and now I need a place
to put that web application so I might
want to deploy it to firebase hosting
firebase hosting is a static web hosting
service that / - Flo your site to a
global CDN with a simple command line
invocation it takes just a few seconds
and it's really easy to get started so
now I've built my web app and I've got
some idea of what I'm doing and I've
deployed it to firebase hosting so let's
take a look at my web app so this is Tim
o G as you need to start a web server
here so team o G is a simple web
application built using firebase and
polymer
which is Google's Google's library for
helping you build web components and
integrate them into your applications so
if i refresh here you can see I have tea
emoji and I'm gonna sign in with Google
ooh the demo gods are already against me
but it's gonna be all right here we go
so I've signed in with Google and as you
can see I can see my team status updates
and I can update things so since I've
already had like to demo failures I'm
feeling a little nervous right now
and I want to let my team know that now
I can also create a new team so let's
say let's make a Google i/o team here
all right so I've made my Google i/o
team and you know I'm feeling a little
bit better because it hasn't had another
train wreck just yet
so this is my application and you know
it works pretty well if I am a web user
and I access this whether it's you know
in a browser simulating a mobile device
or on a real mobile device it's gonna be
a pretty good experience but what
happens if I go offline well that's not
a great user experience in fact that's
not any user experience my app is
completely gone and you might have heard
a lot about offline first with regard to
progressive web apps but that's not
really the only important thing because
believe it or not connectivity is pretty
good in a lot of places or at least it's
good enough so you're not gonna be
offline much of the time but there might
be a pretty good significant portion of
the time that you don't have the best
connectivity so let's say that I have
just a regular 3G connection and I want
to load my team og app and I'm gonna
have to vamp a little because this takes
actually a really long time so low
connectivity and web applications
traditionally haven't mixed very well
that was maybe ten or fifteen seconds to
load my web application and that's not
really acceptable to my users if I hit
that every time I want to go update my
emoji status no one is going to adopt my
application so we need to use new
technologies to make this a better
experience
right now I have my web application and
like I said there's nothing wrong with
existing web applications and existing
technology if I have a good internet
connection
I can build a web app that leaves my
users feeling really happy much of the
time but we can do more we can integrate
our web application with the platform a
little better so that I get things like
a nice in a nice icon on my home screen
or a splash screen when I'm loading and
now my users feel more like hey this was
designed for mobile this is something
that I can use we can go even further
and cache our application shell so that
the the bare bones and the chrome of our
application are ready nearly instantly
as soon as we boot the web application
and now my users are really happy
because that's what they really want
they want my they want the app to be
fast they want it to work where they go
and then we can take it one step farther
and actually make your application data
offline so that even if they have no
connectivity at all they can still use
your application and that makes them so
happy they turn into a cat for some
reason so I'm talking about progressive
web apps and something that I really
want to emphasize is that progressive
web apps believe it or not are built
progressively this isn't something
that's all or nothing you don't have to
do everything that I'm talking about
here today all at once and you know
spend months developing it and then do
some big bang launch each of these
technologies can be implemented
piecemeal one by one adding new features
to your web application making it a
better experience on mobile and making
your users more happy because that's
really what it's all about
and so you know what forget what I said
earlier progressive web apps aren't just
a way to build good web apps because we
could already do that progressive web
apps are a way to build great web apps
and so how do we achieve that greatness
where do we go to get from where we are
today to a great progressive web app
that works in all of these situations
well something that I want to sort of
emphasize and remind you is that users
don't care what technology stack you use
to build your application they don't
care which framework you choose they
don't care even whether it's a native or
a mobile app for users
if it looks like a nap if it feels like
a nap it's a nap that's all there is to
it they just want a good experience and
so what we're gonna do today is we're
gonna take this team og app and we're
going to add better and better
experiences so that it becomes a
first-class mobile application the first
thing we're gonna do is really easy
we're going to add a web app manifest to
our application now a web app manifest
is just a new standard that allows you
to provide some JSON metadata about your
application so that browsers and
operating systems can pick that up and
use it for various hints about how to
work so here's what it looks like we
have a JSON object we add a name and a
short name so the short name will be
used under like an application icon on
the home screen the name might be used
on the splash screen as it launches we
have a theme and background color the
theme color is going to go into the
title bar on Android when you're in your
task switcher the background color is
going to be the background of your
splash screen as the application
launches we have some configuration
about display and orientation so the
display mode is essentially when I
launch this app what do I want it to
feel like standalone is sort of the
closest analog to used a standard native
mobile application it launches in its
own window there's no browser chrome
around it you can also do a full-screen
mode if you're building a game or you
can bring browser UI in if you haven't
completely converted to a to an app
friendly UI and then finally you want to
provide icons and you have to provide a
big array of icon sizes to support all
the different platforms and everything
they need and that's kind of a hassle
and honestly remembering the names of
all this stuff and what I have to do
also kind of a hassle so I built a
little tool called the web app manifest
generator it's available at app manifest
at firebase app comm and I'll take a
quick moment to show you what it looks
like here it is we can put in team og
team status put in my name my short name
let's see I want a nice material design
amber for this I think that's what I'm
feeling so I'll paste that in I want the
standalone this app is designed for
portrait mode
and then finally I just need to pick an
icon so I'll pick my logo and this will
generate a zip file that contains your
manifest JSON as well as resized icons
for all the different sizes you're
likely to need again this isn't a
complicated tool but it saves you some
time makes it easier to get started you
have literally no excuse to not add a
web app manifest to your application so
I'm gonna install this web app manifest
and what is the result well if I look at
my web app on my phone after installing
a web app manifest I'm gonna see a home
screen icon if I do add to home screen
I'm also going to get a home screen to
install banner if I use a web app
manifest and some of the other
technologies we'll be talking about in a
few minutes if I load the app I see this
nice splash screen so rather than just a
blank white page of Chrome trying to
load the pay load the app I see this
nice splash screen that waits until the
application is started loading to kick
it over to the browser and I see this
nice themed title bar so with just a few
minutes of work just adding a JSON file
into our application and then
referencing it in our HTML we have
already made our app feel a lot more at
home on mobile so now our users are a
little happier and what's next well you
may have seen a statistic recently that
the average web site is now as big as
the as the original doom game from the
early 90s it's a little bit over 2 Meg's
so every time you go to a web site on
average you're gonna be downloading 2
Meg's worth of content and that sounds
like a lot and it is a lot but I want
you to keep something in mind web apps
are kind of held to a higher standard
here if you look at the top three
applications and Android each one of
those is over 30 Meg's you install those
that's 15 times the average web site so
web apps are held to this sort of
different standard because traditionally
every time we go to the web app we're
loading all that content again unless we
get really lucky with Brout with recent
browser caching so of course there has
to be a better way and there is we can
offline our app shell now the app shell
if you've built single page applications
that's just all the JavaScript HTML
CSS and images that make up your web
applications Chrome not the user data
but just the stuff that needs a
bootstrap in the browser for your
application to be able to run and if we
want this to be available offline so
that our users have a fast experience
even with slow connectivity we're gonna
use serviceworker so serviceworker is a
new low-level browser primitive that
allows you to install a JavaScript that
runs in the background whether or not
you have a web application open if you
do have it open it runs in the
background you can pass messages if you
don't have it open the serviceworker can
intercept network requests and decide
how to handle it so it can intercept a
request and say oh hey I have a cache
version of this locally so I'm gonna
serve that up instead and you can do
really cool really complex offline tasks
using serviceworker and there's only two
things you have to know you have to do
to be able to use serviceworker first
you need a secure connection
serviceworker only works over ssl it
also works on localhost so you're not
you're not totally in trouble if you're
doing local development but if you're
deploying to a production server it has
to be running SSL the other thing the
serviceworker needs is a complex
understanding of browser caching and
networking semantics and then how to
write all that code so that it handles
it properly Service Worker is not simple
it is powerful it is not simple and
that's actually great because
serviceworker gives us powerful
primitives that we as developers can
build on top of to make an easier
experience so how do we get these two
things that we need well first of all if
you need a secure site I highly
recommend firebase hosting because as of
Google i/o you get a free custom domains
with SSL bring your own domain will
provision a certificate for you you
don't have to do anything it all just
works so I'm pretty excited about that
I've wanted it for a long time
the other thing that you can use is a
library called sw-precache this is an
open source node library that basically
gives you an easy way to generate
serviceworker javascript so this is a
task that you would run in your normal
web app build process that'll generate a
serviceworker for you and do most of the
heavy lifting to get your app show ready
to go offline and there's two types of
data that it caches it caches static
files so that would just be your actual
like application files in your project
directory all the JavaScript HTML all
that stuff and it also caches remote
files so if you're using fonts from
Google web fonts or you're loading
images from a CDN or JavaScript
libraries from a CDN you can cache those
on demand using sw-precache as well so
first let's take a look at how we cache
static files here I'm using gulp as an
example because it's popular but SMU pre
cached is just a node module you can
install it in any build system or just
run it independently as a command-line
tool so I'm defining a gulp task called
generate service worker and I require my
sw-precache library and now I call
sw-precache
right and I just point it to the service
worker JavaScript that I want to
generate it's important to note that the
service worker should always be in the
root of your web application because
service workers are only able to do work
on things that are at the same level or
lower in the browser hierarchy so you
always want to put this at the root so
that your service worker can do
everything you need it to do next I give
it a cache ID which is anything you want
to call it but probably the name of your
app and I provide a list a glob of the
static files that I want to cache in
this example I'm picking pretty much
everything from my Brill directory you
may or may not want to do this depending
on the size of your application there
are limits to Service Worker caches and
really big ones will have things evicted
so you're gonna want to sort of tune
this and play with this until you have
just the right stuff to like bootstrap
really fast and then finally we stripped
the prefix disk so that the urls all
work because our build directory is disk
it's no big deal
the other thing that we need to do is
register the serviceworker so first
we're going to detect if the browser has
service workers because of course these
are progressive web apps
to build progressively we don't want to
break browsers that don't support it yet
if we do have serviceworker then we just
call navigator serviceworker dot
register and point to our generated
serviceworker this returns a promise
that will complete when the
serviceworker is registered or of course
we can see if any errors happened and
deal with that as well so this is really
the simplest way to get started with
serviceworker and now we've cashed our
static files offline by generating a
service worker with sw-precache
and we've registered it in the browser
the other thing we can do is cache
remote files and this is just adding
additional configuration to sw-precache
for runtime captioning so here's an
example of I want to cache anything from
Fahnestock Google API is calm and I want
to use a cache first strategy so cache
first means that well web fonts don't
change very often so I can always depend
on the cache version because I don't
expect the network version to be any
different and that makes it really fast
that means it's gonna respond from the
cache immediately however for other
things like profile pictures or firebase
storage URLs from things you've uploaded
those things might change and so you're
going to want to use Network first and
network first just says go to the
network if I get a response use the
networked response but if I don't use
the cached response and that's what
allows it to work offline so that zest
of you precache that's caching our app
shell offline so let's add this to tea
mochi I'm gonna go over here and pull up
my gulp file and the first thing I'm
gonna do is define my gulp task and
again this is exactly what I just showed
you with a little bit more configuration
but nothing too different and I'm gonna
add that into my build process so
generate serviceworker can't so now
that's in my gulp file and of course I
need to register it as well I have this
app KS which is loaded immediately on
page load and so I'm gonna register my
serviceworker in here and i've added a
little bit of extra logic here so one of
the things that you may have seen if
you've used Google inbox or other
progressive web apps is that sometimes
they'll pop up a little notification
that says a new version is available
click to refresh
and that is what we're doing right here
so we can detect if a service worker was
already installed and has just been
upgraded and we can display a message
that says hey there's a new version you
might want to refresh or if it's the
first time we can just let people know
hey team og is now offline ready so now
we have added this to our gulp file
we've added it to our application
JavaScript let's build this and see what
happens so I'm gonna go back over here
I'm gonna use my full network connection
to get the first page load and now you
can see at the bottom team og is now
offline ready and now let's say you know
I'm out and about and I'm not on a great
connection I'm on lg Paris is a little
harsh let's go as regular to GE so I'm
gonna refresh my page and you can see
that loaded up in a couple of seconds
versus the 15 seconds it took before so
by adding a few lines of code to our
code
sorry if you want to apply go ahead so
with a few lines of code in our gulp
file and a simple serviceworker
registration in our app JavaScript we
have now made our app way more usable on
poor connectivity experiences but our
app isn't going to work completely
offline yet because all we're doing is
caching the shell so what comes after
this
well of course oh sorry now our users
happier moving on
of course the final goal of this is to
have that truly first-class experience
and if you can have offline data if your
application can work when there's no
connectivity at all then your web
application stands toe-to-toe with
world-class native applications there's
no difference from your users
perspective they can use it offline it's
snappy it's responsive it's all of the
things that they're looking for and you
don't have to go native to get all of
those advantages so finally we're going
to offline the data in our application
and to do that we're actually quick
caveat before I continue this is the
part that is most app specific
there's different strategies that you
might want to use when you go offline
for some applications you might need to
store a draft of a document and then
when you go back online you sync it for
other applications and many applications
all you really need is kind of a view of
what they were last looking at and
that's useful enough so for this example
we're going to use a read-only offline
cache so as I described all of my data
is in the firebase real time database
and ordinarily what I would do is take
that data and display it directly in the
browser but in order to support a full
offline reload situation I'm going to
put one step in the middle I'm going to
add an index DB mirror so I'm going to
take all that data from the real time
database I'm going to mirror it locally
into index DB which is an offline
database that's available in most
browsers and then I'm going to use the
browser only to access that offline
mirrored data by using the browser only
against the index DB data that means
that when I'm offline the browser
doesn't know the difference it's just
reading the same data that it was
already reading but when I'm online I
can use the browser to push directly to
into firebase and update my changes so
this is a relatively simple thing to
implement but offers powerful features
by mirroring all your view date all of
your data locally and here I'm going to
get a little help from my friends at
polymer so there's two new things that
I'm excited to announce today the first
being polymer fire an official set of
bindings for polymer to firebase and the
second that the polymer
the second thing is app storage which
was built by the polymer team as part of
the polymer app toolkit and provides
easy ways to do things like mirroring
data offline so we're gonna use these
two things together to take our data and
make it available completely offline
let's see how that works so first here's
how we use polymer fire I'm going to
import the element into my application
if you're not familiar with polymer
import if you're not familiar with
polymer the link rel import is
essentially a script source you're
importing into your application and then
I'm going to use the firebase app
element to sort of setup and configure
my firebase application all of the data
that you need to put into this is
available from the firebase console for
your project so you just take those
values copy and paste them into your
application you put one firebase app in
your page and then it's initialized
across everything next I want to
integrate firebase off so first I'm
going to add a firebase off element into
my page and I'm going to select a
provider in this case I'm using Google
authentication and I'm going to bind the
user into my application so the user
will be null if I'm not signed in but it
will be various user data if I am signed
in so how do I get between those two
states well I implement a simple login
function here that calls the sign-in
with pop up method on the firebase
authentic a in JavaScript and that will
trigger a sign-in flow which will then
populate the user which will then bind
into my application and it all just
flows through so my actual application
code is really simple I like I can
display a welcome message if I detect
that there's a if there's if there's a
user and I can display a login screen if
there's not a user now for the firebase
database things are also very simple if
I want to sync a document so an
individual document say I have user
preferences and I want to sync all of my
preferences into the browser and use
those I use the firebase document
element I provide a path to the document
that I want to sync and then I bind that
data from the data
property into my application I can also
use a fire based query element which
allows me to query collections in
firebase using all of the same query
properties that the firebase database
allows and then sync that data into my
path and so this is this is how I
originally built emoji I used these
elements I built the application but at
this point it's still not offline
because while the firebase database
supports offline if you lose
connectivity and then come back online
if I hard refresh the page all of that
data is gone because it's just an
in-memory cache so the once extra step
that I need to take is to integrate app
index DB mirror so here's my firebase
query element as you can see I've got
I'm querying updates from a user the
current user that I'm binding into the
path I'm providing some various query
elements or some query properties and
now I'm going to import app index DB
mirror from the app storage element app
index DB mirror does exactly what you
saw in the diagram it takes data that
gets bound into it and it creates an
offline mirror of it and then makes that
available to the browser whether or not
you have connectivity and the way that
I'm gonna do this is first I'm going to
bind the data from my firebase query
instead of into a public variable I'm
gonna bind that into a private variable
that I'm gonna call FB updates now I'm
going to add an app index DB mirror
element and you can see that this
actually mirrors in many ways the
properties of my firebase element I have
a key that tells didn't actually be
where to store it and the great thing
about this key is that as that user dot
UID changes as I'm loading different
data so if I have you know a switcher
where I pick between multiple things all
of that data is going to be cached
offline to those different keys so I can
still have that same UI state change and
all of that data even when I'm offline
the session property there simply says
if if this diff this value changes we
want to wipe out everything so if I have
a user that logs out and a different
user logs in they're not going to see
the other users data it's all just going
to be wiped away and so what I do with
the app in
xev mirror is I bind the FB updates
variable that I that I pulled out a
firebase query into the data property
and then for my application I use the
persisted data property which is the
data that has actually been persisted
into index DB and that's really all
there is to it once I've implemented the
app into X DB mirror alongside firebase
query my data is going to be available
offline so let's take a look at that I'm
gonna go into my app my main app element
here and I am going to so here you can
see that the only data that this that
this app needs is some preferences the
updates for the current team that I'm
looking at and the list of teams so what
I'm gonna do is I'm gonna take all of
those and I'm gonna replace them with
equivalents that have app index DB
mirror and this is just exactly the
pattern I just showed you I'm mirroring
into the key I'm using the session it's
everything that you just saw and that is
what makes my data available offline now
one other thing that I'm going to show
you here is how to use the browser to
detect offline State so that you can
change your UI since I'm implementing a
read-only offline cache that means that
I shouldn't be able to I shouldn't be
showing my users a button where they can
make an update if they're not able to
while they're offline so here in an
initialization function I'm going to
just throw a little JavaScript and this
is just straight from the browser this
there isn't anything special about this
the navigator dot online tells me if I'm
currently on or offline at least
according to the browser and again this
is no connectivity versus some kind of
connectivity so even if you have the
world's worst connection this will still
be online but it does give you some
semblance for when you're totally
offline and then I'm going to listen to
both online and offline events and just
set a property on my main app element
now I've already done some work of
wiring in data to change UI state
throughout my application but remember
that all I'm really doing to change all
of that is setting offline to true or
false based on whether I did
that from the browser so I'm gonna save
that I'm gonna rebuild my application
and once it's ready now I am going to
refresh I'm gonna turn off throttling
for a moment oh and I just refreshed out
of it but you could see for a moment
that a banner popped up at the bottom
saying a new version of tea emoji is
available click to refresh whoops oh and
I missed actually importing the adapt
indexdb mirror element so that didn't
work first try let's give it another
spin and server has started refreshing
so now you can see I'm online my data
works I'm feeling I'm feeling a little
bit better again so I'm gonna go ahead
and update my status I'm feeling pretty
good and now I'm going to do something
that to me at least seems like a really
bad idea to do in a live demo and I'm
going to turn off my Wi-Fi so now I'm
offline and as you can see the UI state
pretty quickly changed and reflected hey
you're offline but of course this would
have all worked with just normal
firebase SDK JavaScript because firebase
is does keep an in-memory cache and
everything will work fine so long as I
don't refresh the page so let's refresh
the page it comes back online almost
immediately and now my app is fully
offline
so that's how we build a progressive web
app and that's how we make users not
just like our application but love it by
providing them the features and the
utility that they need regardless of
connectivity regardless of device if
they use this on the desktop if they use
this on their phone it's all the same it
all works great and that's the promise
of progressive web apps so now that
we've taken our application to the next
level what do we do after that well
there's several things you can do of
course you can implement offline right
you can make it so that you can compose
data offline and when you go online it
will sync and the polymer fire app
storage duo actually does support this
there's a code lab available that'll be
linked from the end of the talk that you
can go through that'll show you not only
how to create a read-only cache but also
how to create write offline data we can
also use the web push API so it's a new
standard that allows you to receive
notifications whether or not your app is
open on the web you can use firebase
Cloud messaging to send messages to your
browser users and they will receive that
as a native notification from chrome and
they'll be able to click and re-engage
you can also do a surprising amount of
things with the web and phones there's
this cool website called what web can do
today and if you go there it'll show you
all of the device capabilities that your
phone's browser is capable of handling
everything from geolocation to taking
pictures to even accessing Bluetooth
beacons or the gyro there's a ton of
stuff that I didn't even realize until I
saw this site that you can do today with
phone capabilities in the browser and so
again progressive web apps are all about
building layer upon layer to make your
browse to make your app experience
better to make your users experience
better and to make great web apps so
that's all I've got
thank you for listening if you're
interested in hearing more I'll be at
the firebase office hours in stage 6 and
15 minutes everything that I just
presented is available on github and if
you want to talk more you can also go to
bittley's
PWA is on firebase and chat in the
Google space so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>