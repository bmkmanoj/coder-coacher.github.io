<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Extending Firebase to the Web (Firebase Dev Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="Extending Firebase to the Web (Firebase Dev Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Firebase/">Firebase</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Extending Firebase to the Web (Firebase Dev Summit 2017)</b></h2><h5 class="post__date">2017-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/puUqJTJVz5A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">are we all excited for the summit
yeah great well as we just heard from
Sam Francis and Kristen there are a ton
of great things happening in firebase to
provide you with the tooling and
infrastructure for an easy and powerful
experience for developers today we want
to talk about how to extend great native
experiences to the mobile web
I'm James Daniels developer relations
for firebase that America dodge UX
engineer on firebase the past decade
we've seen a native first approach to
development where companies will opt to
provide a superior native no Popol
experience for ios and android while
their web experience suffers it goes
stale or it's non-existent we're here
today to show how simple it is to
provide a powerful and consistent
experience for native and web users in
this session we'll play the role of
publishing company the exploring
firebase as a solution to build a
compelling website for our passionate
users so we're gonna take off our fire
beats hats for now and introduce on
snapshots on snapshot is an android
application that provides news and
updates on all things firebase our
parent media conglomerate sought to
disrupt the traditional firebase news
space and boy has exceeded where the top
app on the imaginary Google Play Store
Aza users like you love the application
but what didn't you like to be able to
read the articles at your desk what if
you're concerned about space and
resources on your phone well we can work
on a mobile web solution for you our top
concern is consistency and a great
experience so I'll be focusing on the
engineering components and Eric the UX
man will be looking at those
considerations
Thanks today's most modern of web apps
are progressive web apps also known as
PW AIDS and they use things called
service workers to manage Network
requests and emulate a native experience
without being locked into a single
mobile operating system so how will the
PWA s help us create a great web
experience our app has to be reliable it
has to be fast and it has to be engaging
so what does all that mean reliable
progressive web apps load instantly
regardless of the network state by
pre-caching key resources we can
eliminate the dependence on the network
ensuring an instant and reliable
experience for our users needs to be
fast 53% of our readers will abandon the
site if it takes longer than 3 seconds
to load and once loaded users expect
them to be fast
no janky scrolling or slow to respond to
interfaces lastly needs to be engaging
progressive web apps are installed well
and live on the user's home screen
without the need for an app store they
offer an immersive full-screen
experience with help from a web app
manifest file and can even reengage
users with web push notifications now
the web app manifest allows you to
control how your app appears and how
it's launched you can specify home
screen icons the page to load when the
app is launched the screen orientation
and even whether or not to show the
browser chrome makes sense right but how
can we at on snap snap shop to use
firebase for our progressive web
application it's a couple things that we
need to accomplish here we need to store
our articles visitor counts cache the
content get some good performance at it
so we won't need a back-end engineer if
we use firebase right that's a great
thing about it we don't have one we're
just two javascript guys so we can just
do front-end so up first we have the
storing and the comments in a scalable
way we have these little nice mock-ups
of what we're trying to accomplish here
building this application
so there's of course the fire based
real-time database that's firebases
first product it's a JSON store clients
connect through WebSockets SDKs are
provided so no back-end needed the
validation all the rules are there on
the server now all that complexity of
synchronization conflict resolution
infrastructure is gone and it binds
directly to the UI
there's also Google Cloud datastore
so we're storing articles txt and a
bunch of comments underneath of it well
what if we get us back to add replies to
comments and then replies to those
replies and replies to replies to
replies we also need to have an author
view right so that's going to be complex
querying that's very difficult in the
real time database we have to adjust our
schema you know move around like our
data and how we're thinking about it so
what cloud datastore it's more like a
traditional datastore but now we go back
to the problem of needing a back-end
developer it has some properties that
are useful though so the shallow queries
and then also we can do things like ants
so we could put together that article
page and pagination is easier so what if
we took the best of both worlds and
firebase has just done that with a new
product clouds fire story that's right
James cloud fire sword for firebase is
quite possibly the best cloud database
for mobile and web it's easy to use it's
real-time highly scalable and has rich
querying capabilities we're able to use
a collection document model structure
our data hierarchically and use those
rich data types here's a sample document
a document can consist of many key value
pairs with available types of arrays
boolean x' bytes date and times floating
point numbers geographical points in
Maps nulls references and of course text
rings and here's a sample collection a
collection is a grouping of documents
and a document itself can have some
collections hey James I think this will
work nicely I think so too
so that's storing our articles and
comments now what about our live viewer
count we we chose firestore for you know
the text the comments but is it really
suitable for this live visitor count or
could we actually use the best of both
tools and go back to the real time
database so there's a couple properties
here that make it really awesome for
this live viewer count namely presence
indicators so when we establish this
WebSocket connection to the database and
query the data get the updates we can
provide on disconnect and I think this
will really help our problem so how do
we reliably you know decrement the
counter when someone leaves the page
when you do on disconnect the action
that you tell it to take on the database
is stored on the server so when that
socket disconnects that action is
executed and you can update the database
so what are we storing well there's fire
based on anonymous authentication I
think that'll work so here you know we
tend to think of users as needing a
username a password or to go through an
OAuth flow or maybe sam'l if you got
some corporate stuff but here any
visitor that hits our site is going to
get a user ID and we can use that in the
database we can use that in our database
rules and if they do log in to create a
full account link their username
password then those identities will
merge so I think for our use case this
would be perfect
now caching the content making it fast
right so the thought here is that we
could actually use cloud functions for
firebase so this would allow us to serve
our JavaScript application
we're just front-end engineers right we
don't need to build servers we can just
have a JavaScript application we can use
cloud functions to serve that dynamic
content we can pre render the pages we
can improve our SEO one of the problems
with you know search engines is when
they hit a JavaScript page that's a lot
of complexity it's not right there in
the HTML straight away so if we pre
render it those spiders can crawl our
site and then social sharing right so
when you put pants post something in you
know Twitter or Facebook then you want
those images you want the description to
come across and that won't happen if
it's a JavaScript application that
doesn't have that rendering and then the
integration with firebase hosting well
that'll let us hook up a domain name for
free with SSL and that ties into what
I'll be speaking about serve the website
securely so once our site is ready for
production we can connect our own custom
domain name to firebase hosting and
firebase handles a configuration for us
and automatically provisions an SSL
certificate so all of our content is
served securely and remember pwh need to
be served over HTTPS this is a big win
lastly persist data for offline now
pwace are the new hotness in part due to
their offline capabilities cloud forest
store was built for offline persistence
so an interim loss of connection say
while you're going through a tunnel or
an extended amount of time say a
long-haul flight will not interrupt the
complete functionality of your app the
serviceworker uses knowledge of our
application files to efficiently serve
code and content from the offline cache
and act as the proxy to all user
requests and ensure the that unnecessary
traffic is avoided
so firebase has provided us with the
solutions that we need to build this so
let's get coding I am actually fond of
angularjs I really like its integrations
with rxjs I like functional programming
so let's put together our app first off
we of course have our home page where we
have that list of articles and then we
jump in and then we see an individual
article so let's walk through this so
the first thing that we're doing is
we're actually pulling in angularfire
store from angular fire angular fire is
a plugin it's in the official angular
plugin for firebase so what it's going
to do is it's going to very lightly wrap
all those calls the real time database
to fire store is gonna wrap them and the
concurrency primitives that work well in
angular namely observables are the SDK
it's pretty close they're super close
they're super close so here we have an
array of document change actions and
that's just rats that dock this data
snapshot and it's an observable we
inject angular firestore into our
constructor and then we grab the
collection so it's really really similar
to the SDK we just have this extra
snapshot changes and a little bit
different syntax around the query so
we're grabbing the collection of
articles that's going to wrap this we
then pass the ref add all the parameters
that we want into this query and this is
a great thing about firestore as this
could be very complex right we could go
over many many different fields and then
we call dot snapshot changes so DAP shot
changes as what's going to hook up the
listener and then wrap it and I'm gonna
preserve able here we're doing a similar
thing for the article view
though if you see is an observable of
document gene action not an array of
them so a single article now we're using
the angular router so that each one of
these articles has an individual
shareable URL so you can copy/paste it
you could reload the page you could put
into your favorite social network and
share it so we pull in the activator
route from there and then this is rxjs
who here has used rxjs a couple of years
in hands who really Grox rxjs there's a
lot of complexity there awesome so this
is a switch map so let me jump into a
switch map real quick so a switch map
takes a data source an observable say in
this case a and it takes a second
observable and it maps them in such a
way so you see there's the first one a 1
2 3 so red 1 2 3 blue 1 2 and then
yellow triggers well where the 3 go so
this is really important for our router
because if we navigate to a page we
establish a connection to the real-time
database or fire store and data's
streaming at us we want to abort that
stream if the user switches URLs we
don't want that data to be streaming on
to another article and getting all mixed
up so that's what the switch map
accomplishes for us so you'll see this a
lot route params so you're pulling out
the parameters from the router and then
your switch mapping to something else
now like I said switch map is a bit
different than a regular map because
you're mapping it to a new observable
and here we're actually querying that
doc in fire store and again the snapshot
changes on to it now you could do this
in any web framework right I'm just
partial to angular so in the view we
have this acing
pipe so this is the article view very
basic we're going to be showing that the
title we're gonna be showing a you know
the author details and the date and the
body
so this async pipe is going to wait for
that observable to trigger so it kind of
lets us idle you know we can put a
loader on there or what be it then we
grab the payload data from it once the
async has resolved and you know if we
are going over all of the attributes
here all the keys that's a lot of code
to copy paste all over what if we change
one of those so we can actually assign
that to the variable article within this
scope so that's it we go over we print
the article title then we go again over
the arc author the author's a reference
to another point in the database so we
actually do that async and of course we
link to the article page from here and
the cool thing is these all magically
are hooked up to the real time database
or firestore and these are going to be
tripping and the view is gonna be
changing as the document changes so what
about the comments I now firestore is
proving great for our articles let's use
sub-collections to store the comments
from our passionate users I think I've
seen it enough code and watching a
firebase youtube videos to handle this
alright so here we're gonna be
introducing a new rxjs concept called a
behavior subject so we're actually gonna
be grabbing the collection going on a
behavior subject for it and how a
behavior subject works is it's like an
observable but it has an additional
property namely it has a concept of a
current value normally with an
observable if it's been firing and then
you subscribe to it you're not going to
get the previous events so here with
this marble diagram you can see I
initialize a new behavior subject with
the green
and when I subscribe I get that
even though no event has fired same with
the yellow right so a second subscriber
attaches and then it trips that it fires
down in so this is very valuable for
when we want to keep around a reference
to something that we may need later that
we haven't subscribed to yet also things
like authentication keep around the user
so we have this behavior set subject for
the comment collection so we're just
doing a map here so we're taking that
those parameters we're mapping the
parameters and we're pointing to a path
in the database we're not calling
snapshot on it yet we're not getting
that observable it's just pointing
somewhere in the database because we'll
need that reference later I then take
that map and start pushing the data into
that behavior subject now we can
actually switch map on that and do the
dot value changes so that we can render
our comments finally we're gonna do
sign-in right we want people who are
using the application to comment we want
them to sign in first so we know who
they are so here that's very easy very
much like the regular firebase SDK it is
is just wrapping it lightly now when we
log in here is actually going to trip
this observable AF auth off state so
that's going to trip
whenever the off state changes so we can
map that to actually get the users
profile somewhere in fire store and then
again we can start piping that to a
behavior subject so that's great so that
anywhere we need that profile we don't
have to be already listening for it and
we don't have to assign it to a
temporary available stuff like that like
I said if you navigate away from the
page you could get into a bad state
if you're doing stuff like that and
finally we can add a comment so here we
actually get the value so we're actually
getting the current value of that
behavior subject now this is a lot
better than assigning it to some
instance variable and here's what our
firestore console looks like so we have
here on the left the document so this is
our article then we have a collection of
comments underneath of it all the
comments and then the data and the cool
thing about firestore is this is all
shallow so with the real-time database
before this would have every time we
asked for the article it had to come
with all the calm comments now we can do
things like limit the comments and page
them that seems pretty straightforward a
lot of complexity very little code and
we didn't have to worry about any
back-end infrastructure now for live
view counts let's say we use anonymous
tooth authentication to get a unique ID
for our resources you our readers to sum
up how many are viewing at one given
time and we'll use cloud functions to be
the true source for incrementing and
decrementing those view counts and we'll
use the real-time database for storing
our values and providing presence James
can you show me how easy this will be I
can take a stab at it so here what I'm
actually doing is I'm listening again to
that estate so I have angularfire off
off state here I'm doing a filter on it
so I only care about the events where
the user ends up being no so no user I
then subscribe to that and whenever that
fires the users been signed out or the
user doesn't exist
then we will sign them in anonymously
the cool thing is we then get the user
identifier and if they go to comment and
they hit that sign-in with Google button
then it'll merge those two identities so
that's well again trip the angularfire
off state observable so here we're
actually going to be introducing a new
rxjs concept so we really need the route
parameters right we need that ID of the
article ends we need the off state so
with a combined latest what we're doing
here is we're waiting for both of those
to fire and then we're mixing them
together right so the first one say our
router resolves before the off state
does that doesn't fire an event when
both of them resolve they start flying
at an event every time one changes but
includes the previous value of the other
so once we're in here we now have fully
resolved the parameters so we can get
the article ID and we have the users off
state and we filtered it if you notice
before so that we're only listening for
when the user logs in when we say
sign-in and honestly or a sign-in with
Google it trips us again so we're going
to map that and we're going to look up
the ref in the database and then we're
going to store that as a visitor ref
behavior subject then on that visitor
ref we're going to filter it and we're
looking for it not being empty right so
then we subscribe we set the value as
true in the real-time database and
that's a promise so then we put that on
disconnect and remove the data if the
client disconnects so what this
accomplishes is the user gets logged in
anonymously if they're not already
logged in they get a user identifier
that user identifier is then written to
a list in the real-time database
underneath the article ID and then if
the websocket ever terminates say they
closed the web browser then it reliable
delete set user identifier from that
database list now we have one more case
what if they navigate away
well the socket to the real-time
database is still there it's not going
to trip that's on disconnect so I have
on on destroy on that component so that
if they navigate away from this page
then it's deleted so this is what it
ends up looking like in the real-time
database we have the article visitors
the article ID and then all the user IDs
that are currently looking at that
article so truly is anonymous indeed so
my fingers are tired from typing all
that could you take over for this I
think I can get it alright so let's try
using two cloud functions for
incrementing and decrementing now one
that is triggered on a create event and
increments and one the decrements on
delete using rules we've locked down the
admin ref so only functions can write a
view count value we don't trust the
client we're gonna use the server as the
true voice from here we get the root
reference we get the child article by
the article ID and trends actually
increment the current value now
decrementing is very similar but trends
actually reducing the current value by
one and there we have it an event-driven
transactional counter james does that
work for you yeah works for me and best
of all we didn't need to spin up servers
for it we don't need that back-end
engineer that we don't have just
JavaScript guys right okay and this is
what it ends up looking so we have those
visitors on the article and then it
bubbles up to this article view count
and that's the real-time database so
we're able to subscribe to that and this
is what it looks like so again we switch
map on the route parameters and yeah our
components getting a little messy here
maybe we'll do a refactor pass where
we'll pull these out into other services
but we just listen to the value changes
on that value changes are just like
snapshot changes in angularfire but they
include less metadata so we don't have
to unwrap the payload and the ID and all
that it's just gonna subscribe to that
value in the database and fire every
time now adding it to the view is super
simple here we don't have to unwrap
anything so we just say being read by
view count async so we use that async
pipe to let it resolve and then viewers
so now let's render our application so
we built it wait wait would this
approach be fast and optimized for
search engines oh well and unless we're
doing any server-side rendering now we
have a good website works locally okay
so well let's go ahead and pre-render
our content let's use angular universal
so that our pages are really really fast
pre-rendered and Google and other search
engines can actually crawl the content
and when we share those links we'll get
those you know the image previews the
description page title so here's how
we'll do it so here we're writing a
little server file here we're actually
pulling in the angular Express engine
we're providing the module map we're
pulling everything from our main bundle
that angular has compiled down so we
just created a server version of our
application gave it a different
injection point and then we're actually
using Express JSP so we make a new
Express app we attach the HTML engine
provide all the angular stuff and then
finally on any get request well this is
our cache control header right here so
we're actually using firebase hosting
distributed CDN and then we render our
index so how do we get that into cloud
functions well
there's a lot here so if we're just
pulling this in and we put this into
cloud functions my angular project has
what like a hundred 120 NPM dependencies
right out of the box and most of them
aren't used so what I'm gonna do is
actually compile it down with a web pack
so that I have one big file once I have
that file in the top here I have my
cloud functions code so I'm just going
to grab the application from that
compiled down server file call it
firebase and then I'm gonna export that
as angular universal and it's an HTTP
function and then in my firebase JSON
I'm going to put the proxy to that
function on any request so I just
deployed that it's up why don't you give
it a view pull out your phone's check it
out we got on snapshot comm let's see
how high we can get that live your
account now you just saw a lot of code
and I'm a visual guy so let's dive right
in to the web page now as I start here
I'm going to kick off an awed it so I
can take you through local now this is
going to go through and rate the
progressive web web app the performance
accessibility and best practices and
it'll take about 30 to 40 seconds so
let's switch over to the other tab now
here you can see the articles inline on
our home component let me refresh the
page and you'll see it's loading and
asynchronous it was so fast you couldn't
see that it was asynchronously loading
in the author etc now I'm gonna click
through to one of the articles and you
see how fast that was and then we have
some comments down here I'm gonna sign
in with my Google account here
and you see off kicked-in recognises Who
I am
hello audience and I'm gonna add my
comment there all right and up here
you'll notice there are two visit
viewers currently on this page okay now
I'm gonna switch over here and now we've
seen this all in online mode and let's
let's let's take a risk here let's go to
offline alright we're now offline if you
don't believe me
there's the disconnect okay so our
network is offline
alright I'm gonna click through and
wouldn't you know it it works all the
content is still there okay and we're
gonna go back here do now and even the
one that we haven't visited shows up
okay and we'll go back to online mode
here refresh it and if you ever want to
toy with the service workers etc and see
the values of the manifest in this
application tab and chrome you can view
all the values here and clear it etc
alright so in the result with our
remaining time we'll talk about some of
the results from this lighthouse so
it'll go through and as we said we want
the app to be fast reliable and engaging
so here we are testing it on 3G
connections it needs to be fast no
matter where in the world you are and
what kind of latency you you have on
your network so it'll go through and
check the latency it'll check your
serviceworker and all the that it's
served over HTTP it'll check the
painting so it's engaging like we said
if it doesn't load within three seconds
53% of our users will abandon the site
so it'll go through the meaningful
meaningful paints and it'll check the
accessibility because we want as many
users to use our app as possible so
that's looking good and best practices
there are other things like using web P
for your images or compressing your text
etc and so lighthouse is a really great
way to really meter your app and make
sure you're following best practices
okay and then we have an author view as
as well so have fun playing around with
that
okay so let's review so here we've we've
used cloud firestore cloud functions
real time database hosting and we use
angular and angular Universal you can
use react react whatever in order to
accomplish your three-way data binding
and your server-side rendering there's
all kinds of stuff that I am really
excited to add before I go on my
refactor I'd really like to get FCM in
there send notifications when users
comment or reply on your comment or when
new articles comes up really engage
things I really want to get an RSS feed
in there maybe an amp version so that we
can get a little higher in the search
engines and subscribe users to our memo
I think we're about out of time these
folks have busy schedule today and have
other talks to get to so let's leave it
there for now
so for those interested we actually
open-source us right before this talk so
you can check out the unreacted codebase
very very messy a lot of code in one
component</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>