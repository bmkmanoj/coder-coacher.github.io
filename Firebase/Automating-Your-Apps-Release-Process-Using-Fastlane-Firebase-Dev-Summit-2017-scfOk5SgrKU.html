<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Automating Your App's Release Process Using Fastlane (Firebase Dev Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="Automating Your App's Release Process Using Fastlane (Firebase Dev Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Firebase/">Firebase</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Automating Your App's Release Process Using Fastlane (Firebase Dev Summit 2017)</b></h2><h5 class="post__date">2017-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/scfOk5SgrKU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you so much for having us here I'm
Felix one of the engineers here at
Google working on Fastlane as part of
the firebase team hey I'm Josh I work on
open source software in firebase
primarily on Fastlane with Felix and
today we're gonna be showing you how you
can build your own app integrations and
make shipping app updates easier and
reproducible so we're gonna Joe just
gonna start with a short introduction on
what fastin is and how you can use it
and then at the half days presentation
we're gonna do a short life demo on how
you can extend Fastlane to fit your
needs
awesome ok so how would you like to have
two extra hours every single week well
our talk is all about saving time and
automating tasks so you can spend time
on the things you care about most so
today I'm going to talk about three key
issues we as mobile developers face and
how we can solve it using Fastlane I
want this talk to be very practice
oriented so that everyone can learn
something today and we can start using
it so I'd be willing to bet that you've
heard some of these quotes Brian is the
only person who knows how to do a
release and he's on vacation so we'll
have to wait or oh man our provisioning
profiles don't contain to the devices we
actually need to be using now so we're
gonna have to add them regenerate to the
profile redistribute it and then refine
the builds or just our build is broken
also sometimes the marketing team really
wants those new screenshots for the app
that you've been working on and that can
be pretty tedious so these are all
things that we've heard in the past and
these are not things that we really want
to hear and so that's where Fastlane
comes into play alright so release day
super exciting day for all of us all of
your hard work finally pays off you want
to get your app into your users hands
but there are so many steps involved
right so first you thoroughly test your
release candidate and then you take all
the screenshots of all the new features
in all the languages and the devices
that you support
but then you go to build it and you run
into signing issues so after you resolve
the signing issues you work on your push
certificate if you use notifications so
finally you upload that new build to
iTunes Connect or whatever beta service
that you're using and you can finally
after that submit it this can easily
take an entire day and that's time we as
developers have to invest I'm sure you'd
prefer to be working on your app so
that's why Fastlane was built it's a
tool that helps you automate all of
these tedious tasks like testing and
building and signing and deploying your
application so Fastlane has a bunch of
tools that you can use but we can also
combine them with various third-party
tools into one workflow and we can
easily automate many parts of our app
deployment process with that as an added
bonus fast lane is open source and
available on github alright so what are
we really talking about now it's
continuous delivery with mobile apps but
what are the goals here well first off
it should be automatic like push a
button and it takes care of everything
for you and secondly we want to store as
much of that information about the build
in version control and I can't stress
this enough we want the build scripts we
want the build info this stuff should be
in get in you know more version control
this way you have a proper history and
by having everything in one place it
means that you can check out the repo
and get started right away also
everybody even new developers on the
first day of the job should be able to
build your app all you have to do is
check out the gate repository and we
really don't want to have internal
things like wikis pointing to various
different documents describing exactly
how we do that so - keeping it and last
when Brian is on vacation we still want
to be able to deploy that app so we
don't have time to cover everything that
fascinating
so I'm going to focus on three common
problems you've probably experienced in
the past and how you can solve them
using Fastlane so first off screenshots
it's a huge pain and then our favorite
topic
I'm sure code signing and provisioning
profiles and then automation of your
deployment process so every time you
publish a new app you have to generate
screenshots and upload those to iTunes
connects and over time your app features
change you have new designs you have new
languages new devices come out it gets
surprisingly difficult to do screenshots
correctly and just to give you an idea
in iOS if you've if you've got five
different screenshots for six devices
and ten languages you can easily end up
with 300 screenshots that you have to
generate locally and the pain doesn't
stop there either you need to upload
that to iTunes Connect and actually
place them in the right place so there's
this one tool that we wrote called
snapshot and we built that to automate
the whole process for you so to use it
you basically just tell snapshot how to
navigate into your app and where you
take screenshots it will then iterate
through all the languages all the
devices and it'll generate those
screenshots for you and finally it'll
collect them into a folder and upload
them straight to iTunes Connect using
another tool called deliver now of
course we have the same tool for Android
and that's called screen grab it works
the same way it just uses espresso tests
and you can upload all the screenshots
through you know straight to google play
using a fascinating tool called supply
okay so that's really cool but how does
this look in action well if you already
have snapshot setup all you have to do
is enter Fastlane snapshot in the
command line and snapshot will
automatically detect your project
settings and start running UI tests you
can already see the simulator jumping up
right here so what's really cool is that
this can run in the background and
concurrently so you can do something
else while your computer is generating
screenshots for you and this is
extremely useful because it collects all
of these screenshots into a folder which
you can then upload to iTunes Connect
and what's really really nice is that
when it's done it gives you this HTML
report where you can see all the
screenshots of all the languages and all
the devices so you get a really great
overview of how your app looks with all
these different combinations and a lot
of companies actually use this to make
sure everything looks great in
particular if you support languages like
German which tend to be kind of long on
the localizations okay now on to our
favorite we're going to talk about some
iOS specific stuff here code signing and
provisioning profiles I don't know if
you remember this dialogue but it
usually signaled the start of an
afternoon of code signing troubles
painful so now you can press the fix
issue button here and sometimes that fix
the issue but it also had a tendency to
break things from time to time so I want
to talk to you about what we can do to
simplify code signing so that you don't
have the sense of dread whenever if
somebody mentions provisioning profiles
or signing certs
ever again all right
so Apple recommends that when you do
code signing each developer and the team
has their own code signing identity
which means that you have one app ID for
every app you have one code signing
identity for every engineer in your team
and then you have one provisioning
profile for each engineer for each app
ID and for each developer it's confusing
additionally for each environment you
have ad-hoc developer app store so that
means if you have a few developers and a
few apps you can easily end up with
hundreds of provisioning profiles and a
developer portal that looks kind of like
that it's a little bit of a mess so when
you have this you have to think about
things like how do we keep the valid
profiles in sync or whenever we add a
new device how do we make sure everybody
gets the right provisioning profiles and
how does onboarding a developer look and
what does her first day of work look
like so this isn't exactly the most
ideal setup and that's why we have a
different approach
what if instead of having hundreds of
profiles and certificates for each
developer we share a code signing
identity across the entire team and we
use that one identity to deploy to the
app store and you can store that
identity and its private key and a git
repository you already use get to sync
your source code so you can use a
separate git repository with your code
signing identity in it and additionally
you can encrypt it or you can just keep
a really secure git repository and with
this that's enough to be able to onboard
any new developer its price we've got a
tool called match that implements this
workflow here's what it looks like first
thing you just run match in it it's
going to ask you for a URL to this git
repository that you want to use and
what's really great about git repos is
that you've got some basic access
control here so you can decide which
users have read access and which users
have write access all right so the first
time you run it you just run match app
store this will generate a new app store
provisioning profile and certificate and
that was it that's that's the whole
thing it just run you just have to run
this every time you want to run a build
on a different machine and what's really
great about this is that you don't need
to access you don't need to grant access
to the developer portal for all of your
developers you just have to grant access
to the git repository and that's it it's
nice and simple all right so we've
covered snapshots and we've covered code
signing but let's talk about why you'd
even want to automate deployment so
think about the following situation your
boss or your project manager asks you
for a new build for your clients or for
your design or maybe so you can send
that build over so they can check out
those latest changes okay so that
process looks like this you go ahead and
you bump the version and then you go and
commit that version back and push it up
to your repository you add the new
devices to the provisioning profile you
then build export and upload
you know goes to either iTunes Connect
or the whatever beta service you're
using and then you add release notes and
finally you can distribute that it's a
ton of work it's but that's where
Fastlane comes into play we can reduce
all of this down to just the push of a
button so first off Fastlane uses a so
called fast file and this file contains
all the information that is needed to
deploy your app you just define which
steps run and in what order and Fastlane
make sure to execute them a group of
steps is called a lane and if one of
these steps fails the whole lane will
fail it'll just stop running and so how
does this configuration look for the
example we were just talking about here
okay well first you define the lane and
this one is beta and then you can see
the next step is to increment the
version number and then we commit that
and push it to our get repository and
then we use match to ensure that we have
the latest provisioning profiles and
signing certs
directly from that git repository and
then we use gem to build and sign so
finally we're able to upload that IPA to
whatever beta distribution distribution
service we use like fabrics beta or
hockey app and after that we can post a
message directly to slack so speaking of
slack we've got many built in
integrations and I think at this point
it's somewhere around 400 it's kind of
changing but these are things like
HipChat
and slack crashlytics hockey email
actions get actions and so on if
integration isn't available yet you can
easily extend Fastlane to use your
existing shell scripts Ruby scripts or
you can build your own integration or
even build a plugin that can be shared
by many others which is what Felix is
going to be demoing for you shortly
all right so how does this look in
action well that's easy enough you just
call Fastlane beta okay so another
example here here we're going to build a
new release and we're gonna send it to
the app store
we run Fastlane iOS release this would
be the first the first build sorry here
we're actually first signing the build
and as you can see Fastlane prints out
every single command that it's doing we
tried to be fully transparent about what
we're what we're doing here and once
it's done it's going to upload the new
build to iTunes Connect and for
uploading Fastlane actually uses a tool
that's built into Xcode called iTunes
transporter it's done so if you look at
this output you can see we get this nice
little summary table actually kind of
huge here but this includes all the
parameters that are being used at this
point and it's really really useful
because you can go back into your CI
system and see what was being used at
any given time and above that you can
see the commands that were run and what
that means is that if you have any
problems and you need to debug this
stuff you can usually go back in copy
and paste and execute them see what
happens alright so that was just a small
example of a really useful workflow
fastly can help with uploading app
metadata and builds to iTunes Connect
managing your push notification profiles
automating app creation in iTunes
Connect and the dev portal testing and
syncing your profiles across your team
using git and much much more
many of the tools in Fastlane
communicate with Apple in some way so
how does this work well there's no
official API right of course not there
is an open-source tool called spaceship
which is part of Fastlane it takes care
of communicating with Apple and all of
our tools are built on top of it so you
know it's battle-hardened and you can
use it to build your own workflows for
example like syncing new LDAP users with
the developer portal anytime your
company adds a new engineer so one thing
we built that can show you how useful it
is to have an API framework is this
project we call boarding so boarding is
this really cool Ruby on Rails project
that gives you a landing page for users
that one
beta test your app using test flight and
I think that's really cool because you
don't have to go into iTunes Connect
manually and add people anymore
originally this project boarding was
just built to demonstrate what you can
do with spaceship and it only took a
weekend to build to build now lots of
people use it and it's maintained by the
community so feel free to use it with
your own apps you can deploy it on Linux
just also pretty awesome it's open
source and you can also find that on
github ok so I want to jump back into
Fastlane some of us using third-party
crash reporters like crashlytics have
probably run into this problem if we
enable bit code you build your app and
then you upload it to iTunes Connect it
gets approved and released at some point
it crashes so you open up your your
crash reporters dashboard and you note
that nothing shows up you don't see a
stack trace ah right and that's because
your app supports bit code just as
suggested by Apple good job
that means they can recompile your app
on the fly and generate new D Sims which
is exactly what happened here so apple
recompiled your app and the crash
reporting tool doesn't have those new d
sims so you've got a login to iTunes
Connect find the builds then download
the D sims then log into your crash
reporter find where to upload those d
sims that's kind of a pain well surprise
we have fast lane here and it can get
your back you can take care of that for
you here Fastlane will download your d
sims from apple and then i'll upload
those d sims to crash Linux or whatever
tool you want to use and then it'll
clean up after itself and that's it
that's all of the code and you can find
more information and the Fastlane Doc's
about this that Doc's taught Fastlane
tools and so these are some of the
things that you can do with Fastlane out
of the box but let's say you want to
build your own integrations with your
own api's that's where fast site and
plugins come in handy and for that I'll
hand you off to Felix
alright thanks Josh
this was a really great introduction of
how you can use fast lane to optimize
your app deployment process and best of
all as charged already mentioned all of
this is open source available on github
as you may have noticed much of Fastlane
is highly optimized for iOS developers
but as Josh mentioned it supports both
platforms iOS and Android so alright
let's say you set up Fastlane
successfully and you use it to build and
deploy your application but then you
decide you want to do something more
let's say you want to run a code side
linty let's say you run around Swift
things this is where the the fasting
docs page comes in handy we have a list
of all the building actions over there
that you can easily use using fast name
currently we have about 400 actions
available but what if you want fasting
to do this one specific thing for your
setup this one thing that is missing
this is where the fasting community
comes into play because more than half
of the actions that are available are
actually provided by the fasting
community in the form of fasting plugins
so just like Lifta actions we can find a
list of all the available plugins on the
docs page and we make it very easy to
find the plugins that are most useful
for you so we introduced the fast lane
plugin scoring system that shows you the
popularity of a plugin based on certain
metrics like the number of downloads the
number of active users the number of
contributors and the number of merge
pull requests and for the distribution
for those plugins we make use of ruby
gems so this is kind of like cocoa pods
but for ruby projects at the same time
as ruby gems we also make use of bundler
which allows us to define dependencies
in a configuration file and therefore
make the build reproducible and we're
gonna see a lot more a lot more of that
in our demo because every time you want
to use bundler and ruby gems you need to
prefix a command bundle exec so all
right we want to see all of this in
action we have a sample iOS app that has
multiple schemes to choose from but we
don't want to specify this scheme every
time man
we want to define what scheme to use as
part of a JSON configuration file so we
don't have to update our fasting
configuration every single time we want
to use the scheme so this sounds like a
great candidate for our first fasting
plugin so we're gonna build one on stage
right now
all right beautiful so we are in this
demo directory and inside this demo
directory we have our application called
my app and we often open this up in our
text editor we can see that we have a
working Fastlane setup so inside our
fasting directory we have our fast file
and this is a very simple fast file all
it does it builds our application using
chim and then it's - distributes the
beta built on crashlytics so if we run
this now in our terminal we have to run
bundle exec Fastlane and then the name
of the lane which in this case is built
so by running this it will detect our
Xcode project and as mentioned before we
have multiple schemes and of course
Fastlane asks us what scheme we want to
run it for so I'm gonna cancel this for
now because as mentioned we want to have
a JSON configuration file so how can we
start a new plugin well let's go back to
the root of the demo folder and I can
show you that the get status is clean we
have no changes here for now and to
generate this plugin now we're gonna run
bundle exec Fastlane new plugin and fast
it makes it very easy for us to build
new plugins so it will ask for the name
of our plugin which we're gonna call
parse underline JSON it's gonna ask us
for a description of what this plug-in
does parse a JSON file and it asked us
for more information we're gonna provide
that later on alright what actually
happens here let's run get status again
we'll see that we have a new directory
which is our plugin so let's see what's
inside this directory alright you can
see that we have a directory is already
full of files it might be a little small
to read but should be fine one thing
that that stands out is that we already
have a fast file but this is not the
fast fell of our Xcode project it's the
fast file of our plugin and it already
calls past JSON we could just created it
so it seems like something already
happened there and since it is a fast
file we can try it just running it so we
are inside our plugin and we're gonna
run bundle exec
Fastlane and then again the name of the
lane in this case it is test alright
a lot of green text that's usually a
good sign um so we see the short summary
of what plugins were successfully loaded
so that is good and then we see the
chase on the parse JSON plugin is
working all right interesting so
something's already happening here and
so that when we generated a plug-in it
also generated a default implementation
so if we go inside the actual source
code of the plug-in we will see that we
have the action implementation here and
there's a lot of methods you can
implement many of them are more advanced
so we're not going to talk too much
about them for example one method
describes what platforms use your word
if it's iOS or Android or both in this
case passing a chase on works on any
platform available options we're going
to talk about in a bit details we don't
provide for now the return value of this
plugin is the contents of the JSON file
and then as an offer name you can choose
to use your github or Twitter username
and here we see the actual message we
saw before the footpaths JSON plugin is
working all right so we need to parse
the JSON file and it is very easy to do
that in Ruby all we have to do is return
JSON dot parse and then pass the file
contents to get the file contents we
just call file that reads and we access
the file path and for the path we're
just going to assume a dummy JSON file
for now and see if it actually works so
we're going to create a dummy JSON file
inside our plug-in directory and within
that we want to define the scheme to say
demo G custom scheme this is just the
dummy's skin to see if it's actually
working all right so we load we define
that the path below the content we parse
the JSON file let's actually give this a
try so I'm going to run the same command
again fastlane test and we see there is
some output is missing there's nothing
in between here anymore
so and the reason for that is that if we
look
the example fast file we call our plugin
but we don't use the return value so
we're gonna say file contents equals
path JSON and then you print out
something you just have to do you added
message file contents let's run it again
and see what happens
all right scheme the emoji custom scheme
to default so we are only interested in
the scheme so to access it we're gonna
use the square bracket notation so we're
gonna say selected scheme equals file
contents and then say scheme and as a
message we're gonna say we're gonna use
the scheme scheme select the scheme
alright let's see if that works as
expected
we're gonna use the scheme demo to
custom scheme alright so this is all we
can create we can parse the JSON file we
get the scheme one thing we haven't done
yet is we don't allow the user of this
plugin to choose what JSON file to load
so if we look back we are assuming
Demeter JSON and fast then makes it very
easy to set those values so in the
available app options methods you can
just return an array of options you
allow to take and you define the
metadata of what kind of value should
take so in this case we're going to call
it path this is an environment variable
we can set so let's call it parse JSON
path and the description is just like
path through that JSON file and to
access it all we have to do is say
params square bracket path and if we go
back to a fast file we can now pass the
path here and then say dummy dot JSON
and this is really important because we
don't want people to have to modify the
plug-in but we want people to be able to
pass values that is working for that set
up so let's run it again and see if it
works all right it's the same output
we're gonna use the scheme demo G custom
scheme beautiful so we have this in our
example fast file how can we add the
plug-in to our application so for that
we're gonna go back to our application
my app and inside my app we can make
use of a command that is bundle exec
Fastlane and underline plugin and it's
gonna ask us what kind of plugin we
wanna install so we're gonna say it's
called parse underline JSON and what
thing what thing fast and just found out
is that the plug-in is not available on
rubygems which as I mentioned before is
the system we use to distribute plugins
and obviously it's not available yet
because it's only on my local machine we
just started building it so we're gonna
use the local path option number two and
it's asking us for the relative path so
we're gonna say dot dot dot dot and then
the name fast lane plug in parse JSON so
it asks us we can modify our gem file
and our plug-in file again this is all
bundler doing all the magic for us it's
just again fast and tries to be as
transparent as possible and let's look
at what actually changed so looking at
the git diff we're gonna see that it now
attached a new file that is the
so-called plugin file again we don't
have to understand how this works
Fastlane does that for us but it is
important that you check that into your
version control and so we successfully
installed the plugin now but we don't
use it yet so if you open up the fast
file of our application again we can see
that we have our trim call here and our
critics call here and let's comment
these two out for now and focus on
selecting a scheme again so we're going
to copy the code we wrote on our example
fast file inside it here and let's see
if it works again so we're gonna use the
same configuration they're gonna run
fast lane and then built ah this doesn't
look too nice big stack trace alright
let's scroll up and see what happens
here no such file or directory Demeter
chaser alright that looks valid because
the Demeter JSON is in the directory of
the plug-in not of our application
either way first before we actually fix
the path we want to fix this error
message we want our plug-in to be more
user friendly and that is really easy in
Fastlane also so as part of the config
items what you can do is you can pass a
very
five block and the verified block allows
you to define a rule on how to verify
that the value is valid so what we can
do is we can say we can throw an
exception using that you added user
error and say couldn't find given file
unless of course the file exists using
value all right
so let's run this again see how it looks
like couldn't find given file all right
this is a lot nicer beautiful so now
we're actually gonna fix the path in our
fast lane first I'll so to fix it we're
gonna go one fold up and say Fastlane
plug-in parse underline JSON
the great thing of course here is that
the JSON file can now be named anything
and can come from anywhere alright so we
were able to successfully load the
scheme so let's connect it connect the
things together we're gonna comment out
German critics again we're gonna pass
the scheme parameter and select our
scheme and in the dummy touches on we
actually want to use the actual scheme
and in this case for this app it's
called demo G so we're doing everything
now load the file select the scheme
print out the scheme build our
application and upload to critics let's
see what happens same command again
loaded our plugin it's it printed out
that it's gonna use the scheme de mogi
and these are all this nice little
summaries Josh was talking about so it
will show that it is using the scheme
demo G and then it started building our
application so this is a basic Swift
application so this is going to include
the Swift standard library and it will
also cause an application building was
successful we are now uploading to
Krishna Dix to critics beta and there we
go
fasting tools finished successfully
beautiful so this all seems like it
worked really well and one last thing we
want to do now is we want to publish the
plug-in to rubygems
so this looks like it's it's it's
working well so we're going to go back
to our plugin and one thing obviously
you would do is you would publish your
source code on github in this case where
we
not gonna do that and only focus on the
rubygems part and if we go back to our
source code one thing that you need to
change is you have to provide a home
page very often that's just the github
page so we're gonna add my username here
and to now be able to to publish the
plug-in I recommend running bundle
update to make sure you have all the
latest dependencies installed and after
doing that you can run rake builds which
will package up you your plugin into a
zip file and then you publish this you
can run gem push and then pass the path
here and it's pushing the ruby gems
successfully registered gem zero one
zero and we can now go to the ruby gems
website and search for Fastlane plug-in
we will see that we have a lot of
plugins here so currently it's two
hundred and forty plugins and depending
on how fast their cache is we can
actually find our plugin here first then
plugging in parse JSON released today
all right we just successfully published
a plug-in here on stage
so to recap we just saw how we can use
Fastlane in action how we can change the
configuration and change Fastlane to fit
our needs and then at the same time we
were able to prepare it as a package and
provide it to other fast end users in
form of the plugin and now back to Josh
awesome Felix so this was a short
introduction of what you can do with
Fastlane and how it helps save a lot of
time during development and deployment
you can find more information on how to
get started with Fastlane at Doc's dot
dot tools you can also find us in the
ask firebase lounge right after this
talk thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>