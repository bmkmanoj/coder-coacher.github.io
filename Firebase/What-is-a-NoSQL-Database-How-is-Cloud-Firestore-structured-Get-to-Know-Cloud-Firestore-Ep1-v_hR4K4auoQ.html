<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What is a NoSQL Database? How is Cloud Firestore structured? - Get to Know Cloud Firestore Ep.1 | Coder Coacher - Coaching Coders</title><meta content="What is a NoSQL Database? How is Cloud Firestore structured? - Get to Know Cloud Firestore Ep.1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Firebase/">Firebase</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What is a NoSQL Database? How is Cloud Firestore structured? - Get to Know Cloud Firestore Ep.1</b></h2><h5 class="post__date">2018-03-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v_hR4K4auoQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what is cloud firestore why it is a
horizontally scaling no sequel document
database in the cloud No
I guess we're done here well that was
easy hey what's that
oh we're not we're not we need more
explanation all right fine I guess can
stay a little while longer let's roll
the credits
so let's talk about cloud fire store
cloud fire store is what's known as a no
sequel database now if you're coming
here from the real time database or
Mongo world and already know all about
no sequel databases hey lucky you you
can go ahead and skip forward like eight
minutes into this video because this
next part will probably be review for
you but for the rest of you if you're
used to traditional relational databases
things like my sequel or mobile
frameworks like sequel Lite or core data
you're probably used to keeping all your
data in tables that look a little
something like this
every table has its own schema which
means that every row in that table is
very strictly defined you have a
specific set of columns that you can add
per row and every column has its own
very strict rules about what kind of
data type goes in there oh sorry buddy
your age has to be an integer those are
the rules I didn't make them up because
of this very strict schema usually end
up storing one type of object per table
in your database and if you want to
associate one object with another object
hanging out in another table you're
usually doing that by creating another
column known as a foreign key that
contains the unique ID of that other
entry in that other table for example
let's say I'm creating a database for a
restaurant review site
I might have one table to represent my
restaurants and another table to
represent my reviews and maybe another
for my users now let's see I want to
look up reviews for a particular
restaurant which kind of seems like the
thing I'd want to do in a restaurant
review app I would want a restaurant
foreign key in my reviews table that
shows me which restaurant this
particular review is for and if we
assume I want to show within my review
some info about the author who reviewed
that restaurant I might include another
foreign key for the user so later when I
need to show my restaurant info screen I
would grab some info about the
restaurant from the restaurant table and
then also grab some of the reviews from
my review table where the restaurant
foreign key equals the ID of this
particular restaurant and then I would
also look up the users where the user ID
equals the user foreign key for this
review and then I could use that to add
like user names and profile pictures for
each review for this restaurant now this
is a fair amount of work being done on
the back end right like grabbing all
these entries from all these different
tables and joining them together based
on these foreign keys and all that but
this can be done with a fairly
straightforward select statement in
sequel the database does the work in
grabbing all these pieces from the
different tables and joining
together not you and that is relational
databases in a somewhat overly
simplified nutshell now in the no sequel
world things are a little different
generally speaking all your data is not
going to be stored in neat little tables
like this in fact there's a number of
different ways you can store your data
from like a plain old key value store to
a big nested tree like the real time
database to a collection of JSON objects
but one thing that most of them have in
common is that no sequel databases are
usually schema-less which means there
aren't any database level restrictions
around what kind of data you can put at
any point of the database so I might
have my list of restaurants here with a
bunch of restaurant objects all
containing like a name and a rating and
an address
but that's basically by convention there
are no explicit database level rules
that say all these objects have to all
have the exact same fields within the
exact same types of data or even that
these need to be objects that represent
restaurants so this loosey-goosey
approach might seem a little weird at
first but it does have some advantages a
lot of developers like working with a
schema list database because it means
they can really easily iterate on their
database design by adding or changing
fields as needed and it won't
necessarily break anything else like I
could start adding a noise level value
for my restaurants and only start adding
it for new restaurants I wouldn't have
to worry about having to backfill it for
all my existing restaurants my no sequel
database can handle that without
freaking out it can also come in handy
in other situations too or I might want
to store data that's similar to each
other but not exactly the same for
example I could easily expand my
restaurant app to include like bars and
tattoo parlors and skydiving lessons for
what sounds like a pretty awesome night
out and my database doesn't care that
one object has like a tandem jumps field
and another has a tattoo style field
right I don't have to fight with my
database to add these slightly different
types of establishments the drawback
here is that you do need to code a
little defensively while you can set up
security rules to help enforce what kind
of data you put where there's not really
any guaranteed at the database level
that you're going to retrieve a certain
set of data at any time and that means
you're probably going to want to do some
checking on the client side to make sure
the data you're getting is really what
you're expecting and fail nicely when it
isn't
but honestly coding defensively is
probably a good idea anyway particularly
in the mobile world you can't always
guarantee you that your users will be
running the latest version of your
client
up against the latest iteration of your
database so I'm kind of hoping this is a
habit many of you are used to already
and if not this is a great time to get
started the other important aspect of no
sequel databases is that and I'm sure
this is going to shock you there's no
sequel meaning that all those fancy
joins where I was able to say hey go
grab the review from this part of the
database and the user from this other
part and merge them all together I can't
do that here in general if I need to
grab objects from three different parts
of the database I would need to make
three entirely different database
requests and that's usually not going to
happen or I guess that's not going to be
your default way of thinking instead
you're going to want to put your data in
places where you can grab it all
together if you need to and that does
mean you might be putting duplicate data
in multiple places for example let's
take a look at what a no sequel version
of our restaurant review app might look
like you probably expect to see
restaurants listed as their own
individual objects in our database but
now depending on your database reviews
can be embedded within the restaurant
itself but I think they'd most likely be
their own objects and then you'd find
some way to indicate that these go
together the reviews themselves might
include the ID of the restaurant for
example now with this setup I can fairly
easily fetch an individual restaurant or
a group of restaurants and through some
careful querying I could fetch all
reviews for an individual restaurant but
I typically can't do both of these
requests in one single call but for a
restaurant review app this is probably
fine right like users first gonna want
to view a summary of like 20 or 30
restaurants and then drill down into one
of these to see more details and it's
really only at this point that I'd want
to request these extra reviews so so far
not too bad but what if we want to show
the reviewers name and profile picture
in those reviews this is where it gets a
little tricky let's assume our users are
represented by their own objects
elsewhere within the database and while
I could add references to these users
from within my review objects there's
still no way for the database to
automatically grab like that user's name
and profile for each review as I'm
requesting them I would need to make a
separate database request for every
single review I get to fetch this
information and that's bad so if we want
to automatically include some
information about who wrote a particular
review we would most likely need to copy
some of that user profile data the
author's name and picture for instance
and place it into our review object now
if you're coming from a traditional
relational database world you're
probably
freaking out right now right you're like
oh what are you doing you're gonna have
like duplicate data all over your
database and that's like the worst thing
ever to happen in programming since go
to statements and you know you're kind
of right people have spent their time
with relational databases have been
taught that data normalization meaning
that every piece of data should only
exist in one place in your database is
super important and they kind of got a
point like in a situation like this it
would be a lot more work if my user
decided to change their profile picture
I need to look up every review or I've
copied over this profile picture
information and replace it with the new
one and there's always a risk that I
don't change it everywhere and suddenly
I've got inconsistent data in my
database and so now maybe you're
thinking well this just seems terrible
why is it that no sequel databases are
so hot right now why are there so many
developers moving away from this nice
world of like clean tables and data
normalization and joint statements for
this crazy new messy world of data
storage so yes one of the big drawbacks
of having this duplicate data is that
when I change it I have to change it in
multiple locations but on the other hand
anytime I want to grab a review it's
really freakin easy like all the data is
right there for me all in one place no
need to run joins across multiple tables
or anything like that and while that
means our rights are going to be more
work our database reads end up being
really fast and for many apps if you
really think about it your reads are
gonna outnumber your rights by like a
lot I mean how many times am I gonna
change my profile picture like once a
year at most but on the other hand maybe
a couple dozen people are gonna see my
restaurant review every day so when it
comes to this data here our reads might
outnumber our rights by like seven
thousand to one and so maybe it makes
sense to optimize the case that's gonna
happen seven thousand times over that
case that's going to happen once a year
but I think the biggest advantage with a
no sequel database over traditional
databases is that it's able to
distribute its data across multiple
machines pretty easily and this is a big
deal with most relational databases if
my app gets super popular and I need my
database to scale up to larger and
larger data set I generally need to put
it on bigger and beefier machines and
this is known as scaling vertically on
the other hand with many no sequel
databases like cloud firestore if I need
to scale up to a larger and larger data
set my database can behind the scenes
and pretty much invisibly to me
distribute that data across
several servers and everything just kind
of works and this is known as scaling
horizontally and for those of you who
are working in managed server
environments like the Google cloud
platform or AWS it's pretty easy for
these systems to automatically add or
remove servers to your database as
needed with very little to no downtime
so your database can scale pretty much
automatically without your ever needing
to lift a finger and it's really for
these reasons that you're starting to
see a lot more databases particularly
once hosted in the cloud moving to this
no sequel model but now if you're coming
from a no sequel background like the
firebase real time database not much of
this is new well maybe except for the
automatically scaling part cloud
firestore does handle that a whole lot
better than real time database but it's
more than just that so let's talk more
specifically about Codd fire stores
document collection model in the real
time database world we typically
describe the data that's stored in
firebase as a big JSON tree because well
that's basically what it is right it's a
tree it's got keys and values and those
values can sometimes be objects to
contain other keys and values now cloud
firestore like the real time database is
a collection of objects and all these
objects are stored in a tree like
hierarchical structure and while
databases like the firebase real time
database store everything as a big old
JSON object Claude firestore is a little
more organized and that it's made up of
documents and collections now documents
are similar to JSON objects or
dictionaries they consist of key value
pairs which are referred to as fields in
cloud fire store land and the values of
these fields can be any number of things
from strings to numbers to binary data
to smaller JSON II looking objects which
the team likes to refer to as maps among
other things and that's a document now
collections are basically well
collections of documents you can think
of them like a hash or a dictionary
where the values are always going to be
some kind of document now there are a
few rules when it comes to using these
things the first is that collections can
only contain documents nothing else no
collections of strings or binary blobs
or anything else here
second documents can only be one Megan
sighs any larger than that and you'll
need to break it up
third a document cannot contain another
document documents can point to sub
collections but not other documents
directly so it's very common to see a
collection containing a bunch of
documents which then point to sub
collections that contain other documents
and so on and so forth the fourth rule
is that the very root of a Cloud
firestore tree can only contain
collections now in most real
applications this will seem very
intuitive you'll have
users collection and a tasks collection
and so on I do find the one time this
ends up being confusing is when you're
building your first little tiny test app
where you're storing like two pieces of
data like it's a little weird to store
hello world inside a document that's
then inside a collection but you know in
most real-world use cases this will be
fine trust me so this means that as a
general rule you're going to be drilling
down into your data by specifying a
collection and then a document and then
a collection and then a document and
alternating like that until you get to
the document containing the data you
actually want
since this code can get kind of messy
and awkward you'll often be specifying
the document or collection you want by
creating a path to that document kind of
like this just remember that in your
path you're still going to be
alternating between collection document
collection document and so on so let's
go back to thinking about our restaurant
review app seems like a no-brainer that
we're gonna have a collection called
restaurants and each one of these
documents will contain some information
about the restaurant as well as probably
a pointer to a review sub collection now
within this review sub collection you're
gonna have a bunch of documents and each
document will represent one individual
review and so within these documents
you're going to have a pretty large text
block containing the review itself and
then probably a few other details like
the overall rating and the date and so
on and you know already I'm kind of
digging this hierarchical structure
because it turns out to be pre trivial
to grab all the reviews related to a
restaurant here but then we're also
going to want information about who
wrote this review now I'm pretty sure
our app will have some kind of users
collection but that'll probably be more
of like a top-level collection that
would contain all sorts of information
about that user like their name their
user profile last login time default
location food allergies what-have-you
and this really does feel like a
top-level object not something I'd want
to make as like a sub collection of a
review and so I talked about this
earlier but this probably means that if
we want to include information about the
user who wrote this review our review
documents will probably contain a couple
of fields like author name and author
profile picture since that's probably
the only user information I'm gonna need
when I'm looking at a review and if I
wanted I could also make this a map
field those are the little JSON e
looking things kind of like so and so
this would probably be duplicate data
that would live both in the top-level
user object and in this individual
review and we'll talk in future videos
about the best strategies to keep these
kinds of things consistent incidentally
if you're come
from the firebase real-time database
land this kind of deep nested structure
might be giving you heart palpitations
because in the real-time database world
when you retrieve some element in the
tree you automatically retrieve
everything below it and that would mean
downloading potentially hundreds of
restaurant reviews anytime I want to
grab like a couple dozen restaurant
documents but in cloud firestore world
queries are shallow by default which
means when you grab documents within a
collection you only grab those documents
you don't grab documents and any sub
collections so I can go ahead and grab
my 20 top rated burrito restaurants and
just get those restaurant documents
without all the reviews associated with
them which you know kind of makes sense
right I mean if I'm doing a search in my
mobile app for best burrito places that
results page is just gonna contain that
basic restaurant info I don't need the
individual reviews at this point later
if I were to click on one of those
burrito places to get more info that's
when I want to see the individual
reviews and that's probably the point
where it makes sense for my app to
request them from the database make
sense all right so I know that was a lot
to go over but let's summarize cloud
firestore is a no sequel horizontally
scaling document model database in the
cloud see just why I said in the
beginning all kind of makes sense now
right now there's plenty more to talk
about here like how you can run queries
in cloud firestore tips for optimizing
your data and how to keep it all secure
all of which are great topics for future
videos and hey lucky you we're making a
whole series all about cloud firestore
so if you want to keep watching and you
want to keep learning about cloud
firestore why you go ahead and subscribe
to our youtube channel and then I can
see you soon in a future episode all
right thanks for watching YouTube land
I'll talk to you soon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>