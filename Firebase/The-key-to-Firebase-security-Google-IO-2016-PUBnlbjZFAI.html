<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The key to Firebase security - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="The key to Firebase security - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Firebase/">Firebase</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The key to Firebase security - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PUBnlbjZFAI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am a huge soccer fan have been for my
entire life I have fond memories of
playing the game while growing up
excluding the one or two times I got
kicked in the face with the ball
directly off the kickoff but even to
this day I still get a rush of
adrenaline
every time the whistle blows whether
it's a game I'm playing in or not over
the years you could say I've learned the
primitives of the game passing shooting
dribbling defending doing skill moves
each concept is not very useful on its
own but piece them together and you've
got a player's skill set in a similar
way security for your firebase app is
composed of a bunch of different
primitives or course concepts that
individually don't do much but when you
compose them together you can form very
powerful rules and protect your data
even for complex applications and today
I'm going to be your coach so to speak
and I'll train you on these concepts and
if you haven't already guessed it I'll
be using the help of the sport that I
love my name is Jacob Wenger and I've
been on the firebase team for over two
years now back since startup days so you
could say I've become a bit of an expert
on the real-time database I'm hoping to
share that knowledge with you today and
I know it's early and I know I'm talking
about security a traditionally boring
subject so I thought I'd spice it up a
little bit and instead of just talking
about the key to firebase security we'll
talk about the key to firebase security
as told with emojis so you'll be seeing
a lot of that over the next half hour
yesterday you heard all about the next
generation of firebase and how firebase
is now a lot more than just a real-time
database it is a suite of integrated
products to help you develop your app
grow your user base and earn money today
I'm going to bridge the gap a little bit
between the old and the new world and
talk to you about security in your
firebase apps across to different
products the first is the firebase
real-time database this is the old
reliable battle-tested real-time
database that excels at syncing
arbitrary JSON data such as a team
schedule or the league standings the
second product is the brand shiny new
firebase storage
you'll use this store to store files
like video highlights from last night's
match or an audio clip of an announcer a
Spanish announcer screaming go I do not
know how they hold that for so long I
definitely could not do it thank you
thank you uh in order to in order to
explain firebase security I first need
to tell you about what exactly do I mean
by security the way I actually see it is
that there are two sides of the security
coin on the one side you have
authentication and on the other side you
have authorization what exactly do these
terms mean authentication is the process
of verifying users are who they actually
say they are so this user is Sarah and
this user is Billy authorization on the
other hand is the process of determining
who has access to what data so maybe
Sarah has a ticket to the match and it's
going to be able to get in
whereas Billy is empty-handed is going
to be stuck watching the game from the
pub traditionally implementing both
sides of the authentication both sides
of security took a lot of work you had
to manage your own servers you had to
set up your own databases and you had to
write a bunch of custom server-side code
to actually protect your users
thankfully firebase makes this really
simple because we have products that do
this out of the box on the
authentication side we have a product
called firebase authentication very
original I know but firebase
authentication allows you to verify your
users in a bunch of different ways we
have anonymous verification which allows
you to assign a random UID a user unique
identifier to every user we have email
password authentication which allows you
to verify a user using a combination of
email and password then there's ooofff
authentication which uses a third-party
provider like Facebook or Google to
verify users on your behalf saving you a
ton of time and a ton of anguish finally
there's custom authentication when you
need something a little extra or custom
and/or you need to integrate with an
existing off solution I won't be
focusing very much on firebase
authentication during this talk today
but if you're interested in it
tomorrow at 1:00 p.m. on this stage
there's a talk called best practices for
a great sign-in experience and so if you
want to learn more about the firebase
off product definitely go and check that
out what I will be focusing on today
though is authorization and the way we
do authorization in firebase is we use
what we call firebase rules for both the
real-time database and for firebase
storage I think the best way to learn
this stuff is to actually go through a
ton of different examples and we're
going to start with learning the
primitives of the firebase real time
database rules language before we can
actually protect data we need to know
what data we're going to protect so
kicking things off we'll start with some
example data for a real time database
the real time database stores JSON data
so here we have an empty JSON object so
far we can go ahead and say let's put a
top-level game's node and this is where
we're going to store all of the game
information including the schedule for
the current team within the game's node
we're going to have a bunch of random
IDs which we call push IDs in the
firebase real time database and these
are going to uniquely identify every
game in our list so within each game
we'll have a bunch of different content
about that game we'll have the date of
the game who the opponent is and whether
or not the game is open to the public
they'll also be a game content node and
this is the data that we actually want
to protect to ticketed customers only
so people who actually have bought
ticket to the game should be able to see
stuff in game content lastly we'll have
a tickets node and this is just going to
be a list of users who have tickets to
the current game so the best place to
start with security is with what the
defaults are traditionally our default
rules looked a little bit like this
just like the data you store in your
real time database your rules are also a
JSON object it always has a top-level
rules node and then within that by
default we have read true write true so
this is the first primitive that we're
going to learn is dot read and dot write
dot read determines who has read access
and dot write determines who has write
access so as I'm sure you can tell from
this this means everyone and anyone has
access
to all of your data both to read it and
to write it this is pretty great for
getting started because you can go ahead
and create a new fire based database and
then start writing and reading from it
right away but it also allows people
like this guy a malicious attacker to
steal all of your data how would they do
that they can easily circumvent them by
writing just a few lines of code so this
is using the brand new firebase 3.0 SDK
and what we're going to do we used for
those who are familiar with the real
time database you used to do new
firebase and pass your database URL now
you're going to go ahead and call
firebase initialize app you pass your
API key an off domain to do
authentication and the database URL
which is where you're going to store
your data once you have an instance of
an app you can get a database instance
and then called RF on that and that's
actually going to give you a reference a
pointer to your data stored in your
firebase real time database we won't
actually pull any data down yet but we
can go ahead and do that by doing a once
value this essentially is going to do a
get on our data this will return a
promise fulfilled with the snapshot of
that data this is an immutable snapshot
and we can extract the data from that by
calling dot Val on the snapshot and now
I have taken all of your data so this is
definitely not great so as of yesterday
we've actually updated what our default
rules are when you create a new firebase
real time database so we still have the
rules node and instead of read to write
true we're going to see off does not
equal null for both of those so this is
the next concept this off variable this
is a top-level variable populated by the
rules language itself and it represents
the authentication state of the client
making the request so if I'm making a
request from a laptop that is not
authenticated with firebase this off
variable will be null and I will not be
able to read or write any data if I'm
making it from a phone that is not
dedicated with Facebook the off variable
will not be null and it'll actually
contain a UID which is a unique
identifier for that user
every time that specific user signs in
in via Facebook they will be given the
same UID and if I'm authenticated I'll
go ahead and be able to
read so this is better because by
default no authentication providers are
enabled for your firebase database when
you create it so by default no one can
read or write data and you actually need
to add add authentication so let's say
you want to add anonymous authentication
which is a common use case for many apps
and now a guy who can see these rules
says hey you know I can I can work with
this because there's still a bit to open
let's look at our look at some code
again we'll initialize the app in the
same exact way and now we'll just call
off duck sign and anonymously so now we
will be authenticated and any requests
we make from this client will have a non
null off variable in the rules so we go
ahead and after that promise is
fulfilled we will get a reference to our
root of our database we will this time
remove all the data and then we'll log
that the data was removed so this is
kind of terrifying and not what we want
by the time we release our application
to production so I know exactly what
you're thinking you're saying this is
really easy Jacob like all you need to
do is lock this thing down and so we can
go and do that we can say let's go ahead
and just say no one can read and no one
can write anything at all 100 points my
app is entirely secure no one is going
to be touching any of my data and this
is this is very true but it also kind of
renders your app pointless
kind of like the face massage emoji
which I legitimately have never had a
reason to use before I guess until today
before I move on beyond this obviously
pointless rule set I want to introduce
an important concept and that is that in
the rules language doing read and write
false is equivalent to not putting those
rules at all and the default value is
actually false so this is kind of a
contrived example but these two rule
sets are actually the same and this will
come into play in some of our later
examples so we don't want to just not
allow anyone to read or write so let's
say will grant public access to all of
the games note how can we actually do
that we'll go ahead and create a games
note within our rules
and then we'll just say re true so now
everyone can read all of the different
games and see the entire schedule this
is not exactly what we want because we
know that some games we want to have
only ticketed customers or only people
who are authenticated and in other games
we allow them to be public so we can go
ahead and make a semi-public schedule by
instead of just doing read true actually
specifying the game ID for every single
game and for the top game we know the is
public flag is set to true so we'll just
put read true and for the other game we
know that it's not public so we need to
be authenticated so this has this works
although it has a couple issues the
first is that this read true rule is
hard-coded and the only reason we put it
read true is because we know the data we
started with is public field was
actually set to true but what we want to
look at is we actually want to look at
that is public field itself and use that
existing data to determine our rule
thankfully we can go ahead and do this
by changing both of these rules to the
same rule and the rules going to say am
i authenticated or is the is public
field set to true so we start with our
auth does not equal null and then we say
we use this data variable and this is
another top-level variable like off
which represents the existing data in
your firebase real time database so we
say at the current location which is
games / that long UID is the is public
child set and is its value true if so
allow the people allow anyone to read
this note so this is getting us closer
but we still have another problem these
game IDs are randomly generated push IDs
and we actually won't know what they are
before our app is sent to production so
we can't hard code them into our rules
and also we don't want to have to
specify the same rule over and over for
all these different games so we can go
ahead and get rid of all of that and
replace them with what we call wildcard
locations that's what this dollar
represents so dollar game ID is a
wildcard character kind of like
variable that will match all strings so
it will match all of those game IDs that
we previously saw and now instead of
specifying this rule that we saw earlier
for every single game we only need to
specify it one time so this is this is
good except for the fact that the data
we store in the game's node is actually
at we want different access levels for
different pieces of data for this pop
field the date the opponent and is
public flags that should always be
publicly readable by everybody there's
no reason that people shouldn't be able
to look at the date the opponent and it
is public flag whereas the game content
we know we only want ticketed customers
to actually be able to see this or see
it if it is public and then finally the
tickets node we're probably going to
want to lock down on a per user basis
where I can go ahead and buy a ticket
myself or I can remove my ticket but a
random person can't write to my ticket
node so if we look at how to do this
with the rules let's start with let's
just put a read rule on our game and
then underneath that we'll say you can
only read the game content given that
rule we determined earlier and then for
tickets we do want to do it on a per
user basis but for now we'll just say do
you have a ticket if so you can read all
tickets so this seems like it would work
except it actually won't that's because
of what we call the rules cascade which
is another one of our core concepts of
the rules language the rules cascade
essentially says that in order to read
data at a / b / c you just need a read
rule that evaluates to true at any level
in that parent hierarchy so in order to
read the data at games game ID game
content we actually would start at the
top and look at the game's node and we
would say do we have a read rule here
and we don't but we know that that just
implies that we have a true need false
and so we know that the read won't be
allowed at that level because we don't
visit if we don't have a read true so
then we move down to the next level in
the parent hierarchy and we go to game
ID game ID does have a read rule which
evaluates to read true
and so the read will be allowed and so
we actually will completely ignore this
game content read rule and that's
because if we are allowing people to
read games slash game ID then they
certainly are going to be able to read
games slash game ID slash game content
so in addition this tickets rule won't
even be included either so we need to
work around this a little bit and the
way we can do that is one option is just
copying these two rules that we had
previously
and then just specifying read true for
every field we want to be publicly
readable this definitely works but it
involves a bunch of different read rules
and now every time we want to add
another public field we're going to have
to add to our rules so if we want to add
a time to let people know when the time
of the game is we now need to add a rule
which is time read true so we can
actually get around this by
restructuring our data a little bit
instead of putting date opponent and is
public at the top level of the game we
can get rid of it add a new metadata
node and then throw those things in the
metadata node and we can go ahead and
refactor our rules in a very similar way
get rid of those three rules replace
them with a single metadata rule which
is re true and now our rules are simpler
we have fewer of them and if we ever
want to add that time node we don't have
to do anything with our rules we can
just add it to metadata and it will be
publicly accessible so we're getting
close the next thing we want to talk
about is this rule right here so we're
currently we're allowing people to read
the game content node if they're
authenticated at all and in our soccer
example this essentially would be I have
a ticket but I have a ticket to some
game not I have a ticket to this game so
we actually want to lock it down to only
people who have tickets to this game not
just a ticket in general so in order to
that let's take a look at what our
tickets node looks like we're going to
have it keyed by unique identifiers
these are those u IDs I was talking
about earlier when user authenticates so
it's a long you can assume it's a random
string and we're going to go ahead and
create a hash map of the
was of those you IDs and so we can go
ahead and change your rules now and say
our tickets note is going to be keyed by
UID so we use a wildcard location to
match all of those random strings and
we're going to go ahead and say read and
write if F dot UID triple equals dollar
UID
so let's break this down a little bit we
know the auth variable has our users
authentication state so it's the
currently logged in user and if their
UID is the same as the location we're
writing to which is that dollar UID will
allow them to write to that node and
read from it this is what we call user
based security so we've locked down the
tickets node the next thing we want to
do is lock down this game content node
and essentially what we want to say is
if the tickets node has the currently
logged in users UID as a key then go
ahead and allow the write or allow the
read we can do that by using a parent
reference so we take data which again is
the current data at that location we
call parent then we go to the tickets
node we see if it has the currently
logged in user as a child so the last
thing in this example I want to talk
through is actually being able to edit
the schedule itself here we can add in
admins node at the same level as our
games node in our data structure and
we'll key it again by UID of all of the
admins of the app and then you can throw
a bunch of profile information for here
all just going to put the name so we
want to lock down that metadata node
which actually determines the schedule
so that only admins can write to it the
way we can do that is by using this root
reference so we say root which is going
to take us to the root of our firebase
we go to the admins child and we see if
the currently logged in user is in that
node so that works
we've now locked down our data so that
the people who should be able to read it
can read it and the people who should be
able to write it can write it but we
need to validate that the write is
actually correct because you could write
wrong data that you know write a date
that is not a date at all but that's not
really what we want so we copy our rules
from the previous slide and then we say
let's add rules to date an opponent
which say the new data must be a string
so what's going on here we are
referencing the new data that we're
about to be written where as data talks
about the data that's currently stored
before the right new data is going to be
the data that's about to be written to
that node so we want to say when we
write a date and an opponent it must be
a string so this seems like it's work
but again we're going to run into issues
with our rules cascade biz just like the
read rules the write rules follow the
rules cascade so in this example let's
say we try and write a number to
metadata slash date as enough as an
authenticated admin we would first touch
that top rule which says are you an
admin and it would say yes I am and at
that point this date rule would be
completely ignored this is not what we
want so we can go ahead and also look at
it the other direction let's say we want
to write a string but we are not an
admin we first would go to that top
right rule we'd say are you in admin it
would say nope not in admin so then we
go down to the next write rule which
says are you writing a string we'd say
yeah I'm writing a string and we would
allow that right to happen completely
ignoring this admin rule which is
definitely not what we want because we
want to lock down right two admins so
how can we solve this it's actually
really simple all we need to do is
change these write rules to what we call
validate rules validate rules are
different than read and write rules and
the way I like to think about it is that
in order for a right to succeed all you
need is one write rule in that hierarchy
to be true so all of the write rules are
Ord together if any one is true then the
right will succeed
whereas with validate rules you need all
validate rules to be true so validate
rules are ANDed together so with
validation you can actually do some
pretty complex stuff so taking our
previous example we can actually require
nodes so we can say the new data that
we're about to write to metadata must
have a date and must have an opponent we
can also say more complex things than
just is it a string we can use regular
expressions to verify that the date has
the proper format we can use
Jane's queries which is this is kind of
an arbitrary example but we can say the
opponent must contain an S in their name
we can say more things like is this a
boolean or is this a number and then one
trick I really like is this dollar other
field this is kind of a little trick
which says don't allow any other nodes
to be written to this field so dollar
other will match all other strings that
aren't date opponent and is public and
we're just going to put validate false
which means if those are there just
completely fail the right so these are
really just a few examples of what you
can do with our validation rules you can
actually combine them in a bunch of
different ways and do some pretty
complex schema validation including
implementing things like counters time
expiring data and even user rate
limiting so we've seen a bunch of
different examples of how to actually do
security rules but I'm going to head
over to my laptop and there's one thing
to actually see code on slide and it's
completely another to actually play with
it so I'll come over here and this is
the brand-new firebase dashboard how
many people have already played around
with this thing all right cool a little
over over epic group so it looks a lot
more beautiful than our old dashboard
over here on the left you can see all of
the products that are now a part of
firebase and we're going to be playing
with database so we'll head over to the
database data viewer and that's what we
see right away we see all of the data
that's currently stored in our firebase
database I've already prepared some
example data and I will go ahead and
load that and it's going to have the
same format as all of the examples we've
been playing with so we have a bunch of
different admins which are keyed by UID
and include the name of the admin and
then we have a bunch of different games
which include game content which we're
going to lock down to ticketed customers
we have our metadata which includes our
is public field and our tickets which
again is keyed by UID so we can actually
play with these rules by going to the
rules simulator and so the first thing
we're gonna want to do is click this
little button over here and that's
she going to open up our simulator so by
default again our rules are you just
need to be authenticated to write to
write or to read so the first thing we
can do is just say hey I'm going to try
and read from slash games even though
I'm not authenticated and we'll see that
the simulated read was denied and cool
thing is you can actually come in here
and see which rule caused the failure so
we see on line three a little arrow pops
up that says the read was denied here so
we can go ahead and we know we can work
around this we can say let's just put
games dot read is going to be true and
we go ahead and run this again and we
can see our rules cascade at work so
we're going to start by this top rule
the read is not going to be allowed but
then we'll head down to this rule on
line seven on line six and we'll see
that the read is actually going to be
allowed and because read rules are Ord
together the write overall will be
allowed and then if we look at just
reading from the root again we'll see
that again we're not going to be able to
do anything so we can go ahead and see
this a little bit more if we swap the
read rules here so if we say put our
read rule at the top move this read rule
down here within games and then try and
read from slash games again we'll see
our rules cascade where we hit that read
rule at the top and we don't even need
to check the second read rule because
it's already going to be allowed and
similarly when we just read at root it's
also going to be allowed so let's go
ahead and add the rules that we came up
with during our slides and copy them
here this is exactly the full set that
we talked through and we have our rules
for the metadata node for the game
content node and for the ticket node so
we'll go ahead and publish these rules
which is actually going to upload those
to firebase servers and put them live in
your app and then we're going to try
doing some rights the first thing we'll
do is we will write two games and then
we're going to want to grab one of our
game IDs so we'll head over here and
just grab this first game ID and head
back to write games slash that game ID
slash metadata
and what we're going to want to write is
we'll start with just foo so we click
run and we see that we're not going to
pass because we're not actually
authenticated so this off variable is
not even is not even set so let's go
ahead and authenticate here you can see
the authenticated section where we can
choose a bunch of different providers
that we want to pretend to authenticate
with and we can actually override the
UID that we use in the authentication
for now we'll just use the randomly
assigned UID and we'll click run and
we'll see that man we still we still
failed the same rule even though we have
an opt-out UID now but we're not
actually an admin so we head back over
to the admin section we grab the admin
UID and we throw it in here and now we
run and alright so we passed the rule on
line 8 but now we're failing one of our
validate rules it says new data must
have date and opponent ok we can work
with that we'll go ahead and change this
to have a date which will be tomorrow
and we're going to intentionally have a
mistake in there where we only put three
characters for the year and then for the
opponent we'll go ahead and say we're
going to be playing Arsenal tomorrow if
we run that we'll see we now pass the
first validate rule but that still
doesn't allow the right to happen we
fail this regular expression so we can
fix that by making that 2016 click run
and now we see all of the different
rules succeed and our overall simulated
write was allowed you can also go to
this details section to get a ton more
details about why the write was allowed
you can see the type where it was
written to what data what often occation
state was whether or not you were an
admin and then a bunch of different data
for each line that was executed in the
right so if we head back over to the
slides you've kind of gotten a rolling
tour so far of both the rules language
itself and the and the actual simulator
so if we head back over to the slides
hopefully you guys are not feeling too
overwhelmed at this point and hopefully
you're realizing the breadth of security
the options that you have available to
you
but I kind of realized that a lot of you
I've gone through a bunch of stuff
already and you may be feeling a bit
stressed or you may be feeling more
scared or you may even possibly be
feeling like this and be completely lost
and like we realize that like security
is not easy there's no there's no
getting around that firebase has also
taken a different approach to security
than many of you are familiar with so in
fact we found that security rules were
consistently one of the hardest things
for new firebase developers to figure
out so we we heard that feedback and we
actually were playing around with
improving this situation by creating
what we called rules compilers so first
came a compiler called blaze which
introduced some stuff like types and
functions and inline tests and then came
bolt which built on the work of blaze
and also included types including
generic types it included a cleaner
syntax to write less code and it also
included match paths to make your rules
easier to read and write but there was
still a problem and the problem was that
all of our rules languages and compilers
were all very database specific and now
firebase is much more than a real-time
database it's now an integrated suite of
products and that's kind of where this
next product comes in firebase storage
we needed a rules language for firebase
storage and we felt like the existing
rules language just left a little bit
too much to be desired so we kind of
went back to the drawing board and we
built a new rules language from the
ground up one that borrowed heavily from
the real-time database rules the things
that we liked from that and that our
users were able to pick up very quickly
and also included the different
learnings that we got from our blaze and
bolt compilers so it's still early days
for firebase storage there's lots of
stuff that we still have planned and
that is still going to be coming out but
I do want to give you a walkthrough of
the existing features and show you how
you can use it to protect your files
stored in firebase storage again before
we actually look at any data I'm sorry
before we look at any rules we need to
look at the data we're going to be
protecting we already know the real-time
database stores data like this
have a users node we have it keyed by
UID and we have a bunch of profile
information this is JSON data firebase
storage on the other hand is going to be
protecting data like this this is a
directory structure like you'd have on
your local file system instead of a
user's node you'd have a user's
directory and within that you'd have a
directory for each user and for each
user you'd have a bunch of different
images and audio files movies and text
files and this is the kind of stuff that
we're going to want to protect so what
do the rules actually look like the
syntax is going to be very different
from the real time database rules but
the concepts are still very much the
same so we start with the default
storage rules and the default rules say
we first are going to specify what what
service we are using to write rules so
we're gonna say we're using a storage
the firebase doc storage service within
that we need to specify what bucket this
is our Google Cloud Storage bucket we're
going to be reading and writing files to
and then we're going to use match paths
and the way to interpret this this
syntax is that the curly braces are
actually kind of equivalent to the
dollar in dollar wildcard locations in
the real time database rules and so
what's saying here is we're going to
match all paths they wild-card all
strings and the equals dollar dollar
essentially says allow it to be many
levels deep so by default if you just
had all paths with no equals dollar
dollar
it would only match one level deep this
will match as far down as we want to go
and within that we'll go ahead and say
allow read and write you see we have a
more compact syntax because we're
allowed to do read and write rules on
the same line and we'll say if requests
dot off is not null allow the read and
write to happen
so these rules are equivalent to the
default rules for the real-time database
there are a few differences in the
actual conditional so like off has moved
from a top level variable into this
request variable and the request is
going to contain all the information
about the request that is being made the
read or the right
so let's look at a few more examples we
maybe we don't want to actually do
read/write only if you're authenticated
what if we want to make all the stuff
public we can do that by just doing a
low readwrite with no conditional again
much more compact syntax than the
database rules
similarly for to do private we can go
ahead and just add in conditional which
says if false which will always allow
which will always evaluate to false so
this would not allow anyone to read
anything finally we can do user base
security so instead of doing that all
paths match we're going to go ahead and
do a match path which looks like this
we're going to say go to the users
directory and then do match any string
which is going to be our UID the unique
identifier for that user and then match
all files this time we're not using
equal star star so we're not going to do
multi-level match paths and we'll go
ahead and say you're allowed to read and
write if you are the currently
authenticated user so we say request off
to ID equals the UID and that that
second UID comes from the match path
itself so let's head to a soccer example
and let's talk about actually storing
some game highlights like we had in the
real time database we'll have a top
level games directory instead of a games
node we will again key that directory by
the game ID so the data between the two
is actually looking pretty similar the
structure and then within each game will
have a highlight reel we will have a
recording of the audio and we will have
a bunch of different fan images these
fan images will be keyed by the unique
identifier of those fans and within that
we will have a bunch of different images
so we want to go ahead and write some
rules to protect this data first thing
we'll do is we'll write a top-level
match path which says slash games slash
game ID so this is exactly the kind of
thing we did with the rules language
except we're doing it much more
compactly and then we'll nest match
paths like we were able to nest rules in
the database rules and we'll say if in
game slash game ID we have a highlights
movie let's go ahead and allow
everyone to read it and let's allow you
to write to it if you are authenticated
as an admin and so here we're using a
new concept and this is actually using
our custom authentication so that off
variable that specifies a UID in the
rules language you can actually make any
you can make any variable with net off
variable so you can say off is admin and
so in the storage rules that data is
stored in request auth token and then we
store a bunch of custom attributes that
we want to write and in this case we'll
store whether or not the user is an
admin next we need to do rules for the
recording audio file and those rules are
actually going to be identical to the
highlights real finally we need to
protect our users data
so within fan images UID file name we
will allow all of those to be read it's
a public view but will only allow you to
write it if you are that logged in user
so we can go ahead and clean up some of
these rules and make these even more
compact the first thing we'll do is
we'll notice that the rules for
highlight-reel
and the recording are actually identical
so let's go ahead and get rid of one
slightly change our match path to say
just match on any file name and then
update our write rule from which
currently just checks it for an admin to
also check that the file name itself is
either highlight stop move or recording
mp3 so we've gotten rid of a bunch of
different lines next thing we can do is
actually extract this read rule from
these two rules because we know that
everything is publicly readable so if we
pull that out we go ahead and squish
those two guys down and then we create a
match path for all paths as many levels
deep as we want and just put and allow
read we've now taken what was initially
six rules and made it down to three
which is much easier to read and much
easier to understand less to keep in
your head so one thing you're definitely
going to want to do with your your files
is validate that they are of the correct
type and the correct size and things
like that
so the validation for the storage
language is actually quite different
from what
we have in the rules language we start
with our rule which just says you need
to be the logged in user and then we'll
go ahead and add a rule which says the
size of the resource that we're about to
write has to be less than five megabytes
we can also do things like check the
content type and verify the content type
of the resource we're writing is an
image even more so we can actually
determine which kind of writes we're
going to allow so we can disable deletes
by doing a request dot resource does not
equal null and if you think about this
this is saying if I ever try and write a
resource to this location that is null
which means I'm obliterating what is
existing lis there then I won't be able
to do that and then finally we can
verify it the file name itself is less
than 32 characters so one of the big
things I'm very excited about with
storage that we don't have in the
database rules language is functions
this is something that people love from
blaze and the bolt compilers so let's go
ahead and take some of a subset of the
rules that we had in the last slide and
turn them into functions first we'll
start with is this the current user will
go ahead and create a function called is
current user which takes a UID
and we will just return that same rule
set verifying that the logged in user is
the same as the UID the function takes
and if that is true we can go ahead and
replace this rule down here with a much
shorter rule which is just is current
user and past the UID similarly we can
do the same with the resource size rule
we'll go ahead and create a less than n
megabytes rule or function pass it the
size of the number of megabytes we want
to limit to and then we can replace the
rule down here with a call to less than
and megabytes 5 finally we can take the
rule that checks whether or not the file
is an image create a function called is
image which just returns the same exact
rule and replace the call down here with
is image so we've taken what was a
pretty long and hard to read write rule
and turned it into something which is
actually pretty clear and easy to
understand even if you didn't write
these rules yourself you could read this
and understand who is
have access and what type of files will
be written here it's even short enough
that you can fit it all in a single line
of code so this is a huge improvement
over the existing rules language and I
think you guys are going to find that
it's going to clean up a lot of your
code so that is the new fire based
storage rules language as with the
database rules language it's composed of
a dozen or so primitives which you can
compose together to actually form really
complex file access rules and validation
it includes a bunch of things from the
database rules language itself but also
all the new improvements that we got
from things like blaze and bolt and it
is better situated for the new
multi-product world that firebase now
occupies at this point I think
congratulations are in order
you all just made it through my 9 a.m.
talk on security you now know the tools
you have at your disposal to protect
your firebase data in both the real-time
database and in the root end in storage
hopefully you use these primitives and
put them into either an existing app or
if you're new to firebase a brand new
app and make sure you actually are
protecting your data if you're
interested in learning more you can find
more in their documentation head on over
to firebase Google comm we have
documentation for all of the different
products you also can find out about all
of the other parts of firebase all of
the new things that were announced
yesterday by heading to our features
page and lastly support is is a huge
part of what has made firebase
successful so far and it's something
that we continue to try and strive and
do our best at and that's not going to
be changing anytime soon so please head
on over to sort of port Page join our
slack community join our Google Groups
join our Stack Overflow community and be
a part of the conversation
let us know what features you want
whether it's with the rules language
whether it's with the actual database
rules or storage or any other product we
definitely value your feedback and a lot
of what we released yesterday is based
on feedback from customers like you also
brand new YouTube channel with a bunch
of really cool intro videos for all of
the new features and you can always find
us on firebase on Twitter for
are all of the up-to-date news there's
still a lot of cool stuff happening at
i/o we still got two full days left half
the office hours are over
but you should definitely check out the
one that's at 5:00 p.m. today or one of
the ones tomorrow also if you're
interested in seeing more firebase
sessions I think there's still double
digit talks left that are just about
firebase so - that you may be interested
in if you thought this was a good talk
one would be zero - app develop with
firebase that's going to be tomorrow at
10:00 a.m. on the main amphitheater and
there's actually a really cool talk
where they're going to be building a
Android and iOS and a web app all that
communicate with each other all from
scratch that includes storage database
rules and authentication all in 45
minutes so it's going to be exciting
whether or not they're able to do it so
you should definitely check it out the
other talk you may be interested is the
one I mentioned earlier which is about
firebase authentication that one is on
this stage tomorrow at 1:00 p.m.
lastly if you're interested in talking
more about firebase come join us right
over at the sandbox right next door and
we can take a look at one of your
existing apps talk through rules in your
app or talk about any of the new
features so thank you everyone for for
coming this morning and learning about
the key to firebase security my name is
Ben Jacob Langer if you're interested in
this kind of information you can find
more on my twitter at underscore j
Wanger thank you very much peace out and
do not forget to protect your firebase
data</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>