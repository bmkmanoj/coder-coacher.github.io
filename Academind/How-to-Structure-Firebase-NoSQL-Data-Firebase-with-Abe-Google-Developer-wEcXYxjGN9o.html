<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Structure Firebase (NoSQL) Data | Firebase with Abe (Google Developer) | Coder Coacher - Coaching Coders</title><meta content="How to Structure Firebase (NoSQL) Data | Firebase with Abe (Google Developer) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Academind/">Academind</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Structure Firebase (NoSQL) Data | Firebase with Abe (Google Developer)</b></h2><h5 class="post__date">2017-08-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wEcXYxjGN9o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so in this video you walk through
firebase in general and we look at all
these features or the most important
features when it comes to building your
app and when the super important 52
feature obviously the database what we
what can store our data read it and so
on and when we talk about the database
we got like a basic structure here for
example from the app we saw in the
previous video where we could push our
messages into the database and then it
words because I had this as a reference
here when we pushed it I reference
messages they would create this messages
note and simply add all these messages
with these IDs right and that's a super
simple structure obviously so here if we
withdraw this is one example structure
basically we have like the key messages
here and then obviously our different
IDs which are a cryptic strings like
like this one below that s messages now
the thing is since you can structured
like Jason there is the ideal or the
danger that we create super deeply
nested structures especially if we would
imagine we had not just messages but we
had different rooms and maybe a message
could be part of separate rooms then you
could get a much more complicated
structure so what are some common
pitfalls or English to wait yeah well I
think the biggest thing when you're
thinking about building a data structure
in firebase is you have to think about
how is your data going to be consumed so
pitfalls and issues come from not really
general rules as much as how are you
going to consume this it in your app and
there's issues there so like this
messages is great right now if we're
only dealing with you know a list of
text where each users or Samsung's you
know this is Texas is a message and just
stacks up if you need to add complexity
that you have to start thinking about
how am I going to use this data so an
example would be if each message
headaches under yeah so I send a message
and it shows like my profile image or my
name next to it and the immediate
question with firebase is do you just
tack that under here I can show you so
would you just tack that under
this these kinds that I got under this
will have a name and like a photo URL so
that would be completely fine in a lot
of situations there's nothing inherently
wrong with that we have huge chats that
just have this but you can imagine a
situation where I'm a user maybe I
changed my profile photo now every
single message I've ever sent is going
to have that old photo URL so this is a
case where it becomes the veteran call
what do you want to do do you want to
store this name in this photo under each
message or do you want to store
alternatively if it's another crazy idea
under that just their UID
and then look up that data yeah and both
of these are reasonable the UID one
works better if you have fewer people in
the chat if it's a conversation between
me and you that's only two UID so if
it's a twitch chat and you have a
hundred thousand people talking in it
probably makes more sense to this it's
not only are those messages more shortly
lived but they have a lot more people so
to be more trips to pull out all the
data from the profile so each one can
work it just depends on how you're using
it and this is the general thing like
firebases how am i consuming the data
and structuring in a way that it makes
sense when you want to pull it back yes
and you can maybe do like a
Hossler that you store the name and the
ideas of you have to name right away let
us display that next to the message also
have the ID if you need to reach out and
pull them extra just formation they
click on a message and you can
definitely do that and something like
that is a great case where profile
photos tend to take a second to learn
anyway so an extra extra round trip that
only takes as long as they fire bit.trip
text that we sell is it not long threw
that on top of the normal image loading
is probably noticeable yeah so that's a
completely reasonable route and that's
why these priorities of what data should
I sir where what you're like copy or
denormalized comes down to what you care
about in your app mm-hmm that makes a
lot of sense and I think when I don't
think which is important to keep in mind
is if you have very complex structures
with a lot of nesting you fetch all the
data every time you you basically
queries or you have this on listener and
you get all the data and it's just what
I get all the messages you get
everything which is nested below that
you write exact
and this is one of the general themes
with firebase is that if you're loading
one thing you're loading all of its
siblings as well so an example of that
is if I wanted to load it if I loaded a
/t messages I would get all of the
children yeah I wouldn't generally get
this one and this first record and the
second record and no other records you
could do that you could pluck those
throughout if you really wanted to but
that's not really how its set up so
you're not only loading you know the
entire list of messages but like you're
send you're loading everything under
every single one so you can limit those
you can say let me give you ten messages
into the last ten give me the ones that
have this exact field or tag or
something on them so there are you know
extra things you can do that but in
general you have to realize that when
you're loading data you're loading all
of it they're not fields or
things like that that makes a lot of
sense so if you are coming from maybe a
sequel background you you have like
obviously a lot of tables and connect
them by ID typically and as you already
mentioned kind of you can store the UID
here too to basically rebuild this when
it's needed or when it makes sense but
it's also important to take advantage of
this like MongoDB like structural DD
Jason structural item - yeah as it says
make a judgment call next what makes
sense to next and and that's the thing
storage is key right like I can copy a
name a hundred thousand times and it
will cost me functionally nothing it's
extremely extremely cheap to do but what
is more expensive is loading that onto
the client how many times am I going to
pull down that setting name things like
this do come to concern but in general
like storing the same the same thing a
bunch of times is very cheap
yeah and it's a lot more expensive to
pull things down on the client do
complicated connections and transform
it's generally easier to just write the
same data again because it's just
probably you can get an easy change but
in because you do have to change it like
you can use either construction but yeah
it works really well to do like named
photo of time of the time yeah that
makes a lot of sense um how would you
adjust to have a doubler example how
would you example awfully structure it
if you had like chat rooms with messages
in there and then we also have users
human most excel for deadly yeah so if
you're having like I use your profile
you're talking about it yeah so provoke
we probably want to set this up so we
have a high level two they're not really
tables but two collections of a type of
thing so example that when we would have
like rooms up here and under that we
would have room IDs and those would be
those crazy ABCs and then under that
will have all the messages for that room
but we wouldn't want to store them just
like this where it's you know exactly
under the unique key we want to do
something where we have probably
messages under that and then under
messages will put in each individual ID
as they come in an agent critical
message that'll yell hi whatever
oh and so by doing this we give us a
little bit more flexibility because this
room has that unique ID that's not a
human readable name that's not anything
interesting so we could also have next
to messages we could have like title in
title could be you know the name of that
chat or the name of that room so if I
come by later I can load at this level
I'm inside room slash ABC and I will get
back all the messages on the title along
with any other metadata or anything else
interesting I put down here in the
future I can come along I'll use that I
I really only want that room title so I
can go rooms this ABC key and just the
title and just get that but most of the
time I'm going to be loading all this
data as it's one group now if we have
another structure like users that you're
talking about user profiles or your
photos and your L things like that we
could have another top-level collection
just called like users and under that
instead of using crazy unique IDs we
would use their u ID as the key so now
when a user signs in or when a UID is
referenced by a message we know we can
look at users slash their unique ID and
under that will be you know their name
Co file image everything like that and
this is the second big thing about
structuring firebase data is that you're
not only building for how you're
consuming it but you're building your
structure in a way
you know where to look it which is a
really interesting concept to me because
the idea that your data is getting
pushed into an array it's basically lost
you don't know where it is you don't
know what key is associated with it but
you can if you're building up this path
you know that any UID you have if you
look at user slash that you already
slash the name that would be that
person's name yes and so it's reliable
so you don't even have to load data from
the server you can just say I know where
to look to pull this out and render in
mind that that's really interesting and
we guess that you are a Z from basically
firebase again if we use alt education
we get to back and we create a user and
then this may be important we have to do
that part on our own but we need to push
the data to do real-time database you
can't leverage the firebase of Education
we can't store it the same databases
email password yeah no they're
completely separate because like email
password we don't want you to possibly
exposed yes or a shits right so they're
complete completely separate but there's
absolutely no reason you can't use a
yellow ID like this or even uses
somewhere else so you can imagine a
situation where users head rooms like I
as a user have my own list of
conversations so you could put another
node in here we go rooms and then under
that like in between here put their UID
and then under each UID you have a list
of my own conversation things like that
you have you have a ton of options for
how to do that and that UID is a really
powerful concept for just storing data
for your user is very commonly used as
as an identity and like I was talking
about before you can rely on that even
if you're using anonymous off or you're
using phone or email password you always
have those UID to say this is the user
I'm going to store it knowing that
they're you ideas associated with them
now what I know is that it can be
difficult to you to make that judgment
call you mentioned so cute you guessed
that right set up and are there some
ways we could think about it or some
some tips you could give so how to make
this decision they're obvious it's never
that clear right or wrong but some ideas
or how do you approach this yeah so my
rule of thumb is I shouldn't ever load
data i'm not rendering so if i'm not
displaying it on the page i need to
structure my data in a different way
where i can fetch it and be more
specific
and I think being specific and you know
using that rule of thumb of saying I'm
only going to fetch what I render really
helps define your structure because you
can kind of work backwards with firebase
a lot of the time you're not building a
bunch of data into your database and
then building a UI on top of it so
that's traditionally what you kind of do
you have like some set and then you
would build the UI second but let
firebase since it's so easy to write
data people build up the UI they build
up the in your app and they start
writing data from the app and as you're
doing that you can say alright I'm
writing it back and now I'm pulling it
back into my app but I really have some
use case where I need a room title and I
need the data was created but I don't
need messages so that's a situation
where you want stuff I can say all right
is storing us all in one location the
most reasonable or should I have
something like slash rooms your rooms -
metadata or something and have under
that just those two fields that I want
of title and you know created because
that way I now have a specific location
I can look at that has the exact date I
did and so as you're building an
application just always keeping that in
mind that you don't want to fetch what
you're not going to render it kind of
just exposes itself the big issues with
these are with this methodology is that
you might not always know how you're
going to display it right like if I'm
building an application and I find out
six months after I finish this that well
I really need this different view of my
data this is a situation that cloud
functions really helps out with this is
what you can do now is use cloud
functions to build basically views of
your data so what you do is you write a
little function and you have like rooms
and you say all right every time
somebody writes to one of these keys
then go and maintain this other
structure for instance to make rooms
meta put it with the same key and just
joy totally created so that you're doing
that you're writing it and it's being
stored there but then it's super easy
you can zoom on again and you're not
doing you know anything complex they're
just reading and writing a couple of
feels but now you have a really really
efficient way to read that and that's
more general theory even separate from
firebases it's like optimized for read
yes because people are going to read
content in a thousand times more than
they'll ever create it yes this is the
nature of application so you can cut
functions to build up different views
and things like that is a really
powerful tool to keep that flexibility
even after you've really you know
defined destruction that happened within
yeah and in general a good idea to also
kind of get some code out of like your
fronted what it does we belong if you
want to store something you can even
make like 10 SDK calls and write the
different pieces and you see resolve to
get that for each callback or you just
make that one call or queue which are
really related to your front-end you
know let's punch through the rest like
egos absolutely yeah and it worked
really really well and it allows you to
have just one you know main track
objects like this is a chatroom object
and I will write to that and assume is
all right so that kicked off a function
renders to reviews update to my profile
to say our last talked in this chat at
this time and does all of that so your
client side logic say it's super simple
it's one right but you get all this rich
data being written and spread out across
forever is super useful
there's Lansing which is pretty useful
because now we did talked about these
example structures but obviously there
is also place to read about it and
that's documentation which kind of
explains the things we all cover like
we're having different rooms and
structures and you can basically read
Olympic there to get some ideas or it
was too quick or anyone's I deeper into
that so that's also a good good resource
but the end result just practicing lets
me and you will probably hit the point
where your application such as say that
does need or the other way around and
the important thing to keep in mind
maybe is that it doesn't cost you more
to add more notes or more top level to
make it and then yet of course storing
more cost you more but it just plated up
it does question yeah the the amount of
the amount cost of duplicating something
even a ton of locations is just much and
it's going to be way more performant if
your app is for your effort every time
you look and you pull that data it's
exactly what you need to render it may
be super fast that's because that's
something which can be challenging
especially if you have a sequel
background record because there you try
to
come up with a schema where everything
is s has it's less redundancy as pop you
want to have one general which manages
one thing and never want to duplicate
data and that's kind of the important
switcher to make in your head now it's
okay to have some redundancy yeah it is
and it's you know normalization
generalization all you know classic
database concept we do kind of flip them
on their head here and it's because
firebase real from database is
fundamentally a different type of
database and it's not just different in
terms of how you're interact with it but
it's different on a technical level when
you when you're thinking about building
on top of it so yeah a lot of our
classic sequel rules just don't apply
anymore
and like if you're using sequel
definitely do those things but in real
time database we make use of the fact
that storage is cheap and we build
structures out of duplicated it makes a
lot of sense so I think a nice next step
is to look at the rules and those rules
obviously another super important
feature because what you could wonder
right now is that we have ways to store
data we know how to structure it but how
do we actually make sure that we only
store the data we want to store and that
oh you people who are our users what
allows you to store data well are able
to so if I look at this another
legitimate fantastic</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>