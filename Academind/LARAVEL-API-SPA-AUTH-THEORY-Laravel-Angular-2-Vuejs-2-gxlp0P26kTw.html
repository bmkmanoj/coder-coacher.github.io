<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>LARAVEL API + SPA AUTH THEORY | Laravel + Angular 2 / Vue.js 2 | Coder Coacher - Coaching Coders</title><meta content="LARAVEL API + SPA AUTH THEORY | Laravel + Angular 2 / Vue.js 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Academind/">Academind</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>LARAVEL API + SPA AUTH THEORY | Laravel + Angular 2 / Vue.js 2</b></h2><h5 class="post__date">2017-02-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gxlp0P26kTw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back to this series great to
have you back on board the far end is
serious we created a back-end with level
which allows us to store quotes and
fetch those quotes and we added a
front-end with both angular 2 and view
chess now with that out of the way there
is one thing I want to dive in right now
before we then have a look at how we
could also implement view chess with
level we'll do this later in the series
for that let's have a look at
authentication here's our angular 2 app
it looks kind of similar to the view JSF
of course now we can create new quotes
there and you quote send them to the
server and yeah it was created and with
the coach quotes and get the quotes
here's our new quote and then we can
edit it like this oops maybe also hits
the Save button though so like this and
if we reload the application get quotes
again we see our change was indeed
stored on the server and so on so that
all works now imagine we want to protect
this whole application behind like a
authentication check so only signed up
word signed in users should be able to
add quotes and to add them to lead them
maybe it's possible to view the quotes
but you shouldn't be able to well do all
the stuff which changes them so that's
what we're going to have a look at in
this video and mostly in the next videos
but first let's understand how
authentication really works in such a
setup where we have kind of two
different and our front end using
angular or view and our back end driven
bilateral let's understand how that
works to best understand how application
works in such a setup where we have
separated back-end and front-end let's
compare it to the default setup the
traditional setup you might know from a
full stack application where you have
letter well on the backend and also have
level render some views possibly through
the blade templating engine so where
your whole application is driven by
level yeah I've got a lot of videos
showing this approach on this channel
now in this approach authentication
looks like this the user sends the
authentication data because it was
entered in some form and then the submit
button was pressed and on the back end
of the
on the narrow side in the level code we
will check that data see if it fits a
user in our database and then we will
create and store a session and this is
an important part level now creates a
session and stores the session on the
server this is how sessions work in PHP
right they are stored on the server this
is what defines a session now let will
also send something back to you de
client though the session ID that ID is
sent to the client with the response of
our assign in or signed up request
request and on the client we store it in
a cookie and for each request thereafter
when whenever we send something to the
server
well the server is responsible for
giving us back of you anyways and since
we also have our cookie which we send
with each request well level can check
if it points this session ID on the
server where your session was stored and
if that is the case we know well base
climb this specific client is
authenticated and this is what's very
important about this approach approach
here the back-end knows the client so
our server our level code on the server
knows our client the user using a
browser connected to that server those
key does the session driven approach
which you know from the other examples
on this channel here probably now 4
hours set up here where we have a clear
separation between our client angular 2
tourism and our back-end levels rhythm
we have to use a different approach
because we can't set up this strong
connection because not every page change
is sent to the browser to the server
excuse me if we navigate around in our
single page application we're not
sending a request for each change in for
each time we change the page or do
something there so we can set up such a
close connection therefore it looks
differently here we also send our
authentication data because we've
submitted a form and we sent this with
an HX request using angular to use HTTP
service or for vue.js Axios for example
and then when there's a sent we check it
on the server but now no session is
created in
stet a token is created Jason web token
typically now there are different
authentication approaches - you might
have heard about OAuth or about lateral
passport which is a readily configured
olaf server for you to set up these are
more advanced and complicated setups
which typically also involves having
clients to register for so you
registering your client app to that
server forest for example if you're
using facebook login you have to go to
Facebook register your app you're able
to add for example there so that your
users of your app can now use the
Facebook sign-in service so that is a
bit more complicated and not something
we are using here we are going to use a
different concept where indeed level our
back-end here will create such a tokens
ID such as a JSON web token and send
this back to the client
now what's inside of such a JSON web
token it contains some data about our
logged in user we can also store some
additional data in there if we want the
most important part is we create and
sign it on the server with a specific
secret which only the server knows we
don't store that secret on these client
we don't even send the secret back to
the client we only sent back the token
which was created
now this token is then stored in the
client on the client of the browser in
the local storage for example though you
could also store it in a cookie and
whenever we then send a request to some
protected resource on the server so some
resource which needs authentication we
add hatch our token to that request so
with each request we need that we attach
it and now comes the interesting part
since this token was created and signed
on the server with a specific secret the
server knows the secret and can now
validate our token so we can't send any
random string there instead we now check
ok do I notice token did I create this
token and is it still valid because
tokens can expire and if this is all the
case if it is valid if it was indeed
successfully checked validated so that
we indeed can match this kind of token
cue to tokens we would create because we
sign them on a server if there's all
valid there
we return the protected resource and if
anything of that is invalid if we can't
verify the token if it was or if it is
expired well then we send back up 401
unauthenticated we're an authorized
error so that the client Ibrahim log in
again or well simply is denied access
this is how authentication works that's
the theory now let's see that action in
the next videos when we actually
implement this approach when we
implement a third party package on our
level back-end which allows us to verify
users to create such tokens and to
validate such tokens so let's start with
this in the next lectures or in the next
videos</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>