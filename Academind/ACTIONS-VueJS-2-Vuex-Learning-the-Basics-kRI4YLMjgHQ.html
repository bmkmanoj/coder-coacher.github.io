<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ACTIONS | VueJS 2 &amp; Vuex | Learning the Basics | Coder Coacher - Coaching Coders</title><meta content="ACTIONS | VueJS 2 &amp; Vuex | Learning the Basics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Academind/">Academind</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ACTIONS | VueJS 2 &amp; Vuex | Learning the Basics</b></h2><h5 class="post__date">2016-12-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kRI4YLMjgHQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to number video about view
chairs and view X this video is a part
of a series but we started at a basic
project not using view X at all and we
improve this project by adding gathers
and mutations and the central story at
the beginning and now we've gone pretty
far but there is one big limitation of
this project right now or one possible
limitation should say if we had any
async code being executed as part of a
mutation that won't work
mutations always have to run
synchronously and it makes sense because
mutations are the methods directly
manipulating your store so it would be
kind of bad if they had some async
nature to them because that would mean
that when you commit a mutation it might
not run immediately so if you then get
the value thereafter it might not have
changed yet so therefore it makes sense
that mutations have to run synchronously
but what if you have let's say some HTTP
call which gets you a value which you
then want to use in your commit how
would you handle this because with
mutations as we use it right now that is
simply not possible or not possible
inside of your store at least so how
could you change this the answer is
actions and in this video we will learn
what actions are and how we use them and
how we can combine them with
asynchronous code let's start by setting
up an action I do does indeed store the
chess files in my store and I already
added the state gathers and mutations I
guess you can guess how I do add actions
I add a new property named actions and
this also is an object here I choose any
name for the action and I will name it
register and oftentimes you will have
the same name for the action and the
mutation because the action is kind of a
middleman running before you actually
commit the mutation here the action also
gets an argument and this argument
actually is the context of this action
now the name is of course up to you the
name you assigned to this argument but
will be
context and context is almost the same
as store but not completely the same
therefore it's a different name now on
this context we can simply run the
commit method because as I said it's
pretty much the same as the source store
but not entirely technically it's a
different object but it does have a
commitment and therefore here I can
commit the register method which excuse
me did register mutation now of course
like a mutation the action can also
receive a payload so either a payload
object like in the unregister approach
here or the value itself so use your ID
here and then I can also pass this as a
second argument to the commit method
because somehow I need to get that value
to the mutation
now with that action setup I can go to
my registration view file where I right
now directly commit the mutation and
here I can now instead call this store
dispatch
so like the mutation I'm not calling
actions and then executing the action
itself instead note we have to dispatch
method and this means I just batch the
action surprisingly here I do need to
pass the name of the action which is
register and then as a second argument I
payload user ID or alternatively like
with a mutation in the registrations dot
view file we could also dispatch it with
one single object where you have the
type as a set property and then any
other amount of properties you want to
use in this case though you need to make
sure that here you're getting the
payload in general and you access your
values like we do it here on the
unregistered mutation if I totally lost
you now have a look at the last video in
the series there I do explain this
approach of passing a payload back to
the action though we're dispatching it
and with that I'd say let's see this in
action well it looks good the app
behaves exactly like before so what did
we gain by
using action here well what we gained is
right now nothing but now we can execute
async code here because as I mentioned
in the beginning inside of a mutation so
inside of these methods here
you can't run asynchronous code
you always have to manipulate your state
in a synchronous manner but here in the
action before you actually commit it
you can run asynchronous code and yes of
course you would have been able to run
it simply in your component before
committing but then again you would have
that mixture of having some logic in
your components and some logic in your
store you really want to have all these
store and state related logic in your
store though therefore I run the action
here or decode now let's simulate some
async action by simply setting a timer
over let's say one second and after that
second is over then we will commit this
like that
now with this approach if we have a look
at an outlet register you see it took a
second before it actually happened
unregistering happens instantly though
because it didn't set a time earlier so
with that you see the difference here we
can and we are allowed to run
asynchronous code and mutations we are
not allowed to now one additional load
note since we are mostly only interested
in the commit method here you don't have
to get the full context object you can
also use an average or six feature
called deconstruction where you simply
use this syntax here curly braces and
then any name you choose to simply
extract and then the name of the
property you want to extract to directly
extract that property from the object
you're getting as an argument throwing
away the other properties that is
something you have to keep in mind but
if you don't need them that's okay and
with that you can leave out the context
thing and directly get the commit method
in this case so this is an action here
running some async code
now since we dispatch our action here in
the registration dot view file we have
the same behavior as before with dad we
finished our view X implementation using
the state in our central store using
gathers to get the state or get some
values depending on that state using
mutations to change the state and using
actions to trigger mutations possibly
after running some async code before
doing so these are all great things and
with that I hope you get a solid
understanding of how UX works why you
might want to use it and how you could
use it here I get a little graph showing
the whole flow of actions and all values
and it's basically just the thing we
built throughout the last videos but
with that and the videos that hopefully
is crystal clear how you can use view X
how state travels and how values travel
through your application and why it
might be beneficial now I got one more
video in this series and in this last
video I will show you some additional
tricks or additional things about UX see
you there bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>