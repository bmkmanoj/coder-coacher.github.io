<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Grouping | REGEX DEMYSTIFIED | Coder Coacher - Coaching Coders</title><meta content="Grouping | REGEX DEMYSTIFIED - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Academind/">Academind</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Grouping | REGEX DEMYSTIFIED</b></h2><h5 class="post__date">2017-10-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NrzFle7RD0g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this video about regular
expressions great you have your board
again we already built a lot of regular
expressions in this mini series we
learned a lot about the different
regular expression features now I want
to have a look at the various groups we
can work with in regular expressions
positive look Ahead's and stuff like
that don't know what it is this video is
for you
so let's dive into groups and for dad on
regex 101.com on the bottom right we can
go into the group constructs quick sheet
or a quick reference sheet here and then
we see the various groups we have of
course we have a group with parentheses
we have a begin here and we have this
regular expressions we get free hits for
a B and we could omit the parentheses it
doesn't do anything here it gets
important for example if we add a
question mark to make this optional now
the question mark is referring to the
full group if we omit the parentheses
the question mark would just refer to
the B so it would match a in this case
as soon as we group a B and make the
combined regex optional da is not
matched anymore
so this is a basic group if we just use
parentheses like this though it's also
called a capturing group now oftentimes
this does not matter to you to be honest
but a capturing group simply means that
matches found with this regular
expression so with the regular
expression enclosed in the parentheses
is kind of stored and you can't refer to
it again with a backslash and that
numbers where the number relates to the
well number of the group so the first
group has number 1 for example it
becomes clear if I now remove the
question mark so that we don't have
these annoying things bars in between
now you see that a B a B is actually
matched as one thing the third a b is
not included in the match though now if
we were to use a plus sign after / dub
parenthesis all of that would be grouped
into one match so backslash one is not
equivalent to the plus sign instead what
it says is first of all here we match
NAB but then keep in mind a regular
expression is read from left to right a
valid match is not just having a a B but
that is followed by another a B so we
could replace backslash one with a B and
that's the idea
we have two similar patterns referring
to the same match here we can then use
backslash 1 to simply say whatever you
found here should be used again and we
of course we could have something in
between like a @ sign now a B at a B
would be matched now this is not a way
to be lazy and write something 1 write
some check 1 and then repeat it it's not
just referring to you the exact check
here but also to what it found which
becomes much clearer if we don't use
hard coded characters but a range let me
include a range in that parenthesis
capturing group here in there let's say
we allow any character a to set now you
see it's not matching the second a B is
not matching that whole expression here
at the beginning which it previously
matched if backslash 1 would simply mean
repeat the rule in the first capturing
group we would expect a match though
because the rule any character which is
lowercase clearly is satisfied for this
part here too so why is it not working
then because it's not just copying there
pattern it's having a look at the thing
this pattern matched you and a to see
like this matches one single character
in the range from lowercase a to
lowercase set so a at a what now matched
is a B at a B doesn't we would have to
add a plus after the range to say as
many characters as you want and then
here it's not matching BB or something
like that or C B to make it clear
because it's not copying the rule as I
said it's copying the result to match
and the match of this is a be because
our pattern is a to see in front of a at
so a B is matched but then we say the
full regular expression should all
match parts word is is true but then
where the part matched prior to the at
sign is matched again after the @ sign
and not by rule but by exact match and
the exact match was a B therefore we
have to have a a B after the add sign to
include it in the match I know this can
be confusing but definitely important to
keep in mind these capturing groups
capture the thing that was matched not
the pattern so if we refer to them again
with backslash 1 for the first group
backslash 2 for the second group and so
on then we're actually referring to the
exact match and not to the pattern
thankfully because it's a bit tricky to
understand you don't need that dad often
still important to understand how it
works now to save some performance if
you know I don't care about capturing
and therefore storing this result you
can add question at the beginning of
parenthesis to say yeah everything
included in the parentheses should not
be stored should not be captured so
question mark colon here is not parsed
at par as part of the regular expression
it just changes the behavior of the
group it's now a non capturing group as
you can see here that is why our pattern
doesn't work anymore now it's just
simply matching any character and add
sign after it and it's not storing that
match which saves some performance so
you stand for groups where you know I
will never refer back to the match
another type of group we have is the
positive look-ahead
which you create by not using question
mark colon at the beginning of the
parenthesis but question mark equal sign
now what is the positive look at the
positive look ahead could be that you
say I want to treat something as a match
if it is followed by something so now if
I remove the @ sign here and the @ sign
down there and add a a in front of it
you see all these A's are matched
the bees are not included in the match
because and that's the important thing
about the look ahead the part you're
looking at so the part in the group is
not included in the match it's just part
of the matching algorithm it's saying
the match should be NEA which is
followed by the rule to find in this
group where the result of the rule is
not included in the match which is why
the Bee is not part of the match this
can be useful for validating passwords
for example in a password you might know
that you need one lower case one upper
case and a special character even though
we all know that this doesn't make a
password more secure nowadays but again
let's say this is our password
validation if that is our password
validation then the order of these
characters doesn't matter to us but by
default the order does matter in regular
expressions with look Ahead's we can say
match anything which is followed by
let's say a special character which is
followed by a lowercase character and by
combining these look Ahead's correctly
we can basically create alternatives
here where we say we need to have at
least one special character and one
lowercase character but the exact
position doesn't matter as long as our
entire string this is where we're
looking ahead includes at least one of
them anywhere inside of it we'll have a
look at password validation in the next
video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>