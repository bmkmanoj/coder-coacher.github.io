<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From SQL to MongoDB: A Side-by-Side Code Comparison | Coder Coacher - Coaching Coders</title><meta content="From SQL to MongoDB: A Side-by-Side Code Comparison - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/MongoDB/">MongoDB</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From SQL to MongoDB: A Side-by-Side Code Comparison</b></h2><h5 class="post__date">2014-11-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kDSjVTpu8kI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello this is buzz machete at MongoDB
and welcome to today's webinar entitled
transitioning from sequel to MongoDB if
your travel plans today do not include
exploring topics in this space then
please exit the aircraft immediately and
see an agent at the gate otherwise
welcome aboard our flight time today is
going to be about one hour some quick
logistics as we start here this webinar
is being recorded and the audio in the
video will be available in about 24
hours you can use the chat window at any
time for technical assistance and to ask
questions now there is a MongoDB team
that's watching that chat window they'll
try to answer quick questions as they
come up in real time as we start to see
patterns of common questions those are
going to be flagged and I'll address
those kind of in the order priority
order if you will at the very end of the
webinar we'll leave about the last ten
minutes of the presentation to answer
those common questions very briefly a
little bit about myself I didn't make up
that name for today's webinar that
actually is my real name I spent a long
time on the other side of the customer
vendor fence and here now at MongoDB I
work with customers large and small to
help them design and develop full-stack
solutions and at the risk of starting an
editor flame or so early in the
presentation yes I still use Emacs so
now let's get into the thick of it
here's really the theme for today and
that is what are people doing and what's
the time they're taking and why is it
sometimes difficult to get things done
so if you are not taking numbers and
strings and dates and applying logic to
them and presenting that to the business
community in a way where they can make a
decision and actually add business value
then you're not adding any value so the
degree to which you actually are reading
and writing data from databases putting
it on to message buses actually working
through open source integrations let's
just call those
necessary evils they're obviously very
necessary evils but you actually want to
minimize the amount of time you're
spending engaging those activities you
want those things to be as friction-free
as possible so that you can get on with
the real value work which is taking the
information and computing it and
displaying it to the to the business
community and along those lines we often
run into this sort of a frustrating
dialogue with our users with our
customers and that's because the way
that they express things like what I
just want to save a bunch of trades or
can't you make the product catalog to
handle you know yen and pounds and
dollars seamlessly but the way the the
data is expressed the information is
expressed at the business level often
pretty different for a variety of all
understandable technical reasons then at
the code level but it's traditionally
been very very different at the database
level and why is that well the problem
isn't new and we've been at this game
with our DBMS for about 40 years and I'm
not going to read through the slide here
but it's clear that in the past 40 years
our business data goals have changed
that's due to both the increase in the
pace of business globalization and
frankly just better and more exciting
technologies that are out there we do
want to release things more quickly than
our competitors
sometimes violating causality in the
process but for me especially as an up
stack solutions kind of guy it's this
third line about the applications in the
code ecosystem that's really important
because in the old days you had fairly
simple languages that were kind of well
mated to the rectangular our DBMS world
and frankly the flat file world but you
fast forward to now and you've got all
kinds of languages and environments and
the whole open source ecosystem and
these are really powerful software
environments and we haven't today really
exploited the full power of those
environments particularly with respect
integrating with persisters and
lastly you know four years ago we had
early our DBMS surprised today we still
have mature our DBMS but in the past few
years we've seen an increase in the rise
of so-called no SQL and in particular
MongoDB
now how does Mongo make things different
well at the core very important to
understand that we are a rich shaped
database we call it a document database
as well document is not to be confused
with PDFs or Microsoft Word it's not
about that it's about rich structures
it's about maps of maps of lists of maps
that eventually have int doubles dates
and strings at the leaves and because
the product is designed from its core to
be able to fluidly not just store these
things but present them in the api's and
have a query language that knows how to
understand these types it becomes
extremely powerful legacy environments
were designed with very different
languages and very different kinds of
programming environments in mind and in
particular but the whole scripting world
that we find ourselves in and it's a
powerful world is not well served by
some of the legacy technologies second
Mongo data is the schema we're going to
see a lot more examples of that as we
get into the code examples later on and
something that's important for me is
well this last bullet there is a
symmetry between the way data goes into
Mongo and the way it comes out and we're
going to see in the examples coming up
of how once you start going from a
simple persistence environment to a
successively more complicated one tree
in traditional technologies the
divergence between what it means to put
stuff in and take stuff out grows and
grows in MongoDB it remains the same
lastly no Mongo presentation is complete
without our requisite ER diagram Horror
Story truth-in-lending the diagram on
the left is more complicated than the
one on the right that's that's you know
to be fair however I will tell you this
the diagram on the Left probably started
out with four or five basic entities and
all was well and then somebody needed
something that wasn't a scalar and then
somebody needed something
where two or more kinds of things like
two kinds of products for example had to
coexist in the same sort of a shopping
cart or some sort of a portfolio a
container collection and then before you
know it those five or six entities
exploded into this thing that you see
then on the left and frankly it obscures
the fact that hidden somewhere in there
are the five or six good entities that
we want so let's actually get into the
differences here and how we transition
our thinking from sequel to Mongo using
actual code very quickly some ground
rules on this just because MongoDB is a
contemporary and exciting software
product it does not mean that we throw
out good rules of engineering so we'll
have a data access layer in between our
applications and MongoDB number two and
this is a little controversial perhaps
but in these examples we're not going to
talk about ORM I'm not going to talk
about hibernate there's actually a very
elegant annotation based product for
Java we have called morphia but I don't
want to get into any of those things
because all those frameworks carry with
them their own special set of issues and
that's an entirely different webinar to
get into what the pros and cons of those
issues are in the SDLC and the
dependency management and all that so
we're just going to and by the way
footnote most of those frameworks end up
under the covers doing exactly the same
sorts of things in code that you're
going to see today we're not going to
look at errors and exceptions please
don't cut and paste this stuff and
expect it all to work flawlessly and
lastly in terms of our date counts as we
progress through our design it's really
just a proxy for progress I don't think
I've had people come back to be say I
can code a lot more than that in three
days it's really just meant to be
granular steps as we evolve the platform
so here's how we're going to begin we're
going to start with a map we're going to
use a map as the way for us to move data
in and out of our data access layer now
why do we like maps number of reasons
first of all they're rich shapes right I
can stick a lot of things in them all
the types I'd want to put in including
other maps and lists
but perhaps most important is there's no
compile time dependency on a map so as
your per sister changes and as your
applications on top of the data access
layer change you don't have to worry
about constantly
recoding and recompiling and deploying
your data access layer this is very very
important stuff and we're going to only
have in our initial case here just two
very simple things we're going to save
and fetch we're going to get into rich
queries later on so with that is the
setup brace yourself because here is
some code now in our initial efforts on
both sides this is kind of what it would
look like and to the degree that yes in
MongoDB we are schema free and the data
is the schema I'm not required to create
a table initially when I put some of
these examples together folks said you
know no one would ever really have a
prepared statement that would be built
over and over so that should have be
handled in the initialization phase
that's a-ok but largely what's important
here is that if you look at the fetch
routines the fetch is largely the same
and what's important as a concept here
is to understand that in Mongo your
basic way of addressing the database is
actually similar to an our DBMS you
construct a query you pass it in you get
back a cursor you iterate over the
cursor it's going to be the fidelity of
the data moving out that's going to
change as we go further on in the
presentation but for the moment let's
just assume that it's it's apples to
apples we have parity now we're going to
go to day to day two in our development
we've decided that we need to add these
two fields a title and a date now you
notice the first thing we're going to do
is that we're not putting a string into
the date there's not we don't want to
have strings in our data access layer
strings are only good frankly on the GUI
you want to keep it in as the highest
fidelity object you can so I'm going to
stick in a date and we want to move this
now in and out of our data access layer
to our persister
now we have to obviously change the way
that the data access layer is going to
talk to the DB and it took me longer
frankly to describe what's going on here
then really what do we mean to change
things so bracing yourself again now
this is what our code is going to look
like in the sequel side the very first
thing that's important is the alter
table problem so before you can touch
any code that's going to go after your
new database you have to alter it
because the Select statement itself
that's going after those new fields will
not work so you were already starting to
leg into and by the way this is not new
this is just something we've become numb
to over 40 years of always being a
lockstep what learning if you will one
step behind the evolution of the schema
in order to have the code against it
work properly
now there's other things as again as a
software developer I've got a little bit
of a focus on things like case
sensitivity in terms of transfer and
such but you in general have to make
mods in a number of places in order to
get this data in and out of the database
and put it in but let's let's say that's
not really too hard but what do we have
on MongoDB on day two well nothing
changed at all that title and the date
that we put into the map we simply place
into the persister I I didn't spend any
time thinking about it I just persisted
oh really
no technical debt and the issue about
backfill this is an important thing just
because I added the fields doesn't mean
I can't go back to my old records and
add title and date but it becomes your
choice to do if you want to add it
terrific
write a little script as we'll see you
later on that iterates over the things
that do not have a title and date and
puts in a default value but the choice
is yours
let's move on to day three now now we're
getting really into the heart of it now
we're going to add some lists we're
going to add some phone numbers and
again this is going to be a list of
structures because each phone number has
got both the type and the actual number
associated with it
and
to stick this into my map in my data
access layer and I'm going to persist it
again pretty pretty easy to add now
really brace yourself I'm only going to
spend a little bit of time on this slide
because it's just plain bad but I've
seen it so many times that it warrants
you know the 45 seconds and that is off
times especially if this was day day 90
instead of day 3 there is a very strong
motivation to not do the right thing and
create a new table instead we'll just
assume people can have let's say three
phones and so you end up with yo phone
one phone two in this case we just
assume that there's one number but this
is not what you should be doing on day
three right we're we're so early on in
our design let's let's explore what
really should be happening in the sequel
world now we've done the proper approach
here and we've created a phones table
we've updated the way that we talk to it
via the joins here and let's again just
assume those are modest changes what is
not a modest change is the code that's
required to both insert and then take
the data back out in particular on the
fetch side you'll see with the yellow
warning triangle no longer as I fetch
data out is it just a straightforward
build it into the map and pass it back
and we'll see a lot more of this in just
a few slides but I now have to unwind
that result set because I'm not going to
return a big rectangle back to my users
that buttons are back to the application
I actually want to pass back a map that
says one person Buzz has a set of phones
and each one of these phones has a set
of properties not not just a big
rectangle that I have to manage through
myself make the mistake by the time you
get into this sort of work it takes time
and money and pretty much if people are
thinking well you'll hibernate for
example takes care of all this for me it
does until your fourth join trigger some
sort of horrible behavior in your
performance and you end up coding things
like this anyway so at some point you
will end up do
the sequel unwind no sooner have we
gotten through that little exercise of
editing things and the zombies appear
and currently very popular in both
literature and film but they've been
with us in information architecture for
a long time and zombies zero more
between entities what we forgot is that
some people in our contact list do not
have phones and my other query which
have the Cartesian product did not
return those people without phones so we
go back and we change the query in order
to do and outer join but as a result we
now have to go back to the unwind logic
and in particular this is actually where
the real work is now and try now to deal
with the unwind because additional
material is going to be coming in and
this took time and money hopefully
everything we're talking about here is
still in the data access layer right
because of your applications we're
talking directly to your our DBMS you'd
have a lot of impact analysis ahead of
you MongoDB a3 there's no change that
list of phone numbers actually a list of
structures with number and type flows
into MongoDB it's stored natively as a
list of structures and this second item
here is so important to understand
because you no longer have to fear
naturally-occurring lists in your data
structures and in addition of course
this kind of approach keeps you safe
from various other undead distractions
as you develop your solution couple
weeks later now it's getting a little
more complicated still we've got things
like startup apps which is a string of
different startups I notice how we're
doing it for two different geographies
so depending on whether you're in the US
or amia you may have different
applications that start up in your
solution at the bottom that very
descriptively named datum map of data
created by external source sometimes
you'll be presented with data that you
don't have control over it's just it's
vended to you you want to count
you don't necessarily want to fit you in
fact you don't have to figure anything
out just what's ever in that shape you
want to save and then later on it's part
of pulling all this back out you will
hydrate that shape and vent it back to
somebody else largely without you having
to get in the middle of any of that
knowing what we've known so far on the
passuk slides about what our journey has
looked like what do you think it's going
to look like to add this in
well truly I stopped trying to come up
with the compile time correct examples
and I just gave up because it would be
many many more lines of code and I
didn't want to work with it but here's
the important thing it's extremely
likely that by the time we got to this
people decided that startup apps wasn't
worthy of its own table and they just
did a semi colon delimited string of
things and so they're you know what's
really in your er diagram something not
only a complex set of tables but you've
probably got encoding of lists floating
around in there simply because people
ran out of time money patience or all of
the above and for security in the
absence of a way to actually store the
whole thing a subset of items in there
were taken out and stored as you know
columns a b c and b you've been
following along the theme here in
MongoDB there's no change as we
incrementally change the kinds of things
we wish to persist and and truly are
trying to adopt if you will
agile development to practice the
database and the code around it can move
simultaneously easily and without having
to resort to extraordinary measures just
to get the data on and off the database
so what if we do have to do a join so
far we've just seen our examples where
we're reading and writing out of a
single collection the sequel world did
have to join contacts and phones but as
a result of the information architecture
we were lucky frankly that we were able
to well model this in Mongo
as a single shape inside of a collection
so for grins sake let's assume that we
want to have some transactions and
although I will say as a footnote for
the highest possible performance if this
was let's say a caching or a web facing
web-scale kind of app you might actually
want to burry your phone transactions
inside the Mongo shape for each phone
number but for the purposes of
discussion today let's say it's going to
be separate and the link here is going
to be the phone number in my customer
table is going to link to one or more
transactions where that number is
calling a target so in the sequel world
we're going to end up with something
like this
and you know get again the point of this
exercise is not to figure out how I'm
going to optimize and look at indices
and other things but the point is now in
addition to linking together what it was
very clearly a one to end relationship
between the context and the phones now
we have a 1 to n to M kind of
relationship where I'm now pulling in
the targets and all the challenge here
becomes how do I turn that rectangle
that's coming back my result set
actually into a real list now those of
you who are watching this carefully will
realize that in general this kind of
approach is only going to work for two
things either I asked for a single ID or
I asked for all of the IDs the reason is
if I ask for one ID I will get back all
of the G nines and that will be fine if
I ask for all of them I'll be able to
traverse the entire result set and find
the full population of G nines but if I
were to try to iterate through this one
line at a time
I've got data essentially randomly
distributed probably insert order are
randomly distributed throughout my
result set so I would have to get a
little fancy but let's leave that caveat
off to the side we won't go line by line
through this example but this is a way
in which you might unwind that result
set where we get back the big rectangle
we're going to quickly look and by the
way this is in the case where we're
saying just get me all the IDS and their
phone numbers not not for a particular
one we see if the ID has been set up
we create a map if there is any target
numbers then we create that map finally
toward the bottom here that's the most
frequently changing datums the target
and duration columns coming out are the
ones that are actually changing over and
over again we put those into a map and
we stick it into a list by the time
we're all done we would end up with a
structure this ID map that would be
passed back in our data access layer
that looks like this
keyed first by my ID second by the phone
number and then a list of the targets
that I'm going to okay not bad now in
general people won't do that for some of
the reasons I described before and that
is you can't bail out of the cursor
early so we'll do a little order by here
now order by immediately starts to bring
into the picture performance
considerations and you had better be
sure that you're well indexed across all
of your ordering now in our example here
probably an index is entirely
appropriate on ID but sometimes it is
not and when you're putting in order
buys simply to drive the logic in your
result set unwinding that's where you
can unnecessarily impose a performance
requirement on your on your database a
performance problem on your database so
the point is in this kind of a setup you
can imagine I can iterate through things
and now jump out when I see that that ID
changes from g10 to g9 I know that I'm
done with all the g10 I can yield
control back to my caller
but still the logic that I'm doing to
build a map of lists to return to the
user is largely the same as what we saw
on the other side so in short what does
this mean in MongoDB sequel is about
disassembling things we start with a big
query upfront many columns we tie
together all the tables business logic
all kinds of material and information is
all loaded in to this big string up on
top then we throw it at the database
engine we cross our fingers somewhere
between two and two thousand or 20,000
or
forever milliseconds later a results it
comes back and then we disassemble it
and the more joins that you have in your
query the more disassembly that you're
going to have to work through and and
this is really the crux of it examples
where I say select star from employee
semicolon that's not the real world even
two table joins isn't really the real
world most of the time you're talking
about three sometimes four sometimes
more way joined in order to bring this
information together and for every
additional table that you're joining
you're incurring more disassembly logic
MongoDB the philosophy is different it's
the opposite in fact
MongoDB it's about assembly where you
put things together bit by bit so
there's first of all there's no big
sequel statement up on top and you also
don't have the problem of splitting the
logic make the mistake as that sequel
statement gets larger more and more
logic is going into the operation that
you're trying to drive into the database
engine and there's going to be more and
more logic in a separate place in
disassembling that result set and by the
way that's further complicated if you
start getting into prepared statements
and other sorts of dynamic structures
where that logic is separate from your
actual select statement that you're
building which is separate from your
result I'm going to be it's sort of
simple you just find what you want to
find you iterate through and then when
you find that you need to go deeper if
you will you simply ask for that
information and you get back these rich
shapes and you continue to populate as
we go along and the way this looks in a
join for MongoDB would look something
like this and there are two important
things but first of all this is not much
more code than what we saw before for
the sequel example in terms of unwinding
of course it benefits from the fact that
there's no sequel statement at all here
right this is the only piece of logic
that's necessary but for somebody who's
trying to come in and then debug this
or do any sorts of mods later on the way
that code is constructed is now very
logical sequential it makes sense how I
can move from maps and just get lists
out of the phones and build them
particular the second red highlighted
item here targeting duration I don't
have to pull explicitly as columns I can
simply take the entire structure and
stick it into a list and return it back
to the parent map now in the end I still
end up with the same ID map on the
bottom but I get a lot more flexibility
and a lot more clarity in terms of what
it is I'm trying to put together in this
kind of approach so so far we've seen
broad queries get everything or get one
thing all right but as we know the
hallmark of sequel is its rich querying
capability well Mongo's got that as well
but the big difference is in Mongo we
don't have a string it's not a grammar
with white spaces and commas and and
things in it it's a well constructed
operator operand set of structures
that's passed into the query engine and
what's really exciting about that is two
things first of all the same techniques
in your codes Java Python JavaScript
that you use to manipulate your data is
exactly the same way you manipulate all
the if Sven's or is not equal to greater
than etc inside of your query
expressions and by the way all of that
and we'll see this at the very end of
the presentation is the same paradigm
that all of our Diagnostics express
themselves in so again the same tips and
tricks are used uniformly across the
entire development space so let's look
at some compare and contrast examples
this is in any one of your popular
command-line interpreters for sequel
going to get some contacts and phones
that largely will yield that rectangle
we saw before in our CLI of course in
the phone's example we didn't have to do
the join so this is how we dig through
the structure and say look for the
phone's list and any structure inside
where the type equals work
earn that item that's nice and compact
if I was actually to code this in Java
well in sequel it does pretty much look
the same I will leave to another time
the subtleties of what it actually means
to dynamically create sequel and make
sure that all your single quotes are
escaped properly as you do a string
buffer append and all that because this
is actually the happy path this is the
easy case dynamically constructing rich
SQL sometimes can be fraught with peril
but at any rate as we can see the
difference between sequel and Java and
MongoDB is relatively straightforward
again the overall architecture is the
same query cursor iterate over cursor
let's get a little more complicated here
we find the contacts with one from or
somebody who's hired this is you can
I'll leave it as an exercise to the
viewers to see which our DBMS I was
going after that supports this syntax
because as you can imagine this syntax
with the date expression the date cast
doesn't work on all databases the
equivalent in Mongo is pretty
straightforward again where I have an or
operator we use dollar signs and from in
front of some of our operators for
syntactic sugar and I'm going to
evaluate these two expressions what's
important to note in our CLI is that
when I ask for a date for example I use
a real date object it's not looking for
the string and in fact if I now say what
would this look like in Java itself now
at first this looks a little complicated
right this looks a little more
complicated than sequel but it really
isn't for the following reasons first of
all it's the same kind of it's really
the same two or three lines just
repeated over and over again as I
construct a thing second of all it's
actually very powerful here to be able
to dynamically construct filters and
queries because I don't have to worry
about where I am in the predicate path I
don't have to worry about am i the first
or the second item and do I have to put
in a whitespace and a comma do I have to
do a to date on anything do I have to
put pole
the Seas into an expression although all
these things are good for when you're
typing sequel at the command-line those
very same syntactic features which are
designed for humans work against you in
programmatic construction of the query
and in MongoDB if you can sort of see
beyond this little code example here you
can see how very easy it is to add more
expressions into the or how I can call
out to another function that
independently can craft a small
filtering fragment that I can add in to
my overall query and obviously with
dates and some of the other structures I
have full fidelity of the types as well
another and I'll repeat what I said
before all of this construction of the
query the same tools that you use to
like walk the maps and debug them and
print them out all that the same things
that you've been doing with your data in
maps and lists you can do with the
queries as well that's really powerful
and lastly yes we can sort the standard
skip limit operators are on cursors in
MongoDB you don't have to get the entire
data shape back if you just wanted first
name and last name out of that contact
table post predicate you could ask for
just those fields and we do support
aggregation and in fact feeds for
another webinar but the power of the
aggregation framework with the release
of the 2-6 product is actually pretty
profound works as a pipeline you have a
lot of flexibility in terms of
manipulating data that's coming in
grouping it based on essentially an
expression not just by field names right
there's a there's a functional
expression that you can use to construct
the keys you can have multiple stages of
grouping all sorts of really exciting
features and it's all done at the engine
level optimized at the engine level
we're going to switch gears a little
here we're about halfway through the
hour we're going to talk about some some
rad you're switching to Python and the
reason we're doing that is because as we
start to explore some of these other
environments it's good to see what
the concepts are in MongoDB as opposed
to some of the core syntactic detail I'm
a detail-oriented guy which is wide open
to the Java first sometimes the
scripting environments hide things but
in this case as we move into this part
of the webinar I think it actually
exposes more so what why would we want
to do rad well because among other
things
just assuming that you will only ever
address your data with a single language
is not a good idea coming back to the
third slide in today's presentation
there's a plethora of languages there is
an even bigger there's a miasma of
frameworks that can manipulate this
stuff you have to assume now that the
rate of change of technology and drivers
and languages is go only going to
increase and you want to be able to
frankly bring the power of all these
languages together but what you want to
do is use the power of the language in
the way that makes sense for the
language so in looking at this here one
of the first things we see is that when
I construct this piece of data that I'm
going to save into MongoDB because it's
Python I don't have to worry about
making maps and making lists and
inserting and adding all that goes away
I just use the syntax of Python just to
describe it and blast it in so you can
imagine coming back to what I was saying
before you added title and higher date
you wanted to backfill it the script to
do that is about five lines worth of
code all feels native toward the bottom
here and not to be underestimated
because it's at the bottom of the page
we'll see that there's an expression now
that other pages that have the somewhat
complicated Java construction of that or
expression for among go inside of Java
here inside a Python it's a lot simpler
because I don't again have to worry
about maps and lists and construction
once I pass it in to call dot find these
functions like upper and sorted in C dot
keys that's not MongoDB that's Python so
mongos driver for Python exposes all
this rich data
in a forum most convenient to the
language that it's running in in other
words the idioms that are most important
for that language are well expressed
inside of our driver so all of the tools
and the tips and the tricks and the
third part and the all the open source
community that has functions and
capabilities that operate on all this
data are immediately available for you
to use here in conjunction with MongoDB
in other words it just works well with
the ecosystem instead of just vending
back a rectangle which yeah you can have
a rectangle and Python too but that's
not nearly as exciting and or as easy to
work with probably the most important
thing that ties all this together is
polymorphism which is our fancy term for
being able to store more than one kind
of a shape inside of one collection and
again in the scripting world this
capability clearly is available in any
language but it's easily visualized
inside of a scripting language like
Python so here what we've done is we've
got an information architecture where
name ID and personal data are well known
it's probably going to be an index on
name or ID something like that and the
field name of personal data is
well-known within our information
architecture but across different
documents the content the shape of
personal data are different and so on
the top it's referred airports and
travel time the bottom Steve is more
interested in the last account visited
and his favorite number which is a
floating point now what makes this
really useful is that you can build
applications where you're storing things
inside of Mongo millions billions of
things but you know that for the power
of indexing on a few fields two maybe
three like you know IB and date all of a
sudden you can go for index optimized
from billions to let's say hundreds you
can then bring that data back into your
application and
Nampally react to the content that you
see inside so you can build
gooeys that say inside of personal data
I see preferred preferred airports which
is a list of strings therefore I'm going
to construct a little GUI widget that
says preferred airports and got maybe
for example comma separated list of
strings for this last account visited in
k9 it will ask what is your type it will
say you are you are a map so I'll walk
the map right I'll recursively walk the
mapping builds other widgets that do
name and values you know ultimately
producing probably a popular tree kind
of idiom obviously you can build a
specific GUI that asks for very specific
parts of this content but that's again
your choice you don't have to do that
you can let the data drive the direction
here that's very very kind of powerful
thing and it's one of the reasons why
the earlier diagram I showed you with
the somewhat inflated ER diagram and
then the simplified version of MongoDB
that's why it's not so far off because
capabilities like this allow you to
rethink how you want to structure your
data
you don't need 22 extra tables to hang
on to different shapes of things we're
really at you know eight out of the
there there eight common fields and a
small number of varying fields or
frankly even a large number of varying
fields you can place it all inside of
one collection and let the data do the
talking don't really have to spend a
great deal of time on this slide because
long story short pretty much everything
you've seen over the past few slides if
you were to try and go do that and build
this kind of environment over sequel you
basically end up just building frankly
like an ORM layer on the inside
polymorphic data in sequel the current
convention is to just blob it that will
work but you lose query capability on it
you lose sometimes type fidelity
information on it meaning if you store a
floating-point number whatever
your representation is in that blob
you'd better be sure that all the
versions of Java c-sharp JavaScript and
Python and Perl that when you pull that
number back out you get the same
floating-point number when you put in a
date into your blob you get back a date
time accurate to Millie's in all of your
languages right these are very important
considerations if you want to focus on
working with your data and not wasting
time trying to build adapters and
conformance layers to ensure that the
data is properly serialized and
deserialized in this blob area so in
summary what what changed you got to
really look back and this is why we
started a bit with the history here in
the old days CPU and disk was not what
it is today memory in particular was
very expensive and there's a lot in
MongoDB visa vie performance that is
enhanced by its ability to aggressively
use memory we're a distributed database
we'll touch upon this in just a little
bit and so we'd have to worry about that
meal there's there were no distributed
things and again I'm an upstanding guy
so the languages and the types and the
things that you could do you know there
was no malloc right in the old days you
didn't just a new object everything was
compiled time bound in the year 2014
right fourteen years into this century
we have a lot more flexibility we have a
lot more power in our fingertips I can't
really blame the environments of old for
doing what they had to do because that's
kind of how they got by but in MongoDB
when the data is the schema there's a
lot of power that is brought to the
table now what does that mean a little
more broadly you can now start to do
things like this so everybody has
suffered through the pain of saying how
do i do reconciliation or maybe like
version delta on a thing whether it be a
trade or a product or a leg or a catalog
entry or a recipe it doesn't matter
you
armed implements unless you're in a
single table world and that's
essentially never then you've got a
problem you can do one of two things you
can build a piece of software that will
hydrate your AR DBMS world into an
object then hydrate another object and
do an object to object compare if you're
lucky the people doing all that stuff
will have implemented comparable
comparable I guess and maybe you can
iterate through the results that way but
it's still it's a bit of work if you do
it at the database level by dumping
tables and getting rows of things and
emitting CSVs you are setting yourself
up for just a world of pain we all live
this pain every single day we've just
grown accustomed to it but it's not
necessarily the way you'd want to do it
this example on top this is how you
would do it in MongoDB if you used
substitute collection for some of the
things that we saw in Python with Steve
and Jane I think it was where we had
preferred airports and last account
visited I can generically ask for an
entire set of data lock that data and
then say this record has got this field
this one has another field I can say
this record has got a date which is of
type date this guy has a date of type
integer
I can flag that the work here goes into
the map de futile which by the way is
not there's also you can Google guavas
got one of those as well we happen to
have one here as well I but that's all
you have to do all of a sudden this
problem of understanding differences in
your data becomes very easy because now
you're letting the data do the talking
ah another use case that comes up very
often is how do you how do you pull
together things sets of data and
continually add overrides so you've got
your your baseline let's say preferences
for a community and then when somebody
logs in there's a company level and then
a group level then the personal users
preferences you want to be able to
overlay these things
and traditionally overlaying anything in
the our DBMS world is really tough and
largely you just pull things out into
bespoke objects and try and do it that
way with MongoDB it's very very easy
just to grab the shape out now that it's
expressed as a map continue to stack it
at the very end say if I do a top-down
look of my data what is the full map
look like overrides and all I could even
ask it at any point what call to what
record document precipitated a change in
a particular value you get all that kind
of flexibility because you're in the
rich map ecosystem you're not just
dealing in the resultset world of
instable dates and strings in a code
framework that's heavily geared toward
the database not geared toward the
structures and objects that are natively
and fluidly manipulated inside the host
language lastly want to spend just a
couple minutes on the CLI CL is are
always good to talk about there are a
number of visual environments for
MongoDB but here it's what's important
to know that in Mongo our CLI is
actually just the node v8 JavaScript
interpreter that itself loads the
JavaScript library for MongoDB plus a
few extra syntactic add-ons in other
words our CLI you can program javascript
in it all day long and ever even touch
MongoDB this is an inversion from is qmp
SQL and some of the other CL is that
essentially are just operating in the
sequel space and so using this kind of
power instead of the traditional perl
and bash and some scripts and this and
that there's a whole host of extremely
powerful native applications that you
can write or utilities really in
JavaScript that fluidly manipulate all
kinds of things in addition to
manipulating MongoDB it's all native and
in particular you can see here one of
the things
sort of ties it all together we are
asking for contacts or some sequence
numbers greater than 10,000 but then we
invoke the explained method to get back
information from the engine on how long
it took etcetera the number your number
of items at scan I can easily put that
into a loop and then here pushed on to a
vector V and we're looking at this
vector of tuples
that's not MongoDB that's just
JavaScript inside the CLI because it's
does a JavaScript interpreter I took the
j stat package off the net
I can run standard deviations or
anything else I want then lastly sort of
as the party trick I can not only take
these things as they are emitted as rich
shapes I can turn right around and
insert them back in so I for example
could adapt this to have a while loop
around it and I could sleep for 60
seconds or any amount of time and
continuously what a little script that
runs all day long like this and see what
the timings were for a particular kind
of query against my database take the
results put it back into the database
which is now available for full fidelity
querying simple easy efficient in
summary so what is this all add up to I
believe that once you get out of the the
trivial cases it's actually easier to
use MongoDB to interact with your data
than our DBMS for some of your bigger
problems not saying that MongoDB solves
every problem but beyond some of just
the trivial cases it harmonizes much
much better with modern programming
languages and ecosystems when you take
that and then you add in a lot of the
things that we didn't talk about today
because today was more about sequel in
the the software interface stack and not
sort of the infrastructure having a full
suite of robust indexing capabilities
plus the horizontal scale story and
actually what is a very exciting
integrated a really nice amorphic H a
and D are kind of strategy it really
adds up to mock MongoDB
in modern database for some modern
solutions and with that we're going to
now go to the the QA portion of the
webinar and you'll just go to question
seven okay our one question okay okay so
there are about seven or eight I'll say
common questions I'm going to try to
address them in order the first is don't
you still have to marshal the data from
the a player into the document before
you can write it to the DB the answer is
yes of course in our examples about a
third of the way in when I was
constructing in my day two and day three
examples that map of data where I was
adding title and higher date that's what
the application would be writing the
application may have bespoke objects you
know class contact class organization
these sort of things with rich getters
and setters but at the point where
they're going to go persist some util in
between is going to say I'm going to go
after that class extract these things
and load the data only portion not
compile time bound portion of the data
into the map and pass that into the data
access later for persistence ah and that
is similar to there's a second question
which is a follow-on to that but it it
means the question is there's no need to
alter tables but marshaling and on
marshalling is similar and the answer is
from the application layer into a map
it is similar but from the map into the
database first of all the richness of
expression means that you don't have to
worry about creating auxilary tables for
one to n relationships but also you're
not bound to always do alter table
before you make those changes into these
genes inseams okay
good crap great question here assuming
you accumulate data in version one
entities change more fields mandatory
how do you migrate the data in version
structure one diversion structure too so
what's great is there's
approach to this called soft versioning
and I'll I'll just say imagine that some
of those shapes that we saw going in and
out of Mongo had a version an integer
just V doesn't matter the the version
number is not about like whether it was
canceled corrected or that sort of thing
the version number is an explicit piece
of information architecture that defines
not only the shape but the business
intent of the shape and if you start
with an information architecture that
day one says I'm calling this thing v1
then your data access layer can
interrogate it and based on all the
things that are flying back and forth
they can say hey you know I used to have
higher date as or let's say termination
date as a single date but now there's a
list of them and my applications now
need to respond to a list you can
clearly identify the the origin of that
data by saying the ones ahead of as a
scalar or v1 the ones that have it as a
list or v2 then it's easy in your data
access layer simply to say what is the
version of the thing if your v2 I'm
going to ask a different question of
that map and then project it up to the
application in a different way it's more
in summary it's more of an information
architecture issue and a coding issue
rather than a database issue the next
question we have here is doing a similar
phone okay so why is this more ahead a
good question why is this more
advantageous than doing a select fall by
another select or than by doing a join
the the answer is well you could do it
that way but you're going to run into a
couple of problems first of all you have
to do those sort of nested selects for
everything that ends up being non-scalar
so in our example where we saw contacts
and phone numbers they're always going
to be a very high percentage of
information architecture models where it
is truly 1 to n where the NR bound
solely to the parent right there are
some counter examples like accounts and
transactions probably keep us to two
separate collections and you do
want to join them but for those things
that you don't have to or don't want to
join in MongoDB you don't have to so
again it's all about options ah let's
see is it doing this at altar so there's
another question don't have to do a
collection drop and then an insert to
alter any document no to alter a
document to update it if you will you
can update in place so I can write a
loop that says find things based on an
update predicate then for everything
that's found I can either replace and/or
overlay specific fields inside that
document so you do not have to do
certainly don't have to drop nor is it
an insert or even an absurd kind of
capability it is in place update that
can take place next question is I just
delivered an application to an agency
with no impedance between MongoDB back
enclosure middle tier in JavaScript okay
that's good
any change on the oh that this this is
not a question it is a it is a statement
but it it's worth repeating because it's
complimentary so thank you mister
actually I don't have my own way of
initials the statement was any chain now
it's been clicked off okay
so we'll move on to our next question in
the example if the history and the
transaction list is big it will be a
problem since 16k is the limit for
singles okay so two things the the limit
for any particular document in MongoDB
is 16 megabytes and perhaps I went
through that part of the example little
too quickly the phone transactions list
is it's a collection with separate phone
transactions it's not one document with
a lot of transactions in it
there's millions or billions of those
number target and duration tuples
sitting in there so it's not subject to
that limit at all
next question is can you extend Mongo by
adding new types I so currently that's a
great question especially with the Geo
stuff some people have asked us to
expose more of the geospatial indexing
and the geo hash algorithms so they can
do more than two-dimensional indexing on
numerix currently we're looking at
providing a facility for injecting new
kinds of types into MongoDB looking at
it on the roadmap the challenge in this
is not some is not so much the
bivouacking if you will just the the
bytes eerily or the bit serialization of
these types it's the way they work with
the predicate and the aggregation engine
at the end of the day you want all of
your types to have some sort of a
reasonable ability to deal with beyond
just equals and not equals to deal with
greater than and less than and all sorts
of things you need sometimes ways to
promote or demote from one type to the
next this is a little more obvious for
example like the big decimal to double
to integer realm but the same extends to
other types as well and I guess we've
got time for one more question
uh which is okay that's a long question
all right well I'm going to go for the
shorter question because we're just
about coming up on the top of the hour
and that is a MongoDB can you store byte
array data the answer is yes byte
bracket bracket is absolutely a
supported type used very popularly in a
lot of our use cases to store both what
I consider to be unstructured data and
ironically PDFs and the Microsoft Word
documents or anything images video
whatever you like in the byte array and
then using as its peers other kinds of
rich shapes and structures to define the
metadata around it which you can then
index and then you can bring back the
byte array into your application alright
with that we're really coming up on the
top of the hour so with that I'll close
by saying thank you very much for your
attendance today and for the good
questions if you have any further
questions you can email me at the
address you see there or you can reach
out to somebody else at MongoDB I hope
the material you've seen here today is
provided a little bit of insight
and maybe jog your thoughts on what it
means to move from your traditional
worlds into MongoDB and how it's it's
really less scary and I think a lot more
capable than you might have otherwise
envisioned and so with that be well code
well and thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>