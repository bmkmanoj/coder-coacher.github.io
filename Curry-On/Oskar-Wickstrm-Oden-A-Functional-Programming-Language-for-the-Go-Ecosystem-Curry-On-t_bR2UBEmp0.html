<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Oskar Wickström -   Oden - A Functional Programming Language for the Go Ecosystem - Curry On | Coder Coacher - Coaching Coders</title><meta content="Oskar Wickström -   Oden - A Functional Programming Language for the Go Ecosystem - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Oskar Wickström -   Oden - A Functional Programming Language for the Go Ecosystem - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t_bR2UBEmp0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ready
hello can you hear me yeah good okay
welcome to my talk Odin a functional
programming language for the go
ecosystem so my name is Oscar Wickstrom
I'm from malmö in Sweden I worked there
and I lived there and since November
last year I've been working on this
project on my spare time so nights and
weekends and this is a very young
experiment so thing so you should not
use this in production tonight or not
tomorrow either well first off I just
want to thank my employer for making
this trip possible and today we will
look at the agenda or sorry had the
background of this project why I started
it the specific goals for this project
and like the motivation and we will look
a bit at the current state and what's
coming up next perhaps and probably we
will have some time for questions I
think so starting with the background
and I've been thinking about some things
that's a couple of years and I just want
to throw them at you so so you get a
sense of like where I'm at and here are
those thoughts in no real particular
order so I want typesafe functional
programming for writing web applications
and servers because that's mostly what I
do and well Haskell is perhaps an option
perhaps my my like favorite option right
now and I don't really get along with
Scala I shouldn't say too much about
that controversial perhaps I think it's
too complex and then there's languages
like rust perhaps not that mature in web
app development and also not like the
abstraction level
I'm looking for and and of course
there's like Java 8 with the Oryx or
streams and stuff and that's I guess
that's okay but it still hurts when you
have to work with data and that is
something that I do and I think that's
something you do as well so I'm kind of
conflicted where to go here so I think
Haskell is a great language in any case
and maybe it's the answer here maybe I
should just like focus on high school
learn the web application stuff for high
school and and help that community grow
and then like there's this yes odd
framework seems promising I haven't
learned it yet so though I think Haskell
has some like pain points for for
writing production software as well it's
it's to me it feels still like
researching if even if you can do like
crap pragmatic stuff sorry and the
tooling is as a bit messy still there's
this project called stack which improves
things greatly but there's more to do
there I guess and the flexibility of
Haskell might be a pain point as well
because you have all these language
pragmas and things like template Haskell
you don't have to use that but it's
there and people are using it so I think
there's a lot of complexity and it's
like Haskell it is a bit too big in
terms of features and and cool stuff
which which may be less pragmatical and
more like researching so could you have
like the safety of Haskell but but in a
simpler language so I'd like to have
less decisions which why which of the
hundred language pregnancy I have to use
and so on I don't I want like a concise
standard instead I don't want you to
debate with every person how I should
attempt to my source code
and in this regard I think the goal
language is doing very well they have
like a kind of strong consensus on the
conventions of writing writing their
code and and how it should work ok I
want fast like clean slate compilation
as an option and what do I mean by this
so first off I should say I I really
love doing rebel programming like
interactive programming and I work with
the closure mostly in my day time so
there's this thing I feel like I'm
forced to use the rebel enclosure
because it's impractical to be on the
command line and run line compile all
the time because it takes too much time
so I'm kind of forced into this
interactive development flow and it's
good to be able to do interactive stuff
but I end up having like strange errors
in rebel and you know it's like I have
this state in my compilation that can
live for four hours or a complete work
day and then I end up restarting the
rebel and nothing compiles anymore
because I had some kind of order state
which has changed or renamed definition
somewhere that's like a source of
complexity that I I'm having a hard time
to trust the workflow kind of so I want
to have the option to to go out and do a
fast clean slate compile as well I'm not
saying we shouldn't use ripples and this
is a biggie for me I think we should
optimize for a writing code that is
correct understandable and safe to
change so I don't like hunting down like
silly programming errors in runtime and
I want other people to be able to
understand the code that that I right
and that others right and I'm going to
talk a bit more about that later and
like ideally changing existing code
should be should feel as safe as writing
you
I think and that probably is an ideal
anyway now and when it comes to do the
aspects of correctness and safety I
think Haskell is doing very well and and
something to strive for and we should
not optimized for cleverness so I think
like writing dense code one-liners and
such they may be very good for your ego
but not so good to maintain for for a
project also like hiding essentials in
code there's I'm thinking of having
implicit stuff or like magical monkey
patching things in in Ruby or whatever
and it's like a trade-off you I think we
should have abstractions for things that
are not essential and we should like
emphasize the things that are essential
and that's what abstraction is all about
I think and another thing on this
subject is macros so there's this
argument that that closure or lisps are
easier to learn because there are very
few like building forms and you have to
learn like 10 or 15 things and and
you're done and you can read all
programs and I kind of disagree because
i think these languages has a lot of
syntax but it isn't defined in the
reader or in the core language it's
defined in terms of macros in lubbers
and everywhere so it still has a lot of
syntax but you have to learn it some
other way okay jumping back to the type
safe web application stuff maybe I
should do like Tata static typing on top
of JavaScript inset so I've been
thinking with this language called pure
script which is really cool and you can
run that on no GS that's so that's an
option and then there's things like
typescript or flow more like an external
type checker things
but all these tools require some kind of
fi bindings and or some kind of
annotation saying that like this
JavaScript function doesn't a native
function or foreign function has this
type or works this way you have to
create an explicit adapter of some kind
so having to write these fi bindings and
adapters is quite cumbersome and makes a
new language take time to adopt and make
it usable so I won't like the compiler
to do this for us instead so if we
compile to your language that already
has a static static type system and
maybe we can query that type system and
let the compiler do this work for us
instead generating wrappers and stuff so
also can we reuse on the dot subject can
we reuse the good stuff from a language
like go which has this static type
system but instead use a functional
language and there seems to be a lot of
people arrive and go libraries tools
whatnot maybe all of them don't want to
convert to Haskell I don't know I don't
think so they seem to like it there and
I'm wondering like can I can I some way
we use the good stuff the run time and
so on but in a functional language
instead and I think I can and we can so
this is not like the official slogan for
this project or anything but I try to be
positive but but with this conclusion i
started working on this project called
Odin so first I'm going to talk about
why and go in this case so it has a
growing ecosystem lots of libraries and
tools it has support forum process
concurrency with like lightweight Fred's
called go routines and they have
channels for communicating between these
go routines cross compilation is easy
Ingo you can compile for windows on your
mac and so on
and it's easy to do static linking which
is nice for deploying server so I think
also the specification for go is quite
small it's a simple language and the
compiler is very fast at compiling girl
code so in this case we can you can use
translation to go source code and it
works reasonably fast anyway even if we
have like two compilation steps so there
are some drawbacks with go as well the
first thing is expressions over
statements I like having expressions not
statements with side effects so I want
like it if switch for end zone to be
expressions and that also includes the
go has this keyword called go like the
slogan thing I guess and that's used for
spawning a new goroutine at a function
call so it doesn't return anything
useful I think it could generic
programming this is a kind of overloaded
term and kind of controversial in the
NGO community I guess they're talking
about the generics a lot so go has no
like parametric polymorphism you can't
write type safe generic functions like
map filter and so on every every one of
those and on the same theme you can't
write a polymorphic type save data
structure like your own sordid set or
something like that and the NGO
community seem to to have settle at
templates and Cody a narration which are
kind of crude tools abstraction I think
is missing from go as well I'd like to
have something like a monadic maybe type
instead of doing Neil Czechs everywhere
also error handling in Ingo error
handling is explicit it's they don't
have they have a panic feature but
mostly you're returning error values and
checking them manually
so in a sense that's good I think having
errors as values but and the checking is
very tedious and easy to do in true
service with so if we look at this code
I don't expect you to see everything it
doesn't matter actually and this is a
function I wrote a couple of years ago
I'm not going to win any prizes with
this function but I think it's like a
standard go program function idiomatic
code and this is what most go could go
looks like that I've seen at least so
what I want to focus on is this part so
the the stuff that I kind of dim doubt
is error handling boilerplate and the
other stuff is what I care about
basically so the gray stuff it's this
thing all over over over and over and
over again it's just checking if the
last thing returned an error and in that
case early exit with that ever so I
would argue this is quite error-prone
having to do this every after in between
every every operation and quite boring
as well so when I wrote this talk I
found another issue with the previous
code sample this red part so i don't
know if you see it already but there's
this error check actually doesn't check
anything that hasn't been checked before
and it's an error that i made so it's
totally harmless it doesn't do anything
bad but i missed this and actually the
IO copy operation from before returns an
error which I didn't know and I didn't
get me a warning and so on and then I
wrote this our check because I was kind
of I guess I was in like a mode that I
have to write an error check in between
everything I do regardless so all the
noise kind of made me miss this so the
goals for Odin them
first off I want to use go as a platform
basically because like like David said
in the keynote this morning that the
closure isn't an island it builds on top
of the JVM and on JavaScript I really
like to do the same thing because let's
be honest if if I'm doing this myself I
don't have the time to do like the whole
stack so it it's more reasonable to
build on top of go and this is
comparable to scala for the JVM more
elixir for for darling i guess and avoid
cleverness and prefer clarity so maybe a
bit fluffy but i'm like happy to write
an extra line of code if it even makes
it more clear what the program is doing
expressions of our statements this was
where i talked about earlier with if
switch and go and so on support generic
programming so this is like the holy
grail of go debates i guess so i don't
think copy pasting code and changing the
types for every instance is a good way
to program and I don't think writing the
same for loops every time you have to do
a filter is a good good way either and I
think it's harder to understand that
code in the end when when it's written
as well because I've heard the opposite
opinion on this quite a lot but I think
it's harder to look at the for loop and
then you have to like abstract that when
you're reading it and think yeah okay
it's a map or is a filter or some kind
of fold and the abstraction isn't there
and you have to map it all the time so
also I think we can do better than
templates in code generation in the like
external tool just writing go code and
kind of way
also support good abstractions so this
is to reduce the risk of making errors
you can use like proven tested code that
works and make it possible to abstract
things like boilerplate stuff like Anil
checking or error handling that we saw
before type inference I want like the
top level types to be perhaps be
required or at least encouraged like a
warning if you don't have a top-level
thought signature and I'm gonna say I
have cheated a bit in my code samples
later on so I'm not dogfooding this yet
anyway the rest of the type should be
able to be inferred by the compiler and
inside the function bodies and so on but
you should of course be able to
explicitly type annotate something if
you want so this is like the Haskell
approach also i think immutability by
default in data structures is a like a
clear clear win I haven't done any work
on this yet but yeah it's a very big
area so we'll see but go is like pitched
for writing concurrent applications with
the thousands or millions of goroutines
I think having immutable data structures
is a clear win in that case pattern
matching I'll be like to have that as a
preferred way of doing a control flow
instead of just having ifs and related
to that is exhausting miss checking see
that you have matched all your cases
also I like to have this is like the key
one of the key features of this project
is to have a simple interoperability
with go so this is the FFI bindings I
talked about before you should just be
able to use go code and it
you shouldn't have to write the adapters
for everything and I think it can work
and I've done some work here so i'll
show you later but being able to to just
build on top of say you want to ride a
HTTP server or whatever you don't have
to first wrap it or find someone on the
internet that has done wrapping because
no one has right now i also want this
programming language to be fun so it
should be easy for for newcomers to get
started with this and have it like a low
threshold for get going open source from
the beginning this is kind of scary so I
I published this quite early and
basically the first version I got
something working in and eventually it
landed on on hacker news and read it and
you know the rage began so that's scary
anyway the good part of having it open
source from the beginning and ending up
on hacker news I guess it is getting the
critique and the feedback and I think
just if I shut myself in for like three
years and write this with what I know I
don't think the result is going to be
really good so even if it's hard I like
having some kind of feedback so come
come pick at me and and tear it apart
and we will find something better also I
think yeah it generated generally it
will be better if a group of people
write this so this is the MVP pyramid
it's called this is a thing that I like
to try on this project I'm not sure
about like compiler projects how they're
usually done but i'm i'm pretty sure
people don't use the the MVP model that
often perhaps it's starting to move that
way if you look at like Elm they have
seemed to do a lot of work on the user
experience
so on but what you see here the blue
slice is how you like prioritize your
features and at the amount of work you
do on a given feature so you make it
work of course but also make it like
usable and create this kind of emotional
layer on top and this is basically the
the Hello Kitty part of the
implementation I guess having the nice
logo and nice design stuff I think it's
fun to work with as well so I'm I don't
mind doing that and I think it makes it
easier to approach for for beginners and
for newcomers so this is kind of my
strategy and it affects it should affect
all all the parts of the projects not
only the syntax and the language but
also like the website documentation
command line tools and error messages
and everything so we looked at the goals
and background for this project and so
my focus so far has been mostly on the
on the stuff of like the highest
uncertainty things yeah well the type
system and the basics that just has to
be there so there's a lot of stuff not
done yet very early and yeah the first
compiler was written in racket actually
using mini can run for the type system
and that worked very well it was a great
great way to start and I got something
working very very fast and later I
actually rewrote the compiler in high
school instead because I wanted kind of
more safety when doing like the
refactorings usually the significant
refactorings touch all files and it's
like total chaos and two weeks later I'm
out on the other side and stuff works so
I like the support of Haskell in that
case and also writing compilers and
Haskell is kind of neat
anyway let's look at the current state
of Odom some of the features I'm just
going to highlight some some parts
because I don't have time to show you
everything the first example of the
world of course this is the main package
with the main function taking no
argument and printing hello world which
returns the unit type so i could mention
here as well Odin has no explicit like
effect system or something you can do
side effects I'm not sure about the
design there I'm kind of crunching
different approaches to to perhaps
encoding effects in the type system I'm
not sure about that yet and these are
the built-in in fixham prefix operators
look kind of standard I can go I guess
the main difference here is that these
are just syntactic sugar on top of
something called protocol methods and
I'm gonna explain what protocols and
these methods are later but with the
support Odin has and gets support for
operator overloading so here's the like
the translation rules for which operator
becomes which protocol and method to
call we don't have to go through all
these just wanted to show you and then
there's no custom custom operators right
now you can't define like the hash
rocket or fishbone whatever I actually
think there shouldn't be a way to do
this because it feels like it encourages
the cleverness things rather than being
pragmatic so what you can do right now
is overload the built-in over
overload the building operators there's
no macros right now at least I try to
keep the language as simple as possible
and my I'm kind of striving to not have
macros because I'm not really sure that
I won't have them in basically I want
you to make it possible to do
abstractions on top of monads and
applicative rather than having arbitrary
meta programming constructs we'll see
how that works out but i think it's
simpler and you might have to to write
like an extra line of code with this but
i think it's worth it so Odin has curd
functions both the Odin functions you
write in Odin and functions from go get
curried automatically so in this example
I explain it quickly the plus function
takes two values and yeah you can see
what it does the twice function take a
function f and some value X and applies
the function twice the plus 20 is a like
a composition of the plus and twice
function and so we apply + 210 and get
another function back because we only
applied one value and then we apply that
to the twice to that result and we get
another function back and on the last
line we apply the resulting function
with the value 20 and we get for you
because we yeah the + 20 it does edition
with 20 so just to illustrate this we
can add some type signatures then it
looks like this and we can see a bit
more clearly what's going on here the
twice function is polymorphic see the
for all keyword keyword is used to to
introduce type variables in a signature
and also the plus function is here is
less general then it has to be it is
restricted to only work on integers in
this case but
and the infotype is actually more
general you can import packages from go
and here we see a program that imports
the HTML package from go and use it the
escape string function to print simon
and garfunkel in HTML safe code and the
the automatic import thing from go is
kind of restricted right now it's only
simple functions with simple types that
work so this is supposed to be improved
later on it put some restrictions and
some demands on the Odin type system to
be able to make that mapping but I think
it should work so I did some hacking on
the flight here so this code might look
like this in a couple of days instead
and that's because of the goal the ghost
specifications that's not nothing about
package import paths it's totally
implementation-specific so that's the
reason for it being a string here I've
implemented a basic version of records
and these are pretty much like Elm and
pure script records so there's some
stuff left to do here but I think it's
promising so here we define two values
Sweden and you say the type of these
records look like this and we can create
functions taking records record
arguments and accessing their fields as
you would expect and so you see here not
like in Haskell where where the labels
are functions but here instead their
access with the dot syntax so if we look
at the type signature from this function
taking a record we get this this is the
inferred type of the function and
inferred by the compiler and we see here
that
we receive a record and we have this
polymorphic type variable called R and
this is used to to enable something
called row polymorphism and essentially
it means we take a record that has at
least first name and last name fields
and possibly more fields so the function
is polymorphic in the sense that the
record shape can vary and this this is
actually this came naturally from having
type inference and records I found this
way of having a nice interaction between
the type inference or end and the
Wreckers so this is the same as in in
pure script but more more naive right
now and then there's this thing called
protocols which I started talking about
earlier so the spoiler here is that
these are like type classes in high
school here there's nothing new here and
they're not like protocols in say
closure they're like type classes but I
wanted to pick another name for it not
just to be cool and have my own name but
I got kind of confused with the name tag
classes when I started looking at at
Haskell so this is a quite recent
addition and it's super limited right
now but it works kind of like this you
can implement some some protocol for
some type so here we implement two
built-in monoid protocol for records
records representing points in like a 2d
space so we say implement Mon art for
this record type with x and y in fields
and then there's two methods in this
protocol that we have to implement the
apply and identity methods and when we
have that we can create two values of
this type and we can apply the method on
those values so here we apply mono apply
on
and distance but as the operators rd
sugaring into protocol methods we can
also write it like this and well yeah
these two are equivalent so plus plus
will become that and so this is how you
get like the operator of loading for for
user-defined types so on so this
protocols feature maybe isn't that
simple I've been talking about simple
languages and not having like complexity
striving to have a less complex language
and I think this is the most complex
feature right now and yeah I guess type
classes has gets this critique as well
in high school it's quite complex to do
to see which which implementation does
the compiler choose and so on and maybe
I should explain as well the
implementation The Dispatch in this case
is done at compile time not at runtime
however i think the protocols feature or
like the top classes in Haskell is a
very nice way of doing operator
overloading or functional or overloading
so it's like the lesser of Evil's I
guess so this was some of the features
of Vodun right now and there's more so
if you want to look at this you can find
some more information at the different
places have the site up at Odin that
Odin Lang org there's development blog
about page with some information about
the project there's links to various
other things like the user guide looks
like this and this is something I've
been working a lot on on my vacation I
was here in Italy actually with a glass
of wine writing documentation that was
nice so
here I try to to put focus on on the
like user experience having a nice
documentation easy easy to get going
with so the many of the programs there
are complete programs in this
documentation can be run directly in the
browser if you want to try them and also
the user guide is available as different
formats and ebook stuff and so on and
the the ability to run the programs is
backed by this site called the
playground at playground online dot org
and here you can like tinker with
programs and run them in your browser if
you like so this is a nice way to just
try this out you can follow online on
twitter if you like here's the handle so
what's next in this project it's an
experiment it's very young I'm doing
this myself right now and there's a lot
of stuff left to do building a language
is yeah crazy so I'm kind of at the
stage where I try to evaluate this and
see if people find it useful if it's if
it's just for me or if this is something
that should be built so I really like to
hear what you think you can ask
questions very soon and come talk to me
afterwards as well and bring all the
stuff so that's it thank
questions anyone man hi thank you for
the talk I was wondering you chose go as
the platform to build this on and while
it is early in the project you might not
have a thorough answer on this I'm
wondering what you feel the biggest
hurdles to cross have been in since
you've chosen gold like halves goal as a
platform obstructed you in some way that
you felt like maybe wouldn't happen some
other platform I don't know yeah good
question and I don't have like a super
good answer i think so there was well i
did this monomorphic mon amour physician
face in the compiler where where every
instance of a polymorphic function is
like instantiated to the monomorphic
version and then there's compiled out to
to that form because that's not like a
bad thing with go having too to do that
but it was kind of hard but it doesn't
see it I don't see it like a hurdle
really yeah if I can come up with
something else I I'll talk to you have
to first yeah thank you so it's curious
what is your completion model do you
compile to the transpile to go coder do
you compile to action like do you have
an alternative fronting yeah so I
transport to go so scored because I
tried to find like a specification on on
calling conventions and so on maybe
didn't like compile through llvm or
something else and hook into go but I
didn't find anything useful there and
just getting something working and
getting in hooking through lamp runtime
the translation was the way forward yeah
thank you
hi how're you going to use the girl who
deems your language yeah I haven't like
found a very good design like a final
design yet but I like there's this thing
called core async foreclosure which kind
of does the same thing as goroutine
channel so basically i'm thinking like
steel that straight up and yeah last
question thank you for your talk my
question is how do you handle compiler
errors so what if for the compiler thing
when compiled it's compiled by go it has
some errors there and do you have some
source mapping or something that tells
you where it was this thing in your in
the quote yeah so compile-time errors
basically Odin has to catch everything
so all the things that would cause a
couple time error Ingo has to be cashed
at caught it at the Odin compilation
face and then there's a runtime errors
which with the where the source mapping
becomes essential so there is this you
can like output small comments called
compiler directives in Ingo source code
which tells the go compiler to treat it
as the file and lie number that you say
so I did some work out putting those
comments and when you like debug Odin
program which is compiled for go in in
gdb you get to open source information
okay let's thank the speaker thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>