<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>James Noble - Notes on Post-Post-Modern-Modern Programming - Curry On | Coder Coacher - Coaching Coders</title><meta content="James Noble - Notes on Post-Post-Modern-Modern Programming - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>James Noble - Notes on Post-Post-Modern-Modern Programming - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a5Q7td6t-iw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">performing this talk there won't
actually be time for questions but I'm
here for the rest of the week must once
again come to know and comprehend the
composite character of a program both as
an entity and in terms of its various
parts 1968 the NATO conference on
software engineering that's Doug McElroy
from AT&amp;amp;T Bell Labs sitting up and the
American at the front of the room
telling the Europeans what's to do and
that's extra dry extra there the
European listening in and being really
really keen and what did he said he says
the general admission of the existence
of the software failure in this group of
people is the most refreshing experience
I've had in a number of years do I
mention this was 1968 there are two ways
to live two ways to live there are only
two ways to make a system you have to
make it so complex that there are no
obvious deficiencies where we make it so
simple that there are no obvious
deficiencies the first point of this
talk is that these things didn't happen
by accident these things are part of for
one of a better word and underlying
philosophical idea called modernism and
it's a movement in art and literature
and architecture and science and
technology that in some ways began even
right back in the Enlightenment in
philosophy and then worked its through
to architecture in the late 19th century
and we might talk about modernity is the
condition of society resulting from
modernism where everybody lived in
buildings that look like that or cities
that look like this and Luca Boucher
says the plan is the generator without a
plan you have a lack of order and
willfulness the plan holds itself the
essence of sensation the
problems of tomorrow dictated by
collective necessities put the question
of plan in a new form modern life depend
demands and is waiting for a new kind of
plan both for the house and for the city
my colleague Robert Bibles University
Niklaus Viet says software engineering
program construction consists of a
secret of refinement steps in each step
a given task is broken up into a number
of subtasks each refinement implies a
number of design decisions among these
criteria efficiency storage economy
clarity and regularity of structure so
English researchers characterized what's
going on like this with four ISM Fordism
has four basic principles you know what
Fordism is it's the philosophy of Henry
Ford standardized products repeated
tasks having the potential for
automation an automated tasks analyzed
using work study methods known as
Taylorism where you measure the
performance of something and then you
use that information to feedback and
improve the procedure and production
lines with work moving to the workers
analysis design programming testing
darlin my god I have to make I have to
mention them have to mention but where
are we well we've got a whole world of
programs we've had 50 years of soffit
probably 65 70 years of software since I
first gave this talk 30 years 40 years
of software engineering and software's
everywhere I flew here from New Zealand
into very large planes that were not I
did say these slides came straight from
the early 2009 planes that you know
we're designed by software were built by
software and those planes were basically
flown by software if the software
stopped working with the ATM I wouldn't
be able to pay for my dinner yesterday
or call anybody or you know even the
lights in this lecture theater if the
software controlling the electric grid
failed we'll all be in the dark why is
this important well in 1968 if you go
back and read the original NATO report
that was the criteria by which computer
science software engineering programming
would have succeeded that we would have
succeeded if you could pilot an airliner
across the Atlantic Ocean or you could
operate a nuclear power plant but today
ladies and gentlemen today you couldn't
imagine doing either of those things
without software
so let's consider the most important
tasks in programming the task intuit
structure computer to print a table of
the first thousand prime numbers to
being considered the first prime number
how do we do this
when we're not writing the first program
in the world okay it's easy we've got a
component source was there was two
thousand right we'll go there okay and
so you see what I've got um actually you
could do what some of my students
clearly do when asked to do a
programming assignment or you could do
what everybody in this room actually
does
so the question in that sense is what's
going on what's left for programming and
for computer science when everything
that we wanted and everything that we
believed in has already been done this
situation isn't unique to programming of
computer science and there's the dread
word post-modernism javis wildly attired
in a book called the postmodern
condition talks about the paradox of the
future post anterior modo the future
past these these guys Robert Biddle and
James Noble said modern means apply to
other than modern ends and there's a
bunch of stuff you can think about
making up this sort of postmodern some
incredulity towards meta-narratives long
French word some of which I'll explain
negotiation and context double coding
reuse topology here's leotard again
recourse to grand narratives is
forbidden we cannot record the dialectic
of the Spirit or even the emancipation
of humanity for the validation of post
modern scientific deked discourse
interesting that leotard was actually
writing out the problem of the modern
University when there's a whole lot of
people so I'm doing computer science and
some doing art history and how would
these things operate and what are we
doing but as we have seen the small
narrative is the form which superbly
allows the imaginative invention most of
all in science what are our grand
narratives what is programming what is
computer science the good thing is there
are people that can tell us there is the
ACM curriculum on computer science and
that actually defines what is important
algorithmic computation correctness okay
the program is correct it's apparently
worth noting algorithmic efficiency
and to quote Martin Reinhard software
that fails to meet these goals is
evidence of the moral weakness of its
programmers what are we got instead
these things called a little narratives
instead of appealing to some overarching
goals will try and make decisions
ourselves in our own small part of the
world so people might talk about a
negotiation between various different
narratives being open to the environment
decisions being contingent or or context
dependent and best of all no single
correct answer gee my students love that
they have this notion of negotiation
right across programming software
engineering and a notion of local
correctness instead of global
correctness so what kind of things does
this involve post modernism post
modernists talked an awful lot about
double coding double coding is a word
for addressing more than one audience or
meeting more than one concern perhaps
your programs have to be acceptable to
the general public but you also have to
care about the technical and
professional experts your colleagues and
we still do actually have implementation
constraints but the thing about double
coding is it says look um we prefer the
surface to the depth now whether our
programming language has curly brackets
or round brackets is more important than
whether it's type cipher we prefer
appearance to reality signifier to
significant fire to signified the
pictures on the slides are more
important than the content
and of course parody pastiche irony and
cute references are all part of this
where do you end up and as health Berg
one of the great language designers
clearly influential actually said this
back in 2004 your choice of programming
language is a lifestyle choice your
choice of programming I was going to say
people have died about choices of
programming languages life was going to
say that's not true but it quite
possibly is true if you believe what
Mattias Ison was saying yesterday in the
the workshop about why javascript is bad
another way of looking at this is to say
that post-modernism is is that condition
for which for the first time and as a
result of technologies this guy's this
guy's a philosopher this is the
Cambridge companion to for like to
post-modernism as the result of
technologies which people which we have
built which the people in this room have
built allow the large-scale storage
access and reproduction of the records
of the past and so the past all the
software all the programming languages
is now included in the present these
days there's no difference between the
Beatles and Beethoven because both of
them are on Spotify
well of course this means is that the
technologies that we have built are now
going to affect what we actually do how
do we make this concrete Larry was
giving a keynote and he said way back
when when I started designing Perl I
lovingly reused features from many
languages from c shell c shell brett
said awk Fortran COBOL P or one basic
plus nobilis Data C++ and Python should
extend that Perl rules rather than sucks
it's because the various features of
these languages rule these languages are
put together from parts of other
languages and if you think about this
when you you program them you were
referring to those things storing and
retrieval the past sum of all human
knowledge it's pretty much on the wiki
web now this is why we can Google for
the stuff we need to do in our programs
and as an aside of course wiki was
produced by Ward Cunningham who in many
ways is the earth post modern computer
scientist because he's been in so many
important and postmodern developments
and wiki's of course the one we're most
familiar with but design patterns Ward
again was very much involved when the
design patterns movement this talk was
originally given 15 years ago was coming
along and what is a design pattern it's
a solution to a problem in a context it
doesn't tell you how to design the whole
programs and frankly the attempts by
some of the patents people to say we
will write a book we will write a modern
book that gives you a big story about
how to design every program in the world
that attempt failed but the design
pattern is assertion a solution to a
problem in a context small stories about
bits of designs that was successful
and patents don't build whole complete
programs but what they do is they give
you small answers to small parts of your
programs and then they interact and
negotiate one another for the whole
program to emerge and of course there's
extreme programming I think Ward is one
of the figures standing around the
glowing whiteboard of knowledge how's
this supposed to work well the customer
and developers are supposed to negotiate
over these things called user stories
and these stories are iterative it's not
the kind of refinements you see if
you're doing stepwise development but
you know other stuff come in other stuff
not comes in and the aim of this is to
build a system not build lots of
reusable components according to some
plan but put a system together based
literally on the negotiation and playing
games between the developers and the
poor customers who are paying for it
post-modernism is leeching actually into
the code that we write each of these
annotations is a small thing telling one
little thing about this method there's
not a complete set of annotations in
Java and you can add your own in each
annotation is like a little bit extra of
a programming on which a small story
about one thing and we end up with code
looking like that
so after gave the force to it we came
back next year and gave a second talk
called No Name notes on software reuse
and most of this talk was about what we
called scrap heap programming and these
pictures are actually taken at a
Wellington scrap heap by Angela Martin
who was a graduate student of ours who's
a photographer and the idea of this is
that programmers don't have a plan you
work bottom-up from the scrap heap
starting with with whatever you can
whatever you can find whatever you can
scavenge perhaps whatever you can steal
certainly whatever you can google and
then you work out what you can build
based on the components you've got and
this bottom-up way of working is
completely the opposite to the way of
working where you have requirements and
analysis and design and specifications
the whole point of something like XP is
that you negotiate about requirements
based on what's easy to build ok you
want this feature you can have it
tomorrow you want this feature you can
have it next year requirements are a
result of programming not an antecedent
to it
we actually had building recyclers this
is a company where if you don't need a
building anymore they'll put it on the
back of a truck and take it away new
zealand most houses are made out of wood
so if the building doesn't fit on a
truck we saw them in half and we put
them on a truck and we take them away
and whole buildings and parts of
buildings and if you want a house you
can actually go to a building yard which
is a yard with a lot of houses in them
secondhand houses and buy one and then
they'll put it on a truck and take it to
where you want to live well it's Brad
Cox would put it well is this kind of
like software I see software components
but the point of this is that what you
get isn't something that looks like a
plan this is this is Wellington and in
fact the University is sort of sitting
on the hill
this isn't corbusier's radiant City this
isn't some grid pattern with all the
buildings looking the same it's
something that's built out of what's
what's there here we have we walk
amongst mm well probably more than that
three four thousand years of history
even in Wellington we've got a couple of
hundred years of history that shapes our
city programs are shaped in the same way
because we're building up on what's
already there on components that already
exist and if you actually do various
metrics on programs if you ask how
bigger my classes or how bigger my
methods or how interconnected are my
objects you don't get the uniform
distributions or perhaps the normal
curves that you would expect if all
these things are built out of components
that are all exactly alike what you get
instead of power laws which is exactly
the same mathematical relationships that
will describe the building of trees the
flowing of rivers the shape of the
mountains in nature in cities and in our
programs
we did to talk again a third time and
true to our form of course we just
reused the previous two talks we're very
careful not to make any new slides and
then we did another talk would love in
the age of software which I believe was
the most annoying talk at an XP agile
conference and possibly while Robert and
I were never invited back again it may
have been because we started the session
at 8:30 in the morning by playing craft
work extremely loud here's the truth of
programming right so looking at this you
know XP is all about tools for customers
and developers to rate with each other
but if you think about how it's actually
done things are different so system
metaphor one of XP s original practices
in some sense this was about saying come
up with at least a small story the whole
system that one's expunged on-site
customers well that's unpractical and
unrealistic you can't expect someone
paying for your software to actually
spend time with you telling you what to
do so we'll hire somebody else to be a
customer use the stories are supposed to
be a promise to have a conversation
where we'll automate those things and
when it comes to the planning game which
is supposed to make our development
flexible well like that's kind of a bit
difficult you know so let's not do that
where 10 years ago did we think agile
development would end up well all sorts
of stuff
one-day iterations the whole team
approach where the whole team is
programmers and you don't have one of
these customers executable user stories
automated acceptance testing 80 hour
weeks three months crisis and career
change counseling and you know we have
to ask ourselves the question yes mass
macho train wreck or death march would
you rather be in the planned train wreck
where you're all sitting on a train and
you're travelling straight towards the
wreck and then
bang you hit it or would you rather be
doing a death march where you work again
and again and again and anyway so where
does this leave us where does this leave
us are we throwing the baby out with the
bathwater
are we rejecting 50 years of progress
and consorting with past debt French
philosophers the point is that post
doesn't just mean instead of it also
means follows on from so the point of
this is to keep modern technology well
the bits that work anyway that apply it
to different postmodern ends so this
raises the question how can we do
software engineering without meta and
narratives without correctness or
efficiency or at least we're both
correctness and efficiency are
negotiable in a way I certainly wasn't
taught when I was at school without a
privileged position from which to model
or conceptualize because we know that as
programmers what we do will change the
world the components we find to reuse
will set the requirements for our
systems can we move from a grand
narrative to just being one little story
above many should we or in practice do
we really have the choice
if there are only two ways to make a
system if you make it so complex that
there are no obvious deficiencies or you
make it so simple that there are
obviously no deficiencies then what the
market has shown us and what we know now
is that we do not have the second choice
we only have the first one systems built
together out of the past out of what we
already have built by ongoing
negotiations between programmers between
customers between the software that's in
the past
the software that's in the future that
we will write in short we're all
postmodern now thank you
so I'll return to the present and that
went quicker than I thought it would so
I do have a bit of time for questions
you
hello thanks for the wonderful talk I
have a question is there something that
comes after post-modernism post
post-modernism um I don't know
I mean I was recently looking at some
stuff in architecture and some of the
best hallucinations of post-modernism
were ones that seem to make most sense
to me as a computer science come out of
architecture and the late zaha hadid had
a form of design she called parametric
design which she basically said look
instead of building these kind of
buildings just out of fixed components
the whole point of doing this is that we
will build all these components that are
parameterize abour does that sound
familiar to anybody I think we're still
here
I I don't think that your conditions
have changed I think that what we have
done what we have wrought what we have
built has basically infiltrated the
entire world you know it's easier to get
cell phone service in Soweto than it is
to get sewage and I think you know it's
coming back to bite the way we as
programmers work we as designers work
and modernity is here whether we like it
or not
hi so I was wondering so I think today
more so maybe than 15 years ago I guess
a lot of us are steeped in sort of these
postmodern things that you've described
in in the programming practice yeah but
I still see really strong influences of
modernism in particular the idea of
grand narratives and we seem to be
making a comeback with you know VCS
talking about how software is taking
over the world do you see any lessons
that we could have learned from the
modernists saying architecture and
planning that we have not yet learned I
think that that's a good question
ayan tempted to say don't do you know
the other thing which I didn't talk
about because didn't have time is that
you know as I said post-modernism
doesn't replace modernism but it carries
on from it so you can still be as modern
as you like okay and in fact again in
programming languages my field you know
there are people who are getting more
and more and more modern right there are
people who are doing everything they can
with mathematical proof and if you think
about languages like interests and Agda
and coq you know what could be more
modern than designing and proving
everything and then having a computer
system that is itself proof prove
yourself correct that's really really
really modern we have a plan which is
the specification and then we ensure
that the software which that
specification
what does post-modernism have to say
about that I think it has two things to
say first of all this idea that the
signifier that what we say takes over
the meaning the whole sign is once we
can write specifications we're not going
to really worry about code will just
write the specifications hmm and you
know maybe your manager could read the
specification you've written them maybe
you could write those specifications in
I don't know a common business oriented
language perhaps
and the other one is is it yeah there
are grand narratives but there are so
many to choose from so if you look at
what's the most again in in my key area
but you can see this in lots of places
of computer science I mean the kind of
systems people built um programming
language is the most interesting on the
one side are the actor and the highly
type stuff and the higher order generic
Haskell's and the other side is you know
the double coding it's the Hello Kitty's
of the programming languages it's
JavaScript and again if you look at
either academic research or practical
development there's the JavaScript side
completely turning away from modernism
and the nice thing about post-modernism
is yeah you know if you want to you can
build a house out of glass and steel and
make it a square box or you can you know
put something together out of bricks or
you can go to a yard and you can buy our
wooden house that's a hundred years old
and move it to where you want it or you
can move to Rome and and you know move
into a building that's 500 years old the
past is part of the present but it
doesn't mean the present replace the
past and it doesn't mean the past is
eaten in the future it's postmodern the
future past
do I have a conception of a good
software engineer the postmodern era
well I think there is an answer to that
because why do you call me good we are
in Rome nobody but my father in heaven
is good ok postmodern you know the idea
of a good software engineer if implicit
in it I guess I could say is a criticism
is an idea of a grand narrative there is
some perfect software engineer whether
it's new klaus viet or whether it's
larry wall and that is to whom that is
to whom we this fire
that is Bannister whom we aspire and but
post-modern says look there are all
these lots of little competing
negotiating things involved in building
software so you have to ask what context
for doing what kind of thing so is is
somebody who is good at at building
websites and keeping them secure perhaps
in JavaScript a good software engineer
doing that a good program is doing that
how they're going to be the people you
want to work I don't know on your
avionics systems No
so that's part of it I think the context
of people and also being aware again
that you know there are more things in
heaven and earth that are probably
dreamed of in your philosophy in some
ways it's easier for to see this amongst
the sort of the the scruffy end the
Hello Kitty the JavaScript people
because they know that actor and
functional programming is there but I
mean some of the most interesting work
that's going to be done in actor and cop
is going to be you know in fact already
is it's it's building models of
JavaScript okay and what's some of the
most interesting stuff being done in
JavaScript or gee it's building
implementations of these hyper modern
macho programming languages over here
and you can't make progress in that way
if you're saying okay look well I'm this
guy the guy I'm a good software engineer
and the rest of you are you know
excellence
I didn't say that
analysis tools try to infer
specifications find bugs and so on is
the post-postmodern approach in the
sense of it brings back the idea of we
want the software to be reliably but we
don't force the software development
process maybe I'd listening to that talk
and it was a great talk
i I thought it's also a quintessentially
postmodern talk you know what could be
more postmodern than taking the best
leading edge research on some of the
hardest problems in computer science and
applying it you know to PHP there in
some sense is the quintessential
postmodern essential example of a
postmodern cooking I mean the reason
this slide says we're all postmodern
because we are we are all postmortem
you know what does Haskell want to be
Haskell wants to be Perl pearl wants to
be Haskell I can keep going all right so
yeah you know real-world Haskell is
Haskell want to be Perl pearl want to be
Haskell
absolutely I don't even think that
architects used computer science
metaphors I think architects are and
have been for the last 50 60 years
they're turning into computer scientists
and some things if you're in London in
south ken and you go to the Science
Museum there is a great exhibition on
over our up you know who over our opers
one of the greatest arguably greatest
most influential engineers of the 20th
century you heard of the Sydney Opera
House he designed that the wobbly
Millennium Bridge in London he designed
that to the Pompidou Center he designed
that or if he didn't design it he did
the engineering that made it possible
and if you go to this exhibition what
you find sitting in the middle of it is
a Ferengi mark one computer because the
only way they were able to build the
Sydney Opera House and this is 50 years
ago was to use computers to model the
shape of the spherical sections which
form the roof of the Sydney Opera House
you're not sawn won the competition with
a sketch on an on a napkin and had no
idea how to build it and so he asks over
a rope and comes in and eventually works
out well these things should be
spherical sections how do we know how to
build them well we use a computer right
up to this are haha did and all the kind
of skyscrapers you've seen like that the
shard and the stuff being built in China
and Dubai all of these things are only
possible because of software and again
you know as I heard it talks about their
style of architecture their small part
they're small approach I suppose if it's
you could say as parameterizing ball in
precisely the way that we use the word
parameterize abour why well because they
got it from us first
the question is like post-modernism in
philosophy is generally understood as
here okay
sorry yep so the idea is that instead of
having an apology about the world like
postmodernist focus more on on a
conventional list worldview like that
the man is the measure of all things
right
does this proposal sort of reflect the
fact that it's impossible to find a
nature for a program to define it as a
mathematical object or whatever so in
the sense that you know I'm doing
against grand narratives I'm saying
there isn't going to be one big ontology
for everything there's a thin line
between like a grand narrative and the
nature of something maybe so I I mean
I'm tempted to say yes but we all have
different natures we all bent Ain
multitude you might think of a you know
it's just as you can think of a program
as something that runs on a computer you
can think of it as a mathematical object
which has some relation to that you can
think of it as a human architect
constructed by humans you can think of
that as an artifact that's evolved over
the time or will carry on and evolving
into the future and the postmodern
approach is well all of those are valid
ways to think about artifacts and I
would say and in fact we need all of
them we can't just say look we're only
going to consider the mathematical model
of our java type system as being typed
safe and not care about the fact that it
has nulls in it which means it's not
time safe it doesn't matter as some as
Peter said you know we can have type
systems that means you can't write null
in Java or Scala the programmers don't
want to use them and there may well be
reasons for this not just Tony horse
million dollar mistake because this is
how I understood it and in my
presentation tomorrow I'm going to say
that's who your presentation tomorrow is
what is program what is what is
programming okay thank you I'm around to
the rest of the week</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>