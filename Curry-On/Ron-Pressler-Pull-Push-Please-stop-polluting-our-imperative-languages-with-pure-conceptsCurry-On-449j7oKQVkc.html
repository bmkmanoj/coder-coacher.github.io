<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ron Pressler - Pull Push: Please stop polluting our imperative languages with pure concepts-Curry On | Coder Coacher - Coaching Coders</title><meta content="Ron Pressler - Pull Push: Please stop polluting our imperative languages with pure concepts-Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ron Pressler - Pull Push: Please stop polluting our imperative languages with pure concepts-Curry On</b></h2><h5 class="post__date">2015-08-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/449j7oKQVkc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Ron Pressler I'm the founder
of parallel universe we make an open
source server side stack for the JVM
that helps you write very efficient
applications um so the talk today is
kind of messy it's going to be part ran
part opinion parts um rehashing of old
ideas I am going to talk about
functional programming and imperative
programming I am NOT going to discuss
the relative merits of the two but I am
going to discuss the applicability of
certain pure functional concepts for
imperative languages or rather lack the
raw and this entire talk is given from
the perspective and imperative
programmer so I'm not going to use the
right names for things or the names
haskell gives them and yeah what we are
we are going to discuss monads and I'm
going to explain what they are and then
why they're absolutely terrible not for
for imperative languages for imperative
languages they're excellent for pure
functional ok so as a motivation these
are three classes from from the JDK this
is a standard Java runtime library many
of you must have heard that Java 8 now
has lambdas it also has in the standard
library at least three moments and this
means that there are more people using
monads in production now in Java than
anyone using Haskell for anything by
probably orders of magnitude which makes
Java
the most monad heavy language in
existence now it's not it's not it's not
just Java Java itself this is built into
two libraries but there are there's a
very good a family of libraries called
reactive X that's based on monads for
various languages their promises or
based on monads and JavaScript and
recently I think Facebook introduced C++
futures the same idea for the C++
okay so we'll start by first going back
to basics and defining a pure function
so a pure function is a subroutine that
behaves like a mathematical function
which means that its only inputs arts
arguments and it's only output is its
return value and it's not allowed to
change any externally observable state
or do any i/o whatsoever just takes
parameters compute compute results
unfortunately we have a lot to cover
keep your questions to the end I hope
we'll have time because there's a lot to
go through and the best part is in the
end
okay so pure functional languages means
that all of our subroutines are pure and
as a consequence of this the or the
converse is that if you are not pure
then you are imperative so even
functional languages like closure or
Lang scheme our ML even our imperative
so in this in this and this I'm going to
treat and treat them as imperative we'll
see why but an imperative programming
can then ask themselves then if all of
my subroutines are pure functions how
can I do anything useful
if they're not if none of them is
allowed to do any i/o how can I can I
achieve anything useful and monads is
the answer to that so
monads are what gives pure functions
super powers now from the perspective of
an imperative programmer I know I know
VFP people have mathematical terms for
everything we don't know about that
so for from an imperative programmers
perspective a monad is a design pattern
and it's a design pattern that's made of
three parts first the monadic value
matic value takes a simple value say the
number three and wraps it in a context a
monadic function is a function of pure
function has to be because we're pure
languages that returns a monadic value
and the composer in an asshole tool bind
the composer is takes a monadic a
monadic value and composes it with a
monadic function and together you can
form a chain of monadic functions either
each of them returns a monadic value and
the composer changed it to the next and
this way you create a sequence
computation steps and we'll see how all
of them together can do something useful
so to make it more concrete let's
introduce a simple monad I call it the
square brackets monad it implements a
counter
so our monadic value is going to be the
simple value X in the square brackets
context along with an integer and this
is our monadic
function it takes simple value X returns
a monadic value Y and K and then this is
the interesting part the composer and
here I denote it as the name of the
monad in a circle so it takes a monadic
val a monadic value x and n and composes
it with a monadic function f how does it
do that what is the composition rule for
this particular monad so it's going to
take X and apply it into F and then F is
going to return Y and K and then the
composer is going to take the K and add
it to the original end so at a key
accumulates let's see more let's see
working on a more concrete example so
suppose we have these three functions or
pure functions they're monadic functions
right there turn monadic values and we
chain them with composers and I claim
that the answer is 8 and 6 we'll see why
so we start with Z doesn't take any
arguments and returns 3 and 1 and then
we compose that with F so it takes a 3
passes it into F and then F returns 4
and 2 and then we add the 2 to the
original 1 and we have 4 and 3 and then
we take that 4 and 3 compose it with G
and we do that by taking the four
passing into G G returns 8 and 3 and
then we take the 3 add it to the 3 we
had and the final result is 8 6 another
more real-life example is exceptions
pure functions like I said they can't
throw exception they can't do anything
other than compute a return value but
with monads we can simulate exceptions
now what are exceptions in an imperative
language if you have a sequence of
computational steps and one of them
errors then we abort the computation and
we don't execute the subsequent steps so
we can do that with a Moana we call I
call it here the angle brackets monad
and the one attic context in this case
is e which can be either success
or error and f is going to be as before
our moon attic function and what is our
composition rule so suppose we have the
monadic value X and E we want to compose
that with F so if E is success
then we pass X into F and return that
result
if EES error we never evaluate to F and
just return error so how does this work
suppose these are our monadic functions
and we chain them together
so Z would return three success which
means that we take the three pass it
into F F returns for success we take the
four pass that into g and g returns
error at which point the composition
rule is not going to evaluate anything
it's not going to value it h of this
case and just return error okay so it
works just like exceptions finally how
do we do io with just pure pure
functions and pure values so in this
case our context is going to be an
operation io operation that's attitude
the simple value X and then operation is
going to be one of print read or no op
there has to be a no op because there
are rules to which compositions are
legal or not but that we don't care
about that for the month so how do we
compose op X with F so if op is print
the composition rule is going to print X
to the console and evaluate F with no
parameters
if op is read the composition rule is
going to ignore X read a string from the
console and pass that into the next
function the chain into F and if op is
no op then we just take X and pass that
into F so what can we do with that we
have these Freeman attic functions and
we can compose them so P is going to
return print and what is your name so
the composer is going to print that to
the console and then R is going to get
called with no arguments and it's going
to return read so the composer is going
to wait for input and the user is going
to input their name and then the
composer is going to pass the name to N
and n is going to turn print hello and
name
and the composer is going to print that
so this way and now you can ask okay but
if a composer is a function how is the
composer allowed to do any IO
and the answer is that this particular
composer is not written in the pure
functional language it's built into the
runtime and so therefore the same
restrictions don't apply to it another
thing you may ask is okay so but now we
find a function that has this PRN
sequence then this function in closing
this is now doing IO and up your
functional languages this is why they
don't let you evaluate this in place any
function that wants to call this
sequence has to return this expression
as its return value all the way up to
the main function of the program and
then it returns to the runtime and the
runtime evaluates it lazily but this is
a detail that we don't care about and
then okay so now you ask yourself fine
okay so we know what moniz are we
clearly understand why they're important
for pure functional languages but why
does Java have them and how come Java
uses them so much we can throw
exceptions we can change state we can do
I owe so to understand that we looked at
the previous example how it would be
written in an imperative languages in an
imperative language so this looks kind
of familiar and boring but I would claim
that just as the monad is like the uber
abstraction of pure functional
programming
what we see here isn't trivial at all
and actually touches that the essence of
what imperative programming is and the
what's interesting about this is not
that we're allowed to do IO in place or
have effect but what happens when we
call our when we call our that reads
input from the console our program
pauses it suspends itself what happens
then we don't know we don't care usually
we yield control over the the CPU to
another program to run and once that
input returns then we continue with our
computation and this is the concept of
this thread of doing one thing after
another
and potentially blocking is what I'd
like to claim the essence of imperative
programming not the ability to change
global state but that and I'm going to
prove prove it to you by showing to you
what happens when we take that away and
I hope you will agree at least that that
this is what what imperative programming
is all about the ability to block
threads and the thread let's define it a
little bit just to to make you think
about the same thing that I'm thinking
of it's just a sequence of operations
with a stack that can block it is also a
unit of programming concurrency in the
sense that you can have multiple threads
running but even if you're a programming
language doesn't support multi-threading
and you only have one thread say I think
Ruby then it still uses the thread
abstraction also because they mentioned
the work concurrency here and I'm going
to mention it again let me just say that
I'm not talking about a particular
concurrency model not talking about
shared state concurrency I'm just
talking about a concurrency model that a
concurrency that allows multiple
blocking threads to run at the same time
how they exchange information is is
completely orthogonal they can be shared
nothing they can exchange messages okay
so to make this so we can follow and see
what happens how one has this court
destroy imperative languages so let's
suppose we have this web application
that performs I need to perform some
financial computation on behalf of the
user and in order to do that it uses a
very simple API to consist of a single
function single method this is a Java
syntax that that's called compute and
it's going to take the name of the
financial operation and a single
argument and return the result in this
case we put it in a function called Cal
comport in finance and we do all that
but the thing to notice here about
compute is that compute in order to
compute the results might need to
consult an internal service for example
to figure out to retrieve the current
exchange rate from the US dollar to the
Euro or the current interest rate so
compute may take a long time may do IO
and can block but we don't care about
that right because we are imperative
programmers and this is just a sequence
it's very clear what's going on here
but herein lies the problems of threads
and the problem is I think a best
summarized by this equation
it's called littles law actually proving
it proving it is more complicated than
it seems but it says this if we have a
server that's serving requests and it
takes us a certain amount of time called
W on average to service each request
start to finish and remember a request
in these days can take a while it can be
an open session like an open TCP socket
that that communicates for a while then
if our income request rate is lambda
then we must support at least L level of
concurrency and this level of
concurrency is imposed on us by the
domain it says that the number of
pending messages that our server needs
to support is L if our server if our
service capacity is below L it's going
to become unresponsive and crash so we
must do that and and there are various
factors affecting our service capacity
so for example one can be the maximum
number of open TCP connections right we
can't so that's if the L is bigger the
number of maximum open TCP connections
we're just not going to be able to
handle the load but that number is
pretty large on modern Linux is you can
support maybe up to two million
concurrent open TCP sockets but a number
that is not so large is a number of
threads modern operating systems can
support up to somewhere between 5,000
and 20,000 active threads that do some
work occasionally and this numbers is
pretty low and puts a like a upper bound
on how high we can go with concurrency
and that means that if we use compute as
we did before and for each request we
handle it start to finish on the same
thread and block then we then we're
quickly going to run out of threads and
that means that we're not allowed to
block and we must use fewer threads
fewer software unit of concurrency to
support the domain concurrency so we
can't block and we can't use our
super abstraction so what happens so
first we said okay so we have this thing
called asynchronous i/o well we don't
have to block a thread and we'll have a
thread sitting somewhere it's going to
pull the os's io q and when our i/o
operation is going to complete it's
going to call a callback we say fine
okay so compute now instead of returning
a result it'll take a callback pass it
on to the i/o thread and once our result
is ready our callback is going to get
rid triggered and this is the result it
gets unwieldy very fast and yeah it's
just it's just not good no it looked
like no js' so imperative programmers
just lost their ability to use a very
important a very important abstraction I
haven't proved yet that it's the most
important abstraction but I think you
will agree it's a very important
abstraction the blocking thread and her
only option was not to block in
callbacks you know are terrible and it
was in this sorry sad and confused state
that the PFP people found us and they
said you know what instead don't return
a simple value from compute because for
that need to block but don't take a
callback either turn compute into a
monadic function it'll return a value in
a context now in case of Java it's
called a compute completable future
we'll just call a future some people
call this a future monad some people
call it the promise monad
some people say that it's not a Moana at
all just something that looks like a
monad but again we don't care it looks
enough like a monad and the idea of the
future is the idea of the future is that
the wrapped value is not immediately
available it will become available when
some the let's say the i/o thread sets
the value and completes the i/o
operation and therefore our composition
rule which in the Java it's called then
compose says that when the i/o thread
sets the value of the future we're going
to pass that to the next monadic
function in the chain and they said okay
listen now your code is going to look
like this and this is Java code and I
think you all agree that
it's much much better than then then
callbacks we call if you have these
three chain computes we have the
composer between them it's say okay Java
doesn't have a nice see a nice syntax
for a monadic composition
maybe it's solvable it's fine now I
claim this is absolutely terrible and
not much better than then then callbacks
and let me try to convince you why so
first of all suppose we want to
encapsulate this sequence this
computation in a function as we did
before calc important finance how do we
return the value from calc important
finance we we can't extract the value
out of the future out of the monadic
value because it's not there yet
we could block but that's exactly what
we're trying to to prevent so we have
two options we can return the future
from the function or we can call a
callback and publish the result and
those are only two only two
possibilities and if we use a callback
then and then we back to callbacks if we
return a monadic value will quickly find
that the entire call stack all the way
up is infected with with this monadic
value so now Java we have to use monadic
functions everywhere you know pure
monadic functions
I don't think control flow suppose that
we wanted to repeat a part of part of
the sequence multiple times until we get
the desired results so for that the
imperative language gives us loops a
functional pure functional and WA jiz
don't have loops but we do we can do
that it's very simple how do we do that
monads we can't I mean we can we can but
we have to use a monadic library we have
to use recursion and all kind of stuff
superior functional languages do but we
don't have to so yeah so we can't use
the call stack as we used to and we
can't use control flow the regular way
and finally let's look at exception so
in the beginning of the talk I showed
how monads can simulate exceptions and
and this particular moment does that too
so if one of the calls to compute errors
and returns an exception then the
subsequent steps are not going to get it
valuated and this final lambda is going
to get call
with an exception but this treats
exceptions as value the the computer is
not allowed to throw the exception
because because when a tucumÃ¡n attic
functions are pure functions it has to
return the exception wrapped in the
future so you can't use throw and over
here as you can see we can't use catch
either you get the exception as a
function argument and the pure function
people going to say that's great you
know an error is a value but to us
imperative developers an exception is
more than a value it's a value with a
stack context so when we log this to the
log and we're going to try to do
post-mortem debugging we're not going to
see that the exception came from the
calc important finest hour from the
apart from the call to the calc
important finest method our stack
context is lost yeah an imperative
languages pool is always better than
push I I don't unfortunately I don't
have time to get into that but to
summarize more not to make us in
imperative languages again Manas make us
throw out our old API is to use monadic
api's and their viral they infect the
entire call stack the second we have to
recreate everything the imperative
language always gives us always give the
same way so we can't use for loops you
can use while loops if they think we can
use that's about it because pure
function languages do you have if and we
can't use exceptions so all of that
error handling and control flow has to
be handled in this monadic languages is
not part of our imperative language and
finally we don't have the stack context
for postmodern debugging and perhaps not
less important that profiling suppose
you run this program through a profiler
and you see that compute takes 95% of
the the runtime for the program they say
ok but is it when compute is called from
Cal keyboard and Finance or coucher
Department value you don't know that so
you can't even get the the performance
profile of the program and this is
something that's very important to
imperative programmers now it's not just
say that
monads are never useful in imperative
languages in fact in some use cases
they're extremely useful specifically
when we deal with
data parallelism someone has give us a
very nice way to say we have a huge blob
of data and we want to do a following
sequence of computation on it and this
is implementing job with Java eight
streams and there because we do
operations in parallel we explicitly say
we don't care about the thread context
right because if we give a have a
function and we tell the library running
on any thread because we wanted to run
in parallel we don't care about the the
thread context so for that monads are
very useful so my question is why
replace a good familiar natural
abstraction just because the
implementation by the OS is inadequate
and in fact it's not just a good
abstraction it is the core abstraction
of imperative programs because
imperative programs give us stats they
give us control flow and we can't use
them in the exceptions and we just can't
use them once we start using monads we
have to basically rebuild Haskell in
Java and Java doesn't have the syntax
for that and it doesn't have the
assurance as if your assurances for that
why can't we just fix it down
implementation and we can and it turns
out that it's quite easy instead of
relying on the operating system to
implement threads we can implement them
in the language runtime this is called
fibers or user-mode threads or
lightweight threads and this is and the
way this is done is the language runtime
can import can implement threads much
more efficiently than the operating
system if you want to ask why why I can
explain detail but the idea is that
those threads don't need to be as
general as kernel threads so we can do
them much more efficiently and in fact
this has been used very successfully in
early engineer sorry in Erlang yes and
in go and in quasar quasar is our own
open source library that adds true
fibers to the JVM with no need to change
the JVM and our code looks like this
just as before we can use this same old
API as we used to and we're not limited
by the number of threads because these
threads are not kernel threads you're
not expensive you can have a million of
those so threads a number of threads is
no longer the bottleneck to littles long
and if you say okay but I like monads
because they let you compose these nifty
functional operators like filter and map
etc you can still use those i'm not
functional is great so again this is
example from Java and quasar so you
subscribe to a channel and you attach a
filter and a map on the numbers coming
into the channel but you consume the
channel by looping and blocking on
receive pulling out the messages and you
have all the damage advantages of both
functional and imperative you get the
exact contacts you get your profiling
information and none of the
disadvantages now fibers aren't perfect
especially for runtimes that don't
support fibers natively like the JVM
they do require library support the
libraries have to be aware of them
luckily it's very easy to wrap a library
to support fibers without while
maintaining the API without changing
actually just you just wrap it debuggers
it can work with fibers but sometime if
you step over something that blocks it
doesn't recognize that you'll see a jump
in the program but you can just fix it
debuggers again it's not hard but you do
need to take care when you exit the one
time because if fibers are threads or
implemented in the runtime it's not in
the kernel once you exit runtime and say
call see then you can then see is no
longer where of how those threads and
stacks are implemented so you have to be
careful okay so we've seen so we can use
or go back to our old habits threads are
no longer problem every incoming request
you can have a million of those each of
them might take half an hour you can
write blocking code get all performance
that you got with monads you got your
control flow you get your exceptions
everything is fine but something still
bothering me updates and he said but you
know what monads are really beautiful
not not imperative languages in in pure
functional languages they're a Brit of
really beautiful like basic abstraction
can we have the same thing something as
essential in imperative languages
so before we get to that nothing for a
little while longer about the thread so
I said the thread is the core concept
now that's not exactly true because a
thread isn't fundamental that's right
these two things really it's a
continuation now if you know a
continuation is just a call stack so a
thread is the call stack with our local
variables and the entire change of chain
of calls that can block and resume and
the scheduler is what assigns our code
or our continuation to a CPU core when
it's ready to run so the scheduler is
not really important to the to the
abstraction it's just part of the
implementation and the code rewrite is
not dependent on the scheduler so the
fundamental idea the basis of imperative
programming is a continuation or in the
call stack so let's build on that and
you're introduced something called scope
continuation it's not really new I think
it is based it's a specific kind of
something called delimited continuation
introduced in the in the mid 80s and
scheme by someone who I think is in this
conference at this conference and let me
explain how they work and show examples
so we need three things we need a scope
variable which going to denote like that
for now think of it as a thread local
we're going to introduce a keyword
called count that takes a routine and
makes it able to pause and resume at any
stacked up now this is very important we
have to be able to pause at any stack
depth and this is why this is not the
same as C sharps async/await or closures
core async go blocks they only let you
pause at the topmost stack frame and
they're therefore called stack less
continuation because they don't really
support the stack and finally the pawns
operation is going to set the value of
the scope variable this kind of thread
local and jump to the point where was
called
we'll see an example okay so we have
this context this scope
and this code belongs to the ex scope
variable and here we take a function C
we turn it into a continuation and we
loop until it's done every time it
pauses we loop again until it completes
C itself just simply calls F twice and F
pauses twice once it sets the value of x
2/3 and second time to 5 so all in all
before C completes it's going to pause 4
times setting the values of X - 3 and 5
interchangeably I mean alternatively and
and this is when it's going to print out
three five three five one more thing
about the scopes they can be nested and
again this is very important when we get
to composition and how we do it better
than monads so suppose we have this X
scope and then inside at a Y scope and
inside another X scope and inside the
continuation C and C calls pause on the
X scope so C is going to jump to the
innermost X scope that surrounds the
continuation so it's going to jump here
and not there because this is the
innermost scope once it pauses and why
it's going to jump to the innermost Y
scopes it's going to jump to this point
because this can't contains a
continuation where the pause was called
on why okay um
and now let's implement exceptions this
is all a language doesn't have exception
now we'll implement exceptions this is
like a pseudo syntax it's actually quite
similar to Kotlin so we'll implement a
try and catch like this try is just
going to be a function that takes two
blocks body and catch and it's going to
introduce the e^x context the e^x is the
scope variable and it's going to turn
the body into a continuation and if it's
not done namely paused then there must
have been an exception we grab the value
of the local of the scope variable e^x
put it into a local e and if it's not
empty we invoked the catch block and
this is very important we'll come back
to that in a second that we invoke the
catch block outside of this scope else
if C complete normally would just return
this value and we introduce the function
scope its
function and it calls pause and sets ex2
the exception so what does it go look
like just like this
in fact in accounting you'd have even
nicer syntax but I wanted to make this
clear that these are two blocks you can
pass through the function this is the
body and this is the catch block and a
might throw an exception so what happens
here when you throw an exception when
you throw an exception we're going to
where was it yeah we're going to jump
here and we see that it was in the
middle of the run so we'll grab the
exception and then we'll call the catch
the catch block and once the catch block
- sorry the catch block logs the
exception and we throw of it but now it
wreaths rows it from outside this
enclosing context this is closing scope
so the second time we pause in the we
throw in the catch block
it's going to get caught by an enclosing
scope just and it works just like
exceptions okay another example
generators I think python has it has
them generators is is you have a
function that calls a yield or produce a
value every time it's called it's like
it lazily adds another element to a
collection so we'll implement an
iterator with a specific implementation
we call Co iterator and the iterator is
next method is going to introduce the
element scope and it's going to take the
generator function turn it into a
continuation and as long as it's not
done it returns the current value of the
scope variable and we have the produce
the produce function that pauses and
sets the element to the given element
here and how do we use that so for
example this is the range function and
returns an iterator of a collection or a
sequence of numbers between a and B and
it's simply a for loop the call is
produced with every number and this is
produced lazily we could also have an
infinite see a different range and with
that I'm not going to go into details
because I think I'm Apple time but
you can implement a flat map and map and
filter and they are very very simple
one thing I do want you to notice here
is that with monads the flat map if you
know this if not it's okay
flat map is the composition rule for the
sequence moment or the list moment so
you must implement and that is the only
thing the composition rule knows how to
do so you must implement map and filter
in terms of flat map because that that
is the only monadic value the composer
accepts it's the only thing the composer
can only do one thing here that's not
the case our composition rule is partly
in the wrapping context and partly where
we call pause and this is why we can
implement map and filter directly and
flat map all to use the same context
without interfering with one another and
every time we call produce in a loop you
can think about it as another time the
Monad evaluates the next function so how
this may not be clear you have to think
about it later but but how do they
compare
they're almost duals so with a monad a
function returns a monadic value and
it's a hint to the composer how to apply
the next one maybe many times maybe
never if it's a filter or an exception
the composer decides with a scope
continuation the inner coat the function
we like the throw the produce that we
called the the the bottom on top of the
stack the innermost frame directly
decides how the next stage will be
executed with pause every time you call
pause it's like evaluating F again the
next the next step and it also decides
at which scope to talk to it's like the
thematic values saying this enclosing
monads don't listen to me
I want another Mona to listen to me and
this gives us great composition so we
can have the trike scope and within it
the the co iterator scope and anything
in here so the range can fall produce or
filter can call produce to produce
another element for this scope but it
can also call throw and
calls throw it's going to get handled by
the outer scope so these things are
composed perfectly with monads it's not
exactly the case you could think of a
universal Universal monadic value I
guess you could do that in closure that
you take a simple value and the context
is a map and it says my exception
context is this my IO context is that
and if the composer cares about this
particular key in the map it's going to
handle that if not it's going to it's
going to ignore it but the prom with
that is that it doesn't I check and
especially Haskell is very sadly typed
language so we use something called
modern transformers first of all they
don't really always apply and they're
very very hard to think about I know if
you've seen NASA's guidelines for
writing safe C programs say that you can
use a single pointer indirection or
doubled like a pointer or a pointer to a
pointer but not a pointer to a pointer
to a pointer that's too much like three
levels of indirection is too much and I
think the thing is the same applies to a
higher-order functions so we can have a
first order function the word higher or
defunct like second-order functions but
not third order not a function call the
function is called a function and
mournin transformers go up is four or
five and and it's very it's kind to hard
to wrap your heads around especially if
you're an imperative program and finally
these scopes type check and the time
check perfectly so they compose
perfectly and they type check perfectly
with what type with what type checker
with Javas check six checked exception
type checker so we can say that every
function that might pause on a certain
scope will declare that it pauses on
that like a Java checked exception so F
pauses say on exception and the compiler
is not going to let us to call F outside
of a try context and what's a signature
of try so F says okay I pause on
exception because I might throw an
exception and on something else say I
might produce a value and try the try
type takes away the accept and no longer
pauses on exception because it catches
it and only pauses on the other things
so they compose perfectly and they type
check
so the people are going to say yeah but
you know you have now continuations and
you have thread locals and pause and a
lot we just have pure functions and
that's true you can't you can't beat up
your functional with with economy but in
this case we preserve all of our
built-in constructs and they compose
perfectly and they type check if you
care about that and that's I'll finish
thank you if you have any question I
just want to leave this up I think it's
a great tweet I just saw recently it
certainly applies I don't know for the
best programmer it certainly applies to
me I think we have time questions yes
how your compares when you fight future
people owners because small acts and
others you have by the rules of
composition you have commanders and of
course you can cherry-pick my
collections and exceptions and come up
with a custom system that kind of does
the job well but modest violate the
sovereignty of providing as soon as you
buy to the laws and then finish for many
many other things you can use for
probabilistic calculations you attach
any contextuality of computation and you
carry it around but I don't see how you
can install a bonus powerfulness by
showing three chart three examples okay
that that's all three different examples
in the sound composition you're the
saying your approach composers when go
to each other dipping samples doesn't
compose better and more reference
formats when you open time one yeah okay
so so again so let me just say that
again the question is you've just shown
a few examples how do we know that it's
really more powerful first of all my
claim is not that it's more powerful
than monads even though I think it is
but and it's also not too terrible to
terrify doTERRA monads if you work in a
pure functional language where you don't
have loops and you don't have States and
you don't have exception you don't have
IO then Mona's are your only way and
they're beautiful it's a beautiful
abstraction but if not I'm saying
another beautiful abstraction you can do
in imperative languages now I have it's
true I haven't proved rigorously that
you can take any monad and implement
with scoped exception my intuition says
that you can I just thought of it a few
days ago but my intuition says that you
can every call to pause is like another
application of the the next monadic
function and this is something I have to
work out but I think that you can prove
that it's a strict superset of anything
monads can do and about composition
again I'm not saying it poses better
than then then monad transformers but
Mona's transformers are harder to
understand I mean I don't think Java is
going to get Monon transformers it has I
think reactive X has some but they are
very hard to understand and again my
intuition says and you can think about
it more we can talk about it later that
the ability to directly when you pause
and set that that scoped variable is
like setting the daemon out of context
and because you can talk to various
enclosing scopes at the same time you
can say now I'm talking to this one I'm
talking to that one it's like the
ability for a monadic function to talk
to various composers to various bind at
the same time since now I'm talking to
you now I'm talking to you and I don't
think it's possible with monads unless
you use the universal monad
that that is not statically that is not
statically sound yes
I think another interesting point of
comparison is the the notion of
co-routines that you have in beta this
is back in 75 so it's even before those
delimited configurations and I believe
you might may have hinted at really
viewed on V who introduced them but the
these co-routines basically in beta you
will have a component which is a special
kind of object that will delimit the
stack so you can stop your execution
suspend to that point you can resume it
from there you can talk to that a
component so the missing bit there is
that in beta you do not have a support
for searching down the stack for the
nearest and closing component of a
particular type such that you can read
this coke variable and it would actually
be interesting to add that I forgot to
say that what I shown about scoped
scoped continuations is is going to be
in Java Java 9 probably we already have
working with an unmodified JVM working
example for Java 7 and 8 but it's not as
transparent it's going to work
transparently in Java 9 yes so the call
spoken continuations but from of two
examples I couldn't tell if the scope
was
lexically scoped how you know there are
like these okay so there do you declare
it at the top or just like just like
exceptions just like the try block with
exceptions exactly the same but the
another piece of code that is referring
to the same name which is declared in a
parallel Asian code right so it's it's
just like think about it as two two
enclosed tribe locks on the same
exception type so I so see you there no
to the X and to the nearest one just
like exception so if this one catches
illegal I don't know number format
exception and this one catches a legal
number form an exception to then when
you throw it from here it's going to be
caught by the the the nearest enclosing
scope the innermost and closing scene
uses this anime that's right right I
think well that's that's in text think
the way it's implemented so X is not X
is not really X's is a global name think
of it as a type name so it's actually
implemented as a tightening I just
didn't want to introduce oh it's the
types here okay all right that's what so
each of these scopes is actually a type
like a catch like trying catch for a
certain exception type
okay so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>