<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tijs van der Storm - Rascal: the Swiss Army Knife of Meta Programming - Curry On | Coder Coacher - Coaching Coders</title><meta content="Tijs van der Storm - Rascal: the Swiss Army Knife of Meta Programming - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tijs van der Storm - Rascal: the Swiss Army Knife of Meta Programming - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ffx7VtEOSx4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I guess that's the sign right so hello
everybody welcome is this mic working
okay
okay excellent my name is Tash
vohnostrum I'm a researcher at the
Center for mathematics and computer
science in the Netherlands CWI I'm here
today to talk about our programming
language that if we've developed over
the last seven years
it's called rascal and it's a
programming language for meta
programming so if you look at meta
programming on Wikipedia it actually has
a quite nice definition quite general
it's basically programs that consume
process or analyze and maybe produce
other programs so it's really just
programs where some kind of code goes in
and something else comes out and
sometimes this is also code right so and
these things are quite well-known within
software development you probably are
all using meta programs so we can think
of called visualizers refactoring tools
but also smell detectors or compilers
interpreters tools that analyze metrics
of other programs and so on so basically
there is a large space of tools that
just do something with source code and
most of that's also code right so and
these are metre programs so if you look
at the tools that are available to do
some kind or some form of meter program
programming there are various sort of
independent tools that you could use for
different kinds of things right so
really simple lexical meter program and
could be done for instance in orc more
complex stuff you would use endler or
something if you just want to search for
some string you would actually use grep
or but if you need more complicated
queries over sort of facts you write
from resource code you might want to use
SQL so all these tools and other tools
they are very good at one particular
thing and the problem is that most of
the refactoring or meter programming
applications I've shown on the previous
slide often use the combinations of
features some
lexical processing some analysis some
parse tree or structured rewriting and
so if you use different tools to do that
then they you get an interoperability
problem right so they don't integrate
very well so Resco is our attempt at
building a sort of unified language that
addresses all these concerns in a single
language where these diverse concerns
are all expressible and sort of easy to
combine in a comprehensive tool so yeah
so to make this a little bit clearer
let's let's have a hypothetical maybe
even pathological example where you do
some grip on some on program on some
source code you get some results of the
matching regular expression you want to
import it into SQL to do some querying
or joining or group by whatever and then
you want to export that to some orc
script to actually generate something
else from it alright so and here you can
easily see that this is not a really
nice way of I mean there is no nice way
to sort of in interconnect these to this
independent tools so an in Resco we want
really sort of address the whole scale
of these things so that you're in one
language using unified representations
to do all that okay so what is rascal
it's basically a functional programming
language but with curly braces so it
looks like it looks like Java to some it
even looks imperative but mind you
underlying all data is immutable so
there are no aliasing problems and so it
runs on the JVM so if you were at the
keynote this morning you know Dave
Noland saying that closure tries to go
where the main stream goes we have the
same ID so we want to sort of take
benefit from a large Java ecosystem that
is around that so we run on the JVM and
have also easy interaction with anything
in Java we have a command line ripple we
also have an IDE based on the Eclipse
you can download it if you want the
source is get up and we
an update site for Eclipse and and
downloading the command live version
just a single jar so if you hate IDs you
can still use fresco okay so how do we
achieve this integration well basically
you could say actually that Resco is
sort of it's a general-purpose
programming language in power it's to
incompletes and you could do technically
everything in it but it's really also
domain-specific language so we have a
lot of stuff built in particularly
designed for this meter programming
domain so for instance we have a lot of
building data types like concrete syntax
data types for concrete syntax trees
which are sort of abstract syntax trees
but you don't throw anything away
we have abstract syntax trees of course
we but we also have a datatype for
defining source locations because often
you do something with some part of the
source code in your processor and then
we have pattern matching really powerful
pattern matching constructs to do
pattern matching against all the data
types so we can write patterns against
all values that are present in in Resco
and I will show down the line using some
live coding I hope to sort of show some
cool pattern matching features and
finally to sort of address more the
analysis kind of thing like the queries
or the aggregation kind of stuff that
you might want to do we have
comprehensions overall collection types
and all collection types means sets
relations and regulations lists and maps
so that's sort of one way one aspect of
how we try to integrate all these tools
more specifically we have some I think
unique language features so one of them
is integrated syntax definition and
parsing this means that you can write
context-free grammars as part of a
rescue program and get your parser for
free we have built-in primitives for
tree traversal you can imagine that in
many source or code transformations you
have to traverse syntax tree structures
so we have we have a built-in
for that we have sophisticated pedo
machine operators I already hinted at it
so this is not your grandfather's
father's peda matching but it has
concrete matching deep matching list
matching set matching I will show some
of these examples but I am afraid I
can't go into much detail there and
finally we have sort of relational data
types that allow allows you to do graph
based analysis analysis for instance
dependency graphs or control flow graphs
data flow graphs we we think that these
are very nicely represented using
relations okay so enough talking let's
write a meter program so here's a really
simple meter program you could call it a
smell detector we want to find public
fields in some java code right so we
could do grep write and write in regular
expression that matches public blah blah
blah blah blah blah and then you get a
list of results but
there's the risky this is very imprecise
right because grep will also match in
comments were in string literals and
maybe there are different forms of
declaring a public field and you have to
do right horrible
regular expressions so this is very
low-tech but no we're not going to do
that so we could do endler you know
download the java grammar and sort of
start parsing java and then write the
visitor and have to write ugly if
statements to sort of selects you know
okay this is filled and the modifier is
public and blah blah blah
so I think that's too much work you you
may differ there but so let's see how we
do this how we can do this in Resco demo
mode so I hope this is all readable yes
okay so I have a module here defined in
rascal in our IDE it's called find
fields it we import the grammar the
context-free grammar of Java 105 in this
case I import also the library to access
the parsed
data types that are built into Resco and
I need that because I want to get the
source locations of certain sub strings
sub trees in my parse trees so I know
I'm gonna sort of write this function
which is now has an empty body but
before that I just want to show you this
so this is the repple and i've also
imported the grammar here and now here
you see a declaration or a variable
declaration that assigns the source
location to this variable source and I
told you source locations are built-in
and also the IDE knows about it so I can
actually click on it and then it will
open the file that sort of corresponds
to that source location right so this is
a simple Java file with some public
fields so of course I can also use this
source location to actually parse the
structure right so I have imported the
Java of 1.5 grammar and in that Java 1.5
grammar there's an start non-terminal
it's called compilation unit and I'm not
going to parse this source location
using that non-terminal and that works
with this notation which is almost like
a cost but if you feel like this is
costing like in Java casting and Rascoe
is parsing so that that basically sets
it off and then I give it the source
location and then I after some this is
only the first time don't worry
generating the parser
so and what you get is actually a typed
parse tree typed as the non-terminal of
that grammar in this case is to start
non-terminal compilation unit and then
down there you see actual the literal
rendering of the source code itself so
you might think okay this is just the
string right and and that's because
that's true because it's a concrete
syntax tree so it has all the
information that's there all the
whitespace all the commands is there and
you can actually see that it the repple
actually knows that this is a parse tree
and not just a string because you see
the syntax highlighting
I hope this is feasible so the keywords
are highlighted there okay so this will
be our example input to the but the
field find fields example so let's write
this code so here's this function public
fields in goes a compilation unit out
comes the list of LOC sort of
corresponding to the locations of these
public fields so since we need a list
I'm going to define it using a list
comprehension let's assume I'm finding a
field and then I want the location of
that and now I have to find all the
public fields within the parse tree of
the compilation unit I'm going to use a
pattern match for that it's a concrete
syntax pattern match and I'm writing it
like this I don't care about the type
but I do care about the field make it a
little bigger so this basically is a
field declaration and I'm going to find
it in the completion right so what this
state is using the slash it basically
means anywhere in the tree find
instances sub trees that match this
pattern this is the pattern that I'm
looking for which is a concrete pattern
so it's not like the prefix notation HT
based pattern but I'm using the language
that I'm processing right so Java in
this case and you can again see this
from the syntax highlighting this
pattern actually is a past
representation representation of a
pattern over some java source code so
it's also the matching that's happening
here is also modular layout so basically
the layout the whitespace and the
comments that are in the source file or
in this pattern are basically ignored
when matching so that you can find
really you basically are matching
against an abstract syntax tree but
using concrete syntax notation okay so
this completes the program now let's run
it
find and let's save it find fields let's
go find fields so now we run it on the
source source and and something is wrong
wait okay that was the location so make
it first three
okay so we have this list of locations I
can click on it and then you also see
that it actually accurately captures the
source location of this specific field
declaration right so the source
locations doesn't cover just resources
on the file system or something but it
really covered captures areas in your
source code okay so this was basically a
warm-up thing right it's sort of it
matches that it fits on one slide it's
almost a one-liner so what have we seen
so we have a compilation unit two types
compilation and that goes in I search
for matching notes within that
compilation unit using this pattern and
this forward slash operator and then I
met against any kind of sub nodes in
industry to find the field that is
actually public and then I returned a
list of source location in a list in a
list comprehension okay so this was sort
of easy and you could say well you know
these false positives of grep that's
good enough for me let's make it a
little harder so let's say we're now
we're gonna do - alt source to source
transformation and high fidelity means
that we want to preserve as much of the
source code layout and shape as possible
and the task now is not to just find the
public fields but actually to eliminate
them so and there are two things that we
need to be doing here so we make the
public fields private and we add a
getter method and a setter method and
then you know we forget about the
assignments that's for another talk okay
so let's do this module here so now
we're going to transform a compilation
unit so in goes the compilation unit and
also out comes the compilation unit so
let's start I'm now going to use the
traversal feature of Resco I'm going to
visit the compilation unit and since I'm
actually transform I'm going to rewrite
the class bodies themselves because I
need to insert additional methods next
to the field declarations I cannot sort
of replace one field declaration with
the new field declaration and the other
method so I need to insert it in its
context so I'm going to match on a class
body and then that starts with curly
then I also have to match the context of
the class body which is any number of
class body declaration and then when I
find a public field there now I do I am
interested in the type RDF semicolon and
then there may be body declarations
after it and closing the thing and I'm
gonna rewrite it so let's just write
rewrite it to the same thing so you see
now I've written a pattern that matches
any kind of class body using a concrete
pattern and the start of things indicate
that this is some kind of search right
so this is like this is called list
matching where I'm actually searching
for a public field anywhere in the list
of class body declarations of my class
form right so now since I do have the
context I can actually restore it so in
the in the other part of the rewrite so
I'm pulling it here but now of course I
make the field private and I'm going to
add methods right for it okay okay so
now the only thing is that I don't have
identifiers for the getters and setters
yet so I'm gonna do that in a side
condition when the setter is ID I use
this parse notation again and then I'm
skipping over capitalization out but you
get my meaning right
right okay so we've written a
transformation that visits the whole
program and anywhere it finds the public
field in some class body it will replace
it with a private field and the
additional methods so let's try to run
it so we have our input program and now
I'm going to transform the fields needs
to import again okay
Eiffel fields mpg okay so it's almost
correct right so it didn't do the last
one so and that's actually because this
visit statement the way I invoked it
here it sort of visits every node once
right so when it visits the class body
it finds the first thing and then it
forgets about the other thing so there's
one feature of this visit segment is
that you can annotate it with strategies
and there is a building strategy that
sort of keeps on applying these rewrite
rules until there are no more matches
and this is called the inner mouth
strategy so I write it like this and now
it rewrites them all right
okay so brief recap we match the source
pattern using list matching right so it
tries to find this public field inside
this list of class body declarations and
then we actually construct a new body
which is of the same type class body and
then we insert the new getters and the
new getter and the setter and change the
field declaration itself from public to
private and then we we need these gather
on satellite and fires we use the parse
cost operation to create them and then
we use the inner mouth strategy to keep
reapplying these rewrite rules to the
end okay so what we've seen now is that
there's basically a sort of perspective
here of making tools to you know improve
or better understand existing programs
right so we smelled it we've made a
small smell detector and we made small
refactoring if you could call that but
it's all from the perspective of okay
there's some existing source code that I
want to improve or understand however
there's also another use case for resko
which is actually more from the forward
engineering perspective where you
actually want to build new languages to
make software construction better and
these new languages are often
domain-specific languages or little
languages if you like and this is where
a Rascoe has a language workbench comes
in
so resk was the language workbench and
what is the language workbench well it's
basically a compiler for a compiler
compiler on steroids alright so yes you
can build your compiler but you can also
build IDE support for your language so
it basically allows you to create
integrated development environment for
your new language so and this is a good
match because if you look at language
implementation you can you see
immediately or maybe not immediately but
I think this is obvious is that language
implementation is a kind of meter
programming right if you build a
language or a compiler you need some
kinds of analysis you know
you need transformations to actually
implement your compiler or the type
checker or whatever you like so we can
actually use these meter programming
features built into rascal really well
in this domain sorry not gonna live code
the whole DSL now that would be great
but I do have a small example so this is
Martin Fowler trying to sell design
patterns he's also known for writing
this massive book on domain-specific
languages and in this book he uses this
state machine example language where you
can define sort of gothic security
protocols where you have to sort of
switch lever open a drawer and then some
secret panel opens and whatever so and
we've implemented this in rascal and I'm
going to demo that now so let's close
this one don't need it anymore so here
you can see a simple editor that yeah so
here's a simple editor over textual
representation of this state machine
language right so you have some event
declarations you have some recent events
it doesn't matter right now
you have commands defining some special
tokens that need to be sent over some
wire and then you have state definitions
that say okay whenever I enter into a
state perform these actions and there
are these transitions if certain events
happen right so this this is a simple
language but it still has already has
some quite nice IDE features right so I
have the syntax highlighting I have an
outline thing that sort of is linked to
my source code I have over jumped to
definition features I think if I just
hover over it
I get also documentation
yeah so you get over documentation if I
make a mistake somewhere then the typed
type checker static checker of the state
machine language will sort of find
errors and also mark them in the IDE
right so it's not it's not like the type
checker says no or give you some basic
errors on the command line or you get
them nicely in the IDE more advanced
features include like rename feature I
can rename an identifier here let's say
I rename it to idle and then of course
this what enables this is that basically
these transformations that I've shown
earlier they work on the concrete syntax
trees right so if you want to build a
reflex ring the first thing you need to
be sure of is to not throw away layout
and comments or at least try to do it as
much as possible because as soon as you
pretty print you're pretty print the
source code your developers won't be
happy right we know this from experience
ok final thing of of this language of
course we need the compiler itself - so
if I save it then it basically is
compiled to Java
mock-up Java but I hope you get my
meaning
ok so to conclude so this D is our
implementation I've not shown all the
features yet of it but basically
defining a concrete syntax the abstract
syntax and first function disagreeing
checking outlining hyper linking
compilation visual simulation rename
refactoring also a parallel merge
operation where you combine two state
machines together you can all write that
down in around 532 lines of code and I
think that is I mean that's not an
absolute yardstick of course lines of
code but it does show you that with
minimum effort you can get a long way
and this allows you to prototype your
language much better to iterate more
quickly
and to be quicker in showing it to users
in some sort of workable form instead of
just okay final words sir you might
think okay Resco this is cool and fancy
I hope you you think that but this is an
academic language
yes it's an academic language but we're
working on adoption in companies and
we're also using it in in teaching
courses and software analysis I'm using
it in courses on software construction
based on details we have not many papers
on rascal itself but most of the papers
that we our group produces are sort of
possible because of restaurants Resco is
for us a really strong research tool
that is behind many of the papers that
we write one particular area is that we
do corpus analysis where we analyze
millions and millions and lines of Java
code and C code but we also are used it
to build the ESL's we have students
working on red ball which is basically
an attempt to redo the ING Bank that's
getting traction their project starting
with Philips micro mechanizations is the
graphical DSL for doing game economies
little more long ago we had Derek which
was a DSL for digital forensics which is
actually in use at Dutch Dutch CSI so so
we're we're getting there and we're very
open to any user that we I mean we
invite everybody to try that we have
Stack Overflow channel etc so if you
want to know anything please contact me
okay so meter programming you have a
couple of you know tools lots of tools
to do these things but they don't
integrate very well we think that in
Resco we have sort of bound together
numerous existing language features in a
unified
whole and you can use it to do sort of
reverse engineering tasks or metal
programming and the basic key the basic
components that that sort of enable this
are really powerful pedal matching
built-in primitives for traversal and of
course built in syntax definition and
parsing and finally it can also be used
because of that as a very nice language
workbench where you can try and
prototype and iterate your language
designs very quickly including IDE
support and so on thank you very much
questions yes yes
so basically the grammar says has a
special sort of language construct for
saying this is layout right and then it
skips it so you don't have to specify it
everywhere in your grammar rules so it's
like an it's like an aspect not yet
so last homework we had a paper on data
dependent parsing and that's then you
can oh sorry yeah so it's about layout
skipping does it work for indentation
sensitive languages currently no but we
have a paper on how to do imitation
sensitive parsers and we just need to
integrate it in our main parsing
framework yes
I'm not sure completely understand I
think the question is whether you could
write transformations like this where
you go from one to many without having
specifying the context yes so yes and no
so currently this is what you have to do
because otherwise your transformations
become syntax unsafe right basically the
idea of this arrow the arrow to the
right is that thing of type T goes to
thing of type T right and if you go from
field deck to field X star or class body
Dexter that's not tie preserving so we
are constantly thinking about how we
could address such use cases in a more
less boilerplate way but for now
actually we just you have to do this
okay so how do you deal with semicolon
insertion in Java JavaScript yeah so
javascript has such a terrible grammar
right I mean the language is well it's
defined in terms of parsers which is
really annoyed right so one thing you
could if you get a grant so we have a
grammar of JavaScript but it requires
semicolons but if you make the semicolon
sort of part of the layout you you sort
of say that it's like white space or
it's like comment then basically it
doesn't matter whether you write the
semicolon here or not because it will be
ignored anyway right so ignore it but
possibly transfer it so you don't remove
them all the time I don't know where to
start oh okay
so the question is does the
transformation understand lexical
scoping the answer is no we did do some
experiments where we fixed the sort of
name capture that you could create in
the trap in the syntax base
transformation after the fact so there
is an echo 2014 paper by Sebastian about
this yes yes
you mean about prison so about
preserving comments so yeah so good
question
so if you don't touch anything then
comments are just preserved right so if
for instance comments outside this class
body they will be just be preserved I
mean in outside of this pattern so to
speak right currently the comments are
always in between things
so in this rewrite the comments that are
in between the class body declarations
would have to be manually reinserted
because basically the term construction
here sort of creates new layout right
uses the layout of this pattern to
choose for all the other locations it
will just be there because it's part of
the parse tree that is not touched so I
hope that answers the question okay yes
Jerry
not yet so this miss grant language has
a sort of yeah you could say custom
debugger so we try to also take
visualization as part of meta
programming and so this users are sort
of old not so pretty
generating pictures visualization
library but it allows you to do things
like this and and then sort of you
visualize the state machine and then you
can click on these events and then you
know stuff happens so this is part of
their 532 lines of code so there's a lot
of of stuff possible and basically I
mentioned that the final slide this
micro machinations language which is a
graphical language for game economies
that's all built on top of this
framework so I think if you google for
micro machinations you can find stuff
about it yes
mm-hmm so the question is if I use Resco
on some source code from the wild that
might not even compile what kind of
trouble would I get so yes so so our
standard library has a number of
grammars for some languages like Java
and we have also and klipse interface
for Java we have a JavaScript grammar
with semicolons
and there are so the idea is that the
grammar formalism is modular so so
there's also work being done right now
on creating a COBOL grammar which exists
in gazillion dialects so basically you
the idea is that you start with some
core Cobo and then you sort of more
generally add stuff for your specific
are we IVM something-something version
and so the idea is we're definitely
targeting this use case but the sort of
the joke is that the grammar or the
parsing is always the problem because
you don't know what the compilers do so
all grammars you find out there are
wrong all documentation is wrong all
specifications are wrong so a lot of
engineering goes into getting the
grammar right but I also must add that
it really depends on your application
right sometimes you only want to find
the if statements in some COBOL code and
then you can actually cheat and make a
simpler grammar a sort of Island grammar
that only matches parts of the the
source code yes
yeah so that would just be a different
compiler for Java that implemented in
Resco sorry the question was can you
compile Java Script to Java or the other
way around right yeah yes yeah so
basically this one was source type
preserving right from compilation unit
to compilation unit but you can easily
write a function that takes compilation
unit and produces the JavaScript
compilation units right I mean it's not
easy I mean it's a lot of work but yeah
so there was a question Alex the parser
is bootstrap so rescue itself the the
parcel of Resco is bootstrap in itself
and we're currently so what you've what
I've shown is sorry the question is it's
Rascoe bootstrap our current what I
shown you is based on the rescue
interpreter which is sort of our way of
getting off the ground we are currently
working on a compiler and and actually
this is almost finished and they're
there it's really bootstrapped because
actually the the interpreter does static
type checking at runtime but the
compiler the static type checking and we
wanted to write the static type checker
in rescue itself because well that's
what we build Resco for so we need to do
that so it's almost there yes
okay the question is whether we can have
good error messages for parse errors
currently no so you get parse error at
some location and that is a consequence
of a general parsing algorithm behind it
which is sort of messes up sort of any
kind of locality where you are in your
parser state so it's ongoing work to
make this better
any more questions okay thank you again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>