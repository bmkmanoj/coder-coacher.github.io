<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jean Yang - Preventing Information Leaks by Construction | Coder Coacher - Coaching Coders</title><meta content="Jean Yang - Preventing Information Leaks by Construction - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Jean Yang - Preventing Information Leaks by Construction</b></h2><h5 class="post__date">2017-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Y6lHNoWC7M8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">please hold your questions after the end
of the talk and when you have then do
come to the mic in the middle thanks a
lot hi everyone I'm gene and today we're
going to talk about how we can have new
programming models for making programs
more secure but I'm going to start by
saying this is not a talk about a former
FBI director James Comey I know he's
been in the news a lot lately but this
is a computer science talk it's not
going to be about him what this is going
to be a talk about though is his secret
Twitter account so how many of you have
seen the this major headline of how
journalists Ashley Feinberg found James
Comey secret Twitter account yeah it was
super exciting right so normally when
you see security and the headlines it's
about these big splashy data breaches or
hacks of skateboards or rifles or you
know ransomware of all of England's
health records but what you don't see a
lot is the subtle chains of information
leaks leading to major headlines so this
was really exciting for me because I
work on information flow security and so
I will talk about what happened here and
how why this is a very big deal so it
all began when a journalist
Ashley Feinberg couldn't resist the
challenge to find James Comey secret
Twitter account so James Comey back when
he was still FBI director said that he's
on Twitter but he didn't tell you what
his Twitter handle was and he's on
Instagram with nine followers and so
Feinberg said I wonder how long it's
going to take me to find the secret
Twitter account especially since you
know FBI James FBI director James Comey
has some tricks up his sleeve he
probably knows how to protect that
account so she started by scouring
Twitter for mentions of his son and
Twitter now has very very nice search
interfaces you can search Twitter for a
lot of things so she knew if she just
searched for James Comey there's too
much stuff but you know his less famous
family members so she searched for
I think it was Brian which is his son's
name - James Komine and so she found a
mention of his son on Twitter it
happened to be a post from his college
Kenyan so his son is a university
student and he was playing some kind of
sport and there was a picture with an
Associated Instagram post and so this
Twitter post linked to an Instagram post
and it said you know they're teeing off
with Brian Comey
and now this Instagram post didn't even
link to Brian Comey it just said his
name but enough things checked out you
know she knew that the son went to
Kenyon but then she went and looked in
the comments of the post and found
someone saying at Brian Comey
congratulations great job and this is
how she found Brian commis Instagram
account and the next step was to follow
this on on Instagram and you might say
well gene there's nothing really
interesting here with respect to any
kind of bugs why are you telling me all
this but what I'm going to tell you next
is that there was a key information flow
bug that Ashley Feinberg was able to
exploit in Instagram and this is how
Instagram revealed James Comey
so Ashley Feinberg goes to follow Brian
Comey and you know he is James Comey son
so he has a protected Instagram account
and then and the suggestions there shows
up a bunch of Comey family members who
all use their real names and then this
very mysterious reynold neighbor so it
turns out that Reynold me bar is the
name of a theologian that Comey wrote
his senior college thesis on and nine is
exactly the number of people James Comey
said that he was following and this
checked out so it turns out James Comey
is not so sneaky he uses the same very
creative anonymous handle on Instagram
as he does on Twitter there are some
very key important people following reen
old neighbor on Twitter who don't just
follow everybody and so this is very
likely James commis odd Instagram
account this is very likely James commis
Twitter account and now let's talk about
why this wasn't just about
Feinberg being clever but why this is
about Ashley Feinberg exploiting an
information leak and Instagram so what
we have here is the suggestions that
Feinberg got were very likely based on
follow information but on Instagram the
following firm ation should be kept
secret in a protected account until the
follow request has been accepted and so
what happened here was that Instagram
has this they don't have an explicit
contract but when you go to someone's
profile if you're not following them yet
then you shouldn't be able to see their
photos you shouldn't be able to see who
they're following but what's happening
is that Instagram is allowing this
information to leak through
recommendations and in fact also in the
spring class I was teaching one of the
students made $1,000 from the class
because Instagram was also leaking
secret photos through email alerts so
they sent an email saying please come
back on Instagram here are all the
photos you can see he saw the students
saw some private photos of his high
school wrestling coach he said oh cool
let me click on that want to click on it
he's not actually supposed to see these
photos and so the fact of the matter is
when you just are viewing these
Instagram accounts through the profiles
themselves it's fairly easy to protect
this information but when you have
search interfaces when you have email
updates when you have recommendation
algorithms all this becomes a lot harder
and so in this talk I'll first talk
about what is information flow and why
is it so difficult to get right then
I'll talk about my work on factoring out
information flow policies from the rest
of the program and then I'll talk about
well we have all these nice solutions
for protecting these information flow
policies within an application run time
but in real applications we interact
with databases and so what about the
database and then finally all of the
things I'll tell you about in the
beginning of the talk is based on a
dynamic runtime approach there are
overheads when you do something
completely at runtime so I'll talk about
our ongoing work about how can we throw
these runtime overheads away
so the main contributions that I'll
describe include a runtime approach for
policy agnostic programming for
information flow that we've implemented
as a embedded domain-specific library in
Python and as a web framework built on
top of Django and then our static policy
agnostic system is built on top of
liquid haskell and a system called lifti
and we're also currently working on Pina
which is a policy agnostic web framework
built on top of the yes ID framework in
Haskell alright so I'll start by talking
about what's information flow and what's
hard so the problem that we saw with
this Instagram example is that
implementing checks and filters across
the program is error-prone so on
Instagram you have your follow list you
have your follows of follows you have
what's hot on Instagram and they're all
being feds of this recommendation
algorithm and they're supposed to be
shown to people like Ashley Feinberg but
what happened here was we had a missing
check your follows list should only be
visible to the followers and one can
imagine if they miss the check they're
probably they also missed the check that
follows the follower should also adhere
to individual policies and in some ways
we really don't blame the programmers
because it's very easy to accidentally
leave off some check on some piece of
information that you're feeding to your
recommendation algorithm to make sure
that all of the information is being
shown as it's supposed to and we can
imagine that it gets even more insidious
with a fancy recommendation algorithm so
you can imagine that they're you know
and in the future or even now you have
all these programmers implementing all
these heuristics for what what should
get recommended to someone for who they
follow and only one of the rules is
whether the other user is a member of
some follow list then you add them to
the recommendations list with some score
here we have four and here it's
particularly insidious because the other
users profile and all that information
may be public but the fact that they're
getting added to the recommendation list
based on follow information is what's
secret so this is called this is what's
called an implicit flow with information
flow so your check that determines
whether some public information is being
added to a list is what's protected but
the actual information going out of the
system a list of user names and profile
picture or something like that
that's actually all allowed to be seen
and so in order to make sure that these
kinds of leaks aren't happening you
really have to track how information is
flowing across the program so how all of
your results are being computed and then
of course there's the potential that
other user might have its own policies
so in order to make sure that
information flow policies aren't being
violated the programmer has to track how
values are flowing through the program
and also what the Associated Valley
policies for all these values are and
there are many ways that information
flow bugs can leak secrets
so recommendation algorithms as I
mentioned are just one of them search
interfaces are super dangerous so if you
have you seen a lot of these papers
about information flow a lot of them go
something along the lines of that you
know in the hot crop conference
management system or some other
conference management system since
conference management systems are the
one piece of software that paper
reviewers are guaranteed to have read
you know there's a search interface
information leaked this way um and also
basically any time code does anything
interesting with secrets there's this
potential that the interaction of
sensitive data with the code can leak
information and this isn't surprising
because the challenge we have to deal
with is what people call policy
spaghetti so here I show two screenshots
of code from the hot crop conference
management system which as I said is the
canonical case study for a lot of
information flow research and what I did
one day was I looked at all of the code
that is associated with policy checks
and I've highlighted those here and so
these are checks that look at things
like who is the viewer
they a reviewer what's their role in the
conference and also things like what
phase of the conference are we high
right now and then all of the code in
between is showing different values
based on these conditions so what you
have is these conditional access checks
intertwined with other code on and on
the left here you see the checks are
actually dominating the code on the
right hand side there are actually
dynamically generated sequel queries so
these checks are not just determining
what you're showing but they're also
determining computations that you're
doing interacting with the database and
anytime you want to implement a new
policy anytime you want to implement new
code anytime you want to fix a bug the
programmer has to worry about this
interaction of policies with other code
and here I'm just showing two files but
in at least 24 of the 82 files I looked
at the code looks something like this
and yeah looking at this code is really
not surprising that there are often bugs
whenever policies are changed and
there's the additional challenge of what
happens when policies themselves get
fancy too so if you've been using
Facebook you probably are seeing a trend
towards really fine-grained stateful
policies like only my friends can see my
location between 2:00 p.m. and 4:00 p.m.
on Wednesdays so we're not quite there
yet but you know you have these policies
that really depend on current state and
also relationships between users you can
have policies that talk about the
sensitive information they're protecting
like only people near me can see my
location and also policies that might
depend on multiple things like only
authors of accepted papers can see the
accepted paper list but only after some
final decision has been made so you can
imagine if you only kept track of the
first part of that policy you could
accidentally leak accepted paper
information before our final decisions
have been made or something like that
and so policies might depend on
sensitive values including the values
that are protecting policies might
depend on a lot of other things
the programmer has to keep track of all
this right now if they want to get
things right and the policies that
depend on sensitive values is a
particularly tricky one because the
current state of the art involves
resolving these policies in some kind of
omniscient context because how are you
supposed to get at sensitive values
without having full access to them and
so in this way policy dependencies
programmers are trusted to handle these
policy dependencies right now and then
there's also an additional challenge so
if you recall the Co I showed you before
there are many cases each of which
determines a different possible view of
the data so there's the also the
challenge that we want our software to
demonstrate reasonable behavior we don't
just want if a check fails to show 404
we can't show you anything but actually
what you want is this differentiated
behavior of your software depending on
different policies and right now the
programmers are responsible for
implementing the functionality for what
should happen if each check fails
they're responsible for implementing all
the cases of what needs to happen
corresponding to each situation and so
now you might say well Jean people have
been doing work on information flow for
decades now
why haven't they addressed all these
problems and what I'll say is that other
approaches deal with the correctness
problems when it comes to information
flow so they'll prevent programs from
leaking information but they don't
address the problem of programmer
bottleneck so there have been static
label based approaches that let you
label data and they'll prevent your
program from compiling if sensitive data
is leaking to users in any kind of
significant way
there have been dynamic label based
approaches which will let you label your
data and then at runtime track that
information so that if your program at
some point accidentally tries to leak
information it'll stop your program
either by raising an exception or
silently failing in some way for
instance not showing a certain piece of
information
and then there are secured multi
execution approaches which will spawn
two threads one for each sensitive value
that gets used one for each other value
and this way by construction of how its
executing the program guarantee that
secret values won't go where they're not
supposed to go but in all of these
approaches the programmer is trusted to
encode these high-level policies as
low-level labels about you know for a
given viewer can they see this value
yes/no so you have these super stateful
policies like only only my friends can
see my location between 2:00 and 4:00
p.m. and you have to the programmer is
trusted right now to translate that down
to Alice's trying to view my location
right now is she allowed to see it the
programmer also needs to implement
conditional access checks across the
program still so these approaches will
check that your program isn't leaking
information but someone still has to
make sure that the program is
constructed correctly otherwise the
program won't compile or there's going
to be some kind of behavior at runtime
that a runtime monitor will stop and the
programmer is also responsible for
implementing alternate behavior for one
these checks fail so and the other cases
unless the programmer just wants some
kind of 404 error or some kind of other
silent failure when the program is
running the programmer needs to make
sure okay I've handled all these cases
and so while all these approaches before
provide really nice infrastructure for
specifying what it means not to leak
information and they will prevent your
program from leaking information the
programmer is still responsible for
making sure that the program gets
constructed in a way that something
useful is happening while the program
runs
so in short existing programs existing
approaches prevent bad bad programs from
running but it's still hard to write
these good programs
so to summarize the challenges so far we
have this issue of policy spaghetti
providing a programmer bottleneck and
other approaches only providing
emergency breaks so as more and more
programs deal with sensitive information
I
single programmer has to worry about
information flow all across your program
this is really holding programmers back
policies might depend on other policies
and trusting the programmer to manage
these dependencies can lead to leak so
if you imagine programmers already have
to deal with policy spaghetti but they
also now have to deal with policies
getting more complicated am i dealing
with all the policies correctly am i
dealing with all of the dependencies
between policies correctly this is
becoming increasingly challenging and
there's also the problem of specifying
what happens when policies fail so if
you remember from the policies PID code
there's just all these cases that
programmers currently have to handle and
so if you've written this kind of code
you might be saying yes I I recognize
these problems if you haven't I
encourage you to try writing a web
application with some kinds of policies
and very quickly you might say oh my
gosh most of this web code is actually
policy code and so now I'll talk about
our proposed approach for factoring out
these information flow policies from the
program I'll first talk about the
dynamic semantics for this approach
which is what which is the the runtime
solution we have for this I'd like to
say though that we now think of our
dynamic semantics as a reference
semantics for how to think about
programs this way but we've since done
many optimizations on this and we also
have a static program rewriting approach
to get programs to adhere to these
semantics so right so bear with me and
in this part but the goal here really is
to factor out information flow policies
from the code so what we want is to
allow programmers to implement their
recommendation algorithms just as these
functions where we have code like if is
member other user follow list we add the
other user to the recommendations
algorithm we don't have to worry about
implicit flows we don't have to worry
about what the policy is on other user
we can
implement search functionality
recommendation algorithm functionality
all kinds of other functionality without
worrying about the policies so the goal
is to have programmers just write this
policy agnostic code without additional
checks and filters and for the compiler
and runtime to be responsible for
checking policies and handling alternate
executions for one policies fail or yeah
the checks fail and our main insight is
to encapsulate policies directly with
the data and have each sensitive value
contain an alternate default value that
should be used for when the policy check
fails so in our system we have these
values called faceted values that
contain a high confidentiality secret
value a low confidentiality other value
and then as an Associated Policy saying
when a viewer should see the secret
value versus the other value and these
values can now be used
oh yeah and policies are boolean
functions that take a viewer as an
argument and return whether the viewer
is allowed to see the sensitive value
and policies are allowed to depend on
sensitive values and now these faceted
values can be used as regular program
values throughout the program you can
just insert this faceted value into your
recommendation algorithm function now
and these evaluation of faceted values
yield more faceted values so what
happens is if we do a conditional check
with the faceted value what we get is a
faceted conditional and then according
to our semantics the runtime is now
responsible for keeping track of what
assumptions it had to make to go inside
a conditional branch so so if you're
doing a conditional based on a sensitive
value it keeps track of okay this was
the policy that needed to be satisfied
in order to have gotten here and if we
update something inside of a conditional
that update now gets tagged with the
same policy so here are the
recommendations list
comes the previous recommendations list
with other user for added to it or just
the previous recommendations list
guarded by the same policy that guarded
the the follow information and the
machine is now responsible for handling
policy dependencies too so we can have a
policy that says the viewer needs to be
a member of the follow list in order to
see the follow list maybe the follow
list is visible if another secret field
has value X what we do is we introduce
labels to guard the faceted values and
these policies these labels allow
policies to refer to each other and now
the compiler and/or runtime is
responsible for solving for values of
labels depending on the policies so
before what the label based approaches I
told you about the programmer was
responsible for explicitly assigning the
label values now you can think of the
labels as free boolean variables that
the runtime or compiler is responsible
for figuring out the values of based on
the policies and more concretely how the
labels get assigned from the policies is
as follows so let's say we have this
function mapping to label a so we have a
function followers can see that takes a
viewer and says that the viewer can see
label something guarded by label a if
it's a member of the follow list what
happens as we keep track of these
policies until there's a viewer and so
now Ashley Feinberg is trying to view
something so we create a constraint
based on the viewer that says if Ashley
Feinberg is a member of the follow list
that implies that our label a has to be
high and then we can figure out more
specifically what this means
Ashley Feinberg at this point is not a
member of our follow list so we get
false implies a equals high which means
that a is low and Ashley Feinberg's
shouldn't be able to to see our
whatever this label a is guarding and so
in this way the labels make sure that
all policy dependencies get satisfied
and so what we have so far is the
faceted execution mixture that any
computation that depended on a sensitive
value is now tagged by the policy
associated with that and how are
handling the labels make sure that all
of the policy dependencies get taken
into account when the values are
actually shown and what we've done is
we've modeled this very precisely using
operational semantics of the runtime and
we've proven a security guarantee about
what it means to show values in our
language and so to give you some
background about our security guarantee
I'll first review what traditional
non-interference means so traditionally
in information flow there's this idea of
non-interference which says that a non
privileged viewer should not be able to
tell the difference between any pair of
sensitive values so if you have a
sensitive value going through the
program like the sensitive list of who
Brian Comey is following that list if
the viewer is not supposed to see it can
contain Reynold Niebuhr it can contain
Miley Cyrus and the viewer shouldn't be
able to tell apart the difference
between those two lists there's a tricky
part of our language though which where
the policies themselves might depend on
your sensitive values so here we have
you you can have a policy that says you
have to be in your list of followers to
see that list of followers and so
resolving that policy itself reveal some
information about that list of follows
and so we how we handle this is we have
a modified non-interference theorem that
says that a non privileged viewer
shouldn't be
able to tell the difference apart
between any pair of sensitive values
that doesn't give the viewer privilege
so how you can understand this is that
the space of sensitive values is split
into two parts
there's the part of sensitive values
that would give a given viewer privilege
and then there is the space of the
sensitive values that doesn't give the
viewer privilege so for the followers
list there's all the followers list that
Ashley Feinberg is a part of and lets
her see the list and for those she can
definitely tell them apart and then
there's the space that follows lists
that Ashley Feinberg can't see which is
all the list that she's not on and so
what our modified non-interference
theorem says is that Ashley Feinberg as
a non privileged viewer can't tell the
difference apart can't tell the
difference between any of the space of
lists that she's not on and so what we
have now is this so so far I've told you
about a language that allows programmers
to attach policies directly to data the
labels don't get assigned by the
programmer anymore but they get assigned
by the runtime the runtime is
responsible for propagating policies and
sensitive value information through the
entire program and the runtime is
responsible for managing the
dependencies of policies on each other
and so what we did was we came up with
the semantics we implemented a version
in Scala then we implemented a version
in Python and we said very cool we have
these nice guarantees let's try to build
web applications with them we started
building a conference management system
in our Python system or actually first
in our Scala system and then we realized
oh wait all realistic applications have
this interaction with equal data bases
and we had all these nice guarantees but
as soon as we call out to the database
all of our guarantees go out the window
because our database doesn't know about
our policies and so let me first start
by talking about some of the dangers of
interacting with vanilla databases so
what you have here is
what you could potentially have is in
your database you have all this data you
might want to do a query based on a
search interface or a recommendation
algorithm that says select everything
from users where the location is equal
to cigarette affiliate and you want to
show this to Ashley Feinberg and what
you have here is potentially an implicit
flow so um your database doesn't know
that your location might be protected
you select based on this sensitive
location value maybe your users
information is actually public like I
said before but the fact that you
selected based on the sensitive value
leaks information and so the high level
takeaway is that database queries can
link all sorts of information that
they're not supposed to leak anytime
your program has a call to the database
that call needs to be aware of the
policies unless you have some kind of
strategy for dealing with this and
because our whole our whole thing before
was that we're factoring all your all
your policies in your code you don't
need to worry about the policies
requiring the programmer to reason about
policies when calling out to the
database is not really acceptable based
on our claim before and so what you can
say now is well we can just take all the
data in our database and loaded into our
run time because our run time has really
nice guarantees so why don't we just
rely on that for our properties and most
of you might know this is not so
practical you can't always load your
entire database into memory you're not
leveraging all of the decades of
optimization that's been done on sequel
etc and so the challenge here for us was
to support faceted execution when
interacting with an unmodified sequel
database and people said well why do you
care about interacting with an
unmodified sequel database you're making
a whole new programming model anyway why
not just make a whole new database but
it was really important for us to be
able to interface with unmodified sequel
because we figured if we're requiring
programmers to pick up a whole
new databases well this approach is just
never going to get adopted so what we
wanted here was faceted queries on a
unmodified database and the semantics
that we wanted was for the programmer to
be able to call save on a faceted value
right that to a sequel database have the
database store a conceptual row that
maps a primary key to some faceted value
and then when they do select everything
from users where location is equal to
Sagrada família they get a result back
that contains faceted values protected
by the policies so that implicit flows
aren't happening and there are some
naive ways of doing this so first we
said okay why don't we just store facets
in our database as strings or maybe we
can use a new database for each label
but neither was super appealing because
these ideas are either too expensive or
make it difficult to extend the formal
semantics and in fact many of our ideas
had both problems so if we store our
facets as strings there's really no way
to query inside the facets and also make
that makes extending the semantics a
nightmare and so our solution was to use
the object relational mapping to map
facets onto multiple database rows so
our key insight here was that while
people are already using object
relational mapping to maintain uniform
object representations between an
application and a database why not use
an object relational mapping to maintain
a uniform facet representation and all
of the invariants of these faceted
values so what we can do and the
specific representation matters because
it determines how much of sequel we
actually can use so what we did was we
took a conceptual row we mapped it onto
multiple database rows with metadata
about the labels so for this location
with primary key one we have an
additional column that stores the Jeebs
key and that ties together all the rows
corresponding to one facet and then we
have an additional metadata column
labels that says which facet each
row corresponds to and now when you do
the selection you'll just get the subset
of the rows that actually match on the
value but if you if you make sure that
the orm-d facets appropriately then what
you'll get as a reef faceted value is
the same policy associated with either
the location value which is sensitive or
the empty list of rows and it turns out
that this multiple row metadata way of
storing values allows us to reuse sequel
infrastructure forget all filter sort
and foreign keys so it turns out that
because you have these faceted values
just sitting in the database and if you
have this additional property that
you're handling the metadata correctly
you don't actually have to change the
way you're doing get all filter sort and
foreign keys you just have to make sure
you're writing the facets to the
database in the correct way and that
you're reattaching labels back in the
correct way aggregation is a little
trickier because if you sum across all
your rows you'll just get everything so
that has to be implemented in a special
way but we were able to not only use
this approach to extend our guarantees
in a clean way but we were able to build
a practical web framework based on this
so in a standard web framework you have
a Model View and controller where their
model describes the data layout the view
describes how the front-end should be
laid out and the controller describes
everything in between
what we have in addition now is the
programmer specifies policies directly
associated with the data model the
controller runs in an enhanced runtime
the framework attaches policies based on
the annotations with the model there's
an ORM that propagates policies and
sensitive values across the application
in database and then the framework shows
the appropriate values based on the
viewer and the policies and there's an
additional nice part which is the
framework usually keeps track of the
session user anyway and most of the time
that's your viewer and so to give an
example of policies in Jaqueline here's
what you would normally write for
in Django to specify your data model you
have a user profile you have an email
field it's just a character field so now
we have this additional so this is
actual code from our web framework so
now you have this additional function
you define for the default value Jeeves
get private email that takes the current
road user and it's not using that right
now it's just returning the empty string
and then you define an information flow
policy in terms of your current row user
and your viewer context and here this is
a snippet from our conference management
system so you're returning whether the
current row is equal to the viewer or if
the the current viewer is the chair of
the conference then they can see the
user email and in Jaqueline we have
centralized policies now so all of the
policies are in one place associated
with the model and you no longer need
policy code in the view or the
controller and I said before that the
framework can now keep track of who your
viewer is and this allows us to do a
very key optimization which is we can
make the observation that the framework
can often but not always track the
viewer and so this allows us to explore
fewer pads so you can speculate that
discussion user is probably going to be
who's viewing it and you don't actually
have to do this multi execution you can
just throw away your executions and in
the case where you're doing something
like send email to everyone in my guest
list then you can go back and do the
expensive thing so we did some
application case studies we built a
small course manager a health record
manager and a conference management
system that we deployed for a small
workshop and what we showed was that
Jacqueline reduces the number of lines
of policy code makes a code centralized
so it's much easier to audit and it also
yields reasonable overheads um and so we
did some stress test where we increase
the number of papers in our database and
we looked at the time it took to load a
single paper and to load a list of all
papers and it turns out for a single
paper Jacqueline is actually faster than
a version with manually implemented
policies in Django because for that you
have to check each policy whereas here
the policies in Jacqueline the policies
get checked all at once
and then for all papers there's a one
1.75 X overhead because the the faceted
execution does does have some overheads
in our Python implementation and these
overheads motivated our ongoing work
which I'll tell you very quickly about
but it involves a static type driven
repair for our policy agnostic
programming so if you look on our
website which I'll show at the end we
have more information about this but
basically the high-level idea is we
encode the policies as refinement types
types that can depend on program terms
specifically we encode these policies as
liquid types in liquid Haskell's the
liquid types are decidedly checkable
refinement types we use type error
localization to figure out where to
insert policies in the program and the
decidability is key because the error
localization is also decidable now and
then once we figure out what the holes
are it's a very easy synthesis problem
to turn each hole into a check and so we
have now is this procedure that is
taking a program where types where each
policy is specified once as a refinement
type and it's the compiler it's figuring
out where to insert checks and what
checks to insert and we're currently
working on building a web framework
based on this and so a summary of our
contributions is we've developed the
dynamic semantics for policy agnostic
programming we've extended this to
database backed applications and we've
been working on static type driven a
pair to support this approach the main
takeaway from this is that factoring out
information flow policies is not only
possible but reduces the lines of policy
code necessary and also has very
reasonable overheads especially if
you're doing a static program rewriting
approach and I hope I've convinced you
that as we have more code that deals
with sensitive values it becomes really
important to factor out security and
privacy policies from the code to things
I'm really excited about for the future
are doing this for statistical privacy
and also using this
approach for information flow for
securing legacy code and I'm very
excited that we can even think about
factoring out information flow and other
policies in this way and I'm very
excited to think with all of you about
how we can make these policy agnostic
approaches practical in the next few
years thank you
okay so I think we have time for one or
two questions and if there are none then
I think let's thing speaker again and
let's meet here in 10 minutes oh there's
a question oh sorry oh sorry yeah so so
the question was there's a problem with
things taking a long time and a large
data set so this is a this is a problem
that people are addressing so these are
timing channels problems there are
solutions where people pad computations
so that everything takes a long time
one might say this is not the most
desirable solution but but yeah but
there are ways where you say okay if all
if all computations take the same amount
of time then then we're not leaking
additional information and that that is
a kind of channel that could be
potentially incorporated into an
approach like this yeah good good point
okay so thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>