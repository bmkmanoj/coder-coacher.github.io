<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Silvia Moura Pina - The Programmers Guide to Ideology | Coder Coacher - Coaching Coders</title><meta content="Silvia Moura Pina - The Programmers Guide to Ideology - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Silvia Moura Pina - The Programmers Guide to Ideology</b></h2><h5 class="post__date">2017-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nAkfBzUPkb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">though I need to stay a little bit
closer to the microphone so maybe I will
sit otherwise it will be really awkward
to stand so as I was saying I'm a
scholar software engineer and I work at
solando in Berlin Germany and I'm here
today to talk to you about ideology and
how it manifests in the tools in
languages or libraries that we choose
and especially in the code that we write
even though ideology is the starting
point this talk will take you through a
lot more topics like cognitive bias
mathematics functional programming and
code quality metrics there will be quite
a few topics in common with the
professor or there's keys keynote as
well but we will see how we can connect
all these dots a bit ahead for starters
I just want to get a few disclaimers out
of the way so most of the time when I
say functional programming I actually
mean typed functional programming and I
use the terms called source code program
and software to mean source code so with
this out of the way how can we talk
about ideology when it comes to software
development so now comes oh okay
I can stand after all so what is without
doubt the ultimate definition of a good
software most of us would say correct
software and I would agree with this but
for the sake of discussion let's say
that we figure out how to do that
and it's not an issue any longer so that
can't be all we need to maintain this
correct software we need to augment it
with new functionality that was not
considered in the beginning and we will
probably need to change how it's doing
something because this is the real world
and and requirements to change so you
can find yourself in one of three
situations either the code is really
good and it's very easy to just read it
and understand everything that is doing
or the
is a copy accompanied by really
well-written and up-to-date
documentation and then you just read the
docs and match the behavior to the to
the code lines or the third situation
you have neither and you're on your own
so this is the least favorable situation
but it's also very common unfortunately
and a lot of times when you're in this
kind of situation and even if you don't
admit it to yourself as you are trying
to understand the code in the back of
your mind you start thinking in terms of
maybe less concrete metrics of software
quality and you might start questioning
the maintainability of these codes you
might even catch yourself complaining
about what was behind the choices that
were made or if you're in really
existential mood you might wish to
question the choice of programming
language you might question the
libraries that were introduced and
actually writing code is an act of
communication and communication not just
between the programmer and the compiler
that translates it to the machine but
mostly between the programmer and other
humans that will be responsible for
maintaining the code in the present and
in the future and writing code is both
an individual and a group activity and
as such it's useful to look at social
sciences like sociology or psychology to
understand this dis activity but can we
really talk about ideology when you talk
about code let's back up for a bit and
look what what role ideology can take so
the title of this talk was inspired by
the documentary film the pervert sky to
idealogy and in this film I I don't know
if you are familiar with it okay a lot
of the audience already watched you
didn't okay but it's it's a documentary
where this guy is sluggishly Zach I hope
I'm pronouncing it correctly so he's a
contemporary philosopher and
psychoanalyst
and he presents some examples from
movies that illustrate how ideology
happens and one of them is the movie day
live and this is a movie directed by
John Carpenter in 1988 that tells the
story of a guy who discovers a pair of
sunglasses that make you see the world
as it truly is and when he puts this
pair of sunglasses for the first time he
notices that a billboard that had
publicity before now displays the word
obey and another billboard has the the
sentence marry and reproduce he also
sees that paper money has the words this
is your God so through a black-and-white
filter he discovers that all media is
actually hiding these subliminal
commands to make people obey and confirm
so the metaphor here is that the glasses
that make you see reality cities
function as a filter through it you can
see through this here the ideology and
these acts says that when you put the
glasses on you see you see the order
which stains your apparent freedom so
how can i holla G be defined it can be
defined as a comprehensive set of
normative beliefs and ideas either
conscious or unconscious that an
individual or a group or society as a
whole holds so it may be a style of
thought it may be a worldview it may be
a political ideology like communism or
capitalism and while this concept is
often discussed in the in the scope of
politics or social cognition this notion
can also be applied to the beliefs that
software programmers hold so let's
imagine yet another scenario you and
your team are starting a new project and
it comes a time of picking a text tag a
language you might just make it easy on
yourself and pick something you worked
with at some of your last projects or
something that the rest of the team is
familiar with and you have your problem
solved or then again you might want to
the heap new language our framework that
everyone is raving about or you can also
go for the thing that you heard about at
some tech conference and thought it
would be cool to try out so sometimes we
get into this without stopping to think
and when a new person then joins the
team and for some reason doesn't agree
with the choices and questions them with
with actually valid reasons then he or
she hits a brick wall and eventually
just gives up and joins the force
another example of ideologies taking
over is when we go down the rabbit hole
of comparing programming languages so
these flame wars are really common and
this is a recent discussion on the
merits of Scala versus go and of course
they are also some reasonable reasonable
opinions in the middle but mostly the
programmers from one language hate on
the other and vice versa
because they claim that the other
language sucks because of XYZ reasons
but maybe we should be able to see
programming languages is more Moore's
tools and because our job is to add
value to users they will not care at
what's behind their their program they
just care about their experience so how
can we escape these never-ending
discussions so as a first approach we
might want to have something like this
basic engineering flowchart to help us
decide between alternative languages or
frame workers or or approaches or
libraries yeah then it's easy we can see
different languages solving different
types of problems and then just match
them to the problem we are solving easy
right yeah not so simple because the
classes the problems that can be solved
by one and the other alternative usually
overlap and there are a lot of factors
that go into such choice in the end and
despite these many times in our
professional lives we make assumptions
and decisions without getting the facts
right the choices we make are heavily
influenced by by our assumptions by our
biases about reality so instead of
making conscious decisions we find
ourselves pushing for something that is
in line with our beliefs and this is
where cognitive bias come is comes into
play so cognitive bias is a systematic
deviation from rationality and it refers
to very specific and predictable types
of error patterns and these these errors
happen because in our evolutionary past
we need it fast
cognitive algorithms that gave us really
quick solutions to the survival problems
we faced and for example if you see a
predator then you can't afford to spend
time thinking what to do you just want
to get out of there or fight it or it
would cost your life so the human brain
makes operations which solves these
kinds of cognitive tasks through
shortcuts called heuristics and these
work really well in these kinds of cases
research on cognitive bias was made by
Daniel Kahneman who was awarded the
Nobel Prize for his work and he explains
cognitive bias through the coexistence
of two systems in our in our minds so
system 1 is responsible for fast
unconscious and automatic decisions and
it's more error-prone because because of
this and on the other hand system 2
which is responsible for slow and more
effort effortful decisions and it's more
reliable so it's like there is a
trade-off between time and accuracy
between the two systems and cognitive
biases mainly result from the use of
thinking shortcuts or heuristics made by
system 1 but it's important to have in
mind that not all of them always lead to
wrong decisions they could be actually
the right decision in many contexts so
cognitive bias and heuristics actually
help us address problems in these
settings
leading to errors of course but when we
have too much too much information that
we need to filter through then we only
notice the most salient features of it
and we only retained
an example of this is in the
availability bias where you are
selecting things that are readily
available in your memory another
situation is when you don't have enough
meaning so you fill the gaps with the
patterns or generalities and an example
of this is the bandwagon effect where we
adopt trends that are popular without
caring for any kind of evidence another
situation is when you have not enough
time so you assume that you are right or
that the easier path is where is the
best and an example of this one is the
sound cost fallacy where you are much
more motivated to continue with things
that you've already invested time and
energy in the last kind of situation is
when you don't have enough memory so you
need somehow to save space and for
example when you make use of stereotypes
so you discard the specifics of the
situation and just rely on
generalizations you can find a really
comprehensive classification of
cognitive bias in in this cognitive bias
codex if you are interested I am just
going to refer to a few examples as they
apply to software developments so the
bandwagon effect that I that I actually
already referred to when we adopt the
coolest new approaches without analyzing
if they really fit the problems we are
trying to solve also for the anchoring
effect this is very common in estimation
when a person from a team the first
person just says a number and this
function is an anchor and the rest of
the team is gonna is not going to adjust
enough so the estimate is is accurate
and also confirmation bias shows up a
lot in testing when you write tests for
the happy path in your code and not
write enough tests for further all the
possible error instances so maybe we
want to write code in a way that somehow
protects us against ideology by starts
and
against cognitive bias so code that
optimizes for our processing limitations
as humans when when writing code instead
of thinking of optimizing for the
Machine we would think of optimizing for
the human brain as well because human
brains are not able to scale we have a
limited size in our skulls and this is
not possible so how could how could we
write is human optimized code what is
what is even human optimized code we can
argue that it is called that has the
following properties
so first separation of concerns many of
these properties are gonna are going to
sound really familiar separation of
concerns so the property of focusing on
small problems one at a time so this
reduces the complexity and makes us
focus on smaller chunks at a time then
don't repeat yourself principal
conciseness is the property of writing
only essential code essential codes and
incurring in minimal accidental
complexity also modularity which is the
property of being easy to adapt and
extend the property of means it will
reuse the same functionality in
different contexts and simplicity or
readability which is quite tricky to
define but I'll give it a try
so it's having a limited number that is
as small as possible of concepts that
you need to account for in your head in
order to read or understand a piece of
code well and naturally if you break
down your problem in two orthogonal
concerns and solve each only once in a
way that can be used across the program
you achieve code simplicity because
there are only so many discrete things
to account for and this makes sense
because this is the preferred way for
our brains to ingest complex thoughts
and by breaking it down into smaller and
smaller ideas so bear in mind that some
of these overlap or are in direct result
of each other and the list list is also
not and not
last opinion so we have seen some of
some of the principles that we can
follow to optimize our code for humans
by managing these complexity and
following these properties in the code
is already an important step in in the
right direction but maybe it's not
enough remember we want to assure that
the number of errors in our code is kept
at a minimum and we want to keep our
code simple at the same time so maybe we
want to look at a discipline that is
more rigorous accurate sorkin close
conclusive and even better if we can
express concepts and relationships in a
concise way mathematics has all of these
and mathematics has long been used to
reason about computer programs it can
help answer questions like how will the
running time of my code change with
input size or is my code as efficient as
as it could be or how should I change my
code to make it faster or use less
memory mathematics can be used for all
of this so why not
consider looking at math for good
programming discipline but is
programming a mathematical discipline
well some believe that this is the case
like this gentleman over here and if you
do then then we're all set but what
would be a good mathematical definition
of computing many of us would go for
lambda calculus and category theory but
I won't go into mathematics today much
because I'm not a mathematician either
instead the closest we can get to
designing our code bases math is through
functional programming and I'm going to
use this color language to illustrate
all of the concepts but very mind that
some of it is not actually the correct
syntax and it will probably not compile
this just for illustration so functional
programming here is programming using
immutable data and well typed pure
functions let's dig a bit deeper into
what that means
so what's immutable data
it's very simple it's when your data is
frozen in the in a single state from the
moment it's created until the end of
your program here we can see three
examples of immutable data on the third
line I create a modified version of my
immutable value and assign it to a new
name and the original value stays intact
your functions are even simpler than
that so if your function is a box and
it's only job is to map a well specified
input to its well specified output and
give them the same input it should
output the same value every single time
and through coupling these concepts with
a strong type system we are going to
explore how functional programming
pushes programmers into achieving a lot
of the characteristics that we defined
us as pertaining to human optimized code
so how does functional programming
approach conciseness and non repetitive
repetitive mess and so functional
programming builds on top of functions
as the primitive building blocks of the
language and this gives rise naturally
to the concept of higher-order function
this is a function that accepts a
function in its parameter and or returns
one as a value so that's where we get to
start doing interesting things with
functions before evaluating them and
really cool examples of higher the fact
functions in action are in the Scala
standard collections library in which
you can see how by leveraging these
higher-order functions we can accomplish
so much with very little verbosity and
very little repetition overhead so in
the filtering and the finding operation
all I did was define the one bit of
extra logic that the standard library
didn't know about which is how I chose
the elements in my new sub list and how
I picked one instance out of the list
and the rest of the logic for
accomplishing the filtering and finding
I got reused from the definition of the
standard library and this is really
concise so the next aspect
of human optimized code is simplicity
and simplicity is very prevalent in
functional programming you can
immediately notice it by the fact that
your data is immutable and it will
always have a single state so this is a
huge load to take off your mind the idea
that values can change anytime and that
you need to manage the way to value a
values change and it's it's a huge
concept to take off your minds so big
win here for simplicity another aspect
of this is perma tricity so let's look
at it needs an error at an example first
can you tell what this function is doing
or how in how many ways you could
possibly implement it given only the
type signature so this is very difficult
because in Scala there are many possible
implementations int is too powerful and
this function is exponentially more
powerful than one int parametric city is
all about providing code with just
enough power to accomplish the job and
nothing more and the fact that we give
we give up only the minimal amount of
power to a function implementation gives
us back way more power in reasoning
about what a function can actually do so
let's see an example of that so in this
example there is only one possible
implementation of process the identity
function and this is a pretty good
example of the least amount of power of
power and it's actually useful
it's not a toy implementation and we
actually make use of the identity
function in our day-to-day code in this
other example you are given a little bit
more power because you're provided with
a function the transforms a into B and
you're asked for a B and there is also
only one way you could implement that
you can always guarantee this just from
looking at a function type signature in
this third example I provide my function
with quite more power so the function
can now grab a show type class
instance for a and you can get a string
for any a and the fact that we've given
up these this much power shows up
immediately in our in our lack of
ability to predict what this function
can can do because the string type is
powerful enough that you could construct
any string value on the fly and pass it
back but at least we make sure that you
can't do anything else with I in
disguise so the take away from this is
that by limiting in the power of your
code you keep the number of concepts you
have to come forward during the
implementation and your in the usage as
small as possible and that is quite
close to the definition of simplicity we
also talked about earlier next step
modular and modularity so in functional
programming you build your codes out of
minimally powerful small units of logic
and those can only do so much by
themselves so if you are sort of put in
the situation where you have to compose
or you can't really do much that already
structures your code in a very modular
fashion even if you don't intend it to
be so and the simplest form of
composition in functional programming is
through composing the simplest unit of
logic which are functions and when you
think about your functions there's pure
transformations of typed values then
they turn into these structures like
pipes that you can assemble one after
the other so here's a more concrete is
an example of the kind of modularity
that composition allows us and this is
functional composition in this case and
here I managed to condense the J's and
functionalities in two functions one to
encode one of the JSON primitives to
string one to optionally decode it from
swinging back into JSON and using those
I can build encoding and decoding logic
for any custom data structure in my code
by simply typing together appropriate
cost functions you can see how very
modular this this is and you can extend
this with very little effort to be able
to encode or decode any other custom
data structure you might have
last but not least separation of
concerns so there are a lot of
approaches for achieving separation of
concerns in functional programming but
I'm only going to talk about one which
is borrowing very useful construct right
out of category theory and here's a
real-world example so imagine that in
your code for one reason or another you
would end up with this representation
for a security permission where you have
collections of resources that it's
allowed to either read or modify and
then you would have the use case of
having to merge several permissions into
coarser representation we could right
away start packing permissions into an
already existing collection type like
list but it's this gets really awkward
pretty quickly because it's too powerful
and then also your function signatures
that deal with permissions would have to
account for the fact that permissions
can be either type permissions or a
collection of permissions and this is
not good so a better way to accomplish
this would be to create your own
combination function that combines the
two of them so you either add it to the
permissions class if you can modify that
or find a way to somehow enrich it with
that function or you could subscribe to
an already existing abstraction from
category theory which is the monoid this
is usually implemented via a type class
and you can get it for free from a
library like cats or Scala z4 for Scala
so then you define the logic of
combining two permissions in a totally
separate manner from how it's used and
having done that you can start using it
in different ways without worrying about
about implementing so as an added bonus
even totally reuse ways of how to
combine instances of your for your that
data structure and you get your these
these functionalities for free once your
mono instance for your data structure is
in scope so you can combine two
instances
using the operator on top or you can
combine any clash collection of these as
well so those words and thoughts on how
functional programming is pushing us
towards these aspects of human optimized
code and there are plenty more that I
didn't cover but this is only actually
one side of the discussion because we
can think of many countries examples I'm
sure where this doesn't apply what if
when we're adopting programming
paradigms such as functional programming
we are still falling prey of ideology
and cognitive bias because even though
the principles that I discuss seem
reasonable in the in the beginning maybe
we would in time deviate from this
optimal mental complexity we want to
achieve so are we still within an eye an
ideology when we use the principles that
we illustrated through functional
programming or is there some practical
real-world outcome of using this
approach and to solve this I would
propose to look at some data and there
was a large-scale study of programming
languages and code quality on on github
which involved more than 700 projects in
17 different languages and so the data
was used to determine the effects of
language features on the number of
defects or errors founded in the code
and the methods used were multiple
regression clustering and visualization
so I just present here the main
takeaways from this study which are
basically three first that strong typing
achieved less defects in the in code and
weak typing then there also functional
languages got somewhat better results
than procedural languages and among
functional languages also static typing
was found to achieve less defects than
dynamic typing so we can say that there
is at least some evidence that following
the principles of functional
programming ensures that at least some
of the fundamental properties of code
quality are satisfied and that there is
some hard data on this and I would add
at the same time that we achieve code
that is optimized for human processing
so it's a win-win situation in the end
and this is the end of my presentation
thank you all and cheers to Umrah Hassan
who was co-author of some parts of this
talk and now I would like to open for a
discussion
Oh
so one of the difficulties with a study
like that I guess would be a correlation
causation kind of thing so I guess one
of the things I was wondering is in
order to get to the next so it's great
that we're talking about at least some
level of scientific rigor on this do you
think that to get really strong results
you would need to do some kind of like
study that is much more detailed not
based on a natural experiment of github
but actually kind of having controls and
things like that oh yes for sure I mean
it would be really important to maybe
zoom in in in some of these principles
and see more detailed results but this
is the only data I could find so so the
the purpose is just to open discussion
about this topic not to provide a
definite answer to Twitter oh so this
this was the point of my talk so and
there is this part of human optimized
code that is not yet scientifically
supported so it's just opening the
discussion on on this topic
Thanks um do you think there is value in
ideology in the sense that maybe it's
not all bad but I think people naturally
cluster in groups that thinks alike and
you see that a lot of value can be
created in those different groups that
sometimes have radically different
opinions so this is my interpretation it
seems it seems to me like you were
arguing in favor of functional
programming and to me it is a kind of
ideology one I like but it's also know a
lot of low-level programming types and
these sometimes they're very harsh words
for the functional people and vice versa
as well but there is no denying that in
both case they create a lot of value and
that works really well within their own
ideology so what do you think
so your question would give another talk
so I think there is in fact value in the
discussion but when the discussion turns
into favoring the person that has the
best persuasion tactics instead of the
person that has the best arguments these
can also not go so well so yes I think I
think the diversity of opinions is very
important but in the end we need to also
be careful with these kinds of things
does this reply to your question or yes
and then we are all biased as you well
pointed out
this is also an ideology and the way to
escape it is through maybe scientific
studies even though it's very hard to do
in these applied settings so I don't
have the again definite reply to your
question thank you as well
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>