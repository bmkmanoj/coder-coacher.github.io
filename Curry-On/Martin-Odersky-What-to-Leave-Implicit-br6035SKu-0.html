<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Martin Odersky - What to Leave Implicit | Coder Coacher - Coaching Coders</title><meta content="Martin Odersky - What to Leave Implicit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Martin Odersky - What to Leave Implicit</b></h2><h5 class="post__date">2017-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/br6035SKu-0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay well welcome everyone and thank you
for the invitation it's a great honor to
speak at this joint audience of Korean
and PDI one of the most exciting
conferences that bridge industry and
academia so I'm going to talk about what
to leave implicit and what that is going
to be is it's gonna be all about context
so contextual is what comes with the
text but is not in the text and
contextual context is something that we
experience all the time in our daily
lives and also in programming in
programming it manifests itself in many
many different kinds which are really
all the same route that they describe
some sort of context the current
configuration how many different
configuration management systems are
there the current scope where you are
the meaning of what an operation like
less means on the type that you have or
the user on behalf of which an operation
is performed might change for instance
require security clearance or not
generally the security level in effect
so the context is this vague thing which
is not in the text it's part of the call
stack you might say it's part dynamic
but it's not only the call stack it's
part of let's say the static environment
of the text that you are but it's not
only that and we had many many different
ways to express this mysterious things
of contexts when we all imperative
programmers maybe a lot of you were not
born then yet context was easy that was
just a bunch of global variables that
you put somewhere and if you had to
change it while you changed it and
everybody could see it context so the
problem with that of course is that it's
very dangerous because every time you
change one of these variables
essentially it's pervasive there's only
one everybody has to agree on one set of
these variables and furthermore it's
time dependents
so it gives you a hidden dependency that
essentially the update has to come
before the read object-oriented
programmers then have thought they can
do much better and they've invented a
device called monkey patching monkey
patching is essentially if you inject in
the root class object or whatever it is
is such a new behavior
it's very was very popular in early
small talks it's also popular in Ruby
and people have come to realize by now
that it's a terrible idea for the same
pervasiveness that essentially you touch
the global object because it Suites you
as a program part and then everybody
else gets to see the same thing so
afterwards people became more
disciplined and also I would say more
bureaucratic there were a bunch of
dependency injection frameworks most
well-known are Spring and juice which I
essentially both frameworks that happen
by runtime annotations and runtime
inspection there are also frameworks
based on macros and Scala space for
instance Mac wire is one of those
frameworks that is possible but it's
fairly coarse grained and it is rather
clunky that you have to essentially use
a whole bunch of annotations or XML or
whatever essentially with your language
to have something mysterious happen at
runtime that finally your code can
essentially see some dependencies that
you want to inject you can do the same
thing in in the language at least in a
language like Scala you can there's a
thing called the cake pattern that was
first introduced in the oops lab
programming language thirteen years ago
2004 about scaleable component
abstractions where essentially you have
traits that can see each other by
essentially simply overriding or
defining what the notion of self is in a
trait and that works also beautifully
until a point at some point people have
called the cake pattern the bakery of
doom
it tends to be all pervasive and you put
more and more things in your cake until
you're great you regret that you started
it so all these things are not ideal and
if by now I think we're all functional
programmers Brian's keynote
notwithstanding so the functional way of
course it's completely simple there's no
problem at all
parameterize all the things right if you
have a dependency you make it a
parameter what could be simpler than
that
well functional is definitely great
there's no side effects its types a fork
and ease be easily made type safe and
these parameterizations gives you very
fine-grained control of what you need to
achieve but sometimes it's too much of a
good thing I guess all of you when you
have started function programming has
hit this wall where you said well I need
more and more parameters my functions
become bigger and bigger bigger because
now I have to parameterize with this
other thing as well because it's created
here and I needed over here so I have to
transport it along a long call chain
along which all the functions need to
have the parameters and I have to pass
on most of these parameters annoyingly
hardly ever change you pass just pass
them from one point to another point
which is very far removed and that means
your code becomes repetitive becomes
boring and it also prone to mistakes
because you might just forget to pass a
thing over there or you might pass the
wrong thing the bigger your footprint of
your program is the more opportunities
to make mistakes ok so there's a more
direct approach which can rescue this
idea of dependencies as parameters and
that approach is to say well if passing
a lot of parameters gets tedious leave
some of them implicit and that in a
sense is what I believe now is the
essence of Scala not the way it was
designed but the way it was sort of
discovered over over the years so I
would say now if there if there's one
feature that makes Caracara
I would pick implicit and that's what I
got to talk about in this keynote
because if you look if we look at Scala
then originally it was
meant to be this synthesis between types
sorry functions and objects function and
object or any programming and in a
strongly and statically typed context
the I talked about synthesis and
synthesis really has two meanings in
this space one is that Scala combines
all these three aspect and the other is
that scarra actually does scalar
programs do a lot of program synthesis a
lot of Scala code is actually not
written by programmers but generated and
generated through this feature of
implicit so implicit SAR reading the
core here because essentially they make
the whole thing hold together so in this
talk I will take you some of the common
uses of implicit since Cara and I should
I will mention also some other languages
that have them and we'll go also through
a set of language changes for future
SCADA that will make implicit even more
powerful and safer to use so let's cover
the ground rules first ground rules are
if you do not give an argument to an
implicit parameter one will be provided
to you and eligible for being provided
are all implicit values so they must
detect with implicit that are visible at
the point of call visible basically
means that I can refer to this thing by
just naming a single identifier if
there's more than one electrical
candidate the most specific one is
chosen and that essentially ties into
the rules of overloading resolution so
it's sort of the same rules as
overloading resolution that you have
several candidates and if there's a most
specific one then you take that one and
if there's no unique most specific
candidate than an ambiguity arrow is
reported so essentially the compiler
will defend against ambiguities and say
there are two or more possible choices
and that's an error okay
originally implicit since Kara we're
sorry implicit in SCADA actually come in
two flavors there are these implicit
parameters about which are going to talk
and
also implicit conversions they are in
the sensor cousin of implicit parameters
the rule there is if the type a of an
expression does not match the expected
type B then the compiler tries to find
an implicit conversion method from A to
B and it does so with the same rules as
for implicit parameters historically
implicit conversions came first in Scala
they were in Scala from the very
beginning we're simplistic parameters
came after two or three years the
original motivation for implicit
conversions was to provide a way for a
class to implement new interfaces so the
problem was you have a class and you
have new interfaces that you define
after the class is fixed and you can't
change the code of the class and then
how do you arrange that that class can
implement an interface that the class
creator didn't think of and the way
implicit conversions help there is play
because they make it very easy to write
wrappers or adapters where you say well
I can't have the class object itself an
object itself implements the interface
but I can make an automatic wrapper that
does this implementation that was the
original motivation for increasing
conversions and they were first adopted
enthusiastically not only for that usage
but for lots of other usage by the
community but I should say nowadays
they're mostly discouraged so I'll
ignore them in the rest of this talk
because implicit parameters the feature
we're going to talk about is so much
more important and also pervasive now in
most Scala code bases so inclusive
parameters it's a simple thing like I
said well you can have an parameter
implicit if you don't give an argument
the compiler will provide it for you
that's it but it's actually quite
staggering what you can do with them so
here are some of the use cases you can
do with implicit parameters you can
prove theorems can establish contexts
can set configurations inject
dependencies model capabilities and
implement type classes in the form of
Haskell or rest or
which is the Tesla so I'm going to take
you some of these use cases and just
show you how essentially that works in
some simple code prove theorems so who
here has already used the flatten method
on lists okay quite a few so that means
they're probably quite a few scholar
programmers here so flatten has an
interesting contract it says well if the
list here is itself a list over lists so
the parameter a is a list then flatten
will essentially just collapse the two
levels and give you a single list and
the way it has us that it says well it
has this funny type signature which says
well I need an evidence that the type of
the list a is the same as another list
and a variable B with type arrow B which
is essentially free here and if that's
the case then essentially I will return
a list of B okay so how does that work
so the idea here is that we have this
funny thing this equals current equals
that's just a trait that's defined in
the library so it's a write without
anybody takes to type parameters a and B
and with that right comes an implicit
instance called is equals which says
well a is equal to a and here's my
evidence I just create a new instance of
this trait so what we see at work here
is something that academics love as
which is known as the curry Howard
isomorphism career Howard isomorphisms
as types are theorems and programs are
proofs and you see it very well in
action here so that's a type and it
represents the theorem that a and it's
the same as lists of B and that's the
proof which says well essentially is
equal of a a is equal to a obviously I
mean I can make an instance for that and
that's all you have so essentially at
this point down here is
show you that a is equals to a and
nothing more okay and the this this
technique is actually rather deep so
deep in fact that Andrew Kennedy
interview also had a paper at obscure
2004 about generalized type constraints
that essentially proposed exactly that
feature as as they claimed an essential
feature of object-oriented languages at
Uppsala 2004 and it actually turns out
that with a more general mechanism of
implicit because essentially you can use
make use of the curry Howard isomorphism
you don't need that in the language you
can write it up in the libraries so
that's a nice example of what implicit
scan do to prove theorems what about
establishing context so I guess we are
the conference here so we're all fond of
conference management systems either as
reviewers or as as authors so here I
have a very simple conference management
system and I should say that that the
outline of the system came from Nadia
Polycarp over who gave a talk at EPFL
recently about that so a conference
management system has one of the
requirements that if you have a conflict
with an author of a paper feed that you
are the author or the adviser of the
author whatever then you shouldn't see
the score of that paper previously when
we had conference PC Committee sessions
if you had a conflict you would go out
of the room and let the others discuss
we can't do that anymore electronically
so we need sort of the analog of that in
a conference management system so that's
expressed here to say well if we have
the score of a paper says well if you
have a conflict with the papers of the
with the authors of the paper then we
just make up make something up - hundred
and otherwise we give you the real score
of the paper but to do that of course
what we have to know is well who's
actually seeing the paper right now we
have to have this concept of a viewer
or of a set of viewers and that set of
yours we give here as an implicit
parameter say okay the score has takes
as arguments at paper and also the
people who can view that score now
looking at the score that's easy but of
course the score can also be used in an
indirect way for instance I might want
to see the rankings of the paper and
even if I'm if I have a conflict even if
I can't see the real score if I haven't
seen my paper somewhere up there or in
the middle or at the bottom I can sort
of diffuse what did put the score of the
paper is so I shouldn't do that either
so that means the rankings should sort
by this made-up score which essentially
is artificial and Heights the real
identity and to be able to do that they
rank rankings also need to know who's
going to see that the viewers because I
have to pass that along to the score and
then finally I could have a situation
like delegate where say well I have a
query and I want to maybe delegate a
review to a sub previewer now it's a sub
reviewer as a conflict and the sub
reviewer shouldn't see the paper either
so I have to do that and the way I do
that is that in this point here I have
to actually add the person the delegate
the person to which I delegate to the
set of yours and I run this query with
the enhanced set of views so you see the
context here is pervasive so essentially
here we have just three functions but a
real conference management system would
have many many more and the notion of
who's actually seeing this goes
basically from one end to of the system
right to the other so it basically you
have to pass these yours to almost all
the functions of a conference system so
to make that explicit would be really
boring one parameter for everything
whereas if the functions are implicit
like that you avoid the boilerplate I
don't need to pass the parameter along
anywhere and second to you you also
avoid possibilities for errors that I
have to make up these viewers or things
like that they just get passed along
automatically okay and the other
observation
that usually context is something that
you want to keep constant so the passing
along should be quiet but at some points
you might want to change it like when
you delegate so there are always these
things the context is typically not
something which is always global fixed
for the whole program but for some part
of the program sub programs you might
want to change it ok the next thing is
configuration and dependency management
what we have dependency injection
frameworks for and configuration
managers and things like that but I want
to show you a program program examples
for that because they're really special
cases of context passing so there's also
something that a design pattern called
the pass a pattern which has been
proposed by big wall for that so you can
look data the last thing I wanted to
cover was type classes as you know them
for instance from Haskell so type
classes are also a simple application of
implicit parameters so here's how that
would be done so here we have what would
be a type class in Haskell and Scala is
just a normal type order of T it has a
comparison method less which takes two
T's and gives you back a boolean now we
need implicit instances for that and
there's one which says well integers are
ordered so there's an implicit value
integers or ordered off type order of
int as you would expect and it gives you
a new object with a less method that
does they use the normal integer
comparison and here you have another one
which says lists are ordered and you
need to read that to say this side this
are ordered lists of T is ordered if T
itself is ordered so that's essentially
a conditional implementation that
demands that the element type of the
list is ordered for the list to be
ordered and then you have the usual
implementation of less on lists so what
is that constraint here that context
bound P : org that's essentially just a
shorthand for another parameter so you
say the list or implicit function would
take another evidence
namely that tea is ordered so that would
be an instance of art of tea as an as an
argument and if we can provide such an
argument the result is order of list of
tea so that's essentially type class 101
that's sort of what you want to do with
you if you do type classes okay so
that's essentially just a quick overview
of all the interesting things you can do
with implicit what I want to do now is
get into some of the new developments
because implicit have been scala was not
the first language haskell was the first
language with implicit parameters but
they were not very popular there but
after scala came out with implicit work
white a few other very interesting
implicit designs notably actor and some
of the points there are worth
essentially copying back so some of the
changes to implicit for scene for scalar
three are a stricter distinction between
parameters and conversions since
conversions are sort of not encouraged
we want to at least be very clear what
is a parameter and what is the
conversion implicit by name parameters
and then three two things I want to talk
about here multiple implicit parameter
lists and implicit function types so let
me talk about the multiple implicit
parameter lists first so one problem in
current SCADA is that implicit
parameters are a bit irregular compared
to normal parameters
because you can have only one implicit
parameter section and it must come at
the end and that sometimes leads to
awkward workarounds so here's a problem
for instance where it is confusing to
essentially see what happens so I have a
function f and it takes an implicit
context and it gives me back a map from
in to string and I write F of two so
what the system would do is it would say
well that is looks like an application
so it seems that I want to provide the
two for this implicit argument because
the currents Koran says that well if I
have an implicit function and then
provide an argument then that argument
will essentially be the the one I use
for the parameter so I would get found
in required context which is actually
not what I want because what I wanted of
course is essentially I wanted to pass
the context explicitly and then apply it
as it is a map just to the index tool to
get the argument so I can do that by
just writing s not apply to because then
it's clear that the apply comes well
from the map but it's kind of awkward
because normally we would say F dot
apply to is just essentially the same as
F of to that one explains to the other
but here that's an irregularity I have
to be explicit about it so the proposal
heat now is to allow multiple implicit
parameter lists and furthermore to allow
implicit and explicit parameter lists to
be mixed feeling X so to get that we
have to essentially change the rules of
applications in one point because
otherwise it would be really confusing
when we do that we have all these
parameter lists if you want to
essentially do then a normal application
then the question is what does it apply
to so what we what you change with the
rules in the rules is that we need a new
magic method called explicitly so to
pass anything which corresponds to an
implicit parameter we have to use
explicitly so f of two now would be okay
because we would know that the two goes
to the map not to the implicit parameter
F of CTX a context would not be okay
would say well I found the context but
that's an implicit parameter you can't
pass it like that I need a link but F
dot explicitly context would again be
okay so by that simple device if we say
passing an implicit argument to an
implicit parameter explicitly has to be
used with this syntax we solve that
problem okay so that was one of the
things which sort of brings us on a par
with the state of the art here the other
thing is the one that makes me most
excited about
the future of implicit and that's called
implicit function types so let's look at
our conference management system again
that's the whole system that you see
here in a large system I mean you could
say well okay that's nice all the calls
are nice I don't see any of the viewers
or any any boilerplate but there's still
boilerplate in that system right so I I
see still see a lot of repetition one
two three three times I pass implicitly
as viewers here and in a large system it
really gets tedious to declare all these
implicit viewers parameters having to
write implicitly as viewers a couple of
time doesn't look so bad right
but if we take another example the
compiler for the FISC the gnu compiler
for scala that we are working on code
dot c we actually find more than 2600
occurrences of the parameter implicit
CTX context and that's quite a lot so
wouldn't it be nice to get rid of them
so you see in a large system these
things typically scale up and and become
a real problem so how can we get rid of
all these implicit parameters that we
saw here well the first thing is we
massaged the definition of let's say
view rankings a bit previously it was
just here so it was a method that took
an implicit parameter so what we do now
is we make it a parameterless method no
parameter here but on the right hand
side we have a closure that's gonna one
or one you can move parameters left to
the left or to the right of the equals
by just making it a lambda on the right
hand side and because the parameter was
implicit so is the lambda so it's
implicitly as viewers and then we do the
soap so far it's purely syntactic we
move the parameter from one side to the
other an expression is what is its type
so so far the type of this thing was
viewers
list of paper a function that takes
viewers and gives me back a list of
paper that's kind of unfortunate because
it means that the implicitness here the
simplicity is less than the time so from
now on and that's the only change that
actually we're proposing is that the
type will be implicit viewers - list of
viewers so we keep the implicit okay so
that's essentially all we need on the
typed level what are the rules to
produce and eliminate those types
essentially just two rules and both are
very simple the first rule says implicit
functions get implicit arguments just
like implicit methods so if you have an
implicit function like that and an
implicit argument and you write F then
that will expand to F of a it will
essentially look for an a that fills the
slot and that will be the result and
there's a dual to that that implicit
functions themselves the implicit
closures get created on demarked so if
the expected type of some block of code
B is implicit a or to B then B expands
to this kind of implicit function that
we've seen before implicit then an
unnamed variable of type A to B so
that's a lambda a closure and that gets
created for you by virtue of essentially
having an expected type like this okay
now you could say well if the parameter
is not named how do you ever refer to it
in Scala there's a thing called
implicitly that's just essentially the
identity function on implicit that lets
you essentially pull out any any value
by its type you don't need to know the
name for it okay so once we have that
how can we change our conference
management system so what we would do
now is we would create a type alias
viewed of T which is just this implicit
function type so viewed of some anything
what you wanted to want to see is an
implicit function from viewers to T okay
and then my three functions that I've
shown before that's what they would look
like
so score just takes a paper no more
implicit parameter and its return type
is viewed of int that means it gives you
an int but an int that keeps track of
who views that it and likewise you
rankings return type is viewed of list
of paper and the body is exactly what it
was before
and finally delegate gives you a view of
T you'd of anything and it does then the
same thing as what it did before
so the nice thing now is to say well we
push things from boilerplate the
parameter lists which are very
repetitive into the return type so we
could name a feature and use the feature
from now on could say well how much does
that help me well it's definitely a
savings in space but it that we don't
stop there so then you say well you have
two or three or M implicit parameters as
as soon as I have the ability to name a
thing with an alias I can capture that
in a single type in a single name and I
avoid essentially an exploding
boilerplate that I would get otherwise
okay the other the other objection
possible objection is well how efficient
is this because after all we started
with creating a closure in each time so
creating essentially something like that
that's the thing that gets created here
and we previously we had just the method
with an implicit parameter and that's
it's actually just an additional
parameter to the method the qurían gets
collapsed by the compiler but it turns
out that actually even for that the
compiler can do a very good job that
essentially brings down the cost to zero
because whenever the compiler sees
something like this which is sort of the
output of this implicit complicit typing
a function f with a regular parameter or
not and an implicit lambda on the right
hand side it can essentially just
convert it back it can essentially give
me an alternative entry point of s that
takes essentially the implicit parameter
and short-circuit to that each time I
know they call target and that brings
the cost of implicit
just down to simple implicit parameters
okay now since this is a talk between
academia and industry I need to talk
about monads so so there's a there's one
thing some people have said well this
looks a lot like the reader manat indeed
indeed it does
so the reader Monat is a similar way
where we can essentially abstract over
the reading of a thing only where we
essentially have an alias for inclusive
function types the reader moana creates
an alias for a mo not the Moana
essentially where the where the Mona has
an action that can essentially read a
piece of context the advantage like
implicit then is that the reading is
abstracted in a type so you can be more
concise but I believe that actually
using monads for reading is like
shooting sparrows with cannons because
monads are actually a fairly heavyweight
thing so monads are used typically for
sequencing doing interesting things with
your control whereas here there's no
sequencing is I have a program whatever
does doesn't matter I just have to
inject this thing that the program can
see this other thing somehow so if we
compared the efficiency and conciseness
of implicit function types with the read
Amanat the conciseness is the same but
the advantages they don't force you into
the melodic side with sequencing the
huge advantage is unlike monads implicit
functions are fully composable so you
can essentially have a subset of
implicit functions that inject arguments
into using and then you use another one
and all the plumbing is completely done
automatically where for for Mona's
that's where the acrobatics starts
that's where lifts and closely and all
these things to essentially plump these
modern things together
no acrobatic needed whatsoever it's all
behind your back and automatic and it's
also much much faster so we measured on
Scala then found that actually this way
of doing things is more than seven times
faster than the read omona so that's
that's significant okay so I talked
about monads and now I want to sort of
go on the other side of the fence and
talk about something terribly applied
and
paratis and functional people would take
objections so the Builder patterns so
some languages have a cool thing like
this for building the yourself so what
you want to end up with at the end is
something like where you say table and
then a row and then you have two cells
and another row and two cells and it's
all including prices and curly braces
what what does it mean effects right
that's where you do statements so behind
the back there's something adding itself
to some Builder or things like that okay
so that's natively supported in
languages like groovy and Catalan via
something they call accordion cause
receiver function so there's a you could
say well the special language features
that sort of have been invented to make
this possible
now implicit function types seem to be a
very versatile thing so let's see
whether they can do this and in fact
they can do this quite well so that's
how you would implement the Builder
pattern in Scala no no further no magic
needed whatsoever so you can all do it
in the library with implicit function
types so let's see let's maybe take it
from the bottom so a cell here so that's
executed in a block so it has to have a
side-effect
so if it cell then essentially what it
does is it adds itself to the role that
contains it how do you know what role
should be what role contains it well
make that an implicit right so it's the
row that is the context that's literally
the context in this thing it's the thing
that encloses the cell that that we are
writing okay so what about droven so Rho
has to essentially the top of the role
thing is to execute this block here
right so that's what Rho needs to do so
what it needs what it does here is it
sets itself up it sets up a new role as
an implicit Val it calls init and it
passes along this well in the implicit
parameter type so that way cell gets to
see what roles of this and finally it
does the same thing as cell it adds
itself to the table which
expiring visit parameters and finally
table essentially that's a top-level
function there's a similar trick with
the implicit initializer so it just
shows you that essentially implicit
function types really they have a lot of
variety a lot of power but you could say
well isn't isn't it all very complicated
and complicated means you could see that
as several dimensions can you do
complicated stuff with it definitely
should you exercise restraint definitely
but the question is well are the basics
complicated and here I can put on my
academic hat and I will try to convince
you that actually it's the reverse the
basis super super simple and super super
beautiful so I'll finish the talk with a
formalization of these implicit and
implicit function types as we know them
in Scala a formalization is done with
typically a mini language so we just
have a radical subset of the language
and also it looks rather more Greek than
programming languages by that's a
historical detail so what we have in our
language is we just have variables X and
we have another subset of variables
denoted as implicit variables we have
these lambdas we have applications we
have an implicit query so that would be
written implicitly in Scala literally
and we have a length both explicit and
implicit okay and then the types of our
language are the usual so the basis is
system of a system called system F so
where we have type variables we have
function types and then we have also
polymorphic function types also from
system F and finally that's the only new
thing we have these implicit function
types so we wrote implicit t a arrow b
now i write t question mark arrow
t so that's the same thing as my
implicit functions okay so for the
typing rules I will use something called
a bi-directional syntax so I have to
typing judgments the first one says well
this gamma is an environment so
essentially that tells me what I know
from the context then I have a term and
I say well this term has that type here
and that direction would be synthesis I
look at the term and I produce a type
that this term has and the other
direction is called checking where I say
under this in this environment this I
can verify that this term has a given
type T of the difference between
synthesis and checking is in synthesis i
compute the type in checking I know the
type beforehand okay so let's look at
the core of what we have here and simply
typed lambda calculus functions so these
are the rules that we all know and love
form simplified typed lambda calculus
it's a rule for rule for lambda the rule
for application where the lambdas as
well if we the argument the parameter
type has type s under this assumption if
I can prove that T is type T then the
lambda has type s arrow T and
application says if a function has type
s arrow T and its argument has tide s
then the whole thing has type T so
that's a classical rule of rules of
lambda calculus that you know the
directionality here just says that
because I don't write the parameter type
here so I have a really an anonymous
function without a type I the type has
to come from outside so that's why the
direction goes here like that on the
other hand for an application I can
produce the type by itself because
essentially producing the type here
means producing the function type once I
have the function type I can use it to
type check the argument okay so these
are the classical rules what about the
implicit ones the implicit ones are
exactly like the classical rules except
that there is no argument and there's no
lambda so it's all the same term T so
here I say well if the term T has an
implicit function type we basically make
up an implicit closure and to type check
that it means we have to make up fresh
implicit variable of type s and
objective term of type T and if that
succeeds the term will
have this implicit function type on the
other hand for the elimination if a term
has an implicit function type and I can
produce a my query my implicitly
operator produces a value of type s then
the same term t has type T so it's just
like application and abstraction except
that it's not syntax directed it's
always the same term T ok now there was
this operation here the query operation
so how do we deal with that
so query is essentially just a form of
bar so that's the bar rule which is also
standard to say well to say the type of
a variable X is whatever it has in the
environment and for the query it's
slightly different to say if I have a
query and I want to get an implicit
value of type T then any variable Y in
the environment would qualify I just
pick a variable Y in the environment
that essentially has the right type key
that's ambiguous so in this system the
the the calculus is ambiguous but you
can make it unambiguous by essentially
imposing additional rules which variable
Y will be taken and finally we need two
rules for that so the here's the first
one which is also completely standard to
say if we have a rule like this then we
we essentially type check the term first
given the type it has and once we have
that reported in the environment and
type check the right hand side you might
ask why do we need let's why we need
left because our lambdas don't have
types so the types have to come from
somewhere and the idea is that the types
come from the lens that's really very
very analogous to what people would
already do in Haskell where essentially
if you define a function you first write
out its type and then you write out its
value so writing out the type of a
function would be precisely that thing
here and writing out the value would be
that thing here and that's that's the
part that uses it okay so that's the
explicit let that essentially
corresponds closely to normal a
programming the implicit lattice
exactly the same only that essentially
we define a query operator here we say
we don't we don't bother that's an
implicit value and again we just make up
an implicit value in the environment
because we don't have a name of it we
just make up an implicit very good
so almost done let's see what this whole
thing is altogether so I've basically
shown you all the essential rules of the
calculus and you just throw them on one
slide here you see that essentially it's
very symmetric on the intro thing where
we introduce all the types of it for
each type we have a rule that introduces
it they are all checking rules on the LM
side they're all synthesis rules there's
a bar and a let for both exclusive and
implicit values and that's basically
there's one thing that I won't just want
to draw your attention to and that's the
the last rule which is called stitch so
typically in a bi-directional type
system I have essentially one synthesis
rule in one generation rule for
everything so here it's actually
different for every construct has either
a synthesis rule or a generation rule so
I need to have one way to essentially
combine the two and that's done with
this one here it says well if I need the
type and I have a type that I need I
want to check it against I can
essentially swap the error and
synthesize that same type but that rule
only holds for ours
and what what where ours while ours
we're in restricted types
there were type variables and function
types so they are not polymorphic types
and not implicit function types what
does that mean but it means that
essentially you can create an implicit
function type and a polymorphic type
only by essentially writing this type in
place explicitly as a type you can't
just make it up out of thin air on the
other hand you can eliminate
an implicit function type or a
polymorphic type only up at the Leafs
so essentially before in particular I
can't immediately eliminate a type that
I've just created so that's what
essentially what makes it work okay so
I'm almost done
this system is essentially if you squint
at it it looks very similar to system F
with essentially a lot more essentially
implicit type in sensation and implicit
parameters and it can be translated to
system F so here you see the full
translation that essentially takes the
rules we have and adds to each rule one
of these translation pieces and if you
do that and then you can do a simple
proof to say well if a program is type
checkable in this implicit system then
it's type checkable in system F the
translation is type type checker in
system F and I should finish with
references so implicit parameters have
been around since about 2000 the paper
by Jeffrey Lewis and others for Haskell
we're curiously where they were actually
sold as essentially being a way to do
dynamic scoping which they are really
are not so I think it's just one of the
greatest myths sales in history they
really are much more than than a me
scoping but at the time people didn't
know that and in Haskell I think it's
fair to say that implicit parameters are
not very popular I think we did a search
and we found exactly one library that
uses it because they are essentially
dominated by tag classes they're modular
implicit Sinnoh camera which have been
formulated quite closely to what we do
in SCADA they're act as implicit
instances also very scholar influenced
and the implicit function types are
actually almost the same as ours there's
another implicit calculus by Olivera
Shrivers water 2012 and our extended
version 2017 that one is a bit further
removed from Scala than what I've shown
you here si so it's essentially more
powerful and also less predictable and
what Scala is and it doesn't really fit
the syntax exactly and we also have a
tech report out called foundations of it
the function types with my co-authors
and that's the report number many many
people have worked on this whole thing
the Gotti compiler that got calculus the
scalar C compiler scholar Center just
wanted to list them all and credits and
thank you for being in the audience and
listening listening to the top
we have one microphone in the middle
someone closed
so I think one of the most obvious
dangers of this very cool mechanism is
that you would require programmers naive
programmers like me to think about the
execution of the type checker so you
basically run the type checker in your
head in order to understand what your
program will do so I was wondering as
far as I can see your implicit arrow
introduction role and the stick rule
would actually allow you to build an
arbitrary number there's no limit to the
number of implicit invocation you can
have for any particular syntactic
location do you have any ideas about how
you could think about it conceptually
and practically how could you actually
get sort of a bound on the complexity
that you need to handle by sort of
running the type checker in your head
parameter ect whatever so I don't
actually agree with the premise that you
need to do that and I think I have
plenty evidence that that's not true
because implicit is really a mass
phenomena in scarlet scholar community
hundreds of thousands of programmers who
use this in their daily job and they do
crazy stuff with it I find they do crazy
stuff with it but nevertheless they seem
to manage so I don't think that all
these people know how to apply typing
rules so the reason why I show the
typing rules is to show that yes even if
you want to be completely formal then
it's beautiful and it's elegant but you
can come you can understand that in a
much more ad hoc way to say well I have
an implicit parameter then yeah I will
just find an implicit argument for me
and that's it
so the that's it that's the other
question that's I think a real danger to
say well people can generate programs
that become very very essentially where
99% of the program is stuff that's
generated from implicit because as you
have seen in the Ord rule equations can
be recursive so you can essentially have
an arbitrary large graph of things and
people do that so people do fantastic
stuff for essentially serializing
hierarchies of scalar type classes into
json and essentially it's all done with
implicit and it generates a ton of code
and but it's all essentially a single
line and type size it can slow down the
Scala compiler to the single digits of
lines when you throw that because
essentially it gives you a huge thing so
one of the feedbacks that I think we
should and will do is to say that the
compiler will give feedback and say
essentially 90% of your code was
generated by implicit and here are the
top five that generate the code just
that essentially library users get a
feedback from from this because the
problem arises basically from a mismatch
of library writers who are extremely
fond of this thing and find this
incredibly cool and wonderful and
library users who are sort of sucked in
because they say well this is clearly
very useful Jason serialization for all
these things is great but then maybe
they have to pay a price that they're
not aware of so the only thing but the
one thing we can do is essentially just
give them good feedback of what what the
price it is that they are paying here hi
I wanted to know with the implicit
function type if it's possible to pass
around the function type itself without
applying with the underscore or
something and another question I'm not
sure in the inference rules I'm not sure
if you pick only implicit parameters to
apply to a function or any parameter of
the correct type the in the inference
rule it's only implicit parameters
that's how the query operation works
passing an implicit function to another
one it's definitely possible so
essentially if the expected type is a
use the same implicit function type you
can pass the value what actually would
happen by the rules if you take the
rules is that you would it I expand so
you would say well I essentially built
an implicit closure that immediately
applies itself the body immediately
applies itself to the closure argument
which is equivalent to the original
value and it's actually something that
we exploit when we do this optimization
that I've shown you so we exploit this
this invariant that essentially every
implicit value we see will be an
implicit lambda that's why we can do the
essentially compile them all away
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>