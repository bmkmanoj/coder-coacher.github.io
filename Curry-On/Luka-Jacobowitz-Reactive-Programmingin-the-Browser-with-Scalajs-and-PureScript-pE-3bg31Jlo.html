<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Luka Jacobowitz - Reactive Programmingin the Browser with Scala.js and PureScript | Coder Coacher - Coaching Coders</title><meta content="Luka Jacobowitz - Reactive Programmingin the Browser with Scala.js and PureScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Luka Jacobowitz - Reactive Programmingin the Browser with Scala.js and PureScript</b></h2><h5 class="post__date">2017-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pE-3bg31Jlo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay great my name is Luca Jacobo woods
and I am extremely honored to be here
and I'm going to be talking about
reactive programming in the browser with
Scala Janus and pure script so let's
begin first the agenda I'm going to
start with a small intro into Scala
jeaious and pure script we're going to
be comparing the benefits and the
trade-offs of choosing each language and
then I'm going to get right into the
meat and afterwards I want you to be
able to answer the question what exactly
is reactive programming and it also like
you to be able to answer why would
anyone use reactive programming and at
the end I'd like to show you like a
small app built using these techniques
in a live coding session okay so without
further ado
first things first Scala GS skodje's
first appeared in 2013 it's being
developed at EPFL it's a very simple
scholar to JavaScript compiler that
means just takes Scala source code and
compile it to JavaScript what it does
not do is take dot class files so JVM
bytecode does not work it can compile
almost all Scala code without any change
to existing code there are a few
exceptions namely multi thread code
can't work in JavaScript because
javascript is inherently single fluid
other things that do not work are
reflection because it would cost a huge
runtime overhead which the implementers
didn't want to incur yeah and then we
have pure script which also incidentally
appeared in 2013 it is very very
strongly inspired by Haskell and as such
it is also a purely functional like
Haskell which means there are no side
effects in pure script code effects are
first-class values
and some people like to say pure script
is like a mix between high school and
JavaScript but I think it's more like
90% Haskell and about 10% JavaScript and
there was 10% mainly come in because
pyramids built explicitly for the for
the JavaScript ecosystem and the
JavaScript environment what this means
in essence is that for example
JavaScript pure script arrays and true
script records which are kind of like
case classes um they correspond exactly
to JavaScript objects in JavaScript
arrays so what this means is that pure
script can compile very very almost
natively to JavaScript without any
runtime overhead and without further ado
let's look at some of the similarities
between Scala Jason prescript um and the
first thing I picked out was function
composition and you can see here on the
left hand side we have a list of one two
three and we map over it using an
anonymous function or lambda where we
map over it and say we want to add one
to each and then we want to filter all
of those that are not over or that are
not larger than three and if you look at
the Scala and pure script code
side-by-side you can see it's very
similar this is in fat in part because
Scala you can choose to use dot notation
so you could say list dot map or you can
just choose to choose to not use the dot
and just forego it in pure script we
have this hash tag which is basically a
function that takes another function and
yeah basically it it is an infix
operator which uses the like for example
here the 1 2 3 is actually the last
parameter of the map function so map is
usually map usually as first the
function and then the actual array or
the actual functor and this allows us to
to write it like in the SVO
subject-verb-object style that we're
used to from or most of us are used to
from object-oriented or similar style of
code and then we have anonymous
functions bound to variables or bound to
values in the last we left we consider
Val plus three and then we actually
explicitly need a type annotation that
says this this this function is of type
int to int so it takes an int and
outputs an inch whereas in pure script
this can be inferred and then we have a
function composition by usage of the
three greater than signs in both
languages is actually in Scala this is
cats syntax you can also do this without
cats using and then or compose and what
this does is just it's a function that
when applied will will add three and
then multiply by four so we can see here
that already Scala and through script in
a functional sense they are very similar
and then we also have some features that
are usually considered part of
functional programming and those are a
TTS in pattern matching ATT's algebraic
algebraic data types and what we can see
here is just a simple definition of a
sum type meaning that it's easier one or
the other so in the peer example here we
have data may be a and either just an A
or it's nada which is nothing um I chose
not I here as a name because in Scala
nothing already is a type so we can't
use nothing and you can see you're in
Scala this requires a lot more
boilerplate and these sometimes are for
a lot of people they're very essential
so having this done in a more concise
way is actually a very big benefit pure
script but in Scala and the new dotty
version
it's probably going to be Scott 3.0 or
we're also going to be have a very very
concise syntax for defining these
subtypes and then um pattern matching as
you can see is also very similar we just
check if our X which is of type maybe is
either just something or nothing nada
okay so um let's look at the next
picture and that is monadic
comprehensions um this is a core feature
too strongly typed functional
programming languages but it's actually
featured not not very many programming
languages have apart from pure script
Scala and all haskell Idris I think very
very few out of this Haskell family
actually have this so Scala I think is
more the outlier but what this allows us
to do is this is basically just syntax
sugar for a flat map in Scala and bind
in pure script or Haskell and what this
code does is it takes the it computes
the Pythagorean triplets for the numbers
1 to 20
yeah and here you can see it also looks
very very similar similar yeah and then
we also have the notion of higher candid
types in both languages higher candid
types are also a very rare feature in
programming language but it's they can
be very very useful and what higher kind
types means in essence that we can
abstract over type constructors here our
type F there we can see here isn't
actually type so type constructor
meaning it's a function that takes a
type and returns another type so F isn't
actually a type but F of in would be a
type or F of string and the same goes
for pure script and a functor is
basically anything we can map over so
this in the left we can define a trait
functor for any type constructor and in
the right we define we call a type class
in pure script
not going to go further into this so now
let's look at some of the differences at
first we in Scala we have inheritance
which means subtype polymorphism and
that can actually be when working with
jsapi so it can make it easier because a
lot of javascript api z' are inherently
based on inheritance and modeling these
in pure script can be well it can be
kind of tedious usually you could define
some sort of dsl but it takes a lot more
steps to get the same code working in
pure script on the other hand you have
pure script which guarantees referential
transparency through which a purely
functional type system which is really
cool in scala for example you can
partially apply a function by any
parameter in contrast that with pure
script where all functions are curried
by default meaning that trip doesn't
actually have partial application
because all functions are already of
already one but what this means is that
if you have like a function that takes
three or four parameters where the
equivalent and peer script where you
have a function that returns a function
that and then returns a function which
are the function is that we can for
example partially apply the first param
the first parent parameter when peer
script and Haskell you always usually
only well partially apply in that sense
the last parameter so it's a trade-off
in that sense in Scala we have in Scala
GS specifically we have the problem or
the trade-off that we need a wrench I'm
environment because Scala already is a
language in itself so putting that to
support JavaScript we need to support
all of the Scala semantics semantics
that are already predefined and to do
that we incur a sort of one-time cost
like I said before
contrast that to pure script where I
already said it has JavaScript semantics
which means there is no runtime overhead
at all
pure script functions just they are just
JavaScript functions and in Scala a
function is not actually a JavaScript
function it's an object and a class so
there are some very subtle differences
that need to be considered another cool
thing pier script does is that the F
type which is like Haskell's IO or
similar types can actually optimize out
calls to bind so if you have a large um
structure of permanent monadic monadic
sequencing that's up in some cases it
can be completely optimized away and
also the st monad which is a monad that
can that can use a mutable state can
actually compile to JavaScript variables
so instead of mutating mutating some
some some actual variable light like you
would do with in Scala where you can
actually have access to VARs you would
use an ST mode and in pure script and it
would compile to a JavaScript variable
which is pretty cool I think um and then
in Scala you have implicit swith
marching what we're marching talked
about it a lot this morning so I'm not
going to go further into that and then
you have string interpolation which
probably a lot of you know but it's
basically an easier way to do string
concatenation and it also supports
dynamic typing which can be well it can
be good or bad basically if you want to
work with JavaScript API s you can
either choose to provide strong types
for the API for the Java underlying
JavaScript API or you can choose to just
use dynamic typing um I would always go
for their for the strong types but if
you're so inclined you can also use
dynamic typing so it's you have some
sort of flexibility there
and the other end pure script I've
already talked about this but true
script has Hindley Miller type inference
and that can be really cool because it's
gala sometimes you end up with a lot of
type annotations and in pure script you
can write your whole program completely
without type annotation because the type
type inference system is really really
powerful I think there are some edge
cases where you need to but you probably
won't run into those another cool thing
is nested record updates and those are
like basically have a very very deep
immutable structure like an immutable
tree of sorts and you want to update
some kind of leaf on in Scala and other
programming languages this can be very
difficult basically have to copy the the
most upper object or record and then
copy all of the other as you go deeper
and then in the end you only change leaf
cue script allows syntax and that does
this very very easily without actually
without much boilerplate so it's really
nice and true script also has voc
polymorphism which is used to which is
used for xx extensible effects and
extensible records yeah I'm not going to
go much further into that so the big
question is how do we develop user
interfaces with pure functional
programming right this is this is a very
difficult question because Euler
interfaces are usually riddled with
side-effects every click usually incurs
a state change sometimes we want to do
some sort of network stuff and we can
see that user interfaces are just
riddled with side-effects or what we
usually have as side effects so one of
the answers to this is definitely not
the only one that is reactive
programming and I want you to think of
reactive programming as very simply just
programming with asynchronous data
streams um and if you think about a data
stream I don't know who-who is used some
form of data streams
Jr Pia's okay so that's a lot of you so
if you think about a stream in the sense
that maybe someone uses his mouse and
that's actually a stream of values like
for example it will emit every five
milliseconds the X&amp;amp;Y position of your
mouse or if you have your keyboard as a
screen it will emit all the things you
made it as values over time and a
representation to make this more to
visualize this is something that we call
a marble diagram and you can think of
this like the x-axis here is like the
time so this might be like I don't know
six o'clock and this is like six o'clock
and two seconds I know it long it takes
to type hello yeah and so this these are
basically values over time and this
isn't inherently useful by itself but we
can leverage some of these properties
and the first one is that streams
usually are pointers that means we can
map with them and then we get something
like this which means that we get a
whole new stream that we'll just omit
all the items we emitted before but with
this function applied in this sense it's
a two lower case so we get another
stream which also emits hello but this
time it will emitted in the lower case
and what streams also are are
applicatives which means you can combine
many streams right and that's that's
really really helpful so if you think
about it you can create a whole program
just by getting the inputs as streams
like right like so your mouse position
and your keyboard inputs and then
combine them map them and then to create
some sort of visual at the end which is
your program but actually there's one
thing missing there and that is how do
we manage state between between two
emissions here right so how do we know
at this point what came before it and
that's where the
scan function comes in does anyone know
the scan function from the Scala
standard library no okay it's also
sometimes called folds P but I think it
can demonstrate it very well by looking
at this chart um and basically what scan
is it's very similar to a fault but fold
works on data structures that are that
are finite mostly right so if you want
to fold over a list you can do that
easily but streams aren't necessarily
finite it can be infinite they can for
example Mouse positions they don't stop
at any point right we don't we want
those we want to get those continually
and work with those um and what this
does is basically it uses some sign of
combine function like with a fold and an
identity which here would be the empty
string and then we get intermediate
values so every time every time the new
emission comes from the old stream we
applied this function to the value that
came before it so we get here the pluses
here as string concatenation sadly Scala
uses plus as string concatenation
but yeah what we can see here is we are
able to hold state of our of our events
using the scan function and this is
really at the heart of reactive
programming for you eyes because having
a cumulative State is one of the most
important things okay so far so good so
you can probably all envision like some
kind of idea how you could make this
turn this into programs but it sounds
kind of academic right so how is this
how is that useful and for once because
streams are values over time it also
allows us to use time-based operations
and what this means is for example the
debounce time operator what this does is
it takes every time it emits it waits
the time you give it here in
milliseconds and looks if it's if it's
if there's any interruptions
it will reset this timer so what we can
see here is a emits and then we start
basically under the hood we start a
timer that goes 20 milliseconds and if
if there's no other emission by then we
emit the value in the resulting stream
then we have here a B and then we wait
and then we say oh okay C comes along
and then we get another 20 milliseconds
and then it emits and then with D it's
the same and what's really cool about
this is if you think about for example a
search a search functionality where you
want to send HTTP requests whenever
someone inputs something into a search
field well for the one you want this to
be true that happen as he types right we
don't want to actually press some sort
of button but we don't also don't want
to do this after every single keystroke
and if you think about this this can be
leveraged extremely easy for for this
kind of thing right so it will only if
if we have two keystrokes very very near
value will only use the latest and
that's that's really really cool just if
you imagine doing this in the imperative
way or with functional functions and
effects we starting a timer and then we
setting that and looking for
interruptions in between they vote like
if you were to do this manually it would
evolve a lot of moving parts and get
complex very easily in in reactive
programming with reactive Dreams this is
just one line and then you got it and
another cool really cool thing is a
buffer time there's lots more I'm just
going to show you these two but there's
lots more buffer time basically just
buffers some sort of values over a
specific time so if you buffer time over
100 milliseconds after single emission
will wait 100 milliseconds and then I
add all of these extra missions into a
buffer and this can be really useful if
we think about having a stream of all
some kind of different actions that a
user might want to do
so maybe we have this user and he clicks
a lot of things and then instead of
sending a HTTP request for each thing we
can then accumulate these values that we
that we buffered up and then we can send
only one HTTP request for example so we
can use this to optimize the pipeline in
that sense okay so let's check out some
code and I'm going to be starting with
pure script let's just delete everything
and first I'm just going to use this
synchronous observable and we're going
to use the create function that comes
from our X which maybe some of you are
the Rx this is just basic wrapper for
pure script over rxjs and the create
function takes an observer takes a
function from an observer to some effect
and an observer is just a data structure
that has a next function a next function
that that basically tells us what to mix
a bit next and our function and a
completed function so it just tells the
observable there that will be created
what what needs to be done so if we
create just a very simple synchronous
observable we can do something like this
one next to and what we're doing right
here is we're invoking a an effect with
dual notation um which will basically
this just sequence the sequence these
and now if you want to run this we
actually need to subscribe to this
observable and we're just going to
subscribe to the next events and we're
going to subscribe by using the log show
function which just loves it the things
we input to the console and then we're
just going to use going to give the sync
up so
and actually because now we have an
effect of an effect because subscribe is
an effect and create is also in effect
so both of these are side effect full if
so we actually have to wrap them in in
effect an F which is an IO um actually
have to join these so join is like
flatten so yeah and now if we were to
one run this lets see pop run hope it
compiles yeah and then we see we get one
two three so this is kind of cool but
it's also fairly unexcited so let's try
to do something asynchronous instead and
what we'll do here is we want to emit an
event every time every time someone
clicks on the on the dom body so we're
just going to use this function add body
click listener and you can see here it
takes an effect and it's then registers
this effect to execute every time we
press on the body of the dom and what
we're going to do is right here you're
just going to say every time you do this
we want the observer to emit one to put
this in parenthesis and now what we see
here oh yeah now it should work let's
actually browserify it to to JavaScript
and now we can look at this and we can
see our it both continuously
emit one it's still kind of
uninteresting but for example if you
wanted something like a transformed
observable we could use our async
observable and use it to to accumulate
state right for example we could map
each to I don't know plus or x-ray just
times 10 and then we could also do
something like scan or where we just
we just add them all up and then if we
do this instead and browser fight we
should get something like 10 20 30 40 50
60 so we're holding some some kind of
state in this app um it's very basic but
if you use this a lot it will actually
you can merge you can actually do there
will emerge some kind of patterns to
handle state effectively on one last
thing I wanted to show you is right now
we didn't use any types but this
actually has the type F I'm not sure if
you can see it probably not
I'm just going to add it for all II it's
an F of Dom because it access the Dom
and it also acts as access is the
console we use we use these two effects
and it also returns a subscription right
because subscribe to subscribe next
function returns a subscription and what
this means is that when we have an
observable and subscribe to it we
usually get a subscription and usually
we have to unsubscribe to this so all of
these resources that get created for
example at adding a click listener um in
order for them to be set free we also
have to tell the subscription that it's
it's done right so this is kind of
annoying in the case that we're using it
right now because we have no clue what
to do the subscription object and we
turning it from main will not do
anything at all so yeah we're going to
have to figure out how to do that so
let's go back to our slides um and
that's why there is a library called out
watch we created um an out lunch has
three main design goals and one of those
is subscription handling um
and the first is updating Dom
efficiently without sacrificing
abstraction and what this means in
essence is is if we use all these inputs
to to build up a string of our app state
we then somehow need to visualize it
turn it into the Dom and this can be
very very expensive if we have a lots of
actions per second and we always we
create some kind of Dom structure that's
why there is this function this
technique called virtual Dom which was
basically popularized by react we have
will you build these virtual Dom trees
and then once once you compare once you
want to update the actual Dom you just
compare these two virtual Dom trees and
then only update the actual differences
between the two virtual Dom trees and
this is actually really really efficient
this is why we act as the library is
incredibly fast under the hood ogwuche
uses snap Dom which is another virtual
library separate from react and then yes
the second thing I want to talk about is
handling subscriptions automatically and
this means in essence that we don't
really need to worry about handling all
of these things all of the all of the
resources will get released in time and
this is this can be done because we know
exactly when um when certain nodes get
released from the dog so we can then
remove their click listeners and yes
some of the things like this the third
is actually more abstruse but we I
really wanted to remove or restrict the
need for higher-order observables and
observables actually in this sense are
just streams um I don't think I actually
said that yet but yeah observables are
just streams and so higher-order streams
or higher-order observables are streams
of other streams and um it can get like
if you try to build an intuition for
this I I never manage to build an
intuition for this there are other
libraries that work
streams that have these and it can get
very very overwhelming very fast so we
wanted to restrict that as much as
possible okay so now that we were
ensured that let's take a small look and
this is what a small out watch component
looks like on the Left we have the
scholar version and we see here we have
div which is a small function and it
takes actually varargs
of other virtual Dom elements so here we
only have child elements but we could
also add something like ID is equal to
some ID or the class or something like
that um or any attributes that the Dom
actually supports so in here we see an
h2 with which just says input here and
then an input field where every input
string every string that there will be
input will be directly launched to the
console and this returns the type v node
and in contrast in pure script this type
is called V Dom instead which has some
technical reasons I'm not going to go
into it's also paralyzed by an effect
world type so because this component
interacts with the console is also
parameterised as as such so you know if
you have some list of components we have
lots of just different components and
you want to figure out why is something
being written to the console then you
can just check here and see okay this
this component actually accesses the
console which is a pretty cool extra
feature and you can also see here the
lack of implicit because h2 needs this
small text function to turn this into
into a text node which is well like a
Dom node which only has text and in the
scala version right here
this isn't needed because it has a
implicit conversion yes and now let's
look at some more code without watch not
sure how much time I still have but what
I wanted to do is create a small app
using the Elm architecture and as anyone
worked with react redux before okay yeah
that's what your hand so the premise is
very very similar similar to like scan
it takes a combined function and it will
it will then update the state according
to this function so we have some kind of
action type and then we have all of our
cases all of our cases will be the
different action types so for example if
we want to do to-do app we could have a
case class where we update a text field
so we just use a case class or actually
you probably can see this right I'm
sorry I'm just going to toggle
presentation mode there and then we are
just going to define this real quick
and then we also want to be able to add
an added to do to our list it's also
going to extend action um and then what
we need is actually our state type and
we're going to create a case class for
this called
stage and what's going to be is just our
current value of the text field so text
field value which is going to be a
string and a list of to do a list of to
do is which is for our purpose it's just
going to be a list of string so now we
have a state in an action now it's time
to define our reducer function and the
reducer is just going to take a state
like the old state and then an action
and it's going to return a new state
state and we can do this by just mashing
wait okay and then we can add here a
case update text with a new text we can
then just copy our old stage and set the
text field value to the text and in case
of our add to Do's we just were just
going to copy the state as well and
we're going to then update the to Do's
inside by setting them to state dot -
duze and we're going to add the state at
current text field value there we go
text field value what's which oh thanks
yeah exactly
oh there we go awesome thanks um and
then we can create something like a
redox tour using these primitives and
basically behind under the hood is just
implemented with a basic observable that
uses the scan function it's really not
much more and we can create it by we
actually we need an initial state before
so let's just create an initial state
value that's just going to be staged I'm
going to start with a empty string and
an empty list so
Nashville state and our reducer function
so this is pretty cool and now the only
thing we basically need to do is define
our view and our viewer is going to take
the state and it's going to return a
virtual Dom tree which is a V node in
Scala and we're going to do is just a
simple div we're going to add an input
field where the events actually it's
just add a placeholder real quick Oh to
do too and then we're going to all the
strings that get inputted we're going to
send them to the store actually we need
to sorry we need to map these to the
update text so there we go there and
then what we're going to do is we're
going to add another button to submit
these two dudes it's just going to say
submit and whenever we press it so on
click we want to add it to do - ensign
it to our store and then the last thing
we're going to do is create a list we're
going to use it ul and inside we're
going to bind children to our state um
actually can just use state and we're
going to want that - duze and we're
going to map them every - due to a a to
a le Li like a list item of to do and
the only thing we have to do is use the
expand them to varargs
and this should actually just work let's
see output
see what happens here
we didn't compile it yet or the compiler
failed let's just see what happens
happen here okay so waiting for Swiss
changes I'm gonna show what happened
let's just try again
okay so ah I know what happens okay see
here in the in our main function we're
still just rendering hello word that
that makes sense so we need to actually
view when we're going to start with our
initial State and now this should work
let's see
didn't compile not sure let's just say
should compile should've compiled oh
there we go okay not sure if you can see
it but this is just very simple to do AB
so I don't know cleanup laundry I can't
spell and nothing happens so ah that's
odd um I don't know I'm not sure what
what happened here but I'm just going to
copy over the the the code I wrote
before I'm not sure what the difference
here is but I'm think I'm fairly short
on time so yeah let's just try this see
you I'm going to shred and I'll really
see the difference okay see clean up
yeah and hold it talk okay so yeah this
is a very very basic intro I could talk
about out watch for hours and hours so
if you have any questions even after
this session you can just come up and
talk to me I'd love to answer all your
questions I think we're basically out of
time for questions so yeah thank you
activist
yeah just very shortly if you want to
check out more of this you can visit a
watch that get up that I or follow me on
Twitter or follow my blog to something
like that
yeah okay okay
no questions okay
I mean everything is clear okay thank
you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>