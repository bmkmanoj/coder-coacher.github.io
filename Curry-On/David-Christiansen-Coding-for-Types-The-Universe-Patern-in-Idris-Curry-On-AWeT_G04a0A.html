<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>David Christiansen - Coding for Types: The Universe Patern in Idris - Curry On | Coder Coacher - Coaching Coders</title><meta content="David Christiansen - Coding for Types: The Universe Patern in Idris - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>David Christiansen - Coding for Types: The Universe Patern in Idris - Curry On</b></h2><h5 class="post__date">2015-07-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AWeT_G04a0A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody welcome to this after
lunch talk I'm glad I was able to draw
some of you away from the illustrious
speaker in the other room just before I
get going I'd like to know who here has
done functional programming before
statically typed functional programming
okay great you're in the right place if
you hadn't done that before then this
talk might be difficult to follow I hope
that I've made a dependently type
functional programming accessible for
all of you and if I fail to do that I
apologize in advance but I'm really
doing my best who in here has worked
with dependent types in some sense okay
I hope you're not bored so the the goal
of the type of this talk is not to
present anything new and not to present
anything that I myself have created or
discovered instead I want to sort of be
a conduit between what people have
discovered in the past some of their
identities are lost to the mists of time
because there's things that have been
sort of folklore and common practice
that have been written down later and
attributed to folklore and common
practice and I hope that by seeing a
little bit of Penant types in action
that isn't the standard tutorial that
you'll be able to get sort of a feeling
for how it works I welcome questions
about sort of to clarify things underway
but I'd rather avoid long discussions
until the end to make sure that we can
get to the payoff because I think that's
kind of fun so so I may I may point you
to the end if you ask a question in the
middle so that yeah the topic today is a
particular design pattern we get
independently typed programming called
the universe before we get to the
specifics of how that works one gets a
little bit of background all of the
examples are in a language called
endurance we could just well have done
them in another language but I like
interest so interest is a
general-purpose functional language
which is to say we intend it to be a
language that you can write the same
kinds of programs in that you could
write in something like Emma or Haskell
at the same time it has full dependent
types which is to say that the language
of the type system and the language of
the runtime computation system are one
in the same we don't have a sort of
syntactic distinction between what
you're allowed to do to the left of the
colon
and what you're allowed to do to the
right of the colon it's developed by
Edwin Brady at the University of st.
Andrews but we have people all around
the world contributing myself included
and you're welcome to become one of them
afterward if you think this is inspiring
so I can start off to sort of a little
introduction to Idris and some things
independent types that you may not have
seen before then sort of talk about
universes in this framework of design
patterns sort of vaguely reminiscent of
the Gang of Four book and then walk
through three concrete examples in
increasing complexity so first off an
intro to Idris if you wanted to find a
data type in interests then it looks a
lot like Haskell so we start off and we
say we're making lists and a list is
something where you give it a type and
it gives you Backa type so int is a type
which means that you give it to list and
you get back list of int which is itself
a type so it's kind of like star in
something like a school we give it
constructors so we give it an empty list
constructor which is called nil in
deference to the wonderful tradition and
here we're saying that no matter what a
is nil is a list of a so we can have a
nil which is a list of its or a nil
which is a list of strings we can also
define the other constructor cons is how
we pronounce this it's in parentheses
because it's an infix operator and
that's a feature of the syntax and cons
takes an element in a and an element of
list of a and gives us back a list today
so this looks kind of like defining a
deity independent type programming you
define lots of things that look like a
specialized version of lists so interest
has some syntactic sugar to make this
nicer if you have your constructor is
called cons and mill you can use square
bracket and comma notation which it's
expanded so numbers here is then going
to be 1 cons to cons 32 cons 123 cons
fail but the thing up after the colon
here in the data type doesn't have to be
a type we can also we can put anything
we want there right I mean that it has
to end in type because we're creating
for creating a type otherwise it
wouldn't make sense but we can
parameterize our types over arbitrary
values so if we want to make a type of
heterogeneous lists then we can take our
and extend it with a index which is a
list of types and the attention is that
they are sort of element wise the types
of the elements in the heterogeneous
list so nil then becomes an H list of
the empty list of types and cons takes
an element of type T in H list which is
parameterized by the list of types T's
and it gives back at H list of T cons
T's note that the cons to the right is
the list cons defined on the previous
slide the cons on the left is the one
that we're defining for H list interest
lets you use the same name in lots of
different ways and it uses the types
that it expects in each position to
figure out which one you meant if it
can't find a unique solution it
complains and you have to tell it I can
then define item to be an H list of a
gnat and a string and now item is the
list containing the natural number 12
and D string high which is hello in -
which is the other language that I often
speak question and please get a
microphone so that the people at home
can hear you back there
so so you mean why why is it it's not
tea right here I said the type of the H
list is TS and not T so the parameters I
think it's a generic type would be yeah
so this T right here is a type and this
T's is a list of types which are the
list of types which are the types of the
elements of the tail of the list that
you're constructing so in this
particular so in this particular case I
have 12 cons high cons mil and so in the
O so it doesn't have to be from the same
type yeah exactly
okay this is an encoding of a
heterogeneous list by telling us with
which types we have H position that
makes sense thanks for asking things
okay and when we're doing to program
with opinion types some of our other
data types grow new features I should
probably take this phone out of my
pocket so I can write a function where I
named one of the arguments and then
whatever value I get for that argument
is named by that name in the remainder
of the function type so here we have a
declaration of operator called singleton
and singleton takes some type name T and
then it takes an element of whatever
type I gave it which is to say an
element of T and then it gives back in
each list containing precisely one T
whatever T happened to be and the
definition of this is single n of T of X
of ex-cons nil that's what the square
brackets mean here so then I can go to
my fancy interest repple and I can type
in singleton at 42 and I get back 42
which is an H list of Matt and I type
singleton string and then a string and I
get back a string which is an H list
containing a single strength
so the important thing here is that the
argument that we named can occur in the
remainder of the type and that's that's
dependent functions yeah what I don't
understand is is the first argument of
the singleton functioned yeah is the tea
and the tea has the kind type right so
if you think in kinds then you probably
confuse yourself more than necessary
okay the type of its type is type which
is the type of types okay after I was
even more confusing butt butt
butt-butt-butt type is a type like any
other it's it classifies the types and
if you're a mathematician there's some
other stuff you need to know about but
nonetheless the the the type of the
first argument of the function is T you
know the type of the first argument is
type and its name is T and why is that
written like that I don't have an
intuition that this looks much like like
like the the colon type is an is an is
an additional information for the T but
the type is still T so in in this case
the T is in fact the type but it's an
argument to the function so if I wanted
to I could write X colon T as the second
argument and actually named that
argument as well
didn't do it because there's no X over
here inside of the h list yeah so where
if i if they erased for this t colon
type then i wouldn't have any way to
refer back to the argument that i
actually got so if you didn't need to
refer to the t with just start type yeah
- t - exactly
thanks thank you for asking Oh another
question
right here thanks them I'm kind of
confused where does type live in this
case is it element of type itself like
because of types so if you if you
studied a bit of set theory or logic
then you'll know that that if that were
the case there would be a paradox so
behind the scenes of there's a sort of
hierarchy of types like type zero which
contains all the normal types type one
which contains everything in type zero
plus type zero itself type two and so
forth
and interest figures those out for you
and doesn't show them to you but it
complains if you get it wrong so it's
that avoided the paradox and it doesn't
complain in a very useful way right now
we need to we need to fix the error
message but we're making progress so
another feature that you see
independently type languages a lot
interest is no exception is this notion
of implicit arguments so if I were to
write this this this is almost a valid
Haskell program here right the I need to
change the single call into a double
colon and then it would be a Haskell
program and so we say that for any type
a it gives you a mapping from an element
of that type to an element of that type
but actually what's going on behind the
scenes in Idris is that it's taking a
hidden argument which is a type and
we're calling that hidden argument a and
then using that in the rest so to get
the identity function at natural numbers
we set a to be Nats and then we could
pass it 42 to get the identity function
at some strings then we could put in
string for a and then we'd get a string
to string function and this curly braces
instead of parenthesis says to address
that it should try to figure these out
for you whenever you use them and if we
need to get a hold of the value of the
interest filled out there then in the
pattern match Clause we can put curly
braces around the name of the argument
so we have this curly brace a and it's
actually not occurring on the right hand
that's kind of a useless finding but I
thought it was good for demonstrating
this in tax past dependent functions we
also have something called dependent
pairs so a dependent pair is a fancier
version of the pair type that you know
and love or the product type that you
know and love
and we write this in a dress with double
star and a dependent pair let's you name
the first element of the pair and then
refer to that element in the type of the
second projection so here we have the
answer is going to be a pair where the
first projection is some list of types
and we're calling that one T's and the
second projection is an H list of
precisely those types T's that we had in
the first side of the pair so if I say
that answer is has a string that as its
first projection and the answer is and
42 as its second projection this is
accepted if I had written 17 then it
wouldn't be because it's using this
exact list of types to type check the
value in the right hand side so at the
repple week we can see that we have two
projection functions kind of like first
and second what we call them get
witnessed and get proof because this
works a little bit like existential
quantification and so we can say that if
you want to get the witness out of the
answer that is get the left element we
get string in that and if we get the
right element note that the first
element is occurring as part of its type
and that's because we have the name up
here T's and the name over here T's so
what a dependent pair lets you do is
package up a bit of information and then
use that in the type of something else
so you don't have to say you know
whatever list of T's you give me I'll
give you back an H list instead it's
saying give me some list of T's and H
list for that particular one and that's
one sort of final thing there's like
there's a color scheme that we've got
from Connor McBride which might help
reading you things a little bit later
because we've only got one sort of
syntactic category for expressions in
the language if you want to have useful
coloring to help you keep track of
things then we have to do it
semantically so when we color names red
names are
two constructors of data things like
konzern ill blue things are referring to
constructors of types like lists or
integer or string or type green things
are stuff that the users defined like
functions but also just normal top level
bindings and purple things are bound
variables like from a pattern match or
elect minding or something like that and
these colors are a matter of tradition
which is why I'm using them here I know
that some people have a hard time seeing
red and green so if that gets confusing
later please let me know and I'll tell
you what's what so now that we've got
the the basics out of the way let's get
some fun coded so universes adds a
design pattern why do we want them what
what what problem is this design pattern
solving well types are values right I
can write it I can write a funk I can
use anything in a type that I can use
anywhere else there they're totally
ordinary bits of the language I can
write this function item which takes
some boolean value we're calling B and
if that was true then it's our thing and
that otherwise it's a turning a list of
mattes and that item true I can put 42
on the right-hand side because it's
reducing this expression with the value
given as the argument and for item false
I could say one two three for the same
reason so types for values like normal
ones that means we should be able to
write a function that pattern matches on
a type right just like we can pattern
match on cons and milk no we can't so so
why is that I mean it's this is
something actually trips we pull up a
lot when they're first starting with
idris so the first thing I'm kind of sad
full one there's not in the
so so you he wrote this great paper
called theorems for free which shows how
you can use type signatures to know what
a function does so if I if I see a type
signature a day then using that
technique I can see that the only
function other than the one that falls
into initial duper crashes or whatever
like the only total function with that
type is the identity but if I could
pattern match on types if you remember
what polymorphic types mean in address
it means I got this hidden argument a so
if I say if a is Matt I'm gonna turn 42
otherwise I'm gonna be the identity
function then I lose that powerful tool
for reasoning about what my programs do
based on their types so that would be an
unpleasant design decision
additionally type you're a sure goes
away I mean if I'm if I'm gonna be case
splitting on the type then at runtime I
need to actually check what type does
this thing have and that means we need
to have some runtime representation of
types and you know this is pretty
painful when your types can be pretty
big so the universe pattern is a way of
solving this if you need the pattern
match on types in some particular domain
how do you do it so the the canonical
solution here is to first off represent
the types that you want to be able to
pattern match on with a data type of
codes so the constructors of this data
type are coding for a particular type in
the same sense that an ast might be code
for an actual program that you're going
to run so in this case we might make a
universe of three particular types
called text real and integer I think the
name column might suggest how you might
use these particular codes then we write
a function an interpreter which maps
these codes to actual real types so in
this case the intercal is that
interpreter and it interprets the data
constructor text as the type string this
is where that coloring gets to be handy
it also truth reel as the type double
and interprets integer in all caps as
the type integer which is noggin in all
caps as a convention in here I'm writing
the code through data types and all caps
as well so sort of distinguish them from
things that they might otherwise look a
lot like and once you've done that you
can do a lot of interesting thing
so let's let the build on that column
example so this is cut down from a
bigger piece of code that I've got if I
might want to take that column universe
and then use that to build one of tables
so I say that tables are a type we don't
need a special feature for type synonyms
because we can just define an ordinary
definition which with the type as the
the thing that you're filling out and so
a table is then going to be a list of
pairs of strings and this column code so
in other words column names column types
the interpretation of that is our friend
H list so what I do then is take the
second projection of this pair which is
to say the actual column type interpret
that as a real type and that's what I
get and that's how I can get the type of
a particular column I then map that over
the particular list of string column
pairs that I've got which gives me a
list of types which I then plug in to H
list from that first example and now
given data we have a type or a given
that description of data we have a type
that holds that data quite nicely I
could define a schema then so I can say
that a schema for people is it's got
we've got names which is a text and then
hamsters which is the number of hamsters
you've got living in your house with you
and that's an integer and then I can
fill this out by taking the interpret
that the I reckon I can represent a
relation in that schema as being a list
of the interpretation of the schema so
in this case we can say that yes there
is a hamster in my apartment and no
there's no hamster in Edmonds apartment
and furthermore I can pattern match over
these things to get useful work done now
so I can pattern match on instances of
the interpretation just like I can do
any other data type because it in the
end it reduces to that H list type which
we know how to pattern that job because
it's got these doctors cons and nil so I
can count the hamsters in some relation
by saying that count hamsters of the
empty of the empty table is zero and
then count hamsters of the case where
the where we don't care what the name is
but the number of hamsters is H and the
rest is X's with an ADD H to count
answers of X's and this is a total
function we don't need any other
patterns we don't need to check if this
if this first list here is three
elements or one element or no elements
because the type H list guarantees that
it will have precisely two elements
because our schema has precisely two
columns so but not only can I work at a
particular description I can also work
generically over descriptions I can take
I can get any I can take in any
description and then calculate something
based on its interpretation in other
words I can regain the kinds of things I
want to pattern match on types for so
let's say I want to print out the result
of a query to my database I can then
write a function that prints a header
for it and that takes a schema and it
returns a string and what that's doing
is it's taking the first projection
which remember is the column name
sticking a bunch of tab characters in
between and then concatenate it I can
print the contents of a column by first
checking what type of column do I have
so if it's text then I've already got a
string so I can just return it if it's
real then I've got a double which means
I need to call some function double the
string if it's integer then I need to
call industry and so the type is is sort
of refined by the reduction of the
interpretation so the interpreter runs
on the code that I got from my first
pattern match to get the type of the
second element that I'm pattern matching
on I could print a row the same way I
look at the schema and I see if the
schema is empty I know the road was
empty so I returned the newline
character if the schema contains some
column type T and then some more columns
then I know that there's going to be an
accessible value and so I can use my
print call to get that value using the
type from the schema and then I print
the rest of the row and finally I print
my result by printing a header and then
sticking together all the ropes and this
will work for any type that I can
describe there it just even has a
feature called type provider
so the first bigger project I didn't
idris which is where you can run side
effect full programs during type
checking so you can connect your
database server compute the code
describing it the schema of your type
and then pull that in at type check
things based on so it's it's heavily
inspired by F sharp type providers but
the difference here is that you're not
having do any code generation you're not
slinging a STS around and violating the
abstractions of your language you're
running in the exact same I o action
that you could use at one time to get a
hold of the schema of the database so
it's it's it's a bit different so the
the next little demo is a very simple
domain-specific language which is one
for a calculator so so we can use a
universe to construct a sort of a
expression type or an expression type
with types so the types of our
expressions are going to be int and bool
and our interpretation will map those to
the expected interest function or the
expected address types then I can
parameterize my expression type over
codes in my universe so it looks a
little bit like doing things with a JDT
in Haskell but when you start doing more
complicated things then you can start
having interesting computations over the
codes inside of the type and then that
becomes a lot hairier to express if you
don't have dependent types you know so
we have a constant integer which is an
int expression we have constant
boolean's which takes a boolean and it's
a an expression in an expression boolean
add gives us two integer expressions or
takes two integer expression integer
expression and less then takes two
integer expressions to a boolean then my
evaluator can take an expression at type
T and give back whatever the
interpretation of T as an interest type
is so the constant integer or the
constant boolean if we interpret their
code we get back integer or boolean
respectively and we know that the thing
inside of the type is correct so we can
return it and the case of add we already
we can figure out what the types are
based on the interpretations of the
codes inside of the left and the right
arguments as we just add those together
we don't need to do any more work we
don't need to do any runtime checks for
anything and for less than the same
argument applies and finally I want to
get to the the example but I think it's
really fun so the the goal here is to
describe binary data file formats using
a universe once and for all so we define
this universe of formats and that these
are the codes right and then we
interpret these codes as types because
we're using this universe design pattern
and we're doing this in such a way that
invariants in the binary file format are
expressible in the universe we can then
write generic binary i/o procedures so
if I have the description of a file
format and a file in that format I can
read that in without having to rewrite
the file reading code for every single
format and the same for the output code
and we do this by pattern matching on
the codes just like you saw for the SQL
example and I didn't actually write this
particular example it's from this really
cool paper for IC Fe 2008 back when
dependent types were sort of not the
barbarians pounding at the door of
Haskell that we are today you know sort
of back back when it was a distant a
distant threat on the horizon and and in
the paper sort of goes through a lot of
really cool things you can do an actor
and I highly recommend reading it's
readable and great so the the image
format that we're going to describe here
is called ppm and I'm using ppm I was
gonna do something more fun but it just
gets to be too much for a slide just
like Windows been that files have all
sorts of complicated things in the
header whereas ppm is like the simplest
of binary image format you can find so
the so here's a vastly zoomed in picture
on the screen in and above is its
representation as ppm so we start off
with a magic number which is p6 in ASCII
or hexadecimal 50 36 following that is
actually a width and a height and these
are encoded as ASCII in ppm
well it's because ppm started off as an
image format that was easy to email back
when attachments were unreliable and it
was and so there's an ASCII version of
the format and a binary version of the
format working with a binary version
here but the headers are the same except
the magic number so so here we have
three and two as their ASCII codes if
you note that oh yeah and then the next
is a the number of colors for a
component and that's 255 I've never
actually seen it a ppm image in the wild
that doesn't put 255 here yeah sorry but
is is there some kind of a delimiter
between the width and the height yes
that's the next step when I push right
on my keyboard the next time okay thanks
for asking
yeah so there's one or more ASCII
whitespace characters actually but
importantly after the number of colors
you have precisely one ASCII whitespace
character and I didn't realize how I was
doing this first and I got some really
weird results and that for that you have
the pixels right so so each pixel is
given as three bytes you know so we have
a black pixel we have a white pixel a
gray pixel all the HTML people in the
room are recognizing how these look we
have a red pixel a green pixel and a
blue pixel the idea is to take this
format and and describe it in a general
in a general setting rather than write a
bunch of specific code for every format
so the the way it looks in this universe
of format descriptions at the top we
have the same file again so first off
there's the magic number so we say that
we have a part of the file which is
called the magic part and that's this
byte followed by this other byte
followed by some number of white spaces
following that there's a some number of
ASCII digits and then we skip some white
spaces and this other argument to white
spaces right here is there because when
worse we want to use this Universal Bowl
for reading and for writing and when if
we just threw them away
a normal skip might do then we wouldn't
actually know what to put there when
writing it out so you have to give it
sort of a representative to put in when
writing in this case a single space
character and then there's some number
of digits and these are being named X&amp;amp;Y
I then compute a width and a height
because those were sequences of ASCII
characters and we need actual natural
numbers so I use this read nap function
that I wrote for that and the interpret
and and the interpretation of things
using this code are those dependent
pairs you saw which is why we need to
get witness I then can read some maximum
number of colors as some number of
digits read that as a natural number
yeah just a quick question I don't quite
get why we have to use the pen impasse
what isn't why can't we just say skip
white spaces so the list of just lists
of 20 20 X so the reason the dependent
pairs here is use does not do to the
white space skipping it's due to the
fact that the interpretation of the
constructor that we're getting from
using this bind operation is a dependent
pair and can i delay this a little bit
as well I show the definition of the
data side because I think that will
answer it and if it doesn't then I'll
return to it thanks yeah and then
finally I skip one whitespace character
I have a part that I'm calling the image
data and then that's going to be width
times height times 3 bytes note that
width and height here are the actual
values that I've computed by reading the
width and the height from the file so
that that's very important for ppm to
work correctly so that's enough slide
let's go to the let's go take a look at
some real code so here's that definition
of ppm from the slide the and we've got
the the magic number we've got our X and
our Y we've got the width the height
computed from them and so forth given
that result of is the interpretation
function for the
universe which you'll see the definition
of in a bit so I can then write a
function that will rotate a ppm image by
first saying that it's a function from
the result of the ppm data type to or to
the ppm description to the result of a
ppm description then all of so the
reason we need to depend in pair here
when we're interpreting the data type is
we need to store what the height and the
width were but we need to have those
available in the types of the rest if we
want to ensure those invariance so then
we have this make section here and
that's the result of that part you know
so we get the magic number we get the
whip we get the height we get the
maximum of colors then we get this
section image data if I change this and
get rid of the colon and then ask idris
to check it for me it just gets sad and
this is because the type system is
ensuring that on the left-hand side when
i pattern match i put the exact right
string so i can sort of ensure some code
readability by defining these part names
so put that back and it type checks
again so the left-hand side i'm
projecting these out and then i get
these these pixels and then what I do is
I and pixels is of a particular kind of
list where the type includes its length
and so then we know that the that this
is the right number of pixels by the
right number of pixels transposed
switches those so note that on the right
hand side I switched the height and the
width as well because if I didn't do
that I'd get corrupted data I have the
right number of pixels but they'd all be
you lined up too long if the image
wasn't square and if I happen to write
height here
this is also a type area this one's
somewhat less pleasant what one problem
with a lot of talks independent types is
that people never actually run their
programs single day they get it to
type-check and then say yes ship it I'm
not going to do that I'm gonna I'm gonna
actually show you we're running a
running program here so I I can define
some of the the typical stuff you need a
little command line app like a usage
information printer yeah it needs a ppm
file and an output name as arguments I
have something to read the arguments
where it's returning a pair of strings
so I get the arguments to the function
like C we get the name as of the program
is the first one so we have input and
output files otherwise we print the
usage and bail then what main does is it
gets the arguments it slurps the
contents of input into an array an array
of size K bytes if that if it failed to
read it then we then we Bale and print
the error message otherwise we read in
the array we then read that according to
the description of ppm so this is that
ppm code described up above that print
processed if this works we call the
rotate function and put that inside of
the of a new array which is the right
number of bytes and this 10 here's a
little fudge factor because sometimes
things get a bit bigger if you have a
number of white spaces and then finally
used dump which takes the contents of a
binary array and writes into a file so I
can compile this
I think there it goes but then I can run
the shell come in so I can say it
actually called it those I need to
here's a picture of me let's rotate it
so the file here is called rotate so I
can then say dot slash rotate and I get
back to usage information dot slash
rotate me three dot ppm to me rotated
PBM it does it and I see right so the
way that this format description works
the we have a two universes in play the
first is one of sort of base data like
the small things that we can read we've
got a bite we've got some number of some
of some other base data or we've got an
array of Couture we got an ASCII
character we can interpret that the way
you'd expect so bits eight is in verses
eight bit a type vector of n of the
interpretation of some base type is that
sort of Lists with the type of the links
and characters go to characters sections
is what I use to get that mandatory
string matching and so what we can see
that that does is it takes a string and
a type and gives back a type the
constructor makes section takes some
label and some element of a and gives
back a section of that particular label
for just the type a alright so we lifted
the the label up to the type level and
keep the actual value just add evaluable
then the format specifiers we have a
part which is takes a string naming the
part and the rest of the format we have
bad which takes it an error message so
this is how we say like if you get here
it went wrong so it takes an error
message and gives you back a format and
says we're done woohoo
bass which takes one of an element of
that bass universe one of which is the
interpretation save either this format
or this format many which is repeats of
format skip which takes a format then it
takes a representative which is the
result of that format note here that
we've got the interpretation function
occurring the definition with the type
this is a feature called induction
recursion which you have an interest in
agna and it really makes things powerful
and then you've got the rest of the
format and then you've got this bind
thing which is how I was able to use do
notation when I was constructing it and
that takes a format and then it takes a
way to compute a new format from the
value read from its first format and
that is itself a format so what are
interpreting these things if you want to
do a part then we use section with that
label on top of the result of the rest
of the format bad goes to avoid
imperative programmers in the room this
is not the void that you know this is an
empty type which cannot be constructed
which is to say that you can't write a
function that returns the result of the
bad format and is unit which is kind of
like void the void that imperative
program is actually no it's got one
trivial constructor Bates we simply
delegate to the base types
interpretation one of it goes to either
which is left or right so it's one of
these many gives us a list skip it skips
something and bind is giving us back
that dependent pair right because we
have that value that we pulled out the
first time and then we have the result
of the format that we computed from the
value that we read from the file already
and that's where the dependent pairs are
coming in did that make more sense now
okay
yeah so just to wrap up if you swap more
dimensions then it won't compile or work
this is this environment correct so that
was coming from the interplay between
the interpretation of this bind
constructor and the interpretation of
this end times constructor of the base
so the buying it was a dependent pair of
a natural number and something with that
natural number in it and this type of
effect is a list of precisely that many
elements when I switched them those
didn't match up anymore it's like you
stole the binary data by roles right and
then you when use how do you store the
binary data is it stopped by roles or
it's sort by like so in this particular
example I wrote a little thing that uses
the csfi to Alec to like malloc a chunk
of memory and I just hold that and I
walk a pointer down it what I'm reading
it in and the result of processing it is
going to be a nested sequence of
dependent pairs or other constructors as
determined by the interpretation
function result of yeah I don't get it
maybe I asked you later okay so I'm at
the level of some right now so if you
want to do your universe pattern you
have a data type and an interpreter of
thatis types you can use these codes for
both runtime and compile time
computation you can use it to type check
but you can also use it to make things
that work for any type described in some
universe you can use induction recursion
to have really expressive universes like
the one we just saw and and then you can
use interest type providers to compute
the codes in some universe using side
effects and and get them from the real
world and interact with something
outside of your ivory tower language
thanks very much for this
so in the main function you said just a
lots a memory with some fudge factor and
that's a little bit worrying and I agree
language it you're trying to verify
properties about it well I'm trying to
verify things here right i mean i'm
using dependent types you can use as a
logic to prove a lot of things about
your program if you want but you can
also use them to make programming more
fun i mean they're sort of the dour the
sort of the DAO are utilitarian approach
dependent types which says you know we
must we must prove everything to some
spec but in this case it's it's actually
saving me work i'm using it you know
it's nice that it catches some bugs but
i don't have to sort of verify
everything i need and if i wanted to put
in a lot of work i could also have
computed how much space I actually
needed but I didn't think that was worth
it and I think it would have made the
example much harder so I could to
actually traverse the description and
see what size all of so the the fudge
factor is necessary because we have
these representatives inside a skip and
so I could have I could traverse it and
see what the size expected by all of
those are for the particular formatting
question if honored to prove that was
correct I'd have to probably spend a few
hours doing that but it wouldn't be
possible so I guess the message is that
you can you can be as formal as you want
if your language has dependent types you
know you can you can go like total type
theory astronaut mode and you can also
sort of use them within a couple of
places because it's nice or anywhere in
between
we actually had one more question sorry
this isn't namely really about the
formatting man
I was just wondering if does iterative
like an existence operator that egg to
his we're the the beam appear but you
don't have to specify what the witnesses
just infuse all the wouldn't it type of
the witnesses from the personal we don't
have syntax for that but you can write
it co so the inference will prove so so
the solicitor so just so pretty much all
of the things that have fancy syntax are
sugar for some underlying name there's
an underlying type constructor that's
just called Sigma which is what the
double stars map to and you can put it
underscores its first argument and then
it'll work it out also in runtime
programs you can put underscore star
star or something if you want and you
can define the alias that did that for
you
I is is there any way to make Haskell
libraries available and interests not
really anyway I think it's actually
would be a very difficult problem to do
an interest to Haskell fo5 for one
interest is strict by default at runtime
so most of the idioms that work well in
lazy libraries will not work well in
interests and vice versa
so probably a no camel FF I would make
more sense than ask the one and even
then if you want to get the types to
match up in a nice way you're gonna have
a lot of difficulties because a
dependent type system isn't just a sort
of strict superset of a hindley-milner
Styles type system they're sort of quite
different beasts so I think it would be
you know you could make it happen but it
would take a lot of work to make it sort
of a nice seamless experience that you
want you you think even having having
libraries from a camel without any
additional type dependently typed
feature enhanced features what would
still be difficult yes
so if you have like a polymorphic type
for example there's not necessarily an
easy way to map that to a dependent type
because you're not just wanting to call
o camel functions that are type napped
in that thun adder or int into end if
you want to call functions that are you
know lists of a - list of B - list of a
B for instance and if you're wanting and
if you're gonna do that it's then you
have to get all of the type
instantiation rules that encode them in
such a way that it just can check them
nicely for you so I'm not saying that
it's impossible it's it's just something
that would be a quite large research
effort to make work well the default
back-end has a pretty good CAF Fi and
then the JavaScript back end has a
JavaScript FF I
just a quick detail question I spotted
some keywords that I couldn't make sense
of one was like mutual mutual and the
other one was and I think covering
something that okay so interest
processes the definitions from top to
bottom in the file rather than having
everything be mutually referential by D
by default like in Haskell so I want if
I want things to be able to refer to
each other and be mutually recursive
then I need to put them in a mutual
block so in this case it allows the name
result of to be available in the
definition of format and the name format
to be available in the definition of
result of and then that ends after this
indented block and covering so interests
has what's called a totality checker
which checks all of your functions and
tries to prove that for all type correct
inputs it will return an output in
finite time not necessarily a short
finite time and this and you have to
pass the Tattaglia checker if you want
to use the function in the type because
otherwise the logic would be
inconsistent because the infinite loop
inhabits every type what covering does
is it relaxes that restriction such that
you're allowed to have infinite loops
but it still checks so that you match
all the patterns so you get I covered
checker more like what you get into
something like the coverage warnings of
JC as a second question which is maybe a
bit brought a broad question but so goes
through my mind is that I find all of
that quite interesting and pretty cool
and could very well see myself like
playing wrong with it but what I'm what
I'm thinking is like of all those
millions of Java developers right now
who would a lot of them they looked at
something that something like that it
would scare the living hell out of them
yes and so and so I'm wondering like how
how do you where do you see dependent
typing in the future like in a way that
where where can they be a middle ground
sort of where we can like move the
languages that we have right now
- what's the direction so I'm not
necessarily convinced that we should
move the languages we have right now
toward that direction it's it's an
interesting thing to try and and you can
do a lot of cool stuff but it gets
really scary really fast it I don't know
if dependent types ever will be a
mainstream programming language feature
I I think making them in its it's really
the kind of thing that in fact every way
everything about what you do with the
language and so might might hurt this is
my personal take on it is that if we
want to be using it we need to design it
into our languages from the start and if
we want other people to use it then we
need to get better at communicating
about it and explaining how things work
and and and be better at admitting when
we're not there yet and we're not there
yet
we don't have mature compilers and
runtimes to the extent that you do for
things you know languages like Haskell
or Oh camel or Java or Scala
I hope to get there at some point so I
guess you would also say that if people
want to want to use dependent having
they should not try to shuffle it into
Haskell but they should just use octal
or sorry I think trying to shove it into
a hospital is cool I don't see how that
goes
I the jury's out in my opinion as to
whether or not that's going to be
something that's broadly useful for a
lot of people or whether it's going to
be something that's narrowly useful for
a few people I'm looking forward to
playing more with it but it's you know
this is this is still research and we're
not done with it yet Thanks
thank you we're out of time
unfortunately so find me in the break
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>