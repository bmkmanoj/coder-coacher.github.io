<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Manuel Chakravarty - A Type is Worth a Thousand Tests - Curry On | Coder Coacher - Coaching Coders</title><meta content="Manuel Chakravarty - A Type is Worth a Thousand Tests - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Manuel Chakravarty - A Type is Worth a Thousand Tests - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q1Yi-WM7XqQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright
good morning hello first of all I very
much like to thank and Heather for
inviting me to this wonderful conference
I really like this idea of the
intersection of academia and
practitioners especially because I am on
one hand I'm a professor at a university
of new south wales but I've also spent a
la semilla contraction of the last two
years as a software developer so I'm
kind of split personality and for those
of you who know me you may expect me to
talk about Haskell but I have to
disappoint you know monitor today let's
talk about Swift so if is not just an
interesting clever language design but
it's especially interesting if you look
at its ecosystem in fact there have been
other hybrid object-oriented and
functional programming languages as you
know a few of them actually but what's
different in the case of Swift is not
that it as those other language is
nicely interoperate with the main
language on the platforms it runs on and
it's libraries but all these languages
like scholar and a fab day they are a
minor player on the platform whereas
Swift is said to replace objective-c and
that presents a you unique opportunity
because why do you languages become
popular we as language designers we like
to think it's languages but that's not
true it's the platforms it's the
proliferation of the platforms which
make languages popular and so Swift is
going to dethrone objective-c by decree
and it will become a mainstream language
that's at this point inevitable as it
will be the major
language on the Apple platforms and
since he the it's a test distribution
for Linux now and Apple has a very
strong push into education for example
in the last developer conference they
released a preview version of an ipad
app Swift playgrounds which is clearly
aimed at the education space in fact
that teaching kids to code in middle
school and high school it is set the
trajectory of Swift is set so why is
that interesting why should we care
about this just another language which
is going to be get big well it's
interesting because the improvement of
Swift our objective c are based mostly
to facilitate function programming in
fact type functional programming so in
summary what we will get is a language
which encourages type functional
programming in a mainstream language i
found that quite exciting when Apple
announced language two years ago at
their developer conference and I was in
the process of writing or at least
actually started writing an ide for
Haskell supporting live programming
using playgrounds and I decided to jump
in and to just write it in Swift and it
was one of the first Swift applications
on the Mac App Store i believe and
that's been very interesting so let's
get back to this this this is the core
point Swift encourages type functional
programming in what will be a mainstream
language well arguably already is and
will be one of the big languages so
types why are types important well the
conventional wisdom is types are there
to catch bugs and prevent crashes or you
could look at it from a different angle
and say well you have to do less testing
you can get the same confidence in your
code with fewer and simpler tests why is
that well if you look at your
application at the state space of your
application then there are some arrows
states those are the states which lead
to crash or on the side behavior and
then we test for some of those what the
type system does it reduces the amounts
of states the application can get into
in the first place which yeah it
eliminates some bugs but it also
eliminates the need for some of the
tests but if that's the whole story are
types just an elaborate form of
restraint for programmers something we
shackle ourselves with to not fall
across some obstacles and and what if
that doesn't work what if you're one of
these people who says the type system
really doesn't do anything for me
because that's not the kind of bugs I'm
making I'm sure you've all heard this or
set this yourself well actually the main
thing about types is that they are a
design tool first and foremost their
design tool the encode static there are
a language to talk about programs
specifically the static properties of a
program which is those properties which
can be inferred and check without
actually running the program but their
guide they help Isco design and then
they automatically check the consistency
of that design so in fact actually types
are designed to other language designers
and then the resulting language allows
you to use it as a design tool for your
programs and that's the important thing
that's the there that's something the
Swift team
deeply understands and one way to remind
us of this is to follow this mantra
often espoused by Aaron Minsky to make
undesirable States in your application
unrepresentable but let's get back to
Swift so Swift encourage this type
functional programming in a mainstream
language that's my main claim here so
let me and if the type system is
designed to then well let's talk about
how we can use types to help us design
programs so I want to specifically focus
on two particular features of of Swift
namely value types and something called
protocols with associated types sounds a
bit scary but to make this more concrete
I actually want to do this in the
context of concrete application a little
iPhone applications not very polished
graphically the what the application
does it's a tracker for personal goals
like how often do you do this or that
activity which you really want to do
more often to keep track of that and
that application it's got two modes so
on one hand as this overview mode where
you see your progress so far and and you
can register that you did one of those
activities you want to do and then
there's the editing mode where you've
got an overview of all the goals you've
defined and you can change them and you
can add or delete new goals and move
them around so that's a simple
application let's have a look at how
value types and these protocols help us
to improve the design of this
application and in in in particular to
use a functional programming approach as
we learned in the last talked actually I
think functional programming is
is great in this context because of this
focus of small narratives fungal program
is all about local reasoning very local
and small so value types what's a value
type well in Swift there are two
different kinds of value types there
strikes and they're in ups and you may
think well you've got struts and enums
in C well that's how Swift like typical
apple marketing is very good at making
things like sound familiar so they are
non scary so they never talk about
functional programming they never use
that term they call things by familiar
names and extend the functionality so
struts and enums in Swift they are
actually much more so in arms as you can
see in the second example they are not
just different alternatives but each
alternative can have values associated
with those alternatives and they can be
parametrized and they can be recursive
and there's pattern matching so as a
Hester programmer I actually call this
an algebraic data type but then
everybody runs away so epic odds it's
struts and enums and people are happy
but what's important about with these
value types is when we contrast them
with reference types so if i define a
class rough point for reference point
and and then i create an instance of
that so I get that allocated on the heap
and my variable points to it if I assign
it to a different variable well of
course I only copied the pointer and
then changing through this point on I of
course effect what's accessible through
the first variable as well you all know
that the big difference with value types
is if I do the same thing um then I get
an instance but once I assign it well I
make a copy and then changing that
obviously does not change the value
refer to
first variable so I get an immutable
structure whether that structure is
actually copied or not is irrelevant the
compiler tries to avoid copying of
course but that's what's happening
semantically so that's great because
that gets us to our postmodern goal of
small narratives of local reasoning it
allows us to focus attention on a small
piece of the code we don't have to look
at everything at once and consider
impact of changes throughout the entire
program so I promised you to use these
ideas in this iphone application we will
do this by using something called an
immutable model so those of you who have
written you your applications probably
most of you those of you who have
written cocoa cocoa touch applications
will be very familiar with the
model-view-controller pattern which is
the way to structure a cocoa touch
application or maybe if you're living
Microsoft land you you're using the
slightly more sophisticated model view
viewmodel architecture but in any case
you've got those model objects where the
data of your application is stored and
and where you retrieve information for
presentation but these models they're
usually they're called model objects for
a reason they're objects with pointers
to them and when you pass them around
then you passed pointers around which
means other objects such as those
controllers of use often tend to
accidentally change things in the model
or they change data in the model in an
inconsistent manner for example because
they're running on multiple threats
which is basically a necessity in modern
mobile applications where you have to
have a very fast responsive UI so
anything which could take a little
longer has to go on a different track so
using value types in Swift we can avoid
this problem we just use a structure and
in terms to define the model so in our
concrete application that would like
like this we've got struct and it's got
a few fields and then one of these drug
instances represents one particular goal
and to track the progress of goal repair
it this is Swift's notation prop for
pairs or topple so in this case a pair
where you can use names to identify the
different components of the total to pay
our goal with the progress you may
towards the goal and then we take an
array of those to get the entire model
state of the simple application so by
doing this we can pass this around now
and we don't have to worry about any
accidental changes because well it's a
value type it's not a reference type so
what we get we avoid accidental changes
to the model state which gets rid of
quite a few tests and we make the whole
thing a much safer in the presence of
concurrency which as I said is really
given in any modern mobile application
so that's number one at this point you
may wonder that's all great but really
sometimes you want to change the model
how do you do that that'll come later
you will have to wait but I will tell
all right so number two we've used
straps let's try to use in arms well as
I explained this application has two
main modes on one hand there's the
overbought view mode and then we can
also edit the set of goals now in the
Edit screen as it quite common in in
these types of
there's a model behavior there's this
edit I don't know whether you can
probably not read it in on the screen
shell but on the top right corner
there's a blue blob it says edit if you
tap that on the left screen you go to
the right screen and then you can delete
goals you can move them around as on so
this is modal interface quite common and
the trouble with it with this type of
setup is that very often in the
different modes there's different types
of state you want to keep track of which
typically means that you've got a few
variables which may be nil or not
depending on in which mode you are and
whenever you transition from one mode to
another you have to make sure to change
everything consistently otherwise you
get into this typical situation where
you're you i chose one thing but you
can't do the things you want to do or
there's an inconsistency in the state of
the application and that's quite common
in this type of mobile you is so using
in arms we can solve that by
understanding that really what we're
dealing with is just a state transition
system right so there are various modal
States the double screen can take and we
can draw nice diagrams with different
states errors between them and then we
can define in enum for the different
states in this very simple application
is just two different states that's
display state and editing state and
using those associated values or I would
call them arguments on a some type and
we can can associate those parts of the
states which are relevant for that
particular mode with that state which
means in the editing state we always
have active goals in the display state
we cannot have them there is not an hour
an empty list or a null pointer to a
list of goals they're just not
accessible and that's something the
compiler can check so when we use those
such enum in this simple setup we can
extract the first line extract using a
map function it strikes out of the area
of goals and the activity whether a goal
is active or not and then wraps it into
this editing case of the enum and in
switch we do pattern matching in Swift
we do petal meddling using a swift state
with the statement which is a
generalization of see Swift but it's
really just like a case statement in
haskell only with weird syntax where we
can pattern match on the component
extract the state components but we can
only get at the active goals if we are
in the editing state and it's something
the compiler takes for us so again we
lose some tests because there are lot of
inconsistent states which which we
cannot get into which are not represent
able anymore and moreover the compiler
can also check that our state
transitions are exhaustive as if in a
switch statement V we forget a few of
those states well that's hardly a
problem in the simple application with
two states but once you get to something
bigger obviously that can help more
easily the compiler will have warned us
about this oversight as well all right
so this is how we can use value types or
a youtuber algebraic data types if
you're a haskell programmer on el
programa how you can use them to improve
the design and type safety of your
application all right let's go on to
something more sophisticated or
complicated protocols so if you're a
haskell programmer then protocols are
just type classes and associated types
are associated types if you are C++
programmer
well it's bit like templates with traits
anyway I earlier mentioned we kind of
knew that ourselves into a corner we
made the model immutable so now we can't
accidentally change it well actually we
can't change it which is a problem
because our user may want to change it
but but what mutation anyway let's look
at a variable a simple integer which
when we initialize it it's 25 then we
update it we update it again we updated
once more and then we update it to 42
this happens at different times so one
different way to look at this is to say
well it's not just a mutating variable
this is a time series right it's one
value strung out of a time or we could
say it's a function of our time two
integers or we could regard it as an
unbound stream of values instead of
something which mutates well this is the
idea behind a lot of these functional
reactive programming libraries or the
way the Elm language operates but the
point is what we can achieve with this
setup is to make the flow of change in
our code explicit it's no longer a side
effect through a pointer but we can
actually we actually have a handle edit
and we know where change happens and and
which part of the code are affected by a
particular change moreover a nice side
effect when well a nice benefit is that
once we regard change as a stream of
values well it's a collection and we can
apply all our beloved collection
operators like maps
filters folds and so forth to make
change propagation and manipulating
changes even more even more compact and
easier to understand so how can we do
this in in Swift well we could use one
of these frp libraries which okay but
actually this is a simple concept and we
can just implement it ourselves so we
start by this defining protocol of
observable values again if you're
familiar is has called think type John's
if you're familiar with Objective C
think protocol and but these protocols
they have an associated type so the
protocol we are defining is the class of
types which we can be observed but
that's not necessary the same type as
the values which we are observing that
is the observed value which is implied
by the type we of observables that
difference will become clearer when we
use that protocol but it's important to
keep in mind two different types in
playa and that protocol requires one
function war or one method if you like
and that's a method observe which
registers an observer and an observer is
just a function in this red box it's a
call back if you like which is being
involved every time and there's a new
observation or the value changes and the
observed value changes so based on this
protocol and we have got two instances
of that protocol the first one is a
stream of ephemeral changes a class a
parametric class called changing of a
particular parametrized by the type of
values which we are observing so the
type of values in that stream would be
in our previous example with that
mutating variable so that class
obviously implements the
observe method because otherwise it
wouldn't be conforming to that protocol
but introduce one more method called
announce which we use to to effect the
change or to announce the presence of a
change in that value so that's our
replacement for an assignment if you
like now that's one stream in this case
when you register an observer you will
be notified of all the changes which
happen after you've registered but
that's not always enough so we've got a
second form of observable values you
don't have to read all this code which
is maybe bit confusing if you're not
used to Swift somewhat slightly verbal
syntax the important thing is that when
we create one of these accumulating
values then we provide an accumulator
function the thing in red the
accumulator functions purpose is that
given a stream of changes the
accumulator consumes those changes
maintaining some local state which is
updated or accumulated every time we get
a new change value producing a stream of
these accumulated values and on
registration of an observer the observer
is immediately notified of the current
value of the accumulator so on these are
the two forms of observers those which
we need in this little application but
based on this protocol we can define a
few collective operations we can have a
map function map on an observable passes
in a function which is applied to every
value in the stream and gives us a new
stream merge takes two streams and merge
them into one stream containing the
changes in both of these original
streams the streams can have different
types
and then finally an accumulated function
which given at Shea a stream of changes
produces one of these accumulating
values which we saw in the previous
slide so now with that at our disposal
which is really just a few lines of
Swift we can implement the change
propagation in the simple iphone
application so we start by the model
which is this array of pairs of goals
and progress counts so the idea here in
this table is G 0 1 and 2 the goal
structures and the numbers to the right
of them are the change counts which are
the progress we've made to achieving
those particular goals now we register
two observers on that one for each of
the different modes of the application
and the overview screen or the editing
screen and then those both of these
screens and affect change because in the
overview screen we can indicate that
we've made progress towards a goal well
that's for the right column of the table
and then in the view on the lower part
of the slide the editing view we can
change goals so that affects the left
column in that table so two different
types of change and we don't want what
we want to achieve here is that the
screen overview screen can't
accidentally modify the goals and the
goal editing screen can't accidentally
modify our progress counts so we achieve
that by having two different sets of
change information which has then merge
together and these two different streams
of changes they have different types so
the overview screen generates a stream
of changes to progress
and the goal editing screen generates a
stream of changes of edits two goals
different types we can't mix them
accidentally they are merged by the
merge Combinator combine a turn and into
a stream of all edits which we then
accumulate to get the table as an
accumulating observable value so with
this this diagram translates very
directly into the swift code we are
using to implement this just putting the
various functions at the arrow arrows in
this diagram together and it makes it
very explicit and checkable to the
compiler how how change propagates in
this application but the point I I made
in the beginning is this is not
something which we've retrofitted it is
that manner in which we designed this
application which allows us to get that
understanding as a human in the design
process but also allow the compiler to
check the consistency of our design so
what we achieve by the setup is that
parts of the views controller
architecture of our application can't
accidentally change those parts of the
model they are not supposed to change
and we avoid conflicting state changes
for example you two concurrent threads
which are sequentialized for example by
this use of Stroup's of changes so to
summarize overall em please keep in mind
types are not am a form of restraint to
checkol you to your computer first and
foremost their design tool and and Swift
is itself designed with those ideas in
mind to encourage type functional
programming and those allow you to which
their place entire categories of test
thank you very much hey there um so like
um from the other side from the Android
world and I just want to say that there
is a very small feel faster I we're
trying to look to apply the same
approach into the animal world with the
help of the reactive it adventures in
this case so functional reactive
programming and I just wanted to say
first us a comment even though we don't
have ugly algebra data types as a first
class element in Java they can be
encoded they can be created because I've
done it I have library that is called
sealed unions that does exactly that for
the JVM 807 so you don't need you don't
need any kind of butter matching because
you can do it with higher order
functions using charge encoding and my
question is the the good part about the
design is that when you're using it in
your view model internal in memory it
works really great but it kind of
diffuses a little bit when you get into
the edges because the type system is not
as powerful when you're going into the
network when you sending information may
be in protocol buffers or anytime or
when you go into the databases because
they don't allow those types how do you
bridge that for systems that you're
supposed to be having for the model in
overtime in those databases or in those
Network holes so the that's so the point
here was that in it in a typical
application the model information of
course is not something which is just
created in the application stays there
until the application dies but you have
to communicate of the network or make
the data persistent by storing in
database or something like that so um
yes so the interfaces are still the same
for for example if you use something
like core data on an iOS application to
make your state persistent then it's
totally possible to wrap those mutable
api's in a way that you get an immutable
view on them and you making to react I
mean react is doing exactly that right
you've got the mutable Dom underneath in
the browser but the API which we present
to the program are to the application
programmer is one of a function
description and of functional updates so
basically you can use those same
techniques here only that well either
you've got a library or framework which
does that for you already sore some of
those existing if a part of PA systems
try to do that for you or it's something
where you do the wrapping yourself then
the person who you present this nicer
interface is you in a different part of
your application instead of some other
person but it's the same idea my
question was a lil bit more related
about how you how do you express those
types inside the database know how you
communicate with it with those
interfaces what I mean is that you
cannot store in a database an algebra
grade algebraic data type you cannot
store on either type you cannot start
maybe because the duality of them is not
there it's not easy to represent on a
database or a JSON schema or the server
has to know about it so how do you
approach those problems you have to say
civilize them so of course you don't get
the same expressiveness of tear types
say in an SQL database so you you
serialize your model into something
simpler and which means that during d
serialization from the database or from
information which comes of the network
you will have dynamic checks
thank you
so let me ask a question which I forgot
to ask in the beginning who has used
Swift at all who has used Swift in
production okay
try it
ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>