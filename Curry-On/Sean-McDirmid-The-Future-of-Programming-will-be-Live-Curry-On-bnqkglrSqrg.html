<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sean McDirmid - The Future of Programming will be Live - Curry On | Coder Coacher - Coaching Coders</title><meta content="Sean McDirmid - The Future of Programming will be Live - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sean McDirmid - The Future of Programming will be Live - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bnqkglrSqrg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good morning I'm gonna talk about
the future of programming we'll be live
so in the beginning we have computers we
have binaries like electrons flying
around not very useful for getting work
done so we applied our you know good
friend abstraction to make the concrete
bits into more abstract symbols that we
can then manipulate and you know write
our programs right so and then you know
this evolved into programming languages
you know very useful programming
languages helped us you know they give
us a language for our abstractions they
allow us to you know you know record our
abstract thinking and provide a
limitation of that thinking and help us
write programs but where does the
computer actually fall into the process
of programming so you know we think
really hard about our programs the
languages guide our thinking but the
program that the computer is just kind
of sitting around there doing nothing
it's not actually helping us think about
our programs it's not helping us write
our programs it's just it's just sitting
there waiting for us to know what our
programs are before we can type them in
well this isn't entirely true of course
we have static type systems that give us
errors that allow us to you know you
know tell us when our programs are bogus
or code completion that allows us to
sort of figure out what to type next or
you know even IDs or the hefty buggers
but you know I I feel like we should be
able to do more with that and so live
programming is this idea that you know
today programming is like arch archery
you know we we think about our programs
and we type them into the computer and
if it's wrong then we go back we think
we type and you know start the process
over and over again and then if you have
a Ruppel you can make that a little bit
faster but then if you have a large
program some some programs don't work
really well in ruffles and you know it's
just kind of like you know it's nice if
you can have a little bit of a feedback
loop
while you're programming but a lot of
times you don't write and like
programming in contrast to archery is
like using a water hose to write your
program right you know water hose you
just sort of aimed the water hose you
hit the target BAM it's really easy
there's an Olympic sport for archery and
there doesn't need to be one for water
hosing because water hosting is very
easy and this really is all about
feedback loops you know making the
feedback more continuous more integrated
more interactive right and you know the
better feedback loops we can get well
programming you know the better programs
we faster we can write programs the
better programs we can write so I've
been working in this field of live
programming since 2007 and I did this
you know this this little language where
you could type your code and you could
see the output of your code while you
were typing it and I thought it was
really cool at the time but you know in
retrospect you know wasn't that great
because you know as Brett Victor says
you know you can see sort of the typing
you can see the output but you can make
no connection between the two so live
programming has to be more than just
running your program Wald's or editing
your program while it's running and I
tried some other things which I will
talk about in just a second in a demo
but I think the overall experiences here
I try and keep failing but hopefully we
can do better so let's get going with
the first example the first time I was
and where is my where is it my taskbar
is completely missing that's not what I
wanted all right so here we're gonna
have a textural environment this is a
the color is not very good on this
projector right so I type a question
here and it's basically a placeholder
for a statement I call it a holy term
right it's it's like it's a hole in your
program and then you can shape it into
something else so we can now quote do Co
completion on that and we can draw a
circle or draw a square right and what
happens is that we get a little draw
command here and these holy terms are
substituted with you know actual values
in your program so this is a geometry
there's even a color here which is that
color you see down there and of course
the nice thing about this sort of holy
term style of programming is that you
know you you every time you add
something to your program you have
something that's executable right even
with default random values but at least
there's something there so you get your
feedback right away so let's change that
into a circle right so we did Co
completion again and then we get other
arguments here this is a position right
and the colors there so let's add a
position in here it keeps jumping around
but that's just the way that random
values work right so now we have a
position with with a two pole we can do
100 by 100 right or I might want to do
200 right but every time I edit this
right you can see it's all jumping
around and everything so let's do this
smoothly right we can just scrub to 200
if we want this is called scrubbing by
the way I'm using Brett Victor's
terminology it's basically the idea that
you can have a value in a continuous
domain and smoothly adjusted right and
we can scrub this one too we can also
scrub both of them right but actually
that's kind of stupid let's just move it
directly right I mean that's really what
you want to do we can go to the color
and we can change it to blue but we can
then we can also scrub the color right
so you just go around and you know
choose a new color it could be lime or
we could change this to a two-pole right
and we can do a little color picker here
right so let's oh well in time let's add
another shape here let's add a another
rectangle now I can just tap out tap on
the screen and do it
alright I'm adding a rectangle here can
I make it dirty let's make this guy the
same one too
I made that 60 alright so now we have
two shapes here and let's say we just
want to align them together well you
know and to do that you just define a
variable about X we'll make it a holy
term then I'm going to drag X to 100
that becomes now that swaps titute right
so now x equals 100 and then this this
where this other use of of 100 becomes X
and I can do the same over here right
now when I move this right they're all
bound together is this is how code works
right we can do the same with the size
holy now when I actually go and make
this larger right you can see it's
moving around okay so this is okay maybe
maybe you might even think this is full
there's some issues though so let's go
in and do a little bit more complicated
example here now we have a ball here a
circle and then we're gonna make this
circle move so on tick that's just every
tick update it we're gonna say the
position equals o eight and I have to do
other stuff your first do P make that
the position make this the the diameter
subtract I wanted to be a centered it's
okay
we just started that one so maximize now
you know it's real because it crashed
right P D don't type 0
I'd imagine is 52 okay so now we have a
centered position right so I can move
this like here but if I if I change the
size right you can see it it changes
from the center because position is
expressed from the center alright and
then we can do a Co ahead and make the
ball move P equals P plus V divided by
50 now we can see that the ball is
moving right of course the time is
frozen at the zero position right but we
can go ahead and do that scrub the time
you know to see the thing all right we
can also scrub the wonderful this didn't
happen earlier in a rehearsal so anyways
you could you get the feeling right so
all we're doing is we're making it move
around and yeah I'm just gonna move on
here
but okay one thing I want you to get out
of this is that okay what when I was
doing all this other thing teaching the
shape and changing the color right that
was that was really easy right but that
was really not not what most of
programming involves right and when I
was actually making it move around right
I wasn't actually using the live
programming environment anymore in fact
the live programming environment was
crashing on me was getting in the way
but even if it wasn't crashing it would
be distracting me right it's not good
enough right we have to try harder
alright so go back to the slides
use all right slides here we go
all right so what's really cool about
the demo I just showed you it has this a
lot of the scrubbing behavior if you
think of your program as a continuous
function right and think of your edits
as sort of being small edits lead to
small changes in the programs output
right and what that's what's scrubbing
supports right you can scrub up and down
you know your values but it's not what
we do in programming right and
programming we type in new abstractions
we type in things and make things appear
and we do a lot of discrete adjustments
to our code right things that can't be
represented as a continuous function but
one of the things that really did work
here was direct manipulation so we
should do more of that
so let's reset we'll do another demo
later that actually kind of explores you
know well how we can do better it's the
one question we really need to ask here
before we get into this work is where do
programs come from right because you
know it's programming languages is about
you know these these programming
languages they restrict your thoughts
they allow you to they provide two
language for just talking about your
abstractions but you're the thinking all
happens in your head the computer does
none of the thinking for you it's stuck
there and I think this is why we've been
stuck in text-based programming for so
long is that is the ideal medium for
that it's efficient to interface with
your mental model since everything is
happening in your head you know text is
the best way to sort of interface with
that thinking right it's efficient
efficient for coding the results of your
thoughts and it's not distracting with
you know feedback that might be
off-topic and wrong okay but on the
other hand text is very abstract it's
not very concrete at all and it doesn't
allow you you to it doesn't allow for
much interaction outside your mind right
you can't really manipulate text when I
was dragging those numbers down and
making them the same right I was doing
that in the most efficient way possible
that's like the the sort of the extent
of how you can manipulate text so why
don't we think about visual programming
again right
this happens every every five years or
ten years or so somebody will say why
don't we do visual program needs you can
solve all these problems but if you look
at the way that we do visual programming
typically it's not
it's about it's just textual programming
with boxes right you have names on these
abstractions and you it's still very
abstract and it's even worse if you if
you have this abstract visual
programming right you get this like
spaghetti a literal spring any code
right you just see a bunch of lines and
stuff right it doesn't act you haven't
actually improved the situation of it so
the goal for live programming is to
capture and augment the thinking that
goes on our heads this is what I believe
the goal is for this right is to bring
that thinking that's currently happening
straight slowly in your head bring it
out into the computer and how are we
gonna do that well let's go back to
direct manipulation right direct
manipulation is this awesome way of sort
of having you know interfacing directly
with a concrete system right you know
mac paint is I guess is the first one
that explored this in a UI paradigm but
you know we're also seeing a lot more
interesting things now that we have
holographic interfaces and stuff right
and it's you know really does allow you
to sort of take it but it's all concrete
right direct manipulation only works in
the concrete world you know to break out
of that right we have programming by
example which was one of these research
topics that was really hot in the 1990s
and what basically you you write a bunch
of examples and you let the computer
magically abstract them into a program
of course that's actually computers
aren't that smart and you know they
don't usually they can only abstract
simple examples but it's nice and
concept right well let's look for like
sort of a middle approach here right so
how about live programming with examples
I mean everybody know what the magic
wand does in Photoshop kind of right you
put the wand down and it doesn't outline
does edge detection for you and it says
oh there's a giraffe right I didn't
actually have to draw that by myself
right and that's what computers are
really good at they're really good at
edge detection though if we could just
find our edges in our program then you
know the computers could say oh there's
an edge here do you want to turn into an
abstraction
maybe so we can help abstract without
requiring magic so I'm going to do a few
more demos here that go into that sort
of line of thinking let's see if I can
do this right escape
how do i okay there we go let's do this
one first alright so here we have a
simple editor a simple line editor here
so I'm going to do a little bit of sort
of geometric thought so I'm going to
draw a line right there's a line and you
can see the code for the line appearing
on the left right if we draw another
line here from this point right they
share the same point if we move this
right we can see that they're stuck
together now let's draw another line
perpendicular to this one and we don't
have to draw it exactly perpendicular
the system will just infer that it's
perpendicular enough now if we look at
the code right this is a perpendicular
line so if we change this right it moves
that's as a perpendicular line should
and then we let's run another line here
to the intersection of where the
perpendicular line hits that other line
I've done that well enough right now you
can see that this is an intersection
right so I I drew this and it
automatically abstracted it into an
intersection so that when I move this
thing here right it stays in sync you
know we can even move this down here and
it will you know just extrapolate the
the perpendicular line that's not down
there right we can move everything
shoots everything gets smaller and
harder to hit okay so we've created this
sort of nice program that allows us to
you know do very specific we didn't have
to know about intersect or perp those
abstractions but you know we just
inferred it by the the lines you drew
okay so that's one way we can sort of
sort of boost this thinking let me show
you another one so let's go - I never
understood Windows
right so this was this is a lexical so
we're going to start with this string
I'll say hello curry on 2016 all right
just do 16 at close right so now we have
a string it's a concrete value we're
gonna Lex this so we're gonna add a call
here and the first argument is going to
be the where that that red thing is in
the string okay and we want this this
call to return true so I'm going to just
click on that I have false and true and
those kind of things right now this is
true and now I can click on this again
and I can get a set of methods that
where it's actually that actually
returned true so letter letter digit
lower right now we do that if we move
this around here you can say is true yo
is true space is not a letter so that's
not true this is all true false false
there we go all right now we can open
that up do an if statement here the if
statement the conditional of this thing
is just as true value that we just
produced here now when that's true it
opens up and we can write code in it and
when it's not true it just closes let's
see let me show you that really quick
here so that's false now it's closed
someone that's open it's there right now
I can go ahead and do another call and
the argument will be the next character
and the string right and now I don't
want a truth value I want another
character which is like the end of
that's the character that I don't want
to include in the token we just pop it
right there now if I move this around
here right this is just a you know this
is just a numeric offset right you'll
see it just takes and levels you know it
takes one two three four five six
characters of the string right but of
course we can make that more general
than six characters we can abstract that
right so I'm going to look at this and
this is okay letter star will also give
you those six character
but it will also give you more than that
because if I move this again now don't
want cut you'll see it's it stays there
and then when it jumps to here it goes
to this it goes over them now I'm
pointing it's free you guys will see
this okay
those lines actually clear washed out to
me all right well yeah projectors are
always troublesome here right so now
we're lexing the whole Korean thing but
we actually want does we actually want
the 16 to so we're going to go ahead and
just remap this to here so I thought it
was gonna be map it's just to here come
on you map there you go now the call
reset because I want a different set of
characters right and it gives us leather
digit is the only possibility right so
now it's gonna give us letters and
digits here right and it closes whenever
whenever it doesn't work and then we can
add space and we can add other trip add
other things here too just just as
easily as we did now okay so that's cool
our hope is cool let's go do another
example
let me hide this for now so this is more
of like a traditional diagram editor so
I'm going to dry it draw a box here
right and I'm gonna draw another box now
remember in the the first example I was
I made the x-values the same because
they were both 100 so then I created a
variable and then I found one 102 that
and then they were the same right well
you know there's a much easier way to do
that in a diagram editor right you just
have guidelines right there are edges
here whenever they're about the same the
edges appear right so we can add the
guideline here right and now they're
always gonna be the same I would really
love to have this in PowerPoint and the
PowerPoint team doesn't really listen to
me but still this is really this is
really useful right I'm actually writing
a program without actually having to
write any code right so now we can turn
this into an array all right let's let's
turn this to array here now we're gonna
have a ray of boxes but nothing really
happened we just said we went from two
boxes to an array with two elements
right again we're kind of climbing the
ladder of abstraction here we started
with two things now we have an array of
two things and of course once you have
an array of two things it's only a
matter of time before you have an array
of n things right now let's look at that
constraint that we did before which I
believe is that one right and now
there's another option here right right
we don't we can oh we don't have to just
bind those two rectangles together this
is part of an array we could find all
the rectangles together on the left now
they're all bound now they're all
aligned we can also do the same thing
here right I can add this I can add a
little thing over here that says talk to
bottom and then I can click on this now
they're all bow and top to bottom but of
course only those two are now if I click
on this guy here we get another option
we can say okay do it for all the
elements right now they're all aligned
right
and if I add more here it'll just
continue on all right we could also do
things like I can draw a large rectangle
here and I could draw two rectangles
inside here inside the big rectangle
right and now I can take this guy here
and I can bind it to the edge right now
now when I move this rectangle around
it'll always be there if I move this guy
it'll move the rectangle and if I move
this guy here it will just it'll just be
free-flowing
right but let's look at that constraint
click on it right there was another sort
of there's a more general interpretation
of this as constraint we can abstract it
further we could say the right of the
rectangle is max right so I can click on
this and now we've gone through and the
constraints the example looks exactly
the same when you abstract your program
you don't change your example right you
just change your the constraints of your
example then you know the future
modifications depend on the abstract
behavior the new abstract behavior that
you've just specified so now there it is
as soon as this guy is at the it this
guy has the edge further right you know
the box expands and we can also do the
same with this side here minimum right
now there we don't say you crashed all
right there we go so the you know we've
you know this is a bit more complicated
behavior than you get in just aligning
the edges let's go away I want to bring
back this guy here so this is a string
right so this is another Lexington
example right if I if I edit this thing
here right you can see the one down
there changes right so we need to draw a
rectangle I'm going to draw another
rectangle inside this one no that was
let me try this again hopefully I'm not
too nervous that I can draw within the
box right now we have this guy here and
I'm going to click on this one and it
has data right we can actually go ahead
and find this data to this guy up here
right now it's just a bunch of boxes
with nothing in them but it's the same
number of boxes and the one down here so
we can click on this guy and say I want
to look at the kind so we have text
which is being shown down here but you
can also show kind which is Alec's token
that's been pre computed for this
example and we can see ID whitespace ID
Y space ID newline right now I can add a
point on this on this you know box right
and we can align it to one of the edges
here so I'm gonna line it here right now
this is aligned to the 5th the the
right-hand edge of the fifth token I
think right one two three four five yep
right but we can also click on that and
we can change that to be ID or white
space star right which is also five
tokens at this point but then when I go
ahead and modify this right that's not
right
you can see it's changing
all right so what I can do is I can take
those tokens here that I'm parsing and I
can then find that to another rectangle
here and show the text right
something's wrong
area
all right so you can see we get the
first line of text here in the box right
now we can add a second point here after
the new line right find that to the edge
make it relative to the first point and
now see what we have here we have oh we
could parse you know a clean star of new
lines or if you just parse one new line
and actually here we just want one new
line right and then we can do a second
one down here but we're just gonna clone
this guy here wow it's a bit slow now I
just cloned this rectangle down here to
this rectangle but this guy doesn't it
only clones the internal connections it
doesn't clone the the external
connection so it didn't actually get
this binding here but that's okay
because we want to bind that to the rest
of this over here all right and now we
see we have C and D and that happens to
be the the line two
right and then we could do that in an
array add infinity to get it like let's
say a text editor that that works on
tokens okay so then we could you know
edit this with it seems to work better
when I add things to it so let's just do
it that way not the fastest thing in the
world but get the point okay so we did
this without writing well we wrote code
obviously we did we did abstraction but
you know it's in a way that's a bit
different from the way you would attack
it in a textual language okay so let's
go back to the slides
okay so what I just showed you is my
attempt my my early attempt of sort of
resetting my research and trying to
attack the core of the problem which
which is you know we don't want to just
provide this feedback loop that looks
cool we want to actually make
programmers more productive and the way
we can do that is to augment their
thinking okay there's a lot of
challenges here right now how do we
project non visual logic into 2d 3d
spaces right we're able to do it
sometimes like with lectures because you
can just think of them as boxes right I
believe and this is not true for
everybody that whenever we think about
problems what a lot of us think about
problems because I don't want to
generalize here too much we actually
convert them into two graphical images
and we work on them in our heads that
way or if we're using the notepad the
paper the boxes and the circles we
actually go ahead and you know we
already do this for ourselves it's just
it's very custom and you know it might
be challenging to capture that in the
computer right we lose the Zen of text
right now the program just isn't there
in front of us with no distraction right
now we have this visual interface where
we have to uncover the logic and you
know can we define this as a general
language as you know that's an open
question and visual design language is
actually much harder this UI sucks and
hopefully as we get more experience it
will suck less but you know the main
challenge here is how do we augment our
minds without limiting it right because
you know if you do a half-assed job on
this right I mean it's just gonna make
you slower because your mind is actually
really efficient alright so we have to
do a really good job here right so I'm
gonna put out a call to action here it's
like I want you guys to think about
where your programs come from and how
you could actually have the computer
help you out in coming up with your
programs right and and send the ideas to
me and I'll copy them and who knows or
maybe maybe build the next great
programming system okay there was a lot
of related work in this space I mean a
lot of its from the 90s some of its from
the 1960s right so so I mean you know
always building on the shoulders of
giants right but I'm not gonna go over
that so how much time do I have left
Oh wonderful great I'm at the end okay
so in the conclusion right today we are
dealing in the age of super programmers
write really good archers if you guys
seen The Avengers movie that cockeyed
guy you can like hit anything on the
first try with just shoot shoot the
arrow right and it's kind of like using
the force right because we expect our
programmers to be really super good and
doing everything in their head and they
just use the Force and they're done with
it they destroy the Death Star okay well
there's another vision coming out of
programming that's probably worse the AI
programmers you know in an adventure is
right Ultron was the enemy right this
guy is gonna do everything and he does
it really well right of course
hopefully we're like a hundred years
away from that well once we get there
that programming is over but I'll be
dead hopefully right and of course that
doesn't have a lot of positive
implications for society here it is this
is where I think the next step is for us
right is the Iron Man programmer right
you know instead of having machines do
the work instead of having people being
really good at doing the work let the
computers do what they do well and let
us do it we do well right with an
Augmented programming experience right
and it's really cool because you know in
these movies right programming is really
something that you can't make look fun
in the movies so they wind up doing
these holographic interfaces with lots
of interaction going on
and yes it's fictional it's fantasy but
you know I think it has an element of
truth there right and of course this
isn't using the force this is just we
have better targeting computers and
that's it I'm done
you wanna ask a question okay
in the back corner thank you most of
this work seem to be focused on how to
write programs
how about breeding programs because most
of my work is actually reading what I
wrote yesterday so right so I I haven't
done much work on that yet but I have
thoughts I think if you have a concrete
example to sort of that you used to
build up your work then you go back to
that concrete example when you want to
understand what you did that can be very
empowering right it's just that you know
right now I look at the code and I'm
reliant on the comments to tell me what
was in your head when you were writing
that code or when I was writing that
code even right but with the concrete
example and maybe getting more of that
thinking out onto the computer we can
solve that problem too because now you
have the concrete example that you were
working with and you can actually see
the code work and maybe you have a few
concrete examples that used to develop
the code but each of those concrete
examples is very important in
understanding the code and I and I hope
and I have no evidence that this is
where that goes
shiron so thanks for the talk
three questions so you know it's clear
that this is a great vision for talking
about how to say build up
domain-specific programs right like I
would never want to write a regular
expression again if I could have one of
your tools so generating reg X this way
seems like the obvious way to go but so
one is yeah so the concrete questions
are one is you you gave us this do it
used to early on put up this picture of
look here's this horrible mess this is
what happened when people tried to
visual programming in the past I was
hoping to hear an answer to how it's
gonna be different this time
right so the second one right so the
second one is about data-driven Ness
because I don't see enough use of using
data to drive the design of the program
and the third question is about there's
great tools here for helping people
discover existing abstractions like in
your text editor where you showed us
here you can have this function you can
have this other function for writing a
sir I worried that at that point people
are going to become more dependent on
using existing abstractions which is
great it's hard to find them right now
and not enough emphasis on building
their own so they don't actually grow a
toolkit as a programmer right so the
first problem the first for the first
question about the visual languages this
is showing non abstract visual
programming or progressively abstract
visual programming which I don't think
there's a lot of work there and then I
think that's going that kind of makes it
better and the reason why we go visual
programming is not because we care about
syntax errors which is what the
traditional argument is but it's because
you know we get that 2d space to work
with a lot more canvas a lot more things
to click on basically and the second
question about data driven is I tried to
get I get to that sort of at the end
right it's more of a work in progress
where I'm talking where I'm actually
binding these boxes to that data and in
that example but yeah it's definitely
something that requires a bit more work
for the last question I think you know
so definitely there's a lot of this the
system has to support the creation of
new abstractions via cloning and that
kind thing first of all you have to have
the ability to do it new abstractions
right not just use existing ones as for
where you where you use an existing
abstraction where you do your own I hope
that becomes like evident maybe you can
start from an existing abstraction and
realize that it doesn't work out and
abstract your way away from that into a
new one but that's the best story I have
for that right now ok yeah yeah
Thanks
at the very beginning
I don't think that's possible okay I
guess it depends on what how you define
problem but I mean in I've kind of given
up on the amine I would hope so but I
haven't handled that case so let me let
me only qualify my statement I've given
up on continuty continuity in general
right or continuous in general right
there's a lot of things that go on in
programming that that's like step
step-step so you you have to write but
anyways you have to you we have to
redefine what it means to be continuous
to be fluid right it can't just be the
changing the numbers around right so you
there's a lot of you know you could just
be progressive abstraction for example
and in this case sounds a little bit
like progressive modification or
something but yeah it's something I need
to think about more
Hey so at first you showed us something
with drawing boxes and and circles and
and and I've seen a lot of drawing boxes
in in life programming and I was going
to ask the question wait but I'm not
drawing box I'm a compiler writer I want
to see how I can do that for regular
fighters and and then you showed me this
this example with the lexer and I was
like no way but but but this triggers
another question but the thing is the
lexer example looked very different then
the box is example and it kind of
triggers the question to me that it
seemed like we need to reinvent life
programming for every single domain and
it might not skill to general-purpose
programming in a sense
how could you comment in that definitely
true in the sense that each domain has
to kind of come up with this dude visual
language hopefully it's something that
you can build within the system itself
right but that's something you have to
invest in so it could be that we're
talking about you know even
domain-specific languages is a big thing
now right maybe we're thinking about
domain-specific thinking environments or
domain-specific you know visual
modification environments you know
hopefully we can make that easy I don't
think there is a one true visual
language to to rule them all right which
is kind of where I was getting at in the
generalization comment that I was I made
about the challenges of this of this
technique we have hello so I'm a hot
beast signal scientist that's that's a
lot but I am trying to analyze EEG
signals and I would like to see a lot
more of life programming within data
science and scientific programming
because right now what I use is Jupiter
is ipython notebook and it's kind of
strange to just switch between
lysing signal in my head and visualizing
how I have to translate to numpy in some
pie and the SyFy to actually do
something with it and for example
Wolfram language try to do something
with that try to do some real-time
visualizations we've just sliders
instead of trying to rewrite a data
structure in pi don't you think that we
can approach life programming for
scientists at first and basically learn
learn at first from for example signal
analysis and then try to take that to
software development or general
programming it's it's definitely valid
and there's people working on that I
think is Luke in the room okay yeah you
should talk to Luke back there he was he
presented a paper at the workshop just a
couple of days ago in that area yes um
so some of us are actually going in that
direction I'm not really well-versed in
data science visualization and signal
processing
so maybe personally I'm just kind of
knowledge deficient in that area but
yeah it does sound like a good area
that's right for it and I think I have
had conversations with Leo meyerovich
about this too or he says that this is a
good place for this kind of work the
state of the art right now in industries
to get these feedback loop is usually
unit testing and generative charity
testing in order to specify this
constraint and there's a huge gap from
what industry is doing right now and
these visual approach were your thoughts
on a step forward from evolving what
industry's doing right now towards this
I don't think there's a small step
I mean I I there's definitely a lot of
people working on sort of the live
feedback and you know the the program
running while you're editing it and
adding a few features on top of that and
I I think that will kind of whet the
appetite but I don't think it really
solves the big problem right which is
sort of the you know how do we get in
your head right because all this stuff
kind of exists on the outside right in
the unit testing and the continuous unit
testing is all sort of post facto you
know make sure I don't break anything
but it doesn't really help you it helps
you figure out when you've done
something bad but it doesn't really help
you figure out what the good thing is
right so it's a bit of a big leap and I
have no good answer for you
in your examples you seem to equate live
programming with visual programming have
you done any research with like aural
feedback or you know smelly code smells
or you know is it because because we use
you know in in our live environment when
we're actually interacting with the real
world we obviously depend on a lot of
different senses
I think the eye is actually the highest
bandwidth per you know to your head
right so I think I think it makes sense
to look at either 2d or even 3d graphics
in the future you know then though
everything else is sort of like low low
bandwidth that's my best answer thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>