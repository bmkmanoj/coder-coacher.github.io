<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kelley Robinson - Why The Free Monad isn't Free - Curry On | Coder Coacher - Coaching Coders</title><meta content="Kelley Robinson - Why The Free Monad isn't Free - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kelley Robinson - Why The Free Monad isn't Free - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/20WVE3bkYrQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and as well caffeinated after the coffee
break so I want to start with a story a
couple of years ago I was working at a
small start-up our code base was written
in Scala and there was enough issues
with it that we decided to completely
overhaul our architecture but we wanted
to do it right we were going to be
functional we added Scala Zed we added
the state monad it was going to be
beautiful until we started seeing stack
overflow errors and this is just in
testing we haven't even deployed this to
production yet so my coworker says let's
just trampoline it and add the free
monad and this is me having no idea what
he meant by that statement that was the
first time I'd ever heard of the free
monad and I didn't know what my coworker
men or why he intended it to solve our
problems then a couple of years later
I'm at a different startup in a
different Scala code base and there was
one application there that no one wanted
to touch and I looked at the code and I
understood why it was a data application
with a really simple purpose but the
code made it look really confusing and
that made small changes take a long time
this might sound familiar to some of you
so I wanted to know if I was justified
and being annoyed with this application
that was using free monads to abstract
this data store so i decided to figure
out what the heck of free monad is so
you don't have to my name is Kelly
Robinson I am a data and infrastructure
engineer at a company called share
through in San Francisco and today I'm
going to talk to you about why the free
monad isn't free a couple of things
about myself I am an industry programmer
I have no background in academia and I
think this talk is really interesting
for a venue like this because I know
that my opinions about the free monad
have people that agree with me and
people that disagree with me and there's
definitely a mass on each side of the
argument so it's good to have the
conversation and get this out there to
see what people think
so before I talk to you about why the
free monett isn't free I promised to
explain what it is we are going to do
that using mono and functors to build up
our explanation dunno understand what
monad is and then we'll talk about the
free versions of these structures why
people use them and maybe why you
shouldn't and then if you don't use the
free mon at in your code what are the
alternatives available to you and then
wrap up with talking about some of the
real world applications of this that we
do see this presentation has a lot of
code it's all in scala if you're not
familiar with scholar want to look at
this later everything's available on my
github here's a link okay we've probably
heard monads or mono it's in the
category of endo functor what does that
mean we'll start with mono aids we're
not going to explain this using category
theory this is you know the ideas for
these structures come from mathematics
but in the language like Sally you don't
need the mathematical definitions to
explain them there is a way to explain
them using the language and so these are
ideas a language like Scala we have to
implement the structures and so for a
Mon way this is some type that follow
some properties it's going to have a
method to a pen to take two of that type
and turn it into a single instance of
that type and then some method usually
called identity that's going to be a no
op or empty so again to of one type
coming together to produce another
instance of the type that is a mono ID
and like I mentioned there are some
properties that it follows so identity
is a no-op when it's going to be used
with the append method and then there's
this idea of associativity or saying
that the grouping you can think of it
with parentheses or in any other way
that's not going to matter for a mono ID
and Buzz Lightyear is right there are
mono aids everywhere we can look at a
couple examples string concatenation
really great example of a mono ID for
this example the append method is going
to take two strings put them together
and return another instance of a string
and then the identity method the empty
value here is going to be the empty
string another example integer addition
this is another great example of a mom
annoyed you can take two integers put
them together and you have another
instance of an integer and the identity
value in this case is going to be zero
okay quick overview of mono aids let's
move on to functors a functor is going
to be a family of types that is going to
apply some it has a map method and the
map method will apply some function to
everything in that family and then it
will return a new container if you want
to look at this with pictures you can
think of it as applying a function there
the function in this case is multiplying
all the values by 2 and then returning
the new container with all the values in
the container x to the result is on the
right like with mono aides functors has
some properties that they follow you
have the identity value which is going
to be the no op function that if used
with math is going to not change the
input and then composition is like
associativity that we saw with mono aids
but that's to say that the grouping
doesn't matter and that's if you chain a
bunch of map operations together it's
the same thing as doing one giant map
with a bunch of logic in it and that
brings us to monads I really like this
quote from a stack overflow post that
says the term monad is a bit vacuous if
you're not a mathematician an
alternative term is computation builder
so this audience might have some
mathematicians but for the industry folk
upon us this is a really helpful mental
model so a monad is some type that's
implemented the pure and the flat map
methods it's a container a context a
collection the pure method is going to
lift a value into that context and
create the computation builder and then
the flat map is kind of like map it's
going to like a functor map over the
values in the container apply function
to it and then flat in the context and
we'll see what that means the
interesting thing about defining monads
like this is because now we can work
backwards to define the functor and
monroy top erations once you've defined
pure and flat map you can define map
more explicitly you can see here how map
is using the flat map in pure functions
in its implementation and so the Scala
code here has abstract definitions for
pure and flat map but it then it's
implemented the map function without
needing to go back and do that
separately and flat map can also define
the mono atop eration of a pen and I've
been very explicit about how I've
defined this year because the append
method here is evaluating the functions
as it's chaining operations together
composing them and then returning the
new value so monads also have some
properties the laws apply here flat map
with some identity value is going to be
a no-op and then composition follows the
grouping of the operations won't matter
you can do a giant flat map with a bunch
of logic and the function or chain a
bunch of flat maps together so if we
look back at our picture example for
functors this is what it looked like
when we were mapping with a function but
what happens if that function that we're
mapping with also creates a new context
like we saw here if you map this then
you're going to be left with some nested
triangles the reason that flat mapping
and monads are useful is because it does
flat in those contexts when you flat map
over this kind of operation you're left
with a flat in context in a single
triangle and that's why monads are
useful they're useful for composing
functions for values in a context
mapping allows composition and this type
of construct is really useful for
managing side effects monads make side
effects explicit and we see this
everywhere in our programs you can think
of things like lists and futures and if
you go back to the triangle example we
don't want to be left with nested
triangle it's just like in the returns
of your programs you don't want to be
left with nested futures okay now we've
defined what those structures mean we
can talk about the free versions
before we do that though what do we mean
when we say free when we say free we
mean free to be interpreted in any way
freeing the sense of unrestricted and
not zero cost or for the Richard
Stallman fans in the room free as in
freedom not free as in beer so there it
is already the free monad isn't free but
in order to build up our understanding
we're going to again start by looking at
the free version of mono aids so will
refresh our definition of ma nodes we
have an append method and some identity
method in an order for a mono to be free
we want it to be free from
interpretation and that means there
can't be also any lost data during that
append step that's pretty vague so we'll
look at an example list concatenation is
a good example of a free ma noid in the
append step here we're just shoving the
data together we're not losing anything
about the data that we shuck together
and it's also important here that we
define this with a generic type a the
contained type in the list could be
anything it could be in it could be
strings it could be other complex types
but because it's generic the only
operations that we can do on it are the
mono definitions here the methods that
we've defined and that keeps it free
because we don't know anything else
about it and therefore we can't
interpret the data in any special way
keeps it free from interpretation in
contrast if we look at our integer
addition example this is not free
because we're losing information about
the input data when we transform it into
the added integer there's a special
algebra that's happening here that is
not free from interpretation it's an
explicit interpretation for the type and
that brings us to free monads in order
for a monad to be free we don't want to
lose any data and that means no
evaluating functions while we're
changing operations together and while
we're flat mapping if you look back at
our example that we use defining these
pictures as triangles this fails the
free test we're evaluate
that function in losing data in the
result we don't know what the function
was and we don't know what the input
data was in that final result so how do
we do this without losing the data the
important thing is is that we have to
store the data and the functions as we
chain operations together and
effectively build up a syntax that we
can evaluate at a later point so I'm
going to walk through how we would do
this in Scala well look we'll start with
a trait will call it free we'll add a
class return that's going to be used in
our pure function and to indicate that
there's no more computation and then
we'll add a class suspend it's going to
take some family of types a and it's
going to be used to suspend the
computation of that container until
we're ready to process it and then we'll
add a class flatmap that's going to take
another instance of free and a function
from any type a to another instance of
free and this looks a lot like the
method signature for flat map and that's
going to help us out and finally we'll
add some helper methods on our trait
that will be used in the computation and
allow us to chain our operations using
the Scala syntax and we're going to use
this to build up the types to store the
syntax and the functions but again we're
not going to evaluate anything when we
do this we just want to store it so
let's look at an example let's build a
free monad for actions on a to-do list
so here we've defined some syntax for
things that you can do to it to do this
you can create a new task you can
complete a task and then we'll also add
some methods that are going to lift
those operations into our suspend case
because we want to suspend the action
until we're ready to interpret what we
want to do again these functions aren't
doing anything they're just talking
about what we want to do and this is why
it's free it's free because we haven't
done anything so let's see what this
looks like so when Scott Louis is pretty
cool you can then chain these together
using a for comprehension and that's
syntactic sugar for flat mapping you
could write this as another way using
flat mapping in most languages and this
is great because it is
chain and this might look familiar to
programs that you write especially in
Scala the difference here is that
nothing has actually happened yet so we
can expand this into its resulting data
structure and here it is in its explicit
types and you can see this is a big
nested data structure where we're
storing all of the information about
what we want to do we're shoving the
data together as we chain it nothing has
been evaluated there aren't in the
operations defined and that's why it's
free again if we look back at our
previous example this isn't free because
the result has lost the input data the
corollary to this in the free monad
world would look something like this you
would store the input data with the
methods and this is free because in our
minds we know what the star function
means but we could interpret that to be
anything in a later point okay why would
anyone do this why do people want to use
free monads there's a few reasons a lot
of people talk about deferring side
effects i mentioned that monads are
really useful for managing side effects
but free monads make it possible for you
to truly defer them you're composing
functions without computing them and if
you delay all of that evaluation until a
later point that means you're delaying
all of the execution and the side
effects until that later point in the
syntax tree that we defined that dsl the
domain-specific language for our to-do
list that means that we can define
multiple interpreters at that later
point at the evaluation point and that
can be helpful in a couple of ways it's
like if I write down a list of
instructions and hand it to everybody in
this room you're probably going to
interpret that a little differently and
we can program those interpretations of
the list or the structure that we give
you and then if you imagine something
like this some nested functions doing a
lot of looping these do something
functions could do a lot of things in
the course of your programs but that's
just it in the course of your programs
it's going to look something like this
every function in the monadic context is
going to be added to the stack so
remember my coworker let's just
trampoline ax and add the free monad
when we talk about trampolining we're
talking about expressing all of the
control flow all of the function passing
all of those change functions putting
them in a loop instead of putting
additional functions on the stack the
free monad uses trampoline Ian when it's
doing its evaluation and it exchanges
stack for heap trampolining and the free
monad all come down to exchanging stack
for heap we built up these data
structures that's the putting the data
on the heap instead of putting
additional function calls on the stack
in the not free version of this world
your result would look something like
this you would have a bunch of functions
that would be stacked up that would be
putting all these additional function
calls on the stack and in the free
version of this your results eyes your
data structure the heap that you're
using would grow and grow with all the
information until you're ready to
process it so if we look at the example
that we built up this chain data
structure we built up this list like
syntax and we have already avoided
putting function calls on the stack and
so we want to make sure that we don't
let that work go to waste and so we want
to evaluate it using a loop and so let's
talk about what it means to evaluate a
free monad we'll look at the function
signature for what this looks like in
Scala and we've written a generic
function here for how we would do this
and this is going to take some input
your free monad it's going to take some
transformer that's going to take your
free mon an input and do the translation
do the evaluation into your output type
and then we also have this implicit
condition the transformed type is also a
monad and that means that we can stop
the execution in the chain so that we
can use something like flat mapping with
the context the functor transformer is a
tricky part here but it's what allows us
to have one generic run function and
define those multiple interpreters that
I talked about so again just wanted to
touch on this real quick you might also
hear functor transformers called natural
transformations I think that name
doesn't make any sense and so I wanted
to be more explicit about what it does
because it is it's taking one functor
and turning it into another ok this is
the function body for the run function
and this is already a lot so I've
intentionally left a lot of it off but
here it is in total and you can look at
some of the important bits and the
points i want to point out are that this
is going to use tail recursion and
that's going to do the looping in a
language like Scala tail recursion
optimizes recursive calls and puts them
into a loop instead of putting
additional functions on the stack and so
that's using the trampolining and then
it's going to pattern match on the
return suspend and flat map cases in
order to evaluate the functions if we
look at what happens in those cases I
wanted to point out what happens when it
hits the suspend case and this is where
the transformation happens this is the
interpretation this is the evaluation
and so we'll look at what some of those
interpreters look like but first I
wanted to point out that we can be even
more explicit about how we do this we
can write this using a loop and if
you're someone that's used to functional
programming looping seems scary and
really non idiomatic to some languages
including scallop but I just wanted to
point out that this is doing the same
thing the logic here is the same as it
was on the last slide but we can be
explicit about it we can be explicit
about the fact that we're looping and
using the trampolining to achieve our
goals so a couple notes about evaluating
we want to apply the transformation on
the suspend case and we want to
trampoline for stack safety that's again
using the loops so let's revisit our
functor transformers the things that are
going to be doing the interpretation and
we can look at a couple of interpreters
that we can define for our to do list
example so we can define a test
interpreter and I've defined a trivial
context here that aid type and that's
going to our test interpreter here is
going to take a mutable map in place of
whatever production service you're using
probably a database then we can look at
the apply method here what's going to
create this interpreter when you
instantiate it and so this is where
it gets interesting this is where that
domain-specific language comes in handy
we're going to evaluate our to-do lists
syntax and perform an action based on
what the syntax is and this is where all
of that interpretation is coming into
play this is where you actually define
what your program is going to do and in
this test interpreter we're going to
build up the model based on what the
action tells us to do and this is how
you would run it you take your to-do
list function list the to do's there
feed it to the run free function and
then give it an instance of the
interpreter that you want to use and
then we can compare it to our expected
map for something like this though this
test might be shadowing some business
logic we put some boolean logic in there
and that might defeat the purpose of
testing so we can define a different
type of test interpreter and so the
action test interpreter here is going to
start with a list of actions and this is
also going to test the order of actions
that we expect and so here when we
pattern match on the syntax we're going
to append the action to the actions list
and then when we run it we instead
expect a list of actions in the order
that they occurred and the cool thing
about this is that your production
interpreters are probably going to have
side effects you're probably going to be
writing to a database and that could
cause problems for you so defining
multiple interpreters and defining test
interpreters like this allows you to
test that side affecting code without
using things like mocks and this is a
really common use case for things like
the free mode as people love doing this
they think it's much more clean than
using something like a testing mock so
we can look at an example of the
production interpreter here I've written
it here to transform to ask allaah
option type that's either some or none
and this doesn't have to be the same
return type as it is in the test and
it's probably not going to be but it is
important that that transform type is a
monad so that the chain operations will
stop if this fails in this case if this
evaluates to a nun so again some of the
justifications some of the reasons that
people talk about wanting to use the
free monads we really want to defer
those
side effects and I don't know of another
better way that to truly defer side
effects and using something like this
and then you can talk about the multiple
interpreters and production you're
probably going to be writing to a
database or doing an HTTP request or and
queuing messages to some service and
then in tests you can suppress all of
those actions and instead would turn the
expected actions that you want to see
but the thing about things like the free
monad is as industry software engineers
a lot of people introduce these concepts
into their code base simply because they
can it's a neat solution but I always
get nervous when I see neat solutions in
industry code because it usually means
that there's an easier way there's this
really excellent talk from Jessica curb
at a scala conference last year where
she talks about scaling intelligence
this idea of blue skies scala the meat
of our business logic that's somewhere
between the green grass the easy stuff
in outer space the complicated stuff the
free monad isn't free because it's in
that outer space category it's
impressive but the path to get there is
broken and why is it broken well there's
points like this and this is pretty
controversial but this comes from marios
Erickson who is one of the architects at
Twitter and this was in response to a
discussion about calling a method in a
library a mathematical name when the
method didn't exactly map to the
mathematical definition and so his
response to this is that programming
isn't math and sometimes we hoist
vocabulary that confers similar meanings
some people think that programmers need
to be mathematicians or that we can only
make those literal translations but i
agree with marius here part of the
reason software has been so successful
as an industry is because we're really
good at adapting and automating ideas
and our biggest skill is exactly this
creating abstractions to translate ideas
to machines that can perform them more
efficiently than we can as humans think
about it programming languages exist for
humans otherwise we don't be writing by
name
and who wants to do that but we want
good abstractions things that make
things easier for us as humans you can
think about it what David Nolan was
saying this morning about the ecosystem
we want to reduce the friction for the
programmers we want things that are
going to make it easier for me to look
at code that I wrote three months ago or
even three days ago and understand what
I was trying to do the reason that this
can be problematic is when the
abstractions are more confusing than
they're worth I said that this is what
we're good at as an industry but it's
also something we're kind of bad at it's
really hard to know when you found a
good abstraction the free monad is a
mathematical concept that has been
applied to the programming domain it has
good abstractions that I'll talk about
but for a lot of us it's not necessary
and why isn't it necessary why should we
avoid it well there's stuff like the
boilerplate that abstract syntax tree
that domain specific language that we
defined for three actions on a to-do
list that's going to be a lot of code
and it's something like a production
system of yours you're taking all of
your implicit actions and turning them
into explicit data structures and
libraries are starting to develop ways
around this they're starting to develop
some cogeneration I've been told but
then there's still things like the
learning curve and it's easy to be
frustrated with things like this and it
can take a really long time to grasp and
that's not only because they're
difficult they're not easy but a lot of
the explanations out there assume there
they assume the wrong context for the
learner they assume that you're a
haskell programmer or that you have a
PhD in category theory neither of which
I had and neither do a lot of Industry
programmers and that can make things
like maintaining this in production
systems really hard this can make it
really hard for a team to maintain a
codebase containing these types of
abstractions we want to stay in the blue
sky we can take an airplane to get from
point A to point B a rocket ship is too
expensive so if we're not going to use
the free monad what are the options for
us
well before we talk about the
alternatives it's important to know your
domain and I'm not saying that we can't
use the free monad I'm saying that we
need to be mindful of the applications
that we make like everything in
programming it's all about trade-offs
and totally dependent on your domain so
first know your domain especially for a
language like Scala there's a spectrum
of how functional you can be and a lot
of people think of it in terms from Java
to Haskell no the expertise of your team
this spectrum is relevant for Scala
programmers but think about the
languages that your team is using think
about the expertise of your team a lot
of my team came from Java so we're
pretty centered on this spectrum I think
we have a really good balance we make
use of the functional style but we're
not too far to the right there and we're
more likely to hire X Ruby or X Java
programmers and we are X academics or X
Haskell programmers and so that makes it
easier for us to stay somewhat centered
on that spectrum but in your domain
think about what your language is good
at is it opinionated if it's not you
have to make more decisions about this
type of thing and think about the
abstractions you're using are they clean
are they easy to understand for people
new to the code base and if you're
writing a greenfield project a new
project from scratch ask yourself are
your co-workers going to understand this
do you have the time in the tooling for
these abstractions and is it necessary
for your business logic I think that's a
big one that a lot of people don't ask
themselves so now we've talked about
understanding your domain what are the
alternatives available from maintaining
stack safety well if your programs are
more object driven or imperative i can
definitely suggest using loops and this
is hard if you're highly invested in
functional paradigms or if your language
doesn't allow it but keep in mind that
looping can be better in a language like
Scala you think about impaired or
idiomatic Scala being using maps and
that kind of thing but if you look under
the hood of the standard library it's
using all sorts of bars and can build
from and these are ugly abstractions
that are more
efficient then using a traditionally
functional style to do this it turns out
that looping and mutating state which
are things we shudder a dysfunctional
programmers are more efficient and so
the standard library is this
optimization on the common functional
style it's ugly but it provides a good
abstraction to us and we don't have to
think about it it's a joke for any scala
programmers in the room so there's also
alternatives for managing side effects
again I don't know of good ways to truly
defer side effects but you can
definitely manage side effects with
other options you can use other built-in
monads you can error handle over
exception prone code and keep in mind
not all side effects are bad things like
logging are really helpful I remember
Heather Miller saying that in a strange
loop talk a few years ago let's look at
an example so this is some code that a
guy named Rob Nora's wrote an entire
library using the frame 0 neg called
doobie to abstract away the jdbc using
the Fremont won't monett and he was
saying there's too many problems with
code like this it's not safe this can
throw exceptions and you can't chain the
operations on the result set that's all
true but the only way to manage those
exceptions isn't using the free monad
error handling is good but the
functional programming overlords
probably aren't going to smite you if
you decide to throw this into a try
except block so here's a code example of
something I wrote a few months ago sure
you can't chain it but it works and it
did the job that we needed it to do it
error handled over a database query so
that we can make sure that that code was
more safe if there's an easy way to make
something more functional I'm usually
going to take it but it's all about the
trade-offs and you have to keep in mind
your domain ok we can wrap up by talking
about some of the applications that we
see if this stuff is this is something
that you're interested in you don't have
to implement this from scratch a lot of
languages have libraries that have
already been created for you in some
languages like Haskell have this
built-in
and then we can talk about some examples
of things that I think have pretty good
abstractions around the free monad for
all of my talk about alternatives do be
is pretty nice it has some clean
abstractions and to the user it is
relatively friendly and then we can look
at something called task from a scala
functional programming library called
scala z and this is a common abstraction
for concurrent programming and it's a
good abstraction for multi-threading and
here's our example of in queuing
messages to Amazon's simple q service
and it's a clean abstraction and I'm
really grateful for it because under the
hood it looks something like this and
some of you might love looking working
with type lambdas or understand at first
glance what this does but I don't want
to have to and this is the kind of code
that motivated this talk from a place of
pessimism because there was stuff like
this lurking in production services so
what happened with my experiences so at
the first company shortly after that
co-worker recommended that we introduce
the free Mona to solve our stack
overflow errors he left the company and
we've never added a free monad and that
was really good in that domain because
at the time we were writing an API for a
web app and if we were seeing stack
overflow errors that meant we had
grossly overcomplicated our business
logic I understand if maybe in your
domains you have deeply nested logic and
you can't avoid it but in that
circumstance we could and then there was
the datastore app that was using the
free monad as an abstraction layer and
I've concluded in the months and years
sense that I first encountered that
problems with that code base are largely
unrelated to the fact that it uses the
free monad it was grossly over
engineered and that is a problem when
you start to introduce abstractions like
this and this is something that we have
to keep in mind as industry software
engineers most of us are getting paid by
a company that is using us to make them
money and a lot of us don't have these
large-scale problems that necessitate
these kinds of abstractions so again
know your domain
so after talking to a lot of people
about the free monad I'm still not
convinced that it's the best solution
but I can see how if used wisely can
create composable and safe code it
really comes down to the fact that we
have to be judicious and our use of
these abstractions just because we can
doesn't mean we should sometimes it's
okay to trade the most functional style
for the sanity of your code and the
sanity of your team I like to say that
you should assume competence but don't
assume knowledge we have to share that
and if you're somebody that understands
these and has the knowledge about these
concepts share it and make sure that you
explain it in simple terms for people
not everybody knows what a monad is and
you can't assume that they do so I used
to think that the free monad was a piece
of crap I don't think that anymore but
if you're like me from a year ago and
somebody is talking about introducing
this into your code base I hope I've
given you some tools to evaluate whether
or not that's a good idea once again my
name is Kelly Robinson here's my contact
info and thank you for listening
yeah do you think the problem is more
that we have Jennifer languages and
maybe they are and that the problem that
we're encountering is more with the
language yeah so the question was is
this a problem because of the language
and the language design is to general
purpose and I think that can be true for
certain languages especially in the
Scala ecosystem there's a lot of
conflict around these types of subjects
and functional programming is not a
first-class citizen in the scholar
language and like I said these are
abstractions that you have to implement
in the code if you want to use them
there's no built-in monad type in Scala
and it's something that you think of
lists and futures and options in Scala
as monads and they are you know in
theory but they don't extend some monad
trait in the back end so a lot of people
writing Scala don't ever have to know
what a monad is there's a lot of ways to
write production Scala code that don't
involve using monads if you're writing
something like Haskell those are built
into the language and so I think a lot
of the explanations are more relevant
there and they might do a better job of
explaining it but that's only if you're
a haskell programmer it's not something
that everybody that's a functional
programmer does know or needs to know
anyone else
yeah yeah so the comment was it's a
theoretical representation that is
applied in the practical domain and so
in some languages like JavaScript you
have things that are using monadic
structure more or less but you don't
have to use those words to describe them
anyone else thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>