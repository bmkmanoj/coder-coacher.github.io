<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ron Pressler - The Practice and Theory of TLA+ | Coder Coacher - Coaching Coders</title><meta content="Ron Pressler - The Practice and Theory of TLA+ - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ron Pressler - The Practice and Theory of TLA+</b></h2><h5 class="post__date">2017-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/15uy9Ga-14I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">time and the auditorium room we are
taking questions at the center Mike
we're not running Mike's due to the size
of the room so if you have questions you
can line up there and I'll take them
after at the end of the talk all right
and so take us away hi my name is Ron
Fesler I'm a programmer and today I'm
going to talk to you about GLA plus last
year at Korean I gave a talk about the
essential theoretical difficulties in
writing and very fine correct software
which was called white writing correct
software is hard and why math alone
won't help us today's talk may be called
how math and thinking can help us so
rather how maths can help us think
better now many of the languages and
techniques and tools that would deal
with in programming are basically
designed to help us think less so there
are things that we don't have to worry
about but at the end of the day the lion
sure the programmers work is still
thinking about the problem at hand and
this is something that GL A+ can help
with Leslie Lamport who create at ela
class wrote that for quite a while have
been disturbed by the emphasis on
language in computer science I believe
that the best way to get better programs
is to teach programmers how to think
better thinking is not the ability to
manipulate language it's the ability to
manipulate concepts but how does one
teach concepts without getting
distracted by the language in which
those concepts are expressed my answer
is to use the same language as every
other branch of science and engineering
namely mathematics so TL A+ is a
pragmatic mathematical language for
specifying and verifying software
systems specifying is just another word
for describing so you describe your
software system or program in math and
you describe your assumptions about it
and you can reason about whether or not
your description of the program actually
satisfies your assumptions now every
mathematical theory even a relatively
simple one like TL A+ is a broad subject
so today I'm only going to cover the
basics and show a few highlights but
everything I'm going to talk about today
and much much more
is
covered in great detail in a four-part
blog post blog post series that I posted
up there so if you find this interesting
everything is in there one of the things
that makes you late Plus so effective in
practice is not just the language itself
but the tools that come with it in
particular there is a model checker
called TLC that takes your description
of the program and your assumptions
about it and automatically verifies that
your assumptions hold for your program
and if you like writing formal proofs
there is a very nice proof language for
tle Plus and an interactive proof
assistant called teal apps but today I'm
not going to talk about the proofs about
the tools at all just about the language
and its mathematical theory TL A+ was
designed to be universal and scalable
and still simple so it's designed for
any type of system of any size of any
complexity and it's made to be used by
ordinary engineers not formal method
experts or logicians it's a rich
mathematical formalism with a very
interesting theory of some very deep
theorems but its focus is on reasoning
about actual engineered systems not
about math in general and end-to-end
verification which is the ability to
prove high level correctness properties
all the way down to machine code is not
focus of tle plus it's possible it's not
a focus and that's a good trade-off to
make because end-to-end verification is
not feasible for the vast majority of
software anyway and also it's not a
requirement
teal A+ has been put to good use in
industry it's being used at Amazon to
design and verify many of their AWS
services and this is in a report a
report Amazon wrote they say that and
even an entry level engineer can learn
teal A+ without any additional help of
training about two to three weeks and
their experience with TL A+ has been so
positive that management at Amazon
actually encourages development teams to
use TL A+ there are a few features
distinguishing
applause from other specification
languages like Isabella the first
is that it is a simple mathematical
logic rather than a programming language
or a logic that is based on a
programming language this gives us very
very simple semantics it's very easy to
tell what steal A+ specification means
and because it's not appropriate it's
not a functional language it's not an
imperative language it's just math it
doesn't have a concept of a function or
a subroutine doesn't have a concept of a
process it doesn't have a concept of our
stack it doesn't even have a concept of
memory we define whatever it is that we
want to think about and it helps us
concentrate on the relevant details and
it alleviates something that Lampard
calls the wharf Ian syndrome which is
the confusion of language with reality
it also differs by describing
computations not as functions but rather
as dynamical systems a little bit like
how ordinary differential equations
describe continuous physical systems and
the benefit to that is that any kind of
program batch and sequential or
interactive concurrent parallel they're
all described in here a plus in exactly
the same way their properties are
described in exactly the same way and
the proof techniques for proving those
properties are correct are also the same
and it offers very rich and interesting
forms of composition and interesting
notions of abstraction and we'll see
later on finally TLA plus the concept of
non-determinism is very important in TLA
plus and what this essentially means is
that everything we say is just a
description of our system at an
arbitrary level of detail and i want to
spend a minute about that and about the
difference between a program and an
algorithm so a program is a description
of an algorithm that is sufficiently
detailed to be automatically compiled to
an efficient executable but an algorithm
may lack that detail let alone a
high-level description of a large
software system let me give you an
example
so this is
the description of quicksort taking from
Wikipedia it has three stages and the
first stage says picking the element
called pivot from the array but which
elements and the reason it doesn't say
which element is because it simply
doesn't matter no matter which element
you pick quicksort is going to work and
sort so even though this description of
the algorithm is complete you can deduce
from this that it actually sorts and
that runs in worst case quadratic time
complexity it cannot be efficiently
compiled because if you want to if you
want to write a program you have to tell
the computer which element to pay you
have to take the first one that last one
it were random one but this says it
doesn't matter and later we'll see why
being able to mathematically describe
quicksort at this level is beneficial
okay so let's get started with a theory
I said that computation is a discrete
dynamical system so first a dynamical
system is a function of time a
continuous system is one where time is a
continuous variable in a discrete system
time is a natural number but a function
of natural numbers is just a sequence so
we're talking about sequences the kind
of objects that or how t Laplace
describes computation is what Lambert
calls this standard model so a
computation which is a single execution
of a program is called a behavior a
behavior is an infinite sequence of
states it is always infinite a state is
a mapping from variable which are just
names to values so a variable can take
different values at different states and
would define a terminating behavior to
be a special case where at some point
the state no longer changes it just
repeats forever we say that it stutters
forever
now it's important for me to point out
that when I say state and perhaps this
is a symptom of the war fient syndrome I
don't mean anything like global or
mutable State or anything that some
programmers say is bad but it's anything
in a program that can change over time
so if you're thinking lambda calculus it
can be a beta reduction that's a
state change or a recursive call or
effects like I am
they're all just changes in states and
to drive this point home so this is a
pure functional program for computing
the greatest common divisor it has
absolutely no imperative assignment in
it and yet the variables x and y point
to different values refer to different
values at different states at different
depths of the recursion
okay so state does not mean imperative
assignments so we have a behavior that's
a single computation what's an algorithm
an algorithm is going to be a set of
behaviors Y is an algorithm a set of
behaviors rather than just one because
it can have many different executions
for example a different execution for
any input or any interaction with the
user or if it's a concurrent algorithm
then it has different executions for
different scheduling by the operating
system or it can just be a high-level
description of an algorithm like
quicksort before that says you can pick
any pivot and different behaviors
correspond to different choices of the
pivots a property of anything can be
thought of as a set - so the property
being read can be thought of as the set
of all read things and to ask whether
something is read is the same as asking
whether it's a member of the read set so
we'll define Behe up a property of
behaviors as a set of behaviors but
according to that logic a property of an
algorithm is a set of algorithms so a
set of set of behaviors but that's
getting a little too complicated so
we're going to do a little trick our
logic will only allow expressing
properties of algorithm that are true of
an algorithm if and only if they're true
for every execution so for example
quicksort actually sorts in every
execution it runs in worst case
complexity a quadratic time complexity
in every execution but we can talk we
cannot talk about its average case
complexity because that means that some
behaviors can run faster or slower so
that's a property we can't express in
this logic and once we do that
we can also describe properties of
algorithms as sets of behaviors why
because then to ask whether or not an
algorithm has a property we ask whether
the set of behaviors of the algorithms
is a subset of the property so both of
them are just sets of behaviors and this
is the only object we're taught we talk
about a TL a formula describes a set of
behaviors now what do I mean by
describing something with logic how do
we speak in logic so a formula is an
expression that is equal to some boolean
value true or false and depending on
which assignment of values it says it
becomes equal to true or false on it can
describe a set so let me give you an
example so this is the formula with the
single free variable X and it says this
so X is a natural number a member of the
set of natural numbers and X is greater
or equal greater than or equal to 2 and
X is less than or equal to 10 and it is
either so the only assignments to X that
make this formula true are these numbers
and we say that this formula specifies
this set TL a plus can be thought of as
as made of two parts the by far the more
important one is TL a the temporal logic
of actions and that's the logic that
describes the dynamic behavior of the
program what we talked about
the behaviors and how they relate to one
another and the plus part is the part
that describes the values that variables
can take at each state so our data and
the the operations on data that are
going to take us from one state to
another and in TL a plus the data
language as I call it is based on set
theory the basic building block of a TL
a-plus specification pretty much the
only one is a definition a definition
just gives an expression name it can be
parameterised in which case we call it
an operator operators can be
higher-order so an operator can take
another operator as a parameter we can
have in fixed operators we can make
local definitions inside other
expressions and anonymous operators now
it's important for me to point out that
operators are not functions functions of
something else and for programmers it's
best to think of them as macros they
pretty much do syntactic substitution so
the data language we have the familiar
logical connectives so this is negation
not this is disjunction A or B this is
conjunction a and B implication if a
then B and equivalence a if and only if
B then we have the the quantifiers the
first-order quantifiers there exists an
X such that some predicate holds or for
all X and property holds this is a named
TL a plus for Hilbert's Epsilon operator
this expression takes some value that
that satisfies the predicate P if one
exists otherwise it's undefined and we
have some contracts that are similar to
the ones from programming like if then
else so the value of this expression is
a if the predicate P is true otherwise
it's B then we have sets so the standard
the standard modules that come with CLA
plus define the set of natural numbers
integers and reals those are the
mathematical sets so they contain all
the natural numbers all the all the
reals and so if we want to work with say
32-bit integers we're going to have to
define them or 64-bit floats it has a
set of boolean true and false and string
is the set of all character strings we
can define our own sets using set
comprehension so this says that this is
a set of all natural numbers X such that
they are either so this is a set of all
even natural numbers and we can define
the same set like this so take the
natural numbers and multiply them by 2
and we have other familiar set theory
operations then we have functions
functions are not how we describe
computations in TLA plus these are the
usual mathematical functions they don't
even have to be computable any
mathematical
function can be defined so this is the
set of all functions from set HSN B this
is the square function on the integers
we can have recursive definitions of
functions so this is a factorial
function and in terms of syntax we apply
a function with a square brackets to
distinguish it from operators we also
have sequences or lists they can be
finite or infinite but they are just
functions of some prefix of the natural
numbers beginning with 1 so they're 1
based we have the set of all finite
sequences with elements in the set s we
have special syntax for small sequences
called tuples and we have all the
regular sequence operations finally we
have records like structs and records
are just functions from strings to
values but we have nice syntax for them
so we basically have all the tools we
need to define any data structure we
want and any operation or data so now we
get to the TLA part the dynamic part so
a variable that can take a different
value each state is called a temporal
variable and we introduced one a free
such a free temporal variable with a
keyword variable or variables and we
also have temporal quantifiers that are
bold I'm not going to talk much about
them and we're going to describe how GL
a formulas look by building them up from
expressions and expressions in CLA you
have several levels where an expression
of a low level is just a degenerate case
of all higher levels so the the simplest
lowest level of expressions are constant
expressions that are the same in all
states number 3 or these predicates here
I'll hire let the high one level up our
state functions state functions as their
name suggests our can take a different
value at every state and if x and y are
temporal variables then the expression x
is a state function so is the pair X Y
or X plus y these last two because
they're state functions are equal to a
boolean value they're called state
rheticus but since their predicate and
they are equal to a boolean value they
can serve as formulas so the formula x
equals 2 and we said that every formula
specifies a set of behaviors the formula
x equals 2 specifies the set of all
possible behaviors where the variable X
is equal to 2 in the first state so as a
predicate as a formula specifies the
first state of the behavior the next
level is called a transition predicate
or an action and this is maybe the most
important kind of expressions in TLA and
the ones that give the temporal logic of
actions it's named an action is a
predicate on two states one of them is
primed one of them is unprimed we access
the the prime state with primed
variables and the unprimed state with
unprimed variables we can also have
primed expressions and the prime
expression is the same as priming all
the temple variables inside it but it's
best to think of it simply as the value
of the expression in the prime state so
it just talks about two states and
answers true or false whether there can
be some relation on what relation so
these are all predicates so as a formula
taken so let's take a look at this one
an action specifies the first two state
or the relation between the first two
states of the behavior where the
unprimed state is the first one and the
prime state is a second so this
expression taken as a formula says that
specifies all possible behaviors where
the value of x in the second state is
one more than the value of x in the
first stage the last level if that of
temporal formulas and this one is
defined recursively so if F is some
formula then so too is box F and a
behavior Sigma satisfies box F if and
only if every suffix of the behavior
satisfies F so the suffix Sigma plus n
is the behavior with the first n states
removed so it looks like this this is
Sigma plus zero this is Sigma plus one
Sigma plus two and so on
so now what happens if we put a box in
front of a state predicate so box P is
true if P is true for every suffix but
we said that a state predicate specifies
the first state of the behavior and the
first state of the suffix Sigma plus n
is Sigma n so box B says that fee must
hold for Sigma 0 Sigma 1 and so on
so box D means that P is true the state
predicate P must be true at every state
if a is an action that works on Tuesdays
then box a is true if a is true for
every suffix but the first two states of
the suffix Sigma plus n are Sigma N and
Sigma n plus 1 and so a must be true for
Sigma for the first two states the
second and the third and so on so box a
means that a is true for every pair of
consecutive States now because we can
put box in front of any temporal formula
we can put it in front of other formulas
and have box in so if we take a look at
this one and we follow the definition
I'm not going to go over it with you but
it means this whenever X is equal to 1
then from that point on y must be
greater than 0 so after everything we've
seen we can understand how to read the
box operator and it basically means
always or henceforth from that point on
so we read this formula as always if X
is equal to 1 then from that point on or
henceforth Y is greater than 0 using the
Box operator we define another operator
called diamond and diamond F is defined
to be not box not F so let's think what
that means not always not F or not never
F or eventually F so diamond F says that
F the the formula F will be eventually
true at some point in the future we can
combine them so diamond box F is
eventually always starting in some point
in the future F will always be true and
box diamond F
says that at any point in time F will
eventually be true which is the same as
saying that F must happen infinitely off
so what does this formula mean so it
says that X must be equal to zero in the
first state and from that point on the
next value of x at every state is 1 plus
its current value so it specifies an
algorithm that simply increments X at
any state forever and this is very
similar to how we describe continuous
systems with ordinary differential
equations where we say that the value of
x at time 0 is 0 and then the derivative
of X is always 1 and to see how similar
it is and I'm lying here a little bit
but we can define this operator this
difference operator and the formula up
here is equivalent to this one so it
starts at 0 and the derivative is always
1 okay so let's look at a more elaborate
specification we're going to strive an
hour clock and our clock is a clock that
displays just the hour it has a single
temporal variable H which is the hour
and H can start being any any natural
number between 1 and 12 this syntax is
just the set of all integers between 1
and 12 and at every step it is
incremented or once it gets to 12 wraps
back back around to 1 and we also
defined this that says that H is always
a number between 1 and 12 an integer
between 1 or 12 and then we can state a
theorem about a program saying that if
our behaviors satisfy the hour clock
then they satisfy the this property that
H is always within bounds but here we
run into a little problem because
suppose we now want to specify a clock
that shows both the hour and the minutes
and intuitively a clock that it shows
both the hour and the minute is also in
our clock it also shows the hour and we
want to say that any behavior that is a
clock is also an hour clock
unfortunately this is not true because
in the our clock specification H changes
its value every state and in this
specification H changes values only once
every 60 states so this is a problem
we'd like to solve so we introduced a
new concept called a stutter free form a
thorough free form of some sequence of
values is the same sequence with any
finite amount of stuttering any finite
amount of repetition of the same value
replaced with just a single instance and
if it's an infinite repetition we leave
it at that and we say that two sequences
Sigma and tau are stuttering equivalent
if their starter free form are the same
so let me give you an example
all of these three sequences numbers are
stiring equivalent to one another and
the last one is stutter free of course
the infinite repetition of four you
leave it to us
now this formula is not stuttering
invariant by that I mean that it can
distinguish between two behaviors that
are stiring equivalent and by that I
mean that it can be true for one
behavior and false for another even if
they are starting equivalent so all
these behaviors are starting equivalent
but this formula is true for the first
but not true for the other two because
it says that X must incremented every
step and that it doesn't happen here on
the other hand this formula is invariant
under stuttering because it says that at
every state either X is incremented or
stays the same so I'm going to introduce
the last syntactic construct which is
the square brackets and the square
brackets around an action and they have
this subscript here with an expression
that is a state function and an action
inside square brackets is the same as
saying either the action is true so the
action takes place or the value of this
expression doesn't change usually this
expression is just the name a variable
or a tuple of variables and we introduce
a syntactic rule that every time we have
the box operator followed by a function
that function must be inside square
brackets and this syntactic rules says
that every TLA formula is invariant
under story if it's true for one
behavior
it's true for all behaviors our
stuttering equivalent to it if it's
false for one it's false for all the
stuttering alignments and now if we have
the proper this is legal TLA the proper
specifications of our clock and clock
and ignore this line for a second then
we get that indeed a clock is an
instance of an hour clock if you're
wondering about this because this action
here is inside square brackets it says
that either H is incremented or it is
allowed to stay the same and it's
allowed to stay the same forever so the
clock is basically allowed to stop so
this additional condition says that the
hour must change forever
and the clock must never stop and but in
practice in CLA we have an easier way
built-in built-in operators to define
these we call them fairness conditions
and I'm going to ignore them for the
rest of the talk now this action is true
for this transition but it's also true
for these other two this action does not
mention Y so the variable Y can do
whatever it wants and this is what I
mentioned non-determinism basically
every t la fÃ³rmula all of them exist in
the same universe and they all specify
the behavior of all infinity of
variables but the only determines some
of them any variable that we don't
mention can do whatever it wants but we
can have more limited forms of non
determinism so for example this action
says that in the current state X is an
integer and so in the next state X can
either be incremented or decrement and
these two actions are equivalent to it
these are ways of expressing more
controlled non determines so in the next
state X is some value in the set or
there exists a K in this set such as X
prime is equal to X plus K the concept
of abstraction is very important to
programmers but we're because we're
dealing with math and very precise
definitions let's try to define it
mathematically precisely so when we say
abstraction we mean that we care
about some features and we want to
disregard others as being irrelevant
implementation details so if we look at
these sets of colored shapes we can say
that we only care about the shape but
the color is an irrelevant of limitation
detail or vice versa
we care about the color but not about
the shape but this suggests that the
concept of abstraction that we all like
to talk about is simply a superset so
the abstraction and its opposite
implementation by the way in ela and in
most formal methods it has a nicer name
it's called refinement so the
abstraction refinement relation is
nothing more than a subset or a superset
and we say that the set of behaviors F
is a refinement or implementation of G
and that G is an abstraction of F if the
set defined by F is a subset of the one
defined by G but in the syntax of GLA
this is just simple logical implication
if F implies G then the set of the
behaviors specifies is a subset of those
by 2 and in fact this relation in TLA
plus induces a partial order on all sets
of behaviors or all formulas depending
for that you want to think of it in
terms of syntax or semantics and in fact
it's not just any it's not just any
partial order its lattice boolean
lattice if you know what that means
you can appreciate it if not it's not
important so now we get a go back to our
discussion of quicksort we can define
quicksort precisely and mathematically
now expressing the non determinism
inherent in saying that we can pick any
pivots and then we can also specify a
more detailed implementation of the haps
where we pick a favorite to be the first
element and then we show that this
formula is just a refinement of that one
and what we get from that is that if we
prove that quicksort no matter how you
choose a pivot sorts and we show that
this program is indeed a refinement of
quicksort by the transitivity the
transitivity of implication we
automatically get
that our program sorts now Lisa Lambert
said that when one thinks only in terms
of language linguistic differences
obscure fundamental similarities and in
the same paper he said that it gave this
example so these are three Java or C
programs for computing that factorial
function and if you ask most programmers
which of the three is most different
from the other two I think that most
will probably say that the third one is
most different because the first two are
iterative or imperative while the last
one is recursive or functional but these
are descriptions of how the program is
expressed not of actually what it does
and in fact the 1st and 3rd version do
the exact same computation and it is the
second one that counts down that is
different and the only reason all 3
yield the same results is because the
multiplication operation is commutative
if we were to replace it by subtraction
than the first and third version would
still give the same result but the
second would give a different so in TLA
we would write the second version like
this we have the parameter N and we
require we can only move while I is
greater than 1 because we're counting
down and as long as I is greater than 1
we multiply F subtract I and once I is
no longer a greater than 1 then this
becomes false and we just started
forever because of the square brackets
it's better though
instead of having n as a parameter to
use non-determinism and say that in the
first state ad n is a temporal variable
and say that in the first state it can
be any natural number and say that it
doesn't change in during the steps and
the keyword unchanged is just syntax
sugar for saying n prime is equal to n
and this would be factorial 1 and
factorial 3 but now you're going to say
but who said that the fact that the
third version uses recursion is not an
important detail why are you telling me
that recursion is an unimportant
implementation of detail
I could care very much about say memory
consumption and it differs by a lot from
the other two versions because a memory
consumption but till A+ lets us specify
any level we want so if we want we can
define mathematically nevermind the
details we can define mathematically
what a stack is and what it means for a
function to recurse into return and then
we we specify factorial three using
recursion but even if we do that and we
specify factorial three at this level
still this is true factorial three
implies factorial 1 because factorial 3
is a more detailed description of
factorial 1 it's it's a refinement of
factorial 1 but not of fact 2 so this
kind of abstraction helps give us
insight into how and why something like
factory works sometimes we're interested
in weaker forms of equivalence and we
can say but we don't even care about
that
we only care when two functions given
the same inputs give us the same outputs
this is called extensional equivalence
and for all we care
all the factorial functions are the same
and it's very easy to define extension
extension equivalence operator and TLA
plus just a couple of lines but instead
I want to show you that even even this
is just a point on this lattice of
abstraction so if we care only about the
input and the output we can describe
another specify another factorial
algorithm that only cares about the
first stage and the last date and this
one is going to do a little trick it's
going to simply use the factorial
function to compute the factorial the
factorial in one step so in the first in
the first state f is going to be equal
zero it can be it's completely arbitrary
but I chose zero and then immediately
it's going to calculate the factorial so
this specification only cares about the
first step of the first state and the
last takes it exemplifies the meaning of
what it means to be extensional
equivalent we only care about inputs and
outputs and I put it inside some
called a module if you're familiar with
ml it's kind of like ml modules if
you're familiar with object-oriented
languages you can think of it as a class
and then inside the definition of fact 1
we define this value done to be equal to
true when we finish computing we're
counting up so we're done once with
we've gone over N and then we
instantiate like creating an object we
instantiate instantiate this fact out
this extensional module and we map to F
in the in the extension module this
expression if we're done we map F if not
we leave it at 0 and this is called a
refinement mapping so this mapping works
on entire behaviors so this is a
behavior of fact 1 and this is what
happens to it under the refinement
mapping and you'll see that every state
what we map stays the same F is still 0
until the last one it gets got off there
a last one F is 24 it's done and this
one maps the actual the actual results
but here we're just covering the first 3
steps first three states are the same
and therefore it's equivalent to the
Stuber free behavior where the
computation is done in a single set and
so it is true that fact 1 is just an
implementation of the extensional
factorial under this refinement mapping
so we've shown exactly what it means to
be extension a equivalent and similarly
for fact 2 we do the same it actually
takes one more step but it doesn't
matter because the mapping only passes
the result of F at the end and is still
only equivalent only it's still
equivalent it's a refinement of fact alb
so both versions one that counts up and
the one that counts down are refinements
of this description that only cares
about the input and the output so the
last thing I want to talk about I have
one more slide composition so when we
write programs we compose things and we
many different kinds of composition we
can have a functional composition for
example function a calls function B or
we can have service composition one
service sends messages to another but a
system that is made of several
components must satisfy all a component
is just a specification of a small part
of the system and so until a bus it's
obvious that if we must satisfy many
components it's just a conjunction it's
just an N and of course depending on
different kinds of composition we might
need to have a different a different
operator here and maybe another sub
formula that says how that you are
combined so let me show you an example
and I'll end with this so this is called
Plotkin's parallel or Plotkin's paddle
or is a following problem describe a
program that is given to programs as
inputs and your program must terminate
if and only if one of the input programs
terminate usually and the solution to
that is simple we just simulate both
programs one step at a time and we
alternate from one to the other and we
terminate as soon as one of them
terminates so usually in languages that
describe computations as functions being
able to simulate programs requires
having access to their source code but
in TLA because we describe programs as
dynamical systems we don't need that and
we can still treat them as opaque
formulas so this is parallel or we had
we take two two specifications two
programs there are just temporal
formulas as parameters spec 0 and spec
one state 0 and state one are a tuple of
the temporal variables that those
functions care about and if you jump
here to the end you'll see that the
composition is just specs zero and spec
1 and some things it's going to say how
we compose so how do we compose them we
introduce a new temporal variable with
the existential temporal quantifier it's
a bold case and called P and P starts at
zero and then P alternates between zero
and one and whenever P zero we only
allow spec zero to take a step and
wherever P is one we only allow spec one
to make a step how do we do that so when
p zero we require that state zero change
and that state one must not change and
vice-versa for one and so we move from
one to the other we allow one to take a
step in the other and then when say spec
one terminates and the next time P is
equal to zero we tell spec one okay now
you must take a step state 0 must change
but we said the determinating behavior
is 1 when the state no longer changes so
spec 0 can no longer take another step
so this entire action becomes false and
we ourselves can no longer take another
step the only option we have is to
stutter forever and basically tournament
so I hope you've learned a little bit
about how we can describe programs and
their properties in math and how maps
can help us find insight into
abstraction and composition and
everything else and like I said you can
find everything in a lot more on my blog
here thank you
okay we can take some questions
Senator Mike yep could you give us a
real-world example of the property that
can be proven by the user Churchill
applause sure for example a consistency
of a database sequential consistency of
a database so linearize ability of a
database you have a distributed database
and you want to show that it's
linearizing or you want to show that you
have distributed transactions that that
are really transactional or you can have
say a concurrent algorithm that you want
to show that is free of data races or
you can show that a sorting algorithm
actually sorts so pretty much anything
in fact yeah there is a completeness
theorem for TLA plus but yeah pretty
much any property you can think of
thanks for the great talk so there is
this very very famous dualism between
specification systems and their
implementations so there is this notion
that sufficiently detailed specification
is equivalent to like developing it
sufficiently detailed specification is
equivalent and it's effort to develop it
developing that system and you're in
like programming language of your choice
so it's it's obviously very very useful
to have for example certain properties
of your database being described in TLA
and reasoned about but when we want to
make this jump into the actual database
implementation then how Toa plus helps
us and that because the complexity of
the resulting database in the real
programming language remains the same
and it's so error-prone as before right
so first of all I'm going to say that in
the whole formal methods the perhaps the
most charged word is can a lot of things
in formal methods is possible in
principle but not so feasible in
practice in principle you could
right your program in whatever in Java
and translate it to TL a-plus and then
show that it refines your high-level
specification it's not just in theory
it's actually been done but only for
small programs and you write that the
fact is that no matter no large program
or even medium size program has ever
been proven entirely correct so the only
program it doesn't matter what tool the
only programs we've been able to
completely verify D properties and not
saying a nullpointerexception talking
about true correctness properties are
pretty small I think the biggest one is
about 10,000 lines of C code perhaps a
little bigger so the way ta + solves it
is by saying if you have a very large
system you're going to only specify it
at a pretty high level that's where the
design bugs are and then the translation
you're going to do manually and use
other tools that reason at the code
levels at the code level and it works
very nice and practice as you can see
from Amazon even Oracle it's being used
hi thanks for the talk my question is it
seems that on the contrary like from the
system like or OGG de the tli plus
allows functions to not be total no no
so is there mathematical functions there
is no such thing as a non total function
that's a invention of constructive
functions and programming language there
is no such thing as the non total pond
so it's just completely tall so the
algorithm may not terminate but that's
completely legal there's nothing wrong
with a nonterminating computation many
come ok but you can prove totality in
tli plus some algorithm is it possible
or it's like it's not totality is an
algorithm or a function of a part of
like I have a have a piece of code like
fine algorithm an algorithm yeah of
course so you can prove totality just
like you can prove anything else so in
theory can be done in practice you
of course there's no because of the
halting theorem there is no completeness
here you can't prove for every algorithm
that is total but for some algorithms
you might you may be able to prove that
they terminate and termination is
actually not a very interesting property
termination only applies to sequential
programs in ela plus you offer reason
about more interesting liveness
properties for example that your server
for every request you get always gives
your response or that a concurrent
algorithm never locks for forever and
these are things that if you think hard
long and hard enough then you may be
able to prove but of course not in the
general case there's no magic thanks to
the last question ok thanks for the talk
and synote concert is actually pretty
big a big size C compiler that has been
proven to be correct so let me ah but
every average going to say an average an
average software piece of software in
industry is about 5 million lines of
code and that's the medium-size program
comm search doesn't even get to a
hundred thousand I think lines of it's
not it's operable K but it's it's
reasonably sized anyway my question is
how much work is it to prove something
in practice let's say I write quicksort
and let's say I want to proof it's
correct how much work do I have to do so
after a lot of experience with the most
benefit comes from just using the model
checker you press a button and it tells
you it finds a it finds a counter
examples if you want to prove using the
proof language which is very nice and
it's basically a front end to visible if
you want to prove something using formal
proofs that's a lot of work and in
industry scenarios where TLA plus is
used it is almost never worthwhile
because again we're talking about
systems with tens of millions of lines
of code and proving them would take
forever if you want to just prove the
correctness of quicksort it's about as
hard as moving it's in Cochran Isabelle
ok thank you
okay let's thank the speaker again
okay now it's time for lunch we'll see
you back here for the keynote at 2:00</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>