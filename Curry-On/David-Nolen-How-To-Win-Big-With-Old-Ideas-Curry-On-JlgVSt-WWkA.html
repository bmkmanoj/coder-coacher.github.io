<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>David Nolen - How To Win Big With Old Ideas - Curry On | Coder Coacher - Coaching Coders</title><meta content="David Nolen - How To Win Big With Old Ideas - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>David Nolen - How To Win Big With Old Ideas - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JlgVSt-WWkA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and closure script a bunch of stuff in
the closure community yo the man needs
no introduction so please give a round
of applause for David Nolan hi good
morning so this talk is called how to
win big with old ideas this talk is very
much a sort of industrial software
developers sort of experience report
about a couple of programming
programming languages as well as a
database so basically I want to talk I
want to focus on I'm not going to show
that much code I'm not going to like
talk too much about sort of the detailed
concepts behind in any of these
technologies I just sort of want to give
an overview on how you could take I
would say sort of off the beaten track
ideas and have some success in the
mainstream with those ideas so I'm going
to focus on closures closure which is
basically a nine year old project now
it's a dynamic functional list that
targets the java virtual machine as well
as closure script which is simply
closure that compiles to JavaScript and
a little bit about des Tomic which is a
immutable relational database which uses
data loggers query language as far as
the mainstream is concerned these are
not you know accepted technologies yet
somehow over the past almost decade
we've been able to grow a large
community of dedicated industrial
software developers who really love this
stuff and so we're going to sort of
drill into why I think that happened
this is mostly there's not going to be
hard evidence this is mostly a fun talk
and just my experience watching how
things have happened over the years so
quickly about myself I'm a software
engineer cognate echt
I work on the de Tomic team on the
atomic database which is the one product
of the company has the company is
primarily a software consultancy so I
also in the lead developer of closure
script again which is basically closure
that compiles to JavaScript as far as
what what do we do we work with a
companies that have existing code bases
written around closure closure script
and atomic so it's not like we're
coming up to people and saying we're
going to build this thing for you people
have already built stuff using this
technology and I believe and we have
lots of different kind of types of
clients but 14 of our clients are
fortune 50 companies so somehow we
convinced very big companies to use a
very crusty technology as far as
technology concerned data log is old
Lisp is old so how did this come to be
we're going to drill into that so even
if you go back 10 years I think the
future of Lisp looked pretty dire if
some of your fans are Lisp I mean it was
definitely in decline I think if you
were sort of a programming languages
geek or researcher I think it should
have been a bit of a wake-up call when
MIT switched away from scheme to Python
for their introductory a computer
science course this was basically I
think kind of like an indication that
things had very changed very
dramatically in industry what industrial
software developers wanted was not just
a programming language right the
expectation was that in this new
open-source culture I should be able to
build the substance systems that I want
to build without wasting a whole lot of
time building infrastructure lives which
was not the case like you know back in
the you know early 60s 70s or 80s people
built everything from scratch but if
you're a web startup you don't want to
become an expert in writing low latency
asynchronous web service right that's
not going to happen you just want to use
nettie or jetty if you're into machine
learning you're not going to sit down
and write a distributed machine learning
framework you just want to use Google's
tensorflow
right so this this is only going to
continue people do not have time to
build these sort of critical libraries
they just want to solve the problem that
they want to solve again I think this is
a trend towards industrial software
developers want to build systems now
that are orders of magnitude more
complex and they wanted to in the past
so this is not a great story for for
people who are interested in programming
languages because it's it's so much work
to even get you know your programming
language off the ground this is just a
slide I cribbed from Simon Paton Jones
talk on Haskell that he gave at OSCON in
2007 um and this this this diagram is I
think
are more grim than just successful
research languages I mean I think this
applies to almost all programming
languages today
so in some sense how you know the
question is how did closure avoid you
know this sort of like you know kind of
language geek ghetto and slow death that
most languages programmable engines
experience so at the top of the
programming language food chain these
days our two languages I don't think are
going to go anywhere at least at least
in the next decade probably more you
know and you can you can pick a few
languages they're really the top ten
hasn't changed dramatically but
definitely two that only that you know
you could like throw a rock and hit
somebody in like what do you do there's
a good chance they're going to do Java
or they're going to do JavaScript and
this is not going to change and and
these these tell these technologies are
entrenched regardless of what do you
think about the semantics of these
languages it's you know they're not they
have their problems and I think they're
pretty well known since almost everybody
has had to work with one of these but
the fact of the matter is is that the
amount of sort of investment that's gone
into making these things palatable to
the industrial software developer is
pretty intense
if you've ever fired open intelligent of
semantic information you have about a
Java program it's pretty mind-blowing I
can download any random Java project
known absolutely nothing about its build
system and hit run and build it because
the tooling is just so good they can
identify any build system that it used
and build the project for you if I open
up a test file even though I don't even
though I don't know what test framework
it uses I can select a method and run
that test so the amount of tooling is
incredible if you are an industrial sort
of Java developer the kinds of profiling
profiling tools that are now available
for examining production systems is
pretty wild job as a thing called a job
in Mission Control which is you can hook
it into a live production system and
it's a very low latency I think it's
like a I don't know what 1% hit on
performance and you can see the memory
profile when the garbage collections
happen and all this and so forth so this
is the type of thing that an industrial
developer wants they may not love Java
but this is the kind of tooling that
they're excited about the same is
effectively true
now for JavaScript so I actually spent a
lot of time doing JavaScript at one
point doing UI work for various clients
I was for a while I was at the New York
Times for four years doing UI stuff but
I started doing JavaScript stuff in like
2005 when you still had to basically
support ie6 and the state of the art
there at the time was print line
debugging right because you just didn't
know what happened you might you might
have written the made a bug and then ie6
would just crash and really the best
debugging some methods you had was just
alert debugging not even print line
because there wasn't even a console but
things have dramatically changed from a
tooling perspective the things that are
built right into this average browser
Chrome Safari and Firefox it's very
sophisticated very advanced tooling if
you're a UI developer the sort of
insight you can get into you know how
much time is being spent in repainting
and layout in JavaScript execution what
does the heat profile look like right
now all this stuff works extremely
extremely well so again these are now
that developers have this the likelihood
they're they're going to put up with the
language it doesn't it's diminishing
JavaScript also probably more so than
Java has a lot of room to grow
specifically because you have this now
sort of fragmentation of the sort of
platform market just because of the
stiff sort of competition that happened
in the sort of mobile space but what
this means is that companies are don't
really want to hire three different
teams to build the same app and that
this has created a lot of pressure to
make JavaScript the sort of future of UI
development because that leads with
JavaScript you can easily target a
multiple platform so I expect JavaScript
to really actually increase in scope and
as far as where people want to use and
how people want to use it so given this
a closure strategy was that we can't we
can't win by building our own system by
building our own Island by building our
environment the environments where the
mainstream is sort of dictated what we
have to use and so closure strategy is
we're simply going to have a symbiotic
relationship decide this I think is
something that's not really thought I
sort of realized that it's a very was a
very smart design trade-off for closure
in that we're just going to go with the
flow right
whatever wherever the industry is indigo
we're going to follow them so closure is
very much a symbiotic symbiotic
programming language closure script is
as well so closure script simply targets
ACMA script 262 JavaScript it compiles
to the same JavaScript that shipped in
2001 so this guarantee is that we can
run and basically any JavaScript
environment like you know even in right
now okay so I think part of the part of
the reason closure has done okay for a
language that again that is somewhat
esoteric is that we've simply adopted a
symbiotic sort of stance with respect to
mainstream technology now the other
thing which is what I'm going to drill
into because I think that the fact I
think if you think about it a bit
symbiotic things sort of makes sense
developers want to target these popular
platforms but there's another thing I
think why people sort of have fallen in
love over time with closure is that
closure actually at its core has I think
a set of very simple principles that
actually came from academia and they're
almost inevitably all old when we get
talked about for you if you're a closure
developer you could pick any four that
you want I'm picking the four that I
think are interesting and I think that
have a huge impact and in fact I'll show
some demos of sort of initiatives by the
community that specifically leverage the
things I'm talking about
but again the I think what makes closure
nice is it's a very well curated set of
old ideas that we know work pretty well
and I think that when developers come to
closure they don't have to spend that
much time with it to realize the sort of
software engineering benefits of these
things the features I'm going to talk
about are not complicated again they're
almost self-evident the other thing that
I like about these features I'm going to
talk about is that they're really simple
so probably these days people actually
know what I'm showing here if I'd shown
this in the Western world even a year
ago you'd be like what the hell is that
this is a go board which is now easy to
recognize because of google deepmind's
alphago competition but the neat thing
is regardless of where you know how to
play this game or not is that for about
two thousand years people only
communicated the rules
just by describing them because it only
took about ten minutes there was no need
to write them down right and that this
is really important I mean I think
there's lots of software features you
can talk about that require you to read
papers or require you to spend invest a
lot of time and energy but the features
I'm going to talk about really are not
like that
I you really could describe them to
somebody and somebody could probably
implement them implement it themselves
in an afternoon and I think that's
really important so what's what's neat
about Go is that even though these rules
can be communicated in about ten minutes
the game has sort of somehow stuck
around this is a game record it's twelve
hundred years old but it would be
trivial for a person to run read and
understand the day and just because an
idea is simple right that only takes ten
minutes to explain it actually says
nothing about the power of the depth of
the complexity of the resulting system
right go has very simple rules but
Google had to spend about ten years of
New Era research they have to build
custom silicon and they had to build a
supercomputer and they still lost one
game to a human okay so what are some of
these old ideas so for old ideas one is
list this is a programming languages
conference a sort of has a program
leaders events or everybody to know what
Lisp is but I'm going to point out a
thing which I think is even if you know
list specifically something that that
people love and that people really run
with industrial salt a software
developers run with I was respect to
lists I'm going to talk a bit about
trees so trees are a very old idea 1960
at Freud can add fredkin wrote about
them so closure sort of sort of changes
the this is a sort of divergence from
the list past of consoles this
coordinated structure in closures based
on trees and then you have data log and
data log via sort of de Tomic but the
atomic has had a huge effect on the
commuting that people are building their
own data log systems are interested in
this approach to data modelling and then
regular expressions and this is a
relatively new thing based off of again
in a hold paper in 1964 but I was
revisited by Matt might in 2011 and then
Richard K implemented a thing called
closure spec which is a contract like
system which uses
parsing with derivatives to get
validation okay
so let's kick it off so list they're not
going to spend too much time on list but
I think people know it but the cool
thing about list as Alan Kay says is
that it's really simple right he refers
to like to list 1.5 users manual the the
to the one page thing with eval and
apply and and that's really it yeah John
McCarthy created lists because he he had
a goal right so a lot of this talk is
not about these features but the fact
they enable software developers to
achieve their actual goal a programming
language just as some path to something
that something actually wants to do and
he was you know basically tired of this
process where you would you know you
would punch your cards you would give
them to the person who would actually
you know run that an internet computer
and then you'll get the results maybe
three weeks later and there was a bug
and then you would start this process
over again and I think one of them
McCarthy's most important innovations
was the repple right he was like this is
ridiculous I should be able to test it
at terminal type the thing I want to
type and see a result right now not
three weeks from now and this this idea
fortunately has had a lot of traction I
think it's very hard finally in 2016 to
see new language efforts that don't have
ripples which is great so what are the
benefits of the sort of the list
approach to software development again
even the list sort of came from sort of
academic research what are the practical
benefits for an industrial soft
developer from a maintainer point of
view it's actually quite nice right Lisp
is one of these things that's still to
this day it's fairly simple to implement
I mean wait so raise your hand if you
ever implement a lisp interpreter so
that that's ridiculous right that's a
lot of people so it's it's not a hard
that's not a hard thing to do and once
you do it you almost can do it in your
sleep right this is this has the flavor
of the of the rules of go somebody show
you how to write a list boom you're
never and afraid how to do it
and that's really cool but it's great in
terms and from the point of maintenance
as people have to maintain this project
in that the language is quite small the
implementation is quite simple and
that's great and we're nine years in and
we don't have an elaborate contribution
process or anything like that I think
only three people have commit right
to closure still to this day the other
benefit is that we you know we adopt neo
macros appeared very fairly early in
list history because people realize oh
the language is very uniform you can do
meta programming through macros and so
this has also been nice and that what
you know one thing that you see a lot of
programming languages do is once you
pick a language which is does not have
an extensible syntax then you really
actually do have to have a sort of more
committee oriented system or some system
in which that people say here's my idea
how to improve the language up to like
you know make a little request for
enhancement yadda and so forth so macros
don't let you do everything that you
want but a lot of basic extensions that
people might want might want to need for
their domain it's available right they
don't need to talk to the core team to
get the feature that they want many
features can be implemented through
macros and that's a really nice thing
something that that's that's finally
paying dividends is taking a lot a bit
longer because it is a bit more
complicated than you know just writing a
macro is that the simplement ation
actually means that the community is
able to retarget to other desirable
platforms so we focused on Java and
JavaScript but because the compiler is
are really actually quite simple I'm
going talk about some other things it's
not work that we did that other people
were able to retarget which is quite
cool does not require a lot of effort a
lot of the things I'm going to show it's
like people have enough time to do this
in their free time and definitely
porting closure libraries its requires
often attribute them I never okay so
that's list so another sort of powerful
simple idea is trees so again Lisp sort
of started with you know an emphasis on
this on this sort of cons cell as like
it's sort of foundation and the thing is
actually the idea that closure adopts is
very close right like tree the tree
implementation we have are very close to
lists right all you got to do is say
well we can't set the car we can't set
the coder so no mutation of the car in
the coder of the console and then
instead of having only two branches
we're going to make it so or actually
only you know one pointer we're going to
actually have 32 way branching and we're
going to use mutable arrays as the
as the fundamental sort of unit inside
the thing but everything that we like
about persistent data structures is
already present here structural sharing
is already here the only thing that's
missing so you're going to get
efficiency in terms of space but we want
to sufficiency in in terms of time and
so if you're bit careful with the
branching factor and you use 32-bit
arithmetic you can actually do some neat
tricks so again this is an old idea like
Lisp list was 57 trees were 1960 so you
take trees you read Okazaki's book on
sort of functional data structures and
path copying and updating and then you
might have stumbled across the paper by
phil Bagwell who wrote this thing called
ideal hash trees and he sort of defined
what a hash array map tree looks like
and this was actually a mutable data
structure and so what Ritchie did he
said okay that's a very efficient hash
map implementation and the way that it
works I can just change this and combine
Okazaki's idea and get an efficient set
of mutable data immutable data
structures so we don't use cons cells as
the fundamental unit of our data
structures we use various forms of hash
array mapped trees and one of the
benefits what are the benefits for your
average software developer to build your
whole language on this so the mutability
is at low low prices right I think right
right now even with the branching factor
of 32 I think if you actually have the
full depth of the tree if you have an
immutable vector and you actually have
the maximum size it would take about 256
gigabytes of RAM which I don't yet have
on my computer one day we'll get there
but the point is you only even if it's
that big and you have I think two
billion items
it only takes seven array accesses to
get to any any particular element on
because of things like the fact that JVM
tries to be very sort of inline cache
friendly with small arrays this ends up
being much cheaper than people expect
and this actually ports to JavaScript so
a lot of these tricks that people have
been doing inside the java virtual
machine are making their way into
JavaScript virtual machines they're
extremely advanced now
lock-free concurrent programming for the
masses so you know a lot people don't
talk about this but the average closure
developer is using the JVM they're
writing multi-threaded programs and
they're doing this without locks and
nothing bad is going to happen and
that's really cool but even if you take
immutable data structures you put them
in a single threaded context this is
less obvious and this is sort of a
recent development from about two years
ago there's still benefits and this
boils down to how good it is for UI
programming so clojurescript developers
design entire applications around
immutable data structures they don't use
mutation as a fundamental sort of thing
and very cool and I don't think we've
really completely mined the
possibilities there but I you know I've
done demos of like okay so you know undo
and redo and you know complicated sort
of change trees all this stuff is sort
of it's self-evident because it just
works you can combine immutable data
structures with a sort of functional
rendering pipeline like react and things
that used to be quite challenging are
very trivial ok so data log so data log
this is this is a again a old idea I
couldn't find maybe somebody here is a
data log expert and they can point out a
year but you know data log is sort of
lumped in with sort of Prolog so you
know if you remove the sort of non
termination aspect of Prolog you end up
with something called data log so in -
2012 sort of the cognitive tech team
announced this thing called the atomic
which is a mutable relational database
it's you know you could say in a very
very short sentence it kind of works
like get in that you have immutable
blobs but basically it gives you a a
relational query system over something
that's kind of like styled after or like
I would say an RDF story in that you you
sort of have queries over tuples it's
immutable relational database it has a
data log style query language and the
tuples are effectively entity attribute
of value and time and the time thing is
huge so because it's an immutable
database one of the biggest problems in
software system is like okay you use a
functional programming language the
semantics of your language are great
except at the edge of your system you
have some meeting which really destroys
all the semantics the most important
operation saving it
Meishan and reading information there's
no guarantees about that stuff but the
atomic basically gives you a database
which actually feels like it's just a
data structure in your program you don't
even think of it as a database and it
has the same nice immutable properties
and that's quite cool and so because it
has this element of time it's easy for
users to write very simple queries you
don't have to you know like think about
again because it's sort of oriented as
queries over tuples you don't think
about joins you can you can add schemas
whenever you want new attributes so on
and so forth so it's both flexible in
the way that industrial software
developers want and at the same time you
don't lose querying as you would with
like say a document store so here I
saying I want to find the timestamp
I have a clause we're saying fine you
know the tupple that matches this sort
of pattern right you know find the
entity P such that that person's name is
James Cameron and then find the logical
transaction ID logical transaction time
and given that logical transaction time
give me the actual instant that that
piece of information that fact was
recorded into the database and this is
also similarly right you know you sit
down a developer and like they can learn
this query language in you know an hour
and people really love it again because
it's it's sort of self-evident sort of
serendipitously it turned out that
things were already heading this way
for the rest of the industry so I don't
know if people are familiar with react
but react was Facebook sort of
functional ish rendering pipeline even
though it has a sort of object-oriented
veneer in essence the functional
rendering system and they announced
something that they didn't internally
using for years called graph QL because
Facebook is essentially it's all it is a
social network and the only thing that
they want to query are what are the
relationships they have a whole graph
oriented query language and and it has
lots of benefits because Facebook along
with Netflix these big companies are
realizing a lot of our queries we really
want clients to be able to describe what
they want because for example Netflix
Netflix us to write queries right
clients need to like the clients could
be okay maybe
it's a set-top box maybe it's a web
browser maybe it's Android maybe it's a
tablet these all have different views
they all render different content based
on the dimensions of the display and
what was happening is that okay you have
a low bandwidth client that's a watch or
something and it has two let's download
a 1 megabyte JSON payload when it only
needs 2 fields so that all can display
right and so this is this is a problem
that people are seeing as clients
diversify the old sort of rest style
I'll just send whatever we're going to
send to the client it stops working
right because different clients need
different things and so you know I've
done a bunch of talks about this sort of
demand driven sort of thing so people
are getting more and more should in
graph databases and graph database like
systems right people have been you know
for years I'm saying we need graph
databases an industrial software
developers like why the hell do we need
that and now finally things are
happening that they can see the value of
that ok
so flexible modeling without abandoning
relational queries that's what's nice
about day Tomic and you know taking this
data logs I'll approach again delivering
sort of immutability which gives you
powerful auditing and it turns out that
people liked this idea so much that
they've actually said oh I would love to
have that on my client I would like to
download some data from the server and
then I want to be able to write nice
little data log queries in the client to
express a different state to my
application so people are starting to
see the value of this for the typical
applications they want to write and
again this is sort of we got we got a
bit lucky here on people are excited
about this and that it's just a good fit
for the types of applications that are
in vogue many applications these days
have some sort of social networking
component and many companies want to
target extremely diverse clients ok so
the last thing that I want to talk about
is regular expressions so this is yet
another based off of yet another old
paper this is from sixty-four
derivatives of regular expressions so
this idea sort of is the underpinning of
this new sort of contract like system
for closure called closure spec it's a
neat paper and
Matt might revisit it and people got
excited about it it definitely in the
academic world but closure sort of uses
this in a very kind of fun way when
people hear regular expression they're
like well aren't you talking about
strings but actually regular expression
in the sort of mathematical sense which
is definitely I would say is not
something industrial software developers
are familiar with but I would say
computer science researchers probably
are and what this paper does is it shows
in 30 lines of racket you can basically
get the full power of a context-free
grammar right it's really neat you only
need 30 lines of code something that
anybody could understand whether they're
an academic or an industrial software
developer so this is the underpinning of
Clojure spec instead of operating over
strings we're going to parse s
expressions so closure is sort of an
extended form of s expressions right so
we don't just have this we also have you
know hash map literals and array like
literal things and so it looks a bit
like this people can talk about
properties in their programs like
properties and hash maps where they can
talk about functions on they're able to
say you know I want because you can
think of the arguments to a function as
like a couple you can say the arguments
to this function needs to be a couple
the first thing should be an integer the
second thing should be an integer and
then I want to have this logical
predicate that says that first thing
should be less than the second thing so
this is quite nice you have a lot of
descriptive power over how your function
is supposed to work but because this is
a declarative description you can do a
lot more things right so this is this
the specification doesn't have to be in
the same file as the place where you
write your functions the specification
can live anywhere it's sort of a la
carte the neat thing about it is because
the specification is declarative we can
we can do data generation off of it so
maybe some of you've heard this thing
called quick check quick check was a new
idea I think 2000 or something but
originally a thing for Haskell by John
Hughes at all and he took this idea and
now he runs a whole company called qubit
which uses the Erlang quick check to do
sort of deep specification and they've
already used this successfully in a lot
of industrial systems to verify bugs
both in hardware as well as software
so what's what's great is that in order
to understand this paper you actually
have to be a little bit familiar with
Haskell you know something about monads
and the nice thing about close respect
is users don't have to know anything
about that right you just write your
spec and behind the scenes we can
generate your data for you and so that's
really powerful that users don't need to
know that much about how this particular
thing works so this is a little bit
subtle so what are the benefits of
something like Clojure spec which uses
this neat sort of regular expression
approach of course Richard documentation
this is the thing that people complain
about I think the number one reason why
people like types is just what the hell
does this thing do with me not having to
read the body of the thing so that's
great people now have a shared language
of what this thing receives what it
takes and what are the constraints upon
the relation between those two things a
better feedback because it's a parsing
technique it's actually in the
implementation it's sort of we have a
simple way to propagate precisely where
your program went wrong like what
specifically in your data was not
correct that's huge
because a lot a lot of what people want
is just better feedback many programmers
industrial programmers don't care did
there happen a run timer or do I know
about a compile time all you care about
has how informative informative the
error actually is it also eliminates
handwritten macro body parsing code
because now that we have a way to talk
about the structure of a closure
s-expression I don't have to write
parcels I thought to write functional
code to parse a macro body and that's
quite nice and again property based
testing for free and something that it's
it's a bit too new to see what people
are going to do with this yet but the
fact we have all our card specifications
right so these days when you're writing
a program chances are you're writing two
programs one on the client one the
server right wouldn't it be nice to have
a specification that you can share
across these two entities two endpoints
okay so this is my sort of idiosyncratic
take on on some interesting features
that are based on again I would say
well-known well understood and good
academic ideas so what is add up to what
do people do with this stuff right so
what I'm going to show are some demos of
things this is not anything that the
core team works on these this is purely
industrial software innovation somebody
takes okay I get it Lisp
I can do hot reloading Oh functional
programming immutable data structures
what can I do with that right so the
next demos I'm going to show are just
things that people figured out on their
own the first thing I want to show is
this thing called fig wheel
so Bruce Helmand very nice person just
this tool again we did not design this
we did not develop this he realized okay
you have Lisp and hot loading is a nice
thing and list and then you have
immutable data structures it's are you
already idiomatic
for most closure programs and
clojurescript programs to put the entire
application state inside of one
reference type right so the entire thing
it's like a database you put all your
state in one place and because this was
already the case he was like oh I can
build a hot loading sort of system that
simply watches the file system as files
change if something successfully
compiles I can reload that in the
browser so again we did not design this
this is oops let me have to it sorry
this is not open oh no this one is it
which oh oh sorry
turn on mirroring come on command f1
wait yeah there we go
okay what's the network here Roma all
right sorry okay that's easy
excellent all right what's gonna work
this is gonna be really slow
flappy bird has a flappy wanted value
and that's what we want to associate
with the sign so give it an amplitude of
say 60 so to move up and down sixty
pixels and get the sign and the sign
will be of the time Delta excellent so
there's a naive side wave let's hook it
into the update function for the flappy
bird there we go
this is the name of the pot rouser in
flappy bird is bouncing up and down at
the top so I forgot to give it a
flappy's initial offset which is a start
Y so let's give it start Y it's
beginning Y position on the page and
then add that now flappy's in the middle
what's still bouncing around
frenetically s-- so anyways that's
that's so if you've done web browser
development write up a lot of time is
lost just blowing away the state of your
application and all you want to do is
change how something looked or you want
to fix a bug and so this is complete
again this is completely taken the
closure script world by storm so all a
lot of closure script developers they
just live code as they're developing
other UI components they don't have to
stop on blow away their state they're
able to keep their state intact as they
develop the program
extremely powerful and again not
something that we not an initiative that
we started just fell out of the
semantics of the thing that we provide
another thing is that you know
javascript the cool thing about
javascript is javascript is everywhere
it's just going to go more more places
so there are lots of places where Java
can't go right Java is probably never
going to run on Apple's iOS but
something that's cool we did a very
lispy thing last summer
so the clojurescript compiler can
compile itself into JavaScript on it
didn't take very long for people to sort
of run with this and so this is closure
script which has compiled itself in the
closure script running in iOS and so
this is if this is all the toll the
whole closure script language inside of
iOS running under JavaScript core
so Apple has this you know their
JavaScript engine which is a standalone
embeddable thing and this is Mike fights
showing a demo of this artwork also very
cool
all the work
maybe
an effort that is going on to kind of
add this stuff to it so you know as sure
as you're typing it it basically
maintains your your parentheses for you
so this is actually on my iPhone it's
actually I'm right here running but I
have it on the screen as well so let me
try entering in I'm going to subtract
maybe from for the first of a vector
where maybe the first elements I don't
know six and some other symbol and if I
put something else in there it's like
really easy to add and delete and maybe
if I move my cursor over here let's see
maybe put another number there I don't
know so so what is this experience so
he's demoing here is actually you don't
need a special keyboard for this
particular repple because it uses this
really neat again community thing which
is a parentheses inference sort of
engine so the user doesn't need to input
parentheses correctly it'll be inferred
based on indentation which is quite nice
given the sort of limitations of trying
to type on an iphone but mike Fikes
actually he's so he so he's built all
the technologies that any person any
random person can actually write npm
natal or something and they have a fully
blown interactive repple hooked into
their iphone right so you can develop
iOS applications you want it to
bootstrap once and you can basically
program your iphone over Wi-Fi and all
this stuff around hot loading all that
stuff just works which is really cool
again we're not working on this this is
just people took the thing that we have
and now they're able to live code their
iPhones the last demo so this is looking
for a little further into the future so
I talked about closure which is JBM
closure Kripa javascript this is are my
friends Tim's Gardner and Ramsay Nasir
and so there is a compiler which
actually people weren't using very much
the closure CLR compiler and they
realize that they could target unity
with this so if you're not familiar
unity unity is probably
we one of the most successful game
frameworks of all time multiple you know
blockbuster titles for mobile devices
have been produced on it I think they
have like a 1.2 billion valuation now
very successful unity is a great
authoring tool that's sort of what
allowed it to be to take off is that
it's great for artists for programmers
is not that great and so Ramsey and Tim
saw an opportunity here they saw that ok
oh you know closure developers have this
really nice interactive live development
workflow in our free time we're going to
make this work for unity so they have
this really amazing demo where one of
them has like a VR helmet on right this
is the head actually have a VR like a
oculus rift and one of them can be
typing on an Emacs buffer and they're
live updating the Unity environment
I can go over to these pyramids
and floating about ten meters in the air
right now
now they're falling kind of fancy
material they're sprung towards us sort
of jump up on here maybe okay
now I'm up on a corner of one of the
pyramid blocks forget what this does
what's this - okay oh that one Oh No
okay so much change and then finally
well I'm going to put the pyramids back
sitting a little bit more room for this
next one I think so
better pyramids can yeah just gonna
leave them for a second anyways super
super cool right so these they're
they're they're you know professional
game developers and they want the same
thing that we have in these other
environments right so they see the main
thing that they want is just again more
feedback more inactivity while they're
developing on their software and in fact
this a lot of my points are reflective
so we run surveys every year and in this
list
people say 2400 responses people say
what's the most important thing you can
see so more sophisticated language
features are at the bottom of the pile
the first thing is people like as
functional programming the second thing
they like is immutability the third
thing they like is the repple right all
these demos I'm showing you are just
repple demos people absolutely love the
repple demos especially if it works for
the the platform to the care about right
I Oh s unity web browser Java and last
is just ease of dead
you know macros way down there
transducers reducers multi methods
protocols all these sort of esoteric
things that you know that are cool for
computer scientists then developers
don't care I mean yes they're going to
eventually use that stuff but the main
thing is doesn't let them build software
faster and with more ease so how to win
so I would say the summary of this talk
would be you know gives industrial
software developers something that they
actually need not what they want because
developers don't necessarily know what
they want but give them something they
need in the sense that you're an
industrial software developer
and you realize there's this huge pain
point maybe it's state maybe it's a lack
of interactivity give them a sort of you
know whole system where they can tap
into the thing that they're missing in a
great seamlessly with technology the
entire industry is already invested in I
think this is a hard thing to swallow
but the fact that matters if you really
actually want people to change the way
they write software you're going to have
to meet them in the middle you're going
to have to meet them on the platforms
that they want and only then are going
to get people to do the sort of
innovations that I sort of end in my
talk with right those are those are not
things that we have done if you make a
system that actually sort of addresses a
pain point people will fill in all the
many gaps that exist thank you
how does that end of my talk and I'll
take questions
so if you have questions please raise
your hand so we can give you a
microphone
so you spoke about the possibility to
write contracts in enclosure essentially
yes and can you tell us something about
how widely they are used I didn't see it
in I think I didn't see it in one of the
features that program is like but just
right because it's new so the conflict
good the question was how many people
are using contracts and actually a lot
but they were using a different library
to do it I was a library called schema
and so yes it was one of the most
popular libraries that were there people
were unhappy with it because it was
actually written with a sort of more I
would say traditional types perspective
the weight of the contract system work
whereas closure spec is very oriented
around validation of s-expressions and
you don't really have but unlike a types
kind of hat when you're using it but
people are switching in droves to from
away from schema to closure spec so yes
it is using a contract system is very
popular but the one I described is a new
contract system does that answer your
question so if you want to do a
tradition to do a recursive data
structure right so you say you want to
validate a binary tree you can you can
say this is the recursive structure and
you can do that you have basically the
full you know the full power of a
grammar so anything you could do with
the context-free grammar in terms of
validation you can do with spec
and so you mentioned the quick check in
relation to your closest Peck can you
talk bit more about what you've done in
that regard like do you actually have
tools where you can generate tests and
know that already oh yes so when you
write a contract and you say this thing
has to take a binary tree then what
happens is that we can use that
specification to generate the structure
that matches and that's functionality
that already existed in something called
test check we can just convert our
internal representation of what the
validation the validation needs to be
into a corresponding test check
generator right so if you're really
quick familiar with quick check you need
to provide generators right the types of
things that you're going to feed into
your program to test that it withholds
the you know upholds the property that
you care about so we saw we do we just
take the specification and we create the
corresponding generator so just as some
people who aren't familiar quiz track
quick check quick check is not actually
just randomized testing so the nice
thing about quick check is what it
actually does is it does generate random
data based on some shape but what it
does is once it finds a failure because
it generated the data something using
something called a rosetree it can
actually shrink it until it finds a
minimal failure and that's huge for
usability with respect to the programmer
because it doesn't mean anything if your
data it's like I see 1 million things
and which one of these things cause my
program to fail you don't want to see
that you want to see a 1 element vector
that causes your program to fail so you
specifically work on enclosure script
what has been the biggest challenge for
having code compiled consistently report
or a executes consistently on multiple
backends so fortunately that's not
something we have to Keane there's been
a few times where this has been a
problem because of bad implementations
that don't follow the spec but for the
most part again because we've been
playing it safe we only target a version
of JavaScript that's existed you know
now for 15 years so most n
have got that well covered so admins JVM
and JavaScript so we have two completely
different compilers maybe maybe that
wasn't clear right so someone writes a
library enclosure and you want that
library to perform both are the same and
job at JVM when called JVM and the same
one compile to JavaScript right so that
just works right unless you'd want to do
Interop stuff so as long as you don't
have host interrupts forms in your
program you can just take that program
and it's just going to work as close
your script
David you admitted that advanced
features are being used yes they were
they were called advance in 1960 yes
this is a part of the theme of my talk
right so that's how macros will be used
it's definitely the case but it's just
that's not what that appears in the
survey is what users care about
understand yeah I was the closure way as
I spoke there and so a really cool demo
and talk about the 737 max so closure is
also used in critical software it's
flying on the Boeing it's just being
released right now brand new aircraft
brand new closure software right on
there it's a it's really important if
we're not just in these androids and web
stuff hi in the past three attempts have
been made to add types to closure yes do
you think now this new contract system
will get rid of these attempts or ah I
don't think so I mean Sam is not Sam I'm
okay
Ambrose boner show John he's still
working on encore type though he's you
know he's he worked on that and the
thing is there are many things that make
it challenging I would say that since
closure wasn't designed with types in
mind many functions have very strange
signatures and it's not that fun to
interact with sometimes and so I think
people have discovered that while they
want the power of ahead of you know time
checking compilation time checking the
sort of cognitive cost of core typed is
not that great yet but I know that
Ambrose is now looking at gradual typing
as a way to find something as a better
fit and without a doubt he's been
putting closure spec through its paces
I'm sure he may have new ideas about how
to possibly to sort of bridge these two
things because I actually think again I
don't think a contract system in ahead
of time checking or at odds at all thank
you
thank you so just a quick announcement
so we going to have lunches and coffee
breaks in two different rooms so pick
the shortest line okay
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>