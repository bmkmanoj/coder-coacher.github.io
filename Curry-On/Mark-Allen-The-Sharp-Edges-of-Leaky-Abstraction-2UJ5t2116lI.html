<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mark Allen - The Sharp Edges of Leaky Abstraction | Coder Coacher - Coaching Coders</title><meta content="Mark Allen - The Sharp Edges of Leaky Abstraction - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mark Allen - The Sharp Edges of Leaky Abstraction</b></h2><h5 class="post__date">2017-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2UJ5t2116lI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hey good morning I guess it's
technically afternoon now I'm mark I'm
glad to be here I'm excited I'm sad that
I have to follow Jean I think she did
great talk if you if you weren't here
you missed out hopefully you can watch a
later
but today I want to talk about
abstractions really what I want to do is
rant about abstractions we talked about
abstractions for basically this whole
conference there's been a lot of talks
already about abstractions and now we're
there's going to be n plus one talks
about abstraction so anyway for the last
few years I've been writing Erlang
pretty much full-time is my day job and
so this is sort of a story about my
journey from Erlang land where you know
super happy mark and then I kind of went
over into Scotland where Mark was not so
happy anymore and so this is a talk
about that and you know one of the
things I learned from Star Trek 5 is
that every man has a secret pain and you
grow stronger with the sharing of that
pain so let me share my pain with you
maybe it's a pain you can identify with
maybe not I'm not sure but in any case
if you don't line up and ask questions
I'm just telling you right now you're
going to have to sit through a lot of
cat pictures so so you know let that be
an encouragement to you so I am sort of
an addict for Vulcan self-help books
this is the bestseller it's called your
pain runs deep check it out it's it's
fantastic all right so I mentioned
abstraction at the top of the talk you
know a couple minutes ago abstraction is
really useful it's what we do I think in
a large part as software developers we
you know introduce abstractions to do a
lot of things we want to introduce
levers into you know certain problems we
want to encapsulate things right so we
abstract them and we want to take
complexity away right we want to be able
to reason about whatever our problem
spaces our problem domain and so we
introduce all these abstractions into
our code and that's that's fine and
great and wonderful and and certainly we
need to continue to do that I think
that's very important
one of the things we need to be aware of
is when we start abstracting the wrong
things I'm going to get into what I
think those wrong things are later in
this talk assuming that you don't ask me
questions so the other thing that's
really interesting lately that I've
noticed especially is as I've gotten
older and grayer is that we have
abstractions as a service now it used to
just be that you had abstractions in
your codebase but now we have
abstractions everywhere and like my
sticker on the front of the computer
says there is no cloud it's just someone
else's computer right like that's an
abstraction of itself okay but we have
tensorflow and services from Amazon and
Azure and Google and you know dollar
sign random hosting provider whatever
any sort of web api that you that you
consume or use or or provide out into
the world you've created an abstraction
that you want other people to use and
you think about like how do people use
that in is it a good abstraction and
does it really encapsulate the sort of
things that we want to encapsulate but
you know we still have the traditional
model which is this sort of on-premise
abstraction right we have search elastic
solar sort of made search a lot more
accessible right there's the the scare
quote big data stuff spark and Hadoop
and Apache project you know you can put
any random Apache project in there and
it will pretty much be big data scare
quote and we also have this one this is
one of my favorites does anyone know
what this is anyone it's a database
right it's a data bass so yeah I used to
work at Bosch oh and we we had this jiff
a lot in our hip chat so yeah so we have
data basses and we we abstract away like
storage and we distract away sort of
storing data and retrieving data right
we hide it behind this interface of
sequel and that's fantastic and
desirable even right like we don't want
to have to manage all the complexity of
everything that we do all the time like
there's just too much cognitive load for
that so the pitch is this right you
don't really need to understand the
messy details about the abstraction
right like the abstraction is supposed
to hide all that from you it's supposed
to contain it it's supposed to protect
you from having to really think about
how it works so the assistant will
account for all the things right like
yeah all the things so just relax relax
right your system right
just write it as you would don't worry
about it it's fine right it'll be fine I
could have replaced this with what could
possibly go wrong all right
okay um we all know what could possibly
go wrong you I'm sure you all have
stories just like I do so if you do the
microphones there we're over the
five-minute threshold by the way it'll
be fine it will be fine
it'll it's even after this talk it will
still be fine all right so I mentioned
earlier that I started working with
spark spark is is pretty amazing it has
a lot of really interesting and great
features to it I'm going to talk about a
few of them in a second and one of the
really neat things is that it sort of
promises that you can write an
application to do big data as if you
know you're writing for a single
computer you're writing for a giant huge
computer that's super happy and does a
whole lot of things for you like this
stuff look at all this free stuff look
at it all you can program spark in three
different languages you can program it
in Python you could program it in Scala
you can program it in our I guess I'll
throw in Java so for free so for
languages
it automatically partitions work
it does job retries when the job fails
it automatically collate all the output
from the worker nodes it does job
scheduling it's pluggable you can plug
in your own scheduler you can run it on
thousands of nodes it even has a
reasonably nice UI right it'll tell you
like hey we're on segment 69 of 3490 -
and it'll even draw you a nice tag with
three thousand four hundred ninety-two
edges which is really completely
incomprehensible but it does it right so
that's super cool and and we like that
that's that's nice right but the main
point of SPARC is is that the computer
is your friend right the computer is
your friend that's what we always hear
the computers your friend but we all
know that the computer is not your
friend right
the computers not your friend and I
didn't come to praise distributed
systems
I came to bury them and it came to rant
about them a little bit but before that
I have an obligatory cat picture because
I have to number one but number two is
I'm seeing an airbnb that's that's
nearby and this cat actually lives in
the flat where I'm staying and she's
very very nice cat so I had to put in a
talk there's a there's a really
interesting article that was published
about a month ago on medium and it
talked about sort of the leaky
abstractions that were in Windows Vista
right it was a Mike Racine your
Microsoft software developer who worked
in office for a long time and he was
writing about surplus Polsky's law
software abstractions which is this all
non trivial abstractions to some degree
are leaky or hey he and Joseph Asti
wrote that in 2002 so that sort of me
more thought has been floating around
out there in the ether for a long time
for a super long time and I don't think
that anyone that I know who's been a
software developer for a long time can
really deny that this is true I mean if
you if you want to discuss that I would
be happy to take any questions but I
think this is a really interesting
conclusion
that's sort of not controversial in any
way but one of the things that that I've
been thinking about really hard in the
context of that is sort of what is the
price that we pay for bad abstractions
right like if they're all leaky to some
degree or other as if they're
non-trivial and you can quibble about
what does non-trivial mean like think of
an abstraction that you've written what
what okay FSA's is it is there more to
that like yeah my question is is leaky
abstraction is really like synonyms to
bad abstraction maybe leaky abstraction
is not like better struction it just
can't be it can't abstract some details
and then you shouldn't use that use this
abstraction in the cases where these
details might matter don't matter so I
mean what is say Robert yeah so the
that's a great point
I think yeah you're right
I guess what I was going to say or what
I'm thinking right now in the in the
context of that question is that leaky
doesn't necessarily mean bad like I know
that often we use it sort of in a
negative way we use it to describe as
fractions that are bad but if they're
all not if all non-trivial abstractions
are leaky to some extent right whatever
those words mean then every every
abstraction that we create has leaks in
it right we expose some of its internals
somehow or other for other people to
consume and sometimes that makes sense
and sometimes it doesn't make sense so I
think that that it's a good distinction
to draw between bad abstraction and just
regular old leaky abstraction which to
me is just abstraction so I don't know
if that answers your question or not but
that's kind of what I'm thinking yeah
another question go ahead so here's a
proposed way to define what it means to
be a leaky abstraction you have a
specification which is short and
understandable and which doesn't
completely describe the behavior of the
software that has this abstraction and
then you have a slight
more complex of specification that says
Oh in this particular case it doesn't
work like that you have to do this extra
thing to fix it up so when you have
these two specifications a simple one
you want and the more complex one that
is actually implemented that's the
league yeah good point um I I agree with
that I agree with that thought and
that's actually part of my journey on on
spark for sure so what I was thinking
about just to just to get back into the
the slides a little bit we're gonna play
pub trivia for a second does anyone know
who this person is any any clues alright
I've got a hint I've got a hint slide
it's coming up this is last chance to
get full points right now yeah it's
Arthur Clarke Arthur Clarke wrote here's
my here's my hint slide right isn't it
isn't that cool
it's it's the monolith like with Lego
guys I think that's super cool like it's
always awesome what you find on the
Internet
anyway the question is like what are we
to do like you know what are we to do
what are we to do about leaky
abstractions or bad abstractions and
Arthur Clarke wrote a story in the 50s
called superiority and it's a short
story it's probably about 3,000 words
you know you can read it in in five or
seven minutes probably and it's the
story of a civilization that was engaged
in a war for its existence with another
civilization and other space
civilization and it talks about how this
the the the first one which had like
technologically superior
military tactics and firearms and all
sorts of things like that ended up
losing the war and the story recounts
basically in graphic detail this
cascading failure of abstractions right
the the sort of scientist teams that in
this in the civil is in this notional
civilization would go out and create
brand new weapons that were super
destructive and they required a whole
bunch of other maintenance and
engineering teams to actually keep them
operational which imposed further higher
you know requirements on the military to
protect them and they could
do that successfully and so what they
ended up happening is they lost the war
right they lost the war because they
just kept building this increasingly
large and technologically complex pile
of weapons that require much more
overhead and thought process into making
them successful even though they were
they were amazingly successful that when
they were working right but that was the
problem was they didn't always work so
is it is the speaker thing counting up
or counting down it's got to go okay all
right sorry so so what are we yeah the
question way in the back I'm sorry to
interrupt because the the test talk is
well you have an ID and you have to
expose it but you are talking about
leaky abstraction and I remember when we
were using sequel we were like hollering
drawings because of performance
optimization and we were thinking like
the undying will execute the query and
we were we will have to format the query
in certain way to make sure that some
kind of optimization will trigger and
and so on but we were doing that because
we are not able to access the online and
and this this is this Yaqui of like you
have the language you have the API and
you have the information model and we
were trapped to this higher level with
where we were not able to access it
right so we will have to leak the
abstraction on your pose and maybe the
problem with like leaky abstraction
would be like why why are we trapped to
to only one level of abstraction at a
time and and we are we have to rely on
only key abstraction levers to be able
to do what we want to do yeah that's a
great question thank you the way I'm
interpreting the question is kind of
like maybe sometimes encapsulation is to
complete and it doesn't explode
those the information that we really
need to have to do our job right so
sometimes when we build abstractions we
don't anticipate the way that people are
going to end up using those abstractions
and we don't expose the right API into
them or we don't provide the right layer
for people to access low-level
information right and in those cases you
have you're sort of in the position of
being forced to work around the
abstraction right like all of us
probably have a story about you know
where we needed to get some piece of
data that's locked away behind you know
some Iron Curtain of of code and you
know you're just gonna have to bite hook
or by crook try to pull it out of there
somehow because that's what you need to
do to complete the task right or let's
implement the feature or solve the
problem or whatever and yeah that's I
think that's a good point I'm not
totally sure that addresses your
question but that's kind of where I'm
taking it ours is that kind of what
you're thinking there is that the
wavelength you're on so yeah I think the
the bottom of the cab selection is the
the problem with abstractions in general
like it to close the abstraction totally
and and make it not workable at the end
yeah and then we have to to take care of
about the abstraction details and it I
think the it could be solved with
extension points but they are very
difficult to define all the time and so
on and on right so they have been worked
on that too to have like multi layer
abstraction and you can like dive into
them and go up at the same time I think
that being worked in compilers to be
able to go back to the original source
code with comments findable like some
people start to take care about the
textual representation and to go back to
it yeah
and this is a very new point of view
before we would think about text as a
inferior representation and then we
would dive directly to the ast and so on
yeah but no we are able to go back to
the textual representation as well so so
it is getting better but yeah yep yeah I
I think I think the way is it again
thanks for the follow up I I think that
um I think we are as a discipline as a
you know I don't want to use the word
engineering because I think Matt might
completely destroy the idea that there's
software engineering yesterday but just
as as as people that work with code and
and programmers that are solving
problems developers they're solving
problems you know I do think that we're
getting better at handling abstraction I
think that we are getting more capable
of handling them successfully for sure
and you know I I'm pleased by that
I'm pleased by that and actually some of
the things I'm going to talk about in a
few slides I think point toward that
because I didn't want this to just be
like a lament right I didn't want it to
just be sort of a eulogy for for
distraction there has to be you know
there's a really super famous paper
called out of the tar pit and it's super
cool it's mostly pointing about
distributed systems design and I wish
that there was sort of a out of the tar
pit paper or thought process around sort
of design for abstraction and you know I
want it to be more in the vein of that
like you know trying to provide some
kind of thought process around you know
how can we make this better so just to
jump back into that a little bit so I
guess what I wanted to do now was you
know sort of talking after talking about
superiority and sort of the decline of
this civilization because of their
terrible abstractions I wanted to think
about what is the cause of leaky
abstractions like what things cause us
to leak out api's or data or just
operational details right what are the
things that influenced leaky
abstractions such that they exist right
there that there
pervasive right so question go ahead
well I guess I have one answer which is
it seems that when we neglect the
expected memory and time efficiency of
an operation in our abstraction mmm-hmm
then it becomes leaky so the thing that
I always come back to is the Scala
collections API and how I can write
something that I know I could implement
with you know jump instructions and
incrementing and index but I end up
getting something that does tons of
allocation and takes like an order of
magnitude longer than it should all
right yeah good point um
so one of the causes and this I think
plays nicely into your comment is that
we abstract the wrong thing right like
what is the quote wrong thing mean and I
think there's sort of a variable meaning
for what that is but a really really
good example is for example you have a
network interface right you have an API
that calls out over the network and you
pretend somehow that that's like
asynchronous but actually it's a
synchronous operation with the other
side or vice versa right another thing
that you can extract that's wrong or not
good is sort of latency right like where
you sort of say okay well this operation
is going to take 50 milliseconds or
something and then you just return it
immediately right you return some value
immediately and I know that there's like
computational models where like futures
right where things will get resolved in
the future and that's that's fantastic
but I'm just thinking about like you
know for everyday sort of web web API
calls and other things that you might do
on a remote basis to other nodes or
whatever sometimes those abstractions
can be really terrible and they can
really bite you and they can really come
back and haunt you and it could be you
as the consumer of that abstraction or
it could be you as the you know the
creator of the abstraction or your team
another thing that is I think a cause is
sort of trying to abstract things that
can't be abstracted like if you if you
have complexity that's just complex you
know sometimes you can't really build an
abstraction on top of that that makes
sense sometimes you have to you just
have to live with the complexity
you can try to provide a nice interface
into it you can try to make it you know
sort of less cognitive load for the
people that are following maintenance on
your code or trying to use your
application but sometimes you just have
complexity and it's complex and that's
just just kind of how it is we we
sometimes run into the situation where
we have things that are leaky by design
and I think this points back to that
tension right sort of like what what
Jonathan was saying earlier between kind
of like the barrier between the data
that's sort of in the underlying data
model and sort of what you expose or let
people consume and there's a tension
there right like I said so you're not
always going to be able to anticipate
how people use your abstractions you're
not always going to be able to you know
figure out that oh well I should have
provided an interface to compute this
derive value or I should have exposed
this data model you know this part of
the data model directly to the user so
that it could be modified very easily
you know so I think those are some of
the things that really can lead to bad
abstractions that end up being leaky and
things that are sharp right things that
cut you things that you that you come
back and you regret either using or or
building that regret can go both ways
right okay so let us be honest with one
another one of the problems that a lot
of us face I think is that service
providers especially and software
abstractions sort of promised us the
moon right they're like just build your
application that like you normally would
and it's just one giant computer then
you don't need to know all the details
those those things are sort of seductive
but not true right there it's fine for
you to ignore the details until it's not
fine for you to ignore the details and
that's just that's just how things go
sometimes that's just how they work you
you have to be honest about what what
the capabilities of your code are and
what the capabilities of your
abstraction are and what the limitations
of your abstraction are I think that's
something that we sort
gives short shrift to a lot of times you
know we want to promote our we're
justifiably proud of the things that we
that we make I'm that's just normal
behavior and we want to put it out there
and maybe other people will find value
in it and that makes us happy because
you know who doesn't like to be valued
for their contributions I think most
people do but one of the things that
we're not very honest about sometimes is
like what are the limitations of the
things that we're giving you so it's
like okay well we built a database for
you to use in your product and you know
it has this limitation in this
limitation in this limitation and
sometimes we either gloss over ignore
those things and or we don't publicize
them right like certainly if you're in a
commercial software product you're not
going to publicize the things that
you're the flaws that your abstraction
has you know that doesn't that doesn't
pay anyone's salary so I guess what I'm
asking for is a little more transparency
a little more honesty about sort of the
limitations of some of these systems and
abstractions and programming languages
and frameworks and all those sorts of
things I think that would be really
helpful I mean I'm not necessarily
asking for like a bullet point list of
all the things that are terrible right
but at least it would be nice to have a
sense of what that is okay I wanted to
talk a little bit about tutorials and
documentation I asked yeah thanks so it
seems to me that you are basically
blaming the authors of the attractions
could it be dead sorry ah thank you
Thanks so do you think equals we can
also blame the users you know sometimes
when I've sections League is just
because they're used North in the right
place yeah I mean I'm a I'm a I'm a bear
of little brain so there's no there's no
doubt in my mind that the mistakes and
things that cut me and spark are just
because I'm dumb I don't have any
illusions about that at all right like
I'm just not experienced with the
framework but I guess when I'm what I'm
trying to communicate and what I'm
standing up here trying to communicate
is that it's okay for me to be dumb
because I wish that there was more
transparency about the things that I
could be less dumb about the things I
need to be aware of as I build a spark
application or building
application and framework you know that
that that sort of experience in wisdom
you know comes with time but it sure
would short-circuit a lot of like sort
of groping around and failing and
falling down in our faces if we just
have more transparency about you know
what were the limitations of certain
things like when we're building our
application right because the promise is
well you just build it you just make it
and it's one giant computer and that's
how it works but honestly that's that's
not it's not how it works the messy
details get in the way
all right things fail jobs do stupid
data partitioning right like they'll try
to move ten gigabytes over to this node
that's already totally overloaded that
happens all the time
you know scheduler goes crazy it fails
whatever there's all sorts of ways that
the abstraction fails and I and what I
just think would be really great is if
there was more transparency about what
things would fail and what failure modes
they have I think that would be super
valuable one of the other things that
that I would like to encourage people to
work on is tutorials and documentation
and not just like the same tutorial one
of the one of the annoying things about
SPARC in particular is and I don't mean
to pick on them it's just that I have
the most experience with this if you
want to count words with SPARC then
there are literally 300 tutorials that
will tell you how to do that if you want
to do something real like with real code
with real data there's almost no
tutorials that sort of describe what I'm
trying to communicate which is you know
we have all these pain points we have
all these leaky abstractions and what
are the things that leak what are the
things I need to care about there's
there's almost nothing like that that
I'm aware of if you know please please
let me know because I would I would love
to find that resource so tutorials and
documentation can help and I think
that's a good way to communicate what
are the sort of limitations that your
system has and you can draw that on in
this tutorial it could be like well
normally we would want to do XY and Z
but you know really if we try to
implement Z we're going to hit this
roadblock in this roadblock and we can
overcome them in this certain way right
but you know this is an area where this
framework is not that good so I just
want to have people give thought to the
way that people might use your
abstraction so both when you're building
it and
both when you consume it right what are
all these pain points and the last thing
I wanted to mention was you need to give
some thoughts to how people are going to
operate your abstraction so this goes
above and beyond usage this is really
more about deployment it's about
configuration management it's about
monitoring it's about metrics
it's about all the sort of things that
you know a quote good production
application is going to provide to your
to your environment if you're an
environment where they ought where the
software developers are responsible for
the maintenance right for being on call
for things like if it fails or whatever
those are the sorts of things that you
need to provide out of the box right and
if your abstraction makes it hard to
operationalize your code base then
that's going to be another pain point
it's going to be another sharp edge that
cuts you when you try to use this in
production right and that's that's it
that's what I have to talk Thanks
yeah oh yeah microphone she is a very
interesting talk
I wonder whether a lot of the effort
from some of the talks we've seen a
carry on is about what I might call
synthetic abstraction so like static
analysis they're not things that have
necessarily been high-level properties
that the people have put in but that
someone's come along later and try to
examine and derive from it do you think
that kind of approach of taking an
existing artifact and kind of
discovering properties of it is likely
to be any more or less vulnerable to the
leakage problem um that's a great
question thanks it's actually a really
interesting question too I think one of
the features that I like about the sort
of static analysis pathways is that it
does give you a signpost to some
emergent behaviors that you may not even
be aware of that it's in your system and
I think like genes talk where she was
discussing you know security policy is a
perfect example of this sort of thing
where you're going to have policies
about who can see what piece of data at
what time and you know the the myriad
ways that that can conflict and come
into in you know change over time like
both the policy and who is looking at it
you know we we got have tools that help
us figure these things out and I think
that with tools like static and
analyzers and other things like that we
can help understand what of limitations
of our abstraction right we can help get
a sense for okay well this is sort of
the boundary of my abstraction so now
maybe I can look at how people are
interfacing with it and decide is this a
really good boundary right maybe it
should be a little bit further out here
a little bit further out there maybe we
should pull this part back right like no
one uses that so yeah great question
thanks thanks
sure I'm happy to go back to any of my
slides here are using leaky abstractions
all the time your example in natural
language and afraid like you can say
something like all abstractions or leaky
we didn't ask you to precisely define
the word abstraction we didn't excu to
give it to the exact temporal scope of
our I'm grateful thank you yeah but you
know we kind of know what you mean it
would maybe be nice if the computer
systems of the future didn't take us so
literally if we could somebody else
suggested before throw a number of soft
constraints that their behavior on them
and ask them to behave
reasonably by keeping all those
constraints in mud mmm yeah thanks it's
a good good comment appreciate that I
think another way out of the tar pit of
abstraction might be sort of along those
lines which is you know right now
computers are super literal and we
really do have to anticipate all of the
sorts of behaviors that users might want
to to do with a system right we have to
create how those interactions take place
and what constraints they have in the
future maybe it can be more fuzzy and
that would be a lot better for everyone
right like if the computer was slightly
more autonomous that might be a good way
to go too
any other questions yeah yeah one more
okay I just think that maybe you could
have a notion of good of bad leaks so if
we have an abstraction which serves as a
starting point where you have service
short specification you understand you
can start writing your code quickly and
get something running quickly if then
there's some kind of kind of
incrementality properties such that the
extra details that you didn't want to
know about at first but you have to know
about them in order to make the system
work in all situations if you could
enhance your system to take those extra
conditions those extra times into
count sort of incrementally you don't
have to refactor your whole system at
the beige you could just add sort of a
little bit of extra code and if in that
sense if your leak allows you to start
naively and then fix it up with a small
amount of code that's a good leak yeah
absolutely yeah I agree I I do I guess
maybe I should have had a slide that
says leaky not equal to bad I I agree I
think if you can start small and pretend
like one of the tactics that I like to
use on a new project is like what is the
stupidest thing that could possibly work
right like let's try that it may be it
will work sometimes it doesn't because
it's not fast enough or it's not
performant enough or it doesn't have low
enough latency or whatever but you know
at least it's a point where you start
with and yeah you just work from there
incrementally hopefully as you go
forward right you're not you're not
buried under this mountain of technical
debt and you can you know continue on
your merry way with your your
abstraction enhanced over time yeah good
good comment thank you there's also the
kind of opposite problem which I always
find myself in up against which is where
there's no escape hatch like where the
abstraction is actually successful and
you're like well if only I could reach
over there and just change that other
thing like if the design is like
stratified and sometimes it makes sense
to operate here and sometimes it makes
them strapped right down here yeah when
you actually can't it below is actually
incredibly frustrating so I don't want
things hermetically sealed all the time
yeah I I agree with you I think there
there's definitely a tension between
layers of data right like we need to be
cognizant of that as both sort of
implementers and consumers of that and
and again those are areas where I feel
like documentation could really help you
right it's like oh if you you know use
this method and you expect to get this
piece of data out it's not available
right like we've intentionally hidden
from you and maybe you could explain the
rationale like I feel like we're missing
so much of the why should we're missing
so much of the why and I think that
that's not a good thing I think I'd like
to see more of that and one more thing
is like free software allows you to in
theory
and go as deep as down the stack as you
want so like everyone knows it's Turtles
but I kind of like that idea that in
principle you could open up Spock and
look at the code or whatever whereas if
you use in redshift or something that
you don't have through access to rating
you can't go down that's true I mean if
it probably isn't a bug in the kernel
it's causing your issue but like yeah
you can let's respect that all the
layers yeah great great observation
Thanks so I think that's definitely true
and I maybe should have pointed it out
like a big difference between your own
your own on-premise abstraction in an
abstraction as a service is is that you
don't control that other abstraction you
know you're just you just have this API
whatever the API gives you that's what
you get and you know if you want more
than that well too bad
I thought you don't get it so yeah good
point
thank you one more question I'm going to
go back to the cat picture because I
really like it there it is the last
comment just made me think that it seems
that oftentimes the most transcendent
wins you get as an engineer actually
come from leaking your through your
abstraction and changing something about
what you're living on so like if you
just assume you have an x86 processor
and you try to optimize things as much
as you can you only get so far and then
all of a sudden Intel releases the Xeon
Phi and you have like 60 subprocessors
sitting next to you right like there's a
whole nother way of thinking but you
have to break your abstraction and go
down a level yeah
and so yeah I don't know and like the
tensor processing unit from Google is
another way we're actually breaking the
abstraction going under it or like
leaking through it and changing your
assumptions actually makes it really
really powerful engineering idea yeah
definitely that's another good comment
thank you I totally agree with you that
can be really really cool
anyone else no all right thank you very
much for your time and I hope you enjoy
your lunch all right
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>