<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Allison McMillan - Angelina Ballerina Learns About Memory Allocation | Coder Coacher - Coaching Coders</title><meta content="Allison McMillan - Angelina Ballerina Learns About Memory Allocation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Allison McMillan - Angelina Ballerina Learns About Memory Allocation</b></h2><h5 class="post__date">2017-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cLbzAXOUpA0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hi everyone okay Angelina Ballerina
learns about memory allocation one more
thing we were almost right
these things get more complicated when
you have hair the peril of being a
female conference speaker
like a headband really fancy headband
okay all right this is good okay okay I
am really excited to be here today
talking about Angelina Ballerina and
memory allocation first I'm actually I'm
going to tell you a little bit about
myself
I usually don't start this way but I
discovered and putting together this
talk but when you're talking about like
garbage collection and memory allocation
and sort of like fascinating but these
heavy technical topics it's surprisingly
really difficult to just easily weave in
a little bit about yourself along the
way so I live just outside of Washington
DC most people probably think that my
life there is a lot of this and this
this but I actually live just outside of
DC in Takoma Park which was recently
ranked the eighth most liberal town in
America and is referred to as a hippie
haven it's also an official nuclear-free
city as of a two-year-old named Devin
you might see him running around the
venue or Barcelona he's off with his dad
doing adventures today and Devin loves
talking about garbage collection as I
was preparing for this talk every time
garbage collection came up it was really
exciting he would look around for
garbage trucks I would try to understand
another complex algorithm it was really
nice to know that we both had this
shared excitement about garbage
collection and what that means for each
of us I also work as a developer a
collective idea collective idea is a
software consultancy based in the US and
collective idea is a really fun place to
work because we deal with all sorts of
clients everything from fortune 50
companies to just small startups getting
going to internal products for a project
a collective idea we are working on an
application that involved generating
enormous excels
Sheetz like hundreds of rows and columns
multiple worksheets really gigantic the
rest of the application was pretty
simple but this spreadsheet generation
was really the core of what the site
needed to do so we're chugging along
building this application optimizing
active record queries here and there is
a concern for speed and then one day
we're testing some functionality and
everything just goes bonkers we're
getting errors everywhere our web server
usage graph has those red has red and
lots of those little colored boxes like
the ones that you really don't want to
see and this kicked off a whole team
investigation into what was going on and
how we could solve it so part of solving
it was through understanding it I may
have already used a bunch of terms and
phrases that you might not know you
might be thinking oh maybe I should just
walk out of this talk if we're not even
speaking the same language and I agree
with you I've been to lots of conference
talks and read blog posts before that
involved words like heap and malloc and
all these resources that just felt like
incomprehensible words being thrown my
way to jot down later to maybe
understand so today we're going to go
over some definitions and scenarios and
we'll dive into each of these concepts
to understand them better and then talk
about some tools that we used in order
to help figure out what was going on and
how to put those in place I'm also going
to talk about Ruby code bases and we're
going to do this through Angelina
Ballerina how many people here know who
Angelina Ballerina is okay
couple Angelina Ballerina was a book
that I read a lot when I was a kid I was
a ballerina back in the day how many
folks here were dancers new dancers no
dancers well then you'll really learn a
lot today so Angelina loves to dance and
in this book she dances all
all the time day and night because she's
so focused on dancing she forgets to do
everything else she forgets to clean her
room she forgets to get to school on
time and so on her parents do not know
what to do they finally decide to enroll
her in a ballet school and once they do
that she's so focused while she's there
and she's still focused on getting back
to ballet school that she's able to
accomplish all of the other tasks as she
needs to
and eventually she becomes a famous
ballerina so obviously there are a ton
of parallels about memory allocation
partitioning memory focusing and shaping
memory into structure and format that
makes the program or Angelina as
productive as possible there are also
similarities between dance and learning
about memory allocation aspects about
remembering steps understanding what's
going on knowing the counts and what
steps fit the real goal is to walk away
with a better understanding of what each
of these pieces terms and words that I
discovered through that process are and
a better understanding of the tools that
you can utilize to look into memory
related components of your application
effectively and I'm going to try to help
these this really sink in but using
actual stories related to Angelina and
dance so they're not just words and
definitions I have a few caveat first
I'm going to focus today on standard
Ruby and some rails because memory
allocation and garbage collection are
enormous topics and works slightly
differently in every programming
language in a second I also want to add
that there are a lot of memory or
performance tweaks that can be made by
looking at database queries especially
when using like rails and active record
I'll mention some related tools for this
but I'm not going to dive into like the
actual active record optimizations and
plus one query fixes things like that
okay so let's get started
we are first alerted to this problem
when we started getting web server
errors we saw request timeout errors
request timeouts happen when an HTTP
request takes longer than 30 seconds to
create so the request is still going and
it may complete but it means that the
request that was sent to the Heroku
router via Dinos took longer than 30
seconds to complete Heroku is this
service that we were using then we got
memory quota exceeded errors this means
that the Dino needs more memory than it
has you'll see this sort of error in
your logs so related to Angelina
Ballerina to take the base of the
story's plot Angelina is so focused on
dancing and loves to dance so much that
she never remembers to do anything else
that she needs to she never takes a
break and is late for school
requests timeouts and just simply can't
remember the things that she needs to
memory quota exceeded so her situation
like ours leads to all sorts of errors
and not being able to remember what
she's supposed to be doing next and
running out of time to do things so this
is what that web server graph looked
like we had a few processes running in
different threads because splitting
portions into threads and background
jobs earlier helped solve some of our
earlier performance issues this is where
you can tell sort of where those threads
and those different dinos are and we saw
that we were running out of memory when
these colored boxes appeared now we
can't get very far into understanding
memory and the tools without
understanding some basic terms about
memory so start some of the basics
memory allocation is asking for a box
it's like give me a place to start doing
stuff memory is the actual box this can
be heap or stack we'll get into that in
a minute
memory usage is putting stuff into the
box so how does Ruby use memory
well ruby uses memory by retaining
objects there are two types of memory
stack and heap stack memory is memory
that's temporary
it's like local variables that are
created when you call a specific
function so angelina is focused on
dancing once she's enrolled in dance
school that's her heap there are all
sorts of things that she needs to
remember while she's at dance school
we'll get into the heap next but the
one-off tasks are like being on the
stack clean her room help make dinner
and do a chore she can remember these
for a short period of time do them and
then forget about it
heath is unmanaged memory where you're
saying please just give me this blob of
memory so that whenever I call a
function there's already a memory thing
malloc is mentioned in a lot of garbage
collection and memory talks malloc is
actually a function in C it's the
function that actually allocates a
certain number of bytes and puts a
pointer at the first bite of allocated
space
there's also Kellogg free and realloc
functions malloc basically stands for
memory allocation so Angelina in dance
school uses her heap memory it's all of
this space that's allocated for dance
specific knowledge but whether she's
learned she's learning about a turn or a
new ballet position or a dance step
she's made the space in her mind to
dedicate to learning and remembering all
things related to dance and within that
heap there's the Ruby heap and the
Machine heap so the Machine heap is like
a big blob and then the Ruby heap is the
portion of that machine heap that's
focused just on Ruby related functions
so within Angelina's dance heap there
might be a small portion that's
dedicated to ballet
her overall dance memory might also
contain information about tap jazz folk
all different kinds of dancing so
there's a heap and within that heap
there's a chunk or page allocated and
inside that chunk is a length list each
node and the length list is a slot and
each slot is a ruby object
so the heap is ballet the chunk or
ballet feet positions the list is a list
of ballet positions and each slot is an
actual ballet position these are just
called first position and second
position etc so it's like each slot is
one of those positions the list is
what's called a free list which means
the program looks to find the first open
slot and that becomes the Ruby object
once it slot is filled the pointer which
the pointer is just a thing that says
like here look at me over here over here
it moves to the next free space and
that's called bump pointer allocation
when all the slots are filled that's a
full page when there's a full page a new
page is allocated this new page is
called an Eden page because there are
available slots the objects filling up
each of these slots are called retained
objects memory usage grows in Ruby
programs as more objects or retained or
as more of these slots fill up so here
you see that now there are retained
objects in 11th slots a new memory is
allocated for what might come so as
Angelina learns more steps more turns
more dance terms she can't remember
everything she needs to prioritize what
she remembers and what she no longer
needs to when the garbage collector runs
the allocated objects can be collected
and thrown away so that you can reuse
those slots so what is garbage
collection to further understand the
difference between memory usage and
memory allocation we're going to take a
brief detour into garbage collection
might take a sip of water
garbage collection is a type of
automatic memory management that makes a
program seem like it has infinite memory
by reclaiming objects that are no longer
in use so there are languages that have
automatic memory management or garbage
collections and ones that don't so for
example Ruby or Python both have
automatic memory management language are
both automatic memory management
languages you don't need to think about
memory and allocation of objects or
implementing garbage collection in order
to free up memory manually the language
does that for you but in a language like
C for example there's no automatic
memory management so part of what you
need to do while programming is worry
about asking for memory freeing up old
memory and only accessing and reading
and writing what you're allowed to
garbage collection was written about
first in 1960 by John McCarthy in his
paper recursive functions of symbolic
expression and their computations by
Machine part 1 the best part about those
paper is that there is no part 2 there's
only part 1 so this paper talks about
lists and some of the interesting
aspects of lists one of those things
discussed is this idea that the program
automatically is able to allocate and
free memory this idea developed into
what we call garbage collection today we
does about some garbage collection
related words before when I was going
through just the basics of how memory
works but I'm going to mention them
again through this explanation because
it's a lot of words and concepts to sort
of soak in you might be able to
understand them in a different way
looking at the definition through the
lens of the garbage collection process
so garbage collection has two parts the
allocation and the collection think of
the allocation as the steps to perform
the dance and the collection is the
person that's actually doing the dance
the allocation refers to the heap or
stack remember the heap is a data
structure that you have access to and
you can allocate
deallocate objects from the heap
additionally as opposed to stack memory
this allocation and de-allocation can
happen in any order a heap can be an
object graph which is a directed graph
where the nodes are heap objects and the
directed edges are references to the
heap objects in the flats we're
definitely going to break this down
further so here like the root is
Angelina the nodes are the positions or
turns and the references or the
choreography that get you from one node
to the next the stack are specific
allocations based on methods or
functions that are called so stack
allocation focuses on lastin first-out
allocation onto the stack where the
record let's say angelina cleaning her
room is pushed on to the stack system
when the process is called and then gets
popped off once the process returns
garbage collectors have three main
responsibilities they allocate memory
for new objects they identify which
objects are garbage and are longer being
used and finally they reclaim that
memory by freeing those no longer used
objects so talking about the heap
looking at allocation and identification
that's part of the allocation piece of
garbage collection the steps of the
dance whereas the collect part is
obviously related to the collection
doing the dance and forgetting about the
moves as we finish them there's one of
this may sound familiar granule is the
smallest unit of allocation that exists
like the idea that there are positions
in dance a chunk is a large group of
granules like an allocation chunk a
chunk or all of the ballet positions
that exist chunks have lists these lists
are linked lists of nodes this is like
the list of ballet positions and each
specific position is a node each slot is
an object each node on the list is a
slot each slot has an R value which
gives you information about the node
and our value is the our object and the
our string and the our class this slide
is still on Pat Shaughnessy did a
garbage collection talk a couple of
years ago and this is like the best
diagram that I found that explains this
this is directly stolen from his from
his deck so each node or slide like a
ballet position and has a value which is
the object string and class so this
would be something like the string first
position let's say the class of position
and the object which is position 1
equals position new this slot also has a
reference or pointer remember we talked
about the bump pointer before and an
address
objects on a heap or talked about by
using their address and objects can
refer to each other and these slots are
pages which are contiguous on the heap
which basically means that they're
together
on the heap the total number of pages
that a program needs to keep in memory
to avoid increasing how long it takes a
program to run by more than a specific
percentage is the program footprint so a
program in this case like a
choreographed dance the dance has a lot
of different steps and turns you also
need to know a lot of ballet
fundamentals like the positions and
other information all of the information
that you need to know about this
particular dance is the dances footprint
these pages and flats are also referred
to as the object space in conjunction
with this idea of allocation and
collection garbage collectors have a
mutator on a collector the mutator is
the code that produces the garbage so
like if there was infinite memory then
the collector would be great because
there would never be any garbage that
actually needs to be collected but
that's not our scenario that's not what
actually happens our programs fill up
memory and create objects when it
executes it mutates the heap so think of
the mutator as the dance steps you let's
say you do a certain type of turn at the
beginning and then you never do that
turn again for the rest of the dance the
dance and the turn are part of the
mutator and then it can be forgotten
about and collected by the collector
so now look at the collection portion
the collector first identifies which
pieces of garbage are ready to be taken
out by tracing through the edges or
references from the route and anything
that doesn't connect to is garbage it
does this by looking at the references
from the route routes or areas of the
heap that can be reached without asking
other areas of the heap how to reach
them there are entry points into the
heap so in Ruby for example the objects
class is a route object in a heap the
collector finds the unmarked nodes and
sweeps them away in one type of garbage
collection offer of them the collector
is triggered based on thresholds and
threshold or the number of slots so once
we're out of slots and we need more
garbage collection is triggered there
are a few different garbage collection
algorithms or approaches I'll briefly
going to four of them and then we'll
really drill down into Ruby's garbage
collector there four approaches are
copying marking compact reference
counting and marking sweet
so first is reference counting reference
counting means that every time you refer
to an area of memory in the heap you
keep track of how many times you
reference you refer to it so you're
keeping count an object is only live if
the number of references to it is
greater than zero so you can easily say
okay great all these allocations are
zero that means they're garbage and can
be collected the biggest problem with
reference counting is that if you have
two objects that refer to each other the
reference count will always be greater
than zero and so there'll never be
garbage collected ever it's good
reference something is good because it's
incremental you don't need to stop
everything to figure out what's going on
and trace through the whole graph but
it's bad because there's a lot of
overhead to constantly counting and
keeping a reference in real life
deferred reference counting is usually
used which can lead to floating garbage
still require application and still
require application pauses etc
objective-c and python use some sort of
reference counting
which collection so next copying the
copying collector reduces the size of
the available heap it divides the heap
into two semi spaces the from space and
the to space the objects fill up the
from space once you've figured out which
are the live objects and which are the
garbage objects the live objects are
copied from the from space to the to
space and whereas in the front space all
the garbage objects were interspersed in
a heap semi space when they're copied
over they're all put together and
compacted and the pointer moves to the
end of the live objects demonstrating or
more allocations can be made then the
from space and the to space are swapped
so the from space is where the live
objects are and the to space is ready to
be copied into again when needed the
biggest issue that you see with for
copying collector is memory
fragmentation you could have a from
space that looks like this and you have
places to put memory so it doesn't seem
like we need to do any copying yet but
none are actually big enough for the
object that we need to place so finally
mark-and-sweep there are two variations
a regular mark and sweep and mark sweep
and compact in this type of garbage
collection the collector goes through
all of the objects and marks everything
that's still live or where there are
still related pointers then it sweeps
and for mark sweep and compacts it
rearranges the heap and compacts the
objects for just mark and sweep again
it's the same steps except without the
compacting at the end so here when the
slots or nodes of the linked lists are
used up then in Ruby stop the world
marking happens our entire application
pauses and goes through all of the
references and marks everything anything
that's live which means they're still
referenced from the root node everything
else is deemed as garbage the whole
object graph is traversed in order to do
this so this type of stuff the world
collection happens in a lot of garbage
collection approaches so our linked list
nodes or each of the nodes here once
they're all filled we stop the world
while we go through that whole tree we
see the root is Angelina and everything
that's referenced from the root is
ballet but these three nodes are related
to other forms of dance they're no
longer referenced or by the root until
they're garbage so going back to our
Angelina example we can think about
Angelina doing a dance she's performing
a ballet so she can't remember
everything about all different kinds of
dances she knows that this is a ballet
dance so she's referencing in her mind
ballet positions turns and moves as she
performs however she doesn't need to
know anything about tap and jazz so
those aren't referenced at all and they
can be collected so she can focus on the
ballet moves that she needs to there's
no overhead every time an action or
mutation happens like in reference
counting but the deallocation of memory
is delayed which means that the
application needs to pause to stop the
world for a longer period of time when
garbage collection and the allocation of
memory does happen so ruby uses
mark-and-sweep generate uses
mark-and-sweep garbage collection and
production start out in reality most
garbage collectors used in production
are a mix of different garbage
collection algorithms and optimizations
so ruby actually uses mark-and-sweep
with generational and incremental
garbage collection which incorporates
pieces of reference counting type
functionality into the process as well
so now we're going to jump into
generational garbage collection once
you've completed the normal mark and
sweep steps the objects that remain get
promoted to the next generation so let's
look at Angelina let's say Angelina's
learning a new dance
she learns a bunch of steps there's a
turn there's a leap and then she wants
to do some fusion cat move as Angelina
practices she decides that she wants to
cut out all of the leaves those leaps
can be garbage collected because she's
no longer using them and therefore that
cat move
as well but she wants to keep all the
pure wets all of the turns so the peer
would stick around and get promoted to
the next generation which is like
version two and she continues to
choreograph her dance garbage
generational garbage collection operates
under the hypothesis that most objects
die young so you might try a bunch of
things out but only a few of them stick
around so here we're continuing to
choreograph our dance we have some steps
already in place and we have some new
steps we've chosen to only connect one
of these steps to the root and to the
dance steps that we already have every
time you collect the garbage the stuff
that sticks around goes into the next
generation when you do the next round of
garbage collection you don't need to
revisit what's in the old generation you
can just say okay that's there that's
why it's staying live great you only
need to go through the newest generation
to mark-and-sweep from there so in this
generation this node and this node would
be marked but we don't have to look at
the others because they're already in
the older generation this saves time
because you're not looking at every node
every single time you're simply looking
at the nodes that are in the newest
generation a possible side effect of
this however is if you have a node in an
older generation and a new object gets
allocated from an object in the old
generation into the newer generation
because we don't check anything in the
older generation the new node will be
assumed to be garbage and will be freed
because that reference isn't checked so
this leap that we've added into our
routine won't be remembered because it's
a reference from an old object in order
to make sure that that new object is
discovered we need to put a write
barrier in place write barrier make sure
that that reference goes into the
remembered set through barriers the
mutator can inform the collector of
what's happening so it's basically
saying like hey make sure to look at me
even though I'm in the old generation
and you would
thing to do so when a garbage collector
does its thing it will look at
everything in the new generation plus
everything and I remember it said one
other aspects is that while generational
garbage collection reduces the average
pause time because you're not traversing
a whole object graph it does introduce
some sort of permutation overhead which
pulls in some of those aspects of
reference counting that we mentioned
earlier
finally there's incremental garbage
collection so generational garbage
collection optimizes mark-and-sweep and
incremental garbage collection optimizes
generational garbage collection
incremental garbage collection happens
through the Tricolore marketing
algorithm the tricolor marking algorithm
says that objects are white black or
gray when are white they'll be collected
when they're grey they're referenced
from the route we haven't looked at
anything that they reference and when
they're black they have no references
pointing to anything but they're
referenced from the route so you look at
gray objects referenced from the route
you make them black you change the
colors of anything that those new black
nodes reference and make those grey then
for any gray objects you mark them you
take away in a newly great object to
make those black there are none here so
you can sweep away the white objects in
more complex systems you do this process
until you sweep away the white objects
and once an object is black you're no
longer looking at what it references the
benefit of this is that you can stop it
at any time you can do a little bit at a
time you don't have to completely stop
the world for a long period of time to
do everything related to garbage
collection all at once
you can stop do a little bit let the
program continue etc but here's where
there's a problem if a black object
references a new white object it could
be freed because for all the black
objects you're no longer looking at what
they reference so here again you install
a rate barrier so that it goes since
that remembered set and isn't forgotten
about when you're doing AIDS and this is
like you can't just have turn after turn
quick move after quick move you need
higher and lower places for activity
in order to catch your breath and make
it through the whole routine again one
interesting piece of Ruby is that it's
not compacting so you can't rearrange
and move Ruby objects so if you have
pages with open slots or holes it can
actually prohibit how much memory or how
many pages you can destroy and have
memory read and how much memory can be
recollected so this is like if you could
never have dancers change positions in a
routine you have five dancers two of
them walk off but you still have dancers
sort of all over the place you can't
adjust the spotlight ideally they would
move together so that the spacing looked
right but Ruby doesn't allow us to do
that you can't free slots while
reference still while reference to it
still exists like if you're on a loop
for example so if you're making a
request and then the system is
processing it as it's processing a
request it's creating objects you need
to retain all those objects while the
request is going you run out of memory
garbage collection or run but if there's
still a reference to those objects they
can't be collected so you can't free any
of that memory so we'll get allocated
memory rails apps are a collection of
retained memory which are things that
will be held onto forever or for a while
plus allocated memory which will go up
and down and that combination of
allocated objects plus retained objects
is memory usage once the process
finishes and a response is delivered the
garbage collector will run again and
free some objects okay so all of that
explanation helps us look at the tools
that we need in order to improve how
memory is being allocated how objects
are being created and then freed to
allow for enough space for the process
to run when I go to the tools quickly
because I have like four and a half
minutes okay
we'll start by looking at Scout when you
start getting those web server errors
Scout is a great tool to start out with
using Scout you can identify what
processes or which endpoints are using
the most memory allocation or have the
most memory bloat this tool also clearly
shows you if your memory is memory
allocation is going up or down which
makes it really easy to figure out if
you're going in the right direction you
can add this tool by using it as a
Heroku add-on
and following instructions or adding the
gem to the gem file and the config file
to your config folder and deploying you
can go to the Scout dashboard and then
go to a specific endpoint and it's a
transaction traces to look to see what
you're looking for you want to look at
the end point and most allocations or
largest memory increase in order to find
the information that you're looking for
now
Scout will let you dive into as many
specifics as some of the other tools
that we're going to discuss but it's a
great dashboard to see an overall
picture and determine where to start
and additionally if you haven't done any
of those active record optimizations
then this is a great place to look for
those performance impacts as well how
many people here know the movie sneakers
oh just a couple that's definitely a
movie that you all have to check out
it's a really great movie from the 90s
and one of the things that they say is
they say that they're investigating
somebody and they say that going through
their garbage is the best way to get to
know someone so earlier we talked about
how Ruby uses memory filling up these
pages and slots with retained objects
the garbage collection the GC library is
going through all of the garbage in your
app to really get to know it it has a
ton of tools to help you determine
what's going on along the way so for
example GC stat has a ton of different
options one option is total freedom
so this is useful when you know you're
creating lots of objects and maybe you
want to see if they if the objects are
being released in order to make room for
new objects by running GC stat total
freed objects before and after a method
you can see how that's working or if
it's even working at all this can help
determine if your garbage collection
process isn't as efficient as it could
be because there are objects being used
that are still being referenced from
somewhere and therefore aren't being
garbage collected we're going to dive
into GC stat and a little bit of all the
information that it gives so this is all
of the information that you get when you
run GC stat and I'm only going to
highlight a few of these I tried to
highlight all of them and talked was
like really long heap allocated pages
are how many pages are available for use
in a
they might be filled they might be empty
it's just the total number of pages so
this is like a dance routine that you're
doing you might not take up all the time
but it's how much time you have for
dance moves
heaps sorted length is the actual size
of the heap so this is the total number
of slots in all of the pages even if a
page is free or used that length still
stays the same each Ruby Heat page has
four hundred and eight slots the size of
each slot is 40 bytes so each page can
hold about 16 kilobytes if we're
thinking about this and the routine that
we're doing and we're trying to
choreograph it this is like how much has
been choreographed so far people
available slots or how many total
available slots are in all of those
pages this is like the total number of
dance moves that can fit into a specific
dance routine keep alive slots or how
many slots are filled with live objects
that can't can't be garbage collected so
let's say in our dance we have a prop
you can't get rid of that prop entirely
until you're done with all of the dance
moves that use that prop heap live slots
would be how many dance moves use that
BET prop and then keep free slots or how
many available slots are left to fill
before running out of memory
so that's like what's left you have a
certain amount of the song where you
need to use the prop and then the rest
of it is currently free but there's
still a finite amount of time before the
end of the song heat final slots or how
many slots have finalized there's a
touch to them where the finalizer hasn't
run yet so finalized errs are basically
a run once the collection has determined
that it's collecting the garbage and it
runs when the garbage is collected and
an object is freed or D allocated so
this means the slots are currently busy
or live but they're about to be freed so
you're in the middle of doing a sequence
of turns once these trends are over you
don't have to do them again you can
forget about them so this turn is one
heat final slide total allocated objects
is how many objects are there to use so
as we work on our dance we add in turns
and we may change some of those turns
this would be like how many total turns
can be worked into the dance in total
freed objects-- or how many objects have
been D allocated and therefore their
memory is
available again for peruse so we're
choreographing we have a total of let's
say eight turns we can do we decided to
get rid of two of them so the total
freed objects-- is two and we can
continue to change the steps and this
will be the total of objects that we've
removed from the dance there are a bunch
more GC stat options but I wanted to
highlight these you can run GC set in
rails console or IRB and you can look
for a specific measurement by using a
command like this GC stabbed count using
this library the GC profilers gives you
access in your code to all garbage
collection information so you would do
something like that and this tells you
how long it took to run how many objects
were de located the total size of those
objects etc when you ask for a GC report
this is what you get back so this is the
invoke time the you size the total size
the total objects and garbage GC time
which is the total amount of time it
took for the garbage collector to run in
addition there are GC environment
variables you can look at things like
Keith heap growth factors malloc limits
etc so changing these is called GC
tuning for Ruby there the maintainer has
preset these for sort of like something
generic but if your application is doing
something specific you can look at
tweaking these a little bit and they
could make a big difference I'm not
going to go into these because that's
beyond the scope of this talk another
powerful tool is the object space
library so the object space library has
lots of different options as well it
goes through you can look at like each
object and it will show you the total
number of objects by class that are live
you can pass in specific classes and it
will tell you information about that
specific class it's basically object
spaces like the heap so it's basically a
way of keeping track of all references
to all live Ruby objects okay I'm going
to skip that example this is just like
the output that you that you get if
you're looking at specific classes
finally you can't fix anything
until you measure it which was said at
railsconf this past year and so the
benchmarking library is really helpful
for this you can do benchmarking which
reports CPU time system CPU time and
total real time it took to complete this
is a brief example like our Angelina
turning example you want to see how long
a process if you just want to see how
long a process took to run this is
really helpful especially when you're
looking at memory from maybe a bunch of
different aspects in rails these are for
gems that I wanted to talk about but
since I'm like already out of time I
definitely didn't have enough science to
talk about these but check them out and
there's a lot here that I didn't go into
garbage collection is actually a much
more complex topic and it differs based
on what programming language you're
working in so there are also a lot of
other aspects of memory including
database optimizations and other
components that we didn't talk about
today here are some resources that I
used for putting together this talk as
well as some additional ones to dive
into I will post these slides within a
couple of days so you know these will be
available I wanted to really quick thank
you to a couple of people who helped me
through this talk Mike Bernstein Chris
Sexton Steve Reichert and Jason Roelofs
for fact-checking hoping with extra
explanations and being really great
people to chat about throughout putting
this talk together and thank you all I'm
obviously not going to take questions
because we're at lunch time but feel
free to find me throughout the
conference I'm happy to chat about this
answer any questions show you some
slides that I had to rush through etc
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>