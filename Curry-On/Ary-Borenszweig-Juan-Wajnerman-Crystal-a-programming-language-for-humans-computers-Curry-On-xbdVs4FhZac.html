<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ary Borenszweig &amp; Juan Wajnerman - Crystal: a programming language for humans &amp; computers - Curry On | Coder Coacher - Coaching Coders</title><meta content="Ary Borenszweig &amp; Juan Wajnerman - Crystal: a programming language for humans &amp; computers - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ary Borenszweig &amp; Juan Wajnerman - Crystal: a programming language for humans &amp; computers - Curry On</b></h2><h5 class="post__date">2015-07-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xbdVs4FhZac" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everybody thank you
for coming my name is Juan as it says
here with my friend Ari we work for a
software consulting company in Argentina
and today we're going to talk about
crystal crystal is is a programming
language that we've been working on and
it's a ruby like language but it is
statically typed and compile it and more
efficient than Ruby and so let's see so
I want to start showing some
demonstration so you can figure out what
kind of applications you can run in
crystal so let's start with a very
simple example
it's a Mandelbrot set generator so I can
compile the example running crystal bill
samples Mandelbrot's here so this
creates an executable that I can run so
there we go
okay maybe the resolution is so we can
see how much time it takes to render
this is just seven milliseconds I can
run for this example I can also run it
directly using Ruby because the the
syntax is pretty simple they are pretty
similar I mean so if I run the same
program with Ruby we get the same result
but it takes around more than a hundred
milliseconds so we get a big
optimization there so another example
it's a right tracer right tracer is a
way of rendering 3d images 3d scenes
into images so this time I'm going to
compile the with the release mode which
adds some compile time optimizations
and I can run now and then we get this
this result this is this is not an image
loli from this this is rendered on
real-time and we see we got around less
than 200 milliseconds which is not bad
at all
let's see another example which is
should be much more fun this is a
Nintendo emulator written on 100%
crystal code so I can run I can load the
image and we could this is being
emulated by the all running in Crystal
Eye not a big another good
Mario player but so let's get serious so
let me explain why we did this so I said
before we were for a software consulting
company so we build software for our
customers and we often use Ruby as our
primary tool and the reason for this is
a Ruby fits really well into agile
methodologies it allow us to take a
project from theory to practice in very
quickly and maintain elegant and
maintainable code but sometimes we get
some performance problems sometimes we
have to after some time we need to
migrate some of the backend to other
languages because of performance issues
and so we normally migrate to some
compiler language because compiler
language tend to be faster at least also
Ruby said I mean language and sometimes
there are some kind of errors that if
not captured by unit tests unfortunately
they are Trickett of runtime so static
type checking allow us to
it contributes to catching some of those
errors at compile time and we wanted the
best of each wall so we started this
project to experiment with the language
that can provide the flexibility of Ruby
but the advantages of a compiler and
some type of language so we hear it at
the syntax from Ruby this simple code
here is either Ruby or a crystal program
not every Ruby program is a crystal
program and not every crystal program is
a ruby program as we'll see in a moment
but we inherit many of the things we
like from Ruby it's a statically type
check as I said so we can get compile
time errors about missing overloads or
things like that it generates a very
efficient binary executable we make
special emphasis on this on every aspect
of the language so I'm not a very big
fan of benchmarks but I think we can I
can show some of the results so you can
figure out where crystal is position at
compare it to other languages so the
first example is brain in fact it's a
interpreter of basically a Turing
machine as you can see crystal gets
resolved very similar to the C++
implementation compared to the Ruby one
which is a very similar code base and
that takes like a hundred times slower
the second example is matrix
multiplication and here we get even more
closely results to the C implementation
and Ruby is just a hundred times slower
and the last example is public is
benchmark set created by Google some a
member of our community migrated the
ported this benchmark
to Crystal and we got a surprising
result because we got even better
results and the C++ implementation and
this time we compared with Python
because there were no result for Ruby
probably still running so this is a
snapshot of a few days ago from github
of the Crystal source code and something
I want to note here we have a growing
community and a lot of people that is
putting stars on our project and for
those who don't know what this means
this is like Facebook Facebook like
right and also notice that crystal is
written on crystal itself so it's
complete boost trouble by now and we've
been working for this with this project
for three years now at the beginning of
course the first implementation was not
written in crystal the first one was
written on Ruby but once we get a stable
implementation we migrated all the code
from Ruby to crystal and now we have a
complete self hosted so now our is gonna
give a brief introduction of the
elements of the language so you can get
an idea of how to use it so I'll give
you a brief overview of the language of
course in 40 minutes we can say
everything but so let's begin so let's
start with the datatypes
crystal is an object-oriented language
so everything is an object and then we
have two big categories we have a value
which are value types they are allocated
on the stack and are passed by value and
here we have boolean characters we also
have the numbers their representation is
pretty efficient just in 32 is just 4
bytes and then we also can define custom
user types value types which are structs
so in this way we can create lightweight
wrappers around other primitive types so
we can avoid allocating memory in most
of the cases and then the second big
category is reference which are objects
that are allocated on the heap and are
passed by reference and they are managed
by a garbage collector so to free the
memory for us so we don't have to take
care of memory management and most of
the object objects fall in this category
right but then Kristin introduces has
another concept which is a union types
and that happens when a variable has
more than one type across different
points in the program so for example
here we have an array of mixed types
numbers and strings and when we access
one of those elements what we get back
is a union type which is again a number
a string later we will see how to deal
with this unions another example is when
we have when we want to ask for the
position of a character in a string so
the character might be there and we run
we return a number that's the position
but if it's not there we return nil and
that will mean that the character is
absent and again we have a union type so
these unions are represented in memory
pretty efficiently so here we have a
union of boolean and a number and they
are represented with the with a compact
struct that has a type ID and then
enough storage for all of the values
that confirm the union but for some
unions we have a more efficient
representation so if you have a
reference type and nil so in our
language in other languages in some
other languages references can be nil
and this is not distinguished but in
crystal there are different things so
string nil are different things and we
represent this as a single pointer if
it's the null pointer then it will be
nil and if not it will be a pointer
pointing to the data so again it's
pretty efficient
then just like in Ruby methods can
accept blocks so on the left hand side
we have a method declaration on the
right hand side we have some code
invoking it and with a yield keyword on
the left what happens is that we execute
the the block that's passed on the right
the right code looks really nice and
really expressive and the important
thing here is that crystal will always
in line this kind of blocks
so if you write while or write it like
this with a block the generated code
will be the same that there's no
performance penalty at all so you can
get to be expressive but you don't
sacrifice performance then we also have
a procs
which are typed anonymous functions so
here we have a proc that receives an
integer and returns an integer in this
case you have to put the types and this
procs can also form closures which means
that they can refer to variables the
declare a declared outside of that the
procs body so here we are accessing the
Y variable and then we change it and
when we invoke invoke it the results
change then we we made a choice here
that's a bit different from Ruby in Ruby
if you want to to have a method behave
differently according to the number of
arguments or order types you can do this
but the way to do is to do it is by
performing runtime checks so you ask
that the number of arguments or the
types and the code becomes larger and
harder to understand and to to read but
it's also slower because these checks
are done every time you invoke the
method and in crystal you have method
overloads so you can overload based on
ret or the types and when you invoke
these methods the compiler will infer
the types of the arguments and fine
the matches so with this just one match
at compile-time that call will be
hard-coded to that so there's no runtime
check to be done and if the argument
types are unions and there are many
matches this this decision to which
overload to call will be delayed to
runtime this is usually called a
multiple dispatch and it's pretty
powerful then we of course based our
language on Ruby and in Ruby you don't
you don't have type annotations because
it's a dynamic language and we wanted to
preserve that as much as possible so we
have a global global type inference
algorithm that means types are inferred
across the whole program and for that to
happen we have to infer the types of
each expression in our program so I'll
give a brief overview of this there are
some more complex details but this is
the basic idea so let's start with a
simple stuff literals the compiler
language knows what their type is so nil
is nil false and true or boolean you
have the numbers characters and strings
then moving on to assignments here what
happens is that the variable a will be
bound to the type of the expression on
the right hand side so then we have an
hour assignment and later we can see we
will see that the type of the the notes
in the in our program can change over
time
right when we compile the program and
these types are transferred across the
nodes so there's a really a binding
between the nodes and types travel and
change then we if we assign to a
variable in multiple execution branches
different execution branches at the end
of what will happens is that a will get
to be a union type right because in the
the first case we assign an integer and
and a string now let's deal with the
methods and calls so in Ruby and in
Crystal - you don't need to specify the
types of the arguments so in a way every
method is like C++ template if you know
them and only when you invoke them the
compiler will type it so what will
happen is that first the compiler will
infer the the type of the arguments so
here we have two integers and the
compiler will instantiate an instance of
this method with those types and then it
will proceed to type the body and in
this case it will be an integer the
result but if we invoke this method with
two strings again an our instance of
them this method will be generated but
with but with two strings as the
arguments and then when we infer the
body we will get a string yes we don't
have a separate completion it's like in
Ruby you run the program
everything is interpreted in our case we
have to compile everything from scratch
but it's pretty fast like the compiler
has around 30 thousand lines of code
that's excluding the standard library
and it's about 8 to 15 seconds to
compile most of the time is taken by the
code generation the type inference is
about 3-4 seconds but we don't discuss
with this we don't discard this idea of
separate completion we have to think
about it because it's this ideas are
pretty I don't know maybe novel and
there's not a known solution for this so
we have to work it out
continuing with the methods and calls
this of course has to work with
recursive definitions because otherwise
the language is not very useful so let's
see a bit more complex example with a
factorial so again we invoke it with a
string so when an instance
is generated with a string argument and
then we have any an if is an expression
in crystal so it will get the value of
the branch that's executed and so it's
type will be the e that you type union
of the branches so it will be the type
will be a Union and then we have the two
branches on one case we have a
multiplication and on the other side we
have a literal but let's start from the
top so it's the left so it's a
multiplication and here we have
factorial of an integer and this we can
deduce because n is an integer and minus
one is an integer so here we need the
type of fact instantiated with an
integer which is exactly the same thing
that we are trying to solve so we we
don't have a result for this but what we
can do is say ok this type will be the
type of the type of this call will be
the type of the this method instance
instantiated with integer so we bind it
and we can continue here so we can we
continue with the integer later and
that's easy to type it it's an integer
so the Union at least has some
information that's any an integer and
something still unknown but the compiler
will say okay I have an integer let's
move it forward to fact in 32 and now we
get a type a partial type that's an
integer now that we know that the type
is propagated to the node at the bottom
so now we know that's an integer and we
can perform the multiplication when we
multiply two integers we get an integer
and then we have the union of integer an
integer and that's just integer so and
that integer is again propagated up and
we are done because we don't have more
types changes like we reached a fixed
point so that's the basic idea of how it
works there we go
so now let's consider this example we
have a string and as I said before we
asked for the position of a character so
index asked for the position of a
character in the string and we said this
because of how the method is implemented
returns an integer or nil now usually in
a dynamic language where all things
happen in runtime if we try to index the
string with a and the character was not
there we will get a runtime saying no
you can't index an a string with a
whitneyhl in this case the compiler will
complain so you won't be able to
actually create a program out of this
because there's no overload for this
string accessor accessing a position
with nil so the compiler prevented us
from making a mistake and this also
applies for example when you have a
union type and you try to invoke a
method on it all the other methods need
to be in the in every type so you don't
get we don't have null pointer
exceptions
so basically or invoking you don't get
undefined method at runtime but we can
solve this problem by using a check so
if we do if ideas for those of you know
Ruby or are not the only values that can
fail an if condition so give that go to
the else branch our nil and false so in
the damn branch of the if if a condition
passed ID X can be nil and the compiler
automatically down casts ID X to be an
integer so pretty expressive and now we
can perform this operation and another
way to do it is with an e a so this is
an operator it looks like a method but
it's part of the language we can ask if
ID X is an integer then inside the damn
branch of the if the compiler again will
downcast the variable so we don't need a
separate variable or something like that
so it's pretty comfortable comfortable
to program with that yes
now in this case it's the first
representation of a union so you will
have a small struct with a type ID and
then if it's nil that the value doesn't
matter because Neil is always new and if
it's an integer it's an integer so it
would be 8 bytes for example for the
type IDs and the integer so we always
try to take really good care for the
performance we don't do outer boxing or
stuff like that we try to be pretty
efficient then we have types and classes
and they can have instance variables
like in many other object-oriented
languages and the thing is here that the
type of the instance variables will be
inferred from the values assigned to
them across the whole program so here we
instantiate a person with a name and
it's a string so the compiler will type
this name as a string but if later in
our program we create a person with an
integer the name instance variable will
get the type a union type of integer and
string and this doesn't work well with
the data types so if you have a race or
other collections you don't want you
want separate types for each collection
so we have the notion of generic types
so here we have a generic stack class
and with the parameter and we can create
a stack that will only contain integers
and another stack that will only contain
strings
and now I'll leave you again with one
more about concurrency and some other
features okay so um as we are doing
language that could perform well we also
wanted it to handle concurrency a little
bit better than Ruby does so we for this
topic we inspired on other languages
like go and L Lang these two languages
have in common that they release the
programmer in thinking about operating
system threads and mutexes and blocks
and stuff like that so in in crystal we
have this notion of lightweight
processes so you can use the bound
function that receives a block and it
what it does it will create one of these
lightweight processes that we call
fibers and these fibers are managed by
the language runtime so automatically so
when you invoke spawn it will create the
fiber and the program continues running
and the language runtime will decide
when to schedule in that fiber in and
out we do always blocking i/o so every
time you invoke and for example sending
or receiving packets from the network it
will block the execution of that fiber
so at that moment the language runtime
will schedule out that fiber and
schedule in another fiber that is on
that is waiting to be run and when the
data comes in for example through the
network the language runtime will
schedule back in that fiber so you don't
have to deal with callbacks like in
noche es or or or things like that
you just write linear code and the
language renter will figure out how to
schedule the the
fibers we also use this notion of
channels from from go that you can use
to communicate and synchronize fibers so
in this example we create a channel that
sends and receive integers and the fiber
will be a waiting for a message to come
through the channel so this is also
another point where the language runtime
will schedule out the fiber if the
channel doesn't have messages waiting to
be received so the fiber will be
scheduled out until another fiber sends
a message through the channel and this
is a pretty simple concept that we can
use to communicate fibers each other
it's actually inherited from another
concept which is CSP communication
sequential processes so let's talk about
now about meta programming Ruby is a
very dynamic language you can modify the
program as its runs because the code and
the data of your program lives on the
same memory space so you can change the
program at runtime but in Crystal we
cannot do that or it would be really
expensive and we don't want that so we
need to add another way of dealing with
meta programming so for example here we
have a class and we declare two
accessors of instance variables and we
see there is some duplicated code here
because we declare a method with a name
and we access the instance variable with
the same name so in Ruby you can use
some special methods that can be the
language that will declare to declare
those methods for us increase that we
introduced the concept of macros that
will execute at compile time and
generate the code for us so we can
declare the gaiter macro for
and this is the simplest example of a
micro that I can show but it receives in
the name of the the access or that we
want to generate and you use those
double bracket placeholders to replace
with the nodes that would receive as
arguments so now we can rewrite our
person class using this macro like this
we can also go even further and we
create a macro that receives many
arguments and we can iterate through
those arguments and generate as many
accesses as we want so the macro is the
macro system is quite powerful and we
can use it to generate and avoid a lot
of boilerplate at compile time we can
even execute external processes that
generate code in in crystal and finally
as I said the beginning crystal is
completed boot boost rapid right now I
mean is self-hosted everything is
written on crystal so if we want to
communicate with the external world I
mean the native libraries of the
operating system or the standard c
library or things like that we needed to
add some some way of declaring those
external external libraries so for
example we can use the we just live
block so to declare external external
functions of course you have to annotate
the type of all those functions and then
you can just invoke those functions
directly in your crystal code we can
also declare C structures and allocate
them and pass pointers to the external
functions we can also use props as
function pointers to give callbacks to
other to other libraries and the
important thing is that this all this
happens inside crystal without having to
go to any other language to create
extensions of the language so about the
future
right now all the concurrency that I'm
just mentioned a moment ago happens on a
on a single thread is it still really
efficient for for example on my machine
on this laptop I can run an HTTP server
that responds about 60,000 requests per
second but we still want to add multi
thread support suit so we can take
advantage of all the curves of the
computer debugger we have only as very
simple debugger but we are working on
that frameworks or libraries I mean no
yes but
okay okay well see we're going to be
hanging around so we you can come by to
us questions yes
we just yes okay yeah so the question
was what we use for GZ right so we use
the right now we use the bomb he CGC
which is an open source do you see that
is pluggable on native applications we
plan to replace it with something else
in the future but for the time being is
pretty good for for this purpose
probably also and I didn't I didn't make
that benchmark and probably the C++
implementation also takes care about the
memory that he creates and maybe the the
crystal implementation is done with the
I mean with standard erase or other
structures from the standard library so
it's probably because of that so the
question is the union types are can be
created by the programmer yes you can
use Union type annotations for example
when you declare an overload you can
specify Union or you can create an array
of Union type by hand yes can we create
new value types yes absolutely yes you
can use the instead of using class for
declaring new types you use struct and
that will generate a new value type that
lives on the stack yes
okay so there was just more like a
comment yeah that Eiffel also implements
Neil as a separate type from reference
types plus is a regular method so I
simplified the slides but when you had a
plus the same process again happens for
the type inference at the bottom we have
like plus implemented for primitive
types yes just like in group
so the question was how to how are we
are we planning to deal with shared
memory between fibers right so this will
be pretty similar to go in which you can
share memory but you should not you
should communicate using channels also
so the you can you have to share by
sending and receiving messages and not
by sharing memory
so let me repeat the question it's a the
question is see if we can take advantage
of the similarities between Ruby and
crystals so Ruby libraries could be
ported to Crystal well it depends
for simple libraries maybe is that's
true
we actually ported that I mean that the
compiler itself was once written in Ruby
and we parted the crystal very easily
that might not be true for every gem out
there but yeah I think it should make
things more easy to be ported yeah I
think so yeah many members of the
community that we have right now that is
it's pretty small but it's growing every
day
most of them are already Ruby
programmers so and they become
interested in crystal because of the
similarities just as we are okay okay so
still we going to be hanging around so
you have more questions and by the way
we have everybody but if you want one of
these you can come by and get one so
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>