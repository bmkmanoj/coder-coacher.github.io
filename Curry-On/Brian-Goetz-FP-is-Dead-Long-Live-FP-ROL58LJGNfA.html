<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Brian Goetz - FP is Dead Long Live FP | Coder Coacher - Coaching Coders</title><meta content="Brian Goetz - FP is Dead Long Live FP - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Brian Goetz - FP is Dead Long Live FP</b></h2><h5 class="post__date">2017-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ROL58LJGNfA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">together so this talk is a little bit of
a heresy it's trying to explore the idea
that while functional programming has a
tremendous amounts teach us all that it
might just be the case that mainstream
wide spectrum languages like Java or C
sharp or Scala they have even more to
offer us in terms of using functional
techniques to confront real-world
problems than pure functional languages
do um and obviously like I have some
self interest in this thesis right like
this is what I do and despite the fact
that a lot of people I think just wish
Java would go ahead and die already I'm
actually quite optimistic about Java
theater and I'm passionate about moving
Java forward because of the huge
leverage that it has we have nine
million developers and if we can help
just some of those nine billion
developers learn to program even just a
little bit better than the then the
effect they are on how the world
programs is really substantial um when I
was invited to do this talk at first I
was a little bit surprised because after
all Java is primarily an object-oriented
language and oo is a little bit out of
favor these days and one of the themes
of curry on is emerging languages and
Java is definitely not an emerging
language but as was explained to me
curry on is dedicated to the idea that
we're kind of all searching for the
answers together and to some extent were
all kind of Impostors here so I like
this idea and I took this as license to
talk about a few things that I don't
know anything about so the first topic I
don't know anything about that I'm going
to talk about is sports all right and in
particular we'll talk about sports
rivalries right every sports team has a
rival team the team the fans love to
hate and you know such as I'll use an
American example the rivalry between the
New York Yankees and the Boston Red Sox
fans love their teams but a lot of
sports fans are even more focused on
hating the other team and so you know to
make this concrete let's imagine a
typical hour of Yankees fan and a
typical Red Sox fan and you know let's
think about these two guys let's think
about them from well Who am I
let's think about this from an
object-oriented modeling perspective
right what are the behaviors that they
share versus those that separate them
and they actually have a lot in common
so to start with of course you know
they're both people and they share the
behaviors
people have and they're both sports fans
so they share the behaviors that sports
fans have like doing the wave and
painting their phase since spouting
statistical gibberish and they both
think that the other is the embodiment
of all that is evil but if you step a
little bit away from these two guys you
realize they're the same guy right
really I mean even in the object model
they don't even get their own classes
they just get different construction
parameters right so this is um you know
this is a topic that of course as you
know has been explored throughout
history um and for example you know the
original Star Trek guy explore this in
one of the episodes called let that be
your last battlefield which is that we
focus so much on our differences that we
miss our overwhelming commonality so in
this Star Trek episode most of you have
probably seen because we're all geeks
here uh the crew encounters this species
of humanoids that are half black half
white but some of them are white on the
left and some of them are white on the
right and of course they hate each other
and all they want to do is kill each
other and you know there's only two of
them left
they're all dead except these last two
guys and they're still focused on
killing each other and of course from
the crews perspective they can't even
tell the difference right you guys are
both half white half black why you know
why are you so upset and of course the
social message here is about as subtle
as a sledgehammer Oh but sadly we play
the story out in our community every day
I mean so imagine what we look like to
normal people when we're arguing over
spaces versus tabs or you know text
editors you know from the outside
you know from the outside perspective
the spaces guy and the tabs guy are the
same guy right um and you know the
observer is thinking you know and
they're upset at each other not only
over not even over code but over this
completely non-functional aspect of
coding so any while the observer is
thinking you know if these two idiots
could just get over their stupid
argument and learn to work together then
maybe my car would actually be able to
talk to my phone so this brings me to
the next subject about which I know
nothing cultural anthropology now you'll
notice sports fans will say things like
we won or we lost even though they had
absolutely nothing to do with the
winning of the losing and this has to do
with you know the creatures we are the
biological biological creatures we are
we're naturally wired to form into
tribes and tribes could be formed along
a lot of dimensions facial social
spiritual experiential but you know this
impulse to form tribes and to
subordinate our identity to those tribes
you know it makes sense from an
evolutionary perspective it's a good
defense against being eaten by Tigers
you know so but we don't live in an
agrarian society with with marauding
Tigers anymore we live in a
technological society and we're pretty
much insulated for the risk of being
eaten by Tigers but our brains are still
wired the same way they always have been
now there's nothing wrong with tribalism
I mean a tribal membership encourages us
to learn from each other ought to help
each other collaborate these are all
good things but it has a dark side too
and where it can get dark is when we
start to demonize members of the other
tribe rather than asking what can we
learn from them and I have to say it's
it's not such a great thing that as
programmers we're really bad about this
I mean really bad we define our
identities as Python programmers or
c-sharp programmers or functional
programmers and then we engage in these
pointless debates about why the other is
wrong or foolish for preferring such
primitive tools or tabs so you know the
reality is as programmers we all have so
much to learn about building correct
robust maintainable secure easy to use
cost-effective software that we should
be ashamed and certainly we shouldn't be
criticizing others about tabs or VI or
static types or objects or actors
because the user doesn't care whether
the code is written in Haskell or object
COBOL they just want their phone to talk
to their car and that's actually kind of
reasonable so the tribal division I want
to focus on today is functional
programming versus object-oriented
programming so these days functional
programming is popular and so not
surprisingly it's gotten really popular
to criticize object-oriented programming
and it's easy to find articles or blogs
or conference talks about how and why oo
has failed to live up to its promises
which okay to be fair is totally true
but let's be realistic here has there
ever been a programming technology that
has lived up to its hype you know so
when I was preparing this talk I watched
about a dozen of these videos and they
all played the same tune they took
examples of object-oriented programming
done badly Mis applied and then
proceeded to bootstrap from well it
didn't work here - it doesn't work at
all and again to be fair there are
plenty of examples of olp done badly so
these guys had plenty of material to
work with but just because something can
be done badly doesn't mean there's
nothing to learn from it so you know
while some of those rants you know have
a point and a lot of them do I think
they're dong a bad at the wrong way
because there's an awful lot of if my
tribe is right the other tribe must be
wrong here but oh it doesn't have to be
wrong in order for FP to be right it's
it's a false dichotomy and we're
spending all of this energy on the anti
on the against when we could be learning
from each other and we certainly have a
lot to learn from each other so this
brings me to kind of the main theme of
my talk today which is rather than
identifying ourselves as Python
programmers or C++ programmers or
functional programmers we should be
focused on being better programmers
because we all have so much to learn we
should seek to learn as much as we can
from as many paradigms as we can so to
become better programmers my advice is
we all need to learn classical FP we all
need to learn classical oh and
then we need to strive to rise above
them both okay that sounds cute what do
I mean by that well languages and
paradigms are tools they're just tools
and no one tool is ideal for all
situations
the French are the French writer in the
Chartier once said nothing is more
dangerous than an idea when it's the
only idea you have if we become you know
too married to one idea or one
programming paradigm you know we're
going to try to apply it even when it's
not applicable we're going to try to
distort the problem so that it fits into
our idea a programmer that's skilled in
multiple paradigms is just much more
likely to find the right solution to a
given problem than one it's only school
skilled at one of them regardless of
what language they're programming in and
the right solution might not be pure oo
might not be pure F P or pure anything
it's more likely a blend of multiple
disciplines and in fact it almost has to
be right because neither oo nor F P are
really complete disciplines right pure
FP has no notion of computational
resources you know such as memory or
threads or file handles and pure object
orientation has no notion of a
computation that isn't localized within
some entity or component but but real
programs running on real machines need
to consider both so as I said object
orientation has a bit of a bad
reputation that these days and some of
it is deserved and some of it isn't and
certainly it suffered from having
arrived on the scene under tremendously
inflated claims and expectations so I
don't know how many of you were
programming in 1985 but it was it was
pretty nuts and by 1990 you know the
hype surrounding objects had reached
ridiculous proportions
most of the OO code out there is what I
might call Sorcerer's Apprentice lol
where you take sensible principles and
then you apply them to their ridiculous
extreme so for example encapsulation is
a powerful tool
let's encapsulate everything and you
know encapsulation is a powerful tool
but I don't need it at every boundary I
mean I might want a heavy lock on the
front door of my house but I surely
don't need one on the closet of my
bedroom and
you know most low in orthodoxy treats
family members and burglars with about
the same degree of distrust which means
that like I have to unlock the door
every time I want to get my shoes out of
the closet and and to make matters worse
as we sort of write our programs and
we're sort of feeling our way around in
the dark the boundaries are often drawn
before we even have a good clear design
for our program leading to the
equivalent of like a bank vault door not
only on every closet and bathroom but
sometimes even in the middle of the
hallway so no wonder people think oh oh
is cumbersome but this isn't really what
I was about although sadly it's what
comes to mind for a lot of people and we
largely did this to ourselves right you
know so I'll take my share of the blame
right you know in the java world we have
this javabeans convention for components
you know which was originally designed
for one thing right dynamically
discoverable visual components in an
interactive editor which was a great
application for oh oh and then Along
Came they learn Java in 21 days crowd
and these books said apply these
conventions everywhere every class
should look like this and of course we
got the worst of both worlds we had all
the ceremonial overhead and friction and
none of the abstract value good job okay
but you know a lot of you have probably
read you know some of the articles or
I'm talking about like there's this rant
called the kingdom of nouns which is all
about why you know Java is stupid and I
think they think that they're railing
against oo but really what they're
railing against is a cartoon
exaggeration of oo the conventions that
were right for graphical component
framework are probably downright silly
for most domain objects but that doesn't
make the technique silly right so I
totally understand the motivation for
dumping on oo this way and and it's
certainly I'm sure it's therapeutic for
some of us but what worries me is that
it just makes us worse programmers
because it closes us off to what we have
to learn from other tribes so all right
if that's not what oo is then what is it
well let's step back a little bit let's
step back from C++ and Java and c-sharp
which are object-oriented languages for
sure but they also carry a lot that's
not intrinsic to classical oh so alan
kay one of the fathers of object
orientation once said
well I made up the term object-oriented
and I can tell you that I did not have
C++ in mind and if he were saying that
today he'd say the same for Java or C
sharp I'm not slagging off on C++ here
C++ and Java both emphasize inheritance
but class-based inheritance isn't
essential to oh it's just one way to get
polymorphism
similarly static typing isn't essential
to oo small talk with dynamically typed
the essence of oo is that computation
proceeds by objects sending messages to
each other these messages don't have to
be statically typed they don't have to
be synchronous they're gonna have to be
local you send an object a message and
it does something maybe it performs a
side-effect or returns a value or sends
a message to somebody else and this
gives us polymorphism because the target
is free to respond in any way that makes
sense for that message and whether this
polymorphism happens to come from
classes are from prototypes or from
nasty stateful logic is really just a
matter of bookkeeping but complex
systems do need dynamic dispatch they do
need polymorphism and typically all
languages give you a pretty easy way to
express that and reason about it ok what
about state in the oo world state is
owned by objects and to access an object
state you send it a message which brings
us to the other major you know
contribution of classic Aloha which is
encapsulation oo languages give
developers a straightforward way of
saying only this code can access this
state and in the you know if you think
about where object orientation came from
go back to the procedural world we were
in you know before 1985 and the one of
the big problems and one of the big
impediments to programs growing beyond a
certain size was reasoning about program
stage if all the code in your program
can access a variable then in order to
reason about its possible values you
have to analyze the whole program
encapsulation lets us take this global
analysis and shrink it down into a local
analysis where I only have to look at 50
or 100 or a thousand lines of code to
conclude something useful and that
enables programs to scale larger so ok
that's class below what do we mean by
classical FP if you ask you know people
what's the
essence of FP the typical first answer
is something like well immutability and
pure functions or maybe they'll say well
pure functions as first-class values or
function application by substitution now
in reality very few functional languages
actually behave this way all the time
and with good reason right because
dealing with things like state or nasty
and simulating state and IO with monads
is while fascinating is not actually how
most people want a program and you know
it's classical FP doesn't give us an
easy way to reason about things like
memory utilization which is actually an
important thing you know that we need to
think about in our programs so most
functional languages make some practical
concession towards the messy real world
via some direct support for ionian and
they accept the strictness that entails
and then we rely on programmer
discipline to not use these things when
we shouldn't so ok let's let's let's
take a nice oversimplified comparison
between these two paradigms you know all
computation proceeds by sending messages
to objects in FP the proceeds by
applying functions to values if we up
level this to the scale of a program we
say an FP program well it's just a
function
it just takes its input and transforms
its input into an output low programs
have a little bit a higher higher
impression of themselves an oo program
is really something more like an
executable model of an entity and and
for any given situation one or both of
these views might be useful to us with
respect to state in in FP our program
sort of swim around in this sea of
collectively own data that's transparent
anybody can inspect it um you know
things are more opaque there are these
little Paik islands of data that's owned
by objects and each object is king on
its own island and there are times when
encapsulation is absolutely a lifesaver
in terms of managing complexity to say
nothing of security and there are times
when it just plain gets in the way and
as professional programmers we're going
to encounter both of these situations
and we really ought to know how to tell
them apart and how to deal with them and
hopefully rise above the distinction
so you'll often hear this comparison you
know oversimplified as you know you know
Oh everything's an object where is it
everything is a function you know every
programming style has an obligatory
everything is an X summary which you
know everything is an object or function
or an actor or a peanut butter sandwich
and you know these characterizations are
useful for about the first 5 minutes of
learning a new paradigm but after those
first five minutes I think that
everything is an X you know a
simplification is actually pretty
destructive because in reality not only
isn't everything an object nothing is an
object right nothing is a function and
certainly not everything is a Java being
right so objects and functions and
actors they're just models right and
these models are useful to help us
understand our code but we shouldn't
confuse them for representing reality so
we can choose to model things with
objects or actors or functions with
varying degrees of fit and fidelity in
the hopes that the messy complexity the
mech cities complexity of the program
can be managed but there's this this
huge leap from use X to model Y to
everything as an X and it's not a very
healthy one so you know it's clear that
everything is an object is wrong but our
objections abadan are usually in the
wrong place usually we're objecting to
the object part when in fact we should
be objecting to the everything part and
you know this everything is object ideal
was like so overplayed you know even by
the late 80s that in the paper future
trends and database systems Michael
Stonebraker said if I hear the phrase
everything there's an object one more
time I'm going to scream but he was an
objects guy right he it wasn't the
object part that he thought it was was
bad it was the purism and I think that
FP fear purism today is no more
attractive than oo purism was 30 years
ago so yes of course we need to abstract
things away from the real world in order
to have any chance of solving them with
software because the world is so full of
messy accidental detail that we have to
filter some things out but we have to
keep our eye on the goal which is
problem solving a problem in the real
world and not a problem in soft
and to do that we probably need objects
and functions and maybe actors and maybe
even peanut butter sandwiches so you
know the problem with falling in love
with our tools is that we risk mistaken
them for reality so you know in the real
world we have a problem we want to solve
like I want to make a phone call from my
car and we decide for whatever reason
wise or not that the easiest way to
solve that problem is discern to turn it
into a software problem
so we transform our problem into a set
of inputs seen by a program and a set of
desired outputs that correspond to our
goal and then we write a program that
turns the inputs into the outputs and
we're done right well hopefully we're
done now you all recognize this diagram
right so there's some process by which
we transform a real-world problem into a
set of abstract software requirements so
that we can solve our problem in the
more tractable domain of software so
let's call this mapping F and I think
the big mistake that we all make is that
we take it as an article of faith that F
is a homomorphism and you know that it
preserves all the interesting structural
properties the problem that we're trying
to solve so all we have to do is take
our problem transform it into the
abstract software space solve it over
there transform it back problem solved
the more that there's a mismatch between
our chosen everything as an X and the
real problem that we're solving the more
likely we'll end up with you know
something that ticks all the boxes on
the the marketing requirements sheet but
doesn't actually solve the problem now
as programmers you know we're
comfortable writing programs were a
little bit less comfortable working in
the real world it's it's actually kind
of easy to forget that we're working in
a synthetic domain and we confuse
writing the program for solving the
problem this is something that we should
watch out for in our more arrogant
moments we might describe what we do as
building abstractions for a living but
abstraction is a double-edged sword if
you look it up in the dictionary we find
lots of definitions some of which are a
little bit humbling abstract could mean
reduced to an idealized form to separate
away all the confounding details to
reveal the essence of something and
that's certainly the kind of abstraction
that we all want to be associated with
but it also means
difficult to understand and I'm sure
we've all seen the second meaning when
we look at other people's code right
but even you know the first meaning is a
little bit suspect different details
matter at different times when you're
trying to solve real problems so by
necessity the abstractions we use in
programming must be leaky and and this
is a kind of depressing fact to have to
have to admit so we know we use
abstraction because we hope it's going
to help us manage complexity and support
reuse whether it be behavioral
abstraction or data abstraction or
representational abstraction but
abstraction isn't an end unto itself
it's a tool for solving problems and we
need to be able to continually revisit
whether our abstractions are really
serving the user or whether they're
merely serving us remember the user
doesn't care about our abstractions they
just want their car to talk to their
phone okay so I'm sure it comes as no
surprise by now that I kind of like
object-oriented programming and I like
functional programming and I'm okay with
that and it took me a while to get there
because well all the tribal noise you
know for a while I started to wonder if
so many folks are moving on from
object-oriented programming to
functional programming and I still like
object-oriented programming what might
that say about me well I hope it's not
this but you know I think the real
explanation is that my experience of
programming is different from that of
many developers um most of the code I
write these days is platform libraries
and I was very gratified to see a number
of examples of people using platform
libraries that I'd written on the slides
and the talks this morning so but you
know if you're writing platform
libraries you're on the other side of a
boundary for most of your users and you
know that changes the story and in fact
you're like on the other side of a lot
of boundaries maintenance boundaries
versioning boundaries encapsulation
boundaries compilation boundaries
compatibility boundaries security
boundaries you know you can't count on
your library class as being co-evolved
or co compiled with its clients or its
subclasses because there are different
maintenance domains you know and and the
only contract you have interface
contract you have the binary one you
expect to be able to separately version
libraries and cly
not only do you take the opportunity to
hide your internals for a
maintainability perspective but
sometimes you actually have to do this
to prevent users from attacking the
integrity of the platform or subverting
security constraints you know so this
all works really nicely you know in a
dynamically length platform like Java
we're so used to this we don't even
notice right you know assuming you
evolve your libraries in a reasonable
way you just drop a new jar on the class
path and away you go and nothing has to
be recompiled that's really cool well
object-oriented languages make this easy
you know they provide tools for
precisely defining navigating and
defending these boundaries and so we're
oh oh really shines is at enlarged code
bases where programs span multiple
boundaries encapsulation boundaries
security compilation compatibility and
version boundaries these boundaries help
us manage complexity by limiting the
scope of analysis required to a small
region of code if my clients were to
tightly bind to my data representation
right if they were just the elect to be
able to reach into an object grab my
data representation out then an ordered
verify a program is correct or to change
my representation I have to audit or
change my entire code base if
representation is encapsulated I only
have to audit a small region of code so
obviously this is a big deal for
security it's also a big deal for
correctness as algorithms get
complicated so I've taken an algorithm
like concurrent the hash map right
everybody who uses anything on the JVM
is using concurrent hash map either
directly or indirectly or the fork/join
pool schedule right these are really
really tricky bits of code and the
representational invariants are really
really subtle and even ignoring
mutations I know some of you were
thinking if you didn't hit 8 you
wouldn't have this problem the
invariants are so subtle that you don't
even know how to interpret the state so
it's really good thing that the clients
don't have to in fact can't try to
reason about the meaning of the
representation they just work through
the interface so you know some people
might respond ok I'm just writing an
application I'm not writing a library so
well how does this help me write this
just gets in my way well the benefit
here is more indirect but it isn't any
less real as we evolve you know as we
evolved the Java language then one of
the things that we we consider one
most important considerations we apply
in considering any given language change
is will this change enable expressive
new library idioms right that you know
for me the central point of language
design is encouraging expressive
libraries because libraries have way
more leverage than language there's
millions of people out there that can
write letter libraries there are many
fewer can write compilers if you make it
easy to develop and distribute great
libraries you get a rich library
ecosystem which means application
developers have a variety of libraries
that they can choose from and leverage
and not just application writers
language implementers - right where
would Scala be you know without a you
know you know concurrent hash map or you
know where would okapi without the fork
join pool you know scheduler write that
because you can just use these libraries
as they are you know you can build you
you can build really useful things on
top of it without having to worry about
it so this benefits everybody it
benefits the whole ecosystem okay so -
speaking of boundaries I highly
recommend a talk by Gary Bernhard called
appropriately enough boundaries in this
talk he outlines a style he calls
functional core imperative shell and his
argument is that within a closed domain
functional is you know are ideal you
know you get great testability and
composability you know from value-based
data and pure functions and within the
domain we don't have we don't need those
boundaries we don't have a need for
compilation' boundaries or encapsulation
boundaries or versioning boundaries
because all the codes maintained by one
team it's all compiled every time you
know you run the thing those boundaries
aren't serving you but as you approach
the parts of the system that have to
deal with messy things like State and
i/o and failure the strengths of objects
start to dominate so this is a kind of
diagram he describes it as we're little
circles in the middle are functional
entities and you know the shell
intermediates between the domain model
and the messy real world and deals with
the nastiness of state and IO and
failure and the considerations of the
boundary are completely different than
those inside the capsule inside the
capsule you control all the code it's
recompile together it's maintained by
the same people but you know across
boundaries you have to think about
copying and separate compilation and
versioning and security checks and
migration compatibility so sometimes the
shell is a class in our program that we
wrote sometimes it's built into the
runtime so this diagram could describe
an airline actor right where the shell
is the Erlang runtime that deals with
the nasty mutability of a message
queueing and within the actor code which
is like all the code you see everything
is nice and clean and functional all the
Nesi stateful stuff has been pushed into
the runtime so it's easy to think of
Erlang as being purely functional
because you can't see the messy stateful
imperative stuff but it's there and it's
imperative so Airlines actors are really
a lot more like the classical objects I
was talking about earlier they're much
more like Ches objects than those we
find in Java or C++
um microservices are really the same
thing right you know within the service
doesn't matter what's going on
functional idioms work really nicely at
the boundaries they have to deal with IO
and state and failure which is anything
but functional and they behave a lot
like classical objects too and so it's
kind of amazing to me that in our desire
to move past objects and everybody seems
to want to move past objects we end up
reinventing them over and over again
just giving them different names so a
small program could run like as a single
instance of the shell but as our
programs grow it might make more sense
to represent it as a network of
cooperating shells rather than a single
monolithic one and you know this again
looks like every airline program ever
written right and in designing systems
the really important architectural
question is where do we put those
boundaries or to put it another way what
are my objects and I don't mean like
low-level implementation classes you
know in Java or C sharp I mean the
classical objects the independent
entities that communicate with each
other by sending messages so this is
another aspect of what I mean by rising
above both object orientation and
functional programming we can use them
at different granularities
we can use all modeling to find the
right places in our application to put
boundaries and use functional techniques
within the core and you know one of the
big complaints about oo is we have so
many boundaries where they're not needed
but one of the things all has to teach
us men has to teach the FP world is
sometimes
injuries in between you and yourself can
be really helpful can be really one of
the best tools we have for containing
complexity so you know while some
members of the FP tribe like to tell
themselves that FP is an evolutionary
advance overall in kind of a funny way
the trend towards FP is also a step
backwards along the same progression so
again think of the conditions under
which lower rows right the whole in
those days the whole world was
procedural we had no language support
for encapsulation or dynamic dispatch
although we could simulate them with
discipline and function pointers right
but inevitably the same thing always
happened clients would bind too tightly
to our data representation and this
ultimately limited how much your program
could scale FP offers us much much
better tools for behavioral abstraction
and reuse but when it comes to data
representation it's a step back into the
procedural worlds where any client can
access any data which means everybody is
tightly bound to everybody's
representation and that's going to limit
the scale of our programs so I want to
get the best of both worlds right and we
can get there once we let go of that
toxic tribal worldview that says one
must be strictly better or more powerful
than the other so FP models programs as
transforms of their input right it
excels when all you're doing is dealing
with data inside the functional core
it's all just data and that data all
lives on the same side of the boundary
of all the boundaries similarly because
ovale focuses on modeling active
entities it excels in system components
that have to mediate between the program
and the messy real world so you know
like the imperative shell in Gary's
example and so the reason it's possible
to rise above them both is that they
offer complimentary tools for managing
different kinds of complexity and we can
apply a combination that might be more
effective than either by itself another
kind of more accidental and cultural way
in which the trend towards FB is also a
bit of a step backwards is how it
acknowledges real world complexity so
Brian Marek I was writing a nice little
book about cold functional programming
for the outsider and in it he observes
that in general if you read what people
write about functional programming
languages
they tend to leave off the messy
real-world problems outside of their
documentation and examples whereas in a
lot of writing about all languages they
embrace the complexity of the real world
and they show here's how oo contain can
contain this kind of complexity so if
you read tutorials on object-oriented
program and you might actually come away
with an understanding of how you might
be able to apply it to like this crazy
payroll system you're working on that's
distorted by arbitrary tax law
differences between nine different
jurisdictions and the you know the weird
union negotiation and compromise that
was brokered 30 years ago if you read
tutorials on functional programming that
usually like leaves stuff like that as
an exercise for the reader so I think
one of the dangers in falling in love
with FP is it makes us want to believe
we can make the real world as neat and
tidy as mathematics and you know FP is
wonderful but the real world is not as
neat and tidy as mathematics it just
isn't so we need to rise above the
desire for things to be cleaner and
simpler than they really are
and then engage the complexity head-on
with all the best tools that we have and
complexity is definitely the name of the
game right you know we're awash in a sea
of complexity both inherent and
accidental and you know the central goal
of programming language design should be
providing us with good tools for
managing complexity and that there are
so many languages out there
it illustrates that while a we're not
there yet and the complexity comes in a
lot of different shapes and sizes and no
one tool is going to be perfect
containing at all it's almost inevitable
that we're operating at the limits of
our ability to manage complexity you
know when a better technology comes
along and it allows us to build bigger
systems without being overwhelmed by the
complexity what do we do well first
thing we do is we rebuild our world in
the new image right hoping that it's
going to take us back to a lower
complexity level and then what do we do
next we make the system bigger right we
keep making the system bigger and more
powerful until again we hit the
threshold at which we're barely able to
contain the complexity Martin you know
alluded to this in his keynote or this
morning where he's talking about the
cake pattern where like people were all
very on early
I'm very optimistic about the cake
pattern and its expressiveness until we
asked more and more of it and then we
ended up calling it the bakery of doom
right that this this is just how this is
just how it works right and I don't
think it can be any other way right the
economic factors are always pushing us
to building bigger and more powerful
systems so it's basically one trick that
we have for managing complexity and he
has different names you could call it
divide and conquer you know take a
complex problem and split it into
simpler problems and solve those you
could call it composition which is the
same thing only bottom-up compose a
solution to a big problem by solving
small problems same thing whatever you
call it and in our list of everything
that our list of things that everything
isn't they all claim composition is
their secret weapon and it's not an
accident right it's the only tool we've
got functions compose object compose
actors compose all right no one paradigm
owns composition right any more than one
paradigm owns garbage collection right
so Oh an F P are both devoted guiding us
towards this divide and conquer approach
just from different directions and at
different granularities
you know so oo offers us encapsulation
boundaries which reduce global analysis
down to local ones FP encourages us to
work with immutable values and pure
functions so that behavior can be
uniformly composed you know from simpler
building blocks into reliable larger
entities would oo does for us works
better with composition in the large
what FP offers us works better with
composition in the small ooohs
composition often gets in the way when
you try to apply it in the small FPS
composition gets in the way because
you're you inevitably end up binding too
tightly to data representations and
that's going to put a limit on the scale
of your program so you know this false
dichotomy of FP vs. imperative is often
compared to a different false dichotomy
which is should programming the more
like math or like physics and you know
as a mathematician I love this comic I'm
sure you've all seen it I love it
because it feeds my sense of
confirmation bias right I chose the
right discipline to study in university
and I suspect a lot of functional
programmers you know feel the same way
but the reality is it's very easy to be
seduced by the mathematics
and lose sight of the fact that we are
actually always running on a physical
machine and that that actually matters
most of the time pure FP kind of
disavows any notion of resources like
memory or threads or file channels which
means that resource management is the
responsibility of the runtime now often
this is a good thing right because that
you as the programmer get to focus
entirely on the business problem without
being distracted by the bookkeeping but
sometimes it doesn't give us the
resource efficiency we need to solve our
problems in an economically feasible way
imperative languages come at this from
the other end of the spectrum they start
with the physics and work towards the
math and this gives us finer control but
at a cost right um and you know I think
the whole focus on immutability is a
little bit of a red herring right
mutability is great for some things and
it's not great for other things and it
doesn't exist in other demands right at
the hardware everything is mutable right
so the immutability is just an illusion
that we pull ourselves we you know we
pull on ourselves to try to help us
reason about the problem so it's great
for modeling business data it's
considerably less great down at the data
structure level most data structures are
concerned with resource management with
you know in functional languages don't
offer us a lot of help with that so
almost all classical data structures use
mutability because it allows much
cheaper you know reuse then destroy and
create this and you know without
immutability we'd give up on cheap cheap
updatable half hash tables which is like
the only trick we have for turning Oh
event problems into o of one problems so
you know don't get me wrong
purely functional data structures are
really really cool but they're also a
little bit of a dancing bear right you
know it's impressive not because the
banth
the bear dances so well but that the
bear dances at all so thinking that like
programming is just math ignores the
resource considerations thinking it's
just physics ignores computational
abstractions so you could look at this
you know as glass half full glass half
empty I like to look at it as glass half
full
right we get to play in this whole space
over here right and we should be happy
about that because we need both and we
should be comfortable in this whole
space and not hide off to one side
because the light is better over there
okay so I'm almost at the end and you're
probably still wondering why did I call
this talk if P is dead long live FP and
and that is because I think FP languages
pure FP languages are going to have a
hard time competing with broad spectrum
languages that let you choose where in
the balance between these multiple
paradigms you want to live but that
doesn't mean we have to stop doing
functional programming far from it it
just means that we can't rely on the
language to force us to do it we have to
make our own deliberate choices about
how we want a program single paradigm
languages force us to wedge everything
in the paradigm whether it sets or not
and the reality is most languages are
built on top of something else and
sometimes you have to drop down instead
something else to write your core
libraries you know you can't write our
lines message dispatch inner line you
can't write the i/o monad in Haskell you
can't even write socket inputstream and
Java and language implementers are
always willing to throw themselves on
that grenade for their users right like
our JVM guys like to say we write in C++
so you don't have to but you know when
users feel like they have to drop down
into the substrate language that's
usually not so good and narrow-spectrum
languages give us a bad choice either
split our program across multiple
programming models with a terrible
barrier in between them or do without
the things you can't do in a successful
broad spectrum language you can write
both your platform and your application
without having to cross the barrier and
it's really a powerful thing that we can
write high-performance data structures
like concurrent hash map and pure Java
this means among other things well we're
going to get more of those libraries
that's a good thing um users with
specialized needs can jump grab that
code and customize it if they can
understand it and abstractions like akka
can just use it right um you know and as
time marches forward you know languages
that were traditionally object-oriented
languages like Java and c-sharp are
learning tricks from functional
languages it's like you know
immutability and lambdas and co-routines
and pattern matching and despite the
history these techniques have nothing to
do at all with functional programming
they're just good ideas that fit into a
lot of different kinds of languages guys
steal recently did keynote at julia khan
called lessons learned from fortress
which i recommend every
and in it he makes the point that it's
the good ideas that we want to focus on
and they survive by hopping from
language to language and the language
that develops the good idea may not be
the one that popularizes it right it may
very well be one of the worse is better
languages and you know that's okay so it
doesn't really matter what language
you're working in nobody can stop you
from doing functional programming up
here and in fact the best platform for
functional programming probably is your
brain so summing up we all have so much
to learn and the problems we're trying
to solve are so messy we can't afford to
ignore anything you know that we can
learn from any programming paradigm we
can't afford to lock ourselves into a
single paradigm just because we like it
better so we need to learn from
functional programming we need to learn
from object orientation and for
procedural to you know for that matter
and we need to rise above them all so
don't be a functional programmer be a
better programmer thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>