<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cristina Cifuentes - Are We Ready for Secure Languages? - Curry On | Coder Coacher - Coaching Coders</title><meta content="Cristina Cifuentes - Are We Ready for Secure Languages? - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cristina Cifuentes - Are We Ready for Secure Languages? - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-fC975HLhyc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's a slight discrepancy between the
printed and website a coupe schedules
versus the Korean schedules so the carry
on schedules show this as being are we
ready for secure languages just making
sure everybody's in the right room go
are the right places so okay great
sounds perfect
okay are we ready for secure languages
i'm cristina fuentes from oracle labs
and before i give this talk i have to
tell you that everything that i've
mentioned today here it's just ideas
okay and they're mine so for the past
nine years I've been working on static
code analysis tools being able to scale
up analysis right over millions of lines
of code and be able to deploy all of
this analysis internally now this
thought is really a reflection of the
type of vulnerability spots that we've
been seeing in the code bases for the
past nine years all of you are familiar
with the heartbleed bug and at the core
of it what did we have a buffer overflow
many of you are familiar with this very
old cartoon SQL injections today it
still happens but it's not just only SQL
injections it's all sorts of different
type of injection attacks we also have a
lot of permissions privileges and access
control type of issues happening in our
code bases and there's one new trend
that has been happening in the past few
years and this one relates to
cryptography and this code here
sometimes is almost like the code that
you find in some production system okay
so the reality is that for the past
three years looking at the data that
comes from the national vulnerability
database you find that there have been
2477 buffer overflows over three years
right if you think about that number
that's quite large
and so we have in the order of more than
two buffer overflows being reported as a
vulnerability on a daily basis for the
past three years you look at cross-site
scripting attacks there have been 2230
in the past three years again in the
order of two per day a thousand 793
access control type of issues so now
we're in the order of one point six per
day and cryptography because this one's
new this one didn't used to happen ten
five years ago and in the past three
years it has grown quite a bit and now
we have 1769 vulnerabilities in the
cryptographic area and when you think
about cryptography when what you were
taught at university they were telling
you very simple things like don't use
hard for the passwords right and back
then when I study the word teaching us
about the best algorithm and we all know
that this algorithm is not secure these
days right when you go and look at the
national vulnerability database when
it's the root cause of some of these
cryptographic issues you find hard-coded
passwords you find use of deprecated
algorithms today you have new code that
is being developed making use of md5 and
the developers that are writing the code
don't actually know that that's not a
safe algorithm to use you have use of
wrong befalls you for hard-coded see it
and so on and I like this last one on a
cloud platform having valid users and
host security keys being left on the
image that gets deployed on the cloud
layer this will come from the national
vulnerability database and nothing from
our internal code bases okay and so the
point is that a lot of this
vulnerability
that are happening but her overflows SQL
injections cross-site scripting they're
well-known they have been well known for
more than 25 years right buffer
overflows has been exploited since 1988
with the Morris worm and you're like
that was more than 25 years ago why is
it that we still have so many buffer
overflows being exploited
you have cross-site scripting SQL
injection attacks that happened in the
world in the nine late 1990s and they
were pretty well documented in the
literature and still today these are the
two most common type of injection
attacks so I'm focusing on these four
different types of vulnerabilities
because when you look at the data from
the national vulnerability database you
find that they're the top four
vulnerabilities that we're seeing in
today's software as reported for their
abilities okay we're not talking about
all the other ones that don't get
reported so you start thinking why is
this possible
how is this happening and if we look at
the first three vulnerabilities
cryptographic issues are a little bit
different because from the flavor of the
examples that I gave you it's clearly
something that is happening because
people don't seem to be very familiar
with the use of cryptography however
when you look at the general data and
you start looking at twenty years ago 20
years ago there were only 25 of their
abilities reported in the whole year and
now last year we have over 6,000
vulnerabilities reported and these are
only the reported ones but also when you
have a vulnerability that is reported
it's being exploited in many different
places right so it's not a one-to-one
mapping we have want to end places where
they get exploited and even worse not
everyone upgrades their software so on a
year by year basis vulnerabilities that
happened in earlier years are still
being exploited today
and these vulnerabilities are happening
in today's common languages right happen
in Java C C++ Python JavaScript you name
it they're affecting all the software
that we're making use of so for the runs
on your web browser the inter that gets
stored into your database your mobile
phones critical infrastructure
throughout the world as we saw with open
SSL but also the cloud infrastructures
and when you try and think about the
economic effect that this is having
happening you end up with data like this
one where the average cost of a data
breach is four million dollars but using
an average of 10,000 records being
stolen and that just gives you an idea
that's only one particular data breach
right so think of it as one
vulnerability one exploit one of the N
exploits that happened because one
vulnerability okay in the code and so
now we start thinking about why is this
happening right we have this big
difference between how hackers think
because they're looking for those
security bugs and the way that
developers thing whereby you're always
looking into what are the new features
that you are developing in the software
and the reality is that when hackers
look at the code they're always looking
at the code from the point of view how
do I break into this system whereas when
we Bela press write all of the new code
they're looking into the functionality
where the requirements was that I need
to implement and as the veil appears we
have never gained an intuition as to how
how to hacker on systems and I've seen
this several times where an epoch
hacking team comes and reports on new
features in a particular system and the
developer that implemented some of those
new features stands up and says I
implemented that feature it's correct
according to the requirements and the
ethical hacker says yes but I'm telling
you how we will exploit it how anyone
else would exploit it right and so this
this lack of intuition really happening
but it's because of how we think about
bugs and peaches now when you talk to
ethical hacking teams have you seen you
know and you ask them what example
attack techniques what do you do for
these four different areas with buffer
errors this is a variety of different
ways of how to exploit buffer overflows
and they're pretty well documented to
the point that this day there's even
automated tools to generate some of this
expert for injections you find that
normally they're going to look for
missing sanitization that ought to be
happening in the codebase well they're
going to look for validation
sanitization that are making use of the
wrong context right like sanitizing is
filled with HTML or sanitizing
javascript with HTML and vice-versa
right for access control type of issues
you're normally looking for those
permissions are they're missing
permission checks in place and you're
also looking for incorrect checks right
like if you're talking about database
code you may be looking for is the
administrator logged in instead of is
the user logged in right in the code
right and then for cryptographic issues
when I went to ask them what is
happening in that area they say well we
just look for like the most basic type
of things weak defaults use of which
defaults
weaknesses in protocols use of
deprecated algorithms right so the
threshold is very very low like from
their point of view and they can always
find a lot of issues in the system so
then why is this happening so when we
think about like the three top three
type of vulnerabilities for Harris
injections and access control
abstracting these issues we basically
end up with user input
hence untrusted input accessing a
security sensitive access in your code
right so in the case of a buffer
overflow let's say in a multi-tenant
system if the overflow is going to end
the corrupt ins of memory so you're
going to access the authority but you're
going to end up accessing memory from
let's say a different tenant
that's a big issue that's a security
concern right no one wants like their
data to be accessed by a different
system same with injections same with
access control right and the reality is
that whenever you have untrusted input
you need to sanitize your inputs right
but the main problem that we're seeing
is that sanitization is left to the
developer if the developer's
responsibility to actually do something
about sanitization because most
languages do not provide sanitization
support in the language so then you as a
developer need to ensure that you add
the right sanitization and that you are
aware of the fact that you need to
sanitize the data along all paths to any
possible security sensitive access in
the program okay and you start thinking
about solutions what about education
right the reality is that many
programming languages subjects they
don't cover security as part of the
subject
and there are very few universities
where they offer a programming language
security course at the undergraduate
level we need to be training at the
undergraduate level not only at the
postgraduate level in terms of security
and so hence this leads to companies
having to have their own training on
programming language security so that
developers become more aware of the
vulnerabilities that are happening in
the code so that they don't have those
type of errors but overall given the
type of vulnerabilities that people are
exploring today it's clear that
education is not working and that leads
you to think is there a problem with the
cognitive load
that we're introducing in our
programming languages right why is that
buffer overflows are still happening
people don't get it with pointers that's
a reality right some people do but the
majority don't we look at other
solutions I mean I've been working in
this area paracord analysis solution and
you think like what a static code
analysis tool is doing is free doing
half of what the part a compiler is
doing right you're reporting you're
doing your encoding of the semantics
you're creating another intermediate
presentation and then you're actually
doing the analysis right and your
analysis is going to be an over
approximation or under approximation of
the program hence you end up with false
positives or false negatives in whatever
your report you always end up also with
a high rate of true positives depending
on your analysis but then we all know
that a static code analysis tool is
going to provide you with an incomplete
solution it's never going to be able to
find all of the parts and panera
bilities that exist in your code base
right so we look at two other solutions
dynamic solutions with dynamic analysis
tools you're always going to be covering
the particular paths that are being run
for a particular data set and
as you're going to do incomplete
solution as well only those putts are
the ones that are being exercised and
fastest solution is going to try and
generate for you automatically data
inputs that are going to crash your
program so superb but again it's like
incomplete solution it's only along the
paths that we're traversing and with
verification solutions they have
improved quite a bit in the past years
right you have more to check in theory
improving however they don't scale to
the size of large code bases industrial
code bases that are being used in
today's world right so then you really
start thinking you have had solutions
like static code analysis tools that can
find a lot of these type of bugs and
security issues in the code why is it
that we're not integrating these
concepts into our programming languages
you could integrate into the compiler
that's one way but you could also use a
different approach and is integrate into
your design of your next programming
language how to solve some of these
issues addict lee so that they develop
ratos and have to even worry about them
here's an awesome language right that
has actually started thinking about how
do we get rid of these buffer errors
statically and what I like the most is
they're trying to provide all of these
memories they figure and piece by the
fact of introducing two new concepts
right so you as a developer need to know
two new concepts but you're going going
to get memory safety guarantees which is
so much better than compared to
languages like C okay so you have the
concept of ownership or why you're going
to own this pointer and you have the
concept of boring whereby you're going
to land this particular value for a
limited period of time but it's still
being owned by someone else right and
you're going to ensure that with
borrowing you don't have shared forum in
here
hence aliases and mutable boring
happening at the same time okay so two
new concepts you get used to them and
then you start coding in these languages
and you can write even like our rich
collectors like Steve Blackburn and Tony
husking have done at Anu and it's well
performing memory say it's also that
erase free by design in this language
right and it performs really well so
superb you know here's like one way of
thinking about how to start changing the
way that the land which is designed so
that the developers have better
constructs to be able to do their work
but we also know that we could design
some of these languages with solutions
that are provided to you dynamically
right or that we could extend some of
the languages so here's an example of a
proposal on how to extend the C language
to be able to deal with getting rid of
buffer overflows right so this is work
by David DP is version 0.5 at the moment
it's a a proposal the plan is to
integrate it into a version of tank but
the idea here is that you can extend the
C language with bounds checking and they
proposed three different types of
pointers okay so now you're going to
have the PTR which is a point that I do
with use when you're not doing pointer
arithmetic you're going to have a repeat
here which is used when you're doing
pointer arithmetic and this can be
tracked statically right and you're
going to have span which is a pointer
that is going to keep track of the
bounds carry it with the pointer itself
and it's going to be checked anomaly
right but you can see also in this
proposal that there's a lot of other
extensions that are being proposed right
as well as some dynamic checks for those
cases that do not feed into these three
new type of pointers right and there's
where you would start to have to think
about cognitive load okay
what is going to be simpler for the
developer right a solution that has two
new type of pointers like concepts a
solution where the developer has to
really start keeping track of a lot more
data okay now how have a lot of them
manage languages built up with Parker
errors and a lot of this other memory
related type of issues well they're
doing this through garbage collection a
concept that was first introduced in the
list language concept that has really
been embraced by the programming
language community right a lot of
object-oriented languages functional
languages dynamic languages are widely
using this technique right however this
technique doesn't always work well when
you have code that needs to be a very
low level right when you need systems
little code bases people that really
care about performance also in the
embedded systems they start making the
trade-offs well I can't afford managed
language I need some other type of
solution right so some of these
solutions need to vary depending on the
type of application that you're trying
to target
now what about injection attacks in perl
3 there was the introduction of the
paint mode and with paint mode this was
the first language that actually did
something about less track all of these
user inputs they're tainted inputs
let's track them and actually let the
application know about it and they use
two different modes there's one more
word pie everything is done
automatically for you when you have like
a different UID and the group ID that is
running the process then when they're
different automatically will track it
for you but you can also turn it on
let's say that you're going to run a
server application you can turn around
with the - T option and it's going to
track where you take the data very good
concept it works well in practice hasn't
been yet been introduced to Perl 6
but you know one of the only languages
that has actually looked into how to
look at injection attacks right and ruby
has been like t one other language that
has picked up this idea now what about
access control type of support in our
languages I know there's a variety of
different types of access control and
I'm going to focus more from the point
of view of the Java vulnerabilities
because I'm very familiar with these
ones we've been working in this area for
the past three years what was the root
cause of a lot of the serie de attacks
that happened in the late 20 2012 early
2013 you would remember lots of
exploitation against the Java platform
serie de attacks happening almost like
on a weekly basis and the reality was
when you started looking into the issues
what were the issues they were all
access control type of issues so they
related to the fact that you need to
have permissions you need to have
sanitization and you're accessing
privilege code and in the case of a
system like the JDK you have clear
sensitive methods you also have to
privilege code and a lot of these issues
there's religious getting to those
security sensitive type of methods in
such a way that even though the goal of
the language the Java language was to be
able to safely run untrusted code in the
form of applets all of these attacks
were being able to get out of the
sandbox right and they were being able
to run with high privilege and then do
whatever they wanted you know with the
rest of the code now the security model
was introduced a long long time ago
nineteen
this was introduced in Java 1.2 and the
model you know subscribe to the
principle of least privilege right and
what they do in the Java our security
model is that there is the concept of
the security manager the security
manager is always going to do all of the
checks that relate to access control but
in essence what they're checking what
they have implemented is a spec based
model and they're going to check every
single invocation frame to determine if
all of the frames have the same
permission when you're wanting to access
a piece of code that is security
sensitive okay
now the idea was very noble but then
given the amount of extras that have
happened like there needs to be changes
right in the system now here's a
different way that you can either access
control and this is work by Mark Millar
and the caja plugin for JavaScript I
mean again super type of idea and it's
how to integrate it into an existing
language javascript a language that is
not providing this type of guarantees
for you right and so what are the goals
like the goals here in this case is to
extend and also limit the JavaScript
language to be able to safely embed
untrusted content and trusted
applications running on a web browser
right and he has lots of demos you can
go and run them and so on but it's
exactly the same type of idea that the
Java system wanted to have through the
use of applets right now the
implementation here is very different
the implementation that Mark is using is
that of object capabilities and with his
object capabilities what he's done is
that he's created like this capability
secure version of JavaScript that is
called SES and then he also has a way of
having a safe Dom wrapper as well as
having CSS and HTML sanitizers and so
the combined package gives you all of
these access controls
any of the vulnerabilities that have
been reported against kaha have not
related to access control they have they
have been a few but they've related to
there was a wrong implementation here
and there in terms of how the compiler
was getting rid of dead code right so
superb idea before we ever have to think
about access control seems to be working
really well and mark is proposing these
two to the JavaScript committee okay now
in terms of cryptography okay that's the
new kid on the block right a lot of
these vulnerabilities that are happening
happening purely through use of
cryptographic api's and many languages
provide access to cryptographic API is
these days Java was perhaps one of the
first languages that introduced this
concept right through the cryptographic
architecture back in Java 1.1 and it's
basically providing a framework for
cryptography for you you're able to have
AP is for encryption for key generation
for management of your keys and so on
right and then a lot of the new
languages are also providing their own
cryptographic API support right why
because it's clearly needed in today's
distributed computing world in today's
cloud world right now if you think back
at the examples that I gave you of the
type of cryptographic issues that are
being exploited
you really have to conclude that the
cryptographic api's that we're making
available today a too low level for the
common developer to be able to
understand how to use them so it's the
analogy to pointers are too low level
for many developers to be able to use
them correctly we need to have better
abstractions to be able to have better
security in the
cryptographic area all of the issues
were through bad use of existing
cryptographic API okay
these days the type of errors that you
see in the cryptography area are not
because you as a developer decided that
you could develop a better cryptographic
algorithm not that's not happening
anymore
it's because we're using crypto api's
incorrectly okay so you could put all of
that together we basically end up with
these four different bubbles and I've
removed the Java language is to focus on
the newer languages here okay and with
this newer languages what you see is a
cluster right in that there's a lot of
emphasis that has been put into the
memory safety area through static
dynamic type of techniques or proposals
for extensions to the C language you
have languages like Perl that they have
focus on the memory safety as well as
how to get rid of this injection type of
attacks you have languages like Ruby
that have looked into injection they
have look into cryptography and because
I didn't build this diagram correctly
Ruby also is here in the memory safety
so they actually have looked into three
or four different areas that I'm talking
about today but what you do not see here
today is any language that is at the
core any language that is actually
capable of being able to focus on those
four different areas and provide
solutions to the developers so why did I
focus on these four different issues not
only because they're the top four but
also because when you look at the higher
level categories that are used in the
national vulnerability database their
categories relate to that are handling
security features for code quality and
pylons things
when you do the combination of buffers
injections access control and
cryptographic issues you find that 76%
of all of the issues that are happening
are really England those areas seventy
six percent of all of the issues all of
the vulnerabilities for the past three
years I purely view due to this four
different types of vulnerabilities
okay now this area here of poor code
quality it really relates to resource
management so things like use after free
and that was freeze but it also could be
like worker termination errors right
some languages to support that through
some parts of that through memory safety
and other languages don't write and this
one percent here time and state that
really relates to concurrency that
erases and due to limited time I cannot
actually go through some of the examples
but in the concurrency area they have
only been 149 vulnerabilities being
reported in the past four years but
there's been a lot of activity in that
area in recent years in terms of
programming languages you have go you
have Tony you have closure also looking
into all of these areas right
concurrency embracing concurrency at the
heart part of the future not a lot of
own abilities happening today
but maybe in the future more
vulnerabilities will be happening in
that area unless we start thinking of
different ways as to how we can provide
more concurrent safe type of languages
for developers to use on a day to day
basis
okay so what am I going to summarize in
terms of what is security in terms of
the programming languages if you can
provide safety in your languages either
by providing the safety in the language
itself or by providing through libraries
okay I argue that the more we can do in
the language the better because many
times some of the libraries are are an
afterthought that's so much better if we
can embed it into the language it's at
the core of it clearly we need to have
trade-offs in terms of performance the
static solutions dynamic solutions it
could be a combination of both and
there's a lot more access to this
depending on where you're going to use
your languages right there have been
fourteen thousand eight hundred and
forty-four vulnerabilities in the past
ten years think about that that's more
than ten per day a three tequilas high
number okay have any in our common
languages an education is lagging and so
it's clearly time to start including
security in our language design and of
course is going to be barriers to
adoption right performance is one of the
most common one that gets mentioned in
many communities but there's a lot of
usability type of issues as well that
need to be addressed we need to be
removing any cognitive overload we need
to make languages simpler so that every
single developer can use these languages
correctly we also need to be able to
look into usability of the tuning for
any new language right if we can
integrate solutions into familiar
tooling so much the better
right everyone will feel comfortable
they can actually make use of tooling
rather than new language I don't have a
good way of debugging this new language
and of course we also need to think
about how would we interface to legacy
language
because the really pissed a lot of
legacy code around the place so here's
some challenges first challenge can we
design a language but just eradicate
these four different types of
vulnerabilities buffer errors injection
attacks access control type of issues
and cryptographic issues here's another
challenge can we provide the context for
tainted data when you're crossing across
different layers so imagine you have an
application this application is a track
isn't it the data storing it in a
database some other piece of code later
on comes and uses this data from the
database how does it know it was tainted
what about high level cryptographic
api's and how do we define and design
this high level crypto API so that 20
years from now they're still in use
rather than we need to change them every
two or three years right and in general
how do we provide security guarantees in
our languages the reality is Ireland we
just do not provide security guarantees
so with eighteen point five million
developers writing code throughout the
world 40% of them being hobbies so not
everyone of course is going through a
computer science degree many people
because these languages they write code
they contribute towards everything that
is available in today's world we need to
ensure that security is not just for
experts anymore and we cannot keep calm
and carry on programming
it's time to make a change we need
security for the masses thank you hello
first of all thank you for the talk I
ended up in programming language design
after I read about how to exploit buffer
overflows in frack in the late 90s so
it's right in my area so a lot of the
points you brought up are right are
correct are very very good the fact that
we still see memory corruption issues is
a shame for the industry
totally but there's one note I'd like to
pick and that is with the injection
prevention so it is a common myth that
sanitizing your inputs helps against
injection attacks it does not because
you do not know at input time where the
data will end up at like Mr O'Hara
working for AT&amp;amp;T born on January 1st
1970 what do you want to send us there
do we want to tell his name no that that
can't work so we cannot sanitize inputs
you need to make sure that at output
time we correctly treating our data and
very important distinction many people
get that wrong and the output has a
context and we need to escape the
outputs depending on the context we are
outputting it and this is also why I
think that 10 striking won't help as
much because we need to assume that all
data comes from somewhere and we no
longer have batch processing we have
import processing output we have complex
systems that interact so 10 tracking it
was a good idea back then but I think we
need something else today and one idea
is to use type systems to prevent people
from just stuffing any old string in any
old output so you can use a type system
to force the user to call the right sort
of escaping function on a string to
and an injection attack I think that's
something that I would like to suggest
on top of your suggestions on where to
go with programming languages and what
you can also do is make it very very
hard for people to get it wrong example
is there are lots of templating
libraries for HTML some of them just
automatically escape by analyzing your
template by analyzing the grammar of the
file and just calling the right escaping
for you
this is what prevents injection checks
in such a cases nothing else ever will
that the programmer needs to do manually
and I'm very very glad that he brought
up the point we cannot train people to
do it right we need to ensure that it's
secure by default on the language and a
library thank you we need to be thinking
about other ways how to do it right like
you can even go like beyond the
programming language and you can start
thinking about like should the operating
system be tracking some of these could
we do some of it at the hardware level
right like if we have make one extra
bead if it worth while is it going to
work we don't know but we need to start
looking into all of these people ways of
doing things
hey thank you for the very nice talk I
agree that the languages should provide
more security guarantees I'm wondering
that what do you think in the meantime
we can do to train our students and
developers better to kind of bridge the
gap and so maybe finally we reach these
languages that have how can we improve
our education yeah I think I'd like for
students that are going through a
computer science degree what we normally
see is that security is not mentioned in
the undergraduate degree right it's not
measured from the point of view of
vulnerabilities there's like computer
security in general but not
vulnerabilities that may
happen in the country and so many
students don't actually have the concept
as to what are some of these
vulnerabilities
I think buffer overflows everyone is
familiar with that if they actually had
to write in the C or C++ language right
but beyond that many students don't have
an idea of these I mean like it's very
simple to integrate some of these
concepts into an undergraduate course
right so what you're saying is that the
first thing we need to proof is on a
bareness yeah I mean like when people go
to industry and they say like in several
companies to have their own training for
how to write code correctly and so on
you kind of wonder like what why so late
really they should already been coming
through industry actually knowing about
this about access control hi over here
about access control you're pretty
negative on the old Java stack frame
thing and pretty positive on secure
ActionScript and our capability is the
only answer here is there something else
what happens they are to the very
different ways of how to implement it
right and with the Java security model I
think we have seen a lot of issues
happening in that area in terms of its
access control support with these object
if ability model we're not seeing those
issues happening right of course like
the model hasn't been around for us long
and so on one could argue but if you
look at Java 9 Java 9 implements modules
right and whichever nine you have a
concept of how to implement capabilities
through the modules right and in
practice what we see is that that
actually makes a big difference in terms
of the vulnerabilities that
see in the code the question of the yeah
the question that was posed in the title
was actually not answered and so we need
security for the masses but I think we
are ready I gave you examples of
different languages that have looked at
different aspects of the problem from
different points of view right and with
a lot of these languages like you what I
found interesting was that they would
say and our language aims to be safe but
then safe for the language meant it's
going to memory safe or it's going to be
theta 3 safe or you're going to be
something safe but it was not like this
bigger picture of Satanists more
comprehensive Satanists right and I
think like we are ready we need to put
also more investment in terms of how to
do it like more comprehensively so that
we start seeing what is the end effect
right on usability for the developers do
you you see any problems like in
unlocking the golden middle of the
intersection Helen do you see any any
issues for example like implementation
wise or like usability wise for
unlocking the intersection in the
diagram that you showed for example all
these different kinds of safe yeah
implementation problem with it is going
to be more like what are there right
abstractions that we need to use so that
those abstractions are really easy for
developers to use rather than we're
going to get them to yet learn more and
more complicated concepts that are not
going to help right so I think like the
core is going to be what are the
abstractions that we need to be able to
have in our languages so that we end up
with everything at the core Thanks thank
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>