<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Michael Sperber - The Functional Programming Languages Nomad - Curry on | Coder Coacher - Coaching Coders</title><meta content="Michael Sperber - The Functional Programming Languages Nomad - Curry on - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Michael Sperber - The Functional Programming Languages Nomad - Curry on</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fd-92QqUdBU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome everybody is I guess
microphone is working you hear me okay
great it's gonna be hard for me to stay
close so yeah well you can see who I am
on this slide but today I better give a
little bit of context on my biography so
we can understand what I'm about to say
later I'll tell a couple of anecdotes if
the time doesn't work out I'll just
leave out an anecdote so you can just
ask questions at any time you like even
though this is not one of those chests
timer talks so feel free to interrupt
don't worry you know that the time is
not going to be enough so a long time
ago it feels it feels like a very long
time ago I was a researcher in
programming languages focusing in
functional programming and I think I'm
one of the few people who had papers at
the ml workshop the haskell workshop and
the scheme workshop so I'll talk a
little bit about the impact of using
different functional programming
languages and various projects today now
in 2003 year again a long time ago and I
became a freelance software developer
again for a couple of years obviously
coming from functional programming I
thought you know it was you know this
was big and research back in those days
but I thought it would be a great idea
to apply functional programming in
industry and I set out to do that and as
I was by myself during that time it was
it was kind of an uphill battle but
since 2000 and I became CTO of a little
software company in filters duct Germany
and so I'm gonna talk about some of the
experience from my time as a freelance
software developer and but primarily
about some of the recent projects that
we've done at that company so just a
couple weeks ago a piece of software for
a major auto mobile services provider
that every German who owns a car needs
to go to periodically and they have a
lot of work stations so people take the
cars through those workstations that
every workstation there is there's a
little closet and that closet used to
contain a stationary PC and a printer
and
analysis equipment for for cars and
other pieces of hardware and for some
reason or other of this company
transitioned to using mobile tablets
instead of having a stationary PC at
every workstation they would give every
employee a tablet and you know once they
sort of done the planning of that they
realized that it you know it's not gonna
be good enough to just give everybody
their tablet and everybody but he would
be happy but really you need to
reconfigure this tablet depending on
where it is so you know if some employee
takes their tablet from one workstation
to another or from one site to another
we're outside of a site to a customer
site you know and they press print or
whatever they don't want that printout
to come out at the printer where they
were they want the printout to come out
at the place where they are and the same
goes for various other pieces of
hardware some of it is USB Hardware a
Bluetooth hardware so what we needed so
we were commissioned to write software
that will reconfigure the tablet
according to where it was and we'll try
to fight find out where it was and then
and then make configuration adjustments
well the problem with that is that well
you know a lot of the time one of those
tab deals tablets would be connected to
Wi-Fi but a lot of the time it wouldn't
and still you wanted to know you wanted
to be able to do that reconfiguration so
you know one issue that came up
immediately is how we were going to
communicate to a tablet information
about the configuration of where it is
and we ended up saying well you know we
obviously can't go with a classic
you know client-server model here we
really need to communicate configuration
information between the tablets and you
know the easiest way to do that was
there wise synchronization so whenever
two tablets would meet they would be
able to exchange configuration
information and just send the
information that the other tablet
doesn't have to that other tablet and so
for example all the way it works now is
that if a tablet would enter a site it
would log into the Wi-Fi there and then
it would immediately know to send a
broadcast message to everyone else at
that site and saying well I'm new here
I need configuration information about
this site and then hopefully some other
tablet would say well I'm here I know
what's
and we too should hook up and
synchronize the configuration
information and now as I said you know
this network it has limited capacity
it's transient so you really need to get
things done quickly and you know over
time we've been surprised by how much
configuration information these people
are creat you really only want to
exchange the configuration blocks that
the other you know the other tablet
doesn't have yet right you don't want to
just send over the entire data base and
then have everybody figure out the union
of their blocks and the other blocks and
so figure out that a lot of the blocks
are going to be common asymptotically at
least you really just want to exchange
you want to then figure out what the
blocks are that you want to exchange and
then you just and you know this is a you
know we've seen people fail at this in
this environment but so we knew we
needed to maybe apply a little bit of
computer science to this problem and in
fact there's a great deal of wonderful
literature on synchronization problems
that gives you you know sets of criteria
that you can apply to your problem and
then that lets you choose an appropriate
method to to actually do it and we ended
up using those approaches are actually
based on something called a Merkel tree
and the way that works is here at the
bottom and what you do is each data blog
gets computed a hash code and you then
use some of the bits of the hash code to
compute a path and a tree right so and
as you go up in the tree and you have
internal nodes that you know that stand
for a subtree and in that subtree are a
bunch of blocks what you do is you
compute a composite hash of all the
blocks in that subtree and you do that
all the way up in the tree and the great
thing about Merkle trees is well the
hash code at the top right represents
all the blocks that you have on your
machine and if you synchronize you know
you can start by just talking about that
hash code at the top and if it's
identical on both machines you're
already done you know that the other
machine has everything
you have and vice versa and if it's not
the case you can don't go down the tree
and now you have two hash codes and
maybe one of them is gonna be the same
in which case you can eliminate that
subtree and the other one is not the
same in which case you go further down
the tree so you go down you kind of
waianae each step as your tree gets
wider and you also narrow as you
eliminate sub trees that you know the
other side already has so at each step
japanese people exchanging business
cards you send a message over and it in
synchronously as you get to the bottom
and then as the last step you've
narrowed things down to a specific set
of data blocks that you need to sit then
send to the other side and then you're
synchronized then you're synchronized
and you can go about your business and
and do configuration and that's worked
exceedingly well now on Windows and the
language of choice on Windows is f-sharp
these days so here's some of the actual
production code which was a very naive
approach to implementing this but which
worked out fine so a mirco tree is just
so I said some of the bits of the hash
code get used as the path in the tree
that's what we call a signature and of
course as you identify a subtree in the
miracle tree you have a prefix of the
state of that signature of all of those
signatures of all the blocks that are
down that subtree so a miracle tree just
consists of a signature prefix that
identifies the subtree and a list of
hashes of all the blocks in that subtree
and the signatures of all of those
blocks and then you know signature is
just a list of numbers and a signature
prefix is also just a list of numbers so
it's very very simple of course you
don't want to send the entire subtree
over you just want to send what we call
a fingerprint which is just the
signature prefix which identifies the
subtree and the hash code the composite
hash code of all the blocks and that
subtree and then you exchange messages
that look like this either on an
internal node you say well I have these
fingerprints to tell you about or you
say at the very bottom you say well I
know know what blocks you don't have
that I have so I'm going to communicate
them to you
and you know this being functional
programming you can write this in a
purely functional fashion in fact you
can do it without even explicitly
constructing the tree which is what we
did as a data structure and you get us
you know at the core you get a function
like this which does one round of this
synchronization which says well here's
all the hashes that are in the system
here's here's a set of Merkle trees that
I believe the other side doesn't have
yet at a certain level and there's a
message I'm getting from the other side
right and so I have something like you
know I suspect you know the other side
doesn't have something the message is
gonna tell me more about it and as a
result I either produce another message
to send to the other side and a new
Merkel tree set one level down or I'm
already at the bottom which is a list of
hashes to send to the other side right
and looking at the signature and knowing
the basics of this you already know what
it's gonna do and you have enough
knowledge to test it so you know one of
the great things about functional
programming is you don't have to worry
much about you know setup and teardown
methods and whatever what you need if
you're testing if you're writing unit
tests and imperative languages so you
can think any you know you can think you
can think up two blocks of two sets of
blocks and you can just run the
algorithm and then you can say well you
know afterwards you know every side
should have the same set of blocks so if
you union the blocks that you have with
the blocks that you get and also you can
test that you don't get any blocks
redundant lis from the other side and
that's what this code does and even if
you don't understand every detail you
can see sort of it works by a set
operations so it's not it's not a big
deal and now the next great sound note
so now you write unit tests which are
individual examples but David Nolan
already taught talk to you about this is
individual examples are often not enough
and as you're manipulating bits and hash
codes you can have subtle bugs so it's
better known as general properties
rather than individual examples and this
says well for any sets of blocks bs1 and
BS to the properties from the previous
slide should hold right and then you can
use quick check which you now know about
if you were at the keynote to generate
test cases or
matically and that flushed out one or
two subtle bugs in the algorithm now
first of all I'm not an I don't usually
I'm not very big on algorithms and we
figured everything else in the system
was going to be pretty simple right we
just need to reconfigure the printer or
the Bluetooth or whatever it was and so
I we figured that you know as we went
towards deployment we would have you
know that the area where we expected the
most problems were that complicated
algorithm and the pragmatic pragmatics
of running that algorithm in sort of an
hostile environment and much to our
pleasure using those you know quick
check generator tests this system has
now been in deployment its exhibited
zero bugs right and you know it's now
running on about 1,500 machines and you
know and these customers I haven't told
you about this but really if this piece
of software it doesn't work you know you
know they lose money like right there
you know if it doesn't work for five
minutes so these are customers that call
us you know there's a problem and before
we did deployment and we of course we
did a lot of testing before deployment
we did we had a lot of problems right we
had you know auto configuring printers
on you know on a Windows system is a
nightmare
mounting drives is there's three
different api's and and you know just
generally tracking a changing
environment or just getting the GUI in
sync with the internal state of the
system all of those cost caused problems
exceeding those that we had with the
synchronization and an embarrassing
amount you know a lot of these things
like you know a cost you know the
customer would call and say it didn't
work and then we changed the software
and embarrassingly often the answer is
something not working as we which is
wait for five seconds and try again and
then you know a lot of those problems go
away after five seconds for some reason
with mutable state right and in this
case a lot of that mutable state was
unavoidable except maybe for the gooey
stuff so but still it was a good lesson
to repeat for us is really that we could
shoot that we should keep the use of
mutable state to a minimum in our
software
so and we've learned that lesson many
many times and through many projects um
questions so far okay so because I'll
switch to a different project now which
is three when I was still a freelance
software developer and one of my first
clients was a very large at the time
very large German bank they're no longer
that large and they're longer German but
so and and they called me up in Toomer
surprise they said well we're doing so
they were doing financial derivatives
and they said we're doing financial
financial derivatives with the system
called scheme 48 you know you need to do
a lot of computation and as you have
complex financial derivatives
essentially the only way to evaluate
them at least at the time was to do
simulation and so they had a large
cluster of machines and they were
running distributed Montecarlo
integration and which was being
coordinated by a bunch of scheme 48 code
in just a few weeks ago I learned that
it's still there even though I haven't
worked for the bank for more than ten
years now that's surprising I mean it
didn't surprise me that they called me
because at the time I was the maintainer
of scheme 48 was a research system with
you know experimental in many ways and
and and somehow they decided that that
was the best thing for them so that's
just a side note though because you know
when when I eventually started working
for the bank the problems were much more
profane to deal with market data and you
all know that a lot of market data gets
generated by trading so you have spot
prices for a lot of things that get
traded directly on the market but as you
get to complex derivatives a lot of that
market data is derived from that sort of
primitive market data so you know in in
in derivatives we're generally in
finance you deal a lot with volatilities
volatility is a measure of how much
something changes so these are old
slides and as you deal with derivatives
you often don't deal with individual
entities that are being directly traded
but you deal with groups of them
so-called baskets or even you know your
usual or whatever Dow Jones Industrial
Index is a kind of bass
which is sort of a weighted sum of the
of the members of that basket so but the
thing is that a lot of those things a
lot of those baskets are usually not
traded directly so but you want to treat
them as one entity so you have to make
up market data for for those baskets and
and you can imagine that those baskets
you know you kind of have a tree where
there's primitive market data at the
bottom you know things computed from
that and the interior nodes and then
there's derived ultimately derived
quantities that you use in your software
at the top right and now you know the
trader is the people with the you know
the suspenders that you see on TV they
don't they don't just want to know about
their portfolio under current market
conditions they want to know what
happens to my portfolio if something
changes in the market so if some
individual call option goes up 1% but
that's off not very interesting because
that's gonna have a minuscule impact
want to know what happens when you shift
an entire volatilities what's calling
volatility surface which is a bunch of
those things grouped together or you
want to know what happens you know the
entire Dow Jones goes up or down what's
gonna happen to my portfolio or even the
entire market everything goes up or down
right and and for this stuff they were
using a bunch of object-oriented C++
code and the way that actual code the
way that worked is you would get you
would have a class called market data
there would be an instance hooked up to
various real-time feeds and you could
ask it what's the spot price of that
thing and that thing was identified by a
number called a sick of em don't don't
ask me why these strange types but this
is real production code right so you
know so you have market data that
corresponds to the actual real world
right and the traders wanted to know
market data that is just like that but a
little different right in an
object-oriented programming what you do
is when you want something that's the
same as something you already have well
you write a subclass and you override a
bunch of methods right now the traders
of course they didn't want to compile
their C++ program every time they wanted
a computer scenario so you need we
needed some dynamic solution and as an
object or in a programmer you open a
pattern
manual right right there it has a
decorator pattern which says well it's a
flexible alternative to sub classing for
extending functionality and that works
at runtime I don't want to spend too
much time on the details of that but a
decorator means that you subclass at
once and you put you put a delegate in
there and that decorator will call you
know we'll call the delegate for all
methods except one typically so for
example you would do it like this you
would say well how about this the entire
market shift so I'm just gonna override
the method forget spot
I'm gonna call get spot on the delegate
which is that F market data thing there
and I'm gonna multiply that by a certain
factor right and now unfortunately this
doesn't work quite as you expect because
for baskets were for things that are
composite entities right we know that
the spot of that basket gets computed
from the spot of the members of that
basket so there's a recursive call there
and the way object-oriented dispatch
works is that recursive call goes
through the spot shifting method again
and so you get double and triple shifts
depending on how to keep your tree is
and so you know I have to admit at the
time I thought you know object-oriented
programming has something useful to say
to this right this is like one thing in
the system made it right made a lot of
things even wronger than this until I we
found out that you know there's an
entire talk about what they did to
remedy that problem but you know I
really need to go back to what I knew as
a functional programmer is that I should
really model transformations on the
market data as functions and combine
them by using functional function
composition right so you have primitive
transformations tell one tell ten tell N
and you can just compose them you again
have another transformation you can
compose them with others so you get kind
of a compositional accommodator model
for this and that's a lesson that I
temporarily forgotten you know I had a
lot of things on my mind transitioning
from academia to industry at the time
that's my excuse but you know over time
we found these culminate err
compositional accommodator models in
many many many applications and is
always worthwhile so that's one of the
lessons from the talk
apart from the purity from the first
example so even in domains which seem
very flat and boring you might you often
find compositional structure and it's
worthwhile looking looking at for it and
you often when you tell your customer
about this we often found that this
conveyed some kind of insight in their
domain that they didn't know themselves
because just that arose from a systemic
kind of modeling so you know this is
just a partial list you know in
particular you know one domain where
we've been called upon to apply this in
the domain of semiconductor
manufacturing switch gears a little bit
um and I don't know if you know this but
you know making a semiconductor is a
very complex process you know making a
modern microprocessor takes something
like six weeks and there's like a
thousand steps involved and you know
when I started out I thought you know
there's a big old machine you put in a
bunch of silicon you pull a lever and it
doesn't work like that
right unfortunately so there's there's
multiple layers involved and the
machines are so expensive that you can't
just make as an assembly line right
there's some machines you just have one
right and so all your wafers have to go
through them they have to go through the
multiple times your average fab these
days makes many different kinds of
wafers so and and and you know this this
big machine that the semiconductor fab
constitutes is very very expensive to
purchase and run so you really wanted to
run as efficiently as possible
and you know there's a lot of things
that complicate the scheduling problem
there nobody knows like a closed-form
solution to this and so I figured for
some of the problems that that I was
facing you know I wanted to know if a
certain scheduling decision was right or
not or if it was going to get us benefit
down the road or not and the only way I
could think of how to do this was to do
simulation and you know I fell into the
same trap that I'd fall into you know
ten years ago ten years before that
which was I thought you know what what
was this thing that was originally
developed for some it was this object
oriented programming right like this
right you know there would be a tool in
the fab and I would install it by saying
what here's an identifier that I can use
to refer back to it and here's a
description of what that tool does and
you can see
this is an esoteric language that we're
using at the time called star and it
returns void returns doesn't return
anything because it installs information
about that tool in the global table and
I learned this from the great from one
of the great books and computer science
butchering interpretation of computer
programs which tells you this is how you
do simulated worlds is you have global
tables where you install things and you
know it didn't you know in the fab we
wanted to do simulation as the system
was running so there was no option of
modifying the current state of the
system even if it was just for a
simulation because that state was nita
in the actual running system and then of
course we wanted to we sometimes also
wanted to examine multiple trajectories
or even run that recursively as you run
the fab and you simulate the fab you
also need to simulate the scheduling
right and so we really need a simulation
to be reentrant and then I got to
thinking about and then I realized well
you know I've known this all along you
know the real world is not
object-oriented right and our perception
of the real world is not object-oriented
it really works better much better if
you think of it in terms of consistent
snapshots and so that's what we ended up
doing is we took a big snap shot in the
pure data structure using a lot of the
techniques that you see saw David Nolan
cite from Chris Okazaki's book and then
have the system progressed by computing
new snapshots which share a lot of
memory with the old ones but which are
conceptually independent and that
allowed us to do a lot of things
instantly which had been very hard that
particular we could run a lot of
simulations in parallel we could examine
many different paths without having to
worry about affecting the state of one
of the other paths in the system so so
that was a great point for purity at up
at that time and then as we kept on
developing the system you know we were
thinking about the actual scheduling
algorithms and one of the problems in
the fab went additional problem in the
fab is that things break down all the
time so some of the scheduling systems
that you can buy on the market they
compute a big ole plan
right you know and and they optimize
they use you know fancy optimization
algorithms to optimize that plan
unfortunately that plan is gonna fail
after about five minutes in a typical
fad because some piece of equipment
which operates on the level of quantum
physics breaks down or needs to be
stopped maintenance or goes out of spec
or something like that and and being
from Germany I need to make a soccer
analogy is is is really so the thing
that we really have to deal with is is
we needed to anticipate that things
might go wrong in the system as part of
its normal operation and so if there's a
penalty kick in soccer I don't know if
you know this and if you're the
goalkeeper then you need to make a
decision where you're gonna jump before
the ball leaves the foot of the player
right just because of the way the
physics works out and so you need a hope
that the ball goes in the corner oh you
know this is right yeah so you know I
was thinking a lot about this this
notion of hope in the context of the fab
and I was thinking well you give the fab
a concrete instruction you're not gonna
get direct feedback that it failed but
you you know you hope that it succeeds
and maybe later you'll find out that it
hasn't happened and the code got very
complicated that I was writing at the
time because I was trying to model many
different concrete situations in the
semiconductor fab and I was getting very
frustrated and let me to thinking maybe
I should think about hope in more
general terms right what is hope your
hope where you hope that something
happens and you have no way to influence
whether it's going to happen or not
right oftentimes
essentially a situation the fab we would
give the fab an instruction we would
hope that it gets executed you know
sometimes it you know though your hope
doesn't materialize so later you might
you reiterate your instruction you know
installing a printers printer driver on
Windows or something so you just do it
again right you will issue the same
instruction again that you hope that
it's going to work out and ultimately
you know some things are just not meant
to be you need to make a decision that's
something you know your hope is never
going to materialize and you need to act
accordingly
you know as I was thinking about this
you know I had a tour in an actual
semiconductor fab you know where you
could walk around and everything was
glass you know and the tour guide would
point on saying oh this lot you know I
you know this was sitting there last
year you know because some production
step hadn't materialized and people just
forgot about it
so you really want to manage this kind
of thing may be shattered right may be
fulfilled in which case it produces some
kind of value underneath you have the
fab operating and sometimes hope
transforms into another hope for example
if you hope that something happens and
then after that happens something else
happens or you say well you know there
is you know you can think about
combining hope you can say well I have
this hope but I really wanted to happen
by that time and so you get you get a
commentator model for this thing and if
you look at this closely you can see
that it's a monad so if there's a catchy
slogan you can put on t-shirt it's hope
is a monad so and we went on to you know
find other abstractions which which are
you know high-level esoteric
abstractions that we do in function
programming that we're directly
applicable to this domain so the work
we're always worthwhile to keep those in
mind and keep those in your arsenal so
that was another success story for not
just functional programming but for
using you know fancy compositional
instructions I want to put a little
sobering note on on this which also was
a success but you know qualified success
in some ways so this is a project I
inherited from somebody else and you can
see it's a bunch in Haskell code it was
for essentially was for implementing a
very large state machine for controlling
an embedded control system unfortunately
I can't tell you what it is at least not
here on video you can maybe ask me later
so and you know the way these systems
are specified is you specify a state
machine and and the way it operates is
also by a state machine and so my
predecessor implemented a DSL for
writing state machines and asked
you know you could see monadic syntax
and you can do you know if you know a
lot state machines this is actually
understandable code especially if you
know about the application domain and
then he was able to use abstraction in
Haskell to really build up the state
machines in a systematic fashion so that
was great and not just that he was able
to implement temporal logic system for
examining the traces out of that of
those programs to do automated testing
and so this was again an application of
fancy defense of another fancy concept
it sold that was very successful and you
know that I don't think that's another
piece of software that I don't think has
exhibited a single bug since then and I
didn't do it
so yeah well I'm the identifier so long
because they're in German right so kind
of going there German words you can't
you're not expected to understand them
huh whatever something like that
yeah no and and and one you know one
fancy trick in the software system was
that you know the DSL was expressed as
operations and a bunch of type classes
and and and you know there's no abstract
you were usually you would implement a
system like that you would have like
having abstract syntax and from that
generate so I needed backtracking more
the Haskell code doesn't run on the
embedded system right the embedded
system runs C code and the way this
worked is you would run the Haskell code
in the Haskell code the only thing the
running program would do is would emit C
code that you could then deploy on the
embedded system and that that went that
that then would get automatically tested
by this so that was great and it was
able the system was able to get by
without abstract syntax for example just
through clever uses of type classes and
monads so it was wonderful and you know
system was deployed and then you know my
predecessor quit the company was working
for my company and you know one or two
years later and the customer sort of
resurfaced and said well we don't really
want the C code we really want code in a
language called skate
which is very widely used in those
circles which has for example a
graphical notation for specifying state
machines and which you know there's a
lot of research papers on this and
there's a lot of ecosystem
infrastructure and more importantly
there's a certify for use and sort of
mission critical domains and so they
wanted scape code Nazi code and then
they would generate the C code from the
scape code and now but the original code
not only could it only I mean the only
thing it could do was generate that C
code you know it didn't have abstract
syntax or anything so it was not really
that easy to just plug in and different
back-end you know and somebody went in
and just wanted to redirect that code
and and you know compile it with a chunk
current GHC VHC emitted a bunch of very
obscure and long type error messages and
there were still a bunch of Haskell
people and that company and they all
gave up on just getting that code to
compile and the reason well the
fundamental reason why that code file
start like this right and and you know
all those features then you know got
used within those files and you know in
some aspect of the of the in Ference of
the resolution algorithm and GHC had
changed and you know the coat was
sensitive to that and it took a whole
lot of tinkering just to get the code
back to compiling and then you know a
lot of work could you sort of get the
code in a shape where I could plug in a
different back-end the the actual
back-end was trivial after I've done
that right and I'm sure it must have
gotten a lot of tinkering to get the
code working you know in the first in
the first place so you know there's this
problem fancy type systems available to
you you know existential and polymorphic
varian's and gdts and whatnot is that
you want to use them to do it might to
model your domain as precisely as
possible right you want to make take
good advantage of the tools that you
have at hand but you know just the other
day I was writing a bunch of Scala code
and I was just trying to make like a
heterogeneous map with you know where
the type would determine the key of the
the the way the key would determine the
type of the value and you know I
that was trivial but getting the type
checker to accept my proofs that it's
actually typed correct you know took me
another half day and I see people doing
that a lot so and here's sort of the
conundrum in this field is that we were
doing functional programming to program
in a more systematic manner and sort of
an engineering fashion but when it gets
to the type level which should push us
towards more systematic programming the
practice of it looks like this so our
next big project that we did in the
semiconductor doesn't mean anything
really to you anyway we implement it in
closure and it has it has a lot of
purity and it has a moan at staying
right at the center of it but in
particular that monad is I know it takes
some very fancy type gymnastics to get
type correct and it's no big deal
enclosure at all so I'd like to take
good advantage of fancy type systems but
I would like to do it without without a
lot of tinkering and right now the state
of the art isn't there yet punch the
programming is wonderful and it took me
you know ten or ten ten years at least
to realize that you know I would do a
year of functional programming and that
for some reason or other I would have to
do a little bit of object or programming
and it's always worse than I remembered
you know people are doing object it
can't be that bad right but it is and
it's worse or conversely functional
programming is that much better and that
much more pleasant aspect for us that's
relevant in our day to day work is
really to do purely functional
programming a lot of functional
programming languages give you
imperative features on all of them do
and your you do well to avoid them and
to model ways and you know model things
in a pure fashion purity gives you a way
to do programming systematically I
haven't talked a lot about that you know
my tsa license here Matthew flat is here
there were people pioneered not just
programming systematically about
teaching people how to program
systematically and and so this is all
eminently teachable
type based programming also haven't
talked a lot about that but you know
systematic programming has a lot of is
you know when you do that you should
really do it thinking about the types of
the things in your system
right I think the closer people as a
whole have yet to learn that but on the
benefits of static typing at least given
the current state of the art and and if
you're a programming languages
researcher and type systems you know
don't just think about the fancy logic
that you might apply but also think
about the requirements that arise from
practical programming which are not just
about you know fancy types but are which
are about modeling things in the real
world and doing that systematically
that's all I have to say
yeah
no no so I didn't found that company
that's what I company exists and hired
me as a CTO so I should say that but
good point thank you
so the question was whether I founded a
company because people before that told
me no object-oriented programming is
better at functional programming for
modeling things and I've never heard
anybody say that to me I think people
use object or near programming in my you
know my domain in Germany where people
are very conservative about new
technologies it's just people like to
use technologies that everybody else is
using in many ways so so that's them the
argument that I hear most commonly you
know there's no especially if you if you
model things there's no I truly conveyed
that impression wrongly right you know
the fundamentals of object-oriented
programming are great for modeling
things right the problems come with the
introduction of mutable state into
object-oriented and arguably you know it
was one of the original goals of
object-oriented programming to get rid
of mutable state so there's that early
history of small talk paper by Alan Kay
which says that very explicitly but they
never got around to doing it so you know
one way to view it as sort of that
functional programming is now coming to
becoming the the realization of that
original dream so the data modeling
techniques you know I think you know
what was great about object-oriented
programming is that you do conceptual
modeling you know we talk about that all
day but but having you know a close
correspondence between the objects of
your program and your problem domain
that's great and that's eminently
applicable and functional programming as
well does that answer your question at
all I don't know
you have a question yeah
oh yeah Lots yeah we're small company so
I mean a lot of projects we just don't
do because of that you know we we've
been foolish on some projects I remember
you know we were foolish to say well you
can go you could we can do this two ways
right well you know what using
functional programming or we can do it
object-oriented programming in which
case it costs you plus 50% and we've had
customers who didn't even blink okay
okay
right there right we're like oh and
that's how we know how awful it is right
is right it's it's when these projects
come along you know we always thought we
were going to give them an easy choice
and sure enough we gave them an easy
choice it just didn't come out come out
the way that we wanted it to so yeah but
it's getting to be less and less right
people know these days I mean everybody
knows what functional programming is
most everybody knows is that it would be
better if they were using it right and I
know ten years ago we were like you know
people would say mine well is not here
but used to say don't say the M word you
can't say monad in front of like
ordinary programmers because they'd get
scared and that is certainly no longer
the case no it is it's a cool world
right it's so it's so you know if you
know what a monad is you know you get a
certain status even among Java
programmers and I've got you know I've
got I've got a little sort of
unscientifically but hard evidence
collected about hard evidence on that
so there's progress
so one more and then I guess we'll break
you know I heard that might not yeah oh
the question was I'm sorry you repeat
all the questions so question is will
dependently typed well dependent types
help and my notes the words say I
mentioned that I hope that dependent
types will help with this right and you
know I haven't seen it happen yet right
dependent types were introduced in high
school I asked a couple months ago I
asked Stephanie why Rick you know which
feature of Haskell can you know take out
right I mean ideally it would you know
the dependent types would subsume some
of the other features in ASCO type
systems she said none so I'm not deep
enough to not to really make a judgement
but judgment call but I really hope that
and and and I think that's the best
Avenue that I see right now is that
dependent types will just make things
more uniform and and and help us getting
fancy getting maybe less fancy but more
programmable and more uniform and and
type systems that allow us to get by
with less tinkering okay I guess we'll
break then thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>