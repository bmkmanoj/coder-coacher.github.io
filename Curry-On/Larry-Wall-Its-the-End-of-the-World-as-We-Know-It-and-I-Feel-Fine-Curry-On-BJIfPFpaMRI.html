<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Larry Wall - It's the End of the World as We Know It, and I Feel Fine - Curry On | Coder Coacher - Coaching Coders</title><meta content="Larry Wall - It's the End of the World as We Know It, and I Feel Fine - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Larry Wall - It's the End of the World as We Know It, and I Feel Fine - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BJIfPFpaMRI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">did everybody enjoy the party it was
okay we just like to remind everybody
that the talks were being live-streamed
at the links on Twitter if you use
Twitter retweeted make some noise that
would be awesome
I'm extremely honored to present the
next keynote speaker as he's the creator
at the language I first programmed
professionally so you know without
further ado please give a round of
applause to the keynote speaker of day -
Larry well
I'm gonna channel RMS here repent okay
the Visigoths are coming or maybe the
Franks on more Frankish than Visigoths
imminent death of the usenet of using
that pretty fish the singularity is near
well actually I don't think it's going
to be a singularity but more of a
plurality the a the ice will probably
turn out to be both most more postmodern
than we are I think as I learned
yesterday
there are even 99 ways to count words in
Python who'd have thunk you said you
didn't quite have a one-liner solution
here's the the Perl six one-liner
and it's sort of object-oriented it's
all methods except there's no side
effects so I guess this functional
programming one of the very important
lessons I've learned over the years is
that most people really only understand
technology from their own perspective
not from some global perspective if
you've been studying a new computer
language for three weeks then to you
that language is three weeks old we get
this sort of thing all the time on the
Perl six IRC Channel oh wow that's cool
I wasn't expecting that figure to work
exactly like that but it did I mean no
it's the other way around
anyway as old timers like to point out
yeah we've only been designing Perl 6
for what about 15 years now we'd like to
think we got a few things right but
don't pay attention to us old timers
well except me today you're probably new
to Perl 6 even if you're an old timer
yourself so please just think of Perl as
a few months old I forget everything you
know or think you know about Perl just
think of Perl 6 as an emerging language
a fairly big emerging language we don't
just include the batteries we include
the battery chargers the electric grid
and several kinds of power plant okay
it's a really big language though it
still not nearly as big as English but
that's okay because one of the design
principles of Perl has always been that
you don't have to know the whole
language to start using it like a
natural language you can just learn the
parts you need as you go we also allow
people to come to Perl from other
language languages and to speak with an
accent so to speak so dialects are okay
in fact many of these strengths of Perl
over the years are based in linguistics
languages evolve over time
we don't have arbitrary limits you know
you may only use 32 verbs in this
paragraph either many paradigms if you
if you will
many small narratives you can have in
English or any other natural language
allow for external influence on design
context is is extremely important to
everything
it's an operator rich language we feel
as more readable will go more into that
visual distinctions are important I
think things that are apt to be confused
should be made to look different
languages are basically fractal in
dimensionality we had a speaker
yesterday bringing that out you know
your city is a kind of a fractal
landscape easy things should be easy
hard things should be possible that's a
very human thing to want and you're
allowed to speak Comp Sci when you grow
up on the other hand many of the design
flaws of early Perl resulted from me
being more of a linguist than a computer
scientist you might say I had a better
grasp of metaphor than of metadata sure
by the time like we got to pro 5 it had
a lot of useful stuff in it and it fit
people's brains somehow and it was lucky
to be in the right place at the right
time for people to bootstrap much of the
world wide web but it also has
significant number of design flaws
profile was nice but not nice enough at
least that's that's what we thought back
in the year 2000 when Perl 6 got started
in 2000 what we announced was that we
would have a community rewrite of
language and of the community as to what
that actually turned out to mean well
that took us 15 years to figure out
first I thought we just needed to get a
few things so I asked for suggestions I
expected maybe 20 and we got 361 like
and we did get a new parental mascot you
may have seen the butterfly okay
long story short people were hurting in
lots of different ways and while there
were many ideas for how to fix
individual problems the set of proposed
solutions taken together we're just a
complete mess
so we ignored the solutions and just
concentrate on understanding the pain as
we started to understand the pain points
that people were experiencing not just
in Perl five but also in Python and Ruby
and PHP and Java and c-sharp and
JavaScript and maybe even an ask a
little bit we started to come up with a
list of principles that would guide the
design of Perl 6 in the end we came up
with about 60 design principles and here
are a few of them this is not the most
important principle except that is how
postmodern we believe in tormenting the
implementer on behalf of the user as
others have brought out here we think
it's a bug if the error message is less
than awesome we even have an acronym LTA
for that every dwindle awning whack try
to hide the wet encapsulate your clever
cleverness and then reuse the heck out
of it so we only have about toothless
that you have to memorize anymore in
Perl 6 the precedence table and the
smart mesh table and we just use those
everywhere an a is just a funny kind of
a B but call it an AE not a B we we had
a lot of this metaphorical stuff going
on in Perl 5 like a class and a module
and a package we're really the same
thing the problem is we have called them
all packages and that was confusing in
Perl 6 we actually use different
keywords for them which you'll see I
give you you get the user enough rope
every feature should have high leverage
but not too high remember this is this
is Pearl we're not actually trying to
target only the geniuses pick the right
default this time around this it's
amazing how how often Pearl I've had the
wrong people and everything should be
made
strangely consistent in this this
fractal way and so on yeah so as you can
see pearl six is sort of a grand
narrative composed of many smaller
narratives it simultaneously rejects the
postmodern syntax the polyglot of early
pearl but at the same time it tries to
do the same sort of postmodern mixed
together but instead it's mixing
together modern features of modern
computer languages down at the semantic
level so we redid the syntax but a lot
of the Spirit of is the same so we have
a plan no wait we have lots of plans the
art of design of course is to decide
when to apply each principle each
decision comes with trade-offs but some
decisions trade-off more than others so
we had to figure out which were the most
important principles so I'd like to
mention a few of the the rather
important ones we think of flooding
algorithms we're talking about the
freedom to perform multiple experiments
in parallel and the freedom for some of
those experiments to fail and this is a
difficult balancing act we're an open
source project with mostly volunteers so
most people we work on what they're
interested in we feature that by
declaring that we optimize for fun on
the flip side we don't tell people what
to work on much we expect people to use
their initiative but usually when people
use their initiative they end up with
something not quite optimal as Theodore
sturgeon would say 90% of everything is
crud so we need other sub principles
like forgiveness is greater than
permission
well we encourage you to try things we
also encourage you not to get your ego
too involved with your experiments if
software experiments never fail you can
never converge on a solution what the
thousand flowers bloom but also
guys that evolution can't happen unless
some of those flowers die young
backtracking can be painful but no
refactor can happen without realizing
you've gone down a blonde at blind alley
so in particular I'd like to honor the
pugs parrot and nature projects which
were among our most spectacular failures
we learned a great deal from each of
those and we would not be here where we
are today without them so where are we
today well we finally converged on
Christmas so the current version number
is called six Christmas well really six
dots see and what do we have well we
have a fun handy learn ball scalable mr.
expressive optimizable maintainable
interoperable and paradigm gradually
typed Unicode friendly it just keeps
getting longer doesn't it test we
specify functional actually reactive
parametric of generic linguistically
malleable multi virtual machine meta
object protocol defined representational
polymorphic thingy it's easy to slip
into into marketing mode here now if we
want to do more marketing you know it's
it's its record without the parens
yes yesterday during the Racquet
manifesto I kept thinking myself we do
that we do that too it'll be interesting
to see what actually happens first
whether pearl six makes a racket a sub
language of pearl six or rec it makes
pearl six a sub language of racket I
warn you it's a big language okay how
about this one
pearl six it's the last programming
language you'll ever want to use you can
take that either way we're not picky one
of our small narratives is that you can
pick your own grand narrative if you
like but I think you'd rather just see
some code to show that pearl six
actually works and actually looks pretty
decent I can't show lots of examples
here but one place with lots of good
examples of both pearl six and racket is
rosetta code
well not rosetta code slash Perl 6 one
place with lots of good code examples
McCann compared the solutions of many
different hundreds of different
languages I think there's there's 500 of
them or so I think at the moment
yeah well I had that somewhere I think
pearls number five brackets up above
okay so anyway pearl six itself has
eight hundred or so solutions to those
various problems and and I might be a
little bit biased but I think compared
to other languages Perl six usually
comes off pretty well in terms of
readability and elegance one of those
rosetta code problems is called forest
fire so first I'll run it for you wow
that's anyway it's kind of mesmerizing
unit this is a crude simulation of a
forest ecosystem in wildfires we start
with about 50% coverage of virgin
forests and the fire burns up most of
that and eventually we settle down to a
quasi steady state now there are two
forms of propagation going on here
trees propagate slowly while fire
propagates quickly if I may draw a
metaphor from this mini modern computer
languages are like fire they do one or
two things really well that no other
language has done well and suddenly
become popular but they tend to run out
of fuel quickly sometimes I feel like we
should emit a flavor of the Month Club
for computer languages and web
frameworks and container technology Perl
6 is not trying to be the flavor of the
month it's trying to propagate more like
the forest slowly but inexorably we
don't really care if one of those flavor
the month languages eats up a bit of our
forests while fires are just a part of
our ecology and maybe they even help our
seeds germinate anyway enough of that
show me the code
what okay
okay so where's that
okay big enough treat okay notice first
of all that pearl six is highly
declarative much more so than in Pearl
five you see many lines beginning with
what we call a declaratory constant my
for clearing lexical variables as in pro
five enum class has method and so on we
also have declarative modifiers which we
confusingly call traits we have
something like small talk trace but I'm
confused me we call those roles instead
because it would be confusing to call
them traits when they are also
functioning as interfaces and abstract
classes in generics so anyway here is
required as an annotation that modifies
the has declaration note that we hide
our annotations inside instead of
stacking them up out front like other
languages do and basically hide the hide
the name and the declaration itself so
important things first modifiers later
sometimes below that you see other
declarations that can take default
values for for these attributes notice
we use the actual words that you would
use I mean I has a relationship you
declare what the has done so so the
default values in this case these are
what the trees catch will grow or catch
fire I noticed we have the optional
typing there we're gradually typed so
you can add more typing as you go yes
Perl 6 is highly declarative but when we
say declarative we mean something a
little different than usual for most
computer languages if you call something
declarative it's fixed in stone it's
built in syntax you aren't allowed to
change it we call this the one true
language syndrome
Perl 6 doesn't suffer from this you can
add your own declarations and change the
language within any given lexical scope
the compiler itself is written in Perl 6
so you don't have to learn a different
language to modify it or to add your own
declaratory sort rates for example we
already have modules that implement
things like monitors or actors as these
are defined declarations and you know it
takes about this much code to introduce
the actors model we just try to even if
we don't fully support some particular
your very favorite style of programming
we're about this far away from it so you
can get there in fact most of the
declarations you think of as built-in or
actually just written in Perl 6 they're
incorporated into the setting that's
what we call the prelude except it's not
a prelude that's around so what's the
setting they're incorporated into the
setting in the same way as user code as
if the setting were wrapped around your
program as an outer lexical scope take
for instance this X operator down here
that's in many languages the set of
operators is fixed maybe even the set of
behaviors for those operators is fixed
because our setting is the outer lexical
scope you could override or add to the
behavior the X operator in your own
program we kind of look at the the
definition of X but first of all maybe
you're wondering you know what what it
is it's just a Cartesian and a
cross-product so if you if I run this
snippet of code it just produces a list
of lists
likewise this went up here you'll notice
X tilde
that's just a cross with operator so
that does in this case concatenation so
it's across with concatenation okay I
promised you I'd show you this
I think it's seamless and okay so here
we have definitions of the the X
operator the first thing you notice is
the operator so it really just functions
with funny names well and because of the
funny names the parser knows where to
look for them it won't be look for an
infix where a term is expected for
instance this is extensible depending on
your grammar you can make as many
different namespaces as you like the
next thing you notice is there are
multiple definitions for the function
second is the ordinary X operator the
one that returns Cartesian products as
lists the first one is used when you
want to do higher-order programming and
pass in an extra function to apply to
those Cartesian products as you can see
there's there's a lot of extra stuff in
there that's that 10 times stuff to make
something industrial-strength some some
of these definitions are kind of ugly
you know going dropping down at the
lower level language here nqp is not
quite perl it's a restricted subset now
this is all you know highfalutin
functional programming internally but
notice how simple it looks in our actual
program just with the X here
that one just with the X here we just X
here because we want to across the
coordinates multi-dimensionally but up
here we can do the cross concatenation
in a very succinct but yet readable we
use uppercase for those visual
distinctions it shows up in the middle
of two lists easily
so if well designed a system of
operators can do more than almost
anything else to contribute to
readability
that's my narrative anyway well one of
them what I really like to do is
convince you that deep down Perl 6 is
really both fundamentally a functional
programming language as well as an
object-oriented programming language
maybe not and then you know in the 90%
sense not in the extra 10% that says you
can't use any other other paradigms so
really what we like to think of is that
we can make pretty much any programming
style look more respectable than many of
the languages that purport to specialize
in that style
we certainly do pretty good job a
prettier Java subset than Java does I
think now this for down here for
instance these fours look like
imperative programming statements but
really they're just map in disguise for
instance you could turn it into and that
is in fact with the arrow there that's
our one of our lambda notations and
because the general lambda you could you
can pass multiple arguments or do
argument unpacking or pattern matching
okay now each of these methods is really
a function underneath the only
difference is that a normal function is
stored in your lexical scope and uses
the function dispatcher it's a part of
your current language a method is stored
in the metaclass
object and uses a method dispatcher so
it's language belongs to the app to the
class or the object depending on your
object style on a surface level most of
the time functions are entirely distinct
from methods and we work really hard to
keep the naive users from confusing them
but down underneath everything is
unified so you can install functions as
methods or call methods as functions if
you work at it so when it comes to
mixing paradigms we always try to have
our cake and eat it too but not by
forcing novices to convert from one
paradigms religion to another but by
maintaining deep unifications under the
surface differences so that we can be
both novice and expert friendly easy
things should be easy hard things should
be possible you may have heard that
before
okay so Perl 6 is not the first language
to claim your multi-peril paradigm
support but that's just one of the areas
in which Perl 6 is trying to raise the
bar how about say Unicode support we saw
a little bit of that in the forest fire
program where we use the tree character
from Chinese but what if you wanted to
use a you know a character outside the
BMP how does your language work that can
your language handle emoticons as single
characters can you just paste any old
character in your program we could like
to change that too from a regular tree
to a Christmas tree treat don't have
time for that it works but Unicode is
not just for the insides of strings it's
also for the outsides of strings right
there as part of your program Perl 6
programs are natively unicode e on a
deep level you can always define
appropriate Unicode operators for what
you're doing this has the added benefit
that you won't be tempted to overload an
existing operator for an unrelated
function I'm looking at you C++
also names may contain Unicode this
includes module names even on file
systems that don't know about Unicode
file names interestingly this gives us
case sensitive module names even on file
systems that are not case-sensitive put
on a shallower level handling Unicode
just saves many irritations how many of
you have tried to program on a
smartphone or tablet how many of those
clients have have new smart smart quotes
that's your favorite programming
language except smart code quotes so
here's regular quotes yeah that works
great so letter range what about smart
quotes yeah no problem
what about if you're one of those other
countries what about if you're one of
the other other countries that puts the
trailing foot the other way that's the
works what if your smart phone changes
the dot dot dot into an ellipsis yeah
whoops mm-hmm have to actually run it
okay yeah it works what we're doing here
is is called nfg a term we made up and
you think of it as NFC on steroids what
what that basically you know well let me
demonstrate
okay here's suppose you want to have a
move with a vector notation of some sort
on top of it because you're some sort of
mathematician Perl 6 knows that that is
one character but two code points okay
now here's a whole bunch of stacked
marks combining marks
how long does p5 Perl 5 think that is
well it thinks it's 49 characters Oh
oops I should have said use utf-8 now
the length is only 27 what is in Perl 6
well of course it's 5
because we default to graphemes get down
to the code points or the bite level if
you want to so you know this doesn't
mean much to the Americans like me who
look with suspicion on any word
containing accents but maybe you want to
work internationally someday even if
your European chances are your
characters will all have precomposed
forms in NFC but other languages are not
so fortunate
it's one of pearl success goals to treat
these languages as if they had
first-class representation in Unicode
anyway and here's how it works
imagine a distant future in which NFC is
extended to have precomposed characters
for all normal purposes nfg is
attempting to emulate that future if
there's already a precomposed NFC
grapheme in Unicode it just uses that if
not perl creates a temporary precomposed
graphing just in this process so that it
can pretend that you can you're composed
form is a single character now this
means that when you index into a string
by graphene it's very efficient because
it never has to skip over variable with
characters more importantly it simply
does what the naive user expects now
suppose you want to write your numbers
in Tibetan well that works suppose you
want to write for native form numbers
now that works suppose your vulgar and
watch just writer fractions yeah that
works well yeah but that's you know
that's not an exact floating point
that's floating point number right so
it's not exact well what is it actually
surat what methods does it have oh gee
we can introspect numbers well one of
those is the numerator and denominator
so what are those 3 and 5 well there's
got to be a joke in here somewhere about
the objectification of nude rats but
or you can ask for the Perl
representation out of it
okay here here's here's a trick c1
okay so what's this gonna say if you add
two decimal numbers and compared to the
third-most here languages are going to
say no and no it's not cheating by doing
approximation if you want a
floating-point number you have to use e0
on your literal or whatever okay these
default two rationals okay
yes what it's what the naive user
expects and if you're if you're smart
enough to really want the floating-point
you're smart enough to figure out how to
get them okay so if you have like a
series operator here and you're going up
by point one every time is it going to
actually hit the end point exactly well
in this case yes it is because it's done
in rational arithmetic so we have the
this lovely series operator which you'll
notice is actually intuitive the
sequence there so what does this say
well it says oops it says don't go to
the next slide it says you're dumb
that's infinite I'm not gonna print that
so you can say well I just want the
first 40 of them so you can subscript
with a slice it with a range this is a
range 0 up to but not including 40 you
put a carrot on either end exclude the
endpoint and I'm so often that we have a
shorthand you just the prefix carrot
operator says up to that so those both
say the same thing okay now what about
this one well obviously that's a
geometric sequence so it's gonna do
powers of 2
what about this one well note the
infinity symbol yes that works too if
you want
yes it just gives you the alternating
geometric sequence strange geometry what
about this one yeah that works too
sometimes it's just a lot prettier and
people know how to read that you know
why shouldn't you write your code to be
readable you can use star star too if
you want okay what happens we ask for
some Fibonacci numbers here
well it says I don't know what you're
talking about there
at one time we contemplating baking in
the whole online integer sequence thing
and we said no that that way lies
madness
so just arithmetic or geometric but if
the last thing in your sequence is an
iteration function that is has a certain
arity it knows how many things to look
back for so fibonacci is just take given
an operator that takes two two arguments
so you can either use the built-in then
by name that's the noun form of the
built-in plus operator or you can write
a lambda in the long form or there's a
self declaring form or there's this sort
of self Auto Korean kind of form that we
have with whatever stars and those all
do the same thing uh more fun function
composition okay so you tried to do a
log of a negative number and you're not
gonna get anything much out of it but if
you like just always want to okay if you
always want to do that well leave that
alone fold operators okay so you can
your gonna review it in method form if
you really want to but mostly we use the
prefix list operator form like this plus
here and so those all sum up to ten
running sums
you know what's called scan in in
haskell in such languages we call a
triangle operator because tends to
produce triangle whatever looking things
so you get triangular numbers you know
and don't be lazy
and okay so you're gonna roll six dice a
six-sided dice five six sided dice like
in Yahtzee you can sum them or take find
the minimum of them
okay let's probably get a different okay
they do vary so anything that's an infix
operator can can be can be reduced with
including user-defined once which we'll
see okay so you're reducing or folding
with a star versus a star star is it
going to be a right folder or left fold
well it just deduces that from the
associativity so these turn out to be
both true automatic identity okay so
this obviously is a reduction which
happens to produce 100 factorial as I
said no arbitrary limits so our integers
just grow
I suppose you wanted to put that into a
function let's do let's define a postfix
bang you've never seen that notation
before so it's 100 factorial same number
okay what happens here if I say 1
factorial well obviously it's it's just
a range of 1 to 1 so I still just 1 what
happens if I say zero factorial it's
still one operators know their identity
value so if I just say this again it's
just one even though there's no
arguments whatsoever any infix operator
including chaining chaining billions so
is 1 less than 2 less than 3 less than 4
yeah so what's the degenerate condition
of that is true
generate generate minion some excess or
infinity plus or minus was degenerate
GCD heck if I know
other Madhav's reverse meta operator
okay let's define a beta infix operator
usually to find operator and it just
puts a bow tie between the two things
so reverse 42 and 43 it gets 43 bow tie
42 we actually have used this in anger
sometimes you wouldn't think so mostly
due to and white continues because it's
considerations sometimes you want to
divide into something so you use a
reverse division the zip met up so zip
with in the meta form you do plain old
so that's up to lists as you would
expect stops on the shorter one the
cross operator you've seen that does the
cross product how about the reverse
cross product yes they stack the X
reverse across reverse beta yeah
something slightly different and if you
do it all the way around you get back to
where you started so when it gets
ambiguous you can put square brackets to
clarify so it does not always become
unreadable well I'm I got you know
there's plenty more I could talk about
in concurrency we've got vectorizing
hyper ops that I really haven't you saw
one in that first top 25 thing that we
use promises and channels like go does
events we basically have a functional
reactive programming stolen I mean
lovingly borrowed from c-sharp only we
renamed everything to make sense so you
have supplies and you react to those
supplies and in general the the the
words that we choose in in Perl tend to
be the the English words you Jews use
for actually solving the problem we
don't use switch case
that's talking about the structure of
the program itself now it's given this
when that when that one that same with
the same with the reactive programming
representational polymorphism your
classes don't even know what the
representation is because that's a layer
underneath it says oh you're you're in
our opaque kind of thing we can do
whatever you want or your a you know an
array in your VM or you know I see
whatever or you know a Python hash you
know whatever it you don't have to worry
about that on the language level just
when you start it up it has to know
which one to use for each type and lots
lots of stuff with native types great
foreign function interface these days
meta programming there's a meta object
don't really have time for it we use
generics all over the place inside we
currently have two and a half backends
one more VM which is written in C it's
it's our kind of our native VM but JVM
is close behind and Jas is in progress
it's the nqp part of it is fully
bootstrapped and they're just
implementing the final few instructions
there either off you know
so I'll stop there and questions
hey with obviously these different ways
that you can do well I'll take the
example of coats but I guess it applies
to other things aren't you afraid that
there may be fragmentation in programs
in the sense that I have a hard time
reading the program written by someone
who is of another native language I mean
I know English native speaker but at
least in most languages I know that I'm
going to see the English style of riding
in here it looks like it might be harder
yeah certainly everything is a trade-off
and you know if you give people maximum
flexibility some people will take
advantage of it our strategy there is we
try to give people enough rope to shoot
themselves in the foot as it says but we
also try to include so many batteries
that they're rarely tempted to actually
extend the base language and so at that
point you know if you're talking about
programming in a different language you
know people are already programming in
different languages like you've probably
seen Chinese programs and know you can't
read them unless you can read Chinese I
know a lot of the characters myself but
even I can't you know necessarily read
them but so it's yeah it's trade-offs at
some point you're talking more on a
level like literature you can't read a
Chinese novel until it's translated to
English either so it becomes a cultural
decision rather than a technical
decision or an imperialistic decision on
my part so whatever
if your Unicode Unicode support is based
on graphemes instead of code units and
we have combinations of code units that
create like flags based on the country
codes does that mean the length of my
string will change over time as like
global politics changes countries yeah
well we can't do much about politics can
we accept vote occasionally it uses the
graphing rules that the Unicode
consortium itself puts out so we have
them to blame as they change it
maybe I missed it during the
presentation can you define your own met
operators it would be possible to we
don't quite have that hooked up yet it
will be I mean they're just another
grammatical category well actually
several grammatical categories depending
on whether it's a and and infix prefix
or an infix circum fix or a prefix
prefix a postfix okay there's lots of
grammatical categories you can add most
the common ones are hooked up we don't
have the all the meta operators hooked
up yet at that level but the intent is
that if you're willing to actually
program inside the compiler it would be
trivial to because the inside of the
compiler is already Perl 6 it's just not
we don't have the way to hook that up
into the user code quite yet we're still
working on our our macro system as as
was mentioned you know hygienic macros
are just a start what you really need to
do true language extensibility and we
have all the internals in place inside
inside the compiler we don't think of
Perl 6 as a single language
it's a braid of many languages inner
inner woven so at every place where
you're parsing a particular grammatical
category you're really in a kind of
little different sub language that's
also true about you know regular
expression languages hear Doc's quote
languages they're all they're all
generated on the fly it's the extent and
it's necessary so all the mechanism for
mixing in new grammatical rules deriving
a new grammar and it actually goes out
and writes in lecture for you with
transitive longest token matching rules
so you never have to write a lexer again
so yeah it almost
Thank You six so if I want hatchling
pearl in racket what's kind of the
minimum part that I need to build is it
that's often hard to boil things down to
available but is there is there a small
piece that I could try to attack it's um
you know we we because we're we are so
have such inter woven this runs this is
this is run time code running a compile
time sort of the dual of you know you
know you've alloys is like running
evaluating string is like evaluating a
compile time code at runtime and we do
the opposite also quite a bit which is
running code underneath in various
pieces to do these declaration all kind
of things so and I'm sure there's a few
places where we cheat on I know there's
places we cheat on context freeness so
we you by reproducing the exact
semantics of our parser might be a
little tricky why do you say falling
down there that's a good thing it does
things like yeah at the moment were for
a lot of us were relying on the wide
view V the the nodejs for for a lot of
our platform semantics that's
so yeah that gives us some some
portability layer that the nqp layer not
quite pearl is also designed to be
fairly portable for a large language I
mean obviously you have to support all
this graphene stuff and yeah yeah if we
were a tiny language would it would be
easier to support to new places but you
know it's one of the one of the many
things we tried to bear in mind and at
least make it possible even if it's not
as easy as it would be the port seat
poetry first we introduced the same boat
how well or not has the paint won't work
for you and when we'll be introducing
pearl six you know that's that's a bit
of a we haven't introduced paint mode in
Perl 6 yet we thought about it it it
doesn't work quite so well when you have
this representational polymorphism where
do you store the tank bit okay where do
you store the tank that in a native
integer well maybe just don't paint them
either
so either you you store something with
the data value that says oh this is
tainted don't use it on anything
insecure or that's if you want the
runtime approach that Perl 5 does if you
want a more you know like a rust kind of
approach or you know more static than
you know we can talk about that we try
to have a certain amount of information
available at compile time so that we can
do both ahead of time optimization as
well as jetting but yeah you got it you
got a store somewhere and even if you if
you have to have some sort of a
descriptor or you know some of these as
mentioned yesterday when you're doing
cross language things you have to have
various kinds of proxies you know doing
it with with proxies that manage that
there's another possibility
but yeah it's one of the things we
didn't get in by Christmas because we
wanted to get something out we didn't
even we didn't even beat Duke Nukem
Forever out the door much to our shame
we hope you'll have a little more
staying power great another question so
I'm curious how gradual typing is
working out in Perl 6 do you like having
it in the language we're there any good
or bad surprises about well my gradual
typing is is gradual as far as the user
is concerned we then the mistake we made
in pearl pearls 1 through 5 we allowed
the the user to be confused about what
the type of a scalar value was maybe
it's a strange maybe it's a number maybe
it's something else
unfortunately we did that by confusing
the the compiler and the runtime system
as well so it had no clue either so if
you happen to use a string as a number
as the number of string it could have
weird side effects in perl 6 we always
actually know what the the type is now
it might be a more generic type or less
generic type but we have a specific type
that we have in mind even if the user
has not declared it so you know literals
come with their types various operations
know what types they're producing so it
works out as gradual typing from the
standpoint of the the user the naive
user but then they could they can add
typing now when we would put in typing
we discovered that you know type safety
is actually only the like about the
third most important thing correctness I
mean it has its uses in terms of
reliability but there were you know more
important things particularly with
native types we get can get potentially
at least as our optimizers get better
much better efficiency with better type
information both ahead of time and and
and cheating but really the most
important thing that
it turned out to be important for was
just to support multiple dispatch
because we just used multiple dispatch
pervasively both multi-method dispatch
and multifunction dispatch and they're
the real reason that that is the most
important is extensibility because I
mean you get a little bit of
polymorphism out of you know your class
structure but people tend to go over use
that so putting multi multiple dispatch
is orthogonal to that you can pull in
modules of the either functions or
methods classes and you know it's not
like the old days where you wrote a case
structure based on your types and you
were locked into that it's the way to do
case structures without locking yourself
in so if you add a new type you add a
new multi for the appropriate operator
hopefully it's the appropriate one not
an appropriate one goodness we can have
all of you and code for operators down
you don't have to overload less than
less than to do i oh so it's worked out
very well because the the base classes
and the base modules just don't have to
know how they're going to be extended so
that's one of the many ways in which we
are supporting extension into the future
that's that's sort of down on the on the
semantic level how you how you delegate
all the is it sort of almost an
inversion of control kind of idea okay
what's</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>