<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Crista Lopes - Exercises in Programming Style - Curry On | Coder Coacher - Coaching Coders</title><meta content="Crista Lopes - Exercises in Programming Style - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Crista Lopes - Exercises in Programming Style - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JlPMOszyjjo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">start I will try very hard to just stay
here in one place that's not how I
usually do my talks but I guess I'm
bound here and so thank you for coming
thank you for inviting me and to give a
talk here I'm going to talk about a
piece of work that I had done a couple
of you a couple of years ago and it
resulted in this book exercise in
programming style and I'll tell a little
bit about how I came to how I converge
to this but it it all comes down to you
know some inspiration from her heart
history simplified which is that there
are many ways of drawing a face and and
not not only that I many ways of drawing
a face but interestingly enough some
some painters some artists have
developed their own sort of stylistic
approaches to design in general right
you can recognize you can look at at a
certain piece of art and you can
recognize certain elements in there that
that gives away about who the author or
the artist was I think we I don't know
about you but I in in my sort of alter
life as a software developer for
open-source software development I am
develops the very large code base that
I'm involved with I I can look through
the code and I can see who wrote that
resonates with this experience you can
you can you can tell right you can tell
the people who come from this se
background very sort of embedded systems
engineering you can tell their code you
can tell people who work from IBM for
IBM I can tell people who work for IBM
you can tell people who are trying too
hard to kind of impress or it kind of
tendency to over engineer you can you
can tell who the people are so there are
these these styles but there's there's
something about what what the style is
what is it that makes the style right
how do why is it that we can recognize
these styles in cloud out there in the
wild
and furthermore where else do we see
these things and why are these things
important so programming styles are ways
of expressing the tasks they exist in
many scales and that's the part that I
find quite interesting and they are
ideas for how to divide the problem into
parts and how to put the parts together
again that's very very many ways that's
that's sort of a very strong component
of a style it's not just you know
whether you use capitalized letter or
whatever that I don't you know that is
also part of the broader definition of
style but the part that I'm actually
more interested is is in the ideas for
dividing the problem into parts and put
them parts back again together and there
are many ways of doing this and and and
you can see these ideas repeating from
very small scale of very small programs
toy examples all the way to distributed
systems how do you partition what you
have to do and how to how do you make
the things talk to each other
and you can see the same approach is the
same styles recurring at these different
scales right and my question was so I
let me tell you my personal why I came
into this I I tend to teach programming
courses but programming intensive course
is at the senior level not that they're
not that sort of introductory
programming level I don't teach
introductory programming but one thing
that I realized when I was looking at
the code written by students that are in
you know third fourth year of an
undergraduate degree in computer science
I saw a lot of really bad stuff right
it's just like some of it is really
really really ugly and I wanted to I
started to realize how what are we
teaching right what what are we teaching
the students that can't they come into
almost ready for for a job in the job
market and they're writing code like
this and how do we explain how do we
teach them right it's the matter of
communication how do you communicate
these ideas these stylistic ideas and
this is kind of a very important problem
for us academics we teach but it's also
an important problem for everybody
because the problem of communication and
now you know you can approach these two
Mis or the
very pure sort of mathematical
perspective say okay the way to you know
minimize be as minimal as possible just
encapsulate that whole thing into a
small little thing that you can use
Greek letters for and this is pure
knowledge that everybody has to
assimilate that's one way of doing it my
experience that is it's just the path to
get there to be able to actually
simulate those kinds of formulations
that is so high that most people will
not be able to assimilate and they're
missing a lot of interesting and
important knowledge including for their
professional careers so I started to
realize but how can we teach these
things and and so these are things that
we are kind of that we know after maybe
20 years of programming experience we've
been exposed to a lot of these different
styles a lot of these different ideas we
gained a lot of baggage is there a way
that we can kind of package this and
teach people how do we do that right how
do we teach people monads coming from
the previous previous talk without
teaching them category theory right how
do we Manas independence category theory
they are really interesting you know
cute little stylistic while you're
thinking about dividing things and
putting them back together right so how
do we teach that and I'm talking about
Nona's we could be anything
actor style you know Map Reduce things
you name it you know everything that we
come into contact as we develop code so
that was my problem how do we
communicate this I didn't know and then
by chance one day that I was thinking
about I was actually googling I came to
the word style because I thought it was
an interesting word and I Google I think
I good programming styles or something
and this came up this author came up
this is does anybody know Ramon Kano
one two three people okay four people
all right
so it's an interesting writer from 1990
he about 1940s a French writer he was
part of sort of disc
group of intellectuals in in Paris
writers mathematicians musicians you
know the French style kind of so and he
wrote this book called exercise in style
that I immediately ordered from Amazon
because it had exactly the right title
and and and and and I was really like it
blew my mind so thanks exact it's
exactly what I want right this is if I
was studying to be a writer professional
writer I want to do this and basically
I've let me tell you what this is this
is a book that you know that takes a
very little stupid little story it can
be told in two paragraphs the soul is
completely trivial there's nothing
interesting about the story some guy who
takes the bus and notices some other
person on the bus and then later on
meets that person some plaza and that's
it that's the end of the story but he
goes tells the story in 99 different
ways right in different kinds of ways of
telling the story so it tells a story
with metaphors lots of metaphors
surprises lots of surprise it's very
precise you know your name there's not
he actually doesn't name the styles but
as you read through you can immediately
see what you know you can get in defy
some elements that he uses that makes
the story different from each other
because they have different renditions
of the same story so so this is like wow
this is exactly what I need right I need
to find a stupid little story through a
program that everybody knows how to do
the program the algorithmic complexity
should be out of the way everybody
should know how to do that and now let
me illustrate the wonderful rich history
of programming ideas and just with the
exactly the same program and hopefully
if I could pull it off with exactly the
same programming language so that we
remove any variability out of it of it
of the problem and the only thing that
ver eyes are the ideas for how to divide
things and put them back together right
and how our you know our the stylistic
ideas of the problems that you encounter
out
how you can solve them so one of the
things that Ramon Cano and his group of
intellectuals in France did their big
thing was this the entire definition of
style the definition of style actually
was quite technical style for them was
something that emerged after you impose
certain constraints okay so let me give
you an example
does anybody has anybody read this book
avoid in French is this Parisian okay so
this georges perec
was one of the people in this group and
what's interesting about this book is
that well the history itself is
interesting actually history of some you
know actual story if somebody could
disappears and something but more
interesting than the story is the fact
that the book both the french version
the original French version and the
translations that I read of English
translation was entirely written without
occurrences of the letter e okay is the
name but so you can imagine that if
yourself impose a constraint like that
right there
ie being such a you know a dominant
letter in almost all the languages
you're going to fall into interesting
idiomatic expressions very strange
idiomatic expressions that you normally
wouldn't use because you have to avoid
words like the for example you know so
it the whole book feels a little bit off
that something is missing because of
these constraints so that's their idea
is that the idea is that style is not
something that you you know it's not
related to inspiration or omit is
something very technical you just put
stakes on the ground what is it that you
can do is it that you cannot do and
style is what emerges after you try to
do something with that of those
constraints I find this idea brilliant
okay it's very simple it explains a lot
of things also for us
so basically this is exactly what I
didn't copy I just copied this idea so
here's my story my little story turn
frequency which is take a file a text
file parse it into words count the
occurrence of the I also added the
exclude the stop stop word so you know
exclude like the things like that they I
have a list of stop words a single
letter words also excluded and after you
exclude us you count your currencies of
old words and write out the 25 most
frequently occurring words right so
everybody knows every undergraduate
after a year of programming knows how to
do this right so algorithmic complexity
is non-existent and and so if you if I
thought if you feed it through private
prejudice which is my test book you'll
end up with something like that okay
this is the output so I give this to all
students here's the out piece your
output of your program so there's
there's nothing more to it so the book
itself goes into is divided roughly into
nine so as I wrote the book in I didn't
to 99 different ways otherwise I would
never finish but I did 33 and it doesn't
mean that it that I covered everything
with 33 in fact there's some more that I
thought about that would be really nice
also to have but I stopped after I
impose myself a time limit for
publishing the book I so I grouped these
33 different styles into roughly sort of
things that are related so there are
historical styles that cover things like
you know the old times machine learning
when you didn't when computers were not
very powerful and you can had to worry
about memory and things like that and
basic styles are things like procedurals
the basic functional approaches and
things like that there's a object and
different types different ideas of
objects and object composition
reflection adversity there's a part on
data centric styles which I like very
much
concurrency and then some styles for
interactivity so so these are all sort
of roughly the nine sort of groups of
styles in those 33 so I'm going to do
for the rest of this talk is I'm going
to just pick some few of them out of out
of the book and just go through them
okay
just so that you have an idea so you all
know what the task that I'm doing turn
in frequency okay so here here we go
so this is style number three nap in my
book I think if I didn't if this is in
sync you don't need to zoom in this is
the it's good that you see it zoom out
this is the entire program by the way I
use Python in the book the base language
for everything even you know obviously
some of these styles are not - stylistic
right I'll show you which one is the
more spiteful month but I just use
Python as the common language so to
remove any complication about syntax and
things depending depending on the Styles
imposed by the languages or not just
python is great because it's just really
very agnostic to a lot of things okay so
this this one is one style and you see I
let me zoom in a little bit over here
you have on the top there's a couple of
sort of global variables in a way the
state some state in there you have
stayed for though for actually computing
the word frequencies for you young out
the stop words so so the word frequency
the first one is the one that actually
accumulates the pair's word frequency
and then you basically go into a nested
loop iterating through the lines of the
file and in each line you iterate
through the characters of each wine and
then you might imagine what goes on in
here right this is basically logic for
identifying the beginning of a word the
end of a word checking whether the word
already exists in the in that dictionary
that it's not even a dictionary but
so that's basically the logic control
flow that's over that's going on in here
that's sort of Allah and so Irene
so I'm supposed to go away so all the
punctuation goes away that's part of the
specification of the problem so alright
so so let me tell you just by your
looking at this layout over here if you
were to want people to write code that
looks like this what constraints would
you tell them no no obstructions good
maximum nesting maybe no return
statements yeah no comment
yes there are some comments in here
don't load the whole thing memory that's
it that's a good that's a very good one
that's a very good constraint that's a
very interesting constraint that that
actually resulted in in this kind of
style being one of the earlier styles
right we we got this style because the
earlier computers could not hold a lot
of data in memory right so we this this
is not that this is not the style in my
book that represents that better the one
that represents that there is actually
style number one which is exactly that
but this one also gained frenetic
storico background that you kind of you
cannot hold you should not hold the
whole text book in in in memory so it
only holds a line at a time which is an
interesting constraint right so but yes
so basically it is I I've heard so it's
basically no abstractions no no no
functions either you are all or others
right you're just doing everything here
and right now and then and and and
another constraint might be that you
have to be very careful about memory
right so do you only hold a little bit
at a time so that might be constraints
that you might
to people and if they observe those
constraints they will end up with coal
that looks like this right and you might
think well this is this code is horrible
and and probably you might be right for
this particular problem but on the other
hand you know there are certain
circumstances where in fact you need to
worry about memory consumption that this
is the thing that you just need to do
right so yeah I'm being relatively
agnostic throughout the whole book I'm
trying to describe what what's good
about this and what's bad about this but
trying to stay away from giving very
opinionated prescriptions about you
should not use this so you should use
this right so yes no abstractions no is
a valuable function so I I call this one
the monolithic style and and the reason
is that if you try to observe these
constraints you end up with a lot of
importance on the control flow and the
logic of what needs to happen because
you're really sort of constrained over
there right you don't write it in sort
of sort of a higher level of abstraction
but you write everything down there it's
too low level so you end up with control
for being like the dominant action going
on in here alright so let me move on to
another one and this is style number six
this is it okay this is the entire
program so it's so much thought that I
can actually zoom in and you could you
will see the whole thing alright so here
it is I'll let you read okay so I so so
here's the thing I did not write this
program I wrote a version of this
program that was actually much uglier
than this and I had it on my github
account and one one day one morning up
on my email and had it an email from
Peter Norvig and I was like what what
are the most interesting emails that I
have ever received my career was just
like I eight lines of Python code okay
and the first two were comments and the
comment was -
shorter this is his this is a this is
his version of often frequency which I
found wow this is absolutely this is
beautiful this is what you write in
Python basically this is the Python
mystic way of doing this so you
basically you open you get the stop
words and then in one single line you
you read everything out of the text file
you normalize to lowercase you have a
regular expression that filters
everything out of that everything that
is not an character you know a letter or
that is less than two characters that's
what that regular expression does and
then basically you and then you use that
very powerful collections library then I
wouldn't know it existed right so Python
is a really good collection of library
that almost there's almost everything
for us already right so it just counts
the currencies of of the words that are
not in the sub words and then you just
it spits out the most common 25 already
has that function most common right so
this is absolutely beautiful so just out
of curiosity the version that I had it
was really ugly which by the way was
also not done by me it was done by
someone who's here at the conference and
he gave me the solution the first time
that I presented that is a few years ago
but this is slightly uglier in that it
doesn't use the collection library so it
has to use some like hacks in here with
the sorting how to start to to rank the
words the word frequency and this is
lamb that compared its comparison over
here and this not only is like Leah but
it's super slow because basically every
time that you want to rank some word you
have to count everything again it's just
like absolutely horrible okay you run
these things it takes about ten minutes
to process the you know Pride and
Prejudice so um anyway so but it's short
right so if I already told you the key
if you were if you wanted somebody to
write code like this what would you tell
them what constraints would you tell
them
concise as possible right is few lines
of code that's possible or as you know a
few characters that's a version event so
I already heard the term the term that I
called this style the code golf style
right so yep absolutely
yeah ask that's very good observation
absolutely you could reduce this to
online if you already had a library that
does exactly the term frequency
specification then I said it would they
would be split into words yes so so so
basically you would say a few lines of
code as possible also an interesting
thing of this style and some constraints
that you might want to to express his
you reuse or use as many third-party
library functions as you can or car
library functions as you can write use a
radical that's already that does already
what you need right that's a style and a
that's an option many cases that's a
very important decision that people in
companies have to do should I write my
own or should I use something that
already set somebody else already done
right that's a really important
strategic decision and you see it those
kinds of decisions Ethernet is small
micro program level two it's the same
decision and it's pretty much same
trade-offs right
okay so code code go of style or try try
hard style also okay so stars number
four your magic for Python yes
yeah yeah but that's kind of a moving
target anyway so let's go to this one
let me just zoom in this is about a page
and a half and you will see what is
going on in here there's a pool of
shared data over there there's some
division of tasks going on in here and
then the main methods over here says it
all it's basically you know refile
filter normalize scan remove stop words
etc right so you've seen this before
right
you all seen code like this before right
there's a pool of shared data over there
there's a bunch of these procedures over
here and and the whole program consists
of basically issuing commands that
transforms the shared data do they stand
do that's like is like a recipe right we
this is a style that was very much sort
of at the center of structure the
structured programming movement
structured programming as opposed to and
structured kind of go tools and assembly
language it was easy this is sort of the
beginning of thinking about dividing
things neatly so again think about
what's really at the core of writing
programs in this style what would you
tell people mutable state yes no no I
yes no argument sorry no composability
no return values okay like somebody's
 me five minutes I have a lot of
stuff to go through
let me go through some my interesting
ones so it's basically what you all said
they basically the larger problem is
solved by dividing it into these
procedures and you have to explain what
the procedure is and and then the
computation proceeds by applying one
procedure after another like a recipe so
this is a very sort of natural way of
programming that we kind of a lot of us
kind of grew up with
and like oh I'll call the cookbook style
nigo - this one this one is almost the
same almost with some important details
and I must I must apologize because I
had to shorten the the names of the
functions here because they were I was I
really wanted to put it all in one line
and they didn't fit but I think that
supposed to be you know the shortened
versions of those names over there okay
so you kind of all recognize this style
yeah so is it sort of functional style
ish so the idea is that you divide the
problem there's no global state okay we
got rid of global side yeah is that the
problem is defined it's subdivided into
smaller problems each one maps to a
function as in a mathematical function
you take input and you produce output
that's it and the way that you compose
the program is by by the by composing
functions as in mathematical composition
of functions that's basically what this
is over here and just for fun I just
decided to put the other the very last
thing for printing out I decided to go
out of style and just print it out in a
loop but that's just just to tell you
that I'm not completely obsessed about
about style so so this is this is
another one so you just have to explain
this idea of designing programs as
compositions of functional abstractions
you have to explain that actually these
tries to mimic the idea of functions as
in math and and then that's how you just
proceed from there so I call it the
pipeline style I didn't call it
functional style because I got into all
sorts of trouble when I try to call it
functional style but but you pipeline is
the I think a fair word for this um
alright so okay this one is a cute one
I'll just go I'll just just look at the
signatures of these functions okay and
of course material is here so you'll
know but yeah who dares to tell me what
this CPS yes
continuation passing style right which I
absolutely love that the people who have
been doing functional programming have
the right word for this this
continuation passing style it's
style of writing programs right it's a
style of of organizing your code and
they have the right word many years ago
and so we basically I don't need to
explain this because half of you already
know and let me move on I'm time limited
here basically take another take one
parameter it all these functions
additional parameter that is called at
the end all right what is this okay just
just pretty much pretty much this is
this is basically so I can go to
describe what this is but you can
already kind of see right you divide the
the problem into these entities and it
tend to be entities right they tend to
be nouns and you have end up with all
these managers and counters and and
things like that and controllers and and
and and so each one has their own
methods and each one can encapsulate
data that you're supposed to accessories
through these methods and not so you end
up with with with with the
object-oriented style that is very much
Java flavored so in my book I actually
have very many flavors of objects
there's not only one flavor object at
all right if you go and in programming
Java Script she's also an
object-oriented language you have a
completely different flavor of objects
right so there's also style in the book
that goals that covers more of the Java
style the Java Script style of objects
alright so which one is this one I'll
skip this one this is another version of
of of objects that is more like actors
like objects so this is idea that the
objects intrinsically only expose one
thing which is give me messages right
and then there's a dispatch method
inside them that dispatches the messages
okay so this one is fun
okay and it will give this the plus part
will give you all the way this is the
main method okay
my producers right and and turn
frequency is a wonderful problem because
it can be crisp it can be done in so
many ways there's like no ending for how
you can do MapReduce it's the most
flexible problem ever so MapReduce
there's variations of MapReduce - of
course you have to explain these
abstractions of map and the session of
map and obsession with reproduction and
you know if you want to people to write
programs like that and in this
particular case the problem needs to be
amenable to this kind of treatment right
not all problems are map reducible
naturally okay this one's also fun
so what's going on in here what's going
on in here is that now you're the
different kind of context right so I I
told you that I wanted to do term
frequency but maybe what I really meant
is that I want to analyze my data and
one of the analysis that I want to do is
counting the words of the file but maybe
I want to do other analysis and bounce I
don't know which ones but in the future
maybe I want to count the number of
words with these or the number of words
in which the you know two vowels occur
or something like that okay so now the
problem is slightly changed and I mean
in the sense that I've decided that
maybe I just don't know everything that
I want to do maybe the data is more
important and this is by the way part of
the data centric styles of the of the
book maybe the date is more important so
maybe I should pay more attention to the
data and how to represent the data so
that it's a mean able to exploration in
the future that's where these these
kinds of relational models come from is
that the data is actually more important
than the computation that you make on it
and so in this particular case of sequel
you kind of have to figure out well if
you want to explore the data in sort of
open-ended ways maybe having the data as
a flat text file on disk is probably not
the best way so maybe you need have to
have a different kind of representation
for your data
so let's parse the data and put it in
this interesting relational model that
is amenable to these queries relational
queries that are really nice and so
that's what's going on in here you just
parse the file put it in a bunch of
tables I have here a table for documents
a table for words in the table for
characters with obvious relations
between them and then you can and
there's one sequel query that does term
frequency for me that's this one over
here okay sequel is great so in order to
to end up with with with programs that
look like this you have to explain a
little bit of these this idea of where
does this come from and why would you
want to do this and and what what is
this idea of having a query engine right
because because you need a query engine
and you also want to have the clarity of
queries
all right so in other word in other
words I'm coming to the end of the
talkers I haven't represented that you
know five or so 33 I didn't even present
my mmm the ones that I like best one
that I like very much is the spreadsheet
style okay and this leaves you as an
exercise for you how would you do term
frequency in Excel okay exercise for you
for this evening so but the take-home
really is that there are many ways of
solving the problems and in particular
the problems that I was most focusing
here is the problems of writing code and
and in particular not so much the
algorithm which there's lots of
interesting things about how to code
efficient algorithms and all that stuff
you know that's great we know how to
teach that there are text until a lots
and lots of text books about algorithms
and data structures that's great what we
have not been paying much attention is
how to actually write the code that that
both does those algorithms interacts
with the outside world interacts with
other pieces of code right so any
particular what where I think that sort
of I have zoomed in for a long time is
how do you structure your thoughts
basically how do you structure the code
how do you divide the problem how you
put it back together there are many ways
of doing that many many different ways
and I would like people to have a very
large spectrum of these ideas on the
back on their back pockets when they go
out to work in industry because they
will find these things in the code that
they will encounter that already exists
and they will probably need some of
these things so as as they write the
code they need to understand that there
are these constraints that their
co-workers have been operating when they
join they need to understand what those
constraints are and how how to rights to
those constraints they need to be able
to talk about different kinds of
constraints and negotiate them well so
so all of these is really what I where I
believe is the core of programming and
program and teaching programming and
actually people know how to program
being comfortable with all these
ideas right knowing how to apply them
knowing what they're good for what
they're not good for and not being stuck
in just one way of doing things we
choose what I saw in my skin those
students coming into my upper division
courses the ones that had started with
Java they were completely stuck in Java
the ones Harry I started in whatever
they were completely stuck in or
whatever is just like you could see
right in there was this lack of
flexibility and their thought about
programming that really really kind of
scared me and like we need to fix this
right need to stretch people's abilities
and skills work for and this is really
what I think is the core of programming
basically independent of algorithms and
the wonderful things that we do with
with programming so that's it I am you
can contact me either at UCI or can
tweet me thank you
so there's times time for questions
really interesting absolutely that's
what that's what's my conclusion to I
mean I I felt that we needed to do
something we're not teaching people well
if we're just teaching them one way of
dividing the problems in you know that's
it's just terrible because there's so
many ways so wouldn't you say that in
most cases if you do understand all the
requirements there is actually one right
way to do things maybe maybe
I mean maybe so yes so this I mean the
the example that I give here and and the
the data file that I give as an example
which is the pride and prejudice book
it's sufficiently small that you know
the the problem is so constrained that
says Peter Norfolk's way is probably the
best way of doing this in Python there's
no question but if you think not about
that now you've actually processing many
books not just one book you're
possessing millions of books now Peter
nervous style doesn't actually scale too
you know you can do better with things
like MapReduce and things like that
right so but but but yes when you were
able to constrain the problem so much
that it's very clear that there's
there's only one way to do it then
there's only one way to do that's the
only one best way to do it yeah yes but
it was the impact on your teaching Wow
how did the students react to that so I
I created a course based on this book I
teach it at upper division so basically
seniors and thereby the seniors and the
younger graduate students to the course
is basically the same except that ready
students also need to read the
historical papers where all these ideas
emerged but the course goes like this
it's ten week and every week they have
to do an exercise and the exercise
consists in taking these a couple of
these exercises and writing them in
whatever other language they want so
except Python which is already here so
you know write them in Java write in
whatever and and so it's it's been I
taught this course already several times
now maybe four times and so I've been
teaching for 14 years usually the
students like me in general I mean I
have a good I have tend to have good
teacher you know student evaluations but
for this course I've gotten consistently
the max because
really really love it and the the
comments that I get is like wow it's
like they are the students are ready
they are at the point that they're ready
right there they know enough about
programming that they don't get tangled
up about how do I read the file but but
when they are ready to kind of try to
explore other things so so this has been
really very successful the way that I
know my experience in teaching this
material so that has been my experience
they like it sorry
this is not actually a question just a
comment I would like to share with you I
have been thinking in how to teach a
style for a few years also I have also
read the elements of the style and think
about it from the same point of view so
I think that styles appear as a solution
to very precise problem so when you have
one problem you develop one style when
you have another problem you develop
another style and in the university we
are teaching solutions without
presenting the problems without maybe in
the students suffer the problem so
whenever you teach the solution to a
problem that that person has never had
then the solution come by one error and
goes by the other without any kind of
opposition so actually I will think that
actually teaching the problems and then
that particular solution will improve a
lot education system I agree well I I
think more than the problem is actually
the constraints if you just make the
constraints explicit the students will
find well they will have then they have
no option but converge to these styles
they will have no option because they
have to solve the puzzle right I say you
cannot do that
oh okay now I have to do it the other
way now I have to think right so it's
it's like they will find it eventually
so the question is if if I think that
there are some stout that are more
useful than others or that the students
like more than others or that they are
more useful for industry for their
careers in general so those are
different questions so depending on the
students and how comfortable they are
with programming the I've seen that
there's two types of students that go
through my courses there's one group of
students who stick to the other only
other language that they know so this is
all in Python but so if they know Java
they do the whole thing in Java and then
there's another group of students that
take this opportunity to actually learn
languages that closely closely match
these styles right so there's two
different kinds of students with respect
to the the cells that I think are more
useful what I've heard from from
students they really really enjoy
learning about the concurrency styles
and and the MapReduce styles and and the
data-centric styles too so the more this
one store is more than the second half
of the paper and the I especially the
master students that take this course
some of them are professional you know
they are professionals they work in
companies and they they they seem wow
you know this is exactly kind of what I
needed to consolidate things that I see
in my work that I hadn't really take the
time to think about it before so the
more the lighter ones of concurrency and
and data centric ones so you're just a
quick comment on getting back to the
comment that there is there was one best
style and maybe timotheus is common as
well so maybe that style came about
exactly from the ability to combine many
styles or understand have a wide
understanding of different styles and
different paradigms so yeah I think it
right I think it's important that it's
important to understand all what are
your options right without if you don't
know what your options are chances are
that you are kind of shooting in the
dark you're just going with what you
know and maybe you know maybe the domain
of what you're doing is so narrow that
what you know is all you need that's
great but in you know if for for most
people
who switched our minds or will do
different things they they end up
encountering problems that they haven't
encountered before and if they're not
aware of all these other ways of doing
things they chance that they make the
wrong decisions in their code ok so I
think we have to wrap up thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>