<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Francisco Sant'Anna - Structured Synchronous Programming - Curry On | Coder Coacher - Coaching Coders</title><meta content="Francisco Sant'Anna - Structured Synchronous Programming - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Francisco Sant'Anna - Structured Synchronous Programming - Curry On</b></h2><h5 class="post__date">2015-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aivVg9WMuMs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I will talk about structured
synchronous programming in the language
cell today our focus on mixing control
and data flow in the language before I
will start with a simple example here I
want to blink a lad like this so in cell
i can write an infinite loop that awaits
500 milliseconds change the state of the
lad and rich stays in this loop forever
then i want to stop blinking after a
button press so after blinking i press
here and it will stop what i can do now
is to enclosing equals the blinky
behavior with without modifying it with
a parallel composition that we will also
wait for a button press in another line
of execution and here i'm using the or
composition so when either of the two
sides terminate the the other side is
automatically aborted and the whole
composition we joined going to the next
line and now i want to restart
everything after 2 seconds so i blink
then I press the button it stops and
effort after 2 seconds it restarts so
after the composition rejoins i can now
await another two seconds and in close
with another loop that will restart
everything so the idea here is to lose
to use control compositions sequences
loops and parallels and avoid the use of
state variables and explicit
communication between lines of execution
so this is a very good specification
through to write in this language is all
about control and you see no data in
these programs only control ok so today
I want to discuss how to mix data and
control flowing in programs using cell
so I propose another specification here
I want to control the ball inside the
screen I will click them out
to start the ball will start moving one
direction with an acceleration and
whenever I click the mouse it will
change direction clockwise so I start to
I click to start it's moving and I click
it changed the direction restarts the
acceleration always clockwise so this
program has a data flow pattern the
position depends on the velocity the
velocity depends on the acceleration we
have dependencies also between these two
behaviors and it also has a control flow
we have abrupt changes in the clicks
that break these continuous functions
here and these discontinuities suggest
some form of explicit stating in the
code so here is how we can write this
program in cell we have two inputs from
the environment one is the time between
frames and the other is the mouse that
we click the button that you click in
the mouse and we define ball with
position and the radios we create a ball
somewhere in the screen and then we will
await the first mouse button click to
start to start the animation we have
velocity and acceleration then we
iterate over the frames and will
calculate the velocity according to the
acceleration we do the same for the
position according to the velocity and
then we just need to put these behaviors
in parallel and we have the animation so
you see here the data flow in the
program and the dependencies but of
course this code here is is too lengthy
and low level we have it also relies on
mutation which is not really a problem
in the language because the scheduling
is deterministic is sequential we follow
the Alaska order of the code for the
await expressions but we can use some
form of abstractions here
so we will create a class that that's
integral over time we have an
accumulator and the value that we will
accumulate and we are basically hiding
this loop inside this class so these
abstractions they have an interface with
fields and methods just like objects but
they also and we pass the arguments in
the constructors here just notice it
here that we are passing by reference so
we can change from inside the arguments
and the abstractions also have an
execution body that we can write any
coding in the language including these
parallel compositions and we equality
these abstraction organisms but they are
really similar to the original idea of
objects in similar data that also had an
execution body but here the important
thing is that you organisms they can
react directly to the environment
they've not depends on the main
application for with cooperation between
the the organisms or some feeling of
events likely having it in the observer
pattern we just do directly so we can
now use the create the animation using
the abstraction again we await the mouse
button we have the velocity and
acceleration and now we declare two
instances of this integral over time
they just normal variable declaration
notice here that they are anonymous
because everything is happening inside
the execution body we don't need in this
case a reference to these organisms and
when we have a declaration for an
abstraction the execution body starts to
execute in parallel with the Block in
which they are defined you have a
question
it's an input event that comes from the
environment following the frame hates
that you you want it depends on the
application so next frame is that
something in the library or something
you've declared yes you need some
interfacing with a library in this case
is a game library or something like that
so it's the same kind of thing as mouse
button yes okay yes and what kind of
thing is dt dt is the valerie that has
elapsed it between two frames okay so if
you want a frame rate of 50 milliseconds
fifth-ranked first icon this value
usually will be 20 milliseconds but can
be 19 or 21 and if I had said every dt
in mouse button do then what kind of
thing would dtb would be the button that
you clicked left your right for example
okay so I should maybe understand those
as a kind of stream of events and then
when I say every something in that i
bind the individual events coming out of
the stream exactly thanks you probably
need that of course the documentation to
know what the event is carrying thanks
so whatever come next the three dots
there is the organism body is executing
implicitly parallel with that okay and
hearing this example I just I will just
move right so I await forever and these
things are happening implicitly just a
second now i have the same behavior but
just moving right because i didn't write
the rest of the code how does it
actually execute these things in
parallel does it does it require some
synchronization because you are changing
the values in one parallel block the
same value in one parallel block and
reading in the another one yeah no it's
it's that this is related to the
synchronous execution semantics
basically when we
we awake if two things oh aight awake
for the same event we awake them in
sequential order we follow the legs co
order in the code and we execute the
first one then we guarantee that we will
wait again so we do not run forever so
it basically works like the event loop
in Java Script and so on ok thank you is
a similar semantics so now i want to
make the turns again i just await the
first mouse button and this is the
exactly the same code as before but i
will not await forever I I want to to
move down and basically i will copy and
paste this code and i will change the
arguments here ok now i want to move
vertically and you see that this will
not work exactly as we want when i click
the mouse you see that the previous
dependency is too alive i'm moving in
both directions right because the
dependency is still alive it is true
running in the background so what I do
here is to this is the dependency that
is to alight I will enclose these
dependencies with an explicit scope so
for the DISA matrix for organisms is
that when they go out of scope not only
the data is reclaim it but also the
execution body that is running
implicitly in parallel is automatically
aborted so you have lexical scope for
execution as well in this case this is
the lexical scope and when I awake from
the mouse button it will go out of scope
so the dependency will be broken and
this is how we can mix data in control
flow in the language basically using
control flow to change the scopes and
this idea of organisms to have something
hidden in the abstraction so closing the
loop I just stop and paste right
down left and up okay and of course
again this is Lady code but regular I'm
just changing the arguments again so the
velocity and acceleration so it's
possible to abstract reached another
class and here i have a class move until
button is pressed and I will hide these
this control flow inside this class and
now I just leads to the class declare an
instance of this thing in this case i'm
now i'm using a and I identifier because
I wants to await the execution body to
terminate when I click the mouse I want
to continue it so I need to away to my
my termination this is a common pattern
in the language so we have a syntax
sugar let me just say do the name of the
class and the arguments and it's exactly
the same as the previous block shows so
the full application we have the inputs
the abstractions and the data and
finally the control flow now is much
smaller we await the first mouse button
to start and we do the movements in the
four directions with a look to to
restart any questions ok I showed very
low level abstractions to hide that loop
but I can also of course move to more
high-level abstractions now I want to
have two players so each one I will
control with a different mouse button so
this one I'm using the left and the
other one I'm using the right button and
now you see that I i will use the the
value of the input ok
the mouse button carries the left or
right information about the mouse click
and basically I will hide the previous
control flow inside the class player it
will receive the ball that I want to
move and also the button that I wants to
react and then now I need to change the
previous class to also receive the
button that I want to react to and now
it's here in the interface and basically
now I say I will await the mouse button
until the the mouse direct click it is
the same one that I'm expecting from the
constructor and I will in this example I
will not do anything else I would just
have both balls reacting independently
one for each player any questions here
your argument is of type int the button
yeah but it's really a stream of ins
right yes is that distinguished at the
type level or somehow when that thats
related to his question if you want to
handle it as on the string we use the
every construct because we want every
single occurrence of that event but
sometimes i just want to react to one
instance so i just say oh wait that so
it can be seen as a stream or as a
single occurrence it depends on the
context of how you use it so you could
also use it like an integer literal as a
stream and then it only has one event or
or multiples or like like if i put a 5
and as an argument into this player what
would happen where would I damn it but
this is in the library the library of
say I passed an integer and the integra
means one is left 0 is right and true
with middle so you you you have to to
look at the interface of the these input
events everything that has an input
comes from outside I'm not controlling
it inside the program it comes from
outside okay
but isn't the distinction between an
individual int and a stream events
whether you say input of our is that is
that the case or I didn't understand it
yes so in the in the code you have mouse
button there is a stream of button
events right yes whereas button left is
an individual click of a mouse button
right yes and and so the difference
between those two is that one of them is
declared as input and the other one is
declared as VAR right yeah here is not
the name of the the the stream is a
value of that string right so it's an
enumeration yeah okay because i think
that the previous question was was
assuming that button left in fact was a
stream when I know it's not it's an
element of that street it's an element
of that sorry I didn't understand okay
so there's this distinction for data
flow we have two general approaches pull
and push data flow and in the pool
approach when we want to compute
evaluate we continues read from source
values and do the computation that's
that's what we did in the integral we
have a loop inside the integral that
will read continuously the dependencies
and recalculate itself but we also have
the push approach in which the source
value will notify of its change and
anyone that wants to compute something
can listen for those changes so I
propose to hear another example that we
use the push approach I will extend the
two player controlling in the ball and
now our random food will appear on
screen periodically and when a player
it's the food it will increase the
radius and we have a constraint that the
sum of rages is always constant
so if you want increases the other will
decrease and we restart when any one of
them reaches zero so now you see the
food I'm controlling one of them and it
will increase and I've at some point the
other one will reach zero and we will
die okay so that's it so what I propose
here is to build a dependency graph at
runtime using these classes so event is
an internal event mccauley mechanism I
can emit and I wait on these internal
events and here i will create two
instances so basically we have two nodes
there and what I do is when someone
emits something when i omit something in
my output event I want to also emit in
the input event of the other node so i
will create a dependence here like this
and i will do the same in the opposite
direction and i will put them in
parallel so the dependencies are alive I
still need so i will await something my
in event and i would do something and i
will meet something in my output event
okay that's what is two missing is how
to close this loop and this is this will
happen in the player class I now pass
each player a different note to control
and inside this node when I have
received something in my input event I
will increase the radius and will omit
the opposite value in my output event so
now basically i'm closing this loop here
I mutate the radios with some
thing v that I receive and I pass minus
V and the balls they don't know that
these dependencies happy existence is
that is declared outside it so but we
still need the initial stimulus that
happens when we collide with with the
food so this is the general structure of
the game it's the code is almost exactly
like this so i have i will restart every
time one of the two players terminal
dies then i define the two nodes and I
linked them as i showed in the previous
slide I have both players defined here
and then food is also an organism it
will appear somewhere in the screen but
it has an execution body but because it
will disappear after after some time out
so it also has cold inside this and as
they you'll be created dynamically I
need a dynamic pool to hold all
instances that I will create and this
pool also has lexical scope so when this
pool goes out of scope all dynamic
instances will go out of scope
implicitly so these watching construct
here we abort whenever either of the two
players die so basically anything that I
put inside this block will be
automatically aborted when the instance
dies and that will what make the loop to
restart and everything be recreated in
the game including the pool and now I
just say that every random milliseconds
I will spawn a new food so this is what
the keyword to create a dynamic instance
and I specify where these dynamic
instance will live and in parallel I
will check collisions every frame so i
will to rate over the foods so this is
also
iterator in the language i get all foods
that are on screen and i will check for
collision against the two players so
this code has to be duplicated for each
player and if it collides with the
player now i will omit the rages of the
food into the denote that will make the
dependency trigger and i also say q food
that because i want the food to be to
leave the screen and leave the the pool
and now this is what actually close the
loop yes did you have to take any kind
of special consideration for these
dynamic elements and how you clean them
up after you know their garbage
collection do you get rid of them like
how does does that come into play at all
when you do this kind of synchronous
programming so there are two ways that n
constancy can be reclaim it it's also
always static memory actually how we
reason about it there is no garbage
collection so the first way is with the
lexical scope of the the poo so whenever
I make an iteration in the loop the pool
will go out of scope so all instances
will be collected but it's lexical its
static and the other way is if the
execution body of the the organism
terminates so and in this case it will
also be a go out of skoo automatically
and the language when we are dealing
with pointers the language we will force
that will you handle the case that the
pointer terminates with these watching
construct thank you yes
this is this is a good question the
question was i have i have a loop a
dependency loop here so why it's not
when i start on a trigger the first why
we do not be forever that's Christ right
so let me go back so the event is a
primitive in the language of course and
it it follows a stack execution it's not
Q is an execution so when I amid
something suppose I am it here in my
output I will not go and oh it again my
input the continuation here we'll go to
my stack and I await everything to react
to this specific emission before I
resume the execution so what will happen
here I will emit here and it will be fed
into the input here so it will awake it
will be meeting the input of the other
one so the other one will awake and will
emit in the output it will do it again
but when it emits in the other input I'm
not waiting here yet because I'm held in
the the first continuation so I break
this cycle exactly exactly
it's clear how the semantics I don't
know if it okay so these are the two
examples i want to show about data flow
so synchronous reactive languages are
something very old there are two basic
original research that started the
concept of synchronous reactive
languages one is esta hell and the other
is luster and we saw in the they are
from similar groups in in France and we
saw in the late 90s we functional
reactive programming a lot of new work
appeared in the in this side here in the
declarative and data flow synchronous
languages libraries languages and
frameworks and so on and but we did not
see this trend in the other side in the
esta health side so that's why we we
created sell just as a modern and focus
it alternative to to synchronize
reactive languages and and today
basically I tried to talk a little bit
about how we can reconcile these control
based languages with dataflow ideas from
declarative languages and so the main
design guidelines that we had in cell
with the trade-offs the first one is
that we chose structured programming
very imperative and clear of about how
the control flow should execute we
promote side effects everywhere but we
rely on sequential and deterministic
semantics that helps understanding the
side effects everything in the language
has an explicit lexical scope and we
enforce that abortion of these scopes is
always safe I did not discuss this today
but there is paper that discussed
that and another thing that I didn't
mention much in these examples is how we
can also force bounded memory and
execution time for reactions to to the
environment I think I'm done minutes of
discussion I'm actually
could you speak a little bit more about
the static memory management you like
enforce a tree structure and all the
objects because clearly you have some
dynamic things being allocated like your
food in random sites before sure so
first the parallel ISM here is lexical
so at compile time we know what is
running in parallel with what and what
is not so basically if things are in
parallel they have to be in them in the
memory at the same time if they are in
sequence of course they don't need to be
at the same time for dynamic instances
we have two variations there i define it
the pool with the brackets and I didn't
specify a limit there so in this case
the instances go to the hip but they let
the control of memory is still based on
like the lexical scope if it the pool
goes out of scope all the instances
grower of out of scope and and the
memory manages this but we can also
specify a limit there and in this case
it's really static we know the whole
thing at compile time so as we use sell
a lot in the embedded systems this is
very important to specify an upper limit
cuties of collaborate on my teachers
effects
in silent satellites are specially
trained so basically because we usually
we started for with embedded systems and
the interaction with C is like is the
rule if we don't have C we cannot do
anything and we have a lot of calls to
send this message over the radio and we
have to pass a buffer so the interaction
with see I already implies side effects
so what we chose that I also didn't show
here is how to do safely with that we
the language knows the type signatures
of these calls and if it's passing
pointers around you have to write
finalization code that will clean up
when it goes out of scope that's what I
meant about safe abortion so and I also
think it's more convenient I'm I like
side effects so so i have a question
again yes if so just just to help me
understand the way the language works if
i wanted to write say a chat server or
something in it as opposed to a
graphical one where i have a kind of a
state that's accumulated over time and
then multiple views into that state for
example multiple people who are writing
to each other and appending to the log
of the chat server how would that look
in as far as the structure of the code
goes so probably you would have an event
to to represent to the request so and
you would have every construct to react
to doll all instances of these requests
and then we found a dynamic instance of
the handler to handle that specific
request and that would be hey what do
you mean by request in this case when
you are dealing with communications
probably you want to request something
give me the next message or write these
this thing in the database something
like that so request is basically
something that you have input
and you also expect some form of output
or may be late but but but what I'd want
to do with within this kind of a setting
is right the client such that I don't
have to worry about going out and
pulling the server for messages as often
as I want right i mean i think that the
incoming state of the log should be a
sort of a stream of vlogs whereas things
are appended by other clients my view of
it sort of updates itself yeah yeah so
I'm not sure about exactly what is like
I can say that again you have some form
of input events to represent something
that is incoming it into your system and
basically you use some every or a weight
or something like this to awake and do
the work only when the request comes you
are not appalling and how do I represent
the fact that I have this sort of append
only log and I don't know exactly what
do me I mean I'm just I don't know the
language at all right so like it so I
want to define a linked list and I don't
have a stream of linked lists where
people are sticking things on to the end
of it so you probably write some coding
see in these in these gifts so I
couldn't express that in a pronounced
name language so so so okay yeah we
don't have any like more complex types
we don't deal with them we delegate for
the host language that nowadays we only
have see okay but potentially you could
build a cell on top of another host
language and if these language supports
the data structures that you need you
would use them okay thanks
so if you have the player to code in a
separate every next frame dew claws is
there a race condition there can they
both consume the same food or are they
always going to be sequentially executed
they are always sequentially executed
but if you you whenever you cue
something in the language they I'm
killing the food it will change the poo
so you have you need to have some code
to protect this so basically there is a
static analysis that will force you to
to use a watching construct that will
either restart the iteration or if there
is no problem it will allow it so if
there weren't this race then they could
execute in parallel on separate threads
or is the flow of execution always on a
single thread so this is all single
threaded ok this that's a synchronous
execution model you have only 11 a view
of the global execution of the program
so it's all single threaded
um can what can one do in a weight on
multiple channels at once all right I
might not be using the right terminology
but you said before about events coming
in and doing in a wait to wait for an
offense to come in can I put multiple
input sources in turn oh wait and thus
potentially be handling one while
another input is getting events and
dropping them on the floor use the
probably use the parallel construct for
that you have a parallel every something
in parallel with every another something
yes for these streams no</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>