<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Marijn Haverbeke - Tern: Practycal Type Interference for Java Script Editing - Curry On | Coder Coacher - Coaching Coders</title><meta content="Marijn Haverbeke - Tern: Practycal Type Interference for Java Script Editing - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Marijn Haverbeke - Tern: Practycal Type Interference for Java Script Editing - Curry On</b></h2><h5 class="post__date">2015-07-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wW5VbogkDQ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what I'm going to talk about is turn
this is a project coming
static analyzer for JavaScript code with
the explicit precise purpose of
improving editor assistance and
integration so it's not a type checker
it's not a linter it's though it does
its main task its type inference that is
for editor assistance purposes so it has
a very different design than what you
would see in a tight checker or related
think I'll start with a very quick demo
show it does things like other
completion context-sensitive as I said
window knows what window is what you can
complete their you can ask it about dogs
if they fit on the window um it does
basic very basic refactoring things so
if I have a variable here I can just
rename it and it knows about scope so
these are absolutely trivial things
aesthetic languages that we've had for I
don't know 15 years maybe more they are
rather hard to do and dynamic languages
there are other systems like visual
studio which have pretty good javascript
analysis built in turn is supposed to be
in editor independence components it's
open source and improves the situation
for the rest of us and so what I was
inspired by his
emacs foreign environment for common
lisp which has extensive first I will
jump to definition and you see a list of
function arguments when you're typing
arguments and these are giant time
savers you don't have to go hunt through
the coach to look something up it just
implicitly does it for you and give you
the context that you might be looking
for income list world or cloture and all
this pretty much do this what they do is
have a running image which has all the
code loaded and they talk to this image
through some protocol to get feedback
they once and this image show you this
runtime obviously knows about the code
it loaded it it compiled it and it can
answer these questions javascript
implementations do not do this so we
need a different approach turn is
basically a process that runs alongside
of your editor doing something like that
slurping in all your code analyzing it
and asking question questions about it
over a simple HTTP protocol for it's
written in JavaScript so for JavaScript
based editors you can actually embed it
directly in the editor rather than as a
separate process so the reason why
integration for dynamic languages is
length behind is basically that they do
everything in their power to make life
art for static analyzers so obviously
the types are dynamic so there is no
formal algorithm for deriving the type
of something when you just have the
source code then many of them especially
javascript is very ambiguously typed
primitives so you can pause anything you
want to plus it'll do something with it
similar for the built-in functions you
can give them anything to convert it to
what it happens to like and do something
where to tell you can't user attacked
occurs algorithm that starts from users
if you see
a plus one that doesn't tell you that a
is an integer so you have to go the
other way around you have to see what
kind of values flow into a from the rest
of the program and then of course
JavaScript can manipulate types at
runtime which is a whole different class
of horrible in terms of static analysis
there is some research on sound analysis
of JavaScript code this research tend to
start by defining a subset of javascript
that they are going to her guns so
things like Israel can not only execute
arbitrary string this code they can also
change the scope chain in JavaScript and
do lots of horrible things soundness is
explicitly another goal here so it
allows us to do much cheaper faster and
simpler analysis the goal is being
helpful in the face of non weird code
and doing the best we can when the code
is weird but there is no no worry about
getting something wrong sorry that's are
you saying faster analysis how is the
performance compared to for example what
we know like statically typed language
is for Java or so or some stuff like
that so I don't really have enough
experience with that again eyes on these
languages to do so much about it i can
say that on my left of turn slurps
through about and those blinds a second
so you do have to catch is you do need
these running instance you can't for
every query start and analysis from
scratch but it is real-time interactive
if you have most of the information
already in your image
okay so so if I'm a Java developer as i
am and i start doing something in for
example eclipse and you have the clip
support i think i think someone wrote a
plugin i can't vouch for its quality all
right yeah so there is an additional
there's some additional stuff like
communication going on so is it still in
the line is it still the same experience
the same real-time experience that I
would have in in a statically typed
language yes there are some situations
where you notice a lack for example if
you jump to a definition in a file that
you recently changed and hasn't been
fully realized its forces reanalysis
because it is the exact character
location of the senior jumping too but
these are relatively rare for the
comments things like completion and jump
with the definitions and known files
it's instantaneous okay so you mentioned
that somebody wrote on Eclipse plugin
are there other IDEs that already
support it so my main the things that I
support our for MX sublime text has a
good plugin there are some editors this
commented I was unfortunate Adobe
breakfast there's a plugin for Ethel but
these are most of the
the still text editor said don't really
know where situation is with IEDs I
think some roach intelligent plugin no I
think there are but you get a project of
this detected some great product doesn't
either actually work so thank you on the
topic of BJJ how does the for me of the
results compared to other organizers
like one in HIV genitals is a definitely
better than jboss then 2013 when I
played with in their offices the best
implementation I think now this is what
might refer to come back to how they're
doing they usually leave term there are
situations where their process works so
well but maybe have a roof it's also
been two years since I played with it
there are situations where terminated
with a sink of the whole video is bit
better and what their speed who can't
return good I didn't know just seriously
lace and energy but approach it like
flow in typescript which are also kind
of in the same a very different approach
but in the same thing they actually type
your code using annotations and this
they can actually give accurate
information opposed to guessing from the
vague semantics just as a small comment
an ID suppose it's very difficult to
combine turn with the built-in
functionality for something like int
energy so you would have to either
choose between heaven turn running in
intelligent yeah or and that would mean
losing all that adds features that
entity has like we factorize it derived
from the others provide poor fit for
deadly or you could just use the
built-in stuff yeah this was born
logically or the frustration of their
existing no decent DMX support and then
some other editors in a similar
situation kind of which is along that
but yeah I de style editors I have seen
that much use so it's the algorithm i'm
using rather directly is an ancestor of
the inference algorithm youth in the
spider monkey javascript engine where
they use this for a very different
purpose namely more more compact and
efficient code generation because if you
know the type of something you don't
have to do that checks and weird
polymorphic interpretations so there
they need to be conservative only draw
conclusions when they're absolutely
certain or you get a sec fault which is
very different in turn where it's great
if you can get some type for something
that you otherwise couldn't tell
anything about Patrick Welton wrote a
fork of JSC text where he applied this
algorithm for for ya something similar
as what turn is doing and I kind of took
inspiration for from depth and will turn
on them so what I'm doing is a form of
abstract interpretation where I just
wash the whole code and run over it and
the product of this interpretation is a
graph connecting basically showing the
wave types flow through the program so
also some something like dataflow
analysis I think this graph that I
produce has a song called abstract
values as note these are basically
corresponding to a given variable or
property or other location in the
program that might have one or more
types so if you have a variable X and
you assign a string to it then the
abstract value corresponding to X will
be noted to contain a string and then
the edges in this graph are
paths through which type slow so if Y is
a sine 2x later then that means all the
types in X and open wide and we create
an edge to represent that fact so here's
how can you use the incremental patch in
like because you mentioned that it's
very important I mean incremental
changes right so the editor talks to
deterrence is over HTTP interface and
when it makes a query it can include the
file that changed or in case of huge
files a fragment of the file around to
change the editor knows what you've been
typing in the meantime so it knows which
files are dirtier to say which files
turn doesn't have an accurate view of it
sends that along and then analyzes this
file in the context of the whole project
that it has analyzed beforehand and then
runs the query on its resulting
representation so you just do it one per
file right you don't do incremental sort
of like changes I mean if I change like
teeny function for example we still pass
the whole file for small files yes
because it's simpler and more reliable
for a huge file say over three four
thousand lines we actually only analyze
a part around the change and then fix
that into the scope that already existed
indeed that works relatively well but
has some flaky educators so so here's an
example is the coach entirely visible
yeah sorta um so here's this this
trivial program where you have variables
x and y and it's obvious that they both
have touched ring if you add another
statements it actually gets union type
of two
two types actually this wouldn't be the
case because why would end up a boolean
but one shortcut that turn uses is that
it's completely oblivious to flow
control in this case flow control will
be trivial to handle once you have
functions which are called anywhere and
do something it becomes very expensive
to handle and most saintly types
programs don't reuse the same location
for different types in different phases
of the program say this is a good enough
approximation so this is the graph that
we build for this the orange things are
abstract values which can have zero or
more types associated with them and
because X is designed the string literal
we let the string type flow into X and
now it's there it's written under X
because Y gets excess value we create a
link between x and y and that means the
type that ends up in X also flows
through to Y and then of course yet
another type it also flows through the
same path and you get the expected types
for these two variables then we'll go
through a more advanced example
involving an actual function call so say
we're interested in the type of our we
call here f with two strings and f
concatenates them and returns them so we
want our to be inferred as being a
string first we look at the top
statements where variable R is declared
there's a reference to variable after we
haven't seen this definition but we
create new precise value for it anyway
because when someone defines it later we
want to know that this was actually
already used in some way turnt analysis
is entirely order independence so you
can throw code at it in any order also
definitions may arrive in any order and
it will infer the same result
this has many advantages for being able
to for example analyzer file and then
figure out these dependencies and pull
those in after effect so what we create
here is one abstract value for f1 for
our and then three for the arguments and
the result type of this call the purple
note is an active node which is a note
for the specific kind of code in this
case the code for handling a call and
because f flows into their if f gets a
type that type will also flow into that
active node in the active node will wire
up the function type with the call so
the arguments will be wired up to the
parameters of the function the rich
return type of the friendship will be
wired up to the result of the call and
then we have our wired up to that
results so that when we know a result
type from this call we know that are
also gets that time at the second line
there's a function being declared here
so we allocate a function type hi um I'm
a little bit or what is it that you
consider to be a type a type is
something like a string boolean function
of integer returning I don't know or an
object with a given shape so what is the
shape of an object an object will get
back to that in a moment but an object
basically is a type object mapping to
several abstract values representing the
types in its property so do you keep
track of the chain of prototypes going
also yeah okay so so if i go and i add
to link to the the prototype of the root
object then all of a sudden that also
gets reflected through the graphs of all
the other types yeah actually I don't
think I handled changing prototypes only
creating with objective create and new
creating that kind of heard that change
so yeah the function type has references
to absolute values for its arguments in
its resolve the body of the function
tells us that plus is applied to those
because pleasant javascript is a bit
strange complicated we have to define
another active node type for that which
looks at its inputs and if it sees a
string it spits out of string if it sees
two numbers it spits out a number and
then we let that function pipe flow into
F from which it'll continue flowing down
into the call which causes that active
node to wire up these arguments and
parameters in the correct way so now if
you fill in the actual types passed to
that call they flow up into the
functions parameters through plus into
the functions return type into the calls
return type and now we know that r is an
actual string so this is already a
non-trivial graph for a completely
trivial program you can imagine that
these are impossible to visualize a very
tangled for for bigger programs yeah go
ahead so in terms of the abstract
interpretation is it that expressions
kind of I evaluated two types say
vaguely and then a program is evaluated
to this graph or no the graph is built
up basically a the abstract interpreter
gets an output object when it's running
on an expression and if the expression
produces a value that will be propagated
into the object pass to it and that way
an English
out for when it's seeing a function in
the SD its will wire up function type
for that and make sure that the
arguments end up in the scope that's
being passed down so they have access to
the scope and their output object which
can be an abstract failure or one of
these active notes so I guess then the
abstract invitation is not really
compositional in the sense that you are
evaluating abstractly evaluating some
expression no it doesn't reduce it to a
single right with you mutate some kind
of global representation yes the growth
I see okay thanks good question so you
said the graph is pretty large but I
mean how you deal with the very large
programs all my problems are solved very
large because I require a lot of node
modules and then if I pass them it takes
a lot of time and do you keep them in
memory or to use some more cash none or
is it this is so there is a mechanism
for condensing a library down to just
it's types and loading that it's
unfortunately not as usual friendly yet
as it should be but this is possible if
you load some huge library and you have
but also when it's tracking dependencies
it uses a kind of furry dependency
budget and if you keep from their
dependency branching out to more at some
point the budget runs out and it just
cuts off the analysis on the assumption
that's probably the types that you're
actually interested in the direct
interface to the module that you're
calling will have been sufficiently
determined at that point but these
graphs do get baked for a big project
you might get into a gigabyte or two
gigabytes of just memory ok so maybe
subsequent question which Martin systems
to use a part I mean if you require
something else then you of course you
have to analyze it as well and then you
it's maybe not quite easy to see where
you get the code from I mean if you've
used up like your six modules do you
support that and then do you spawn
required you support as the plug-in
architecture and currently there's a
plugin for a note and for a required yes
and there will be support for here six I
actually started working on using es6
support so far cs5 and these basically
when you create a server you give it a
mechanism for accessing files so if
you're running note this will just be
looking at the local file system but if
you're using required yes for example
you can also require URL so it's but it
is recognized as dead and tries to fetch
them from the net and sink like that but
usually there's a relatively
straightforward mapping for example note
plug-in when it's running um note just
use notes on results mechanism so that
you actually get the father would have
been required thanks
so speaking of modules and libraries I
guess that for native modules like the
Dom or native NPM packages you have some
kind of um yeah a summary that says okay
this is actually how it works and what
types it expects in returns right did
this condensed mechanism that I
mentioned before outputs kind of
adjacent files so you can run it on a
file and just get a datafile that
succinctly describes it types and
there's an written or partially
generated for documentation files of the
type in the distribution for the browser
for a few popular libraries and for the
language standard itself so you get
those who just yet you load to you
there's a configuration file format just
Jason where you can say which libraries
to load this this directory
and I also wrote to shim that takes
typescript definition files and converts
into this book because their compiler
keeps changing and no longer works with
recent versions of the compiler work in
progress javascript is also an
object-oriented language and actually
core is a special function and just like
apply and actually the first argument
would be the array of arguments and I
need have this argument and then you
know with apply so is it the base
argument like being more object-oriented
is this being also analyzed and infer
yeah actually this slide Elizabeth each
function and call now it also has
absolute value for the object as being
passed and yeah those are just reflected
in all function argument all funky
signatures and you can also just use a
call method and pass an explicit oh like
in some libraries an API is that
overload the vase like you know in the
dome and HTTP i took score whatever so
it you keep track of the beasts and you
infer it and right so um it'll in some
cases it will refer it from context if
you're defining a prototype it'll assume
that this will return to will refer to
instance of the prototype for just
normal functions it'll wait until it
sees a call to figure out what kind of
objects are being tossed in as self
but do you handle something like the
command create node where essentially
past et al string and written you have
like different types depending on the
string literal okay I mean consider for
example document create know to create
element where for you have different
Tyga depending on the string literal
cells are a nightmare for typing those
are all treated as one node type and it
has all the properties that all possible
no touch have it's a it's almost
impossible to do better because if you
do document query selector something
with this class you have no idea what
you get back yeah but I mean front of
all types creep them is a sort of not
try to implement it because now say they
support sort of like inherit and well or
based on string literals so in a sense a
treat for exemplary like create document
know depending for great element
depending on cingulate or you could do
some things with that so create element
is an example but you couldn't solve it
generally because often you get them
just from some other structure and you
don't know what they are so I so far
considered it not really a great
solution okay behind you so let me just
try to understand a few things so do you
have flow in the heap between between
fields as well between object fields yes
each its object property is one of these
orange now it's actually let me just get
through to fish an example with an extra
object so there's the code this is the
object type with references into its
properties line and then there's again a
special note for get the Y property of
all objects that flow into this and
that's how i implement object access
right so that's the case then
essentially what you're doing is kind of
morally equivalent to a context
insensitive pointer analysis of anderson
style right i guess which is not really
i mean other things like this Kelly
really quite quite well I mean all
you're getting out of it is effectively
concrete types at the end
but you know yeah me too much the system
i subscribed so far works great for
monotypes simple programs if I have the
time yeah I probably will be able to get
into a few tricks that I used to handle
simple polymer but even one level of
context is still it you will buy you
something yeah yes I just had a quick
horse she do you understand the closure
type annotations but the Google closure
compiler I mean these are jazz dr. yes
yes i parse several styles of jazz dog
comments not exclusively because there
are all kinds of conventions and they're
not that documented but oh yeah for
simple things the the types that you
annotate will also flow into the Grove
on using multiple sources of type data
are you I mean the spider monkey type
inference had to use solid data as you
explained but since you can use sort of
really shady data if you have a field
that can be type A or B and then you see
it used may be called a method is called
it that only exists on B are you using
that to then decide okay this is Type B
no no i don't i do use something like
that in the context if I don't have
typed information in my graph and you
for example try to complete the property
on something you really need to type to
be able to do anything saying so what I
do there is look at outgoing edges from
that thing so if for example it has
access to get wine and get Z I look
through the known object types something
matches it has those properties and a
complete based on that type as a kind of
fall back there's quite a lot of
interesting things you can do with these
graphs also if something flows into
another note which does have a non type
and you could approximate this type as
the thing that
frozen
and so here's as i said this works great
for mounted type programs but here's a
very simple example of something that
does not work you have a generic
function last off which takes any kind
of array and gives you the last element
no matter what to type this if you just
use the naive approach i outlined it'll
get a new type in its return type every
time it's called so these would be both
num and stir would be number or string
which is not very helpful and worship
and saluting the whole graph with
useless types that don't actually apply
so what I do here is where the function
is analyzed just this body has been
analyzed we haven't connected the Arc de
paramÃ¨tres to anything yet and it does
not have a return type at that point we
do a relatively shallow graph search
from trying to get from one of these
arguments nodes to its return out and if
we find such a path we can derive a
function that can compute a return type
from the argument types based on that
path and so then we just disconnect the
normal return mechanism and use this
this function to compute the result of
each individual instance of their
function so in other programming
languages you could solve it by having a
model make powerful type system they can
describe whatever goes into that
function whatever that area contains in
that front of whatever that type is
building the return type that might be
generics in typescript for example or
generics in Java or C sharp but it of
course requires a more powerful type
system I don't know how type system that
you're using under the hood looks like
but then you support anything like this
it's very simple a type system and not
really something that's usable for for
manipulation or any serious theorizing
but the mechanism i'm using i'm thinking
about moving to something more powerful
than mechanism i'm currently using is
that functions can just have an applied
block of code that computer return type
if they are known to be special and
return something that we know about an
otherwise we have these normal arrows
and boxes mechanism to compute it and
there's a simple text notation to
describe these types so then you get
serious runtime type manipulation their
district really doesn't work for example
many people define all their types using
some helper function the common one is
called extent where you just copy all
properties from one object to another
and that of course the analysis are
outlined completely falls down there so
what I do for friendships that I
consider type manipulating type
manipulating I have some heuristics on
the kind of things that type
manipulating functions do and I score
each function as I analyzes body too how
much of that stuff is doing it would get
below a certain threshold of type
manipulating the spur expression it
flips into a different mode where its
sub graph is reinstated for every call
this is expensive and you have to be
very careful about recursive calls and
it's very easy to get into an infinite
expanding graph that way but I got it to
work and that means that even things
like this and the various sub classing
functions that for example CoffeeScript
spits out and most of the tools in under
core just end up working it makes the
just last week someone sent me a link to
a library called some fun on lambda with
the first letter change right and its
turn took 20 seconds to analyze that
file which is only few thousand lat long
because it was all all functions ended
up being instantiated multiple levels
deep and this was just pretty much
exactly the pathological case that it
doesn't currently handle I have to think
about some way to just stop rather than
freeze in these situations have quite
found the right approach for that it but
but I wanna stress that this is rare
most coach just goes through and you
really get useful types yeah so why do
you want to deal with computer to our
producer seems like you should drop them
right away because many people define
their actual classes this way their
types and you do need to know the
properties of classes people are using
to give completions constant properties
you do computed properties are not so
sure well there if you have a constant
that's a different case yeah yeah but
these are for example they'll pass in a
source some literal object with a bunch
of properties and then copy these to the
prototype of some constructor and an
insensate that constructor to get an
object which has all these properties in
this prototype chain and these needs
absolutely need to be known to the
analysis or it's pretty much useless so
what i'm doing here is I recognize this
pattern of copying over all properties
and secure then you can get and I have
been playing with IDs of modeling small
collections of strings or so that I can
in a few more cases for example use
object that Keys turn is lost which
returns all the keys in an object
because it can't represent an array of
these specific strains it can only
represent an array of strings so do you
do also something like this for hire
other functions like say yeah nap on the
right yeah and that's where the
functional library went wrong it was all
higher level deeply nested higher level
franchises
ok
I have a few more but I already touched
on this so when we don't know the type
of something we just use the graph
context guess this is very useful if
you're writing a library where your
project isn't actually calling your
functions and also there's a bunch more
magic for referring this pointers
because those are very critical the
completion is just terrible if you can't
complete on this usually when you're
writing a class you are not
instantiating it yet so it recognizes
some some patterns like assigning to a
prototype or creating an object literal
and assumes that you'll probably want
with this and it has a mechanism to if
another object type comes in as the this
pointer to override them and do these
speculative types which means that we
can do it without doing too much damage
we were wrong so as I said the server
slurps in a whole bunch of files and you
get a cross file knowledge notable
projects you can jump back and forth
between files you can rename since
across files if this goes a bit dodgy if
the turn actually knows all the files
that you're using if you're not using a
module loader plugin and you didn't have
all the files open in your editor it
doesn't actually know but you can also
configure your project to load all files
in this directory or something like that
but you have to be slightly careful
there because it doesn't know some files
belong to it these Maori names won't
actually go through and
then you can see here for example of
weird pattern for defining a module at
the bottom it designs to this which is
the global object creates an empty
object passes it to experts and then
assigns in this anonymous function some
stuff to it this is relatively common in
browser programming but these are all
easy for turn to see true if i say my
mod that it knows what it is and i can
also jump to it and the approach works
surprisingly well for a lot of code i
was actually skeptical at first but it's
useful enough so as i said there are
plugins for for these editors which in
some scenes are the major editors but i
guess there are also whole worlds of
people using IDEs for risky situation
might need to improve the term project
file is a simple JSON file saying load
these plugins load these type
definitions always immediately slurpin
these files don't ever load this file
things like dinner then as I said a very
interesting implementation existing
visual studio what they do is very
different though I think they're also
have been extending it with with some
static analysis similar to turn but
their basic approach is they have their
own JavaScript engine they're
instrumented to actually run the code
disabled I oh and then look at what
happens in the running program to figure
out types so this is you can for example
for dynamic type manipulation this works
perfectly stuff at the global scope that
gets defined in some extremely indirect
weird way you just get exactly the shape
that they have it does have some
problems for functions that aren't
really reachable from the from the
currents the current coach if it can't
find a pop into a function can figure
out the types I think they've started
using techniques like turn or maybe even
believe a different static analysis to
improve this situation which that's the
kind of yeah trade-off there if I had
all the budget and time in the world I
would probably start extending turn in
that direction with doing a superficial
interpretation run first and then static
analysis using the input from what
happens in that run because most type
manipulation which is the big problem
happens once at startup time and is
actually not expensive to do interpret
of course then you have the whole
problem of writing an interpreter and
that might not be fun but it only needs
to be relatively superficial I have a
partial that I also wrote for JavaScript
and Java scripts this just spits out an
STD relatively standardized SD formats
for JavaScript code and it I also wrote
a SD Walker framework which allows you
to say run through the code when you
encounter such a note do this and then
you can tell it's optionally how to
descend into debt note so it's the as I
said before it just passes a goal note
to each invocation on an ast node so a
goal note in terms of this graph that I
described so that the result of this
expression knows where it has to go and
that is actually not that much ghostly
the inference engineer a few thousand
lines
yeah other related to work which i
already mentioned is flow and typescript
they both have little demons that you
can run alongside your editor which will
do something like turn analyze the whole
project give you very accurate
completions and they have a flood or a
lot more to work with because they do
have a relatively well defined type
system and type annotations and that's
all i have to say so if there's a few
minutes left we can't let me do a few
more questions so to your comment
towards the end I mean we talked with
the visuals to the guy is quite a bit so
one of the ways you can consider doing
it is that you can scrape a heap
snapshot at the end of once you reach a
set it steady state somewhat right and
the new browser edge thus Martin browser
actually has some facilities for that as
well and you can do that once the
program is run for the first time you
don't even have to artificially execute
it in this IO block environment which is
kind of a mess you can just let until
the user runs this thing right captain
here he'll also be somewhat out of death
to resist but I mean the initialization
probably won't be right capture it and
then start analysis without one
it's another question here
so it's rather comments so I played
around a little bit with the flow engine
and it works with no type annotations at
all if you want that yeah they also have
I guess what they do internally must be
pretty similar what you do so maybe you
I'm actual diamond sure what China today
they are a flow sensitive yeah I'm very
implemented in a faster language so i
guess so you would have been a little
camel but maybe that might be problem
but their algorithms might be influenced
by them talk i know that that the the
guy who wrote it is around Flo okay yes
so maybe you find not ready to I don't
actually know about there there is no
real documentation about the algorithm
that they you just I don't know I just
know that it works with our talk on
occasions is very powerful and it's
helped a search but I didn't bother I
cannot send welcome so that it's I think
very much oriented after the pre she
teases of comic Flanagan waves actually
also at the conference so also just as a
comment unless I'm completely mistaken
you can indeed run it without any
annotations but I think that it's a way
more powerful if you add the annotations
and I think without annotations it's
it's not all that great but I I not sure
if that's just what a colleague of mine
told me and unfortunately I really don't
understand why unfortunately the
annotations are not like in commons but
it's well you have to it's like java
soup so syntax right your javascript is
not sell javascript anymore which i
really can't get my head around i don't
quite get me why they don't just support
adding like comments to your functions
because that that way I could just more
awkward but yeah it's Jana the design
goes after it because I'm done I mean
most people are probably not going to
convince anyone to hey let's switch to a
compiled language so we can use flow so
weird from our point of view we a
decision but yeah I think in my
experience people are moving to
about languages anyway for a conscript
six features and so and then they just
that the the I think currently most
widely used compiler from EA 62 vs 5
also supports lifestyle and typescript
style annotations so then you have both
the one okay all right thank you for
listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>