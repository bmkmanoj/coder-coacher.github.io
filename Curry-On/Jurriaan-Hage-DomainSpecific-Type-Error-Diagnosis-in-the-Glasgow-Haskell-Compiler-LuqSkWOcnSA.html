<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jurriaan Hage - Domain-Specific Type Error Diagnosis in the Glasgow Haskell Compiler | Coder Coacher - Coaching Coders</title><meta content="Jurriaan Hage - Domain-Specific Type Error Diagnosis in the Glasgow Haskell Compiler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jurriaan Hage - Domain-Specific Type Error Diagnosis in the Glasgow Haskell Compiler</b></h2><h5 class="post__date">2017-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LuqSkWOcnSA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">they are so never Wow
or like very much because I stood for
motors transformers you're not loud
enough yeah so so because I mean not
that I'm out to make converts I mean I
don't care whether you program in
Haskell or not but I would also be
interested in people working in
different languages saying well this is
something I'd like to have so what I'm
talking what am I talking about it's
about how to customize type error
diagnosis and it's a specific goal in
mind is to make type error messages yeah
the things that you always get when you
make a mistake and the compiler knows
about it get those messages to make them
better explain what you did wrong and in
particular when the libraries that you
write and when you make a mistake they
actually represent and that a
domain-specific languages that you can
actually make the error messages
domain-specific so you use a bunch of
culminated library and all of a sudden
your error message talked about talked
about partials a normal Haskell compiler
cannot do that you have to train it to
do so I me and my PhD student Alexandre
Shannon arena we've investigated this
for four four years or so and we came up
with a letter I think neat stuff with
posters at conferences but this is a
prototype stuff right it's because we
need to set out the type inference
mechanism in a particular way so it
works for us and then at some point we
said well actually we just want to see
whatever of all the things we've
developed what can we get in GHC with
almost no effort so that's what this
talk is about so I mean I don't know
what do you where you come from
so I'm in a situation where I have a
statically typed language so strongly
statically typed language like high
school it comes equipped with an
intrinsic type system this is a new
thing for me so it's an intrinsic type
system that tries to prevent
structurally correct but semantically
nonsense programs from being compiled
and this is - well one slogan that well
typed burner school
and go wrong it might still not
implement what you want but you will
love the adding brilliance to strengths
add those kinds of things and then if
you have a typing correct program
yeah the compiler should inform you it's
type incorrect I preferably say a few
more things on how to fix it or whatever
that there is this need for diagnosis
and this is usually where compiled
abilities say well I don't want to do
this I'll I'd like to generate faster
but having to spend all this time on
explaining error diagnosis boring boring
boring yeah so this is my field type
early diagnosis to the problem of
communicated to the programmer and why
this program is not type corrected this
involves depending on the compiler some
information like first of all that it is
type incorrect and that's always nice to
note some compilers don't do this and
this is a non statically typed
programming language it would be nice to
say what kind of inconsistency is it
because it kind of a unification error
or is it the type Clause constraint that
could not be resolved things like that
it might also tell you this is these are
the parts of the program that that are
involved in the conflict then whatever
you fix it has to be in that part and
none of the other parts this is called
type error slicing also a field of
itself and even better might be is that
it actually tells you all but this is
how you fix the problem I know this
problem now if you look at the
literature there's very very little
about type or diagnosis for languages
like Java even for Java that has a type
system it has an intrinsic type see but
it's very little I I think I wrote the
only two three papers about that
nobody's interested it seems there's
actually a PC features in Scala
but almost no papers about Scala for
example and it's still quite a problem
in functional languages traditionally
there have been that because it's so
rich in its higher-order functions but a
method polymorphism there's much more
room for mistakes that seems so decades
ago already people started doing work on
this and whatever I'm doing is kind of
like a part of that big body of
literature so
so it's a problem in functional
programming but not just the functional
programming because languages grow and
we've seen that over the last decades
that that all of a sudden our language
start to support functional stuff
because of parallelism Java has seen
introduction of parametric polymorphism
but error diagnosis suffered then they
introduced anonymous functions I have
not dared look alright languages like
Scala they embrace multiple paradigms
the type systems Scala itself is
actually quite complicated local type
inference is much more complicated at
least to understand and to diagnose I
think then then hindley-milner
algorithm that that Haskell uses you
have to do a bit more effort to get more
powerful type systems particularly
parametric polymorphism and subtyping
they bite each other quite off so I've
been talking about HP as well we for a
number of times and then he he mentions
this type role he says well we can
invent more and more and complex type
systems but at some point if you don't
also address the diagnosis programmers
who had kind of hit the wall they're
saying well yeah I'm making all these
mistakes but you can't explain what I'm
doing wrong so I'm going to closure I'm
going to err along I'm going to to non
statically typed languages because then
I felt at least I don't get complaints
that you get runtime errors but they're
much easier to fix maybe and he talked
about they precess yesterday but he
didn't talk about what that does to our
diagnosis he had some idea is he doing
okay well there's a new trend is very
intimate languages are dynamic but
everybody also finds out if you apply
dynamic languages all over the place in
your company you'll find out that there
are over a thousand lines 20,000 lines
of codes with more than five developers
you also run into a law right the
maintainability law Bowl
so really good language like hacking
like typescript that by piece-by-piece
introduced types but then again error
diagnosis where rear its ugly head so
here I have a number of examples of
things in high school yeah so it's a
high school where I make a mistake and
I'm not that happy with the kind of
diagnosis I get so this is Bryn Jordan
there's a lot of diagrams librarian he
has a first in the top that takes two
pictures are recruited cue diagram is
basically a picture and it can be a
three-dimensional picture or a
two-dimensional picture the planning on
the roof is actually these vias as the
vector space and you can put these two
on top of each other and then you get a
new picture out so this is basically
take a picture put one on top that's the
new picture fairies I mean yeah
everybody
I guess knows how you can do that now if
I write things like a top true then it
basic says yeah but I expect my first
argument it should be something like a
cue diagram B V and M but it doesn't
talk about what is a cue diagram yeah
maybe this is something that's not
completely clear to the to the program
if I put a 3d cube on a two day put 2d
plane it will complain that they're not
living the same vector space because one
is it 2d picture in the other is a 3d
picture and it talks about matching type
V 2 with type III but it would be really
nice if this message could actually talk
about vector spaces right that's the
domain
term that is associated with this
particular component beautiful circle
represents the back end and M represents
the metrics pair so these are all things
that mean something to the guy who
developed this domain specific library
but ASCO doesn't notice you cannot
notice because that you would have to
build all kinds of the main information
about all the EDS else on hackage that
have been implemented well wouldn't it
be nice if the compiler the Valdiserri
the EDA's el developer could kind of add
this kind of information with library so
that the error message you can actually
talk about vector spaces instead well
that's what I do another one is the left
on this chart so we have type classes in
high school there is a position library
for working with databases and the idea
is that you can search for you can
insert unique records in there that you
can only do that because it's very type
safe if you have the persist entity
instance for the types that you use in
your database and it's just a matter of
putting a deriving somewhere and
actually the the you showed web.com
manual actually explains how you can
easily do that you don't even
think about you can just write a piece
of text somewhere that will fix it but
now you would like to get something a
message that tells you exactly this this
is where I go to find out how I can fix
this the formatting library is like a
type safe printf yet the printf that I
hope everybody kind knows a little bit
from from see yeah but this is a type
safe print F and what I wanted what i'm
doing here is i'm building a formatter
that will just print the text hello
world there are no arguments here like
in a normal printf it's possible but
this is just a simple example now
there's no function it just says i
already have the text variable that I
want to print when you print this
message so it's just a literal string
but the thing is this now guy actually
doesn't expect the string he expects a T
dot building and somebody started
shooting further for me okay so so
actually this now actually expects some
kind of other data type data structure
with the school they build it now as it
happens yet this is actually maybe quite
unexpected in fact it might be that you
found this piece of code on the internet
and you just copied it and then it
doesn't work and the later I'll explain
why actually this might have done that
but it would be nice actually have a way
of fixing the program that this error
message would suggest it then we can we
can do that too
so this is actually an expression with
parsing lambda abstraction so this is
the slash this is the arrow these are
the list of arguments this is the body
and actually you get this error message
if you do this in hug for example and
the only thing that is actually really
is that this letter is greater then
equal Addis greater than regular bracket
should actually be omitted and that
everything is typed correct and I could
we call these siblings because this
function which has a different type from
the function which this particular
symbol is missing they're easily
confused you would like to have a
message from the compiler saying well
you'll use this it's incorrect but if
you replace it by this other function it
will actually work will be typed correct
might not be what you intended but it
will be type correct and now this is the
message you get just talk about parse as
anything which is not selected
and then finally I came up with this
idea yesterday about simplifying Monet's
so so this is the message you get when
you the oak leaves okay I'm doing
something to the iron ore net that's
fine everybody should be able to work
with the i/o Mona but it's not okay at
this point to work in the maybe monad
because this student hasn't gotten his
monad license yet and and again with
what we do you can actually have to have
this and also explain okay this is
you're not allowed to do this kind of
thing yet may come back next again next
week now so these are the kind of tricks
you can play with whatever we do and
what we do is the main specific type are
diagnosed so this all starts with the
notion of an embedded to make specific
language what he did you did right
you just wanted tears comes you all the
mics you're saying okay good idea
yeah you think so yeah all right I can
still talk okay so well heat salon for
example gave in his one of his keynotes
a definition of an domain-specific
language that you have a domain which is
the well-defined and central there is a
notation for expressing well in our case
programs in that domain the informal
meaning is clear so you can explain it
in manual but and this kind of
distinguish it from a yard in' the
formal meaning is clear and implement so
and this is what he says is a dsl one
thing that is missing i was when i read
this i thought that this is nice but
there's something missing is that there
should not be a leakage of the main
abstractions when you actually use this
implementation there so an
implementation of the DSL should be able
to communicate with the program in terms
of the DSL and not in terms of the
underlying encoding which is normally
the case okay
so embedded domain-specific language is
what's the idea that where you take a
domain-specific language and you
implement it as a kind of a library
inside a suitably
for programming language and so this is
something that we can easily do in ESCO
there's lots of nice advantage like
reuse of existing libraries compiles I
des you can easily combine EDS else and
at the very least you can use it to
prototype your domain-specific languages
and maybe later you build your own tool
chain because it's a very important to
make specific language like C cool
but but maybe this is good enough for
you now there of course lots of host
languages and typically these host
languages maybe it helps if I stand here
so maybe these host languages are
typically your general-purpose languages
but they're a few levels that are really
well-suited for this kind of thing like
like Ruby for example or Haskell and C++
using templates that people have been
using this to embed their dsls inside a
general-purpose language and to me that
was an EDL how does it distinguish from
a library in Haskell if you look on
Hackett's or whatever what to me is like
a library that has a certain fluency
that resonates with the people that work
in that domain to say oh yeah this
actually looks like something I I know
even if I don't know high school I but
this is all fake and I don't really care
that much so their challenges one is
optimizations but today we look at
domain-specific error diagnosis and the
idea is what I want to have I want to
have control of the error diagnosis when
errors are good for programs written
with a particular domain specific
language okay we do that oh yeah we care
so I've worked with question here a long
time some time ago and now Alejandro
Solano Mina and we actually can do this
quite well I think
but which of these ideas can we actually
built into dat yeah so that we can give
something to the functional programming
community to play with and that's the
final part of my talk and maybe the core
of my talk so as it happens there have
been a few developments in GHC that
actually make our life relatively easy
so one of the things is the introduction
of the type error plus where basically
you say if I ever find a piece of code
that demands that I have a show instance
for functions then I will real rewrite
that to a type error thing where this
message
will be displayed to the programmer that
basically sells you I will never want to
write a show instance for function types
so when it does occur to have when it
actually does happen it's probably a
mistake on my part
and this guy usually says okay maybe
you're not you shouldn't be comparing
functions or showing functions but you
actually want to show a function apply
to an argument and you forgot the
argument right so the intellectually
leverages type level programming
techniques like this type level text and
type level string concatenation actually
textual catenation then we also can now
reuse for our own approach well it's
fairly restricted it's only available
for type classes and type family
resolution you cannot change the order
in which constraints are considered and
you cannot have messages depend on who
generated the constraint so these are
the things we'd like to have so this is
what we do that we provide control over
the content of the type error message we
provide some control but not all the
control we would like to have for that
we would need the changes to GC would be
much more invasive but a nice really
nice thing I think of this approach is
that you can use DC's type level
programming abstraction features to
reuse all the error diagnosis we've done
for one library to another library so
lots of things we can kind of write we
can reuse in many places and this is
really nice so it's basically a type
level embedded DSL for diagnosing and
better details click we've integrated
this in the patch of GC what I am my
mine runs eight point one point
something and Alejandro's now at eight
point three point something it works and
another thing is that something's and
completeness they kind of come for free
I mean if you change the error diagnosis
may you not also change the types
associated with the function that's a
risk but we can easily prevent that
because actually GC will check this for
all right and this is the slogan that
you get expression level error messages
by type level program one level up now
we only wanted to do this if it didn't
involve too many changes to the compiler
because my there are people in charge
sort of in charge of it see they don't
like in extensive changes to the
compiler
exactly so only if it was very easy to
add and change and in a small part of
the compiler then we allowed ourselves
to do it so the inside GHC we need some
kind of way of tracking the messages
associated with constraints and we need
to deal with priorities because we
sometimes want to control a little bit
to order in which constraints are
resolved or considered but actually type
error and the constraint can't do most
of the heavy lifting force we need to
edit a few things to the tie plates
files which is in the compiler just like
20 lines of code and edit the new module
type errors which are basically expose
the API that I will explain to you in a
minute
we do need lots of fancy type level
extensions so these are the ones that we
need to implement all this stuff the EDL
programmer only needs the first for
these ones and it is a usual
DSL user typically none except that
eight-point-three all of a sudden we
need to allow ambiguous type sometimes
so probably something changed there yeah
well I was hoping maybe Simon knew but
he doesn't okay let's start with a great
mistake so this is an identity function
I gave you the prime because it's my
identity function it just does the same
with an identifying she does and of
course if I give it a booty or return an
integer because it's the identity
function it whatever I provided it shall
return this is the error message you get
take it some time to read it and this is
how you encode it in Haskell
so here I have own ID function ID Prime
at it does huh it's a wrapper for my
original ID function George
simply the prelude version the ID from
the peril that I also import and I will
export this ID Prime to the rest of the
world and if they use it they get this
error message and not the standard error
message so what does it do well it has
this custom errors type class which is
just a way of saying okay there are some
customized errors coming up that's all
it says it's just simple necessary but
these are pipe level lists let's forget
about them for a minute there are a
really interesting part is that I say
well I D prime is a function from A to B
ah but that's not true I hear you say it
should be a function from a to a that's
why I'm checking the fact that a is not
equal to B over there because if I if my
checkered knows that a can never be
equal to B for example because it knows
that a is an int and B is a bull this is
what we call in the partners check
whatever happens in the future if a is
int and B is bool they can never become
the same and I know that this is an
error if I know that this is an error I
can generate this error message that I
construct here and this error message is
message saying hi please read these
elements a great error message exactly
what I had here this is normal
concatenation of texts and this is
putting two texts above each other yeah
these are the only two I think I need to
build my text the text is actually
displayed to the programmer there's one
other thing here is this versus a B so
you might say so here for example zebu
because sometimes I don't I don't just
want to give literal strings I also want
to kind of give you information about
what types did I actually compare here
right and this is what this type of
level function versus the type level
function versus does it will actually
compute this text using built in things
from DHT like show type and so forth but
we'll see some more examples of that
later right so this e you should not
worry about too much because I mean text
is something that lives at the
expression level but I need text that
live at the type level so I need
distinguish between them so that's why I
need this qualifier the fact that I can
write it prime equal to it ensures that
my eight prime is sounds although not
necessarily complete this could be a
more restrictive type but it cannot be a
more general type than the original it
this is checked by the ESCO type checker
and if you don't want to have the room
type overhead of having this then you
can just write in line to get rid of
that and that's something that gigi
supports out of the box all right so
what I'm actually doing here although
most of the time is we actually have
constraints and these are all constraint
like things that we can actually
manipulate and and we do that by me yeah
so these things live in a special kind
has introduced indeed seed not by us but
by people before us and this is called
this constraint kind and we apply these
type level programming things that we
have to these constraints so you can
actually already use this in your
ordinary Haskell well maybe not ordinary
Haskell
so if you're lazy you say what I want to
have show in show bull show blah blah as
a word show bleep and ever you can of
course repeatedly write all these shows
but you can also write a type family all
that will kind of map show over all the
types in this type level list that's
something you can do well this is the
kind of thing we actually exploit and
stop working
oh no hey I have to be good closer okay
yeah so this opens the door to
manipulating constraints and having
these type error messages in a reusable
fashion so this is one of my running
example to your top that you saw earlier
you take a diagram and another league
RAM you put them on top but we see that
they have silicon me on the back end
they have to agree on the factor space
you have to agree on the other two
parameters yet this has agreed on the
metal and the the semi group that they
were the absolute group on the ordered
field these are all type classes again
yes so all these things have to be the
same now I can rewrite these explicitly
using constraints saying well actually
it's a function from d1 to d2 and the to
d1 but I also have to check then that d1
is something like a diagram that d2 is
something like a diagram
and that element-wise here b1 equals b2
v1 equals v2 + 1 equals m2 and m1 equals
m2 and this exactly represent together
with these type class constraints is
exactly the same as this type of only
written down explicitly using
constraints
that's orders to it but that to a
compiler this equality is actually not
any different from this equality but
what I want is that well this message to
say something about back ends not
matching and this error message to say
something about vector space is not
matching because that's the domain
information that they represent ok so
how can you do that well we do that by
means of these apartments so what is
apartments apartness is a check that
that says it will succeed if it knows
that it's two are two types that it gets
as these arguments can never be made
into the same type by any other
constraint resolution later on so int
and bool are apart list of a and list of
int are not apart because it might be
that later somebody comes along and says
hey but you're a is an int ah but then
they become the same and then it's okay
so only if I know for sure that they
will never can never become the same
later on then I know that they are apart
and this is represented by this not
tilde thing and then a constraint
failures either the fact that I know
that some apart is check succeeded which
means that it is actually typing correct
the program all I know that some type
class constraint could not be discharged
so it's our failure and then a customer
ship followed by the message that will
be generated when it actually fails in
that particular way or it's simply a
constraint that we want to check because
we're not interested in having a special
error we just want to use the error that
that has compiled or narrowly give
that's a choice we made here so what
does that mean how can I now rewrite my
top having special type error diagnosis
for all the possible ways in which the
inference could fail here well the first
thing I do is I check is the 1aq diagram
or do I know it's apart from aq diagram
so
example d1 is already known to be blue
at this point because we are kind of
this is kind of looked at in the process
of serving all these constraints so
maybe it already has information that
this d1 is a blue well then Buland Q
diagram can never become a part can
never become the same so then this error
message will be generated and this is a
very not very informative
aramis but you can add some details to
make it better the same thing we can do
for the d2 that is it the Q diagram and
then we have to check ok now we know
that both of Q divers because these are
considered in this order now we know
that both of these are Q diagrams but
that means we can kind of access the
fact that the back end that I had known
at this point so can I then already
verify that the back ends are different
if they I know they are already
different at this point I can generate
this error message back ends do not go
inside answer and there is the sex for
which we have no special air diagnosis
now now and in the compiler this is all
changed into some kind of constraint
structure that the programmer needs not
be aware of this is the the API that you
exploit this is what you write
now of course here I will be writing
back ends do not go inside and then if I
check for you one against T two then I
get vector spaces do not go inside what
you would probably prefer is that these
messages are different because one talks
about vector space the other about back
ends but there is some similarity some
commonality there you would like to
exploit that right and this is where you
get the reusability of using type level
functions I can write a type level
function here do not go inside that
takes the name of what I'm actually
comparing represented as a text or
string in a domain like vectors spaces
or back ends and I get two types and
then I do the apart is check say well if
they are known to be apart then I
generate the text what do not go inside
and I give you the actual types that I
was comparing and this show type for
example something that's provided by gh
see it will just give you a textual
representation of the type and now I can
write it like this I can
a custom errors I do some checks and now
where they say do not go inside there
can't be one be to do it coincide vector
spaces v1 feet answer okay
now I've done something else here
because this is not the only change I
made what I also did here is instead of
having one list here of constraint that
I'm checking one by one I now have a
list of lists and what this means is
that this constraint will be checked and
that constraint will be checked even if
both of them or one of them will fail
because that allows me because I know
that they are independent I know that
the fact that this one can fail is
independent of whether this one can fail
but I can give two error messages at
once but if one of these two fails then
I will never consider these which makes
sense because then these B 1 B 2 V 1 B
fee to a developer never introduced in
the first place right so that's a little
bit more flexibility that we add you can
also do the sibling thing it's a bit
more complicated but the idea is that if
I have for example here a function that
I apply to something that generates a
list of ends and something that
generates a list of characters but the
function itself takes a character
nothing int what I might have meant is
that actually this Wrangell should be
deleted if I do that the program
actually becomes type correct because
then this operator will kind of throw
the information away and the character
will flow to this function and well this
is the way that you could encode this in
our language it doesn't need any
additional support well a little bit but
but not very much so you can describe
this and actually this is the message
you get you said well you have a type
error in this particular operator but if
you replace it with this operator then
actually things will be the problem will
be fixed one other thing you can do is
alternatives and conversions so to the
diagrams library a vector and a point
are two different things so you can
measure the length of a vector but not
the length of a point but to a
programmer maybe he says well yeah I
mean factors points are just tuples
right but in the case of diagram this is
not the case so sometimes you might for
example
for a minute so you might for example
have a function perp which computes the
perpendicular of a vector and you might
give it something which actually is a
tuple and not a vector and then by means
of this specification you can actually
have gec suggest to you look I'm
expecting a 2d vector but I got a couple
please use a dis conversion function to
turn your pair into it up and you are a
couple into effect right this is
actually the the thing I wrote yesterday
how you can restrict the monnet to to
only work for IO Moniz and this is this
message that you would get also works
this worked on my computer and what time
how much time do I have eight minutes
well we can at least look a little bit
some kind of demo so that you at least
know that I haven't been just typing all
the error messages in but actually
there's a G at C version or at least a
program that actually generates
something like this
Wow why not
right yeah yeah yeah oh yeah place
anyway play he says that for the check
constraints do not initiate giving
specific to be independent of Yannick
actually the same
yes that's that's what that's what
that's on the list of questions that you
could add I think we have a question so
so so paper discharges if you go with
DHC eye and you ask you to type it right
we can find it so all the customization
is gone that's nice
help however so to have this
oh yeah so yeah baby tip so we had that
here yeah and people say yeah that's
fantastic so I think was a doctor
yeah actually sperm because we want to
be for that gets me possible right mixed
yet progress but we wanted ships having
SP part massive social so now I want to
give a quick look so this is the
formatting library with this kind of
world example right and so what you can
so our GTI
so this is our patch of GC if I run it
on format X which is this file it will
actually give say for bloody hell
for this format no now have a world
example it will actually CTS the
function now expects a builder but was
passed a list of character which is a
string he can convert your argument to a
builder using from string or turn on the
overloaded strange language proper right
so actually if I go into the source file
and I uncomment this overloaded strings
fragment so now it's turn on and I do a
reload then actually the first error
message is gone yes sir this was
actually the fixed so now applied to fix
and it actually fix the problem and this
is actually not so strange if people
copy code from the web maybe this
overloaded pragma is not there right
then just copy the code but don't see
the problem here you see another example
where it so where you don't get the
hints because if this hint only works if
it happens to be a string that you are
passing but if you pass in an arbitrary
list of boolean's for example like in
this case it doesn't have or it doesn't
want to give a special fix and it does
that by actually looking at the type
that is actually looking at so if it's a
string gives a special message it's a
list of bulls it gives you the standard
error message okay so that's that that
and then the question may be okay how
does this actually look maybe a bit too
big but and so this is actually what you
write in your high school file for this
now function and also going for the
percent which is like compose function
for for matters and here for example you
see that I call the title of a function
check for builder that will verify
whether that but the tacky policy is
actually a builder if it's not a builder
it will actually suggest the fake it
will look at is it does it happen to be
a string and it does that over here so
it says this check for build assess if I
know that I'm not a builder then first
please check M is three if so give me
the special emphasis for Strings and if
not give me the default message so no
special hint so for this the rules this
will not succeed and I get here but if I
happen to pass in the string
we'll succeed and then I'll get the
SPECIAL error message well this this
says so so this has a little pair will
follow where this is a list of
possibilities to check so the
possibility you can give a special error
message and there's a default to be
expected so it's a generalization of the
other one yeah the other yeah so the
other arrow I think I have an example up
here as well so this arrow is like the
less general case where where you
actually don't have when it is this
empty a section right so that's
especially and what this allows you to
kind of look at alternatives all right
so I think I have to leave my my demo to
this but this is the kind of thing you
actually write for example for your
percent operator and so forth and I'm
not saying that this is easy to write
now because I want people to hire me and
Alejandro to write this for them and pay
lots of money because everybody knows
that Haskell that's a way quick way to
fast money but okay need to get on this
so we actually did some of this for
quite a number of these libraries power
of diagrams persistence things like maps
formatting library my students has a
special assignment they're working on
partially reason code pilot I said
whatever you fancy whatever you are
event experience we have please use it
and add this kind of diagnose so I want
to recap my slogan here to have
expression level type are diagnosed by
type level programming if there's
anything you'd like to take away from
this I think maybe that's this I do have
to say that well if you are working in
Scala in some other languages well there
is still something maybe to be added to
the language to be able to exploit this
I also hope that this will become let's
say the food in the door that well the
sign says well change
GHC well let's go to the next step
people say well this is great
I want more now you still laughing now
okay thank you for your attention
so you just said it was hard to ride to
those conditions to to express what
about the error message of those yeah
there are messages that you get for a
new miss type here conditions okay yeah
no that's that's a good thing so
actually I all made it so so the thing
is we do type level programming for that
we have no solution right so for that I
guess we need kind level programming to
address the type level programming error
diagnosis problems that's so that's
going to be the subject of my next
proposal that I'm writing now no it
isn't but but yeah so yeah get one level
up so yeah but indeed that's something
you cannot do indeed yeah
oh yeah yeah yeah I've done I've done it
so that's actually the case with the
Builder and the string it will actually
check do you happen to be a string then
you get this error message
actually I'm why the wait list case is
yes yes yes of it but this case mpro
like you could also say yeah but that's
that's so one that that's invasive so I
first need the food in the door yeah
then we're talking the thing is you are
the one who decides what message to give
you want you want some you want to
update his escrow files is that people
don't like this you could do it
I guess well I guess if you're an IDE
debt to do this yeah it's just a matter
yeah but
you have with either giving examples of
yeah keep it yeah well for example yeah
or or or or even nicer you I could make
one in Dutch because I want to teach
high school to primary school students
in in the Netherlands right so I I mean
I modify everything basically everything
is under your own control well so well I
mean for example of the e suit I just
said look there's the documentation
please take a look I mean you also have
student so you know sometimes you have
teachers that kind of work they want to
work on the the egos of their students
so they say every error you make it says
you're an idiot and then it points to
the page in the lecture notes that they
have to read to understand how to fix it
but it's the thing is it's all up to you
of course what I cannot do I mean
everything has to be textual because I
work in the context of in this case es
ein and ngat right and if you have a
system that goes beyond that course but
you could also as part of your text I
guess with a with a bit more work in the
pretty printing you could actually kind
of display a snippet of code I'm not so
sure
so in helium we can actually do that so
we can pretty print pieces of the code
but I'm not so sure whether we have easy
access to that kind of information when
we build our messages so that would be
something we would need if that's what
you mean yeah yeah so the idiom we
actually do have this I haven't so
because that's what I mean so you need
to be able to you have to need to be
able to access this at this type level
and that's so EDM I have more control
because we built a compiler and here we
kind of very light it okay we're like
larger set we're staying in GHC hotel
and then yeah we just have to make do
with what yeah yeah yes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>