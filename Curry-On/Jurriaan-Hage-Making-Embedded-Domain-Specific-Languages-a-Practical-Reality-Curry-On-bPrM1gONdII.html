<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jurriaan Hage - Making Embedded Domain Specific Languages a Practical Reality - Curry On | Coder Coacher - Coaching Coders</title><meta content="Jurriaan Hage - Making Embedded Domain Specific Languages a Practical Reality - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Jurriaan Hage - Making Embedded Domain Specific Languages a Practical Reality - Curry On</b></h2><h5 class="post__date">2015-08-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bPrM1gONdII" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is cerulean has I'm an
assistant professor at a university and
I'm going to talk about making the main
specific language a practical reality
and actually I just happened to see that
that was the name I gave to the abstract
when I prepared my talk was actually
like that the make specific type and I
diagnosis in high school but I still
remember them that actually before I
wrote when I wrote the extract was
originally the second title but there
might be these than I decide about this
doesn't sound spicy enough so we turn it
into the first one but I will actually
talk about the second one instead of
course that what I will talk about is a
part of making the main specific
language is practical reality although
well that's cool practical not really so
what's the purpose of my talk I want to
introduce you the field of type air
diagnosis in a somewhat sketchy way and
then I want to address one way of
solving the problem of type or diagnosis
I didn't ask this question to the
previous speaker for nothing usually
when people talk about yeah complicated
type systems and then I go yeah
complicated error messages so and that
gives me you work to do so that's nice
so the way that we did I started solve
this is by allowing the type inference
process to be modified from outside to
compile so the compiler needs to be able
to support that but then you can kind of
get an external dsl for writing down
type rules that behave differently for
your specific dsl and also give error
messages that use terms from that domain
so let's value and I applied this idea
to achieve the main specific diaper that
comes for embedded to domain specific
languages in Haskell and so is that
practical it's on the way to break
but what I also want to do in this do by
doing this this should show you what is
actually possible not just in high
school I hable to end any strongly typed
language I haven't done that I may not
even do it but I also hope that other
people think about this is a nice idea
we need to have this in Scala ah this is
nice idea we even need to have that it
in Java now or they say well maybe we
should actually impose a type system on
our dynamically typed language just to
have this yeah that's the kind of thing
I'm hoping for so to start from scratch
where we're talking about statically
typed language so the compiler type
checks your program to see it if there
is nothing that can go wrong it is the
well-known slogan will type programs can
go wrong and this is done by what I call
an intrinsic type system to distinguish
it from likes a type and effects isms
animals then the type system that also
work on but the idea is that there are
some programs are parts correct and
scope correct but they're still type
incorrect because you manipulate values
in the wrong way and that's where you
get the slogan and of course it's always
for the right definition of wrong yeah
because exceptions can also work you're
in high school you can still have a
crashing program I like to crash my
hesco programs once in a while just to
show them so yeah it's not all pleasant
in that's not even in Haskell even if
the tires were right i mean programs can
still go wrong but everybody i think
probably has played with a language like
this you kind of have the feeling cake
this is the kind of errors i can
typically fight and our previous stalker
speaker actually introduced lots of
things that you can check with the type
system that you probably had not thought
you could actually do hey now then I if
I if a compiler risk to use is to
compile and run my program or an
interpreter refuse to run my program I
think I deserve an explanation that's me
I mean if I get it paper rejected at the
conference I also explained expect
arguments from the reviewers yeah and
that is the sucks or you can 0 expect
arguments why is it the wrong why is it
bad what did I do to offend you so this
leads in my case the need for diagnosis
so what's typeerror diagnosed as well
simply put it's the problem of
communicated to the program a debt and
or why a program is not that correct and
depending on the situation that you're
in you might at least expect to know
that it is type correct or incorrect it
could also be that says it's what kind
of inconsistency did its fight yeah this
is an incompatibility between values or
is a type class instance missing all
kinds of errors can occur what you would
also typically like to know where did
you find this mistake is it in this
function or in that function or is it
everywhere like pretty typical ever type
what you can have a type lost another
thing what would be really nice some
sometimes is maybe it can also suggest
how I can fix the problem if I call a
function f expects an int and a list of
int and I reverse the arguments can't it
just tell me that should reverse the
arguments now if you look at the
literature turns out functional
languages probably have had a lot of
more problems with bad era diagnosis
because there's actually quite a bit of
research in that field not much but much
more if you compare it to the
industrially much larger field of all
ang so let's look at a bit of high
school not very complicated has grown up
for you certainly high school so I want
to check whether X is a palindrome which
means that the reverse of the list is
equal to that list and I've implemented
reverse in some way and quick high
schoolers will probably say iono this is
not type correct and indeed the program
is not typed correctly to the error
message you get you get a curse check
that we cannot construct the infinite
type that T is equal to a matrix of
teves this is very hard to satisfy once
you start doing that and then it says
expected actual type and then it
explains your wireless is actually it
says the problem is here turns out
actually the problem is here this is
type correct but it's not the type that
you expect the reverse all right so
let's look at a bit more detail so first
of all it doesn't say where really the
error occurs because it says something
about
x is equal access but actually the
problem if we know for our
interpretation of reversion palindrome
you would actually find out that this
implementations incorrect although its
type correct instil incorrect but it
only shows up when you use it later it's
pretty intimidating infinite types could
never hurt but before I started to work
in visit if I'd never heard of an
infinite type before occurs check I
hadn't studied provo either so how would
I know with a probe within a curse check
it yes so what you see it's intended and
other things it's mechanical in the
sense that it it kind of reveals the
underlying type inference process to the
program who should not probably not be
aware of this generally it's not very
helpful and actually the likely fix is
very simple who it's one letter fold our
should be fold up and then it's okay
right now there are three people in a
bra yang Trinder and wells they wrote
down in one of their papers a good error
reporting manifesto I like to refer to
that because it kind of gives you an
idea okay and not a lot of people do
type or diagnosis people who started
they just started maybe it's a good idea
to kind of make up sure for yourself
okay what am i aiming for it is well it
should be correct detection and correct
reported so strange you want to be
precise or the smallest possible
location that somewhere in the program
but in this definition you want to be
sixteenth don't mention any stuff that's
irrelevant it should not depend on the
implementation so we wanted to be a
mechanical it should be source based so
the sugar rings actually out of the
question or you have to have some
mechanism for translating it backwards I
think much harder than simply not the
sugaring in the first place most of the
compilers especially when we actually
started to do this for the first time
we're very biased because they use Hindi
Milner's the most Milnes implementation
that kind of traverses the program and
this you need to form unification or
equality tests on the fly between types
but that also means it's very dependent
on the order in which you make your
mistakes or in this case I take the head
of a list but the problem here is at
least can only get take either boolean
or characters not both at the same time
but you can tell well there are many
characters there's only one boolean but
if you try to say most compilers it will
complain that one is not a boolean and
then you change that into a booster but
two is also another podium and three f4
f5 that's all alright so this kind of
bias and of course if you say well I'll
change my order to go always from the
back to the front then I can change the
Lister out to get the same problem yeah
so there's no fighting bias there's
always an example that really screws
things up it should also be
comprehensive you should leave
information a way that is necessary for
explaining everything so these are think
are always wise thriving for sometimes
you will focus on the one sometimes you
will focus on the other but in the end
quality is extremely subjective it
depends on the intentions of the
programmer yeah
the reason why I said the mistake is
here is only because I say this is
reversion thats palindrome I could come
up with different names here and you
would think the mistake is here why
would you do that by convert compare it
blob of X's with access for a particular
definitions of block right and of course
a compiler will not look at your
identify is probably in reversing
reversing again with the spell on drugs
right that's not the kind of thing that
your compiler can come up with so I was
like yes yeah well yeah we'll have
compilers that can only compile program
just complete ballinger that would be
nice a lot of time on hands all right so
it depends on these factors it also
depends on program experience it depends
on your background are you PHP
programmer this trying is handed at a
school or are you akhtar programmer or a
curry programmer trying his hand at
haskell you can get from higher up and
deeper down and all of these people will
tend to make certain kinds of mistakes
because they still have this Beach be
feel or whatever in their fingers so its
type early diagnosis they don't
enterprise yeah if everything is
subjective well I don't think so what's
first of all there's a lot to learn it's
also not to be careful about but I'm
going to explain to you what we did in
2003 already so quite a bit time bill so
actually we implemented to make specific
type as actors we didn't call it like
that because nobody talked about
domain-specific languages I'll only did
that when I wrote a new proposal three
years ago and everybody was talking
about the base specific languages and as
it happens it is about my specific
language so at that time we will pay the
compiler called the helium compiler
which meant to be used by students when
they started to learn how to program it
is a subset of Haskell has 498 minus 5
plus definitions and this is definitely
it does have type classes but they're
all built in and it does have instances
but authorized and so you have your no
man you're showing your each class and
your art class but you cannot add your
own stuff unless you build it into the
compile that you can't play with it it's
recently I put it on it on the
so you can play with it if you really
want to it has a constraint-based
approach with many ristic swirled
absorbers but most importantly it
supports this domain specific type a
diagonal some can explain to you how we
do this not how we do it what it looks
like when you use it so it's about the
main specific type right now so let's
look at the definition of juanita high
for domain-specific languages you have a
domain with the central notations clear
informal meaning slave and the formal
meaning is clear implemented to which I
like to add domain abstraction should
not lead for example and so embedded
domain-specific language from resume
still zooming in to that very tiny part
of the world when I have to start solve
problems so embarrassed languages
internal if you if you are like a multi
foul they are achieved by encoding the
diesel syntax inside of a host
general-purpose language and according
to a hudathan sets the ultimate
distraction so there are quite a few
advantages compared to usual dsl's you
can say and these are arguable because
people will argue against the fact that
ejection advance of disadvantages but so
you might be able to use a familiarity
of the host language because maybe you
have you just want to optimize people
implementing stuff in a general-purpose
language by providing them with EDS else
to do their work quicker this is not
going to be useful to you if you want of
example use dsl's or four for
non-programmers X equal that might be
different it gives you an escape has in
case you forgot something or in case for
example you would like to use the
floating point somebody else implemented
you don't want to implement all over
again for your own need for your own dsl
I can imagine that so you can also use
existing libraries compiled IDEs you can
more easily combine these else because
yeah usually the assumptions are working
1 dsl sequel they say oh wait a minute i
also want to have some other stuff like
machine learning stuff in there oh how
do i combine it if all of these separate
two separate compiles it's much more
easy to do if it's just a matter of
importing libraries and hiding a few
things we named you
but even if you don't agree with all of
this I think it's the useful prototyping
the users because building a DSL with an
IDE is a big investment and here you can
play around finding trying to find the
right vocabulary the right fluency food
DHL so there's still two challenges at
least in high school I think also the
other languages domain-specific
optimizations and domain-specific type
or diagnosis optimization and the other
are also complicated and hard to do in
the non è dsl setting but there you
have more control because you're
basically building a complete new
compiler click new environment and today
i'll talk about how we can do something
about this domain specific area
diagnosis getting this control for error
diagnosis inside Haskell and asked what
so to do that I need to introduce an e
dsl just for the fun of it so I usually
take partial culminates as an example
basically what it means it's an
executable form of ebf and extensible as
well so everybody i assume knows about
context free productions and this is a
no terminal C D and E and we have small
tokens a and B so these are terminals
and you can translate that to a parser
Combinator implementation where you say
well the parser culminated see is just a
high score function that first runs the
parser d followed by the parser e or it
parses the token a or it parses the
token be that's what it says I hope to
that's just that force juxtaposition we
have to use start because function
juxtaposition is already used by Haskell
for just making function calls and here
we just take a slight variant of that
symbol there so essentially no terminals
become Haskell functions you can add
semantics with the dollar this just
applies for function to the result of a
part for example there's lots of other
communities that are defined but also
nicely just the library you can add your
own that's how these are things like
sequential composition so first bar C
and then at first D and then ebah throw
the result of iya way and this is Frodo
from
for the first results the first person
away and these are things like zero or
one time this is star this is plus in eb
+ f yard but they don't really matter
the thing is that you have such a
library and what you would like to do
first let's let's first see the problem
in its full glory so here i write a
parser for expressions which is either a
expression at the end priorities level
all it's a lambda so how do I parcel
onda well it starts with a slash then I
have a list of identifiers which I part
with this befall the one then there's
the arrow and then there's the body of
the lumber the same X problem actually
expect two arguments the list of
identifiers and the parts of the body it
doesn't care that you actually read this
particular symbol there and actually i
should have permitted this larger then
and then everything would have been
correct but now i get this error message
why because the underlying
implementation the encoding of partial
culminates inside Haskell is revealed to
the programmer who of course you have no
understanding of this whatsoever so it
looks large it's complicated you have to
actually match up the type yourself to
say we're actually is the mistake takes
a long time it doesn't mention parsers
anywhere and as it happens it's actually
very easy to fix it's just one larger
than side so what were you in the helium
compiler we brought the type inference
mechanism under our own control
explicitly generating constraints
instead of solving things on the fly so
that we could manipulate the set of
constraints and then we provide hooks to
the programmer for describing the way in
which the type inference process behaves
for certain classes of expressions not
for all expressions in high school but
only for those in our case that have to
do with parcels now what is very
important is to be able to guarantee
that by doing that you don't change the
type system you don't subvert so that's
actually that was the
the thing that we also needed to do and
we can sorry's so how do you organize is
in a high school setting well basically
if you build a module delay ABC with the
high school extension you can also
supply and typically the dsl designer
will supply the file called ABC do type
that contain certain directives i'll
explain it means what they look like and
the idea is that whenever you compile a
deed of HS it will load in this ABC do
type it will store information also in
the generated code for this ABC later so
whenever you import a b c dot somewhere
else the bytecode file summaries you
give the generated code to somebody else
he also still profits from your type
error diagnosis improvements alright and
the compiler will do all of that for you
it will just rip out these rules and
apply them for you to make of course
better it's up to the library design
yeah maybe they will also apply these
techniques and they have a nice servant
dots type file they say well for every
expression that deals with any of our
Combinator's you get an error message
 or read the manual page 78
 yeah so it's just up to the
programmer the library designer to
decide what do I want to communicate to
my end users you can also think about I
mean this of course is not very
realistic because they like their
clients they'd like to keep them but I'm
a teacher of functional programming and
maybe in the first two weeks most people
start the program i want to say well
whenever you make a mistake that
involves map or folder i just pointing
to the page in the lead lecture notes
first we'd over there and then come
complain to me and they've got two three
or four weeks i will change that back to
what it actually is but the thing is i'm
in control feels great alright so let's
look at one of these specialized type
rules now still in and let's say
deduction style format cause we're going
to ask you art later on so this is one
of our code parser culminates is the
dollar what does a dollar do remember
the dollar takes a function and takes a
partial that generates a they are yous
and then applies that function to the
result of the pars so it becomes
be a posture that produces B values all
right so you can actually write a
specialized type roof for this in this
way when you say hope so if I have this
dollar then the first expression is a
function from A to B the second X sub
expression is a partial as a and then
the resulting type is parser as be an
accent why are not necessarily variables
they can be any expression with that
time so this is our starting point and
I'm going to work that around to do to
the specialized typhoon so when I first
do is I rip out the special to specific
types and I replace them with
placeholders like tau 1 tau 2 and 3 and
I make explicit on the side what
constraints are therefore tau 1 a 2 and
a 3 so this is clearly i hope equivalent
just took them out just a matter of
notation but i'm going to do a bit more
i'm also going to separate some of these
constraints because implicitly by
enforcing disqus rating that constraint
I'm also implicitly enforcing that these
simple types the things that they bars
from are the same so actually I'm going
to make the set of constraints minimal
in the sense that I have as many as
possible and each of them only
contributes a very small thing to the
correctness of this expression but in
the end it's still equivalent and now I
write it down in a nasty fight like this
so this is exactly what you would write
in our specialized diapers this says for
every expression of dollar I have these
meter variables x and y they can
represent any expression i introduce
names for the type that they should have
and these are the restriction on those
games in that particular order that will
be checked by the compiler and if i did
it correctly these are actually the
constraints that would be checked by the
compiler if i didn't write this rope the
difference however is is that i can
associated with every economy of
constraint a special error message and
now you see that hey when this failed so
that one fails it actually mentions
partials so that's
people there is however Sophie you can
also i know that it will check these
from top to bottom that means that when
i check the fact that these are the
correct simple types i can talk about
parsons because i know that these two
have succeeded its eyes never the risk
that actually when the guy the person
program it goes bad and he says he's
complaining about the single touch but
these are not even parcels which might
happen if i would check these things too
soon so i can use that information of
course then you get error messages like
this which is a great improvement on gac
of course we're missing lots of stuff
and those are what we call error message
attributes things like the position of
this whole expression in the program so
we can write that by interpolation
expedit pause expert OPP over there
that's the pretty printed version of the
expression expert OTP would be for
example the type you can also
interpolate the types that at that point
have been found for t1 t2 and t3 all
this information is available and then
you can write it like this and then this
is the error message that you get so now
you see it's a 2.com a21 the right
operand of dollar over there that string
hello world should not be a string
because it it should be a partial
harvester
you can also when you don't like to
write all these constraints with all the
error message here you can also
interpolate some of the constraints back
in and then you get the usual error
messages for that particular constraint
you can still the ones for once if you
right here you get them exclusively so
for example if you don't care about the
fact that the three is something of
partial kite initiative show type is not
a partial then you can just interpolate
it over here and a compatible check it
for you but you get the usual error
message and you have a bit more control
but let's skip the front all right
that's another your last one is a person
has an incorrect result was gone yeah
that's yes there is indeed it could be
but this is just what I decided possibly
yes but of course if you actually ha but
I'm pretty sure you can write really
good parse error at least type airship
type of a message is accurate all right
yes yeah so so you're correct and of
course it's all up to me to write that
in here in here I can explicitly say
okay I have this type and I've that type
I'm not saying here that one of them is
not correct or anything I just say with
this type and that type and they're not
consistent but it's up to me maybe the
effort is worth it maybe the effort is
not worth it but of course it is
something you have to take care of right
yeah but but I think this is a crucial
thing there days so also when we submit
papers they often say but you don't seem
shows that you can improve diapers but
it's we only give a mechanism for
somebody to tailor the error messages to
either improve them or make them worse
because you like the old versions of GNC
much better I don't but yeah but it's
possible the thing is that if i want to
write a let's say aren't biased yeah
because actually you've correctly seen
actually that this is biased it says oh
this is inconsistent with that so that's
to blame so yes i hope that in a real
implementation i would never give this
error message but I would go for a more
biased area mess it's where I say this
does not is not consistent with that and
maybe I can explain a bit more or how
they can fix it it's over that's a good
person so the final facility I'd like to
discuss the siblings but it's pretty
simple so you could write it like this
in the same type in in the same type
directives file so basically what
happens here is that well
let's assume that you are a PHP
programmer and you move to Haskell and
you constantly make this mistake that
that you that you write dot for string
concatenation instead of plus plus well
then you can train it by writing this
for the compiler to check ok if there is
something like concatenation going on
but you use a dot replace the dots by
the plus + 0 is it not type correct ah
then we give it suggests a fix and this
is very easy to add and you can also
change it depending on the group of
students you work with whatever you like
it's all from the outside you don't have
to delve into the internals of the
compiler because that would be a no no
but so this is the situation in 2003 so
this was domain specific type error
diagnosis in 2003 a few years ago I
thought after doing some type of effect
systems it's time to raise up the Rays
this idea from the dead again but now do
it 4 s 4 2010 so I wrote a proposal to
scale this whole thing to ask for 2010
so that you can that it actually works
when you have geds attack families and
blah blah blah and I have a student
working on that since 2013 so it's a
desk igniting it complicated enough well
we've just learned that no not by a long
shot we need flexible instances
multi-parameter blah blah blah blah blah
if you look at the top 20 of downloads
of hackage packages 10 of them use
flexible instance is nine of them use
multi parameter type classes and this
goes up and this was already a few years
ago it's probably much worse now at it
and then people use the unities they
used by families they use functional
dependencies existential quantification
scope target none of these are supported
by helium none we don't we're not even
high school 98
so I tried to sell this as a prop in a
proposal as a project and then one of
the reviewers said this is going to
revolutionize program so I got the money
but I think that's it so what else we
accomplished since then well we've
worked on could having conditionals and
Tyros regular expression and if you want
to play with it and now's the time to
type in this URL since you have your
laptop on any way you can play with it
at this website we've done a few more
things but this is what I could want to
talk about a little bit so why do we
have map &amp;amp; F map yeah so map is the
usual list traverser and f map is this
the one that is in the front or close
well part there's tradition Matt was
there before functor was there but you
might also say well why not get rid of
this map guy and just use F map all over
the place well one I think this is
partly or diagnosis if a student comes
to me and starting to learn about films
of programming they apply map to lists
and yeah in lecture number a to talk
about f map after type classes and stuff
but but not in the first two three
lectures but I do expect it to use map
already at that time yeah so and then he
makes a mistake with this from torial f
map and then you get some life from
tabla instance by so yeah so I guess
this is why you can keep map around so
we introduced conditional matching in
type rules to make sure that you don't
have to keep it around you can just have
tailored error messages for map in case
the type Klaus instance happens to be
list you can also have something similar
for example that you can introduce bonus
comprehensions back into high school
because you can tailor the error
messages for this comprehend for list
comprehensions in high school with these
rules there's much more to it so we have
whole paper about this but there's much
more to it I can't do it but the idea is
that if you can decide before an error
is discovered that F map is working on
lists then the special rule will kick in
and tailor the error message for list
and talk about this
the second one we've looked at is
regulatory expressions so you can right
now maybe I did not give this idea
directly but you can write arbitrary
almost arbitrary complex expressions on
which to better match for which you want
to improve so this only improves the
error messages if we apply map first to
it and then some list XS where map and
it our library functions that have been
defined and I could also make it more
complicated but that's about it here I
have two metal variables x and y with
some single operator in between what you
cannot do is write lambda 0 what you
cannot do it was right let's over there
but any application even though can be
nested I can also have here an
expression that applies a particular
function to access for example it's all
fine it's going to work out fine but
this is all you can do and my pc
cinquain came up with an idea that so
this is pretty simple but he said well I
would like to have some kind of
repetition and choice to be able to add
to my patterns and actually became of
regular 3 expresses that actually we use
regular three expressions and somebody
else came up with and I'll explain a
little bit what that looks like there is
already a disadvantage so when I use
helium I get a complete and sound check
for my specialized type roles here I
have to resort to something like
twitching and turns out escort reviewers
a task or symposium really don't like if
the type system is checked by cool check
yeah so I'm yeah this is not my own
computer the other one burned down so
but let's look at an example why this
would be nice to have so let's think
about the gdt we have X parades where we
have a plus and the moat and we have
literally and the literals have to come
from the noon class so basically these
are arithmetic expressions where you
have literals for example integers or
floats and you can build expressions
with plus and multiplication now the
idea is that when you have a literal
offer like let's say a float in your
tree then all the other letters also
have to be flux and if there's an int
all of them have to be in but the
problem is in in all these unification
base type error diagnosis systems they
all go through your expression and they
will do it in a particular order which
introduces bias so my piece decency well
if I have a function like execute that
evaluates to the expert and returns the
result of evaluating this expression
yeah if I can have if I know something
about this expert eh I would like to be
able to verify for example first that
all the leaves are checked correctly
typed so the lids are correctly typed I
can give them a type because it could be
that something there's a function there
or or it's a function to therapy type
and express it cannot be tight but once
I know that all my leaves are well tight
I can verify that they all have the same
type a4a so the same instance for a and
then I will verify that this a is
actually in the num plus and then I
answered of course you might say well I
prefer actually to check first that all
of the things in the tree are in the new
class and then check that all the set be
my guest it just changed to rules around
in your specifications this is not a
specification to be too complicated for
now to explain but you can do it you can
always need to modify it to whatever you
want it to be we only give the syntax
for writing down these rules and like I
said if you want to play with this these
things are
on the way so I have introduced the
problem of type or diagnosis I've
introduced some specialized divers to
achieve domain specific type area
diagnosis and informs you about some
recent developments and of course
there's lots of ongoing work so first of
all we're looking at lightweights
approaches so that we can actually
already get some of this in d8c without
changing G&amp;amp;C too much another thing is
we're working on is integrating in
productivity hiring types into outside
annex as implemented in GNC because one
of the things that is necessary for this
to work is that the type inference
process is constraint-based and it's one
constraint solver while in GHC is a
bidirectional type system followed by a
constraint so oh so outside in X is the
constraint based formulation of the high
school type system adidas couldn't
almost clearly implemented in GHC yeah
good question and and we're also doing
cosmetic changes the cintas because the
rules don't really look very nice and
then there's future work so we did find
that writing down these rules is not
easy there's a lot of syntax going on
and we already have good ideas I think
on how to make this by making this
interactive to make it much more easy
for non type system specialist to be
able to define these kinds of rules we'd
like to them to experiment with live
with developers and then users and move
to dependently type languages like
iteration after because that's where the
real improvements I think can be made
because all right and and spread the
gospel of course further to any language
that is interested in Scala maybe I
don't know so I think that's it and I'll
leave you with the credits of people
that have contributed to all this work
thank you so you have a hypothesis which
sounds really plausible which is that if
you allow the user the embedded
domain-specific language designer to say
what type messages they want that this
will be easier for users that sounds
very plausible and you gave an example
but you know now we need to validate it
and you gave an example in your talk you
said look here's something you might
write down and it gives you this
horrible error message which is hard to
decipher where is the bit of the talk
where you said here are the rules we get
them with these rules it gives you this
much nicer error message and don't just
say well we could do it right oh yo you
want some evidence that it actually
works in practice practical in the title
you this one yeah yeah so actually you
can actually I deleted it because I
deleted the slides ahead on siblings
because I had two main slide but this is
actually something that is solved by the
siblings mm-hmm because the only thing
that needs to change is that this guy is
replaced by / less than star and then
it's correct so if you would actually in
the helium compiler if you have that
sibling it will then might be risky so I
had other presentation from which I two
things and
probably i deleted it's over there
festivals presentation around some of
these are took from a talk I gave the
charge let's see a bit more elaborate a
bit more technical I had a bit more time
here as well
and of course I mean the only thing is
that if I think it explains well what's
going on it doesn't mean that it's a
particularly good error message because
and yet it all depends on how much
effort do you put into yes actually
here's the other way around here i omit
it this one and it actually should yes
that you put it back what all right
that's okay so helium does this for you
right and I collect you do some
experiments of sitting users down and
and and you ask them how satisfied you
are no you give well with JC and helium
and we need a miracle work oh yes and we
will but the thing with helium was that
so we'd actually we built all of that
and then the lecture of that course
decided not to use the anymore i'm not
that lecture and now i am the lecture of
that course but the same with Healy yeah
so the same with you leavin is that so
we I think if I've profi programming
assignments in my course you can only do
the first two at the most the other
thing you cannot do because you have to
define your own type class you implement
in if they find a role monads you have
to use the gloss library and then I have
to demand that by you by my programmers
switch during the course from using
helium to the other and that's that's
too much about the number of complaints
hmm count the number of complaints it's
actually so so that a nice n ago maybe
is the following so gorge it doesn't
have domain-specific diaper diagnosis it
will shortly because we're working 30
hardness but so I was the Haskell
implements meeting last year and I was
also working on the lecture notes for my
course and actually the lecture notes
mentioned this is the helium error
message this is the very bad GHC error
message I can written that but my fault
and I was running through these examples
again it turns out the GSA simply gives
exactly or isomorphic lee the error
message that he leaves so i mean an
actual assignment was in the room and i
said i think Simon has been influenced
by some other compiler maybe helium and
he was like nothing like this so yeah I
think he yeah so I think I think for him
helium was a wake-up call at the time 22
nah mean if if they can do
it better than I can and I have to
improve that Lisa school Tuesday orbit
of course he doesn't have to make
specific type a diagnosis yet but
actually yeah we sort of agree that it's
going to be part of this oh yes yeah but
that's that was the experiments that yet
surely and I've actually a sec so do I
did one experiment where I had students
students writing these these things so
these were at the time that's
undergraduate level students writing dsl
typhoons and they found that to be
pretty hard so one thing I did not
mention is that when you start to write
down these rules for example there you
want to have some kind of uniformity of
your type error diagnosis that if
example contrast something indented four
characters blah blah blah so we need
some abstractions there to be to make it
reusable that you have a template in
which you fill in information to change
the template stuff like that so the
usability is really something that I
want to pay attention to and yeah 35
like I said sure
maybe should go over to my presentation
and are these enhanced type error
messages do you think they might be
useful for has spinners only for
students learning Haskell already use it
oh I think it's quite different I think
that gift so so the question is is this
for whom for what group of user Haskell
uses it is you sources for every user of
Haskell or is it just students for
example so I think the people
implementing the servant library I think
they would really like to have this kind
of facilities because other people are
using their dsl that and they may not
then come to complain ok there is
something really strange going or I
don't understand this error message if
we can explain it better if we'd if you
can talk about because they do lots of
stuff to type level and with our
conditional rules for example we can
better match on that you could say you
can give different error messages and
this is kind of like the vision I have
when your list contains JSON your type
level is contain Jason or a doesn't
these kinds of things are then possible
so actually I think it's much more
useful for the professional program and
then it is for the student program
because we are working now on those
things yeah that students don't really
need to know about yet and when they
come to our course an advanced
functional programming Natalie then your
danger to our type level programming and
then you learned about Mona transformers
and all that stuff and DDT's but in the
first course that IT and because I'm
going further their moment type of
monsters that's all so there is less
useful I forget
said okay now we'll go see no you first
so how do you see this extending to
languages such as Scala or a dress or
agda that aren't in the sort of broad
Hindley Milner tradition where it makes
sense to collect a giant bag of
constraints and then try to solve them
at the end yeah so recently I had to
look at the taxes too much Carla and
that there's a lot to explain about it
that's for sure but the basic thing that
uses some sort of a bi-directional
approach right yeah but I also I mean
they're already I think teaching your
programmers about the subtyping
relationship and the x direction that
combined with if the course that's
seeing that Java for example gets all
these new features they will get the
same problems that Haskell has had all
the functional languages have had and
much worse because the way they put it
into the language is much less elegant
and less orthogonal and so it's a much
harder time they will have to explain
and actually I actually papers about
this Java genetics playing John genetics
not the domain specific time very close
but just using heuristics and that took
us quite that's nice but yeah nobody
picks that up and back in high school so
for some reason we've seen the people in
the whole world's either say they don't
care or I don't want their speakers with
you thanks do and there is some
different exactly
yeah you had a question the one with the
green yep pretty much the same question
but I mean to say whether I mean you
mentioned maybe you could do the same in
dynamic languages but that would mean
just rewriting the wrong Paris I would
be super I would say I was crawling with
you okay of course nobody's gonna do
that but actually I actually had a slide
about this of course I mean also people
writing in dynamic language they find
out that you can't really build
dependable big systems in them and then
you go from PHP back and once you add
when she let the pipe system in there
goes by each index right you mentioned
that we might get a lightweight form of
this in GHC is how can you talk about
that how does it differ from what you
present it that's coming you mentioned
that we would we might get a lightweight
form of this oh yes look like how bad so
my student has looked at this and so
survives from some very small
modifications to the GHC he has been
able to kind of associate well to bad
feeling here give me back that what you
can't do but of course it's not a whole
lot as you can
pair of messages like these so the idea
is that you can associate error messages
like these inside the hospital where you
make the definitions of your functions
or where you use the functions you can
so he made some kind of type of level
what's not good later so it so it's sort
of different than some kind of different
kind and then you can work that later
you can associate this error message and
later also kind of says don't check this
immediately but wait a little bit but
actually when it then finds out that
that that that particular constraint is
to blame it will in addition to the DC
area message also give that particular
line of text so this is really hacked
into the GT but it's really lightweight
and you don't need it's just you just
write this stuff in your own Haskell
code you don't need to separate files
and everything because it's just as it
is only in addition to the GT at a
message and it's also checked for
samples</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>