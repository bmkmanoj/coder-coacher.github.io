<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Brandon Dail - Building Web Apps with Reason | Coder Coacher - Coaching Coders</title><meta content="Brandon Dail - Building Web Apps with Reason - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Brandon Dail - Building Web Apps with Reason</b></h2><h5 class="post__date">2017-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Yflk43afWj4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we web application excuse me web
application
with reason ml what I'll just call
reason before I talk about what that is
my name is Brandon Dale
I repeat formidable abs we're a
JavaScript consultancy doing a lot of
cool stuff with JavaScript like react
and node at scale and open source so
come talk to me if that sounds cool and
I'm a really on everything that's
important so we're going to talk about
reason and how we can use it to build
web web apps but before we do that I
couldn't even set the stage a little bit
and kind of get an idea of why I could
even ask this question like what has
brought us to this stage that we're
looking at alternative solutions for web
applications and the first point is that
historically javascript is really
difficult to scale with who uses
JavaScript cool here in the right place
then who's had trouble using javascript
cool yeah so you guys would I mean it's
a dynamic language it has a lot of rough
edges you know the most recent versions
with es6 in year 7 and Beyond are making
it a really great language but for the
majority it's it's just been a little
tough and part of that is it's the only
language about web browser support
so even though it's tough to use you
kind of have to use it if you want to
build for the web which is you know it's
never fun to be forced to do something
and the other the last few years
especially the web is a really growing
platform with grilling requirements here
your users are going to expect that your
web application provides a feature set
that's pretty much on par with your
native application in a lot of cases and
that's even going to be more and more
true you know as we go and we've seen
any monitor than javascript tooling that
the community wants better language
level abstractions right and the biggest
thing we've seen is like Babel you know
people want to use new abstractions like
es6 es7 and beyond now and that means
that we're starting to compile our code
right compilers are kind of a common
part of rumata in javascript don't stack
who here uses babel or something like it
yeah what people it's not in common
that's a relatively new change so we've
got to the part where we're really
trying to compile our problems away and
that's mostly a valid approach
like I said compiling is now pretty
common we've come to accept it
you're not going to be outraged by
someone compiling their JavaScript the
compiler comes at a cost and those costs
are both abstract and practical right
you know compiling can be slow
it adds complexity to your build system
whereas the build system even if you
didn't have one before you have to have
one now and it introduces a layer of
indirection between the code that you're
writing and the code that you're running
obviously so we have to make sure that
the benefits of this new source language
that we're using whether that's the new
versions of JavaScript or an entirely
other different language the benefits
outweigh these costs so to kind of get
an idea of how we can judge that I want
to set up a couple points on the
criteria we can use to judge that so
this is to judge know is this new
language and compiler with it and the
first point is accuracy all right so the
JavaScript compiler has to accurately
represent your source abstractions at
runtime right like I can write a Haskell
to JavaScript compiler in a day if it
just compiles to a bunch of console
about log calls right it's an extreme
example but it kind of illustrates the
point that the patterns you know they
need to be accurately accurate and
consistent during you know runtime the
numerator which has to be expressive you
know a usually a compiler wouldn't worry
we're accepting these costs so the new
language should let us express our code
better than the original language so
that means we should be able to either
use existing patterns and abstractions
more clearly or safely or succinctly or
it should provide new ways to express
our code new data structures control
flow ways to express our intent compile
time checks I mean forget a user
compiler we should probably use a
compiler it's doing some sort of
checking for us right for example like a
static type system that checks types if
it's just translating you know source
code to source code or to target
then maybe we're not getting the most
out of it in our this is huge the code
that it compiles really needs to work
with existing code the JavaScript
community is giant there's you know only
thousands of modules maybe more on NPM
and other package managers the code that
were writing needs to work with those
and it also needs to work with any new
JavaScript code and that goes both ways
right so we have to be able to call
JavaScript from whatever language we are
using and JavaScript has to be able to
call whatever our compiler outputs the
bug ability I wasn't sure if that's a
word it sounds like a word so how did
our compile time check so the language
abstractions are we're probably going to
have to debug at run time even if you
have something that guarantees no rent
I'm type exceptions or exceptions at all
like elm you still might have an issue
that's not necessarily related to an
exception you might have a logical error
that you need to debug at runtime and if
that's difficult or impossible you know
you might be losing out junior family
and this is really a point more in the
context of the community and community
adoption rather than in a specific
implementation or application but if
they're going to talk about using a new
language and adopting a new language we
want to make sure that it's accessible
to everybody in the community but
because adoption is affected by how
accessible the language is if there are
features of the language or limitations
of the language that limit that no
matter how great those abstractions or
limitations may be we have to consider
that as a potential downside so we look
at those I listed a bunch of stuff
whatever in our options and might be
they really is going to involve three
technologies first a camera which is
going to provide the semantics it's a
programming language who here has used a
camel oh cool a lot of people it's been
mostly used in academia for a long time
and in some sort of niche or maybe niche
with smaller industries like finance
we're also going to talk about using
reason which is a new syntax for camel
and also sort of a tool chain as the
logo says now we're going to talk about
buccal script which is what's going to
let us actually use reason and okay ml
for the web so I'm going to talk about
these kind of out of order but just a
quick overview about camel for those of
you who haven't used it it is a dialect
of the ML language family so ml I think
other dialects like standard ml very
functional developed by Aaliyah I think
so that pronounce it which is the French
Institute for research and computer
science and automation and it first
appeared in 1996 actually a year after
JavaScript interestingly enough it is
messy paradigm so ok it was really used
as a functional language but it also
supports imperative and object-oriented
programming so it's pretty flexible its
popular with the finance of Jane Street
who's actually sponsoring uses it pretty
much exclusively as far as I know and
you know for those Roger s is an example
of an OK ml project and then there's
reason and reason is much newer it's
about to Facebook but it provides a more
familiar interface for users who might
not be familiar with ml or its variants
it uses a camels PPX system which is
part of the compiler I believe that
basically lets you hook into compilation
sort of at the ast level and transform
the syntax which is how reason even is
allowed to work and it's also meant to
provide a lot of tooling and I'll go
over the more specific aspects of the
tooling that it provides in a little
later but first I want to talk about the
language itself for those you know you
have an extra use it or not sure that
provides and so keep in mind that when I
talk about the language I might say
reason or Oh camel interchangeably
- selfies Oh camel and reason is just
the interface in this context so if I
use those interchangeably I hope it's
not confusing if I'm talking about
something specific to reason and what it
provides I'll try to make that explicit
so first off some basics let bindings
and scoping so you define a variable you
slap bindings or block scopes so here we
define a film named and we assign its
value to a block that defines a couple
local variables
Brandon Dale and then the last statement
in the expression is the value of the
expression so full-name ends up being
Rena Dale so the type system is is
really powerful and it's it's pretty
complex to the point that I probably
can't cover a lot of it in this talk but
basically you have type annotations just
like most statically typed language is
but it also has a powerful type in print
system which is one of the biggest
features of ML languages they have
really great type inference so it's a
powerful type system that really gets in
the way
it also supports algebraic data types or
a TTS here we define a vector of intz
and it has permitted polymorphism so we
can sort of define generics in this case
we have a generic vector type so talking
more about a TTS we have a a contract
called a variant which might be called
disjoint in some type discriminative
unions all basically the same idea here
and then Isis represents sort of
heterogeneous data in a type safe way
and here we define a color variant with
red blue yellow and other these are all
type constructors and note that other
takes an argument which in this case is
a string so variance can actually prove
data in a way that can be accessed at a
later time then we have records pretty
basic just key value pairs this is a
user record as a handle it's a string ID
that's in it and then we're using that
color variant that we just defined
previously pretty basic and these are
mutable by default that does support
mutable fields which we'll talk about a
little later one of the greatest things
about the language is its pattern
matching system so here's an example of
using
and matching with variants and pattern
matching is pretty pervasive in the
language and in this case we are
defining a function called hex which
takes a color which is of the type color
that we defined earlier and we're using
the switch statement to switch over it
and handle all the cases for that
variant and we can see here that pattern
matching lets us sort of extract the
data from a type constructor
specifically other we're getting that
string value which we assume is a hex
value for the color and returning it
really the best thing about pattern
matching here is that it's exhaustive so
if I forgot to match blue for example
the compiler would give me a warning
that the pattern matching is not
exhaustive and then it actually gives
you an example of a pattern that you
forgot to match so this is really useful
and it also applies to pattern matching
with other data types like lists so
here's an example of a recursive
function that sums up a list of numbers
and we can see that we're using a switch
statement again to pattern match the
list and when it's an empty array we
just return zero otherwise we add it and
recursively sum up the the tail of the
list so it's a great way to handle sort
of abstract or like compound data like
lists or variants and of course ok moles
only uses a fossil language so the
functions are pretty functional here are
just a few of sort of the main points
that you get you've currying and partial
application pattern matching
specifically with a function keyword so
functions can be defined specifically
for pattern matching you get labelled
arguments and you also get optional
arguments with optional default values
as well and then modules so to
paraphrase from probably one of the best
books on ok ml real roldo camel ok there
is almost two languages a poor language
concerned with values and types and then
sort of a module language concerned with
modules and modules signatures so module
is a huge part of a camel and they're
really powerful but basically every file
is a module by p5
modules can contain other modules so you
can define sub modules you can define
specific and explicit interfaces for
modules in a separate file like a called
an REI file so you can limit sort of the
API for the actual module we have
functors which in the context of a camel
are basically like parameter where
monetized
functions for modules basically that
lets you operate on modules in which an
Augmented or new modules and then we
have a concept called first class
modules which lets you sort of compact a
module into a concrete value so you can
use it with sort of variable bindings as
well which usually isn't possible it is
just a small example of a module it's a
user it contains a type T which is a
variant of basic user moderator admin
and then a function for getting some
sort of title from the user again using
pattern matching so like I said it's a
functional language but it also supports
imperative API so we have mutable arrays
we have arrays that we can sort of edit
in place the immutable record viewers
and again mutable fields have to be
defined explicitly by default record
fields are immutable we have these
things called Rex which are basically
you know sugar for mutable record fields
which kind of let you define a mutable
value and then we have imperative loops
you know we have three loops while loops
so mark ml is heavily used as a
functional language it can be used
imperative lis it also has a pretty
great object-oriented system with
objects classes inheritance all that
kind of stuff but moving on I want to
talk a little bit about reason
specifically so reason does provide a
syntax that makes okay I'm a little bit
more familiar but it also provides tools
that make it easier to use and one of
the best tools is what's called a reason
format or reformat
and I'll see if it plays it's supposed
to be a gif oh gosh no it's not a good
it's not working but it's a gift trust
me
so reformat basically is a formatter for
reason so you don't really have to think
about formatting your code if you've
heard of prettier for JavaScript it's
what inspired prettier and it does
motivate these beyond just sort of basic
formatting it can identify you know
optimal constructs for your code for
example if you try to do a pattern match
on just a true or false value it can
automatically update that to sort of a
ternary expression so it works again
beyond just basic formatting there's
also this thing called Reason tools
which is a browser extension and what it
lets you do is it lets you visit any
sort of resource that's written for
o-chem net and then automatically or
explicitly convert that code or code
snippets over to reason which is really
useful because a lot of the
documentation out there or tutorials for
the language are written with just the
plain of kml syntax which makes sense
because reasons only been around so long
and camels been here for 20 plus years
better errors this is something that's a
work in progress but I think it's going
to make reason even more attractive and
it's already working pretty well so if
you've ever used Elm you've probably
seen that they have really great error
messages and if you've ever used reason
the error message is really they're good
but they're not as good so better errors
is an effort to make them even better as
the name suggests basically here we have
an error about an optional argument so
yeah we can progress but it's upcoming
and any one of the most important things
that reason is providing us which is
even more than part of the tool chain is
what's called Reason react and it
provides an API for writing react
components using idiomatic patterns in
reason and lets you bind to the react
library so you can write react
applications in reason
and I want to walk through an example of
using using reason react and note that
this is the new reason react API which
was released last week or the week
before so if you see any other examples
online that look way different I promise
I didn't make this up it's just kind of
new but I want to step through this to
give you an idea of what the API looks
like so starting at the top we define a
component template using this method
called stateful component which takes a
string which is basically the name of
the component kind of like display name
in react really useful for debugging and
this component template we use to
actually make the component and speaking
of make we define a function called make
which is what reason react will call to
actually instantiate the component and
each prop for the component is defined
as a labeled argument so this component
greeting takes one cop name and the last
argument has to be the children for the
component if you don't you have any
children you can ignore the argument
using the underscore which is what we're
doing here which tells the compiler that
it's an unused argument so then we
define a click Handler and this is an
event handler for a click event and we
can see that it takes an event which is
the click event the component state and
then this self record which I'll talk
about a little later and you can see
we're ignoring event itself and we're
just using state and the interesting
part here is that we are explicitly
returning the update so if you've used
react before you know that setting state
is usually sort of an imperative API you
call this set state to tell you what the
next state is in this case methods
actually just returned the next state or
whatever update they're making and here
we're updating the state by incrementing
it by one
speaking of state we have to define our
initial state which is just a function
that returns our initial state and note
that in reasonably act your state can be
any value
as opposed to regular react where it has
to be an object so it's kind of useful
and here we're just using a number zero
and there is any render function very
similar to just react in JavaScript and
it takes the state for the component as
well as this self record again let's
look really closely here at what's
happening in render though first we're
just creating a string which is a
greeting using concatenation and then we
render it as an h1 tag and it's
interesting we note here that we have to
explicitly convert the string to an
element as opposed to regular quickly
just return a string or a number or
whatever and it might be a little bit
more votes verbose but it does
demonstrate how reason react lets you
write react components in a more type
safe way by default there are other
conversion methods like the Rader
element for like arrays and no element
for returning null and then we're
actually using that click event handler
that we defined earlier and this is
where we actually use self we're passing
that method to this update function that
is on the self record and update takes a
function and returns another function
that has access to state and is actually
returns the update type so it kind of
takes the place of bind which you
usually have to do in regularly act so
there's no sort of concept of this you
know this dot set state or this state in
reason react but really the coolest
thing about this that I've skimmed over
is that we're actually still using JSX
here and we're not using babel or any
other compiler other than reason to do
so because reason has native support for
JSX which means that we can use it
without any additional configuration or
setup and what it basically does JSX and
reason looks something like that and
then that's basically sugar for this
function call where you call this Dib
function where the props again are
arguments of the function and then it
adds this JSX attribute which is part of
the PPS
higher which reason than fixing to you
again and then compiles it to this
function college I hope you can see at
the bottom basically calls create
element with the name of the element and
it's important to note that when you use
a composite component like the one that
we just defined it'll compile it to a
call to that make function that we
defined it's pretty cool so going back
to our criteria how does reason an okay
ml stand up and I paid out the option or
the the categories that are kind of
related to the compiler but starting
with expressiveness I think we can see
the kimmells is very expressive
especially compared to JavaScript has a
great module system with explicit
boundaries it has a static type system
with really great inference MLT argument
curried functions all that stuff
it also has imperative coding or API so
even though we can use these functional
api's and add constructs we're still
working with the JavaScript ecosystem so
being able to use those imperative you
know code paths is really important so
for compile time checks I think pretty
much agree that that's also green we had
a really great type system again ml is
known for its type inference and the
soundness of its type system so we're
getting a really safe language and then
junior friendly I think this is
something that reason really provides it
makes a camel accessible to developers
in the JavaScript community at least
more accessible not only by providing a
syntax that's easier to understand for
someone with that background but also by
making the tool chain a little bit
easier to work with but we get to take a
step back because unfortunately you
can't do this
browsers have no idea what reason or
camel is for the most part in the public
we probably never will so we do have the
circle back here and talk about the
compiler because without it even though
it's a great language we wouldn't really
be able to use it for web applications
so again the compiler that we're using
is what's called buccal script and
buccal script
is a back-end for camel that outputs
JavaScript it's developed by Bloomberg
specifically one developer Bob Zeng it
has native support for reason which is
really great that means you can use
buckle script without actually
configuring any additional support for
reason anything like that it will
recognize a reason file and
automatically compile it it has high
quality dead code elimination so it does
that code elimination sort of at the
function and module level and it also
does a lot of things like inlining so
the outputted code is usually very sleek
extremely fast compilation this is
something that I wish I had more
concrete numbers on I tried to find sort
of a benchmark so run benchmarks but
unfortunately is I couldn't but
focus-grouped has time and time again
showed to be an extremely fast compiler
oh camel is already known to have a
pretty fast compiler relative to other
languages that similar sort of levels
and buccal script is no exception it is
much faster than babel and typescript
for sure and my experience faster than
other languages - like alum or pure
script it has no heavy one time and in a
lot of cases you can write code that has
no one time at all so there's no
inherent run time with buccal script
that has to be included the code that it
outputs can usually run on its own
standalone
it might input or it might import semi
utilities for things like type
conversions that need to happen at
runtime but otherwise it's pretty sleek
and like I said it is possible to write
code that avoids those imports and it
has a really expressive FFI foreign
function interface so it lets you bind
it lets you bind to things like objects
dynamic property access you know
functions uncrewed callbacks modules
there's a number of things that make it
really easy to use as well so let's look
at a quick
example of the language or I'm sorry of
the compiler output here's an example
that I pulled from the buccal script box
it's just using basically the HTTP
library from node and it's creating a
server I know this is the ml variant so
this is actually using reason this is
just regular or camel but we can see
that what it outputs is actually very
close to what the source code looks like
there's very little here that would
indicate that the code was generated by
a compiler other than sort of comments
and that pervasive import that's used
for like I said runtime type conversions
but like I said there's no inherit one
time but if you do end up importing
something from BS platform which we have
here pervasive z-- it is usually very
lean all of the standard library the
hazards runtime is written in Oh camel
and composite JavaScript so you get all
the benefits a buckle script there as
well and combined with like a JavaScript
bundler like web pack or roll-up that
does tree shaking you'll end up with
very minimal overhead in almost all
cases so getting started buckle script
is super easy now really all you have to
do is npm install this vs platform which
is the package for buckle script and
then it installs this global utility BSP
and when you want to make an application
that uses buckle script you just call it
with the adoption give it the name of
your application and it will set
everything up for you including you know
getting the buckle script by manning set
up a node module setting up a
package.json all that and it even
recently introduced a feature called
themes where you can initialize a
project from an existing template such
as a reason react project so that will
continue to grow and make it really easy
to use buckle script in a lot of
contexts in the JavaScript community
so certain that to hit all of our points
how does the script with reason look
first and with accuracy
focused it provides really not only an
accurate representation of our source
program but it does so in an idiomatic
way the outputted code is almost always
readable by humans I would say always
and it's usually well structured for
interrupt I didn't get to actually show
any examples of buccal scripts API FFI
API but it is very complete and like I
said it has bindings for functions
values modules getters setters all of
that kind of stuff and since the code is
often very well structured and buccal
script respects any interface files you
define like those REI files for modules
there's really no overhead for calling
functions compiled by buccal script from
any other JavaScript code it will just
export what you defined so it's really a
module to module compiler for debug
ability this again does go back to
accuracy a buccal script does a great
job without putting code that is really
well structured so stepping through it
at runtime is usually non-trivial
there's very little difficulty
understanding what's going on
so the question arises is it time to
jump ship should we delete all of our
JavaScript start all of our new projects
and reason call up our boss and tell
them that we're going to start migrating
now I want to say yes but probably not
and don't ever run that command that's
probably a bad idea I do highly
recommend using reason and experimenting
it with it when you can but it is
important that we try to identify all of
the rough edges so that we can kind of
make an informed decision about you know
how well it works for us and also so
that we know what the rough edges are
and we can help smooth them out so let's
try to identify them the biggest issue
that I've had is that most learning
resources use regular or camel syntax if
you mail a camel that's really not a
barrier for you but again we're talking
about using the language in the
JavaScript community so we want and then
we have reason which makes okay more
accessible so we want resources that
will also be accessible this is
something that isn't inherent to the
language or the platform or anything so
it'll get better over time
but right now it's a little difficult
difficult if you don't know a camel
because you have to go but between them
and sort of you have to learn the
language and the different syntax at the
same time which is a little tough the
big pool is in flux it's pretty stable
especially if you just want to write web
applications or just native applications
but a lot of the times you might want to
write applications that run on both and
that's where other great things about oh
camel is that it has of course a native
compiler so you can compile your
application to native code and the idea
is that eventually you'll be able to
have a shared code base for your web
application and your native application
but it is in flux but under active
development so it is as well getting
better
like I said targeting native and web
isn't as easy as it could be
which if you're just doing web this
might not be an issue for you error
messaging isn't as good as alternatives
like Elam just yet I did show better
errors early
but it's a work in progress and it's not
yet at the same level as Elm getting
close and hopefully someday it will be
and I believe it will sly reason is
there is limited use in production
outside of Facebook who's developing
reason ok itself has been used in a lot
of contexts over the last 20 years and
has showed itself to be a pretty proven
technology and language but reason and
buckle script have only we've been
around for at least a couple years and
the adoption is sort of rising which
means you know you're an early adopter
which inhaler means that there's
high-risk high-reward there's no
guarantee again that it will continue to
have the support that it has the
community around it is building and I
believe it's getting stronger and
stronger and I hope all of you
participate in it but again it's
important to realize that it is a new
technology as far as a buckle script and
reason for the web and that's it
thank you for listening here's a couple
of MIL resources oh I guess it wanted to
stop the docs for reason the docs for
buckle script and then there is a really
active discord channel which I highly
recommend joining where the community
talks and even the creators of reason
are very responsive yeah that's it
so you mean like how I'm sorry can you
repeat that I'm not specifically sure
how much you like how much buckle script
in reason are using the reason uses the
PPX system with the apart okay well
compiler supports so lets you hook in
and respond to attributes and so does
buckle script you can add annotations
which is how the the foreign function
interface works
I'm not pacifically sure to what extent
buckle script hooks into the existing
compiler or at what level but I no
reason again is mainly using PPX that
answers your question I'm not sure all
right yeah yeah it's it's the existing I
think it so camel it's a specific Oh
camel version 4.0 point two or three or
something like that so it is using like
the type checker and stuff buckle script
or reason they don't have their own type
checking system so although again the
language itself is okay is oh camel so
all the language features are compiled
or or run through do camel compiler it's
really just a syntax for the interface
and then a back-end for the compiler
buckle script which outputs JavaScript
so yeah
I haven't tried to use that and I can't
speak to the to the maturity of those
yet I know that there are a lot of
people working on it and that it is I
believe a goal to be able to write sort
of universal react code write react for
web and react native so it's something
that's probably can be very actively
worked on at some point yeah yeah that's
actually one of the biggest advantages
the question again is if you have an
existing JavaScript can project it how
can you integrate with reason and
because bucco script works sort of
module by module you don't have to
compile a whole program at once you can
move over and in JavaScript projects
nowadays are pretty much written in
modules right you have various modules
that export various things so you can
move it over module by module and then
just adjust your other existing
JavaScript modules to import the
compiled JavaScript files instead of you
know whatever original JavaScript file
so you can pile it and then just import
it and like I said bug the script does
respect like interface files so you can
define explicitly what's exported and
you can also make sure that the
functions for example that it exports
are easily usable in JavaScript so you
know camel like all functions are
curried by default right and in
JavaScript that would look really weird
because you'd have to like call a
function and call a function so you can
define you can explicitly say hey I want
this function to be on curried which
makes it really easy to call from other
existing JavaScript code
yeah yeah so I live yeah so the question
is like what's my personal sort of
opinion here or what's my background and
how do I feel about it personally as I
am a JavaScript developer and I haven't
really used a lot of languages like oh
camel in production or anything like
that so coming from JavaScript to a
camel has been I think as far as usage
goes a pleasure for me because you know
I see the advantages of static typing is
very extent I've used other static type
systems like flow if you've use that or
typescript in JavaScript so using the
language has been really great and I
think the type inference really lets you
use it without the type system getting
in the way of course that's the whole
idea of type inference so it's been
really easy for me I believe but going
back to smooth the rough edges what's
been hard for me personally is that the
learning resources again are pretty
fragmented so if you don't know a camel
and if you're not familiar with it you
have to learn a camel and then you also
have to learn reason which is kind of a
syntax for it so that's getting better
there are more resources being written
for the language but it's kind of a
tough point right now
right so reason there's a lot of things
that make the syntax I guess more
familiar to JavaScript developers and
let's have to say the reason is
specifically targeting JavaScript
developers but I think it is at least
partially built so for example like I
know camel you have like if you use like
in for scoping you know in JavaScript
you just have block scoping and that's
what reason provides and using basically
similar syntax like you know arrow
functions are in es6 and buckler's good
pepper local script okay well has them
but they're little syntactically
different so I think as far as syntax
goes it makes the language a little more
accessible to people who aren't familiar
with ml or sort of functional languages
you might be coming from another
background like Java Script or a
language like JavaScript and then I
think the alternative goal is that the
path to using Oh camera for the web
specifically with buccal script was a
little rough before so reason and the
reason team and the buccal Script team
they do work pretty closely to try to
integrate that so that's part of sort of
the toolchain effort making it easy to
set up get started or start using reason
for the web
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>