<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Silvia Crafa - On the chemistry of typestate-oriented actors  Curry On | Coder Coacher - Coaching Coders</title><meta content="Silvia Crafa - On the chemistry of typestate-oriented actors  Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Silvia Crafa - On the chemistry of typestate-oriented actors  Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XPiI3BRxnZM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so hello everybody I'm back Rafa
I'm assistant professor at the
University of Padua and so I'm from
academia and I have a very theoretical
background because I'm used to work
about formal methods and so type theory
is equational theories logics to reason
about concurrency and especially
concurrency in foundational calculus but
in this presentation I want to talk
about theory absolutely not theory the
formal foundation of this work you can
find every detail in my webpage in this
presentation I want to put formal matter
in action I try to apply these methods
on Scala innaka code and I'd like to
have some feedback from real programmer
to understand if this kind of approach
could be actually useful in some real
application at least in some domain okay
so let's start with some motivation in
disability systems one of the key issues
is the coordination of concurrent
entities there are different approaches
to address this problem one proposal is
to structure the code according to a
protocol oriented programming style what
is it this kind of programming in
thinking has programming in terms of
communication protocols
so having protocols in mind and
programming according to these protocols
but in order to to have an effective
programming style you must have a
language that actually supports this
style so a language requires supporting
protocol oriented programming requires
high level high level abstraction to
express into the cliff these protocols
and then some other obstruction to check
the protocol compliance if you don't
have it you cannot really apply protocol
oriented programming
oh it's okay there are very different
distributed systems so this is a very
general approach and in depending on the
kind of system you have it protocol
oriented programming means very
different things so if you have a
message passing based distributed system
you already know that it's something
related to messages and it is what we
will see but it is not the only kind of
disability system so this is a more
general view thinking and then ends
programming in terms of protocol could
be useful to coordinate concurrent
entities then depending on what kind of
entities you really have in your program
then protocols are different things and
different language may support this
thing in very very different way indeed
what are suitable obstruction for a
protocol of the anti program
there is absolutely no single solution
there could be a set of solution and
even in general finding suitable
obstruction is very different is a very
difficult issue because a suitable
extraction must be something he isn't
easy to think about easy to reason in
terms of this abstraction but at the
same time an abstraction is good if it
is expressive and it can be implemented
in in a way that takes into account
performance and scalability and this is
a trade-off so there are no single
solution as usual and above all when you
add an abstraction to your language this
abstraction must also product ly
interoperate with other abstraction that
are already contained in your language
so really there must be many many
different solution dependant depending
on what you're working on and even the
distributive system can be very
different in nature as I was saying
before just as rough distinction is
between systems that are in a sense data
centric that worked with
amount of shared memory these systems
but but the feat a centralized conquer
centralized control of distributed
entities in that kind of systems a
top-down approach to a protocol oriented
programming could be best suited it is
more it is easier to reason in terms of
a globe of global protocol and then to
project this coordination global
protocol into local sub protocols and
this is for instance the methodology
proposed by multi-party session types
but there are systems distributed system
which have a very different nature which
are usually message-passing oriented
they are communication centric and the
entity are built around strong isolation
principles and they take their decisions
according to just local info information
in this scenario maybe there is a button
up technique to compose a bottom-up
technique to harmonically compose local
protocols should be possibly more
sweeted this to this scenario and don't
forget that real distributed systems are
not clearly either data centric or
communication centric they are a mix of
different natures they are a breed even
in models so again there is a trade-off
and no single solution ok it was just
for general motivation this is an
overview of what I want to show you it
is essentially a single simple example
what is a running example that we will
discuss it is written in Scala and Anaka
and I want to show that even in the
actor model the well-known type state
oriented programming which is well known
in object-oriented languages can be
applied to actor systems what is the
ideal types state oriented programs
types the type state oriented object is
an object that has different instances
in different states so an object can
change a state and when change in state
it allow it offers different set of
messages an actor can also be in
different states and it can
different behaviors in each of these
states but we want that actor to endl
different set of messages in those
different states and there's a key
difference and we want those defined
actors in a stateful way but we also
want to rely on the Scala compiler the
standard Scala compiler we don't want to
add anything for the moment to this
compiler and use it to that check
protocol violation so we will do it by
adding types to represent actor
interfaces and we will add type the
references to actor to represent actors
that are in a certain specific state and
to keep track of the dynamic state
change of the actor we will rely on
continuation passing programming style
but not just on explicit programming
explicit continuation passing
programming which is the solution
adopted for instance by the archetype
experimental model we want to do it in a
more implicit way so I will propose you
a monitor which greatly simplify the
definition of the user code with a
continuation passing style and we
obviously want that this idea of
different set of messages in different
state we want it to be robust fully
robust even in a when the actor is
accessed concurrently by different users
and we will do it using a mixing
composition with the semantics that I
call the chemical semantics because it
is inspired by the chemical abstract
machines that have been proposed in
foundational calculating so this is the
the roadmap and the take-home messages
will be that according to my view but I
want an answer from you the style of
definition of type state oriented actor
allows you to define the actor with a
clean logic and a very natural
definition and the mixing composition
allows to keep this natural definition
also in the complex setting and we have
a scholar compiler which helps us to
check that all in intended messages are
actually handled at the intended state
so no protocol violation
in this sense but let's see the running
example is very very simple
I consider it one place butter which is
enough which is an object with a very
simple protocol but it's not so trivial
it has two different states the buffer
can be empty or full when the buffer is
in state empty it it's interface only
contains the incept method you can only
insert something in an empty buffer and
inserting something moves the buffer
into state full and which are they're
saying the full state you can only ask
for removal of the content and move in
the state to empty buffer very simple
you can express this protocol with a
funny state machine I'm not saying that
I want to rely on fight state machine to
express protocol not though the language
for the fine protocol is at your choice
I just use it as a picture that is easy
to which is an easy representation of
the protocol so this is the protocol but
once you define this protocol defining a
corresponding buffer up to is very very
simple you define to two different
behaviors which correspond to the two
possible states so the two behaviors are
empty and full as the name of the states
and in each behavior you end adjust the
intended message so the empty behavior
just handle the insert message and the
fools behavior just handle the remove
message and you start initialize the
buffer with the empty behavior because
the buffer initial is empty so this is
clearly very natural definition we have
no defensive programming because we just
handle the intended messages the problem
is how to make sure that this simple
definition is robust in a concurrent
setting
hi I was wondering so if in so here in
this example you have two states and in
each state you have one message so how
would the code how would you express
let's say that in the empty state you
have two messages because here the the
message or the state actually surfaces
as a function definition yes the
function is a partial function which can
be defined in the K with the number of
button you you prefer so you can define
message you want to handle in that state
okay so it would be like empty colon and
then the different message if you had
another message oh gee is the case class
you have to define the case class okay
in the beginning which case close to an
alright thanks okay okay when calling
remove because in this simple example
you just remove the the value you
emptied buffer you're not interested but
you can define an announcement message
by message this is a simple example we
know we are not interested in the value
okay just to keep it simple okay so what
are the possible errors you can make if
you are just a single user which makes
this sequence of message sin well the
first message sent is bad because it's
Antonello message to the buffer which is
not intended to answer hello messages so
we want to comply the compiler to signal
this this message sent as an error but
also here you have to to remove messages
in sequence and you don't want it
because
asking for a removal move the buffer
into the empty state which is not able
to handle a further remove message okay
so you have to ensure that insert the
remove all are in alternation
re-sequence okay so this is already a
difficult problem even if you have a
single user but the setting is more
complicated when he you had multiple
concurrent users ask you so in previous
example how would the program on the
teachers an error in the last example
how would that know if it's a bad state
or a bad message if messages are defined
only encapsulated in a state
well the protocol the protocol of the
buffer should okay the user should be
aware of the protocol okay and he finds
his code according to the protocol and I
want the compiler to signal that this
code does not compile because it doesn't
respect the assumed protocol so the user
would not compile this is the general
case when in this example you have two
concurrent users a producer with just
makes and consumer with makes just
remove frequent requests since in this
scenario there is concurrency and non
determinism you cannot assume that
insert/remove are ended in sequences so
for instance an insect message can
arrive to the buffer when the buffer is
still in the full state so it can arrive
at the wrong moment but we we want to
still ensure the correctness of handling
of these messages keeping the definition
of the buffer simple as up there and
this is where chemical semantics will
help but let's solve first the easy
problem so let's assume a single user
and let try to use types to ensure that
no other messages but insert and remove
are admitted the problem is that in akka
the send message tell is actually
untyped because it accept any kind of
values we want to add a layer of typing
on top of this untyped ascending and we
can do it by adding in M by wrapping the
actor reference into which is a wrapper
with a generic type stating for encoding
the state of the actor so we let types
represent actor interface so if
represent an actor interface it only
allows messages which belongs to the
interface T which means that you can
only which belongs to the actor
interface and once you started it type
check your message then use the usual
del operation that that's curing 9f if
to represent the alternative state right
I mean with with this type I can send
the insert message button I still have
the same type I can always send the
insert message and never the remove
message so there's something missing
there I just I'm root sorry
all right this is an actor which is at
state t but which cannot change its
state as you sing so it is okay for a
stateful up for actor but here it is
example at the previous state so you're
not tracking the dynamic change of the
states
okay okay the problem is that statically
you cannot change the type of a
reference okay you can only assume an
abstraction of all the types that
reference can assume runtime so you can
resort to this continuation passing
style technique which means that instead
of changing the type of the same
reference you change the reference each
time so whenever you send a message that
makes the buffer change State you change
the reference according to the new type
continuation you can do it in act in an
explicit way or in an implicit way let's
start with the explicit way which are
similar as I said to to the archetype
solution
besides the insert the remove messages
you have to add the reply messages which
reply is sending to the user the
continuation at the correct type so for
instance when you ask for an insertion
you are you send a value but you also
send your reference because you are
waiting for a reply so there is a reply
to it is at the reference is the
reference of the user which is expecting
an insert reply message which carries a
continuation which is a buffer ready to
be consumed okay so the buffer actor has
the two behaviors with just intended
messages but besides changing its state
even also reply to the user carrying
itself at the new oops
this is a consume interface this is how
the user code is change it here you've
said that you insert something into
buffer and then you wait for an insert
reply and you use the continuation all
tools and remove and so on okay this is
a well typed code it ensures that there
is an alternation between insert or
remove but it is not so evident the
it is a sequence of insert/remove
instant remove the explicit continuation
makes the code a little bit involved so
what I propose is to substitute them
with implicit continuation and change
this code into this one in this code you
stick to just insert the remove messages
no reply messages and the continuation
are implicitly passed by means of Amana
data we'll explain in a moment
but just look at the user code which is
which is using a mana in the form
notation actually it is based on the
future monitors so scala programmer that
are used to programming with futures
should find this notation familiar
because it is like using using futures
and here you say you see you rebind each
time you use the same variable all that
is a rebound it's in each line to use
the same ol but which have different
types in each line okay okay I'm
cheating a bit because the the the code
which is compiled which compiles is this
one you cannot have a simple all here
you have to add the compiler to with
typing so you have to use some phantom
types I don't know the details but this
is the code which actually compiled and
here if you want to if you try to make
to insert the compiler complains so it
may be a bit early for this question but
to cut into so innaka the one of the
properties of an actor ref is that's
transparently to the consumer the actor
can for example crash and we initialize
itself but then it will reinitialize to
the initial States but if you still have
a
type Taktarov of the second state and
that could be a problem right okay I
didn't consider for tolerance problems
at this stage and this is indeed the
major thing must come but I think that
it is useful here the difference between
the actor class and the actor reference
class and this is an a wrapper around
the reference class so you can rebuild
the the actor class and take the same
okay and continue with the same actor
reference so with the same type doctor
reference that is the idea but you have
to decide what to do with the new
starting at which stage okay my move my
feeling is that when you come to fault
tolerance problems you have to consider
those at the protocol level so how to
deal with protocol failure should be
considered at the protocol level and now
a woman I will I'm going to encode
protocols as types so if the protocol is
fault tolerant in some sense even the
type would consider also this problems
I ever see a way to you to to cheat the
system here but but I'm so I think that
there is nothing that prevents me from
just calling type tell and then ignoring
the continuation and just call another
make another call to title with the same
insert and again you know where the
continuation so I could fall the type
system in that way or is there any
protection against that thank you for
the question indeed you can you can do a
lot of bad things if you want the
easiest bad thing is to use the buffer
reference more than once and continue to
call this line buffer type that insert
is well typed and you can continue to do
it the problem is that references must
be must be used according to an affine
logic behind the scene there is a linear
logic a linear linear typing which takes
into account how many times you use a
reference the idea is that you can use
this reference most once how to ensure
this policy well if you want to insure
it statically you must add linear types
to the type system so you change the
compiler you can easily do it
transforming this in a runtime error if
you add to type tell a flag which says
whether this type tile has been called
or not so you add to the reference to
the type reference you are the flag
saying that title has been already cool
when you try to call it the second time
it results in true unacceptable an
exception so you moved in a fine problem
F you you encoded the affine problem
into a run timer but you don't like I
think to increase the runtime errors but
this is a linear problem okay I think
that one okay
my question was almost answer it but you
mentioned that you need like a prototype
system but I mean husker can actually
manage that or the positive statement
not that actually ensure that state on
the used ones
is it like just go up our type system
not powerful enough in this case or are
you seen that asked already linear types
well I mean you can model with them
because in a sense with the type system
you can prevent referent escape you just
like coming so that's why for camp we
can sort of like encode statement out so
use only state only once and that's it
and type system pretty much ensure it
and with it without like a something
about reality and something I think that
the problem might be similar to this one
if you use the model correctly as it is
but I mean Haskell insurance like
statically that you only use the only
ones by user type system and it's you
just come up not powerful enough if you
I if you reference and you like just the
mana to handle the reference you can
design the monitor so that makes it
correctly but once the reference is
exposed so what happens if you have two
references to the same actor and both
references are in the empty state and
they both try to insert at the same time
yeah this is indeed what I'm going to
let's first let's go to the answer the
example is this one you have just a
buffer which is shared by two two users
which want to use it in a different way
but at the same time each one cannot
assume
the state is empty or full because the
state might be changed by the other the
other after so out is that dress this
problem in archetype you can change
state but in each state you must handle
the same interface okay so this is an
easy solution because you say that
Botany empty and full you can handle
both insert or remove so actually the
state changes but not the interface what
I'm doing here
the solution is resorting to the
chemical idea the chemical model of
concurrency looks at the concurrent
system in this way a state is a soup of
messages that had been sent to the
concurrent entities the behavior of the
system is written in terms of reaction
rules and a reaction rule consumes a set
of messages and produces a new set of
message this is the chemical idea and
main point is that you keep a molecule
until reaction is triggered and our
solution is indeed keeping an incoming
message until it is the correct time to
handle that message okay so you keep an
incoming message which belongs to the
protocol so we keep a protocol message
until it the the buffer enters the
correct state to handle this message and
so this were the buffer with the with
two behaviors we just handle insert that
remove and to make it robust with the
chemical semantics you mix in the
chemical trade you see that behavior
still define the intended messages what
what change was this chemical react and
chemical become so the magic is there
and chemical reaction stashes the
incoming messages and one enters the
correct state and stashes dispatched
messages and handled them because it is
the right moment which is described as a
recipe for disaster in a production
system because you led to the cue
explosion and like if you have an
unbound buffer
spoiled eventually mm-hmm okay thank
thanks for for for pointing in indeed
scalability problems must be take into
account at this stage I didn't consider
them but one idea is that what you keep
and at which time keeping what I'd like
to link these two types so at the moment
I just keep types sorry I just keep
messages that are tagged with a special
trait protocol message but I can do it
more in a more fine-grain that way using
subtypes so I'd want I do not want to
keep all the messages but just those
that eventually will be handled and I
think that's this kind of problem might
be addressed using this fine grained
typing but a related pop potential
problem might be deadlocks I mean I
might be trying I mean I might be
trading runtime errors of the communis
message not on the streets for deadlocks
with you two actors basically trying to
send the remove message and basically
they're waiting for something and in
that case I might prefer to actually
have my runtime however saying there is
something wrong here than just observing
while not observing anything which is
what that loves you and also on the
similar topic do you have any way to
represent timeouts or like invariance
for any time time related thing like I
don't want for instance as a client of
an of an actor to wait more than 10
seconds okay
not explicitly no not yet but the mana I
will I'm writing here okay it's based on
the future mana so you have a time out
in please implicit time out when you use
mana a when you use future so what
behind the scene but
I agree that for a robust version of
this approach you must and also
exclusive timeouts so similar to what he
said we you kind of run back into the
Erlang problem of a you're keeping
messages around and in this - and B
every time you change safe basically you
have to look for a decision like is
there something I can apply this to now
right so you kind of have to look both
through this - and to the new messages
to see okay which one can I take now all
right
and the the standard solution to this in
Erlang was basically to always have an
handle our case which makes the whole
thing completely pointless right I mean
then you basically and I'm just going to
sidestep it because practically it's not
helpful yeah yes I'm hoping and I'm
asking you if you see that instead of
keeping everything you rely on types
saying what keep here the trade you can
when mixing this trade let me let me
show this example okay okay
this is a much bigger protocol this is a
book shop server you can initially add a
number of books you want and and then
you can check out there are a lot of
states each round is a state I don't
want to keep all this message when I
decide how much interleaving I want in
my program I decide which message to
take for instance if I decide to keep
only the message that starts an
interaction with a new user I just
got to keep both odd and check out
messages so I can be really fine great
if I decide which message I am mark with
the trade which not can you go back to
the slide with the two users yeah so one
thing to observe is that neither of
these users will type check using the
same actor type right occurring your
system you can only have an inserts
after remove after an insert so you
wouldn't be able to write such programs
okay that said so that's not that that's
that's a good thing so these problems
that were considering aren't actually
problems what you deal what you need
basically is a okay if I have an actor
for this I can create two actors from
that one of which is the one of which
goes the producer and which goes the
consumer and these two actors coordinate
with each other so basically they say
okay I've made a choice that's been
inserted now you can choose
synchronization policy that you want so
you could either have both sides be
synchronous right the insert basically
waits every single time or you could
have a be asynchronous and you queue
bunch of methods methods or messages
using an unbounded buffer so all these
different situations are because
different or all these complaints
because are because different situations
need different solutions and you can
make that something that people could do
manually or provide convenience
convenience libraries for doing that for
them rather than have a global solution
that everyone has to use I'm not sure I
understood your question but at one
point out that a buffer that will be
used just by one user as a different
protocol from a buffer that it can be
used by a producer and a consumer so
once you if first of all you think in
terms of protocols so if your buffer is
intended to be used in this mode it will
have an according protocol so here in
this protocol the answer to an insert
will go back to again a type which
allows the second producer let me show
the code of this to okay here you have
the producer which receives a buffer
reference which has the interface
producer interface and it will not
change his interface
because its protocol is continuously
inserting messages while the consumer
receives the the the buffer as a
consider consumer interface which will
never change and the same button share
and the contravariance of the type type
the reference allows you to share the
buffer with the correct subtypes but
this is because you started with defined
in the protocol let's go is that I were
to limit the rate of the but it is there
are future so there is no blocking at
all I can use one minute of my time to
explain why there are futures there okay
the idea is that besides having a typed
reference around the actor reference the
new class protocol reference encodes
it's up there it goes the current state
of the actor with a party but it also
encodes the state transitions that are
allowed for this actor by using a
function I typed expression which is
protocol which carries the type of the
continuation so the type test now
returns the value which is a
continuation it is an instance of the
continuation class and the continuation
class contains an absolute type which is
the next state the next interface and it
contains a cup a pair or the promise and
a future which are linked and the
promising future carries the typed
reference at the next state so whenever
you call continues with that future we
will not blocked and the promise is
forwarded to the actor and when it
after enters the correct style you will
complete the promise and it will unblock
complete the future and let advances the
user so behind the scenes there is
despair on promising future take a
question like do you hear essentially
your model in linear types in a language
it doesn't support linear types yes but
if you for example I could use that like
in a language like rust rest have like
perfect it seems like it like perfect
way to implement this because they kept
like move semantics so you can just have
like consumer and I mean it's just like
linear type system so what do you think
about using different language
implementation that's the kind of fight
of America I'd like to add there are two
ways one is we add a behavioral type in
which is proof that this sound that it
is Dipel it is developed on the joint
calculus okay we have wonderful type
system and we want to apply it so either
you find a language which is ready to
apply that type system otherwise you
find the language where these type in
this discipline might be useful so my
idea is that actor programmer can profit
yes may be worth to further explore the
Scala compiler to add what it is not
there otherwise if you say that rust
might be a more suitable language well
what kind of programming application
program application written in rust one
minute so I'll get to conclusion was
essentially that okay was just to resume
the results so I try to convince you
that type state oriented actor can be an
actor that can be defined with a clean
logic and electric definition and by
means of the chemical mix in the simple
definition of scales to the concurrent
axis but with those problems of
scalability of station and especially
message that we mentioned
and then what about protocol compliance
the idea is to express protocol with
some language you prefer and then
possibly automatically convert this
language into a type violation can be
already checked by Scala compiler which
ensure that only intended messages are
Android intended state what is not
supported at all and again tis the
problem of linear and types is complying
with compliance with protocol obligation
if the protocol is set you must send a
remove message first and insert and then
you must also send a remove while this
kind of obligation are not checked
because type safety is just absence of
error okay not wrong states but ensuring
that the card stain will be reached is
not the work of standing types so linear
typing and so these were but you already
do you think that this approach of type
state oriented discipline could be
useful in distributed system what kind
of application may be just a simple
application are not saying that this is
the solution for everything but the idea
is to have a toolbox of programming
style that can be used in different
situation and also what kind of property
would you like your compiler to to check
in this scenario
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>