<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Juan Lulkin - What is programming? - Curry On | Coder Coacher - Coaching Coders</title><meta content="Juan Lulkin - What is programming? - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Juan Lulkin - What is programming? - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xOOkc8xI06E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I really didn't expect so much people
so i'm not sure if there's like a sudden
interest on philosophy or people just
doesn't know closure i don't so okay
let's start with my bio right everyone
starts with this whole one was just a
regular kid until one day he bet his
soul of the devil and lost then he
suddenly learned to play blues and
started working with technology making
fortunes in the.com bubble he studied
physics where he couldn't find any
evidence for and philosophy where he
couldn't find any good argument for the
existence of souls given an approaching
deadline set by the Dark Lord he decided
to move to Israel and learn Hebrew in
order to read God's words and sick
atonement for his sins nowadays he works
with front-end technologies since he
couldn't find anything more self
legislating to do so as the Coen
brothers would say this is a true story
okay so what is programming let's start
with a tail right it's good to start
with the story so five philosophers sit
at a table with bowls of spaghetti Fords
are placed between each pair of wedges
and philosophers each philosopher must
alternative think and it if you know
this problem right so the first
philosopher things for a little bit and
says programming is like the human body
there are parts that conduct actions
like hands and legs but these are
commanded by a central control the mind
the mind is not only capable of
commanding the body to perform tasks but
to produce ideas and to think about
these ideas in the most abstract ways
and understand the world around it we
can know about ourselves both by
reflection and direct contact with our
ideas feelings and sensations but also
investigating ourselves as objects in
the world the second philosopher thinks
for a little bit and says no programming
is like an ideal city the architecture
is formally planned to perfection
everyone does everything to the best
interest to the community and no vices
are
the city will create an unbeatable army
by selecting only the strongest and
bravest and train them through the most
rigid discipline the city must be ruled
by kings educated in mathematics and
logic the third flaws for says
programming is not like that it's like a
real City so some cities start by chance
some cities are planned but it evolves
based on real human needs individual
parts are planned built and involve
according to these needs the city must
be ruled by pragmatical leaders who put
the population interest first the fourth
one says no no programming is a
postmodern activity all your suggestions
are grand schemes and are simply lies to
children programs are actually system
constellations of parts building
completely different ways connected
arbitrarily while you are discussing
your grand schemes people continue
building big balls of mud let's instead
study this mud and improve from there
and then the fifth philosopher says hey
guys can you pass the fork I'm really
starving here but non replies and he
insists four hours days until he finally
dies so what is our agenda
see my keynote also lights
so we're going to go over five small
parts first of all I'm going to talk a
little bit about how I think philosophy
can deal with these problems we're going
to take a look at the history of the
paradigm Wars and then we are going over
each of the paradigms this is supposed
to be more like a one-on-one if you were
to have like a philosophy and computer
science in the University this would be
more or less the content I think so what
the hell is this connection between
programming in philosophy so there are
many ways in which philosophy and
computer sign already intersect right
especially in the philosophy of mind
artificial intelligence world but also
tangentially like in computer ethics
right does not precisely computer
science but it's all related to the
domain but in this presentation will
focus on another way and I'll show this
way using a citation from Connecticut
Colburn so he says computer science is
ripe for the good old fashioned Allah
analysis that philosophy can provide for
any science thus a perfectly reasonable
rule for philosophy is to attempt to
place computer science within the broad
spectrum of inquiry that constitutes
science the concern here is to deal with
the inevitable identity crisis that crop
up in the self image of any adolescent
which computer science certainly is plus
we should address questions like what is
the relationship between mathematics and
computer science is there a sense in
which computer science is an
experimental science and what are the
ontological implications of computer
science so so it appears that there is
really no consensus on what programming
is about right it seems reasonable to do
to be so after all this an activity that
exists for a relatively short period of
time 50 60 years and this time it
changed the way we perform almost all of
our other activities and it carries no
smaller promises then you know virtual
worlds artificial intelligence on the
other hand disagreements are huge and
apparently you're constantly you free
counsel so the way to put it there's
this quote from an article called three
paradigms of computer science where they
say that computer science science
textbook classics articles conferences
curriculum are dominated by radical
different methods of conducting research
in teaching so mathematical methods of
Investigation guided research of
computability automata Theory
compilation computational complexity and
the semantics of programming languages
design rules of thumb extensive testing
suits the regimental development methods
dominate the branches of software
engineering and the methods of natural
science which combine mathematical
theories with scientific experiments
govern the research of artificial
intelligence maturity machine learning
so and so on and then he goes on saying
like that in certain universities you
know the Department of Computer Science
belongs to a different place mathematics
science so i just made like a quick
table so you can see what he's saying is
saying like you know we have these three
paradigms they call scientific
rationalist and technocratic there's a
certain ontology around these things
this means what the problem is right how
did he find program the sort of
knowledge that you can get based on
these objects and the methods and of
course the department that these
approaches are in the universities but
how can it be that programming seen in
so many different ways you know us the
things that established areas of
knowledge had what we call today a
pretty scientific period and this is
defined by a period where their object
and Method were either not mature enough
to produce major breakthroughs or were
disputed to the point of not having a
general consensus around their
practitioners but the things that even
mature areas of knowledge seen from a
historical point of view seem to contain
a dynamic process of breakthroughs
leading to redefining or at least
refining the understanding of the object
and therefore the activity itself one
example is like the battle that is going
on in the physics department between
party go and string theories right some
claim specially given the lack of
experimental results that string theory
is not physics they think it's just a
mathematical thing dealing with
something else not physical objects
while others say that well we're using
mathematics but our goal or object is
still physical objects we can also look
at introduction of probabilities of
aggregates by the kinetic theory in the
18th century so it was introducing
probabilities you know
in a domain that people expect it to be
purely a void of this sort of thing you
know completely deterministic and I
would say more decisively we can see
that even the empirical method was not
central to what was called physics
before that when Galileo pointed his
telescope to the moon and he invited the
scholastics to look at it and and see
his research they didn't want it and
they came with a priori arguments that
his theory was not even possible
logically possible so he sent this
letter to Kepler where he says something
like that my dear Kepler I wish that we
might left the remarkable stability of
the common herd what do you have to say
about the principal philosophers of this
Academy who are filled with the
stubbornness of an ASP and who do not
want to look at either the plan either
the planets the moon or the telescope
even though I have freely and
deliberately offered them the
opportunity a thousand times truly just
as the ASP stops its years so do these
philosophers shut their eyes in light of
truth but nowadays we don't even equate
these early efforts with physics we call
them are still in physics scholastic
physics anything to distance these
efforts with what we call physics
nowadays but what links these
pre-scientific physics with the current
one is that it was probably you know
interest in the same objects no one I
guess would deny that her stottle was
talking about motion right the only
thing is that the matter that were
employed in the past which like in a
medieval period was mainly commenting
Aristotle and Plato we're not fruitful
and then it required like rethinking
these methods but what seemed peculiar
to the problem of the nature of
programming is that there's why this
agreement not only the object not only
the method but also in the object itself
the disagreement that seems to be the
most fundamental is the one regarding
the object since all these presented
characterisations they follow the method
from the object following you know the
current structures of sciences it
wouldn't be very creative if computer
science would come up with like a
completely novel method than another
explanation of this object but this
presentation I'll try to focus on is
free very
so the first one is programming as
science so in the 50s I would say that
the majority position about programming
was the scientific one that certainly
related to the fact that the varying
invention of computers was sort of
related to this grand narrative of
creating a thinking automaton a robot
right in height sign in hindsight this
seems really strange because by now we
know that is a very hard goal to achieve
it seems that we put the cart before the
horse but it's too remarkable the
confidence in which researchers by that
time would make analogies and rock quick
conclusions relating programming to
human thought yet good example so this
is John McCarthy saying well to
represent our items by symbolic
expressions in such a way that
significant changes in the behavior
represented by yoga rhythms are
presented by the simple changes in the
symbolic expressions programs that are
supposed to learn from experience change
their behavior by changing the content
of the registers that represents the
modifiable aspect of the behavior and
the coolest part is this for a certain
point of view having a convenient
representation of one's behavior
available for modification is what is
meant by consciousness now that's a
little bit controversial so if
programming is to be properly scientific
it seems that it must have as an object
something that is a natural entity the
relation of program and mental processes
is not men simply as a constructive
analogy in this understanding it is sort
of an identity the nature of this
identity is hard to fathom but must be
based on on the possibility of
translating patterns encoded as programs
in a machine and patterns of neural
states in our brains so if software is a
pattern first and material body meant of
patterning second then it can be ported
from unsubscribe into an order it is
liftable that's the main concept here
the pattern embodied in magnetic fields
and ideas can be lifted from the disk
and posed to solids and lengths on the
cells of punch cards and vice versa it
is this property of software that gives
workers in the field of artificial
intelligence their hope of success if
the mind is reducible to the brain and
the brain is a complicated
dorrough switches then the mind can be
lifted and reinstalled in a silicon
substratum and maybe otherwise as well
right but this assumes that well the
mind is reducible to the brain probably
that's the less controversial assumption
brain patterns are deterministic and
understandable let's probably live with
more controversial but the hardest one
is that this position may also require
the assumption that there is or there
will be a solution to the hard problem
of consciousness and I simply put this
problem is that it appears that a simple
functional explanation of how the brain
works doesn't seem to account to explain
our subjective experiences so this is
the hardest problem in this field from
the 50s until today but moving from the
mind process idea there are also some
views on programming a science that
doesn't really rely on his own ontology
of mental processes so let's see one
example
so here this is from it's a touring a
lecture each program is an experiment
and its behavior of her clues to an
answer neither machines nor programs are
black boxes there are artifacts that
have been designed both hardware and
software and we can open them up and
look inside we can relate their
structure to their behavior and draw
many lessons from a single experiment
inspection of the problem in the light
of a few runs reviews flaws and let us
proceed to the next attempt so in this
account programming scientific simply
because we apply an experimental method
right but the difficulty of this
specific formulation is multifold if a
program is an experiment in its behavior
offers clues to an answer we can write
rightfully ask and answer to what right
for if a program is an artifact there is
a clear this analogy with all the other
natural sciences for these are sciences
occupied with nature and if they test
artifacts it is only to ascertain their
correctness as a mean to ensure the
experiments you'd reliable information
about their ultimate objects and even
more importantly it seems that any
knowledge that we derived from testing a
program is about the program itself and
following quine everything behind the
program so the Machine laws of physics
logic everything and not general
hypothesis so tony hoare says computers
of the present day are very complicated
and rather poorly defined as a result it
is usually impractical to reason
logically about their behavior sometimes
the only way of finding out what they
will do is by experiment such
experiments are certainly not
mathematics unfortunately they are not
even science because it is impossible to
generalize from the results or to
publish it publish them for the benefit
of other scientists but this sort of
empirical research can use some
generalities but i think this Renard's
are more akin to rules of thumb
guidelines and this seems more in line
with the idea of programming as
engineering with time this naive
enthusiasm of the scientific view
started to fade and here's Fred Brook
assessment of this
so I said that this is 90 something I
said it is time to recognize that the
original goals of artificial
intelligence were not merely extremely
difficult there were goals that although
glamorous and motivating centered
discipline off in the wrong direction
said that in this paper he argues that
we could have done much more if you had
focus on practical things from the
outset instead of no trying to make
mines right away in any event this view
haven't yet died or at least its main
goes to motivates and we will always
motivate even if our spiration czar
lower but it's survival as a fumble
blown paradigm depends on major
breakthroughs in an understanding of the
concept of mind programming as
mathematics many computer science have
expressed the opinion that computer
science is simply a branch of
mathematics let us first establish this
position so computer science is an exact
science and that all the properties of a
program and all the consequences of
executing it can in principle be found
out from the text of the program itself
of means of purely deduction reasoning
so how to use purely deduction reasoning
doesn't really need to be defined on
this presentation suffice to say that
this position depends on the idea that
in some sense a problem can be seen as
an ideal entity that is as a general
characterization something that doesn't
have spatial location doesn't have
causal powers and so on in any event the
most convincing way of doing this is in
the realms of logic and mathematics is
by formal methods I'll jump this there
are indeed many different arguments
against the possibility of finding all
the consequences of a program by means
of purely that you've risen the most
rate for argument is the argument of
complexity right so in this paper and
they say back in the real world the
specifications for any reasonable
compiler or operating system fuel
volumes and no one believes that they
are complete the input assertions for
these algorithms are not even formidable
let alone formalize about so this is
basically saying it's too hard right
so if you look at this sort of argument
in further inspection although these
arguments they put an almost
insurmountable difficulty for this view
they don't really refute it right but a
more crucial point is what was presented
by a guy named Fetzer this is a little
bit long but let's go over algorithms
and henderson algorithms this way so
it's a specific definition now rhythm is
a logical structure of the type function
suitable for the derivation of outputs
when given inputs so algorithms are
subject to absolute verification by
means of the deductive procedures this
possibility occurs because the
properties of abstract machines can be
established by definition in this sense
the abstract machine under consideration
simply is the abstract entities and
relations thereby specified in the other
hand programs there is a causal model of
an algorithm obtained by implementing
that function in a form that is suitable
for execution by machine are merely
subject to relative verification at best
by means of the directive procedures
their differences from algorithms are
precisely because the properties of the
abstract machine they represent stand
for physical machines hosts properties
can only be established inductively the
very idea of program verification trades
upon an equivocation I'll try to
translate this quickly so in some
disproof any proof related to I do
entities does not apply unreservedly to
natural ones let's put elsewhere there
is no way to deduce logically that
bridges stand that airplane airplanes
fly or at our stations deliver
electricity so when a physicist or an
engineer calculates the moving movement
of a cannonball it doesn't expect to
have proven it right this refutation
doesn't exclude the possibility of
studying programs in an abstract way but
precisely because it is only considers
them in abstract it is not a science
science strictly speaking about programs
the mathematical ingredients involved in
the movement of a cannonball don't talk
about the movement let alone about
cannonballs they talk about the parabola
right
that's the mathematical object so third
programming as engineering so it seems
that the failure of these two views to
yield like a final method for
programming a couple of course if the
growing need to solve immediate problems
has led to more pragmatic view about
what is programming so as Brooks puts
here the distinction between science and
engineering lies not so much in the
activities of the protections of the end
as in their purposes a high-energy
physicist may easily spend most of his
time building his apparatus a spacecraft
engineer may easily spend most of his
time studying the behavior of materials
in a vacuum nevertheless the scientists
build in order to study the engineer
studies in order to build so the way he
pictures programming is an engineering
activity also sort of give an
explanation and why some people may
think it's mathematics or science this
is because seeing it as engineering
doesn't rule out the possibility of
using these other methods right and in
his account for an activity to be
considered a form of engineering we
don't look at the methods the disease
activity implies we look at the purpose
so the purpose is to build something
therefore is not science or mathematics
these distinctions conform of this
classical view of engineering of simply
applied science we have distinguished
for instance chemistry and chemical
engineering biology genetic engineering
in the same vein even if these are sort
of different from other forms and
engineering in the sense that we build
things that are natural entities
actually we make animals you know but
the problem is that this doesn't really
solve the ontological problem in the
same way that you know saying that
something is something is science
doesn't make it so just labeling
engineering doesn't explain away the
object that is in question one
alternative is actually to assume some
more naturalistic view of what is a
program because the two previous
presentations are sort of dependent
abstract entities
so one way of looking at it is this
program is information only when is
executed before it's really executed as
a program in the machine it is handled
carried to the machine in the form of a
stack of punch cards or is what it is
transcribed it is just a bunch of data
so this is a very much realistic way of
looking problems not just a bunch of
data the problem of this
characterization is that it can account
for the designers intentions to
illustrate this point imagine imagine
that there's this book okay that we know
for a fact that someone wrote this book
like long time ago in a language that we
don't no one speaks nowadays the thing
is that we would still call this a book
regardless of the current possibility of
it being translated understood
interpreted if we find a way to
interpret this book in the future we
would say now we can read this book
right instead of saying now this book
that was just a bunch of data for a long
time is readable and this captures our
common usage of the word book so we use
this word conversely to denote a
specific book or an abstract notion of
book when I go to a friend's house and I
look at these books and I say I also
have this book you know I'm using in
this abstract sense I don't have exactly
the same copy and the things that
software looks the same we all have the
same program you know we can copy this
program and it's interesting because
this nature is actually what created
countless issues for software as
intellectual property there are lots of
debates in legal departments about in
the law about that so the analogy of a
program in a book is a highly valuable
one it seems and it extends to many
features of both except when it comes to
be able to causally influence the
behavior of machines which is something
a book cannot this can can be seen as a
difference in intent while a book is
written for readers and must be
understandable by a human or at least
exciting understanding like in
jabberwockies case you know the the poem
that is like nonsense it's still
think its literature right in the other
hand a program is written for a certain
machine or a certain compiler that
translates it into a certain machine to
understand it but even this distinction
is not as sharp as it seems because in
the current engineering world writing
programs is a highly social enterprise
and the programs need to function not
only as a machine instructor but also
has a mean of communication between
humans many modern languages try to be
as close to natural language as possible
making the code readable and many
developers emphasize aesthetics in their
practices but since not all data is
software we need some criteria to
distinguish them the best criteria seems
to be exactly the author's intent st. it
since it preserves the identity of
software regardless of the fact that is
being currently executed there is a key
difference in saying that when resting
software is just data and that it can be
seen as just data when a program is
compiled for instance it is taken as
just dated from another program and
finally there's a disk on filling
between software engineers that this
ontological question is not really
relevant so I would say that using fire
fire Robin famous quote this is the
anything-goes approach right so one
quote from James level that was here
yesterday our view is that computer
science has come of age computer science
is sufficient for itself I'll beat as an
unrestricted science from our
investigations must be prepared to
follow their problems into any other
signs whatsoever indeed some key results
on the discipline of software
engineering such as design patterns seem
to be judged simply by the criteria of
projects applying them being successful
it doesn't seem to be any bigger reason
to apply them so the anything-goes
approach can include a posteriori
justification but it tenth Assizes the
nature of programming as a practical
activity and rima fakih it is reasonable
to take decisions based on purely
practical grounds
the pragmatism of software engineering
and its emphasis on human needs can we
capture better than in Brooks saying
that sword Smith successful hosts
clients died of old age so the
anything-goes approach also advocates a
descriptive worldview that is one that
avoids metaphors and grand schemes it
sees the ontological question not so
much as a question of nature of a
program but more is a futile attempt to
find the most perfect analogy for what a
program is it also don't play the roles
of analogy in other fields like in the
design of the languages themselves like
we have seen you know analogies of
object oriented programming as Plato
platonic forms or even prototype basis
vegan Styne family resemblance or
recently I've have seen some certain
forms of functional programming as
whiteheads process philosophy the sort
of thing so
so in the same paper they have this
criticism of the sort of analogy which
is it doesn't seem to make much sense to
say that a bovine object in a program is
an abstraction of a real cow in a farm
it doesn't make sense to say that the
object in the probe the program is
implemented by a cow in reality or that
the objects in the program are special
kinds of cows which do not eat excrete
or expire I'll turn ative ly following
Plato we could have an abstraction of a
cow as the idea immutable eternal form
of a cult perhaps corresponding to the
cowl class but again this kind of
abstraction is not a good ! out in the
following part of this they try to give
an account of this relation which is
interesting but the things that all
these analogies simply put there what
what people call lie to children a lie
to children right there is something
that allows students to climb the first
steps in a subject and only throw away
the ladder later but it is very common
that we in our deeply ingrained desire
for simplicity we commit this fallacy of
analogy confusing the analogy for the
real thing right so within modern
computer science there is an
intellectual posture that accepts
metaphors from water disciplines and
critically without providing arguments
as to why that metaphor should be
applicable in general it is the result
of the modern grand narrative computer
science must conform to some theory
where the theory is carried by metaphor
and also I have to say that dextra has
criticized harshly this role of analogy
especially on teaching computer science
because when we go to university you
know people try to find something
familiar to explain these new concepts
so what he says is that it is the most
common way of trying to cope with
novelty by means of metaphors and
analogies we try to link the novel to
the familiar and they're sufficiently
slow and gradual process gradual change
it works reasonably well in the case of
a sharp discontinuity which things
computer science is however
mmm the matter breaks down though we may
glorify it with the name of common sense
our past experience is no longer
relevant the analogies become too
shallow warm is leading them
illuminating the education of dogma
seems to be that everything is fine as
long as the student doesn't notice that
he's learning something really new more
often than not the students impression
is indeed correct I considered a failure
to prepare the next generation for
radical novelties as a serious
shortcoming but again the dangers of an
allergy only materialized when the
ladder is not thrown away and given the
educational benefits of an illogical
thinking and maybe even the possibility
that we can really get rid of it we
should maybe instead focus on more on
being clear and clarifying these
relevant features when any analogy is
introduced if you want one very
interesting example of this sort of
explanation there is a paper by a guy
called antero duyvil sorry I don't know
finish so I know and the papers called
classes versus prototypes and the way he
explains that object and his programming
seems to embody this platonic of scheme
for a very simple reason is that a lot
of our practical work when we're
programming is related to the problem of
ontology that is we need to define what
are the elementary entities in our
applications we need to define their
name their functions and their relations
so once we recognize that this is the
relevant feature of this analogy we can
throw this analogy away and what he does
in this paper is that he even used this
to advance a little bit the field
because he goes to more contemporary
cognitive psychology and he concludes
that prototype based object programming
is more in line with current
understanding she's trained right white
we would draw analogies of like very
old-fashioned theories that have nothing
to do with reality so now some final
remarks and whatever programming is it
is certainly a radical of novelty in
this sense that the extra puts it
so this view makes it imperative for
programmers to understand their trade in
a deeply reflexive way in the worst case
scenario this kind of knowledge may help
us have better answers than the phone to
the question that there's this book
colors at work so this guy asks for many
programmers the question do you think of
yourself as a scientists scientist or an
engineer or a craftsman or something
else entirely so I'm putting this
response to this question not to mock
the outer of course because i think this
sad feeling is widespread in our
industry and represents many of other
programmers feeling so his answer to
this question is I see myself definitely
not as a scientist or engineer because
because those are very formal
connotations I don't do a lot of math I
don't drop blueprints I don't prove
things I write a lot of screen savers
thank you the text is on github so you
can send pull requests fork make your
own version hi so one thing I'm curious
about is what your thoughts are on
design as being kind of an activity
that's that's comparable to science and
engineering because I know that like
after some of the stuff herbert simon
did i think there was this whole
movement of like design methods where
people said like hey design is actually
kind of a discipline and it's it's a
real thing that that people do across
all kinds of careers and I and I see
after learning about this I see this a
lot in I feel like as a programmer
that's largely what we're doing not you
know architecting or crafting or
whatever yeah I think this just feels
like a new breakthrough or something
because I think we work we know if you
agree with me but we use the word design
in two different ways why there's this
idea that design is sort of related to I
know what web designers do you know like
that is purely an aesthetical thing
there's this sense of design but if you
look at the literature of epistemology
of engineering they use the term design
to explain their method for like a long
time so you know design has starts with
a problem you know you you apply certain
reasoning to figure out what how to
solve this problem have to choose
materials you have to you know do all
these steps and nowadays you even have
to think about the consequences of your
products like environmental issues in
stuff like that and yeah I think that in
this sense when people say that the
design is method of software engineering
they are equating with the engineering
sense they'll actually actually the
other way you use design is also the
same we just have this I guess
misconception hey so don't you think it
may be useful in the modern world to see
programming not as a discipline maybe
but as a kind of literacy as it is kind
of common foundation that is used by
scientists craftsmen artists industry
professionals not not not a discipline
anymore because the foundations are laid
out already it's kind of literacy
everyone needs to speak this government
no I think this is like a different
question to be honest I mean of course
in the beginning said like you know
programming change all the other fields
and it means that it's not only
programmers whole program physicists
program everyone programs nowadays you
know even when you do a spreadsheet your
user is sort of completing your program
I haven't give the whole program so you
know of course I mean it's super
important what else can I say yeah there
was one slide that disturbed me and that
started with a good in the real world
everything breaks down you know and you
can't really trust anything and well
it's not about really trusting anything
they're just saying that you cannot you
know mathematically prove things because
it's too hard it's not like you cannot
know anything
but I think it's unfair because even in
mathematics you have assumptions axioms
where you start and then you build from
these axioms you build some some kind of
truth and proofs yeah and in the same
way I think you could at least think of
a program as assuming that we have an
operating system that always do this and
this then we can think of the program on
top of that yeah yeah this is I actually
refer to this two things one is that as
I said you you can see a program in an
abstract way that's not pro matic at all
I mean think about a sphere in a
mathematical context right mathematics
deals of the sphere there's this
equation that you know you just know
this equation about it but then you have
in science you care about movement of
dolls and then an engineering you try to
make the best ball if you're successful
you make like a World Cup ball but we
all did like a little softball which is
shitty engineering but it was fun so
mathematics deals with this object that
is not in the world that is the the
sphere you know so putting what I said
there is that when the prongs that when
you look at programs abstractly you're
not talking about programs anymore
that's that's the main issue you know it
is useful at the same way that studying
sphere is useful for understanding balls
but it's not the same thing okay thanks
so I saw the categories that you
described and I mr. one which I was
introduced to in Upsala 2006 in
presentation by machinery not so he
classified the linking into the
rationalistic thinking and ballistic
thinking which would be engineers and
mathematicians and clueless thinking
clueless clueless as existing like when
you make like this sock ball you you're
being clueless about you know the
dynamics of balls and stuff fine yes if
you just play this occur then you are
goulais our losses fun well but he
claimed that the majority of programmers
are clueless
and that's reality that we need to be
ready for ya and when I was well I
sometimes talk about API design I was
saying that the role of the designer is
to make sure that the framework created
can be used in clueless mode because
that will really help do good
engineering for majority of the people
out there yes so I think this is sort of
an embodied in his a postmodern whatever
name you give you because I know you
should read the big ball of mud paper
great paper so basically I guess the
idea of the paper's like okay in the
reality people are doing this not what
you're studying so why don't we sort of
study this thing understand it and try
to improve from from there but I guess
that if I really needed this part
because i have only 35 minutes but i
feel that if you go this way you're sort
of your methodology sort of becomes a
mix of all these things plus some social
sciences because what you're doing is
sort of anthropology like you know you
have to study programmers you know how
they behave and so on which I think it's
valid I mean the dip is why this is the
defining programming so hard because
this is also part of it you know it last
question okay not not so much a question
is observation you ended up with a slide
about screen savers and there's the
cords with my own view that perhaps
there's a fourth category which is
programming as artistic medium yep and
that's why it's so difficult to detangle
a foreman and and the you know formal
aspects from the the physical aspects
but I had a an illustration of your you
know what is data what is program way
back in the day there was this program
but that we had which had an a minus e
option which would spit out an EDD
script which was obviously program and
there was also a minus C option which
would spit out a context diff and
everyone said that's data that's data
for humans and it
and probably because the minus e option
existed that actually blocked people
from thinking I could think of the
context if it was a kind of program yep
which is instructions for how to update
someone else's copy of it yeah and
that's that was realizing that that was
a form of program was kind of the origin
of the patch program and realizing oh no
the computer could actually take the
context diff and interpret it and apply
it and and so you know there you have a
piece of data that was not thought of as
program actually turned out to be yes
hope just a comment on your comment is
that I actually for the lack of time I
haven't evolved much on this discussion
but one of the papers that deal with
this sort of data nature of programs
they sort of agree with what I said you
know like that intentions of the
programmer is what keeps data being a
program to time even if there's no
existing way of executing it today but
they sort of give a very good counter
argument which is that if you see it
this way any data can be interpreted
software it's just a matter of you
building the parser for it even you can
find a crazy way to make noise execute
you know you just need to create the
parser for that so it's like a counter
argument that they try to deal in a
different way but I think it's really
interesting observation thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>