<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Adil Akhter - Orchestrate ING with Petri Net | Coder Coacher - Coaching Coders</title><meta content="Adil Akhter - Orchestrate ING with Petri Net - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Adil Akhter - Orchestrate ING with Petri Net</b></h2><h5 class="post__date">2017-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wICfskNsa2E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning guys yeah I know it's five
o'clock but yeah you're just getting
started right so please bear with me for
the next 30 minutes we are going to take
a look at how ing is using Petri net to
model this financial organization a bit
about me my name is Adil and I work at
Angie as a lead engineer and today in
this talk yeah today in this talk what
we're going to do we are going to take a
look at a mathematical formalism called
Petri net and how we're using it to
model a financial organization IG in
this case so the outline of the talk is
as follows first we are going to give
you the problem that we are solving in
today's talk so give you a bit more
context that what Angie does and what
kind of problem we are solving there and
then I'll give you an introduction to
patina just in case if you don't know
about it it's a mathematical formalism
for modeling concurrency and control
flow flow and then we'll move on to the
application of Petri net at Angie and
finally I'll conclude with some remarks
and pointers to our future work that
we're planning on doing on the project
so without further ado let's get started
IG is a global financial organization
which has been operating in 40 different
countries and serving around 36 million
customers right now and the way it's
serving that meeting customer via large
amount of processes so if you think
about opening an account and think about
just in Netherlands we have 40 different
products to manage our current account
and if we empirically take a look that
how this kind of processes are built we
use a lot of low level programming in
this case it's a sequence diagram of a
process communicating with different
services in order to create current
account which in paper looks quite ok
but
as we jump into the code it gets quite
messy as we are using quite a low-level
programming in order to model this kind
of processes which is largely ad-hoc
error prone and very time-consuming and
hardly scalable as the system evolves
reasoning about these kind of
interactions where a service is
communicating with many different
services become much more difficult and
it also become quite difficult to change
the service because it might have a
ripple effect on other services so
proving the correctness of the
modification become much more difficult
as we are dealing with we're using very
low-level programming in order to
process our models so when we change
something it looks like and try to
deploy it in the production it looks
like this we hope that it might work and
if it works all okay but but if it
doesn't work then we have some
interesting problem that we need to
solve in the production systems in
general it is quite difficult to specify
how a system should behave and ensure
that it behaves according to the
specification but yeah as a financial
organization such as ng we it realizes
that we need better model tools and
technique in order to implement this
kind of process where it interacts with
a lot of different distributed system in
order to fulfill a customer's request
and therefore at ING we are moving
towards building one in-flight platform
a bank of feature we're using one
platform will be serving this 36 million
customers and the therefore the the
platform has to be omni-channel scalable
and resilient fault tolerant all the
buzzword compliant and therefore we are
moving towards service-oriented
architecture micro service based
architecture where each services if you
think of it as a building block it has
to be a very modular building block and
at the end we'll be composing this
building block in order to create
a bit more complicated complex systems
but as we start building our system as a
composable building blocks it poses some
difficult challenges with respect to
coordination integration and
synchronization of services in order to
fulfill a request let's say that you as
a user want to create an account in IG
meaning that okay somehow we need to
coordinate among different services now
for instance in this case if you want to
create a customer create create an
account it has to go through two
different services in the first service
here it's registering an user to ng
system in the second one is just
generating an Iban number and the third
service their open account
it's assigning an eye pin number to a
customer so that brings us to the
problem that we'll be addressing in this
presentation today how we can model a
process abstract specification of a
process that can interact with different
services so we need a formalism by which
one can specify a process that interact
with different services and we have to
have this ability to analyze this
process so that before we deployed it to
production we somehow have this
assurance that ok it will work and the
fast and dynamic composition of the
services and proving that composition
works is an essential requirement for us
at ING to accelerate it's time to market
with diverse set of products so this is
the problem that we'll be addressing in
the rest of the talk and since it has a
great value for for NG we started to
look into different solution for this
problem so we started brainstorming we
went to academia start reading some
papers and we found a curious little
language for concurrency and control so
called Petri net which provides a high
level yet precise language to express
and reason about the concept at their
natural level of abstract
and after we did some more investigation
we found out that okay so it's a very
expressive language to model all
different kind of contours flow patterns
and after further investigation with
reading a lot of different research
paper we realize that it's a really well
founded process modeling technique that
has formal semantics so if you use it
it's a very simple language it has a
graphical counterpart but it has a
formal semantics so you could analyze
this analyze the specification based on
Petri net to come up with some
interesting aspect of your system so
that's why they have been used to model
and analyze processes in different
domains for instance either it has been
used in modeling protocols modeling
manufacturing tools and also in business
processes as you can see there are
several because that's also pointing
onto the fact that it is it can be used
effectively in composing services and
for coordination and integration of
different services together so we
thought that okay it's a really
interesting idea why not we do some yeah
investigation dive it dive into it a bit
more and in this section I will give you
an idea that what pattern it is is basic
construct and a semantics as well so
this expressive power of pattern it has
been here since 1962 so it's quite old
it's around like 50 years old now and
there are only three ingredient three
building blocks of this modeling
language Place transition and token a
place you can think of it as a
placeholder which can contain some
tokens and there is a transition that
can consume some token from a place and
produce some tokens in some other places
so these are the only few building
blocks that that that a patient has and
with this building block we can define
the structure of a patina as follows the
painting that
a bipartite craft which is connected as
well as directed so the node of this
bipartite can be only cocaine sorry only
a place at any transition and the place
can have tokens as well so distribution
of token is formalized with this notion
of marking you can think of it as a
function which takes up place and give
you number of so I talked in that place
has or it can be modeled with some other
data structure like vector or multi set
for instance in this case in place III
we have two tokens so you can see the
aim of III is 2 so this marking gives
you an idea that ok how the tokens are
distributed among the places so now we
have all the basic constructs so we can
formally define water Petri net is
getting it is at a pole of PT F and M 0
where P is a finite set of places T is a
finite set of transition so we already
know about place and transition and M 0
is the initial marking so initial
distribution of token in the graph
structure and important part here is f F
is the flow relation it it it represents
the arcs between a token and sorry
between a place and a transition which
in essence determines the behavior of
the network so for instance in this case
we have graph we have a catcher net the
t 1 is connected to plus p 1 and p 2
both has tokens so since all the input
places has tokens t 1 is active or
enable in this case and when it is
triggered it consume one token from each
input places and produce token and
output places so in this case when it
fired just consume some token from the
input places and produce the token and
as simple as line so we'll dive into the
semantics of of Petri net its execution
semantics with it talking again for
instance in this case T 1 is connected
to this place which has a token meaning
T 1 is enabled
so when the transition fire it just
passed the token to its output place and
which in essence are enabled transition
t2 and in essence that determines
transition t3 so that's how it passes
token from a transition to transition
transition just moving token from input
places to all places and it creates this
interesting relationship for causality
so as you can see the T true d3 cannot
be fired before t2 so it actually you
could explicitly encode some ordering in
in your with Petri net in your topology
then there is this concept of a cold
foundation in this case t0 is a cold
transition because it doesn't have any
places so it is another all the time and
this kind of transition are a bit rare
but it represent the the event that can
be fired from outside of the transition
so you could fire something from outside
of the transition that can produce a
token so that's that's what it's
represent so it it models the
communication outside the Petri net in
to insert Virginia and when the token is
enabled in this case token is in place
then in turn about two different
transition t1 and t2 now we have to
transition Anibal in this case it shoots
it selects one of them
non-deterministically so this kind of
property encodes some non determinism
using this you can also yeah also define
some safety requirement in your Petri
net for instance in this case either t1
or t2 will be executed not both of them
so using this modeling language you
could spare you could encode this kind
of safety requirement this is just only
one of them that I'm showing mutual
exclusion if the t1 get fired
non-deterministic
it can split the token flow in multiple
branches that can be executed
concurrently in this case yeah since t1
put the token in two different places t3
and t4 both it's active and then you do
have conferencing so you could encode
explicitly how concurrently you would
like to process your pertinent since T 3
and P 4 does not have any dependency
among each other they can be executed
parallely and yeah so now that you model
we model concurrency with Petri net
there has to be some way to synchronize
as you can see that PD file can be only
enabled when both t3 and t4 is done with
it's processing and put the token in
other places so in this case by by using
this kind of somatic you yeah you could
equal encode synchronization in Petri
net so as you can see using this simple
modeling language we have defined
several things we could define causality
we could define concurrency and also
synchronization and it also allow us to
specify some safety requirement like
mutual exclusion so this using this
formalism we thought that okay we could
define the control so of service
interaction quite nicely therefore we
had a problem and suddenly we found a
formalism that we can use to solve our
problem and therefore we thought that ok
why not let's do a proof of concept with
this formalism Petri net and therefore
we started with a team of developers to
build her colored page in the DSL and
runtime a color fitting it is bit
different than normal portunity in
normal portunity you don't have the
tokens doesn't have any value in it but
in color petunia the token has a value
and time as well you can think of it as
a domain object in your system account
or user so we build this libraries that
allow you to model
coloured Petri net and also run it in
aqua cluster and we use a bit different
transition model in this case the T
transition T takes input marking and
also a state and whatever transition is
a fire it produce an event so we we were
moving towards a given region
architecture in this case and when this
event is produce we can apply this event
on state s to produce a new state so you
could think of it as a even sourcing
function we had all state and an event
we can produce a new state from it the
reasoning behind using this kind of
transition model is that we thought that
okay we're defining process with petting
it somehow we need to migrate from one
version of the process to the next
version so we have some notion of
version versioning with with with the
state we could do something about it so
let's take a look at an example of
making a pasta with that unit so
basically in this case we have in we
have a structure we have a network
structure where first we're doing
groceries it can give you pasta and
tomatoes and then we can boil that pasta
and cook sauce so T 3 and T 2 can be
executed concurrently and when you have
boiled pasta and tomato sauce yeah we
synchronize it somehow with a
synchronization construct and then T 4
sub the dinner and we're done with this
patch in it we can model in order to
model this network topology we use type
level DSL that so if we just focus on
this part of the graph here we can
define the pasta the places of boiled
pasta tomato sauce and tongue using this
code and also we can have a transition
that takes the ball past and tomato
sauce and do some stuff with it so this
is how we can define a place and pasta
using the DSL that we have in figure
and using the tact little DSL we could
we could just specify the flow
relationship then we have the graph file
this this above drop above specified but
note that we have to specify all the
flow relationship manually so the the
whole graph can be owned and that can be
described using this flow relationship
and it's compiling at compile time it
can checks all the time all the time
matches or not so in order to do that we
use shapeless and so this is how you can
declaratively specify your network
topology but when it's done designing
the definition of the net we can
instantiate we can materialize this net
as a Petri net and then we can start
executing by firing a transition for
instance when we fired groceries done we
get pasta and tomatoes then t23 can be
executed in parallel and then when we
have both boiled pasta and tomato sauce
we are serving the dinner so basically
this is how you could differ you could
design your processes you can execute
them and you could do also some analysis
on it we'll come back to the analysis at
the yeah in the next section of the
presentation but we have seen that okay
it's a it's a graphical representation
it's a graphical modeling language but
it has formal semantics so we thought
that okay it could be quite ideal for
ing because we have expert and Onix by
both are working in the same team so
they can communicate with the same
graphical modeling language and
important part here is that okay it says
state based so we could do something
about the process migrations and yeah
there are a lot of analyzes technique
that we'll see in the next section of
the presentation that we could use so we
thought that okay it's quite interesting
maybe we could use it to actually model
the current account process that we
already had energy so when you've
started modeling we suddenly see that
the graph structure start to grow really
big and as the system evolved further it
become massive and we realize that okay
it would be quite arable to draw all the
flow relationship between the place and
the transition manually and it is not
work so we get a completely mixed
reaction from from the stakeholders and
developers of the team that okay and
it's difficult and yeah we thought that
it's cool but a lot of people like no
it's really difficult so basically the
learning from this exercise was that the
name structure grows really large for
large you reason about for industrial
processes and dope it in it is a simple
language
it's a conniving formalism which has
yeah formal semantics which scares
people quite a lot modeling and
analyzing business processes is a
non-trivial task and it's kind of an art
than science to model processes so we
started doing that how can we make it
work how can we come up with a with a
better solution than the solution that
we had so we realize that okay maybe we
could come up with a bit higher level of
abstraction than patching it and which
allow us to define those transition and
we'll give it give this transition to
this abstraction and it can generate the
flow relationship among those among
those transition so basically what I'm
referring at that okay if you have a
sequence of transition one can analyze
this transition and derive that graph
structure the bipartite graph that I've
shown earlier but that doesn't solve the
scary part that okay it's a mathematical
formalism and the adoption of this
formalism is very critical for our
project so we realize that maybe we can
come up with a nice DSL so we build this
project called Baker it allows you to
define the processes with ingredient and
create a recipe so just like we create
pasta which has a lot of different steps
so we thought that okay as in order to
define this recipe you would define
those steps and you give the ingredient
then rest of the staff Baker will do it
automatically so in particular it
enables orchestration of complex service
based process flow but it will use the
terminology from
yeah family a domain like recipe cooking
and that kind of stuff so we started to
build this abstraction so there are like
main three thing in this case we come up
with ingredient even an interaction so
previously we cooked pasta now in this
example we'll be cooking pizza and we'll
give you an example how this dsl works
so in green like any recipe like okay if
you are cooking pasta what would be the
ingredient it it will be like flour
tomatoes and that kind of stuff so those
are like ingredient in our dsl as well
and more event there's this notion of
even that models causality so you could
think of it as a primitive signal but it
can it can carry some structured data
for instance in case of baking a pizza
even could be that okay your kitchen
tools are available that even gives you
a lot of kitchen tools like bowl for
oven and sieve or it could be like only
oven heated even so let's say that you
turn on the oven you get even that oven
is hitter away so you could define this
kind of event using your by by extending
this even market rate and yeah lets you
specify all all the stuff that you can
produce it might not produce anything
then the last construct of our DSL is
interaction it can be you can think of
it as just a function or it just has an
i/o that is communicating with an
external service and give you some
result so it's an operation for instance
if you think about C flour what do you
need you need a flour and salt and C and
then you do something and you get C
flour to bake your pizza so it can be
defined as follows this C flour can take
like three ingredients and it provides
our C flour as ingredient as a return
so yeah we could define these
interactions but note that we didn't
define any implementation of the
interaction here we're just specifying
that okay this could be a interaction
this could be a step in your recipe then
we can give this recipe we can we can
construct it we can we can create a
recipe from it by giving all all the
different steps but this step doesn't
have to be ordered so you could give the
step in any order and you would also
give some external events as well if you
recall these are equivalent to cold
transition of Petri Nets so these are
the even that could be fired from
outside for instance one could be like
okay groceries is done so basically you
get all the yours ingredient to cook
your pizza so when you have define your
recipe like this then you could give it
to Baker and Baker what does it do some
compile time validation static analysis
and derive this graph a petty net gun
but this in this case is not a pet unit
so it's a third graph or four yeah step
so in this case it's also draw all the
flow relationship among this are so it's
quite similar to patching it only we
have additional course rep even but
that's equivalent to cold transition in
Petri net just to give you an example we
have previously these three different
services and now would like to create a
recipe to create an account a current
account at Angie how we can do that we
can define different interactions and we
can give it to the recipe create a
recipe from it and give it to the
recipient Impala when when we give it to
the recipe compiler it can yeah
sequence all all the actions that's need
to be done for instance the first you
need to do have the I remember
and customer create customer that has to
be done first and then when you have the
Iban and customer ID then you could do
open account and then when the account
opening is done you just notify your
customer so what's happening that we
previously had all the transitions now
we have ingredient ur actions we are
giving it to the compiler and compiler
is generating all the flow relationship
but before generating it and also
validating that the your recipe is
correct if the recipe is correct then we
compile it down to our Petri net and
that that pattern it can be executed via
the pleasure runtime that we have built
earlier part of the presentation so we
can instantiate instance on paper by
leaving all the implementation of the
interaction and the recipe so we give
the recipe and we give the
implementation then it creates an
instance of Baker and when an instance
is created we can and let's say that a
customer requests to create an account
it creates a process so from recipe we
are going towards process now recipe is
just a description and processes the
runtime part of the recipe and then we
can read again we can initiate some
external events like groceries is done
teaching tools are available when that
is available when this events are raised
then it starts executing all the steps
one by one so all the transition start
firing and we could we could check that
ok which are at what state our current
processing in is in by taking a look at
all the events that's already been fired
and by looking at the ingredients that
already provided in the system or
generated from the system there are
several things that we get for free
using this model one important aspect is
that the concurrency since we are using
patent as our online engine we get one
currency for free while recipe compiler
generating this graph it makes sure that
the concurrent paths can be executed
apparently and then we do have also
synchronization automatically down there
apart from that we do have observed
effort from that we also define our
persistence in a quite generic manner so
we are back we have a lot of different
kind of regulation and policies so we
have it we come up with a generic way of
encrypting all the data so now the
application developer does not need to
worry about any kind of encryption if
you use Baker Baker is just alive if you
use it your data will be encrypted and
stored in Cassandra for instance and we
do have some real unreliable services so
in that case we also come up with a
generic way or retry mechanism so if one
of your staff fails then it can retry
with a configurable yeah configurable
retry strategies so if you get back to
if you take a look at the technology
stack we are using Scala akka and all
kind of extension or Farkle like our
code cluster sharing a persistent four
even sourcing and occurring for
processing all different kind of events
and in production we are storing the
data in Cassandra and for the even
processing or getting even from outside
of the system we are using Kafka as well
so in this case it's important to note
that every process all the events that
coming is handled by one actor one
persistent actor so every press process
we create an actor and this actor will
be receiving all the events from outside
and process all the events as well by
fighting the interactions or transition
in between each arm so yeah we come up
with this abstraction then we tried it
in different systems as well for
instance in this case we built an order
management system with with this Baker
recipe DSL and we also tried the current
creating the current account creation
the sequence driver and dragon that I've
shown ok
Oh should have five minutes
so that uh yeah still it looks scary but
the thing is that you don't need to
handle those arcs the flow relationship
yourself anymore it's been done
automatically by the compiler analyzed
validated by the compiler so yeah we
have done we have built quite some
abstraction but what's the gain what's
the profit from it we can visualize not
only the compile time version of a
recipe but also the runtime so at
runtime the the event which are
monitoring are already being executed so
we do have a monitoring tool that can
that can view that at which state the
processes in right now and yeah that
that helps a lot with the different
process if the processes start we know
that at what level the process got
stopped and since the underlying
technology that we are using is patchy
net we could do a lot of analyzes for
instance we could do reach ability we
could we could find out that okay these
are the date transitions these are not
being executed at all given the initial
marking end and then we can also check
the the if there is any any cycles in
the in your graph we these are only to
name few but there are more analysis
that can be done for instance we could
do a lively liveliness check bonus check
and there are a lot of different kind of
analysis that we can can be done on this
net structure and we'd like to focus on
other aspects as well like for instance
the back traversal time we could we
could find out that how much time it's
taking to go from a to path P and also
time also find out some button like that
okay probably one of the one of the
interaction is taking a long time to be
executed so these are the thing that we
would like to focus in future also we
have shown you that the choice in
petting it it was non-deterministic but
probably you could use some heuristic to
determine that which part of our of
choice will most likely to be executed
so the last benefit that we get is
usability we get a unified programming
model by using DSL and so expert and non
expert of a team is communicating in the
same language we get a conceptual
infinity so not only in one team but
multiple teams is speaking up this way
of modeling processes if we take a look
a different variant of product of
creating current account now most of the
interaction can be used from one product
to another so we have the building
blocks and we can compose those building
blocks together to to create many
different processes and these
interactions are created in a reusable
building blocks and shared in in a
shared repository so the other team who
is starting a new process they can pick
up these interactions and submitting the
recipe and processes from it so in in
our opinion that was a huge gain from
this whole project so what next would
like to model Baker as a service where
someone can upload an external DSL and
it can start processing those DSL in a
service architecture and we like to try
out some other formalism as well and we
like to focus on a project where we
could generate the ey from this recipe
DSL for our back office and every year
we get around 8 million calls in our
back office for different processes so
if we can visualize what's going on and
at which step a process stuck we could
do we could we could help our back
office quite a lot and the last but not
the least would like to focus on process
mining as well basically that means that
we do have a lot of mainframe computer
that has even lock so you'd like to
analyze the email log and derive a
better net from it so that way we could
we could observe the behavior of the
mainframes that we already have at Angie
so yeah these are the few direction that
we would like to work on
in coming period so the key take away
from it that okay this was just one
problem that we have solved by using
some mathematical formalism but
definitely we need to we have other
problems that probably could solve by by
by taking input from academic research
so it should work more closely and with
respect to this project the learning is
that okay raising the abstraction level
a bit to towards the problem domain
helps a lot and hiding complexity
specially make it much more yeah much
more adoption that we got from it is by
hiding complexities so now all the teams
are communicating with the with the same
concept so we get some conceptual
integration by using the DSL that we
have developed and definitely it
increased our usability and productivity
as well and last but not the least I
like to point out probably this is the
this is the main learning that I have
that we should always use lawful
abstractions which are correct by
construction and it has the formal
semantics that means that okay we could
analyze it and we could do we could come
up with some nice property we could
validate the thing that we have written
or works and then we can deploy it yeah
without worrying about the runtime
errors nullpointerexception and that
kind of stuff so we have already open
sourced all all the code that i've shown
on those slides this project is there
and github please have a look and give
us your feedback that how we can improve
on behalf of the team who is working on
this project I'd like to thank you for
joining this talk and if you have any
question or feedback please let me know
okay yep
yeah we were thinking of trying out some
other formulism as well but no it's just
something that I saw talked in the
morning I would thought that probably
it's quite interesting to to model
distributed system like that and
therefore I was thinking that ok maybe
we can try out the point that I was
making that since we have a separation
of model and and you have different
model to model transformation is going
on we could change quite flexibly one
part of the model and try out some other
formulas or as well yep yep
most people
like
ha
okay so it can it can automatically
derive that arrows as well
uh-huh
hmm no but it's a good pointer I'll I'll
take a look are there's something that
we can we can do so we we don't at this
point we don't have that feature so we
were thinking of some some way off so
basically it's immutable structure if
you create a new recipe it's a new
process so how does the old process a
new process there's a there's a mismatch
between the wall and a new but we we
have been working in this project for
the last eight months now so yeah these
are the stuff that that's in our roadmap
to look into it so right now around ten
teams picked up this this model and they
will be modeling all their processes
using this etching net and Baker
previously it was like all hand drawn
all hand written now they could at least
yeah they don't have to deal with
concurrency anymore synchronization
anymore so these are the stuff that
they're getting for free yeah yes
now the thing I and in the beginning I
was wanting out that okay we are moving
towards the service microservice a
collegiate so those services are they're
running somewhere huh so those are the
building blocks somewhere running your
functions getting some input giving you
some output so in the recipe you define
that hey I'd like to communicate with
the service with this value and get get
this as a result so I'm giving something
to the service and getting something
from the service and that resulted as an
ingredient in the system or token in the
Petri net so we communicated the service
get result and provide that token in the
network
I'm sorry I didn't get the here's a
model yes so the model you define it
abstractly and then you use the compiler
to compile it to a pet unit and runtime
version of the Petri net so you have it
running somewhere now we are running it
in a cluster okay so basically each
actor a persistent actor is responsible
for one process so we have this request
idea one of the side I was showing we
have this request ID and via this
request ID with clusters shutting it can
always go to that one actor meaning that
that one actor is handling all all the
other transitions and firing different
transitions we could also versus that
and yeah and because the process can run
for multiple days so basically we can
persist and reboot the process as well
from persistence
so fine
or that also model in the graph grow
really big because that was also
modeling that so basically can
interaction can fire one of events we
have that construct in the language so
it can file like okay I have the account
has been created or account we could not
create that out yeah sure so many yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>