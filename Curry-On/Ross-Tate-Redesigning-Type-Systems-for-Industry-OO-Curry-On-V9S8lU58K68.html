<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ross Tate - Redesigning Type Systems for Industry OO - Curry On | Coder Coacher - Coaching Coders</title><meta content="Ross Tate - Redesigning Type Systems for Industry OO - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ross Tate - Redesigning Type Systems for Industry OO - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V9S8lU58K68" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I kind of want to learn say about the
audience who here does some language
design handful people all right anywho
any of you not like have a PhD
sorry other language learners these
actually want to know that too so that's
good to hit those hands but other
language I knows who does not a PhD
almost everyone that's the present
alright didn't know and now I not much
understood people in the audience okay
um i am ross states i'm a professor at
Cornell University I also advise
multiple languages on sort of how to
improve their type systems this is
somewhat of an unusual set up so I
figured if she gives a background like
so first of all I can i when Steve
Coppell he stands with so as an
undergrad this is a completely industry
oriented school I am I think the only
person in my major that went to grad
school by you so I never planned on
going to grad school I used to make
video games so but now evidences UC San
Diego because a bunch of pressure from
faculty and internet microsoft research
and then I'm a professor at Cornell
alright I study just make video games so
I actually worked on Activision's
internal programming language what they
use to script their games and this is as
an intern but then they hired me back
later on to redesign their language
later on I did some research on language
design and the sailing team contact me
about how they can find out research
through their language and then the
Colin team did the same thing and just
recently like very recently assigned
working the Java team but we haven't
actually got anything done yet so i'm
working on bridging this gap between
academia and Industry trying to say how
big people i understand what research
theory is out of things we can use and
also understand help the academics
understand what needs of industry are so
my goal in all this is to sort of makes
the industry languages better now it's
important to note is that I'm not saying
make a and if your language better I
don't have my own language I actually
want to be so many of them better and
also better is in quotes that's because
it's not clear what better means right
we don't really have a good way to
evaluate things like productivity or
stuff like that and I'm although I used
to be a web developer happens or did so
before JavaScript was a really big thing
so I keep myself in touch but this is
something different between doing things
every day and doing
things just once in a while to keep
yourself up to date so rather than me
making the call I work with other people
and help them or who make the call and
help them work that through so my
approach is to help industry language
designers create the language that they
envision right if you once the language
to look like this or act like this or
interact like this you have an idea of
how to go about doing that but there's a
lot of details to work out there's a lot
of technologies you have to introduce
there's just a lot of open problems and
so I help them navigate either the open
problem or either the existing problems
and let me know social solutions exist
already or the open problems and come up
with new solutions for them so I just
said I don't push my own vision but I
have this one principle I've seen sort
of hold for routes all my interactions
which is this idea of predictability
sobre disability is the ability for a
program or is the degree to which a
programmer can predict what their
language will do this in something like
I can predict what if I'm at this type
of code i'm going to write this going to
type check or i can pretty through the
library i'm going to use it can be
usable or i can britax if this part of
my code is going to perform well if
things go better than your predictions
that's great but you at least want to
notice or the minimum ground so you can
plan ahead so predictability isn't a
mathematical property of languages right
I can't formalize this in any
mathematical way this is a human poverty
this is about how people work with
languages and so this is something that
I'm trying to see how we can bring sort
of into mathematics so can I try to have
track these things to say okay this
pattern tends to be more predictable or
this behavior helps things out and let
me give you an example so the Colin team
back when was like Ross we wants to be
interoperable with Java but we don't
like wild cards and I imagine number of
you can agree with that sentiment but
wild cards have a use they're actually
they code something called variance and
variance is very prevalent across our
programs so what is variance well an
example is an iterative integers can be
safely be used as an iterator of numbers
right if I'm getting numbers out of it I
don't mind if those happen to all be
integers that's fine it's just a
coincidence
another example is I'm only putting
things into this list and so I don't
have to worry about whether that's a
list of integers or a list of numbers or
list of objects any of those is fine so
long as they can put integers into it so
these are both uses of variance or
various councils variance the top is
best examining declaration side variance
that is when you declare iterator from
this declaration you can see that has
this property because you can only get
these values out of it and the bottom is
a use siberius it's not a property of
all lists as a property of how you're
using this particular list so wild cards
wild cards encode you cite variants but
and c-sharp later it started using
declaration site grains and from this
experience people have sort of said that
this one is if you can only have one of
these two this is the one that when you
use it's just this one has a lot of
syntax and it could be overwritten or is
this one is easier for people to learn
so the common people what if you use
this but they needed interactive Java
and you cite variance is more special
than declaration site variance and the
thing to note also is that both of these
are useful they're covered different
kinds of situations so ideally we could
have both so the question came up it was
basically how do we combine these kinds
of variance so let's give it a little
more detail so declaration side bearings
looks like this you say this an
integrate this is interface of iterable
it works for any e and it Out's eat you
get ease out of this thing and this is
your side drinks this particular list is
something i'm going to put integers into
so this is what goes here could be able
some dangerous or a list of objects
that's fine but this tells you how
you're going to use this country your
list so there's sort of an obvious way
to combine these just like let get my
people do both that and that but the
question that comes up is what is an
interval i could put numbers into now
there's more complex examples that are
not quite so obvious or not what's so
complexin but a lot of people have
actually worked on formalizing this
already
so I went through the literature and saw
that they're all these formulations but
they didn't agree with each other some
of them said this would be the case some
of them should this should be the case
it wasn't clear which one is correct so
rather than designing a language and
selling programmers here's how this
language works I flipped it around I
said I want to figure out what will work
for programmers what is the most
predictable to them and so I came up
with a sort of methodology for a simple
predictability of study study so the
idea is write a bunch of programs it
really depends on sort of the question
of mine so this program will type check
if you interpret iterator this way
versus this way stuff like that and then
give these programs two people that know
the features at hand right so they have
backgrounds we want to exploit that
background so let's see what's
understandable to those people and ask
them which programs they think should be
valid but don't tell them any rules red
bitch is raw other intuitions or the
prior experience and to say what do you
think makes sense here then collect all
those answers and see what patterns you
get okay so did I did this for this mix
light-bearer that sorry to combine side
variance thing and these are the results
people didn't agree with each other you
give the same program to somebody and
they say this would work in its taint
program to another person they say this
doesn't work or shouldn't work but
what's more interesting is I didn't
agree with themselves so I actually
would give the program and just rename
things and give them that program back
they didn't know I did this but and they
would say okay that one should be
accepted in that one should not be just
the change of names change what they
thought should work and the reason is
that name sort of apply some semantics
but type theory doesn't know what these
names mean and so I can't rely in that
kind of semantics that's in their head I
have to have something that works for
all names and so I asked a different
question that was afraid that if I made
some design no matter what it's going to
confuse somebody and I don't want to do
that so the question I asked was this
interval n number makes sense right I
can only get values out of adorable so
why does it make sense to say the
scenario Capone numbers into
my question it or my answer that is no I
just don't understand why anybody would
ever use that type and so I came up with
Nick site variance from the whole idea
of Nick site variants is that you reject
these use sites that sort of contour
they can repose the corresponding
decoration sites right so we have an
iterable in where interval is out mr.
contradiction you can weaken and that's
fine but this opposites are just don't
make sense and what we found looking
back through the analysis is that this
is actually nicely the cases where
people agreed everyone agreed on
examples than this that mix I'd variance
allowed so rather than saying let's
allow all types and give it some addicts
of all types let's just make restricts
the types to just the ones that we think
makes sense and it seems like this work
in practice and interestingly went for
all the formalisms including something
I'd made up just try to constrain more
options and they all agreed for exactly
on these cases as well and this might
imply this right it might be that
everybody says okay well I have this
intuition for how these programs work
that intuition at some half nekked level
corresponds to some mathematical model
and so no matter which intuition you use
because they all agree you get the same
answer now you might be saying well
you're throwing out a bunch of types
maybe those are the useful types right
you're saying I'm not allowing these
programs maybe that's a problem but we
looked into it basically actually handle
has all the full expressiveness of
combined side variants may be things
like the durable n number i don't really
give you anything useful so you can just
stick with a subset and so have
everything you want now because this is
both sort of predictable usable and also
really easy implement right because you
just say since active check don't like
these ok same typing rules that we
already know for everything else and as
a consequence is adopted by cottman
which makes sense I mean I designed it
for them but later on Salem actually was
trying to avoid having used side
variants but they were a nice we went
for the uses obvious I drink so they
once it have is so they added it in the
form of technics light various so this
is an example of sort of looking to
people first before coming up with a
design
and in that way trying to be design
predictable for people right if they're
already checked without them knowing
what the rules are that it gives in the
same rules that they expect we believe
that should make it more predictable so
as another example or I have a sort of
this i'm still debating this question
but if i wanted languages be detectable
does it have to be decidable and so I've
asked specialist many times and one of
the most common answer is is well job is
undecidable he didn't know this job is
undecidable but people don't really run
into that right have you ever had a
program that i picked because it
couldn't figure it out yes what was it
Oh English yeah cruising who wasn't a
malicious users okay so in practice job
is to sign up so people say decidable to
hide really doesn't matter because in
practice it's silent but the fact is you
still care about the side ability you
pair that societal in practice so the
question is why is decidable in practice
right how do i know i'm going to add
some feature that people going to use
and now that's so now it's not decidable
and if you're not also be not decidable
in practice so i think so what I pride
of you whenever I had this kind of
problem is say well looks like I
practice works what are people doing in
practice that makes it that the Java
compiler can handle bit so I'll getting
down a bit but first send a crash
compiler okay so here's the tongue java
code look and it's not popping up
exactly oh I know what it is it's
because I'm wrong mode duplicate there
we go ok so there's in Java code it
doesn't really make any sense yeah
there's these these these theses easy
these really don't do much and you see
it extends is a big complicated thing
let's not worry about that for a second
it's not close to make sense and then we
have the first thing and it takes this
see data sea of excess and returns it
and so the compiler is K is a sea of X
ad ? super C of X
that's all that's all it takes a tactic
this program and so if I oh no I habits
oops here we go
so that's what compilers answer well yes
or no what to say I'd really tried hard
but I couldn't figure it out and what's
concerning is things like gradual typing
which you kind of saw a bit of the last
talk tries to do these checks at runtime
so if these things are happening at
runtime you never know where Brent time
is going to suddenly crash your program
because I can't figure out where the two
types are sometimes each other okay so C
sharp has solve this problem whoops
let's go back to extend mode there we go
but that's my baby project c-sharp I
solve this problem sorry for the
technical difficulties there we go so
here's a seizure program that kind of
exhibits the same behavior I won't go
into why later but we can actually start
using it so you can start ok it handles
the classes you start typing things and
it goes and then eventually crashes so C
sharp as I said solve this problem and
yet still crashing so why is that well
the solution to c-sharp uses is actually
quite expensive it has to as it hurts us
through the program or through the
subtyping has forever everything it
looked at so far and check to see
whether it's repeating itself and that's
just expensive but IDs need to be
responsive right if you press dot you
don't want to wait you get really
annoyed if you've to wait for that thing
to pop up and so the idea said well this
thing is too extensive let's just let's
not do that part and just hope for the
best and here here i crafted soaps so
not only we want to be sizable we
actually wanted to be efficient we want
to be something that they're good re you
can implement easily and that itself
takes a whole bunch of work i'm not
going to go into today but let's look at
why these problems happen
so here's a class and that's the one
from that Java program again don't worry
about understanding it and here's the
sub typing rules at this topic program
how to attract so what Java does it says
well here's a see an addy they're not
the same class so let's use inheritance
now we have 2 d's and then the rules for
wild cards say there's this wild card if
i can instantiate it over here with say
that such that it satisfies the super CX
constraint that is it's a super type of
c of x then this type checks so the
courses and say is ok well now is a sea
of it it's a subtype of equation mexico
cex or then their words is d plus my
super cex super type of CX and the NSA's
okay well c's and d's and my inheritance
then this is the same station again and
so we get to there and the thing to note
is that this is basically the exact same
thing we started with except now it
exchanged X with Y of X and you can just
see this forever you eventually you get
de x and yeah it just doesn't never
finishes so this is actually an infinite
proof of subtyping that is if I'm
allowed to prove forever I can I can
show these are subtypes and so the Java
type ticker is trying to prove something
forever which is why I crashes now you
might say ok I don't care this thing is
completely contrived you know I'll get
to that in a second but first I need to
take a step back ok so the Salem team I
told me actually is one of the design
classes that they want to be decidable
before I even talk to them about
predictability so they care about that
stuff but they also this other girl that
they want to have type safety quality
that is if i say x equals y i actually
know that tell emily will check that XY
have the similar types and those types i
we have a well-defined equality on them
you may run it this bug in the past for
the problem is lists it makes sense to
equates your lists if their elements
makes sense to equate
so they're sort of X's condition going
on there and expressing that condition
using traditional methods is really
difficult it's known as the binary
method problem and it came up with a
solution so this thing so and still on
lists are what's called Coburn so you
can only bits or invariant or sorry
immutable you can look at values out of
it and saying lists are quite about
other lists whose elements are quite
able with these elements this works
actually solves a question glue list of
integers are equitable and lists of
functions are not equate able so I could
check the solution to them and this was
their answer now I didn't make the slide
this is my student father emu look
actually this been dreamin here okay
another student who worked on me on this
project for which with me on this
project and Bobby made a passing slides
so so being a good researcher I am after
pouting a bunch about people hating my
solution I won't eventually and ask them
why don't you like this and I said well
you're using these were your types I
don't we don't understand these types
well they understood there but they
think they're weird I said why is that
well do such a thing as a list of equate
ables equate able associate something to
tell you this type is equated you don't
hand around equate ables you don't put
them in this you might put ease that our
acquaintance leslie it but equate
herbals themselves enlists now that this
is really interesting right this is as a
type theorists I'm like these are these
are just types you can do whatever the
hell you want with him and it solves
your problem the impact least have yet
to find a solution but they still won't
think this is a solution that I gave him
so I decided to formalize this intuition
where we decided to see so I came up
with this idea of materials so some
examples are list integer comparator
these classes are classes you hand
around right you say I take a list but I
return a comparator I take an integer an
hour this is a list of integers right
you actually how so using this type
arguments you can help sorry there's
about a field value return types and you
can list a list the list of integers if
you want that'll make sense but as we
just talked about you can't have the
civic weight of us that doesn't make
sense
and so what is acclaimed ball and play
doubles what I call a shape comparable
which is more familiar example is also a
shape right the idea is that this is
describing a type not necessarily a
value and so these are used recursively
inheritance that is I have integer
extends comparable integer you've
probably seen that and some early I can
sort a list of T's for any t that's
comparable with itself and these are so
shapes do not exhibit this behavior and
materials do not exhibit this behavior
or that was my hypothesis this is the
idea that there's a material shape
separation as people naturally say
things are one or the other and so what
I guess is that no class or interface is
both a material kind of shape and it
check this out we analyzed 13 and a half
a million lines of Java code basically
everything we did at home all the
generic Java code we get there hold on
from mining repos and all that stuff and
what does it say well it's sad you're
right there's not a single use and all
these things on this code now single
class or interface that's use both this
way and this way everything falls
cleanly into one category or the other
so this suggests that there's some sort
of cognitive separations going on here
right we don't realize we're doing this
but we happen to be always using one
thing and everything one way or the
other even though we could complete them
if we women and what is this give us
well pro-one decided subtyping is a
sizable in fact it's a side of all using
a very naive algorithm which is why and
practice you don't run into these
problems because in practice you're
already doing this and they're naive
hour and that everyone's already using
works okay so can we learn anything from
this well if you notice basically shapes
aren't being used as types anywhere
they're just abusing these type
constraints so if you make that
separation you say shapes are only type
constraints and not types then you get
computable joints so that means that if
someone says hey I have an edger and a
string or if someone's asked the
compiler hey I have an injury in a
string what's in common a narcissistic
PI over say they're just booked
objects is that really much in common
but if you tried that in Java has anyone
ever tried that in Java okay so if you
have something like ? call in five hello
but Jabba will say is this is a
comparable if something that's
comparable if something is comparable or
something is comparable something that's
comparable forever and you say i don't
care i don't okay that's a good pair of
all I just don't need to know that's an
object's because you don't use
comparable as the type you only use it
as a touching straight all right
furthermore this thing generalized is
super well so we proved that you can get
triple you'll prove that we could to do
higher kinds so if you would add
functors and my dad's we'd be able to
handle that and everything still be
decidable really subtyping stability is
still excitable other people so ginga
doll prove that you can also do thai
classes with us to this solves its high
plastic question 40 or with using you
cite bearings so what i like about this
is this is a situation where we took an
undecidable problem that is something
that's proven to never be solvable and
we solved it by incorporating the fact
that this problem is not a mathematical
problem it's a human problem right we
are the ones who care about this it's
our we want to be able to program and
that's all we care about so if you
incorporate the human factor that this
this sort of cognitive separation we can
solve the problem and we can solve many
other columns as well using that and
we're actually still exploring our
locations of this and also this is in
language specific it's already been used
or in multiple languages cilenti for
example r and US on their repo as well
and found the same thing actually no
they found one counterexample and they
were already arguing about why they
didn't like this design so I showed or
so given this and like okay let's throw
that out there is really easy to change
one to the other so they just made it
there just change it ok how am i doing
on time what all right good so questions
first
any questions about how you might do
this with your language no so what I'm
hoping is that people will sort of apply
this idea to their own languages that
they'll maybe not this right maybe your
language wasn't have generics but this
idea well rather I have to make the
design choice rather than making me
making the design choice let's ask the
programmers what they expect and do it
not in this sort of very concrete way
here's a program this is work or not
here's a program what does this do and
get all those answers and see if there's
a pattern across those answers in this
case the pattern is really or it was
quite simple there's a subset that
everyone agreed on but in other cases
there might be more complicated right
you might have ninety percent ten
percents and you can make that choice
yourself just you can see what your
philosophy suggests should be done in
that situation yes
I actually use code linen in production
I'm still trying to wrap my head around
equate able of a generic of e rather
than e being an extension of equator
well I guess that that's that's your
solution so can you can you follow that
so try remember what they did because we
were we talked about it um and I haven't
actually looked at what is a difference
when you collaborate with people there's
a difference between what to say we're
going to do and what they actually do
okay so I haven't checked out they
actually do yet but sounds like they say
fool extends for credible foo okay and
this was so that's what Java and all
those things do that okay so why do they
do that rather than rather than through
extends equate able is that the question
yeah so those are the idea is that why
is the difference between the boxing of
the type inside equitable versus the
type actually implementing the equitable
itself unless on the grammar that was
the suggestion all right so big
difficulty so there's two answer to this
question one is the video standard
inheritance you say here's an extenze
acquaintance just equate able you don't
know what's equate able to write because
the quite able says I have an equals
method in and says I takes a object or
something like that and so if you want
to access equality you want as though no
I'm just equate able and equate able to
these things the other answer is that if
you apply this stuff you get basically
actually so a further study it is we
said we found that everybody uses shapes
always as this form it's always fool
extends or food stands equate able foo
so you might as well specialized your
syntax and say well I about foo satisfy
is available right and then well
whenever that's done it just figures out
over that means that it's a quite a bowl
of food and same with all your
constraints so you're getting rid of all
that redundancy in your programs that
makes it clearer to programmers that
these are separate concepts and so when
they have behavior this or do something
that maybe tries to contradict that
they're not surprised that answer
question yeah really insightful thank
you
I'm just trying to understand this so
materials alike first order and shapes
or second order it's like so materials
are sets of values and shapes are sets
of sets that's a nice yeah yep materials
and says this value is the thing that
contains a bunch of values right where
the shape says this type is something
that can be equated just like that's a
first order logic and second work a lot
uh it's not agree yes yes that's your
thing more questions that I have more
fun stuff we can do there's 10 get a pic
on me now yeah yeah I was thinking it
actually it's a very nice result that
you have separate the materials and
shapes and achieve this huge reduction
in complexity and the funny thing is
that this goes along with a increase in
complexity because you put together the
Declaration side and the use I variance
and it seems to be less of a cost
somehow you could just wrap up a lot of
views site decorations into the
decoration size so you won't have to
repeat it all the places where you would
probably use it and in it's basically
like it's a semantic simplification
because it's the syntax doesn't get much
simpler because you say in and out you
know it's not that different from ?
accents increase max super there is
value to that actually but we go on sir
yeah yeah I think it's really
interesting the distinction between new
materials on checks here and I'm not
quite sure if you could give a few more
words on how that would help you get the
computable joint okay so with computable
joins the question is so say a manager
in string what so what happens is if you
get rid of shape so you see these aren't
types anymore there are finite but you
can actually walk up and sort of get
there's a finite number of principal
instantiations of all prior classes so
you can say okay integer is also
serializable and swing is also
serializable so actually we might say
serializable if we had if you did that I
do it that way
but because there's no recursion anymore
that's taken out of the picture and this
was sort of a finite number of steps you
have to take and try it out try out and
then once you've done those steps you
get the answer so what's important is by
taking these out types there's no longer
recursion than the all in the process
there's any there's a shallow recursion
but not these infinite recursion any
more questions okay so now let's have
some fun this is break a bunch of things
so I don't have time to sort of go into
more thing about fixing these are
actually old results but we can have
some we can break some things and give
you some idea of what either we're
working on or have work done okay so
actually we'll start with the thing that
actually got me into this entire field
so I was teaching a class it's program
with programming language class where
they wouldn't learns a variety of
programming languages but the first
thing so what I wanted to do is have
them influence that ass at software and
they use that sovereign every language
to see that differently we just have
different pros and cons so I hadn't do
it in Java cuz there Eddie new Java and
so this students wrote this code they
said ok well sat solvers have these
variables as I'm solving those variables
get values at the end I have to figure
out what all the variables true pairs of
what are all the false variables so I
just gave an ad to method and said add
to the appropriate list right if your
true ads it screws if there's a dress up
for your files have yourselves a pulse
and so the way implement this method is
yes right depending on what value is the
value screw then for the truth list or
the fauces list at its add this variable
to that list this looks good right ok so
Java Java compiler rejects this and
you're like why this is like super
obviously true and according to the Java
like something like typing rules this is
correct and I saw my student obviously
is like what the hell's going on and I
came up talk to me and then we've looked
at this and so I dug through sort of the
documentation stuff not or like like a
pile of documentation
and what they do is they say well punch
mark super is really hard like so with
the material stuff that we did now this
becomes doable but before without that
stuff that is actually really really
hard to do ? super well and so whenever
they have the situation where they have
these sort of quick my colon these in
general can have different types right
one could be straining what could be an
injury antra got a way to combine those
types so they say well if you know this
type size ? super what's to ignore that
there is a treat is listed ? and so it
turns both of these into blister
question Mike which is sound try juice
for getting this extra information and
then Stan's okay obviously less of
question marks that's all this efficient
market then I try to add a variable to
this and this says well I don't know
what this ? is right it could be
anything it could be an injury and we're
like we'll know it's a variable so this
is fine so the material stuff actually
solves this problem but essentially to
see that they actually are examples
where decidability does affect people in
this case it was an easy fix you make an
if and your students to separate we
interest so the compiler isn't trying to
do a joint algorithm anymore but that
fixed is not always easy all right
another example what does this do like
well usually it's not integrative that
value have five it's like gimme an
integer from this list and this is
something that runs in happens in j unit
this is a certain equals ready to say
check out there the same test or the
same value my students have to write
this all the time anybody know what this
does yeah says it's ambiguous so rejects
this code and this as you said the two
situations are I can't tell whether it's
us to managers or two objects right
because integers have and plus it career
or because energy is could be converted
to objects through the wrapping and vice
versa whereas our teams compete are the
integers and integers and return the
ants and doesn't know which way I
supposed to do of course we know that
doesn't matter they're gonna get the
same answer anyway but it is a note head
so it's ambiguous okay make things worse
so here's okay I mean you actually
implement this but I'm doing laziness
playing in oil there so singleton here's
some craziness unfortunately you have to
simplify it so that fits on the slide so
doesn't make any sense understand that
this basically what's important is that
it's doing it's a generic method at just
as I need to comparable things and then
here a bunch of things that are just
overloading its right to say okay well
I'm what's the name what's the name of
the type of this value oh yeah anybody
know what this does okay what is having
fun now so anybody know what this does
so first is filling in the type
arguments right of saying well it's a
singleton of something i'll figure out
if something is so cool and then that's
going to be a few of something and i'll
figure what that something is and then
it gives you a surrogate and then return
some string guess is how about something
easy to take guesses nobody's willing
tickets all right well I'll jump to the
answer it returns the parable if it once
return string if it once returns and
everyone's leaving reprints calendar for
once even though there's no count or
anywhere in here it actually can say the
hey this is the calendar so what the
setup does actually says okay well type
argument inference is going to sort of
make guesses what these types are just
allowed to guess anything that makes
this type check and so depending on what
if there is hey this is should be this
type this would be this type and then
does a different overloading I thinking
what types of try it out so Java I
hadn't have you never seen a sight
before and asked you I forgot to ask you
before this this Java is does java
psychic or a pecker semantics and
probably everyone who said no but the
answer is yes how i would type texture
code would actually can change on your
code Reds all right another problem ok
so here we have singleton thought that
singleton was this listing again and
then we add five to it this is work this
job at I picked this you say no where do
you say yes everyone's like now very
scared to say anything ok so the answer
is yes java type here does i have a
handle this and the java specification
handles this as well what about this so
what about the specification was a
specification say
so according to spec this is valid right
because I can do for any type say this
is list of whatever I want so i could
say just a list of objects right I can
do that so same thing as I did appear
but it's high picker fails to do that
and the reason is that inference and
java and actually in c-sharp unless
these things uses the return type it
says well I know this must be a list of
objects so I'll use information to
figure out how to infer this but here I
took that information away I just you
know in line the variable but now that
type is gone and I can't figure that out
so it says well this is a string and I'm
just gonna use I has my guess and then
adds five David oh I guess I was wrong
crash when I crashed but like it ever
yeah so you can say rackets objects and
make it explicit if you want all right
so it's gradual typing you seen some
sense with this before the gradual
typing is the idea that you can make
things dynamic if you once okay so
there's an equals method from C sharp so
C sharp has dynamic and here's equals 0
0 what does this do in c-sharp Shi
program is here returning through or
false what do you think
so remember that objects has to wrap
things up right so it turns eros into
objects and then what does he think what
does it do French has reference equality
so you get the Francis well it depends
if it's residue caching and something
that so the answer is convened it with
their catches but nothing is as this
returns false ok now let's make things
dynamic right so all I've done is throw
a type of rooms i'm being lazy just do
the same thing you did before but now I
don't bother with types what does it do
Prince true so what happens is it says
well I'm going to use the right times
like this we'll figure what to do and
read time this is an integer so it can
use imagery quality because that's
overloaded in c-sharp and then figures
out that that's it those are equal all
right here's again ER that gives me a
tea here's by that you can be there get
you can get a string out of it or an
injury other depending which you once
here we say gather in sand you normally
this is more direct but right here in
this is equals new five and then this
Prince the integer we get always this
new is the obvious answer Prince back
well the number hide ok so now I make
things dynamic who has it you so now
it's being gradually tight so doing all
this at runtime
what returns 5 okay there's one vote I
gotta get lots of those so who says
returns five all right boots are this
word five sorry all right who says
everything's number five nobody run
everyone's like Ross is tricking yes I
know he's doing it something must have
you bet you could think about that but
actually what it does is it crashes it
says well hey there this thing is to get
methods I don't know which one they call
so I'm gonna crash um I gotta do one
really another quick example here's one
that's knocks on to a list right so it's
not just adds to the end of the list
well it makes a new lesson adds to end
of it where's Sokka 05 I get hello five
now have some naked dynamic any guesses
crash is correct anybody to go why no
okay what happens is the sample two
lists I don't that is I can't figure
that out you're like well worked before
why couldn't i forgot now oh it's an
extension method it uses the static type
information that compile time to figure
out what that for you should be okay
well let's just help that out okay so
you're supposed to you a numeral through
this room that we got rid of the
exception at it now was it
now you're like all scared of your
compilers and ok well the crashes so
what happens is to list is a generic
method and before we using it was using
or snack essentially was a generic
itself so if it out hey the common type
here is object but now we're doing this
all day namak League so it's a hey we'll
start as a list of strings so I'm just
going to guess or as an innumerable of
strings I was guess that should be
returning its list of strings and we can
see here and says oh that's adding it
let's add a number to it wait wait list
of strings can't do that crash okay so
to conclude even though this all still
being like done but we can exploit
commanding design right we can say
languages are hard to do everything is
undecidable everything has all these
crazy problems so let's like how people
use them right all these features are
useful but they're generally just done
in this one most directly possible which
is just too general right we're not
using the foolish residents of our
language so by analyzing how we use our
languages right how the human behavior
involves we can make up and we can come
up with solutions that both are
principled right there decidable things
like that or they don't have all that
crazy behavior you saw in the previous
slides and they're usable right they
because we analyze the behavior we're
gonna use them the way that you wanted
to and that's what I do so I think I'm
out of time yeah well we could take one
question it's fine if everyone's
exhausted
you considered applying your analysis to
a corpus of Scala code or a corpus of
Martin order skis code and well Scala so
I'm suiting it I'm trying to figure out
how to deal with like all the other
features it has so I do know that a
scholar researcher has a counterexample
because they're doing they're big what
they do is they have lists extend sort
of maybe actually there's how can you do
the practical example that comes up a
tree extends list of tree right a3 is
just a list of trees and that's
perfectly fine so that that's actually
the example that came up in the sailing
code and it's essentially the example
that came up and the Scala code as well
that we know of and so it's possible you
could say well the cases don't use this
the other option is disabled it's really
easy you just make three now the method
or I have a field at the list of tree
and you've lost some expressed with this
right you no longer have that
innumerable of tree is an innumerable
list of tree but you still have a fair
amount expressiveness so it's a question
of whether the trade-offs are worth it
and that's your choice is what's good is
that I don't make the choices hey I have
to argue really hard and I think
something's broken it needs to be fix
anything else I think we're just about
out of time so let's thank this week
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>