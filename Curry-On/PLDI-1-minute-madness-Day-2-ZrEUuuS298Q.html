<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>PLDI 1 minute madness (Day 2) | Coder Coacher - Coaching Coders</title><meta content="PLDI 1 minute madness (Day 2) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>PLDI 1 minute madness (Day 2)</b></h2><h5 class="post__date">2017-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZrEUuuS298Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is our second day of one-minute
speech so today we are going to have the
speaker PL di speaker for today and
tomorrow morning so once I can guarantee
you is that we have plenty of coffee and
cake outside so please stay so don't you
don't need to rush you off a piece of
cake okay so now let's start it hi
everyone I'm Jacob from UT Austin I'm
here to convince you to come to our talk
first thing this morning and now let me
take you out of the matrix and introduce
you to Morpheus our tool for automating
guy wrangling tasks and are on the right
side you can see the old world of doing
data programming where people spend 80
percent of their time doing tedious tray
table transformation tasks scientists
spend hours upon hours banging their
head against the keyboard just to make
their data readable if you wish to stay
in this old world take the blue pill
wake up in your bed and believe whatever
you want to believe however this isn't
the only world that's out there what if
I told you that such programs could be
synthesized for you in only a matter of
seconds if you wish to see how these
programs can be synthesized for you take
the red pill leave the matrix and come
to our talk this first thing this
morning thanks
okay so we live in a world now where
computer networks are increasingly
running more and more critical services
however at the same time every year
there are major network outages caused
by human miss configuration that can
create substantial disruptions in
people's everyday lives so for example
last year Southwest had to ground 2300
flights in the United States because a
router failure caused a large part of
their network to go down so in my talk
I'm going to describe how we can use
ideas from programming languages to try
to address this problem network
configuration and in particular I'm
going to talk about a new language and
synthesis tool which can take as input a
network-wide routing policy an abstract
apology and a collection of fault
tolerance requirements and then from
that synthesized low-level parameterised
distributed configuration templates for
off-the-shelf distributed routing
protocols and by using abstract networks
we can scale this type of configuration
synthesis to large networks hundreds of
times faster than existing tools and
also help incrementally deploy networks
over time thank
so CQ is a de facto language for
relational databases but today I'm not
talking about sicko and talk about how
to see at a sequel from in for example
to help you send you the psycho
programming our algorithm breaks down
the origin expensive search process in
your to face search algorithm we use a
notion of oxidation and be very encode
into a scale up algorithm we're able to
solve over 100 several secure post
within several seconds comment our talk
in signal check Thanks so computers do
all kinds of weird things to memory
operations like reordering them kind of
crazily and surprisingly to make things
go faster and the rules by which they do
this accord a memory consistency model
it turns out that formalizing one of
these models is a really Herculean task
so in my talk I'll tell you how to
synthesize automatically formal
specifications in memory consistency
from examples of the kinds of things a
process I can do and then I'll do one
better I'll also tell you how to
automatically disambiguate these
synthesized models to discover
ambiguities in the formal specifications
themselves so if you're interested in
synthesis you'll learn how we can
synthesize formal specifications but
themselves contain quantifiers if you
interested in memory consistency you'll
learn how we can automatically
synthesize a new kind of formal
specification and regardless is what
you're interested in I'll tell you why
there's a cat on the slide hope to see
them
hi
Paul gizelle oh I'm going to be
presenting decomposition instead of self
composition for proving the absence of
timing channels software has secrets and
like passwords and with side channels an
attacker can find these secrets
indirectly by exploiting running time so
what we want is a static analysis where
we can see whether these vulnerabilities
exist or not but this is a hard problem
because we have to reason about multiple
executions of the program at the same
time what we have is a reframing of this
problem so that we can use a non
relational analysis that only has to
reason about individual traces to prove
this prove whether an attack exists or
not so come to the talk it's the first
talk of the day and our master we have
algorithms cool security problems and
formalism and a tool
hi everyone I'm keeping and I will tell
you about automatic programming version
using symbolic transducers we build a
two genic which is based on the theory
of symbolic transducer and syntax
guidances Jenny can invert programs such
as screen encoders and decoders for
encoding schemes you place it slow and
UTF my talks in the next section and
please come to my talk if you want to
know how Jenny quacks thank you hi I'm
Peter and I'm here to tell you sadly
your application is crashed and worse
it's crashed in production so you
probably have a lot of questions about
what happened come see our talk in the
next section where I'll talk about how
we answer user questions over failure
reports using ideas from symbolic
visibly pushdown automata and sub
regular languages we answer questions
via tama da intersection emptiness we're
able to answer these questions over
programs up to two hundred thousand
lines and failure reports with thirteen
thousand elements if you want to hear
more stop by in the first section
all right cache attacks are able to
break Crypt implementations by
exploiting differences in the execution
time that are due to the use of the CPU
cache and multiple such attacks have
been shown in all the top security
conferences right now recently so some
are widely used countermeasures have
relied on techniques such as for example
storing data in some special layout to
ensure that when we are doing secret
dependent data accesses the same
sequence of cache lines is being
accessed or making sure that our secret
dependent control flow is slow as small
enough that it all fits into a single
cache line all right so the security of
such code can be quite brittle depends
on some details such as the hardware
architecture and the compiler so how can
we establish the security of such
countermeasures come to my talk at 1205
in all the master and I'll show you
I am Victor and I'm going to talk about
how can we synthesize parallel programs
from simple sequential implementation so
look with dependencies and if we just
divide a loop can we find on how can we
find the merge or join operation to
recompute the total result from the
virtual results and if this joint
doesn't exist how can we automatically
find an extension of the loop so we can
actually paralyze this loop so please
come to my talk today this afternoon
first token polarization and concurrency
it is a commonly held belief that
functional languages while expressive
and safe inherently slow well they don't
have to be we've constructed futhark
a purely functional parallel array
language that has been carefully
designed to enable the creation of an
aggressively optimizing compiler that
can generate GPU code using the high
level invariance provided by a
functional language the compiler can do
regressive rewrites like joining nested
parallelism into efficient flat
parallelism on a set of a dozen
benchmarks the compiler can generate
code that is competitive with hand
written GPU code so come to my talk and
see how that works out
hey polarization of software is
important for improving his productivity
I will present grasp as an automated
synthesis procedure to generate this
parallel code based on the sequential
implementation grassed considers three
polarization scenarios and it walks
through it gradually because it wants to
group once to deliver the seed simple
solution as soon as possible importantly
grass has a certification to make sure
that the solution is good for any input
our experimentation boss on the laptop
another huddle shows the great
performance go for more details from our
talk hi I'm Colin I'm going to talk in
the concurrency and parallelism session
this afternoon about verifying
invariants lock free data structures
because they're still hard to get right
and we have a lot of new tools over the
past few years for verifying them but
for many of those they're no longer
compatible with unverified code you
either need to pay performance overhead
or just drop them in and hope for the
best so I'm going to talk about a way to
enforce invariants 1 and Tuesday
invariance that control mutation in a
way that's compatible with unverified
code and has correspondingly
intermediate proof for something in
between what you get from a basic type
system or a full-blown program logic so
if you want to hear about how this works
in a lightweight coq DSL or liquid
haskell library or if you want to hear
about cool data structures like a lock
for a union-find implementation come to
my talk this afternoon
in 1992 Andrew Appel who was sitting
there before he went to get cake
well this amazing book TL DR it said if
you're building a compiler you should
use continuation housing style as you
want immediate language so I had a bit
of Indian fury writing complex about
this was jig see my co-pilot Haskell
used direct style so it was really good
when Andrew a comic Flannigan who is
also sitting here wrote a paper that
said no you don't need that CPS stuff
but then it turned out that Andrew
Kennedy my colleague wrote a paper that
said yes you do after all so this paper
is the knockout punch in that little
interchange in which I show how you can
use a direct style compiler but still by
adding join points get all the joy of
continuation passing style and in an
intermediate representation without the
pain of turning your life inside out to
use CPS
two o'clock right after lunch it's a
hard act to follow so this talk is
actually related it's about mixing
high-level and low-level languages and
you might be interested in this if
you're interested in verifying
just-in-time compilers because if you
think about what a JIT does is it takes
some high-level program and then
replaces parts of it with low-level code
and so if you want to know that that's
correct you need to know that the
original program is equivalent to that
mixed resulting program and this is
challenging because the control flow
between high-level code and low-level
code is very different you end up with
continuation style low-level indirect
style in the high level and so what we
show in this paper is how you can mix
high level code with low-level code
that's a high level functional language
in a type assembly language in such a
way that you can ensure safety and also
prove equivalence Thanks hi so sequel is
a language that is virtually supported
by all relational database systems yet
trying to come up with a semantics for
the language such that it can be easily
used in mechanized proofs turns out to
be difficult so in this work we propose
a new semantics for sequel that is based
on homotopy type theory a hot spot short
using this new semantics we have
implemented this semantics called hot
sequel on top of the on top of the hot
library and also using the proof
assistant and we have used it to prove a
number of new sequences that arise from
the new world from the real world and
haven't been actually proven correct
before using only a few tens of lines of
 code so if you want to learn more
about why hot is so hot or simply try to
understand how we transform type theory
into reasoning about relations come to
my talk this afternoon and I'll tell you
more thank you
everyone on this afternoon I'm going to
talk a little bit about levity
polymorphism so in that talk we're going
to consider the detention between the
beautiful structure of polymorphism and
the raw power of performance in in
coming up with a new way to write
polymorphic code that is that is that is
performant and convenient to write so
this is through a new form of
quantification essentially quantifying
over a calling convention but it turns
out we can't always do this so you'll
see this afternoon why we can't and yet
using this technique we can generalize
almost half of the standard library in
ghz s ghz standard library distributed
with haskell so come to the talk this
afternoon at 3:15 hello everyone I'm oli
I'll speak afternoon about this paper
repelling sequential consistency in C
C++ 11 and we all think I guess that
sequentially consistent memory accesses
are simple well this is not the case in
the weak memory settings when you have
multiple accesses of different sorts to
the same location and in fact we found
out that the c c++ 11 SC accesses are
walking in the sense that there are
programs for which if you compile the
program on run on hardware
you might get behaviors that are not
allowed by the specification in the
topless afternoon I will show what
exactly went wrong and how we propose to
fix it Thanks
hello my top discipline I'm going to
talk about the problem with undefined
behavior in all game and introduce our
semantics introduce our new solution to
the problem so I'm sorry if there are
many companies compilation errors in the
LLVM and also we reported this
compilation error to the LVN but there's
no way currently there's no wait for
LLVM to fix it so maybe we supposed a
new element we suppose anyone define
various amenities which is simpler and
also fixes the previous inconsistency
thank you
my name is Timothy burg what you see
there is a screenshot from the ancestral
technology skate tool which is routinely
used to program safety critical software
like the fly-by-wire controller in the
Airbus a340 which you can see on that
slide the underneath underneath skate as
an academic language called loosed what
we did was implement a compiler for
loose
basically you put your data flow
programs in one end of the pipeline and
it goes through all of those pipes and
then we've integrated the concert C
compiler which produces assembly code
for x86 PowerPC or arm what's special
about our compiler is that we specified
it and proved it correct in the proof
assistant so please come this afternoon
if you'd like to hear more about loose
it's compilation and the proof I promise
there will be more source code than
Greek thank
hey well I guess a lot of us here in my
know about si T or s NTS over but today
I'm not going to talk about that today
I'm going to talk to tell you about
another kind of saga it is about strings
over and our strings over can be built
on the top of snps over and what else I
mean what I knew thinking about our
strings over so in our work we proposed
a new framework for fostering sober and
I was doing sober is able to handle risk
Rite of Spring countries for example
context-free grammar and transients and
so on
and our work based on the bygones as
beyond sigue it is a cultural cut region
poor guy to attract refinement it has a
thing about our work at is we have a
tool based on the framework and our a
natural perform better than
state-of-the-art if you want to know
more about our hours over so come to my
tozi at half past four thank you
want to implement a new programming
language that's as fast as today's Chava
and JavaScript you can I hire a dozen
compiler in GT experts or you can use
our framework we know since 1971 that
partial evaluation of an interpreter
gives you compiled code but in the talk
tomorrow we'll show you how it's
practical and feasible today and as a
bonus you also get debugger and a
profiler for free and if you wanted in
that book come to our tutorial on the
grind compiler Friday morning thank you
hi I'm Stefan Muller and I want to tell
you about a separation that exists in
the design space of threaded programs on
the one hand we have competitive
threading models like P threads that try
to gain the maximum responsiveness and
interactive systems on the other hand we
have cooperative threading models as
exists in some languages for
high-performance computing which try to
maximize throughput in large
computations these languages have
high-level abstractions for parallelism
and elegant provable cost bounds but
they have no way of reasoning about
responsiveness or even interaction and
we believe this makes the models
incomplete if you can't reason about the
interactive programs that people use
every day so come to my talk tomorrow
morning where we'll begin to tear down
this wall I'll provide a cost model that
allows programmers to reason about both
the throughput and the responsiveness of
parallel interactive programs a modal
type system that guarantees
responsiveness and interactive programs
an implementation and a bunch of cool
benchmarks here's this title slide again
and hope see you tomorrow morning
hello I'm Konstantinos memores and my
talk is going to be about stream query a
language for modular specification and
efficient evaluation of qualitative
queries over streaming data in
particular we propose a language with a
small and expressive set of core
abstractions that combines regular
expressions quantitative aggregation
streaming composition and relational
features such as key base partitioning
our language has a formal mathematical
semantics in terms of partial functions
on stream histories we also show that a
high-level query can be compiled into an
efficient streaming algorithm with
precise guarantees on space footprint
and processing time per element and the
good performance of stream query has
also been validated experimentally by
comparison with other popular streaming
engines on practical workloads so if you
want to hear more about this work please
come tomorrow morning to my talk
thank you ok thank you so that's the end
of the 1 minute speech
so the carrion session starts now and
the PRD ipalo session starts from 10:50
and we have coffee and cakes outside
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>