<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Andrey Breslav - Kotlin: Challenges in language design - Curry On | Coder Coacher - Coaching Coders</title><meta content="Andrey Breslav - Kotlin: Challenges in language design - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Andrey Breslav - Kotlin: Challenges in language design - Curry On</b></h2><h5 class="post__date">2015-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zVZFv80l_lQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">when we started this project 12 years
ago it was our meetings or business to
have them more productive tool more when
I took the job because we realize that
we have very many lines of code in Java
all we are stuck with as programmers is
Java for making our tools so we're
looking for a better language we looked
around we didn't find anything with that
suited our needs I'm not going into
details now and we figured that yeah
it's time to make the language that well
suit our needs because our needs are
very similar to others other people
needs so it's a motor language on the
Java platform and on the JavaScript
platform as it come now comes along and
the target audience is you everybody
it's a general-purpose language so you
can use it yeah I can actually show you
a slide in that so we're yeah so the
first thing is that you can compile
Colin to java bytecode and run on
android or on the server or on the
desktop of course so and actually to die
it's getting traction on Android so
people are making mobile applications
with Colin lot also of course there are
web applications written Colin and we as
a company use it more and more for our
like web based browser based project and
the other track will be compile to
JavaScript run a note or in the browser
and also if you connect the two at the
bottom you can run your java code java
java colin code on the JVM in the server
and your government Jas code in the
client and that you can talk to each
other and it will be the same language
and the same strictly type language
which many people would actually like so
I'm sorry for so um that's the
introduction because I was lost without
my slides I can talk without slides you
know so anyway this
not intended to be a real introduction
for the language please refer to to the
website the only take away from from
here is that it's a good one and it's
open source so you can actually dig into
implementation and send us a patch if
you like so if you're curious about the
particular language features go ahead
and check out the website you can even
play with language in the browser so we
have like a small web base IDE there
just to name a few things that there is
a list for extension functions builders
primary constructors delegated
properties other words I'm not going to
explain tonight and we are proceeding to
the first challenge so I'm here to talk
about things that are maybe a little bit
out of the traditional focus of people
who are thinking about languages and the
first thing is that whenever you think
of an implementation of a programming
language most people think compilers
right so to implement a language means
to make a compiler but as gilad
mentioned and they previous session
today's people want a little more or
rather a lot more than just a compiler
people need a whole tool chain and a big
part of it is the integrated environment
and there is a thing about compilers
integrated environments because the the
compiler is like a very narrowly
targeted tool it's trained to do a
single thing very well it takes a bunch
of code and it spits out a bunch of
whatever class files or something else
the ID on the other hand is very
different it's something that can help
you in very many ways right and it can
help you navigate analyze your code find
your or restructure your code refactor
so on so forth so and when you build a
compiler and the ID alongside each other
it turns out that you definitely want to
reuse a lot of code because you have
very complex logic in your compiler
front end
you have you your compiler knows how to
unload analyze code but can you actually
reuse this code in the ID they said this
is a challenge because if you think of
what ID is dual here are three crucial
point that ID is actually use and the
compilers don't care about so the idea
when you open a file you have it
highlighted but not only like with your
keywords and stuff but also all the
errors in everything right so and
whenever you see a name there it says
foo right you can control click on that
name and get to the declaration for this
name right so this is something
compilers kind of do but in a different
manner they don't care for it like one
identifier somewhere they just do it for
the whole project of millions lines of
code so one thing Heidi does is
navigation and then there was reversed
navigation with that's called find
usages when you have a declaration
already I want to know where it's used
in your project and this is something
compilers don't care about it all or
unless they do some specific
optimizations and then of course IDs
highlight files so it takes a single
file and analyzes it compilers don't do
that they only take the whole project
most of the time so I'll explain one
thing of these three how it works which
is find usages just give you a taste of
how a compiler is different from the ID
so find usages is like the most
controversial of the three so I have a
symbol that foo on the left it may be
whatever a class a function does matter
something that can be referred to in
your program and I asked my ID please
show me all the usages of this foo in
the project first of all there can be
other foods right so this can be an
overloaded function other packages may
have the class with the same short name
so and so forth so it can I simply grab
for all foods in the project and show
the list right so what would you
really need to do is recognize which few
names refer to the actual one so one way
of doing that is just analyze the whole
project take every food there and check
if it refers to the original declaration
right but it has this you know tricky
point of analyzing the whole project
it's something you don't want to do
because the whole project maybe like
millions lines of code and you'll wait
for a very long time while it's
analyzing so one an ID does at least
IntelliJ IDs do that or JetBrains IDs it
keeps a word index which means that all
the files are not entirely analyzed they
are just processed with a lexical
analyzer all the identifier czar
recognized and stored in a kind of a
database and index so you instead of
like grabbing literally through all the
files you pre-computer all that you
asked the word in X please tell me which
files in the project have the name foo
mentioned anywhere like it may be
anywhere where it's code any name of the
code can be a type a function reference
anything so give me the files that have
foo and then for every occurrence it's
not the whole file it's just the place
in the file the particular name that is
their resolve that name and check if it
refers to the declaration I had right so
this is something compilers don't really
do take a file and a single identifier
in the middle of the file and do as
little work as possible to resolve that
name correctly so this is something a
compiler doesn't do ever and now what I
want to do is write a single piece of
code in my type checker for example for
it to work for the compiler which takes
the whole file or the whole project and
compiles it and for this case where it
needs to take one reference in the
middle of the huge code base and resolve
it so it's a huge controversy about how
you design the algorithms around your
language it's not about not even about
the particular language design
it's about how you structure your
implementation your algorithms to
address both the challenge of the
compilation and the challenge of the
interactive responsive ID questions here
great okay so the word index is the
radiance is the database that lists
which words are are mentioned in which
files so it's updated every time any
file has changed or if I was added to
the project so in the idea when you when
you open a project for the first time it
will be indexing the whole thing for
some time before I can't do anything
because it has to scan everything but
it's a quick analysis so it does not
analyze types or even resolve names
nothing there more questions yep
yeah so the question is why not just
resolve everything once and then use the
like resolve database for that thing is
that whenever you change any declaration
your program that resolve database is
invalidated a lot of it well actually
there are different approaches to this
like for example in eclipse which runs
on an incremental compiler they kind of
use this a very well a very particular
version of this so you can do this like
a resolve cash and invalidate parts of
it when your declarations change and
this is one way of doing this it's a
very complicated way another way a lot
simpler one is to make your resolve so
fast that you don't have to do that more
questions okay then so this was another
challenge like challenge about how you
think about your language
implementations or language algorithms
so next one will be about language
design already and yeah we'll be talking
about nulls yeah kind of I'll tell you
about it so thing is that things may not
be there you know and there is big fuss
about how you deal with things that are
not there and java has taken this for
example is that when you say that
something is a string it's not
necessarily string maybe a string or a
no right and nevertheless you can call a
method that's something and sometimes it
breaks obviously this is the way to go
I'm not saying it's bad it has its
implications so you probably know that
null pointer exceptions are one of the
most frequent errors in Java programs
which is not surprising so in common
we're trying to tackle this and make
something more typesafe so in common
when you say that something is a string
it has to be a string so when you're
trying to assign a null to something
typed as a string you're not allowed to
do that on the other hand you can't
safely do reference this variable and be
sure that it doesn't break now when you
want a null an absent string you have to
designate that and the type so this
string ? is a type which is a string or
null nullable string I would call that
noble types so in Colin the type system
tracks your absent object and lets you
know that when you're trying to
reference something which is knowable
you're not allowed to do that right away
without a check because it may break so
it gives you an error at compile-time
questions here tribulus all right now if
you think about it if something is not
able you cannot reference it but then
what you can you make of it right so the
language has some devices for dealing
with knobs in a convenient way so the
best device for that is the conditional
operator so when I have my novel string
I can check that it does not know and
then I'm allowed to reference it safely
so the compiler knows that if you have
checked that this is not know the type
of the variable is kind of different now
and we have something called smart casts
this is having behind the scenes here so
the compiler knows that now this s dot
length is a safe checked Cole so it will
not complain it's even clever enough to
see that if you have broken your control
flow somewhere like if you check for now
and return from the method on the next
line this s is guaranteed not to be no
so it will be fine to reference so first
thing for very many complex safety
features is
have a smart compiler so we have one
then of course it's in many use cases
you want something not as half as and if
so there are some specific devices for
managing nulls in the language so the
first one which is ? dot it's called a
safe call operator which means that if
the left-hand side is a null do nothing
the the expression will evaluate to null
if s is null and if the left-hand side
is ok you just call the method and get
the result then the next one is
something interesting it's double !
operator which yeah go ahead yeah it
will be a nullable integer yeah integer
or no yeah the next thing is a double
Bank operator which says if s is null do
what throw an exception so this is kind
of like Java but explicitly you say I
want an exception here if it is no and
when you're looking at the code and your
stack price you get a clear designation
of where this null pointer comes from
and the last one is called Elvis
operator by the groovy people who
introduced this so we just borrowed this
index from them and it basically gives
the default value to a novel ok so we
have a bunch of devices that plays
playing nicely with nose and the
takeaway from this part of the talk is
that colin is good with nolles ok so if
you remember nothing else remember this
go ahead
yes but it does work people need that
before come again please uh-huh oh yeah
so so if you or say allocate an array of
fixed length that has to contain strings
I have to give a the allocator function
that initializes every cell in the ring
okay so cuddling is good with note isn't
it but now Collins interoperable with
Java right so the thing is that whenever
you write a program in Kotlin for the
JVM you can use any java library and
your java code can call Colin so it's
interoperable both ways and actually
doesn't have to be a library you can
just write a Java file next to a column
file and reference both ways so colin is
good with knobs but Java isn't right so
whenever I'm calling in Java library the
common compiler has to think a little
like here's the Java declaration it the
function returns a string and now what
do you mean a string is it a nullable
string or not null string and the same
function takes a list of strength so is
it a like list of string a list of
notable strings a notable list of
strings or a nullable list of nullable
strings so that's a question and the
java java class doesn't give you any
information of that they have no idea
when Colin compiler looks at the Java
class there is no way to know which one
of those is mint so like the type safe
language designers intuition here will
be decide ok we go the safest way
anything can be no in Java right so
we're taking notable string of the left
and the knowable list of novel strings
on the right because anything can be no
and yeah this is the safest way let's
try to work with it this is actually
where we started a few years ago
so yeah whenever you use anything from
Java now the dot is not your way because
this Java value can be null the to
string your call on that Java value can
be known and so there you are you have
to guard every reference you have this
doesn't happen with the kaplan because
with caitlin you have your non null
types and everything is getting safe but
with Java you have no information so the
best you can get is something like this
like safe call for every dot and then to
use a plus that there is no safe call
for an infix operation so you have to
put in double bank there to add two
numbers I don't like that but okay but
you can one can argue that this may be a
price you're willing to pay a second
this may be a price you're willing to
pay for type safety like you're
guaranteed not a half null pointer
exceptions and this may be the burden
you might want to carry along but there
will be another thing after I answer the
question go ahead
well we could only have notable types
for everything but then what would be
the point of like okay that what would
be the type of double bang operator for
example like if we just replace all the
dots in the program by ? dots it doesn't
change anything just the program
sometimes doesn't drawn because
something was not somewhere right and
also when you very often you require a
value assembler somewhere some algorithm
cannot work without a value so the only
way will be to like have the question
mark not semantics that if you don't
have a value the algorithm doesn't run
so instead of a nullpointerexception
you'd have like a stalled program
somewhere because can progress okay yeah
so coming back so this line is not so
bad it's bad but it's not so busy maybe
willing to pay this price for type
safety but then there's another problem
like the list I want a list of string
Kotlin and I want to get it from Java so
what Java returns me remember is
knowable list of noble strings right so
okay I can get rid of the outer most
null with the double bingo pre right it
will be a list of nullable strings but
list of noble strings is not a list of
string you cannot assign a list of
malleable strings to a list of string
here so you're stuck there is no way no
nice operator in catalan and no nice
operator i can think about that could
mitigate this problem so thing is that
this ? here is stuck forever and if
there is even no way to properly fail at
runtime if the actual list contains a
null because you don't know how to
inspect it go ahead yeah you could and
this is inherently very slow right at
least and also a list is a very nice
structure it's a sequence of elements
but some food generic class can be
anything like I might not even know as a
human how to inspect whether it's it
contains nullable string as an argument
or not so take away from here is that
the safest option doesn't work you're
you just get stuck there that's it so we
for quite some time we've tried to fight
this with annotations so try to annotate
Java code with not null here and there
to get some type safety into the Java
language so basically those annotations
help you rule out some of the cases but
again java before eight I think android
doesn't have type annotations so I
cannot annotate the string inside the
list and annotations are cumbersome to
work with and sometimes you don't have
control over code so i have a binary
library and you need to attach the
annotation somewhere from the outside
and then it gets lots of configuration
issues so on so forth so the annotation
why is difficult and doesn't really help
so we we actually struggled with this
for quite some time we tried to make
this approach work because it seems
pretty you know type safe and we wanted
this but then we had to face it so among
the three options here not safety
convenience and java interpreter lady
apparently you have to pick two sorry so
since we cannot double-cross Java and
drop and there is no point in
double-crossing convenience just sing
we're double crossing the safety part
good yes
well disclaimer I'm not very familiar
with the developments you were talking
about but yes yes but just step back so
then none all annotations I mentioned
before are the contracts somehow these
are the contracts on the methods and
what we tried was for example to infer
them automatically inspecting the
bytecode and trying to infer those
contracts automatically so thing there
is that you can't do that it's not very
fast so if you try to automate these
things these are all flying algorithms
you don't do that in the compiler
without carrying huge artifacts along
with your libraries and users may not
want or have the scale or the time to
analyze their libraries they're using so
it's not smooth in drop so if I have to
manually or Adam automatically annotate
a huge amount of code to interrupt with
it nicely and the other option is
terrible this is not a practical way to
go
ok
okay so yeah so thing is yeah so this
inherently complicates the interface so
the experience we would like to deliver
is that you plug in a Java library
networks so on top of the approach i
will be presented in a second you can do
what you're talking about this is
something we're working with at the
moment but we wanted by default to
require zero thinking on the user side
so when you switch from Java to coddling
I wanted to be transparent and require
no interaction on the interface so an
interface must be as transparent as
possible so if I have to specify
something there it's a lot of work
because the library i'm using can be
huge and the user doesn't know what's
the particular semantics in the library
so they don't have even the
qualification to properly annotate on
the interface like properly specify
things on the interface so this we can
take the rest video offline I'm sorry I
don't have enough time to yeah exactly
yeah yeah
yeah sure yeah thank you so what we're
so this is where academia comes in
actually because with the help of some
professor from Cornell or AA state we
developed something very close in this
spirit to radial typing which we call
platform types in Colin and I'll give
you a little taste of what it is like
without any calculus because Phil will
catch me on it every error and make it
so the idea behind platform types is
that you have to admit that you don't
know whether it's not able in writing
Java so when we see a string in Java we
say okay it's a platform string we have
no idea whether it's Noble or not so we
the notation is the exclamation mark at
the end and you cannot use that in the
language actually so whenever we see the
generic type it's a platform bar of
platform strings i'm not using
collections here because collections are
complicated i'm probably not going to
have time to present you of the thing
about collections but the Justice short
note the collections in Kotlin are
divided into read-only interface
immutable ones and they are not divided
so in Java so we doing lots of compiler
magic there and whenever we see a
collection in Java it's actually a
platform collection which says I don't
know whether it's mutable or not and I
don't know whether it's Noble or not so
here I gave up in my list and use bar
because bar is fine a simple and
collection is not so yeah so the
representation is like confess to the
user and to yourself that this is a
platform type you don't know whether
it's not all or not so on the user side
it means that whenever you have a proper
string you can reference it and you get
a warning whenever you're trying to
treat it as a null so if you make a safe
goal it's a warning with a nullable
string you cannot the reference and safe
call and double ! are legitimate
contracts constructs for the platform
string you came to reference it's
risky it may break but it it's what you
expect from Java write Java brakes on to
referencing objects it's okay so and the
novel devices are also applicable here
so pretty straightforward isn't it now
assign ability rules normal Kotlin
allows you to assign a string to noble
string but not vice versa right because
this may contain a null which is not in
that type now with a platform string it
is assignable from both of those which
obviously may break when you try to
assign a platform string which is
actually no to a string which is not
supposed to be not so there is Iran time
check emitted that will break if you
mess things up and unfortunately this
makes assign ability relation in the
language non transitive so there is a
way around this error arrow which can
lead to an error a runtime error which
makes there's a non transitive relation
because you cannot assign a nullable
string tostring directly but it can't do
it through Java which is the way the
world works actually it yes you get an
oppo interception at the point of the
assignment so this is yeah
no no when you have a list of strings
and you assign it to ya thank you this
only works of course on the simple sorry
yeah the null pointers only work on the
values themselves so the condensed of
the list will not be checked and will
well break where java generics break on
any type unsafe operation so at the
point of getting an element from a list
and putting it into a non-null variable
so this is very much how we raise
generics work ok so if you note on this
first of all platform types are not de
notable into language you cannot declare
something to be applied from string so
the string ! is just notation not the
syntax in the language which means that
pure cotton is null safe as safe as it
was when we're trying to impose null
safety upon Java so we deliberately
decided to lose null safety when it
comes to Java interop but we want to
save it for the pure cotton code then
Calvin plus Java this is just an
observation when you interact with Java
you're as safe as Java sorry if you are
interacting with the untrusted entity
your s trustworthy has the entity right
so we're as safe as Java there
annotations still work and this is a
part of the conversation we're having
earlier so you can still specify
contracts even more complicated
contracts than just not know and this
will turn the platform types into proper
common types and give you some extra
type safety but this is voluntary so you
can basically you can plug the
annotations out of the system and all
the code that used to compile with
annotations will compile without them
and this is the deliberate design goal
and yeah also when you think javascript
javascript is even more unsafe than Java
because when you're talking to you about
types in Java Script it's like why
you're talking about what kind of types
are there in the JavaScript code there
are types
one time but no types in the code so
basically for JavaScript there is one
platform type called dynamic and and you
can do anything with it and so the
machinery the calculus and the semantics
behind it are the same as for platform
types basically a platform type is a
range from a string to an audible string
and dynamic is arranged from nothing to
anything so this is how you reuse these
things it's uh yeah oh that's this is a
very big question which I cannot
actually answer off the top of my head
so the the answer is it's complicated
and most of the time I think it's
undefined but I'm not sure so summarize
we had to pay quite a bit we added extra
complexity to this type system so the
whole platform types machinery is an
involved part of the compiler we had to
sacrifice oh we did that to actually
make our language less safe on the
boundary when Java comes in but is
benefit we got smooth in drop so when
when people start using cosmin with java
libraries they don't know about platform
types and they don't notice them until
they need it and of course you usually
need these things when something breaks
but it seems to be there with the right
trade-off here because it's easy for the
users and ninety percent of the case is
very intuitive to use sometimes it's
complicated but it's inherently
complicated there any questions at this
point yeah go ahead
ah
oh yeah so basically in Catalan you have
pretty clear boundaries between the like
in drop and the pure cotton coat because
at the method boundary you have to
declare types and platform types are not
de notable so so this is almost true so
the parameter types have to be written
down actually and the return type can be
inferred from Java so the platform tab
can go into there but basically if you
specify all your types at the boundary
you have to deal with the platform
nature somehow otherwise it will break
when you access this so so the answer is
with simple values totally yes with
collections you can have discipline to
do that with other generic types you
have to devise your own discipline for
every type because if you have a foo of
tea in Java you not necessarily have a
way of checking if the tea inside is
nullable or not and even breaking at the
right time so you have to devise your
own way of you know making sure and this
is something I don't know how to explain
easily to the compiler
yeah yeah there is a way to make sure
that there are no platform types behind
some boundary that's right but with
generics you can get even proper cuddlin
types break because the proper check
wasn't made behind the boundary
yeah so this is something that happens
very often so when you define something
in Catalan it's a proper coddling class
so it used to have all the null safety
information when you give it to Java and
get it back it doesn't have those
platform types all over all of its
methods right so if it had a method that
was returning say string it still
returns string right but the value
itself is not known to be null or not
now the same thing with the generic
argument so if I make a mutable list of
strings and cuddlin give it to java java
could have put a null into that list so
i cannot guard for that
yeah let me see so first of all for for
a generic class coming from Java I
cannot generate the code because i don't
know how i say i had a box of tea in
java how do i write the code that makes
sure that the tea is not null there I
don't know the semantics of the box
support for a list i do for box i don't
so this is one thing and then again so
this is something we can do for can do
sometimes and that's what we're doing
with the annotations when we are either
inferring them from the java site not to
burden the user with declaring thing or
can ask the user to declare something
and it will be automatic but this works
only for simple values where I know how
to check if the it is now or not in
break because otherwise i can get an
unsafe null from there and yeah if
something particular but not so I me I
see okay so what i get when i have a box
of tea i could wrap it at wrong time and
an object that checks all the results of
all the methods and breaks appropriately
this is a way to go theoretically there
are Calvin's to this because first of
all it breaks your quality when you wrap
something and on the JVM you get a
different identity for the object and if
somebody uses identity equals it's
broken one thing and then it's
potentially a lot of wrapping a lot of
memory so we're not willing to sacrifice
this yeah I'm sorry I just have this as
many objects as you transfer between
Java and cottman so it can be a lot if
you interact a lot
oh it can be well I can easily imagine
application fifty percent of memory
traffic of which would be this wrapping
easily it's like so in Java we have this
boxing of primitives no no no oh alright
yeah yeah sure sure so thank you very
much for your attention here and if you
have any questions even if you're not
Phil just approached me in the career
and i'll be happy to talk to you thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>