<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Alex Muscar - Pyro: Typing Python in Python - Curry On | Coder Coacher - Coaching Coders</title><meta content="Alex Muscar - Pyro: Typing Python in Python - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Alex Muscar - Pyro: Typing Python in Python - Curry On</b></h2><h5 class="post__date">2015-07-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TBTbW5DuSK4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone I'm Alex and today I'm
going to tell you about the project I've
been working on recently it's basically
a type checker for Python written in
Python um it used to be called pyro but
not anymore because someone in the
Python community pointed out viral is
already taken so now it's quite and ash
okay sorry about that okay it's called
fight sandesh I'm not going to tell you
why right now but it's going to be
obvious by the end of the presentation
so first of all I'm a software engineer
at least and I'm also a language geek so
that gives you plenty of reasons to ask
me questions I'm going to do some
geeking later on so what's this list is
basically a fashion navigator it's kind
of an Amazon of fashion and this loves
Python basically because the founder
loved Python now five years later we
have 350 k lines of it and we have
around 30 engineers making sure that
those lines don't break and it's not as
easy as it sounds because python is nice
and cute when you start prototyping your
system and you can get out to type in
one weekend but five years later is not
going to be all fun and games because
basically when you just refactor
something you have to be sure that you
didn't touch the bad method or that you
didn't change all the parameters so it's
not that much fun basically we do around
five to ten deploys a day and basically
we optimized for a fast deploy time not
because we want to be like super agile
but because we have to fix stuff right
so when you deploy something it's not a
Mallory of not breaking it it's a matter
of finding out as fast as you can that
you broke it and fixing it so that's why
we optimized for fast deploys
and I personally have a strategy which
is called deploy and pray so one
important detail is that our deployed
process involves a deployed token which
is Rainbow Dash right so whoever wants
to do a deploy has to get the hold of a
plushie of Rainbow Dash and then you can
do the deploy this is a very important
detail so we also have some static
checks in place well if you can call
pilot and placate static checkers
because they're very superficial and
also a lot of monitoring so basically
when stuff goes wrong and it will go
wrong you get a lot of emails you know
that you broke something so that helps
us keep the site running and our earth
looks something like this and if you
look at them you'll see that they are
all quite type related that's because
python has a latent type system which
means that it only detects stuff at
runtime which is fun because by runtime
your stuff is on the server people can
reach it they can break it and I find
the last error the one which takes five
arguments five given really interesting
so you have to deal with stuff like that
all the time okay i already mentioned my
policy i'm not sure if it smartly
repeated so when i came to this company
i was just finishing my PhD and i said
okay this sucks just rewrite it but it's
it doesn't work like that in the real
world you can't just go around to
writing three hundred and fifty thousand
lines of code i don't know why but they
didn't let me so being a language think
i said okay i'll write a type checker
how hard can it be famous last words so
i had to set up some goals for my type
checker given that we are used in python
too we can't use any type annotations
because python to just doesn't have them
so it means I'm gonna have to do global
type inference which is hard it should
also allow idiomatic code because our
Python developers want to either code in
a certain way so it should allow those
code patterns and also if you have good
air
msgs not like these types don't match go
figure out where it's gone wrong so it
should point out the earth fairly nicely
before i go any further yes i heard of
my pie my pie is another question static
type checker and guido the guy who
invented python decided to integrate it
in python 3.5 but once again we're using
python too so no j for us and also
python is multi structural has most your
structural type system so how many of
you come from iraq from an academic
background okay are you familiar with
structural type in dec sorry for that
are you familiar with structural typing
versus nominal typing do I have to
explain what that is come okay cool so
it mostly boils down to a simple
question I have two types I have foo and
bar they both have a method called em
and then i instantiate them the question
is do o 1 and 0 to have the same type
now if we had any academics in the
audience it's a very hand wavy
definition of same okay so do they have
the same type well uh nominal type
system would say no because they have
different names right one is food the
other is bar they don't match that's
what T sharp Java C++ and other
mainstream languages use a structural
type system would say well they look
kind of the same so okay they have the
same type now this is really interesting
when you're dealing with methods right
let's say I have those two objects and
also have a function which you receive
some object oh it doesn't want it what
it's type is but it wants to call a
method M on that type what should the
type of FB well Python says if it has a
method M I don't care I'm gonna use it
that's basically called duck typing
because if it walks like a duck and it
quacks like a duck it must be Python so
cuero is a bi-directional
constraint-based type reconstruction
algorithm withdraw polymorphism and
union types it all sounds really fancy
and that's it so coming back to our
example we have our took two classes we
have our method let's see what pyro
decides the type of f should be so i
already have this example open in them
and if i run viral but when you'll see
the writing should i make the font
bigger is this better ok ok so my roses
well have f has that ugly type right
which isn't actually that hard to read
it basically says if you give me any
object which has a method M that doesn't
get that doesn't receive any parameters
and returns any type I don't know what
to type in I don't care it's some type I
want to call it the sticks because i
hate you i will give you belt 36 right
because i'm calling the method and i'm
giving you back its result so this is
what peril things the type of that
method should be but how does it get to
that type well first of all it looks at
foo and it says that who has a method f
it doesn't receive many arguments and it
doesn't return anything right so the
type of foo is just a record with a
method M with that signature it looks at
the type of bar which has the same type
as I said before and then it decides
that F should have this type why because
I'm calling em on my object oh it
doesn't really care what it is it should
only have a method M ok but things get
interesting what not
yeah probably ok I will just stay in
this part of the stage ok so what is the
type of F now I'm also returning the
object from the function well it's
obvious i received that I'll give you
back that right it's quite simple but
this kind of breaks down because if I
also add some methods another method end
to each object so sorry in bar the
second m should be an end it's my fault
so if I had another method if it doesn't
know about it right f only knows that
its object should have an M it doesn't
notice that you have anything else so if
I happen to call F with one of the
instances of foo where bar then I'm
losing information right it doesn't know
about it it doesn't care about it it
just throws it away that's what true
polymorphism tries to solve it has a
weird name it's kind of academic but
it's actually a really simple concept it
says well if you have this object and
you are trying to use them you only tell
me the about em but I'm going to assume
that that your object also have some
other properties I don't know what they
are but i will just put them in a
variable and that variable is called row
in the literature so don't blame me
that's what the guy is used and as you
can see the very important bit is that
it's also returning row in the result so
basically it's remembering anything that
it doesn't uses it doesn't use it but it
remembers it that's the key point of row
polymorphism so in this case row would
just be another object which has a
method n and my object has two methods
now it all works out nicely so yeah
you run it the head of time horror also
at a runtime because it types change and
also if you have two meters whatever
that are the same and take adjust itself
you could then rewrite one of them to
have one default argument I don't know
that can be cool but can a lot of wild
things with that so you cannot do really
at a head of time of this kind of things
of course you have constraints because
python is a really really magic language
and it allows you to do crazy stuff
which is which just don't fit in a
static type system of course I had to
cut out stuff but it as you'll see later
in some examples it meant it maintains
some nice bits of Python so I'm just
trying to make it harder for people to
shoot themselves in the foot right yeah
sure so earlier you said that you
couldn't use type annotations because
you're in Python 27 but if you look at
for example the Google closure compiler
they've done a lot with type annotations
despite JavaScript not having a syntax
for that so did you consider that kind
of solution yes um so there are a couple
of alternatives one of them is just
specifying annotations in comments which
doesn't work because i'm using the
Python ast module to parse the source
code which doesn't keep comments it
rolls them away so there's no go I can
also use dogs drinks so for those of you
who are not familiar with Python Python
allows you to put a strained at the
beginning of your function or your class
which is just documentation basically I
could parse the dog strings and extract
type annotations o our code base does
have them in a couple of places so we
just say this parameter has type int and
I could use that I haven't implemented
it but I can implement it and I probably
will because global type inference is
hard any other questions
yeah sure well tell me when to stop yeah
they're here okay yes so here you say
that F has returns a unit that's
actually nothing unit boy yet yes and
that M also does that but but F doesn't
doesn't need that right like FF could
also work with an object that where m
returned something yes that's a
simplification that's actually a type
variable there okay so that's your right
in pointing that out anyone else related
to this question also the two meters can
return void or unit in some cases and a
value in a verse mrs. our load by
pythons oh okay I'm not you're right I'm
not sure I understood your question can
you it can change the return types also
from limited's so you cannot be sure of
what is returning from are you referring
to cases where I might return some value
on the den branch of wave yeah I will
talk about that a bit later sorry no
worries okay so how exactly does pyro
decide which type f has well it reverses
the abstract three of the program so
basically you can represent any program
as a tree right and then it just visits
that program and it assigns some made-up
types two expressions it doesn't know
what the types are so it just uses some
place holders which are called type
variables because they are variables
which whole types so it looks at if F is
a function it receives one parameter and
these returns something I don't know
what so I'm just going to say it gets an
alpha and gives you back a beta I don't
know what they are I don't care now
since 0 is the first and only parameter
wave is going to have type alpha because
there's a type of the function and
it looks at the method call which is
other type gamma I don't know what it is
okay so this is the first part of the
algorithm I'm just assigning types type
variables two expressions now it's time
to collect constraints basically a
constraint is an equality every time I
call something a method on an object or
I do something which should tell me that
two types are the same I add one of
these constraints so in this case
because I'm calling the method M on the
object oh I say well I think that alpha
which is the type of 0 should be an
object which has a method M which
receives some parameter Delta I don't
know what it is and in this miracle
gamma a gamma because that's what I'm
returning from my function right and it
might have any number of fields I don't
care about it and then it says okay I'm
calling em with no arguments with unit
so gamma should be unit and finally I'll
sorry Delta should be unit and finally
gamma since gamma is the result of em
and that's what I'm returning from my
function gamma should be the same thing
as beta and it ends up with this this is
basically what i showed you earlier in
the console just with a nicer notation
right so f is a function that receives
any object which has a method m and any
other healed that method returns
something which i'll give you back to be
fair the full type is this because I can
abstract over that that I can be
anything and also because i already have
a field called em in my object I don't
want it to appear in my other fields I
don't want want to have two fields with
the same name so there are restrictions
on the type variables in this case it
tells me that ok your type variable can
hold an object but that object can't
have a field call them so that's
basically it that's what peril does and
a lot of magic
so the example I showed you earlier is
not really the simplest example you
could use because I could have used
something like add one to a variable but
in point and that's actually a method
call because python has a data model
which says that some magic methods and
magic methods in Python are those ugly
things with underscores in front and in
front of them and after them it tells me
the some magic methods can implement
operators and common operations right in
this case I only show two of them which
implement the + operator the minus
operator and a multiplication operator
and now let's see an example which uses
a plus operator so in this case I have a
very very small font so in this case I
have a function we just increments the
value it received an N and it returns M
plus 1 then I just call my function with
an integer so what should the type of
ink be let's see what pair of things so
in this case it tells me your type is
that being good luck reading it so it's
telling me that it's something that
should have an ADD method which receives
an int and gives me back Neil and the
other methods are there just because
hints have them it has an upper a
comparison operator subtraction operator
equality operator and so on and if using
back on it and the type of my variable
here the result of calling Inc with an
integer is correctly identified as an
integer right so that works out now what
would happen if I would uncomment this
to this line and try to type check it
again well it should fail hopefully it
will fail and it failed and it's telling
me ok the first argument of the map of
the function you're calling is a string
but the fun
Shin want something that can add an
integer to it you can't add integers of
strings because it doesn't make sense
right so this rejects the diaper in a
very verbose way okay so those are magic
methods in Python so how exactly no it
was command P go away okay so how
exactly do I decide if types match
because that's the most important thing
in the type inference algorithm well I
use something called inserters which is
an algorithm developed by Mark Pete
Jones and the co-author back in 94 so by
academic standards is like ancient but
it works out really nicely with type
inference it has some drawbacks but I'm
going to talk about them a bit later so
basically the question is if I have this
record which has the label L a field L
which has typed tau some type whatever
and it may have some other fields how
can I say if it's the same type or if
it's compatible with another record
which has label L prime which is
different from l and another type so
what the algorithm does is it walks over
the first type label by label and it
tries to find it in the second type
right if it can do that if it invents a
new variable it assigns the new label
and the type to that variable and it
goes on for the rest of the variables
basically this has a very bad time
complexity because if you're unifying
big types you can get really slow and
unfortunately in structural typing you
get big types so the algorithm is quite
slow that's one of the drawbacks now I'm
going to show you some more examples so
feel free to interrupt me ask questions
that's why we're here yet
I have a few questions like before in
the example where you add a string with
an integer yes I don't know much pytam
but can you reopen the string class and
add add method to it yes an integer you
can do that and if you do that it would
work so it takes into account that and
how do you deal with like code that's
written in C the methods and all of that
that does not work so you are hard
coding all of that for the standard
library oh yes unfortunately I will have
to give type signatures for the standard
library or I could try to infer it but
that's probably not gonna work no I
think the solution is yeah unfortunately
you have to do that in latency type
languages ok thank you thank you ok I
think there's a question here in the
front row when you hit the line where
you assign the Y when there was
commented out uh-oh because it's it
doesn't make any sense yes now when in
this state the title gene fur for ink
yes assumes that the argument is an
integer that's a very good point and
that's an unfortunate side effect of wow
oh how inserters work they just when
they unify two types they just propagate
methods unfortunately I can work around
this but in this version they will
pollute the type of the argument but but
isn't that really problematic when you
put this function in a library and you
don't know the call sites yet oh no it
doesn't care of all the cool sites well
but what if I wanted to call ink with a
double odd that will not work but in
this implementation in but in simple
Python would write in real Python it
would work yes that's basically a
problem of the fact that it's tricking
plus one the one in plus one as an
integer so it's
locating the type information from the
one in the signature of plus and that's
why it's getting integers yeah but but I
know it it basically it means that plus
is not polymorphic but but but the class
only assumes that the end needs to have
a nanosecond ask our add method right
does we assume that it's integer that's
a very good point it depends on how to
find a plus so in my case plus is
defined after very very much code code
which lives in only one file down to
this ok ok so plus is defined as this ad
which is a function type which gets a
self type and it gives you back the same
cell type so the type signature of the
plus of the ad operator is intentionally
very narrow so you say that they both
have to have the same type and then when
they even is integer if I want to make
the more generic I could insert type
variables here and generalize them but
that doesn't play very nice with Union
types which i'm going to introduce a bit
later
is it possible to to type something
that's actually generic on several kind
of input types and there's something so
for example can you type something that
takes it into your integer or a float in
your type system but the moment no okay
so I'm going to go into details in a
little bit okay we have another question
oh cool so it's on this lack of 150 a
serious issue in it I don't know 100
doesn't line of code base so in this
implementation it is a serious issue ah
it's an issue with numeric types to be
specific it does only with minute yes
only the numeric types because you have
to bootstrap your type system somehow so
you need some base type like integer and
so on basically this problem arises
because I chose a very narrow signature
for the operator of integers they
basically say I want an integer i will
give you back an integer and that
information propagates so it's kind of
the same problem in having languages
like o camel and okay okay well it's a
good example where you can't use plus to
add integers and floats and you have to
use a different operator this can be
worked around I just haven't decided
what the best solution is if I want to
use a union type or if I want to use a
more permissive signature for the add
operation so I'm going to raise this
question at the end of the talk
it do you know typepad lure i know i'm
not familiar with it it's a an attempted
to to type Lou again so maybe it's off
to compare with your approach that's
interesting does it use type signatures
or does it do global that global type
inference I they use optional type
annotation ok those kind of help yeah I
think did me they use gradual typing
yeah that's a that's nice approaching
how do this work with object hierarchies
so i will i will show inheritance a bit
later it's in one of the next examples
other questions ok so i think someone
had a question about using multiple
generalizing over multiple type
variables in this case this is a
polymorphic function just to show that
polymorphism is there the type of ID
which is a function which gives which
takes anything and gives you back the
same thing it's just for any type
variable for any type i may have for any
type you give me i'll give you that type
back and this works for multiple
arguments so if i add another why here
it will just say i have two types i'm
going to give you back something so next
next we have classes and objects here we
are defining a very simple class called
see which has a method which takes the
self parameter and some X and let's see
what the type of C is
is just see so because types are so
awful in structural type systems up
Python dash okay it's not part of any
more Python dash tries to give you the
name of the type when it has it so
whenever you define a name type it will
remember the name of the tag and it
tries to show that tag whenever it can
right and now let's see what type of oh
should be and what the type of calling
the method is so we are instantiate in
our class here the type of all should be
C and then we are calling the method
which should give us back an integer
because it just gives you back what you
give it and in this case it works now I
can also call the method with a string
and it will give him back a string
nothing very special here basically it
should just work okay what about cell
types we haven't talked about them but
they're actually very interesting
because recursive types are not that
straightforward to implement or not
always how do you type a recursive type
well there are two approaches one of
them says I have this record i introduce
a special type variable which is myself
type and then whenever I call a method
on that type or I access one of its
heels I'm going to replace the self
variable with a pipe itself right so
that approach is called is or iso
recursive types and it basically says
that the type is equivalent with it
level one unfolding so that's what
python dash dolls and in this case we
have a class C which has a method
receive just receives the self argument
and it returns it so in this case I
should be able to call the method
repeatedly because I'm just returning
the same object and the type should
always be c
so in this case if I type check my
program I see that Oh has type C because
it's an instance of my class c and then
again x.x is also see because it's all
right I'm going to run this in the
verbose mode to show you what's actually
going on and there's a lot of things
going on basically these are the steps
that Python dash is following to unify
stuff so that's what types actually look
like but because they're kind of hard to
read it tries to give you back nicer
types okay what about constructors
objects classes can have constructors
right how does Python dash handle them
in this case we have a simple class see
it it's a counter it receives an initial
value it remembers it in an attribute
then you have an increment method and
the get method which will give you back
the the number
so it's the same situation as before
with the integer because i'm adding 1 in
increment the information propagates and
the type of see here is a constructor
because in Python you can just call the
name of the class as a function and that
acts as a constructor in this case I
have a constructor which receives an int
and gives him back I see the problem
with not non polymorphic plus and now if
i call the methods see that inc oops it
works it shouldn't print anything ok and
finally since we're talking about
objects we can also have inheritance let
me scroll up here I have a base class
which has a method M I have a derived
class which has a method and the derived
class is right from base so if i
instantiate a derived class i should be
able to call both m and n on it but i
shouldn't be able to call and on the
base class so this should talk this
should throw typer so if we try to type
this without calling and on be it
actually works and they all have the
expected types but if I uncomment this
line here it rose the type and it tells
me that the object does not have an
attribute called n which is expected
basically Python dash treats inheritance
just as copying properties from a base
record to another record is just
basically extending records it does not
create a subtyping relation because the
subtyping relation is replaced by Rho
polymorphism in this case subtyping
doesn't work that nicely with structural
typing and
type inference that's why I chose this
approach and I think it works nicely for
Python ok and finally one of the last
features I want to introduce is Union
types in this case it means that a type
can have a value can have multiple types
one of the simplest examples is this
function which receives a number and if
the number is greater than zero it just
returns the number minus one if I type
it I see that this is the important bit
down here the type is out you can see it
right the type is non type or int so it
because it only returns on one path of
the function the by default python
returns none from functions that don't
return anything so in this case the
return type is either none or int and if
I want to use this if I try to say y
equals x plus one I will get the diaper
telling me that the type of X is
actually a union none or int and if I
want to use it I should use a type test
which is an instance or is not none
check one of the goals was to give nice
error messages I think this error
message is quite nice not all of them
are as nice but it's getting there so
let's make this actually work and we say
if X is an instance of an integer this
is pythons way of asking are you an
integer
this should work and the type of why is
it now this this has one row back the
fact that is instance in Python actually
uses a subtyping relation which Python
defines in this case because wife and
dash does not define that relation this
is not going to be transitive right so
if i wanted to test for the right type i
want to test the drive type if it's a
base type that's not going to work
because it's not going it's not doing
structural unification inside union
types it's just doing simple matching so
that's one of the open issues so I think
that that mostly covers the demo part of
the presentation now as I said the types
are quite scary if you look at them when
they're unfolded one open question is do
row polymorphism and union types
interact well I think that if you use
Union types everywhere it's not gonna
play nicely with row polymorphism but
you can use Union types for a very
restricted purpose like nullable types
the example where I returned either int
or none and other cases that are similar
but i think the generalizing it for the
whole language might have some weird
interactions with row polymorphism now
you might have you might remember seeing
this yet so do you use do do anything to
try to type check uses of classes as
values like creating mix-ins or anything
like that no at the moment classes are
not first order uh they can be quite
easily that's not a it's not a
shortcoming of the system it's just that
I didn't implemented classes are just
objects okay so I recognize that in
Python classes are just objects but I
don't think it's just a small matter of
implementation to type check that
there's a lot of tricky aspects of that
okay we can take this offline or I
encourage you to come too
are cuckoo paper later this week cool so
you might remember seeing this flyby on
the screen earlier this is the reason
why it's called Python dash if any of
you guys watch My Little Pony I don't
but my colleagues do it seems that the
Rainbow Dash gets angry a lot and this
is her angry face and because Python
dash screams at you and it's quite
colorful that's why it's called Python
dash okay it's alpha code it's mostly a
proof of concept because your SSD
crashing does that your project it's
open source I'm gonna put it on my
github account and finally thank you do
so if I might still do you have some way
to distinguish between something being a
union type and something being a
typeerror for example if you assign two
types to something does it get a union
type or easy to type error that's that's
one of the points where I said that
Union types and unique volume down so he
can enter education so that's one of the
problematic points of Union types and
pythons semantics basically in Python
when you don't really have assignment
whenever you assigned to variable you're
actually defining a new variable so it's
all matter if you want to think of
assignment as introducing the new
variable or just updating the union type
with a new type right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>