<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Renzo Borgatti - Distributed Configuration with Clojure - Curry On | Coder Coacher - Coaching Coders</title><meta content="Renzo Borgatti - Distributed Configuration with Clojure - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Renzo Borgatti - Distributed Configuration with Clojure - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FKa24oHsHbA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I've been enjoying it so far was pretty
good the party yesterday was amazing you
think and Rome is fantastic so the
stupid configuration with closure but
before me in the meanwhile in chemistry
um fluorine is a pale yellow gas at room
temperature it can be liquefied if you
call it hard enough to go like a down-
180 degrees Celsius is extremely
reactive that's a very interesting
element in the table of elements of
course it's very poisonous and maybe the
interesting fact for the talk of today
is that it tends to form compounds with
almost every element even the noble
gases and I think it's like an
interesting metaphor for configuration
in which every application which is not
trivial and needs to run in production
has some sort of configuration it might
be very basic like a file maybe a little
more interesting like some system like
zoo keeper or etcd but as far as I know
each application I've been dealing with
in my professional life has always had
some sort of configuration so it tends
to be everywhere like fluorine if you
don't pay attention so I'm going to go
through a just a little bit of
definition at least we know when this
configuration is a pretty large wide
spectrum of things you can do with an
application so we're just going to
define it a little bit what are the key
aspects and what are the available
solutions and a model that in my opinion
is solving at least the problems that I
have am I my current professional
activity I'm reebok on on Twitter you
might know
that handle and on github as well
currently work in the main online quite
a big closure application out there and
I also publish this weekly post although
they are not sometimes constantly weekly
and lazy sometimes about closure and
things that are interesting in the
closure world so definition I don't
think there is a like a perfect
definition but in my opinion
configuration of application is any
external handle that you can somehow
tweak in order to substantially change
the behavior of the application of
course there are many things that are
behaving this way and so configuration
configuration definition is blurring
into features of an application
sometimes examples are like typical
examples the way you want to see your
application to change behavior based on
environment so yeah if you're in local
development you want some specific
configuration that is connected locally
maybe if you are on integration there's
a different configuration and so on
until production where maybe your hosts
IP things like that are changing I think
we can consider also a configuration the
user configuration like the settings
menu that sometimes you have in
applications both web and desktop
applications you have a settings if you
go in as your user you can change the
configuration application on something
that is peculiar about that is it needs
to be stored so when you come back in
you still have your configuration and we
can go like push this to the extreme
into multi-tenant applications where
like you have some settings may be
stored in the database and when you fire
up the application is fetching those
settings it is setting the entire
application UI themes a lot more deeper
concepts based on your user usually a
corporator like think about slack
the fact that you have yours lock for
your company and another company has
their own slack and is they are
completely different and that is
blurring a little bit into the into the
feature you can call it configuration
maybe we are talking about the proper
feature of an application more properly
feature toggles this is something that
we're using quite a lot at the main
online every almost every feature is
deployed in to live with some sort of
feature toggle that allows us to decide
in which way should be deployed so it
should go initially to some specific
channel maybe sport and maybe just for
Australia and not for the US and we
can't recall these things while the
application is running and this is the
definition of feature toggle you could
turn it off and on or it's if it's more
intelligent you can do different things
a be testing maybe is one flavor of that
where you decide between two features
instead of a single one and the way you
use this data then it's up to you but
usually is to discover interesting
patterns and see which one of the
feature is most interesting for your
users then we can discuss a little bit
of like the different dimensions of
configuration so one maybe is the value
lifetime things like the host for the
database is supposed to stay stable for
the at least for the application the
running lifetime of the application so
maybe it's a booster thing so when
application starts up it reads this from
somewhere and it stays like that but
there might be added every kind of
values with a different line time like a
schedule a time for example every week
some report is fdp it into some location
your application is restarting maybe
daily maybe weekly and picking up this
file and do something different or real
time and then thinking more about
feature toggles that I was talking
before and one maybe things that is
important is that if you have future
toggles you usually have a condition the
way you decide that your application
should follow a different path is
decided at runtime so you have an if
it's this then do this if not else do
something else
storage backhands it can be inside the
sources itself usually like maybe in
Java although this is not suggested and
is not very common you can have a class
that is dedicated to constants but as I
said is not very used XML files or maybe
modern much more common so you have some
file that you're reading you have you
can have relational databases so you
store them in some sort of tabular form
and you can read them real-time key
value stores is similar in concept but
it tends to be separated from like the
business data of the application that
you tend to store in a more isolated
consistent transactional data store like
a relational database or you can have
just dedicated services and I can
mention a couple that I know zookeeper
etcd they both have features dedicated
to configuration so they say in the
documentation somehow that you could
store config and then you can read
config and they also have a very nice
feature that is that you can push value
to the application push changes of the
configurations application instead of
reading them in a cool way they push the
ten to push to you or you can have that
if you use those specialized products a
little bit another kind of distinction
is about organization if you have files
you have single file multiple files if
you know if you have units so not
necessarily files they can fold the same
convention you can organize
configuration into tables if use a
relational database so you can go here
arca cool like the case of zookeeper
where you have a tree and tree is as far
as I can say one of the best options to
inflexibility of organizing the
configuration or we can talk about
caching so if you have a pull model
compared to a push model if you have a
pull model you my certainly have the
problem of deciding what you want to do
if this is a feature toggle is a live
value that you want to read you can set
to read it every single time or think
about something that is network it like
a database you might have a performance
degradation it might not be suitable for
the application so usually what happens
you cash this configuration somehow in
memory and then you have as soon as you
do that you have the problem of all
right so now it's cached when we are
going to expire it when I'm when the
application is supposed to know that
there was a change in the configuration
and pick that up and you can use TTL so
that you can check time stems and do it
in a more custom way worth noticing that
if you have the push models that is this
is not isn't it's not related it doesn't
it doesn't force you to have any kind of
cash and the configuration is just push
the tray to you you can like as the
application decide to do nothing about
it usually in our application what we do
is we bounce a few components so with
that I mean they became they become
aware of the new configuration and they
behave differently and then distribution
is another important aspect and this is
especially for clustering application so
if it's like our environment you might
have an environment where your
application is running a multiple
instances each one of them can receive
one of the request and in that case if
the configuration changes you want this
configuration to be propagated to all
them hopefully in our almost synchronous
way you don't want like a partition of
the class that to know about the old
configuration and gather partition to
know about the new and work in this like
in two different worlds this might also
involve the fact that you need to
coordinate a local cache invalidation
it's the same as the single Winston
this application just if you have a
cluster you have to coordinate that case
as well last aspect is that I want to
talk about is versioning and that was
probably the key aspect that made me
think about a different solution for
this problem and because what at least
was very important for us is that we
have a lot of future toggles so they are
the configuration if you look at the
configuration in my seemed very
complicated is quite long as there are
many features some of them are all some
of the menu we tend to clean up them
every once in a while but there are
quite a substantial number of them and
you want to know when you're pushing a
new configuration to the live
environment you want to know what you're
pushing you want to see a diff for
example of what values are about to
change and you want to be of course also
you want to be able to revert the
configuration if anything goes wrong
into the running cluster so this is
especially true for future toggles that
are like impacting on the live
environment and if you push this kind of
configuration you want to be fast in
recovering from an error in the
configuration and you also want to be
able to dis them so versioning is in my
opinion a key aspect for configuration
so going in is like more deeper details
I'm just picking one possible products
of the many like for relational
databases or key value stores or
specific products and I just want to
highlight that for each one then there
you know there is no a single column
that is all green there's some of the
aspect that is impacting on your
development life cycle in terms of you
might need some effort to put together a
custom solution or there might be some
in flexibility or lack of flexibility
and do some other kind of stuff
just wondering if going through maybe
one of them were two of them so let's
pick the first line for example updating
so if I if I'm using plain text for
configuration in that case the updating
action so the way the application is
going to read them if a push or pull
it's something that I need to do cast
them that can be a library of course so
there are many solutions all ready for
that kind of problem use your library
but still it's a custom action you need
to do so maybe is not that much of
effort but it is something that you need
to do for might equal or for other
database usually usually the way you can
be pushed about changes is by using
triggers tring triggers are I have the
drawback that they they sit outside the
application so you have this part
sometimes very important part of the
application that is sitting in the
trigger and this triggering sitting in
the database and then it's not part of
the same place where you see all the
rest of your sources so that might be a
problem also programming trigger is not
always done if it's time in pure sequel
is not maybe the best language to do
these kind of things order bet there are
better options right is for example if
we talk about updating they they have a
way to push your notifications you have
a client and you use the readies client
it will push notification to you
fantastic ET city is the same thing he's
got Watchers I'll take another one and
then we can move on if we go down for
example to the difficult versioning
which are kind of connected and you go
playing text you have this nice thing
that almost every versioning system has
a way for you to do d finger files so
that comes almost for free you have a
tool that is already doing that is
making things colorful you see exactly
what is changing and at the same time is
a version in tool so you can revert
quite easily so from that point of view
is a very good solution but if you go
into for example my sequel radius or
etcd
they are not using a like a pure text
approach of course they are storing
something that is p 0 text but in order
for you to do this difficulty of
synchronizing something that is on the
file system into something that is
inside this kind of database which is
storing unusual in a binary and
proprietary format so it's doable and
there are also tools for doing that I'm
just saying that is a custom thing and
you need to think about it so can we do
a better and for better I mean can we
have all of the greens in a single
column and this is what what I was
trying to achieve with the idea that i'm
going to illustrate to you now so plain
text a possibly a hierarchical model
which is a push model so i can receive
configuration changes as much as i want
I don't need to pull pad on it I can
even catch them but they will be expired
as soon as the new configuration is
landing on the app which is possibly
distributed because we have multiple
nodes and also possibly it's dedicated
to configuration only because another
thing that is bloating into both
zookeeper and anissa also offer you
other things that you might not want or
don't necessarily need this distributed
locking thing on into keeper is quite
it's quite big so is impacting in the
documentation in the API you need to use
and in the way you need to maintain the
cluster the zookeeper cluster so it's
impacting on you the fact that you have
distributed locking and you're not using
it if you're using it good well we're
not so the model is there that I'm
proposing is a client-server model I
think the the most important part of
this is that is a layer that is growing
on top of a file system based
configuration so we have already
configuration files containing all the
configuration that we have and we want
them to sit and gate or another version
system so we can use the different
and we want our would be ideal to have
something that is sitting top of this is
figuring out even when there are changes
and is propagating them to all the
listening clients so it's a little bit
like the people or etcd is doing or a
database is doing the only difference
maybe is that it's using a push model so
whenever there is a configuration change
each and every node in the cluster is
getting the configuration change and
maybe some important aspect of this is
that every node is connected to like
multiple of these servers all serving
changes that the configuration and it's
important this this is an important fact
for failover of the configuration so
what I do what I certainly don't want is
for any of the running application to be
dependent on the configuration server to
be up and running in order to continue
running so what can happen anytime is
all the servers go down fine but
applications needs to continue running
of course with whatever version of the
configuration is loaded at that time
that is the important thing there should
be no network connection that is
breaking and stopping application for
ramming running consistently so why
functional i'm using I've used closure
to write this server client application
and I think functional is a perfect fit
for the kind of especially for the kind
of concurrency model I'm looking at so
when I think that each client is
receiving multiple updates maybe
sometimes multiple dates of the same
configuration I really don't care I'm
not interested in the fact that for
example it is receiving the new
configuration from two of the servers
and the other two service for some
reason are not sending it the important
thing is that there is something pushing
and this pushing
to the client that is receiving the
configuration can be concurrent as much
as I want and this is a perfect fit for
unmute able up a functional language
that supports immutable data structures
because I can push as many of these
changes and there won't be any chance
for one of these clients to see half of
the new configuration in the fly and
half of the old configuration because
the update is still running because
thanks to immutable data structure the
kind of concurrency model is a compare
and swap semantics the casting there and
this is perfect for the for this case I
don't need to be completely
transactional just need for one change
to be atomic and to read it as an atomic
change another aspect maybe that is
important is that the functional
languages especially the lease / famine
of them is coming with this concept of
liveness of the system is they are not
the only one that are also
object-oriented system with this
aliveness of the system of course but
especially in lisp languages is coming
it's it's assumed to be there almost
it's almost a granted fact and for this
reason it's working we're very well and
why it's important because my system is
a live system and when it's received a
new configuration it needs to be able to
potentially swap a function with another
behavior completely and work in a
different way and especially for closure
what I liked about the solution is I was
able to use atoms as the model of
concurrency which is supporting exactly
the behavior I want multiple changes all
arriving at the same time and they're
not impacting on the client reading a
new configuration in isolation
atomically metadata this I'm using them
to store data about the raw format of
the configuration file
so multiple clients written in other
languages can read it so I wrote it in
closure but with the idea that it shoots
should be able to serve any application
that can talk WebSockets basically for
that reason there are wonderful
libraries in the closure landscape like
a left and manifold that I'm using for
for exactly for this reason they support
this networking and I don't need to
think about it I just need to use them
and they're very easy to use and Java
interoperability it gives giving me
access to Java niÃ±o primitives to
listen to file changes so I don't need
to think about which operating system
and deploying it onto the JVM is doing
that translation of i'm on linux is used
in the linux way to propagate file
system events if I'm on Windows is using
the windows way and so on and since it
is not written yet but I'm planning to
write it almost right away I was
thinking too right at the closure then
JavaScript client for this to have a
client to be written in JavaScript to be
able to receive this configuration it's
probably coming for free almost for free
by just generating closure script from
the current closure client this is a
list mine i hope so i want to show you a
little bit of how it works we are going
to see a little demo running we are
going to fire up for service that are
sitting on top of a very simple like
branch in my file system that is
containing a few folders subfolders and
some file and we are going to fire up
one client to client may be a little
more to listen to these servers and then
we will try to change the configuration
and see what happens so you're going to
see a little bit of logs moving around
so let me just and this will be the beat
what I need to drag and drop this so
make some make it bigger ah how does it
look like you read it's okay all right
from it I cannot see it um yeah I have
it under here let me see if I can do it
okay so let's start the service and then
we can follow a little bit of the server
starting up we can see a couple of
interesting things let's give it one or
two seconds when each service starts up
is just printing a few things about what
is the root folder is looking at or
which body listening to and things like
that and some warning yeah I don't be
worried about that there's not enough
entropy but you shouldn't be worried
about that okay let me start a client
so if i go here you should see better if
i leave it in the middle and suppose we
see the client starting up and when the
client starts up the first thing it
effins it connects to the server and
that's ever the thing the first thing
the server does is to push in your
configuration to the client and you
should let me check before it starts to
ping you see this line here okay let me
highlight it ok this is the
configuration this is the result of oh I
forgot to show you by the way at the top
here as soon as I can see where the
cursor is okay at the top here I have
like a few applications subfolder once a
folder for each application and I
decided that my client should listen to
the top one I think no this one this
test Jason thing and inside this
destination think there are a few files
like this Sam Jason if you go inside you
can see that it's just like a sample
JSON file and this is what you can read
them if you go back to the line here so
it is it the client number one says I
received the configuration I can read it
and it's ready to run basically so let's
fire up another client just to make
clear them a little bit more noise I
need to kill the logs for that just to
see there
and the client is coming up maybe an
interesting thing to notice is that each
client coming up is receiving a push
from the configuration for the
configuration by each one of the servers
that are running so that was one aspect
that when I thought about it said oh
that might be a problem because I'm why
should I receive the same message all
over again and then I thought about it
is it's just fine because in terms of
scalability is is going to impact only
if you have millions of these I suppose
or if you have megabytes of
configuration at that point in my you
might have other kind of problems as
well so it just decided to leave it as
is and let the concurrency and immutable
data structure immutable data structures
to deal with the problem of receiving
multiple of these messages all at the
same time I don't really care um so
let's try to make a change and now it's
kind of difficult
I'm sort of help me so let's write carry
on nah some vector things is it correct
Jason yeah all right save it let's see
what happens now the machinery is about
to send stuff so you can see many
messages come in as an eel thing is
because it's the same kind receiving the
configuration multiple times but at the
top of that it is actually receiving the
change configuration and you can see it
here with the carry on now coming
through and the same client is in
receiving the same messages so it is
printing the death so the next message
is printing Neil because there's no diff
but the first one is the one who
interested in and it goes on like this
so let me go back to the slides couple
of technicalities about this problems
that you might need to solve keep
tracking of connecting clients so that
might be interesting because I need to
clean up from the server perspective
since this initial implementation is
using WebSockets I don't have any other
way to know if a client went down for a
proper reason or is just temporary
disconnection so if I see a client that
is reconnecting again I'm assuming it
died for some reason and I have the
previous WebSocket state that is still
in the server state so I need to clean
it up so I need to keep track of all the
connecting client if the same client is
connecting twice well I'll clean up the
preview state and say oh hello again
send the configuration the current
configuration again
the keepalive beings are for firewalls
some of them they usually are friendly
with WebSocket connection some but if
nothing is passing through the pipe they
might decide to drop the connection so
I'm pinging and you probably notice the
the messages of the pings going through
they have local caches as I said when
you have a push model is you don't have
the problem of the cache invalidation in
the sense that you invalidate the cash
every time there isn't a new message
coming I throwing away the previous
configuration and taking the new I'm
supporting both Jason and Eden Eden is
the format standard format for closure
it's got a specification so you can use
it from JavaScript as well or other
languages but is definitely the most
used enclosure land JavaScript client as
I said is the process of being written
and all the code is in that repo and my
name is called foreign and that's all I
think I think this solution is serving
us well at the moment is not deployed on
the entirety of the application is
running on part of it yeah I think
that's all so if you have any questions
in short words what exactly makes like
what's the best like the biggest
advantage of this distribution of
configuration over like well no
distribution configuration management of
distribution systems because it's it's
their lair slightly different like I
know chef or poppet like what's the
biggest advantage so I think they when
you use shadow puppet you get you get
the distribution mechanism based on
those so you can push files on a
distributed system then the way the
application is picking up that file is
the custom part you have the option of
sending a new hop to the app if you
don't want to peel it that that's
usually the best way I know you don't
want to kill the application if you can
so you may be Santa no hop and you need
to create the code to react to know hop
and reload the files so it's not
completely difficult solution and I
suppose many system works work that way
but you have that kind of moving part
and by using this you get it in the
client you don't need to code it
yourself and also caching is handled by
the client as well so that would be in
my opinion the advantage hi one thing
that I didn't understand was the
transmission of the differential know
that you drive and so I'm wondering if
there's a scenario where because of
because a connection might drop and get
re-established or something or any
anomaly with TCP that you might deliver
those differentials out of order and is
there a case where when merging those
differentials out of order that you risk
an inconsistency across the nodes so
maybe the thing is that there's no such
a thing like sending two different
versions well
there might be if you are updating the
configuration in a very fast way that's
that's precisely the scenario I'm taking
over or a concurrent addition right so
it doesn't have time fast it could be
that two people make change roughly
around the same time and so you have to
in quick succession that may arrive out
of order that that's is something that
you to solver the like process level of
why two people are doing the change at
the same time this should be at least in
our case this deploy the configuration
is connected to a Jenkins job so when
you click run on the Jenkins jobs and
you might have different way of
synchronizing but the Jenkees job is in
a running state there's no way to click
it twice or you can click it twice but
there will be one configuration change
and then another and that is the case
that happened when based on zookeeper we
we had the configuration and the problem
with being based on zookeeper is that in
that case we were not really able to
understand what was the change that went
up and how to revert it based on what
was the change then we invented a way to
post the configurations lock to check
and verify bit but we didn't have the
diff and so you had to copy paste the
configuration from locking to a diff
thing figured out what was changed and
reverted so for like multiple people in
the organization always wanting to
change the configuration at the same
time this is not preventing you to do
that it is a process part that you need
to figure out who is doing the
configuration when QA needs to be
involved maybe not maybe yes right and
so the I I guess just to riff on that
same scenario with out of order messages
it seems like another possible scenario
is drop messages and so something like
zookeeper one of the benefits that you
get from zookeeper and zookeepers atomic
broadcast is that you get the guarantee
that you'll have delivery to notes that
are considered part of the current the
current view and so I'm wondering yeah
it seems like in the ideal operating
case
in ideal operation whether a few network
partitions something like this is fine
but in in a scenario where you're trying
to reconfigure something because there's
a network anomaly and you need to get a
majority of your notes online and
reconfigure them to like kind of
stabilize the environment it might be
difficult to perform that stabilization
if you're dealing with these drop my
senses then I'll consensus the way the
way you deal with it is you increase the
number of servers you put them in
geographically distributed areas so you
have that kind of like failure a way to
deal with failure and then one of them
yet I mean one of them will be able to
send a configuration this is what what
should happen if none of them is able of
course you don't you don't get to the
change but then you have another kind of
problem if five servers are going down
okay what about difference between your
solution and the other configuration
specific ones like Netflix Keizer or
worse being cloud config I don't know
about them you know I do I try to solve
the problem that we we had with the
current products and I had looked around
for how other what are the other
products in this scenarios when I did
the search I can only found etcd
zookeeper and five based solutions based
on libraries but they were not solving
all the problems so I'll be happy to
take note of Oh other solutions for this
and see if this can be improved Baden
based on those or I did a completely
useless work but this is very it was
like very simple application to at the
end and it seems to me that there are
two scenarios here one is where you
change your configuration you leave the
code intact so so what needs to happen
is what you showed the other scenarios
where you deploy a release and very
often you have to tweak the
configuration
the same time so you don't want any
boundaries to come up with an old
configuration you want something Crenn
ization there how do you deal with that
well every time the client at the moment
is configured so every time it it fires
up it is connecting and receiving the
newest so in case of a redeployment or a
redeploy at this point is if you kill
the app and you restart it is going to
get the latest it's not answering the
question no because the previous one is
just it's just disappearing as soon as
the client dies is just in memory
there's no like other kind of caching so
the client starts up again and it just
gets whatever is the latest if anything
was deleted it's just going to be wiped
out and start again so there's no
there's no like this kind of logic
merging stuff because there's no lock of
sight i bought from the memory thank you
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>