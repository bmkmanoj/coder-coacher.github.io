<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sean Grove - From Unikernels to Databases to UIs: Truly full-stack apps in OCaml - Curry On | Coder Coacher - Coaching Coders</title><meta content="Sean Grove - From Unikernels to Databases to UIs: Truly full-stack apps in OCaml - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sean Grove - From Unikernels to Databases to UIs: Truly full-stack apps in OCaml - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QWfHrbSqnB0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's a little bit hard to tell you know
whenever you write a talk ahead of time
for an audience who the audiences so
there's a lot of stuff in there so it's
kind of whatever you guys are interested
in what do you guys want to dive into
detail please ask questions and I will
try not to lie
basically it's my only I'll answer them
to the best of my ability thank you
beautiful all right so I'm going to talk
about Oh camel in general specifically
kind of about the deploy targets about
some of the characteristics of Oh camel
start out real quick I'm a developer I
generally work enclosure and Oh camel
most of the time so those are two
difference okay how many of you guys are
familiar with closure the Lisp on the
JVM how many of you are familiar with oh
camel
okay for those of you like they're very
different languages for those of you who
are not familiar with them but it's
interesting kind of positioned to be to
compare contrast the two but purposes of
this talk I'm basically a hike man I'll
try to be a semi responsible Heitmann
you guys are you know feel free to bring
me up on anything and as a caveat this
is a really short talk there's lots of
stuff left out and it's basically we
contribute as a thought experiment in
lots of ways so real quick we're all
kind of familiar with app dev goals
basically we really want kind of
correctness for your bugs we want to be
able to deliver our product really
quickly the product should run very well
we want to ideally have lots of code
reuse right when I'm to repeat ourselves
we don't have to security is oftentimes
a concern that isn't given due
consideration but it is something that
is important and we want to write
maintainable code we're all kind of
familiar with these these ideas
whenever the rubber hits the road in the
real world though is just kind of an
ordered list or go something like we
need to be able to deliver quickly we
need to be able to deliver quickly and
so on and then kind of at the bottom
it's like well by the way we also want
to be correct fast secure everything
right and I actually think this is this
is kind of fair rights in a lot of ways
business goals are very important you
know it's not sustainable if we take a
very long time to deliver a product I'm
going to have a chance to kind of
invalidate our business hypothesis but I
have the hand kind of developer
happiness and operation happiness is
very important as well right if you are
like we've all been in a code base
generally speaking that we are not very
happy about and it is a struggle to kind
of like you can hear the timer ticking
down for how long you're going to be at
that job until you get into a better
code base so I try to kind of figure out
like what's the the balance how do we
strike a balance
I think oh camel might fit an
interesting space or interesting spot in
the space so real quick which like who
of you have used Oh camel either at
university anyone use oh wow two hands
okay I expected a little bit more how
many of you have used it it's a job then
okay
oh okay one okay great how many of you
enjoyed it
of the three people okay
so just for those of you who don't know
then it sounds like I can kind of go
into it a little bit so camel has an
incredibly lightweight but thorough type
system it's a bit like Haskell in a
sense
lots of inference o'connell
implementation has a strange obsession
with performance actually it's worried
sometimes it's statically compiled with
very very predictable characteristics
there's no JIT you can look at the
assembler output of the compiler and
have a very strong intuition about how
the performance is actually going to to
be it has a lot of different deploy
targets has highly efficient JavaScript
output the execution model of oh camel
maps very very nicely on to modern
JavaScript engines you can build UIs
with it it compiles down to arm 64 so
you can use this for example to build
mobile apps as well or you can run it on
your raspberry pi and it tends to
encourage a functional style but it
doesn't require it and this is
particularly nice kind of at the edges
of the application right oftentimes you
want your core to be functional but you
need to interact with either a legacy
system or
with some kind of Highly Effective
oriented domain and so it's really nice
to kind of be able to fudge things at
the edges there but kind of strangely
because of the obsession with for
formants and correctness but also the
high level expression is like it's
actually really well-suited for both
systems programming and app development
which is not traditionally kind of thing
you have like rust and whatnot which is
very very kind of systems oriented you
have things like maybe Ruby Python Java
Exedra which are much more kind of app
level so okay with this kind of a good
job of straddling those two different
ends of the spectrum
so as an example of the deploy targets
you can write oh camel programs and run
them on Linux and Mac going into detail
there's not much to say here right so we
guys we all we all do this but kind of a
more esoteric targets and one that oakum
has been doing a great job of leading
via the Mirage OS is you know kernels
how many of you guys familiar with
unicorns all right
so unit girls real quick so very like a
kind of new way of building applications
there were a lot of these ideas in the
90s they've only kind of recently become
realistic in many ways because of
virtualization where we actually have a
standardized hardware profile that we
can target but the idea in Okemah at
least with mirage is that rather than
having this huge monolithic linux kernel
which is 15 million lines or more of
memory unsafe see that whenever you want
to write a simple program you pull all
of that in we're going to say well we're
going to write all of our write an
entire operating system in no camel but
as a library and a compile time you only
pull in the libraries that you actually
need right so if you need a TCP stack
we'll pull that in but if you don't we
don't the value right and that's
actually very very difficult to do with
traditional kernels so this means that
there is a lot of pierrot camel mutation
it's a very very low level system
libraries but things like TCP stacks
implementation of TLS different forms of
data storage your application will
actually compile ahead of time
and you only pay for what you use and
what this means is we actually compile
not to a typical like elf minor or
anything like that but we actually take
your application we will compile it
we'll pull in the exact libraries that
you need and we'll create a an entire VM
that will boot up so your application is
now the VM there is no Linux kernel
there's no operating system it is just
your application which is why it's
called Mirage right the OS is a bit of
Mirage actually it's just your
application running on the VM and so
this has lots of like very interesting
applications so yup your app is the M
and you get some really really cool
small numbers here so now we have
thousands of lines of memory and
typesafe code versus millions of lines
of memory unsafe code this has pretty
severe security implications the the
surface area alone is hugely it's
considerably smaller soothing it's
considerably smaller right so if you
think about the Linux kernel how many of
you well I mean no human being can hold
that in their head right 15 million
lines of code is a lot of a lot of code
I don't want to generalize I can't hold
it in my head but actually with the
ochem limitations you actually can you
can actually traverse the entire stack
on your own and part of that is due to
the fact that it's a memory safe
language so there's a whole kind of
swathe of implementation details you
have to worry about part of is this type
safe nature of it but largely it's just
due to the size now because of the
expressive nature of oh camel so
whenever we actually compile up please
of thanks what's the current coverage of
a camel libraries when you compare it to
color for example is there anything
missing that you may want to share a lot
right actually the way Mirage and the UN
kernel stuff started is a group of
pretty crazy people out of Cambridge
about seven years ago we were like let's
just rewrite everything from the ground
up no camel and seven years is a while
and they've been able to do a lot but
not everything
so they kind of started with the core so
stuff like TCP stacks DHCP servers TLS
implementations this kind of stuff but
there's kind of always going to be the
edge the envelope of stuff that you
might be missing that you're used to and
in a Linux kernel so whenever you
actually do compile down your VMs you
end up with these very very tiny
artifacts so if you kind of imagine if
you were to optimize a Linux
installation you could probably eat it
down to hundreds of megabytes maybe
anyone deploy Linux servers with smaller
than that so few all right cool what's
what's the range maybe five megabytes we
got five megabytes it's pretty good and
is it easy to do this oh so I'll find is
actually quite good at this right so
some of the newer approaches have
actually been quite good at kind of
emphasizing being able to dissect this
and then I'm curious about boot times as
well like one of whenever you boots a VM
on Alpine with a 5 megabyte image how
long does it take before your
application is up and running
that's pretty instant so like instance
meaning no very nice yeah so this is the
goal is to make it so that's everything
by default is like that right so
whenever we build an application we want
to be in the range of hundreds of
kilobytes to maybe low tens of megabytes
and boot time is typically around 50
milliseconds right now for your entire
application so your entire VM and your
entire application and this changes a
lot of what we can do with actually
development and deployment right we're
now because these are so small you can
actually check in every single VM that
has ever been deployed to production so
you can actually have a git repository
where we're going to have an entire
audit log of anything we have ever
deployed and it has big kind of
implications for one second for
reproducibility so for example if there
is an error in our production you can
actually go to that exact VM and
reproduce the state pretty trivially
so do you check in binary blobs or
resource so both so you have your source
code which is of course you know we just
traditionally have the version control
system with it but as part of the build
system right before we push to
production we actually push to this we
do a git push into of the binary blob of
the VM image into another git repository
and so that's kind of our entire audit
log of everything's ever been deployed
as an actual artifact so repro cases are
significantly easier right it is much
nicer whenever rather than getting an
email like an error trace and you could
say like play computer in your head try
to figure out how the user hit this or
how the error actually occurred you
actually can save the state and save the
VM pull it up and have an instant repo
case there is some work actually in this
area so mirage is traditionally oriented
or targeting the Xen hypervisor there's
some work with the solo 5 stuff to
actually get it wrong on KVM and they're
targeting kind of 20 milliseconds and
boot up time and may be smaller than
that so this also means that there are
it changes the way that actually
deploying application not only deploying
but booting applications works so we
have this idea of just-in-time summoning
so where a request comes in because 50
milliseconds is actually shorter than
once again shorter than the reply window
for a TCP connection so literally we can
have a TCP connection come in and we can
we can block on that we can hold boot up
an entire VM just to handle this one
connection we can then give back the IP
and then have them kind of finish the
session and then just kill that VM so
because these films are so small and
they boot so fast we can actually for an
incoming TCP connection just boot up
another one entirely and then just kill
whenever we're done the idea is kind of
like a dust cloud they call it right I
would like to operate these unique
kernels like in Linux we have dist under
tools like you know the value stops net
start and whatever but when you use this
unique owners you don't have that right
no yeah so it's it's kind of this
entirely different way of
thing about it and it caused me to
reflect a little bit on what kind of
Unix development actually is like right
now and UNIX development like with a
shell when it is a bit like an ad hoc
repple right where you kind of go in and
you have very strange function calling
conventions and whatnot like it's not
standard but you do have a lot of these
tools where you can kind of poke at
these different things running with the
unit kernels it's kind of all happens at
compile time right you're deciding
exactly what's going to is a bit like
Nick's rights where you're saying
statically this is exactly what I want
to happen in the exact order that I want
it to happen so you don't have these
other tools you just use the tools that
are provided for you in the language and
you build your application and I think
it is actually analogous to the server's
being kind of applications rights where
we don't tend to think of the UNIX
kernel as part of our application but
actually if you think about like an app
server right it is actually all there
that is our application so using these
different tools is analogous to function
indications in this kind of strange
execution environment well depends on
the specific case so because all of
these libraries are written in ochem
well it means that a lot of the
debugging becomes very easy right you
can actually capture a lot of TCP
traffic and actually replay that and
other tools you can yeah so depending on
like subnet have fluorite or a Sarge
star excuse me you it depends on like
you have a bit more flexibility but
there's a lot more work required on your
part to figure out how is the buggin
actually due to happen right it's maybe
more ad hoc right now rather than like
the standard tool everyone uses hi I was
going to ask if you could do real time
with this but now realize you're only
targeting running an AVM right also this
can compile down to
kind of real are so smaller devices so
recipe find that kind of thing but you
do have a garbage collection here all
kind of like it's not traditionally
meant for a real time target right
I don't think soft real time yeah okay
what about the fall system good question
so file systems are kind of sort of
crazy and away right like if you think
about kind of the complexity that a file
system presents and so this is one of
kind of the tools that needs to be
rebuilt coming from the ground up and so
whenever the Mirage team in particular
was thinking about this they tried to
take a different approach and so they
said well what if we just started with
something very very simple on the
beginning where we could just source a
bit of you know blog or whatever
depending on what you want to store and
we just had get semantics so they
basically have implemented a kind of a
database like thing and no chemical
Durman and the idea is you store your
data in there it speaks get so you can
actually store in memory you do a git
push to a server or at boot up you do a
git pull and you kind of pull the file
system that you need in maybe a shadow
clone or whatever and you operate off of
that but there's no kind of
implementation of you know any existing
file system as it stands right now so
this does require kind of a radical
rethinking in lots of ways of how you do
your application it turns out to not be
such a big deal right but a lot of the
stuff that we take for granted like
existing tools or file systems or
whatnot kind of go away cool
so I'm interested in how to deal with
these situations where you do need to
that is missing in the immigrant for
example image processing or access the
file system how do architecture how you
solve it is this approach so I'll go
over a little bit of this and like okay
mo caveats at the end so I mean part of
the challenge with o camel is like it
does not have the ecosystem the
something like Java would have where you
have this wonderful image processing
libraries and whatnot right and so you
are left to reimplemented bits on your
own or to set up some sort of external
service so actually think we're moving
into an era where we have a little bit
more wiggle room because of the API
oriented nature like there's a lot of
services that will do this stuff for you
so in our case we use image X which is
this this external service kind of image
CDN processing thing and it works fairly
well for us but there are cases or there
are some attempts to do some cross
compilation and want us to bring some of
the existing infrastructure out there
into it but then you are bringing in
these big memory unsafe
you know binary blobs since your to your
application but the goal is to hopefully
at some point give you the ability to
choose where on the spectrum you want to
be there may be it defeats the purpose
but can you link see the libraries yeah
exactly
so there the goal here is to be able to
do that but like I said you're brewing
in these these blobs and but at least
you have the choice right so you can
kind of choose where on the spectrum you
want to be and health you know in an
ideal world everything would be
implemented in in Okemah whatnot but
oftentimes that's not a realistic thing
again for you know if we want to shift
on sometimes it's decade kind of thing
right so there is work on being able to
bring in kind of arbitrary C libraries
cool so on the other hand you get these
really big numbers for you know kernels
rights whereas previously maybe we could
run hundreds of VMs
on a piece of hardware now we can run
thousands or tens of thousands of them
right because they take up so little we
can boot them so quickly and throw them
away so quickly as well ah another
deploy target is JavaScript
in you guys JavaScript's front-end
developers I can kind of skip through if
it's not super interesting so we can
take that same code so we have Pierrot
camel implementations of TCP stack TLS
all that kind of stuff right we actually
take that and compile that down to
JavaScript we can share type definitions
modules etc and pretty much any Oh camel
code any pure Oh camel code just works
and so this has kind of interesting
implications for example debug tools so
for example if you were able to record
all the TCP traffic that was coming into
your unit colonel and you maybe set it
aside for a given session and if there
was an error triggered you just stored
it and then later on what I want to do
is actually build a little in browser
tool that would bring in that TCP stream
as it was recorded and would actually
render it in the browser and I would
know that I'm using exact same code that
was used on the unit kernel as is used
in the browser and this is not for like
creating connections I think it's about
maybe visualizing the TCP stream and
understanding what was going on but now
I know that I can very very reliably
bring in this tool replay the session
actually use a lot of debugging like the
kind of debugging tools I can build are
very very different now how do you get
this efficiency with a SMGs or something
know so actually it's just the the
natural model of so camel relies on a
garbage collector and with a smj s
there's no hosted interrupt for the GC
or even web as in right now but it's
just kind of the execution model is
highly amenable to kind of a v8
optimization and that kind of thing
what's the interrupt like between okay
we'll compile the JavaScript and
JavaScript library sure
um maybe order my slides so there are
wanted let me dig outside picture one of
the big problems with oh camel is
there's like two of everything as a
minimum so they're like two standard
libraries there are two async libraries
and there are now two JavaScript
compiler different transpires the old
one is very very efficient and has lots
of Awesome ization that are very
interesting but it has kind of a closed
world assumption
we're interrupting with the outside
world is kind of a tedious thing where
you need to kind of manually type
everything also it doesn't understand
JavaScript modules and kind of all this
the stuff that has been happening in
JavaScript
there's a new one a bloomberg called
buccal scripts and that has been written
from the ground up specifically to like
with this open world assumption if we
want to interrupt we want to bring in
the existing legacy stuff or not even
legacy but existing stuff that's in
JavaScript and that has been doing a lot
more work to kind of automatically and
for a lot of the stuff for and make it
so it also generates highly readable
JavaScript where's the old one is all
about how can we make sure that what we
generate is very efficient so there are
two different kind of approaches to this
right now so if you guys are familiar
with like flow or typescript
okay well the type system just basically
gives you this stuff out of the box but
much much better okay so they're they're
both really really cool programs but
it's really difficult to recover a lot
of the typing information and make sure
that you have these sound programs and
with oh camel you're not recovering it
just just from the ground up you have it
and then the output size is is generally
very reasonable so having worked with
clojurescript quite a bit this was a big
concern I had can you do multi-threading
and Oh camel or so it's a new foreign
umm yes you have a sync libraries which
are so kind of like go style you know
lightweight concurrency and whatnot but
there's it's okay I'm oh itself is
single core so you can do
multi-threading or not but ultimately
it's all going to be single core there
is a new release it's it's been in the
next release for like several releases
but it's a difficult thing to do but
they are actually implementing
multi-core but they're implementing it
via algebraic effect handlers which has
very very interesting properties and
hopefully I'll be able to get to that
yes
what is the coverage of web api s so on
the JavaScript side yes
little to none so again it's this idea
of a close so with the more mature one
it was a closed world assumption
I have Oh camel code that I want to run
and like I'm going to bridge the gap to
an output for render or whatever at that
last last line our last last mile
problem so there are quite a bit of work
there where you can pull in like canvas
rendering and lots of stuff like that
but it moves much more slowly than even
I think like the web standards are
moving at this point which is quite fast
right they're really seeing in to change
WebRTC and Web Audio and kind of all
this stuff very very quickly and so
that's part of the goal of the newer
approach is to be able to very very
quickly cover this stuff even
automatically comfort I'm wondering how
how stable is the kernel API if you say
you can reproduce um your older versions
of your stuff is that still going to be
true like if you take one year old code
will you still be able to well I mean
you should be able to write because
you're specifically bringing the
dependencies and whatnot of that so like
whenever you your code is tied to
specific set of dependencies inversions
whatnot right so does the whole
everything you need is in there and
exactly it should be kind of self record
label right so self describing okay yeah
all right so another target is mobile so
this is one you're in do to my heart so
we can take the same old camel code
compile down to arm 64 you can very very
easily interrupt with C Objective C etc
so I mean building Android and iOS apps
fairly straightforward another one is
raspberry pi so again I'm going to just
do arm 64 and this is one area where the
strange obsession with
mensa no camel kind of pays off right
because these are smaller devices and
they get faster and faster and better
all the time but we still have to be
very very mindful about the limited
resources on these kind of things so
being able to take your code that runs
on the desktop on you know kernels and
on mobile and actually run that on
embedded devices is quite nice not quite
real time but if you can get away with
something like raspberry pi it's very
nice
so as far as sitting code reuse I feel
like okay what does a fairly good job
it covers most of the compiled targets I
care about I haven't worked a lot with
maybe Arduino sized devices or real time
devices and so I would definitely say I
have no idea and I would doubt kind of
its ability to go down there but for the
vast majority of the areas that I've
worked on it matches very nicely as far
as correctness goes I just kind of juice
the nature of the construction of
programs you can no get no more no
pointer exceptions no more undefined
it's not a function
and I spent a sad amount of my life
chasing down these and so I'm always
very happy right that I don't have to
see these and in closure I still see
them
I like closure a lot but I still see low
pointer exceptions yeah so this is just
an example who so this part this black
right here is actually highlighted very
nicely on my screen with a nice error
just imagine that there was an error
there that's uh whatever you yeah
so just effectively like you have these
very nice tools in our camera whenever
you save it will immediately tell you
you know all the types type errors went
up as you're used to but the the way
tooling is built in no camel is it's all
libraries and so it doesn't depend on
the specific editor so it's very easy
for Emacs or atom or vs code or whatever
to kind of pull in these libraries and
have a very nice editing experience for
oh camel and it's very very cool if
you're working on the backends you know
you're working somewhere way way down
here to change some type definition
change some implementation of the code
and actually know that you've broken the
clients way over here oftentimes that is
a pretty strenuous reasoning ability our
reasoning exercise so it's very nice to
just unsaved automatically have this
happen so working in recently I had to
do some JavaScript work and some closure
work and closure is really lovely
because you have this live ripple you
can touch your code like in the editor
and you can kind of see what the value
is immediately it just kind of feels
like it's alive and you're editing in
life and Oh camel is not live but
whenever you save it immediately tells
you hey here all these errors I just
kind of like both sides of helping you
and kind of feel this iteration and then
working in JavaScript was amazing
because I would save and I would wait
and it wouldn't tell me anything was
wrong and save again and save again and
I just you still used to this but then
on the other hand you know you're like
well it's running right now what's the
value and you can't get it right you
have to go into the browser and get it
so javascript has managed to kind of
combine some of the nature of closure
and some of the nature of oh camel in
respect to that little camel is is
lovely as far as that goes so the
performance general speaking is very
good so this is used by in
high-frequency trading by Jane Street
they're one of the big contributors to
oh camel and so like millions and
millions of dollars flow through their
system and they care about performance
to a pretty insane degree let's use it
Facebook darker Jane Street all these
other places lots of Industry and
industry use it's actually quite a
pragmatic language so what's holding it
back kind of there's generally a sense
of you know if it's twenty years old
okay I was twenty years old
it's quite quite quite aged you know if
it's if it's that old and it's not very
popular like it can't be that good right
and so there are different problems with
the ecosystem there are a lot of
libraries that are not as developed out
as on other platforms there are
challenges with the mindset so because
of the very very kind of systems
oriented nature o camel traditionally
it's not really given a lot of tools for
web development as of yet do you think
reason is going to fix some of those
issues alright so that there is hope so
there are lots of problems with tooling
and all this other stuff but Facebook
has been investing a massive amount of
resources into oh camel and the big kind
of manifestation of that is reason and
reason has is a metal language on top of
oh camel any of you guys familiar with
reason oh cool all right I'll try to
hurry all right so it's a language on
top of Oh camel but it's entirely
compatible it is not a fork of the
language everything works exactly as it
did before it's basically a two big
things it reworks syntax and it
encourages kind of a bless stack
approach there are lots of different
tools in old camel and they basically
say we're going to make these small
subsets of tools all work together
really really nicely so you don't have
to spend days or weeks trying to build
up something that works for you and they
focus heavily crazy on developer
experience experience so to give you an
example
sometimes the type errors can be
inscrutable so this is a expression
where we use a string but should have
been a boolean and okay I'm oh and
here's the recent version where they
actually it's kind of inspired by Elm
when they say here's the exact line the
types of match we expected a shrink
we wanted a boolean they even go so far
as like to embed kind of warning and
coastal in here so in this case this is
really hard for beginners like to
understand why optional arguments can't
be erased and so they actually do quite
a good job of saying you know here's the
optional argument specifically that
can't be erased and here's why and kind
of helping you it's like having a
robotic pair buddy with you right as you
go along so there's lots of exciting
stuff there they rework the syntax to
effectively be JavaScript yeah I mean
it's slightly nicer than JavaScript but
you know what are you doing but it's
really really cool so this idea of
separating syntax from semantics alright
so the idea is we all serialize to the
same output format right but syntax now
becomes to a large degree a render time
concern right so I like lists and I want
to view this ast as
list you can view it as JavaScript and
other people can't view it as Oh camel
this means that there are like lots of
experimentations like syntax now becomes
libraries rather than a language blast
concept so as an example here's JSX for
building UIs this is actually valid
reason someone built a thing this all
these sugar statically into function
calls that are statically typed but this
helps bridge the gap between a designer
who's used to HTML who wants this kind
of thing and once to be able to express
I know a lot of you are probably
revolting a little bit at this but this
has huge implications for actually
expressing domain-specific kind of
syntax for designers for systems
programmer for that kind of thing yeah
and I think I'm probably out of time
just this should be like lots of
questions here anyway you can also get
JSON code I like closure in my iOS
Buckle script we went over a little bit
random stuff so there's new memory
profile we have whole program dead code
elimination multi-core and algebraic
effects kind of coming out so in case
any of these are interesting feel free
to ask
so for Yoona Colonel deployment
I guess you're familiar with Heroku yes
so what's great is you can just upload a
VM and it starts as when it's needed
what's not squared it takes a long long
time to start so unicorns seem like a
great way to solve that oh yeah and so
is there something like Hiroko for
unicorns and if not what are the
challenges that's holding that back
right now
there is not really so they're a company
just launched called deferred panic
which is working on this kind of thing
but I actually have a small site project
open source yet where it's basically
little Heroku built-in Oh camel whenever
you compile one these internals you can
literally drag it into a browser drop it
and it will be running in milliseconds
for everyone else it's actually
incredibly trivial to build something
like this because of the kind of the
library nature you can just like slice
these things apart and build them very
very easily yeah it's a very fun thing
by the way can you tell us a bit about
the algebraic effects I can't tell you
very much right so I'm not smart enough
but it has so there are some really cool
things that you can do with it right
we're typically so in Haskell right all
of your effects are statically analyzed
and you need to like they infect the
entire call stack the algebraic effects
in Oh camel for I think largely
backwards compatibility are dynamically
scoped what this means is you put a bit
of wrapper in here and it's kind of like
a try-catch but instead of catching
exceptions you're catching effects so
you would say for example if someone
tries to write to the network
specifically I want to actually provide
this implementation of the network and
so you can do a lot of cool things where
you can say if someone's trying to log I
actually want them to use my log and so
I can capture a lot of that I believe
actually I'm not sure entirely yeah so
there's a lot of so multicore is
actually implemented in terms of
algebraic effect handlers and so there's
a lot of work to make it efficient so
I'm not sure what the implication of
continuations would be there but Casey
it does some very cool stuff and I will
link to it in the slides if you'd like
is there a package manager or and if
there is how can you distribute code
that has some native code for one of the
platforms there is OPM is one of the
most colorful package managers it's very
nice and they have a very different
model from NPM so the packages are
actually reviewed before they're allowed
into the repository but it's a very
light light lightweight review process
and there's lots of instructions about
how you actually do this this kind of
thing often times for example you can do
an open def xed which says there are
external dependencies that are not in
Ocampo and I need like libraries in them
and see you around
open def X and depending on your system
it will actually go and install all
those things for you so it's quite a
nice nice approach I've heard a lot
about unique kernels you've also have
databases and UI and there can you say
something about that sure
so the idea so databases is kind of
urban approach rather than having file
systems and databases separately what if
we could cover some of the use case or a
large portion of the youth case with an
in-memory data store based off of get
that could speak get so for example your
UI sorry your internal boots up and the
first thing it does is actually do a get
full of the state that it cares about
from some central git repository it can
make some changes and can push and if
there's a conflict programmatically
resolved it's depending on whatever your
your merged conflict resolution
algorithm is with the native part of
reacts native and react integrations you
can build UI is very very nicely so we
saw the JSX
code there right this is very familiar
to them who writes react to you wise and
so actually being able to write this
code in Oh camel and then have it render
either server side or client side or on
mobile depending is very nice and then
you're you're reusing so much of the
code across whether it's validation
parsing whatever it is you have this
great code coverage across both clients
and server and
kind of the intermediate layer as well
like like using flow right so how are
these it to migrate javascript code base
that uses flow to play no camo like we
reflect so after I think there's some
opportunity I would say like right now
it will be quite quite difficult right
especially if you weren't familiar with
oak m11 Dante would take lots of work
because there's a big ecosystem and in
JavaScript that you don't necessarily
have on okay so porting it over would be
challenging the mechanical translation
part is actually quite trivial but right
so if you're not worried about the
ecosystem or not it's very easy all the
types are inferred as is kind of it's a
considerably easier process I would say
even then working with flow generally
but you get a much much more sound kind
of typed program so you mentioned that
you like and work with both closure and
the camel and from your experience so
far where will you use one and one
another and so actually it's I lean more
and more towards oh camel each day
simply because of the I run into a lot
of action at a distance and some of the
closure code bases where I'll change
something here and I didn't have the
foresight to write all the right correct
tests to know that I've actually broken
something over here and this ends up
kind of leading to this crippling states
where you're afraid to make these
changes and we writes kind of I work on
financial system and so correctness is
quite imperative in a lot of these cases
closure is a lot of fun though just
generally speaking it's a lot of fun to
work in life though if you have stuff
like fig wheel for live programming you
just I do really like it
Oh camel the repple story is not nearly
as developed it requires kind of more
upfront approach or kind of thoughtful
approach and so overall like I know
closure is fun for things I would throw
away right so like I want to experiment
I want to explore very quickly
but I don't know that I want to rely on
it in a month or two months or a year
from now what which is not to say that
other people shouldn't write just kind
of my personal experience after four or
five years yeah so I didn't mean to be
inflammatory their closure is great us
closer it is cool yeah cool
all right thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>