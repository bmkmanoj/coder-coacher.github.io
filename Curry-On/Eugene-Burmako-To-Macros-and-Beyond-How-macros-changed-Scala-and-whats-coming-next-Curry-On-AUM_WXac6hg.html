<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Eugene Burmako - To Macros and Beyond!: How macros changed Scala, and what's coming next - Curry On | Coder Coacher - Coaching Coders</title><meta content="Eugene Burmako - To Macros and Beyond!: How macros changed Scala, and what's coming next - Curry On - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Curry-On/">Curry On!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Eugene Burmako - To Macros and Beyond!: How macros changed Scala, and what's coming next - Curry On</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AUM_WXac6hg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">one two three okay good
all right hello everyone thanks a lot
for showing up at this talk because it's
at the very end of the conference some
pretty surprised that someone's here
anyway let's talk about macros in Scala
just a quick show of hands who here
knows about Scala has called it
something in Scala oh okay that makes my
job much simpler anyway so my name is
Eugene and I'm a compiler hacker as you
can see from the stats on the slide that
I really like hacking the Scala compiler
I did a lot of experiments there but my
biggest passion in Scala see is macros
and that's what we're going to talk
about so in today's talk we will take a
look at the design that we shipped with
a production version of the compiler
design of compile time meta programming
via macros that marries meta programming
and types then we'll we'll take a look
at what's the best thing about macros
and what's our worst nightmare and
finally as promised in the title of the
talk we will see what we are applying
and next for future meta programming
capabilities in production Scala
all right without further ado let's
begin with the really quick tour of our
meta programming capabilities well the
Scala macros project it started as my
PhD project so every time when someone
comes to a pfl to join a doctoral
program they have to do a semester
project session so the time and you
close to nothing about Scala but I heard
of this esoteric language called me
Merlin this is one of the last known
languages on the.net platform and it had
macros they fascinated me a lot so
luckily luckily there was a chance to
take macros and just implement them in
Scala the thing is that just right at
the time when I started at EPFL
our lab and typesafe
well live band now called Lydon the
company that does commercial support for
scholars they started the joint project
that was about building a native that
data access library first
one of the key features of the project
called slick was language integrated
queries so language integrated queries
also commonly abbreviated as link you
it's a common idiom of encoding data
access via by allowing users by allowing
programmers to write queries to data
stores as if they were writing you know
normal higher-order functions like map
filter group binds and so forth
using the usual capabilities of the
language such as lambda expressions as
we as you see on the code example above
and then thanks to link you there should
be some some kind of a way of turning
this queries into a structured
representation that can then be operated
in the main specific fashion so here in
in the example on the slide we see how
the natural looking code users dot map
and then some lambda gets transformed
into some representation of the query
that can then be transformed into sequel
or what have you
so another to implement that we could go
go ahead and use the experience that has
already been explored in C sharp and F
sharp declare that the parts of escala
syntax that need to be transformed into
this domain specifically representation
we declare them as some sort of experts
as shown in the example here on the
slide and then the compiler wouldn't
every time when the user provides a
value of type T and the value of type
exper of T is required the compiler
would magically transform one into
another so that's that's how it worked
in c-sharp it worked very well but we
decided to take one more step ahead so
since we are going to operate with
syntax trees in the form of expert why
not go and execute inside the compiler
where everything is represented as a
tree in world type symbols but trees are
the main thing there so when while we're
executing inside the compiler we could
also gain some other are very useful
properties for instance we could do
early validation of these queries and
then
reports potential errors faster so now
since we decided to adopt this
particular design the main question is
how does the compiler figures out that
when the user rise users that map that
it needs to invoke the meta program
written in macros that map at the very
top of the slide
so in order to do that we declare users
that map as a macro so here's how a
macro declaration looks in Scala at the
left-hand side of the macro declaration
to the left of the equal sign we see a
regular type signature so this is how
one declares methods normal methods in
Scala so we have a type parameter called
you here we have a term parameter called
a fan we have a normal return type so
everything is usual but on the right
hand side the macro definition it has a
reference to macro implementation which
is the meta program that whose cash
we've seen on the previous slide so so
in that meta program we take something
called context which provides an entry
point into the reflection API into our
metaprogramming API that macros can use
and also this meta program it takes an
abstract syntax tree representation of
its argument finally it has to return
another abstract syntax tree that will
be inlined at the call side after macro
expansion is finished so inside this
meta program we can call arbitrary Scala
code so nothing there are no limits at
all we can do I owe which allows for
some really crazy stuff and we can also
call arbitrary functions that are
written in some libraries so here for
instance in the example the translate
function that were called I assume that
is defined elsewhere so we can just take
normal school libraries and then call
them from macros finally execution of
the macro it finishes it typically
finishes with a quasi code that is a
notation that allows easy creation of
abstract syntax trees so here we can see
how the macro creates an abstract syntax
tree that corresponds to creation of a
table then we call some we create some
domain specific object called map and
finally we integrate the dynamically
calculated value into the
so now let's see how the expansion will
will look like let's let's take the code
at the top of the slide that the user
writes users that may happen then some
lambda and then after the compiler
encounters invocations to table dot map
which we declared as a macro it will
invoke the Associated meta program that
we've seen on the previous slide and
then finally it will inline the results
of that meta program that is the macro
expansion into the call side achieving
the desired result so just to sum it up
to sum up our really fast tour of Scala
macros here's the full code example that
we just explored so obviously the
function translate is declared elsewhere
because it wouldn't fit on the slide but
otherwise the example is more or less
complete so I think it's it's a really
good time to to make a pause and take
questions if you guys have any all right
please go ahead
why does a map need to be in a second
separate macros object instead of that's
a very good question yes so the reason
for this is more of a social one other
than technical one so I remember the
keynote that Bern in Strasbourg gave
here at Korean a year ago and there he
said that for some language features
that he was pushing when these features
were sufficiently alien to the current
mindset of programmers people insisted
on very loud syntax so here the design
that we see here we should view it
through the you know through the lens of
that time five years ago when Mac when
macros were introduced so macros were
really the first of their kind of
compiled official for compile time at a
program in in the official distribution
of the language so therefore we really
considered we really considered the
opportunity that people will get
confused and so we decided to explicitly
spell out that you know this macro it
takes a context and then a fan is
actually not a function but an abstract
syntax tree and it returns an ST as well
yes please
speaking of see why do you call these
things macros did they work on syntax
trees you know you don't have any syntax
bugs yeah sure that's an excellent
question indeed there was some
controversy around this name but
personally I decided to call the macros
because in them earlier things that did
similar stuff were called macros and in
Emily I guess they draw inspiration from
racket which we also did by the way so
that's a very brief story of the name
all right any other questions yep please
go ahead why is it cedar tree rather
than just tree wow that's an excellent
question I'm really glad that you
spotted it so if I were to introduce
that it will take a while but now I'll
just provide a very brief explanation so
actually the reflection API that macros
work with it's very unlike usual
libraries that one can see in c-sharp or
Java the thing is that all the entities
that macros operate with like trees
types symbols what have you have like a
really big API they are declared inside
this inside the big thing called
universe inside an object so since an
interesting feature of Scala is that it
allows to nest classes types whatever
really inside other classes inside the
other values so you to do some very
interesting pattern which is called cake
pattern you can google it later it would
be really hard to explain like on the
spot the Scala compiler is written in a
very peculiar style and so we
essentially took compiler internals we
took the way how they were written and
well more or less copied it into our API
I will talk about this later maybe in 20
minutes ok anything else
great let's proceed so the best thing
about Scala macros what's so cool about
them it's something that I promised
earlier probably that cost someone's eye
well actually after the public release
of macros that happened in Scala 210
they spread around the ecosystem like
the wildfire so a lot of popular
libraries they are using macros and Bob
you don't have to trust me on that you
can go to the website of wideband the
company that does official support of
Scala and just check out their Lichtman
stack so everything there it's I it
either has used our stuff or they have
experimented with it so why did this
happen why macros were so popular that's
a very good question and probably part
of the part of the answer it's social
again but speaking of technical stuff I
think an important feature of macros is
that they they cannot transparently in
which the familiar concept of a typed
method call as we've seen on previous
slides I'll probably go back there
macros they look like normal methods so
here users of table dot madly don't even
understand that table that map is
declared as a macro when when something
misbehaves really seriously they will of
course did use that but in the in the
normal mode of operation everything will
be fine and they won't even understand
that they're using advanced language
features and as a result people have
been able to use common library writing
idioms to incorporate macros and then
enrich them with additional capabilities
so now in order to provide an
illustration of this very abstract
concept
let's take an example so here we see a
fragment of Apple session that tries to
format a stream so here we take form a
string and the syntax of Java so this
dot format method is is actually defined
in the Java standard library and then we
try to to pass a string to form a string
that expects an int so unfortunately
scales type system isn't powerful enough
to type-check the string and then report
the
smash at compile-time so we get an
runtime exception from the from the jdk
so actually with macros there's there's
no such problem as the type system
that's not powerful enough so here I'm
exaggerating a little bit but just a
little bit so here we can see how the
custom stream interpolator this F thing
before the double quotes here is able to
take the form a stream and then at
compile time I figure out that there's a
type mismatch between the thing that we
were trying to format and its format
specifier so now I'll see how how how
this example works out and how we would
be able to implement this we share
ourselves if if we wanted to so first of
all let's see how string interpolation
works in Scala we were talking about
Fisher interplay between macros and
other stuff so let's take a look at some
Scala features so string interpolation
here here we can see another rebel
session it works in a pretty
straightforward way in this case we have
a stream interpolator called s which
takes which can take variables from from
the lexical scope and then splice them
into a given format stream as a matter
of fact stranger when I was calling to
interpolate interpolation and Fisher I
didn't mean that it's like a
full-fledged feature which is handled
very very specially by the type checker
as a matter of fact it's it's just the
it has a simple disagreeing so here the
S interpolate er that we've seen about
that we see a bar is actually
distributed in the call to a method s
that's that's done on something called
string context which is a standard type
from the from the Scala library and
finally this method method s it takes a
the things that were splicing in as
arguments so that's a pretty
straightforward the sugaring and it's
important for us to know that string
interpolation is not something magic
it's actually coolant to this code as if
we were writing this we were writing it
ourselves now let's see another feature
called extension methods
so how does this call this one declare
customs through interpolators if if they
represented the schools to to the
standard method code to the standard
types during context well in Scala we
have support for extension methods mind
this heavyweight syntax please this
implicit class is something but in any
case there's a way to enrich the public
API of a given type with the some
additional methods and this is how we do
it and if we declare method F like this
to be an extension method on string
context which is provided as a parameter
to an implicit class then the history
interpolation F hello world will work
fine and now here's the beauty of macros
they naturally integrate into this
picture and they allow us to make they
allow us to introduce compile time
checking into this pipeline so if we
declare this F extension method as a
macro then the compiler will
transparently rewrite this tree
interpolation into the invocation of the
F method and then once it encounters
this invocation it performs macro
expansion so in this case you can see
the results of the macro expansion at
the bottom of the slide and there the
macro doesn't have to do anything
special it just creates temporary
variables with specified types but it in
first from the format specifiers and
then the the code that we've run is
rewritten it wouldn't even compile so
that's that's how we get this pretty
error message that we've seen before
type mismatch we provided the string and
actually int was expected yes please Wow
a lot of questions I'm very glad so what
is the location of the error
but that's a very good question so I
didn't want to talk about that in detail
so again some very brief explanation
actually macros they feature an API that
can specify positions of custom error
messages that they are emitting and in
this particular case if we take a look
at the expansion this API is not even
necessary because here we see some
synthetic code Val Arg dollar 1 for
instance but this synthetic code it also
includes real code for instance X it's
taken from the program as it's written
by the programmer so in this case X will
be the culprit of the error and
therefore the type error will be
positioned at X so everything will work
out magically but of course in real life
sometimes things they do not do that and
for these cases we need an explicit API
the position errors manually you know
overwrite existing functions with yes or
no the I have a specific question
suppose have a function f it goes from
some type A to B but if I happen to know
the actual value of a I might be able to
say B prime which is below B can
override this F with a macro so that if
I see this particular value of a I get a
better type all right ok so first of all
since macros are expanded at compile
time no virtual dispatch is possible so
the normal notion of overriding that we
have in Scala it's not applicable yet
you can compute into any you can compute
at compile time anything you want
including IO for example or probably
capturing continuation and whatever
that's that so you know alright so as I
said the short answer is no this is the
answer that I would have provided on the
forum but the you know the the extended
answer is yes because macros can do
anything so theoretically they can take
a look at the program and
decide what to do with it yeah sure so
by normal means that you cannot do that
what's not normal means I need to know
all right all right if you insist if you
insist but I insist I didn't tell you
that so actually as I mentioned before
macros they're using this wonderful
context here it is see context and the
context did it somehow encapsulate the
magical world of the reflection API and
so this magical world is actually the
full scholar compiler so with some down
casting you're actually able to get the
code of the compiler itself oh yeah of
course
that's very nice yet but I warned you
yeah how cool is that
okay any other questions to this
particular example who knows how many
revelations written well anyway so we've
seen how macros interact with existing
language features namely string
interpolation and extension methods to
achieve something that wasn't possible
before in arguably quite an elegant way
so actually there's a bunch of other
examples of feature interactions of
positive future interactions thanks to
macros we've been able to implement
classic rules these cue quotes the
construct objects in text trees that
we've seen before we've also been able
to implement a sink in the way it's not
as a language feature but as a library
so that was a project performed by
typesafe called wideband with macros is
naturally also possible to do deep
embedding of dsls that is take some
fragments of Scala code and then imbue
them with custom meaning there is also
type class derivation which is similar
to derive in in Haskell and rust and
Heather my colleague from pfl she's been
able to implement a really fast
serialization library
isn't that technique and finally with
with these macros that we've seen before
we haven't been able to emulate tie
providers that's one of the crazier
things so if you're interested in that
please find me later I have a lot of
interesting stories anyway but now we
really have to proceed in order to feed
the stock into the bank and I have one
more question can you override function
application so I can turn a straight
application into lazy application I mean
you already have my name but can I
automatically insert by name before you
actually run the program in function
applications alright so again the
official answer so the official answer
would be in order not to confuse those
who watching this talk later
is that macros they expand locally which
means that if we have a function of a
method application this method is a
macro then the macro the fair game for
the macro is only take a look at the
application and then replace the
application with something else oh yeah
of course
and this crazy stuff with compiler
internals well jokes aside it's going
away it's not like we were very fond of
it oh you can not
yes that's right so in Scala is possible
to define methods with hard-coded name
apply that will be invoked when
something is applied to something else
so if you explicitly define this apply
as a macro then you can control what
happens there but standard functions
like function one and so on and so forth
for arity of the arguments they applies
is a normal method yeah so therefore
it's off limits officially no all right
so now that we know the best thing about
Scala macros and it's not that you can
do everything there it's that you can do
stuff in a principled manner hiding
behind type signatures and local
expansion now let's take a look at what
was the most complicated and in our
macros well when I was preparing for
this talk I actually take took a look at
github and iced omit that the amount of
effort that it took us to get there it
was about 1k comments probably a bit
less and the the accumulated changes
lines of code that were changed there it
they were like in thousands of hundreds
of thousands of lines of code yeah
that's a lot that's all I know
now see why it took us that much right
so actually made the list a breakdown so
first of all macro engine it's actually
the simplest thing that we have so as I
as I supposed as one may suppose it
contains some tricky logics it took us a
while to figure it out but all in all
it's just a couple key lines of code the
second thing that took us a lot of time
is of course discussions it's a it's not
there in the lines of code size but it's
there in you know men hours many years
so to speak another thing it took us
even more time is to build the community
so as I said macros were the first of
their kind and therefore the target
audience for them when they just
appeared they were just you know a dozen
of people who've written Scala compiler
plugins before and now we needed
of course that was too little for a
feature that was that was to become part
of the official Scala distribution so
therefore we had to create the community
it took us a while and now what what was
you know the the real the real thing
there is the reflection API so as you
can see from here in the final
incarnation it's almost ten key lines of
code and plus a bit more of that
documentation it took us several
rewrites and now you can you can start
to understand where this 100k lines of
code came from so reflection API that is
if if you have any questions then I
would be glad to answer embarrassed okay
well this sometimes happens anyway so
this skull reflex thing we actually
needed to provide some sort of an API to
macro writers an API that they could use
to throw together abstract syntax trees
the structure of them ask them four
types ask types for list of members and
well this basic stuff it took us a while
and now we get to you know the worst
thing about skull mattress which is how
we did that exactly but as I mentioned
before we took compiler internals and
then we expose them behind a very very
thin abstraction layer it was it was a
it was a cool solution the coolest thing
that I ever ever did in my life so we
were very agile we could deliver this
thing almost immediately because the
compiler it already implements all the
reflection it eyes that you need and
even more of course and then for power
users you know those dozen of people who
wrote compiler plugins before we
provided paradise because they could
downcast to the computer compiler
internals and then do even crazier stuff
but you know the the only downside to
this plan it was that this thing it
required a little bit of learning but
man I mean Scala users they're pretty
smart right they will get
well what could possibly go wrong right
and naturally that was the reaction of
the community when we haven't reached my
croissant well jokes aside let's see
what exactly went wrong I can talk about
this for hours but here I will give just
three reasons well first of all since
compiler is very complicated beast and
now it's it's history it comes more than
10 years it contains a lot of stuff and
therefore we had to expose quite a bit
of that stuff so that we can get the
basic operation going as you can see
from this list there's a lot of
different kinds of trees there type
symbols also scopes names all these big
nasty complicated bull of classes it's
hard so just explaining this it takes a
while I'm currently finishing my thesis
and well it takes a while that's that's
probably the biggest problem here the
second problem is that the Scala
compiler and in particular this cause
type checker which runs macros it has
this nasty habit of doing the sugar
rings well the sugar rings they're a
very nice textbook technique to
implement languages as we all know from
textbooks but unfortunately for macros
if we do the sugar rings pretty
liberally like here then the
innocent-looking code on the top it will
turn into the monster at the bottom
which is kinda crazy and the monster at
the bottom is is what macro writers have
to understand in order to write macros
that take things on the top so this kind
of breaks the intuition the
what-you-see-is-what-you-get feel that
we wanted to give to a macro users
unfortunately well that's the case and
with the api that we get from compiler
internals we cannot do better and
finally we just locked ourselves in by
exposing compile because so I mean we
prevented the evolution of the compiler
I know if you pull requests that had
problems going in just because they
changed the API that macro writers grew
to expect and also there were problems
with tools so compiler in the compiler
it naturally implements the interface
required for its internals but other
tools going ahead and implementing those
hundreds of methods that we exposed well
that's that's not a good idea and as a
result as a very practical result of
this and the theoretical question
there's an IDE in our community which
cannot expand macros just because it's
built on on a different type checker
that's this fairly said I would say of
course some there's a good point that
counterbalances at all since macros in
Scala they hide behind type signatures
so macros look like methods which means
that they have typed parameters and they
have return types and all that we can
approximate the behavior of macros with
these type signatures so these this idea
is of course not completely useless but
there are some problems with certain
corner cases and that's definitely
unfortunate well since there's a problem
and I'm giving a talk here well I have a
solution already so let's see how we how
we figured out what to do with the
situation since the reflection API was
so important to our macros we decided
that so we will start from first
principles we will designed this a
better reflection API from scratch and
then once it's ready we go ahead and the
user to build better macros what
happened afterwards after this
realization is that we created a new
project called scala meta
i recently we've had the version 1
release which is a really clean room
implementation of the language model so
it models all the definitions that the
language has all the possible terms and
types you know all this boring boring
stuff and since since kalamata cannot
depend on anyone it cannot depend on
existing on the existing compiler or on
the IDE that implements its own type
checker we had a problem so it took us a
while but the good thing there is that
we didn't have to conform to any limits
we didn't have any limits essentially so
we designed our abstract syntax trees to
be
that is we didn't do any distributing so
the distributing from from one of the
previous slides it's not a problem for
our parser and also we didn't throw away
any information about the code so
scholars Bosch compiler it's famous for
throwing away white spaces in comments
because who's gonna need them when one
hour goes just to produce executable
bytecode but of course if if you do meta
programming if you're writing tools this
kind of information is important so we
could not do anything with that before
but in Scala meta will retain all this
information and finally as I mentioned
Scala meta was designed to be a platform
independent from day one which meant
that were really targets in all the
tools we want we want the macros that
are written against kalamata to be
executable everywhere not just in a
particular compiler so just a few
examples so that's that's how we
comprehensively model Scala syntax so
previously we've seen how this for
comprehension it gets distributed into
something so on the on the top part of
the slide we see how sky reflect our
current API process and at the bottom we
see how a process in Scala met and also
speaking of syntactic details so in that
example above we see how the Scala
compiler drops the comment as something
that doesn't matter and in Scala matter
we somehow retain it the mechanism how
we achieve that it's probably to involve
to go into it right now but please
contact me later if you're interested
and you know what since we spend so much
time working on this good ast is once we
were finished we realized that it's not
about macros anymore it's not about just
macros anymore because thanks to VCS
people have been able to implement tools
that weren't just weren't possible
before so here's two examples of our
earliest adopters first we have coda C
which is a web service to do estelle
checks and code from github bitbucket
and stuff and so there's Cal Engine it
uses Scala meta to provide users with
the capability to write their own rules
and thanks to the fact that skal
American can model Scala syntax
comprehensively as shown here of the
year rules can be very detailed and
secondly there's a very cool tool that
was developed recently by my master
student Oliver garrison called Scala
from T so Scala from T it takes the
comprehensive lexical model provided by
Scala method it takes a look at the
tokens that comprise the code and then
formats them accordingly and as I
mentioned now the tooling story is as
important is at least as important as
matters to us so we have a lot of cool
ideas and I'm not working on them so
hopefully I'll be able to report on that
in future conferences now back to macros
let's see what we did to mak response we
had Scala meta so now I'm not gonna
present the final result right away I
will just go through the design process
that we had so yes the mandatory
disclaimer so this thing it hasn't
shipped so everything may be changed
please don't rely on that well that's
that's really necessary
based on my experience anyway let's
start with the the current macros that
we've seen before so this thing table
dot map would cause a custom meta
program and then try to cut the
boilerplate first so as mentioned before
it's it's really unnecessary to split
this macro definitions and macro
implementations so this code in blue is
just pure boilerplate we cut it out
since people have now have understanding
of it and we just merge the code and now
what we do next is we try to anchored
code some of the special cases that we
had before so previously this separation
between macro devs and macro Impulse
it's a really textbook illustration of
how not to do anguish design because
this thing that comes after the equals
sign in the macro definition namely
keyword macros in white space and then
some some very very specific syntax that
the compiler expects there it's very
error-prone
so it's unlike everything that's that's
there in the language and it requires
the user to specify some to follow some
particular rules
they're just just for macros for nothing
else
so now let's let's do this analysis on
the on this on this design at Weaver
right so what we can cut out from here
and what we can replace with orthogonal
parts so first of all the left-hand side
of the macro as we've seen everything's
fine with it it looks like normal method
definitions in Scala so we have regular
signature so nothing has to be changed
but this right-hand side which says
macros something it's kinda weird
because well macro is a keyword which is
used just in this particular language
Visser can we do better let's let's try
to take a look at the at this block of
code in isolation and actually if we
like really really squint I don't have
much time so I'll go through through
this a bit faster then this block of
code it does make sense on its own so if
we try to think of what it does then we
can view this macro block as some sort
of an indication to take to execute this
block at compile time take the results
and then line them at the call side so
here we don't have macro expansion we
just have a facility to invoke custom
code at compile time so that's that's a
pretty that's a pretty cool language
feature that was just born from from
macros so if we try to play with this
feature a little bit just you know take
this block assign it to where or pass it
to some function everything looks fine
so it looks natural and what we finally
need is the is the ability to deliver
this macro blocks to call sides of
macros to achieve feature parity with
with the previous functionality and for
that we introduced a modifier called
inline which says that the method it has
to takes to take its right-hand side
substitute parameters with actual
arguments and then inline the result to
the call side so here's how macro
expansion works in this new world it
works in two steps actually so we take
the right-hand side of the macro because
the the macro is declared as inline and
then we get the intermediate result
which is just the macro block finally we
do compile time compile time function
execution of this block of code and we
arrive at the final result
so now with a slight rebranding of with
a slight change from macro to meta just
you know swishing keywords around we
arrived at the design that would plan to
pursue further so this is this is pretty
much the good old thing that is already
in production and that people grew to
like but without the boilerplate and
without hard-coded definition syntax so
we're really looking forward to
exploring this design Avenue and of
course I would welcome your comments but
since I'm running out of time we'll have
to do that afterwards finally just to
conclude back rows then that'd been a
powerful and popular feature in Scala
the best thing about macros is that they
compile combined metaprogramming and
types and in transparently enrich
existing language features the worst
thing about markers that we went on
about Fleur in details is that the
metaprogramming API has proven to be
inadequate and it provided a really high
barrier to entry
finally a much better method probably
many PI is already in the works and it
turned out to be about much more than
just macros so we're really looking
forward to the future of our new meta
programming world and Scala Thanks so I
think I cannot take any questions now
but let's take two questions two
questions
awesome so for many years of experience
in even racket we've learned it phase
separation is important you do any of
that so phase separation and regime this
is something that we're so long story
short we did not yet get to that so we
have well we don't have face separation
essentially whatever side effects you do
at compile time they will be shared
between macros but of course they will
not be carried to run time because Scala
is a compiled language right but then
you can sort of observe what your units
of compilation are and stuff like that
that's right it's so nice so we would
like to do better
there's nobody else I will ask anybody
else so copy as unsurprised that you
were missing good macros in Scala now
you have mediocre macros congratulations
what I have a question about the
language community this is a social
process you you clearly have a lot of
code in backwards 1.0 right and you
introducing a whole new way of doing it
I use that in the community or are you
typically yeah technically speaking I
deprecating the old stuff and in terms
of community did you answer the question
and in terms of community expect people
to really follow the application or are
you gonna split the community into the
novel power users and the people who had
used the old stuff and one experience
more pain all right so of course it's a
I think the most important question of
software revolution the goal of macros
was always to be to work in the
production environment and I think
that's the most important the most
important of a question of those so as
you can see from this example this is
the new macros the code that is used
there it's it doesn't it doesn't call
any fancy api's so it just uses quasi
codes to construct apps as abstract
syntax trees it calls into some custom
logic but all in all it doesn't do
anything involved so this sash macros
there will be it really migrated able to
the new system because you just need to
merge macro definitions in macro
implementations which were previously
split and then you can use classic holes
which behave almost like the quasi codes
of version 1.0 of course power users
that were that were you know don't cast
into the compiler internals and trying
to do crazy stuff we won't be able to
support them unfortunately that's a non
goal because well we allowed too much
and now we're going to suffer for that
well it's not like the original macros
that were using too much of the compiler
internals API are gonna disappear
authors of these macros they they can
always write compiler plugins that
implement similar functionality so as I
mentioned before that's that's one of
the good things actually use the
compiler internal API because everything
that was written in macros that it can
be like copy pasted into compiler
plugins and it will just work it's
definitely very sad please don't think
that I'm taking this lightly that we
expose a huge API and now we just cut it
and enjoy it no we do not we all try to
do so to do as much as possible here all
right the third question can we take it
as well all filled in table oh it's
possible area now oh it's just ideal
example could you formulate yes so
translate it takes it takes an abstract
syntax tree you must know about type
about you must know yeah yeah probably
it does yes yes it's just also it's
possible for the function Translate to
take the abstract syntax tree then to
ask the compiler for its type and then
to deconstruct this type and if you get
out exactly always 14 you so yes
definitely
okay I guess so we're out of questions
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>