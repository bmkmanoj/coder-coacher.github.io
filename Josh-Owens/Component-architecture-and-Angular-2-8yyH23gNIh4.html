<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Component architecture and Angular 2 | Coder Coacher - Coaching Coders</title><meta content="Component architecture and Angular 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Josh-Owens/">Josh Owens</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Component architecture and Angular 2</b></h2><h5 class="post__date">2017-07-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8yyH23gNIh4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this crater comm 2017 video a
big thank you to all the speakers that
took time to give these talks hopefully
you enjoy this video series and also be
on the lookout you can go to created on
Io to get all the latest JavaScript news
and you can also follow me on Twitter at
Josh Owens and we've got some other
exciting stuff coming up in 2017 Thanks
enjoy the video we have an amazing
speaker Todd motto with us welcome Todd
hello how are you he's gonna be talking
about angular and specifically angular 2
and I know like I'm followed your stuff
Todd you you do you still work for Josh
I'm drawing a blank now I'll see how
long you can go without remember that
telluric jimmy telluric yes yeah yeah
the one thing I bought I was trying to
think of the company that bought Oh Oh
progress yeah progress that's it yeah
yeah that's the one yeah so and you you
you're kind of a dev evangelist for
native script right it was I actually
left in December on basically trained
people on angular full-time now so
that's my my jump into the wind is to
get full time for myself so yeah I
definitely do
angular training full-time for myself so
yeah as working with those guys sorry
had to kind of follow my dream a little
bit so yeah yeah so yeah understandable
all right well I will let you take it
away and if anyone is interested you
know Todd just mentioned he's doing
training so be sure to follow him on
Twitter and check out the stuff he's
offering is great class thank you
I'm gonna share my screen I should do
the trick and then I gotta stop my video
because my bandwidth is not the best you
see that okay so ready to roll
yeah you're good we can see it cool I
just I can just see my fullscreen so
like to double-check before I go on a
ramp for half an hour
cool so this is kind of a primer talk on
thinking in component architecture and
it doesn't necessarily have to be
specific to angular itself this could be
applied to things like react where react
made this component architecture and
uni-directional
unidirectional data flow much more
popular so we're going to look at the
concepts of component architecture and
then how we can essentially apply that
to angular it's kind of been renamed
from why not renamed it was always
angular but it's been it's been known as
angular 2 for a few years now
but it's it's basically just been called
angular so if you hear anyone talking
about angular instead of angular 2
that's what it means and then anything
angular 1 we just call angularjs now so
this is why I've removed the two from
the end of my talk and some other places
so if you wanted to ask a questions or
bump some of these up this again you can
follow me on Twitter and ask some
questions that might come to your mind
at some point during the next week
maybe so I just mentioned to Josh that I
run a training company called ultimate
angular which we basically specialize in
building courses from zero to hero we'll
call it on anything angular 1 angular 2
and we also do typescript so that we've
got like a whole ecosystem covered on
ultimate angular calm if you want to go
and check that out so I've got
information the talks going to be about
this it's gonna be about compiler
architecture then we're also going to
look at what I call different well many
people call it these different types of
components but we'll call it this as
well so we're going to investigate the
different types of components that we
can create then we'll look at the
concept of one-ways dataflow as well and
then we're going to look at how we apply
that to angular
hmm so what is angular for those who are
maybe used angular 1 or a new to angular
2 and above so it's the successor to
angular 1 now known as angular just just
angularjs it's pretty cutting-edge it
doesn't work in some of the sort of
older browsers like ie 8 for example so
it's it's focused on the next five years
and beyond so it's very cutting edge
framework and some of the API city uses
are just being added to browsers now
such as like web worker support you can
bootstrap angular a web worker for
example so this gives you a platform to
basically build with from now to the
next five years so it's it's good for
evergreen browsers will put it that way
it sits on top of the web platform this
is really nice features just doing some
recording this afternoon which uses
native shadow Dom with angular so this
is a really powerful feature for things
like style encapsulation so not sort of
emulating this stuff
it uses a component based architecture
so we're not just sort of creating the
MVC model typical of huge page with
loads of bindings for example and the
cool things are that it can be deployed
to the both web the mobile web it's
something like ionic and we also have a
neg script I used to work for so
telluric they used to build well they
still build native script not used to
which you can essentially native script
would take your angular code and compile
it down to a native mobile code so
you're in fact transforming perhaps a
desktop perhaps a web application down
into mobile so you can basically share
the same codebase which is what angular
is good for is sharing their on multiple
environments you also got things like
desktop with electron which you can
deploy angular to
so we'll start with
kotecha I like to use this hopefully
everyone consider screen as it is on
mine some projectors and stuff at
conferences like to cut off bits and so
this is how I kind of go about trying to
drill people's minds into the component
architecture is just say we got four
boxes here one of them's a search box
one of them is a list so you can imagine
this is like your Gmail where you've got
the search for a message at the top
you've got your list like inbox and
draft and trash messages on the left and
then you've got the chat that you can
put on the right or below the list but
we're just keeping it simple here and
then the view container is what we call
like a component route or some kind of
container that changes different
components based on the Rueter so if
you're at forward slash inbox you're
probably going to see a list of your
emails if you click on an email this
view container will then bring in the
component to be to be able to display
that particular email with then go and
fetch as a data etc so these are just
like building block ideas so starting to
think about components one by one
so for the duration of this talk we look
at a completely made-up chat component
so inside the chat component if you
imagine you were to start thinking about
the features that you were going to
build you would have like a chat profile
so if you go to like Google Hangouts for
example or any other chat line you can
usually see the person's profile you can
see whether they're online or offline or
away for example and then you also have
like the chat list so in hangouts
specifically you also get the list of
friends that you can chat to and you can
click on them and you can go and type a
message for example
and finally we have a chat search so I'm
going to say we're going to have the
feature to be able to search the list of
people for examples so let's assume I
have 500 contacts I could just type
somebody's name into the search and it
will like fuzzy fuzzy search they're
their results now the easy part is
defining now now that we've defined like
the features is how do we break these
down into thinking about components and
component architecture so the idea is
that everything is pretty much a
component but then we're going to work
out how to think of the different types
of components to build this feature
without kind of making a mess and
keeping things clean and easy for us now
if you've used custom elements part of
the web web components back or you've
used angular which allows you to use
custom elements or something like react
which also uses JSX where you could
create something like a chat component
which uses JS X in angular we use native
components so we can just create a
custom element called chat the way that
we can then display the children this
just uses some simple name in terms such
as chat profile the chat list and the
chat search so the idea here is we've
got this container called chat and it
then renders or does something with
these three child components
this is the like the Dom tree of how to
think of it so you've got this these
three child components of this one
bigger component so we're going to use
these these three three or four
components in this kind of story to kind
of introduce the concepts and then how
they apply to angular
so we mentioned that we have like a
pairing component and then if you child
components
a component could be more defined than
just being a boring component or it
doesn't do anything itself so the idea
is that we have these different types of
components which are generally referred
referred to as as perhaps a stateless
component or a state full component and
you may have heard of these being called
presentational and container components
or smart and dumb components so the idea
here is you have two different types or
slightly different types of components
that have different rules or some kind
of guidance that helps you build out
your application using components
so I've got a these basically look the
same apart from the red box here so this
indicates that something else has
happened so we'll dive through these and
understand what the differences are
excuse me mm-hmm so for a stateless
component what we like to do is imagine
your component is some kind of API maybe
like a function callback or some kind of
configuration that you want something to
do when you create like a JavaScript
function you obviously pass some kind of
function argument in function argument
and then you can use that argument
inside the function so the idea here is
the stainless component will receive
some kind of arguments which we call an
input and it will do something with
these arguments and when you're done
inside the JavaScript function what you
would do is typically return whatever
you've done through the data for example
this come through the function argument
and the return statement is what we call
an output so I try and think of these as
just pure JavaScript functions we pass
some data in and then it does something
and it returns some new data for example
so you can think about that as as a
component just apply the job the
JavaScript function thinking to it so
the idea is that maybe I have a chat
list where I want to render out visas of
stateless component and I pass the list
into a component and then I click on a
person and then I want to send a message
to the parent to say I've just clicked
on this person so this is what we do as
you can see point number 2 says the data
enters via and
which we call property binding and
angular and the data leaves in and the
data is completely up to you what you
want to like emit as an an event output
typically if you're doing something like
a click event you could pass a unique ID
that the person you just clicked on for
example and I've just mentioned that we
can also also call these stainless dumb
or presentational so this is kind of the
idea that they don't have any they are
simply passed data and they can do
something with data and they return new
data so you can see that it's not
fetching data at this point itself
so this is where what we call a state
full component so it actually contains
the stay or can go and fetch state comes
into play so the idea is that this well
in angular we have something called a
service so you can see on the top line
we have to communicate with services so
this the idea here is that we inject
something called a service which can go
and fetch our data and then we bring it
back to the component so that the
service basically gives that component
the piece of data which is which which
is when we would like render out here
we've got render child components so at
this point we would pass the data down
into these child components such as our
list so the data is stored in this
component and we simply just pass a
reference to it into the child
components so if I flick back to the
stateless one these are typically what
are rendered by the state for component
and we essentially pass it down so
that's that's kind of the thinking
behind it
that it still ties nicely with something
work called one-way data flow or
unidirectional data flow I've got some
diagrams again just to show the kind of
relationship between services components
and then we look at events and how they
plan to one-way data flow so the idea
let's assume that we've just loaded our
mail application we want to obviously go
and get that uses mail who's just logged
in so at this point the service would
make an xhr request they would go and do
a little checking stuff come back
through so yes the user is authenticated
to go and fetch these messages it would
then bring back that response and we can
just simply bind it to the component now
at this point in the components template
we want to render these three child
components below so you can see here
that three arrows are essentially just
describing how the data is passed from
the top to the next level down you can
see the box on the right so we use
something called property binding
because angular uses the native
JavaScript properties in the actual
elements themselves so if you've looked
at the double curly braces in angular
where you interpolate a value this is
actually like sugar syntax so let's
assume you had a h1 tag which you put
some curly braces inside of and you put
the word title and then did hello world
equals of title equals hello world
somewhere in the JavaScript well this is
actually doing is something like a if
you imagine plain JavaScript you do
element in HTML or element text content
equals a string so it's essentially
doing this under the hood and then we go
to the next level down so this is
completely made-up on a completely
optional depending on how many
components you have so the idea is that
the top-level container holds the data
gets passed down to this component we
can then pass it down to further
components and further and further
should you like
so that's typically like an initial
render of some kind or it might be a
next render if you just change views
perhaps so if that's assuming that we're
editing a form for example and we want
to make a change to the state full the
stateless component that's deep buried
down in the componentry
what we would do is essentially fire an
event so this this ties in with the
one-way data flow the data flows down
when we want to make a change we then
capture that change and then pass it
back up to the next level and then we
then get back up to the next level
if that component doesn't rely on the
piece of data that's just been passed up
it can then pass it up again and then it
can tell this smart component at the top
there's something has actually happened
so let's assume that this component here
hopefully you can see my mouse kind of
wiggling so let's imagine we just click
delete on somebody and this error is
representing their unique ID that's
being passed up we can then pass it up
again see you this parent component
stateful component which is smarter it
has a service bound to it and the
service can then the component can then
go off to the service and say please
delete this particular user so that's
the idea of breaking things down into
components and each component has its
own kind of rule set or rules that it
avoids by
and that's the final area which passes
to the service
hopefully that last bit made servings so
what we can look at now is how angular
basically applies all of these concepts
hopefully okay maybe this is good enough
to view
Oh everything ready yeah perfect
so
much like other frameworks or libraries
such as react you need a root component
so in angular we need to create an app
component which we generally do I'm just
going to skip down here so you can see
we have this selector we have a selector
called app so this will basically live
inside the index.html
so to actually create a component in
angular you can see we have this import
component you can ignore the on an init
piece for now so this is called a
decorator which this is using typescript
to demonstrate how we actually create a
component so the idea behind the
decorators that they hold specific
metadata for this component class which
is underneath so here we have a simple
constructor it says this message equals
hello world so the idea here is that we
take the message property on the class
and we can simply bind it using the app
component so this is a decorator
decorators are likely coming to
javascript soon I think this stage too
at the moment so they will hopefully be
in the the language but they essentially
allow us to annotate something like in
es6 class or prophesy and kind of add
powers that we want so if you can have
the ability to write your own decorators
these are custom decorators that angular
has written relies on typescript to
basically give you so at compile time
angular basically binds this component
emerges it with the act component
decorator and you can see we have
message logged out here and we have this
one message so it kind of joins the two
so that would give us like a hello world
status
now the on Annette piece is simply just
a lifecycle hook so if you use like
angular 1 point X or like react I think
some other frameworks have lifecycle
hooks as well but it's essentially key
points in time of the component itself
so there can their component specific
and they tell you different things about
what's happening at current time so if
we were passing data into a component we
could listen for those changes where new
data comes down wire and on changes so
these are different kind of where we
call them interfaces which is why we use
implements on in it here and then we
have the ng on it here so at this point
in time the component has been
initialized by angular
now this is where we essentially inside
the base component we're going to talk
through the chat component that we
looked at at the beginning to understand
how we render it and then sort of let
the data flow down a few components and
then we're going to make a change and
then Pat it back up
so inside the template for our app we're
simply going to have a main element and
inside of that I've just got chat so I
just locally looked at at the beginning
we had the three columns and we said
it's just going to have a base element
of chat which essentially just
encapsulates all of the behavior for
like a chat module something that sits
in the sidebar allows us to chat to
people
so this is kind of our first stateful or
smart component or container component
would essentially allow us to go and
fetch some data and then render that
data down into other components so for
this piece I'm what we're going to do is
demo one of these components but we're
going to just import them and use them
in the template to demonstrate how how
it kind of works based on the diagrams
that we just looked at
do we have the chat profile that we
looked at in the table at the beginning
we have the chat search and the chat
list component now angular has some ink
of molecule and we use an NG module
which we register these in I'm not going
to show that code because we're just
concentrating on how to actually think
about components so inside of these we
have the chat profile we have the chat
search and then the chat list so this is
just giving you an example with no logic
at all let's just purely think about
component architecture and how we might
structure our applications or break them
down into smaller pieces
so at this point inside ng on a net I've
got a comment here saying do stateful
things so at this point is where we can
go off of the server we might have
already got the data if you tie it in
with something like a routing resolve
which basically preloads the data before
you hit the component but really we're
going to assume that we're just going to
start off inside that on a knit when the
component is ready we're going to go and
fetch some data from our API
so all I'm doing here is basically hard
coding the data so we're going to assume
that this is some kind of responsibly
got back we've got a chat user so this
is a public property under this so this
is part of the actual component class
it's just going to have my name and on
line is true then we're going to have a
chat term this could be like local state
or initialized from the server it
depends if there's something you want to
do with an initial value and we also
have chat friends so if you log into
Facebook for example it brings up all
your friends in a chat bar so this this
could represent your list of friends as
an object as a list of objects in an
array
so if we take the chat user object which
we'll be focusing more on let's go to
our profile so if we don't think about
this too complex we've got three
components here we've got the profile
we've got the search and we've got the
list so on here what we're basically
doing is now providing some data to this
chat profile so this is taking a
different approach to write and get a 1
and react and some other things and you
can see things like these square braces
which will come on to what they actually
mean but essentially we just pass that
chat user down as a value here and you
can see that using the user property
that I mentioned about how you use an h1
and perhaps dot in HTML which is a
native JavaScript property that it binds
to so angular's square bracket notation
essentially means that it's trying to
bind to a property called the user so
you could think about element user for
example if it supported that property
however these are custom components so
we are responsible for creating the
properties to allow angular 2 binding we
also have the chat term inside the smart
component we're just going to pass that
down as a string so we can say this is
going to be an initial value for the
search maybe you could cache it with
local storage or something if somebody
has 1/2 type the name in and then
refresh the page or something like this
and then finally the chat friends which
is our array of objects we can then go
up and just simply bind them using a
property called friends so hopefully
that's kind of simple we have three
properties we've got chat user chapter
and chapter that we then they exist in
our component class and we're now
delegating them down into further
components mmm and you can see here like
I'm not attempting to create any click
events or any of these things because
this is like a state full slash
container component which is responsible
for just handling the data and
side-effects and data changes and also
rendering the child components so that
child components will be responsible for
any changes that we make at this point
you
so now we pass some data down we
obviously want the side effects side to
happen so back to our entry on a net we
have the three objects that we just
passed down so let's assume that inside
my chat user object I have on line as
true now if I change the on line to
false
perhaps in further down the componentry
I want some kind of notification in this
component that the status has been
changed I don't really want to manage
the status change three levels down in
my component tree because I want to
manage it in one place
and keep things nice and simple
similarly we have this search so if I
start typing somebody's name and I want
to search for them and then click on
their username if they if they're found
we can have some kind of call back when
a search has been changed similarly if I
click on a contact that I've found or it
just happens to be at the top of the
search list I can click on contact
select so these will expect some kind of
event to be called back at this point we
could then go off to the server and say
please initiate a chat or open a web
socket with ex content contact so inside
this callback here
so we'll start with a
change how do we bind an event to this
component
and you can see like I've not actually
used any JavaScript as such all I'm
doing at the moment is thinking about
how I'm going to think in components and
how I'm going to pass pieces of
information down and what I'm expecting
to come back up
so I mentioned think about the
components is like an API so if you want
to create some components
you say okay what does this do much like
when you create a function in JavaScript
you need to think what the function does
if it doesn't have a well-defined role
then it's probably not a good function
whereas this component has a defined
role it accepts a user and it can tell
if the user has then gone offline bio
status change so the way that we do this
is passing the function down as a value
here we expect this dollar event so
angular will expose this for us and you
can see I've used a different type of
syntax in the actual bindings here so
this will actually listen to events that
are basically emitted from the component
itself now if I had a button with and I
did the bracket and then click this will
then listen for click events so there's
a difference in the syntax of the
different types of bindings that we make
if that makes sense hopefully so when
you're using a square brackets you're
essentially saying I want to bind one
way so I'm binding downwards from the
top into this component similarly if
you're if you've just got an input and
you want to bind an initial value you
would use square brackets value so this
is just finding a property piece of data
to a property
comes to events so let's say you had a
forum or a click event of some kind you
would put the name of the event inside
these braces here so there's two
different syntaxes for two different
types of bindings that we want to make
it was kind of weird at first getting
used to this and trying to think like
why to do this but after you've used it
for a few weeks you kind of the light
bulb dings and it makes a lot of sense
and you can join a new development team
and you don't have to kind of look
through all the types of bindings and
callbacks and stuff they've got so using
the syntax is quite explicit and easy
similarly with on search change what we
can do is just create a property called
search change or pass a function down as
well and then when a contact has been
selected you can probably guess we do
the exact same thing so by now my
make-believe chat component and the sub
components are populated they're ready
to go
so now we move
on to a stateless component so we're
just going to be looking at one
stateless component just to essentially
see what it does how it can be used
so I've imported Suman a few things here
we've got on in it on changes the input
and the output and the event emitter so
these will kind of sit hand-in-hand
depending on what you want to do some
components will just import component
and input if you need to go and tell the
component that something's changed you
want more we call an output alongside
the event emitter
so what I'll be doing for next five
minutes is can't go well few minutes is
going back between these two just so we
can cross-reference and everything makes
sense so we looked at the slices
beginning and stainless components have
like an input and they have an output so
the data is the input and the new data
has changed is the output which we would
get back in here vias bowler of then so
we're saying here we have an input
binding because it's we're using square
brackets we want to bind to something
and our input data is going to be the
chat user so the way that we do this is
we import the decorator at input again
this does a lot of stuff under the hood
for us to basically connect the
properties we have this user property
that we're saying is going to be an
expected input and all it's going to be
is an object now if you're using
typescript you'll probably want to
create your own interfaces against your
data structures and different objects
and arrays perhaps however we're just
going to keep it simple with object
we also have an output so if I flick
back we have the different binding and
then we have status change so I am
actually creating an output here called
state exchange now this is just a
property on the es6 or typescript class
so this is essentially this dot user and
this sort status change which you can
see down here if you've been looking
closely so what we essentially do is
create an instance of the new event
emitter and bind it to the output so
this enables us to emit an event using
the event emitter API and go and tell
the parent so we also have the ng on an
it so what I'm doing here is basically
just checking whether the user is online
so using the input decorator will allow
us to basically bind to that user
property and get the data associated
with it
so inside of here I'm just creating some
real quick sort of local state that's
just for display purposes and we're
going to say if if this property is true
so the user online so we had online true
it could be false if it's true we're
going to display the text online if it's
false we're going to say offline so this
is just an example of using some local
UI state here
we also have the end
on changes so ng on changes gives us
this changes object so if we for example
because we're building some single page
applications the state of the
application is driven via JavaScript so
unless your full page refresh in each
time you'll probably want to be using
something like ng on changes to get a
new piece of data if something changes
so let's assume that you're you maybe
had your application on one computer and
you went and logged in on another one
and you changed your username you could
then maybe viral WebSocket have it
hooked up and then the data that's being
passed down would have changed so this
changes your user here is basically
seeing if the change has been effected
to the user object which we've bound up
here so if the change has been occurred
for example I was kind of provide
example but we do lots of state changes
in our applications the one we basically
do is merge the current value this is
completely optional but it essentially
breaks the bindings between the parent
and the child component because
javascript objects and arrays a pass by
reference so here we basically break
that so here's the current value of the
user and it simply assign it to this
like user so we're kind of overriding it
with new changes using a mutable
operation which is object to sign here
so now we've kind of looked at this how
they affect the template so here I've
got welcome and then user name so that
property at the beginning is going to
hold my name and then we also got this
local user status so you can see it's
not part of the user object that's being
passed down it's just some local state
that just says online or offline and if
you're using something that dynamically
swaps out class names for example so you
might change out a class to a div that
then makes the background green if
they're online red if they're offline
and so forth
so this is this is essentially doing
that but just printing out the words
online or offline we also have the click
event here toggle status so if we want
to change the status this will then
invert the expression
so you can see here we are you can
ignore this top line for now so what
we're basically doing is creating a new
object here with a property called
online and all we're doing is using the
not operator so we're inverting whether
the user is online or offline so what we
can do is pass this particular piece of
information up because the toggle status
is being used as a callback
so here we have the this dot status
change which if we go back slightly not
that way yeah there so we're expecting
status change to be an output so this is
how we get informed from the child
component and be basically just paying
an event up from the child to the parent
so here is where we'd have the callback
when something changes and we get that
new piece of information so this dollar
event would correspond across to the
this navigate this top status change the
dollar event would correspond to this
object here so this is how we omit and
change from a child component
so we're pretty much at the end
hopefully has been good for thinking
about how to architect an app before you
get started and how you think about one
create and nicer functions but also
creates creating nicer components with a
well-defined API so I put a couple of
bullet points here and staple components
generally own a stateless component so
you could have multiple stateless
components living inside a stateful one
the stateful one basically delegates to
the stateless so you can see based on my
code I wasn't doing any bindings or
anything any click events for example
inside my state for I was delegating
these pieces of logic down into smaller
components and this makes testing and
things like this much easier
what's also good with angular is
thinking about immutable operations so
the way that we essentially do change
detection and the input bindings are
basically faster if you use immutable
operations we can use a different change
detection strategy in angular if you're
interested and don't know about the
change detection strategies you can ping
me on Twitter and just ask the question
and I will send you the link
so there's obviously tons and tons of
stuff in angular this is basically just
a brief on the component side we also
have something called ngrick store which
Rob Wormald
who's part of the angular team is a bit
basically works on it with some other
collaborators but it's it's basically
read acts but rxjs driven so it's it's
using observables these kind of things
fear for Redux implementation and
angular as always said angular 2 then in
angular this is a really important and
nicety of angular is ahead of time
compilation so this makes the payloads
size of an angular app extremely small
so if you download and helloworld an
angular boilerplate you'll be looking at
sort of two megabytes I think of like
local development code if you build out
your application let's just say we did a
small to-do list for example and we use
this ahead of time compilation instead
of the at the size of angular being two
megabytes
I think the smallest HelloWorld is
around 25 kilobytes so it can basically
remove most of itself that it doesn't
need and it will pre compile your
templates into the virtual machine
friendly code so this is like instead of
creating like for loops for example it
will print them out in a VM friendly way
so it's optimized for like maximum speed
so it's not just payload size but it's
it's also that the speed of the actual
rendering what's also nice is we can
bootstrap in a web worker so this story
is kind of being worked on at the moment
and server side is being worked on at
the moment it's just moved into started
as a community project has just moved
into angular actual core so there's lots
of lots of good things to come on the
web worker side which would essentially
allow us to bootstrap where does allow
us it needs some further things like
in a world in a webworker so we can
leave the UI as a completely just
rendering only so you could do heavy
data processing in a webworker which is
a separate processing core in the
browser so this actually gives us a
performance boost because we're just
using the UI thread to simply render
rather than doing
perhaps a huge JavaScript iteration or a
calculation which we've likely all
infinitely looped ourselves at some
point or something like this so it
basically delegates that to a different
thread
so yeah that was all of it from
hopefully that was quite good if you got
any questions feel free to reach out on
Twitter and I will be happy to answer
your questions
all right thanks time awesome
all right
you want to stop sharing your screen and
turn your video back on we do have a few
questions here before we can go through
these quick all right so Jack asked so
you essentially set up your callback
functions in your parent component ie
the chat component in this example is
this to mainly keep your function
centralized or is there another reason
to do this
are these in the thing I can see are
they in a different thread ah there's a
QA thing I don't know if everyone can
see that oh yeah there's a button of my
help like brassy yeah give me a second
but see essentially serving function is
a very grand are you the tractor in this
example yes I be hopefully in algebra
the other half just in case and so the
idea is the trying to explain it in a a
fun way
let's just assume I had a tennis ball
for example and I I'm the controller of
the tennis ball so I gotta throw the
tennis ball and somebody's going to hit
it back to me and it's going to hit me
in the face when when it gets back so
that that point where it hits me in the
face is my callback so something is then
come back and told me so that's the idea
and it if you keep your components like
a stateful components or I'm just
pulling wire pulling out my ear so if
you keep your components like focused
like they fishin typically have too many
functions because you can then break it
down into another layer so if your cool
bags rely on something like a get
request or a put request or a post
request so let's just keep it simple and
say a to do list my to-do list callbacks
when I edit it to do or delete it to do
list the callbacks for those would live
in the parent because the parent is the
communicator with the service so it can
then throw the tennis ball off to the
server and then get the response back so
that's the idea is that everything is
controlled in one place so yet it would
keep them centralized in the particular
component
yeah yeah I would agree to like this is
a is a pretty common pattern and react
from what I've seen and used to and I
really like it like it just allows you
to kind of keep that the knowledge of
you know whatever state you're kind of
tracking the parent component it can all
be and you can yeah
so maybe not as much on this talk but
maybe angular in general Moz asked what
is the state of styling in angular and
react we're seeing increase in the use
of CSS modules and libraries like style
components which which max is actually
going to speak later in the week
is there some component style
encapsulation like officially promoted
by angular so it's kind of an
interesting one if you've played around
with I expect most people have used sass
or at least played around with sass or
less or something like this so to start
with you can use sattell des with with
angular but it's it's the point of
getting it into a component and then
doing something useful with it so
essentially I was that the question
disappeared we'll just moved it moved I
think one was an akai let me scroll up
I'm just looking at it while I speak um
so let's assume that we've just got
styles it can be less sass CSS driven
whatever sass driven not CSS driven it's
obvious it can be compiled but it's then
what does angular do at the point of
compilation say there's essentially
three different things that we can do we
call this view encapsulation so if you
use shadow Dom or played around with
shadow Dom you can essentially embed a
Dom within the DOM and the Dom that it
embeds is completely new so it doesn't
inherit like let's say you had a as
background read and then you had a div
inside your shadow Dom with a as a class
name those would not communicate with
each other so the first one is no
encapsulation so let's say in reacts you
could say I don't want to encapsulate
this component it's going to be sharing
its styles globally that's one option
we also have I'll start with the native
shadow Dom because it's easier to
understand there emulated so you can
either trip switch just say I want to
use native shadow Dom if you're focusing
on browsers the of very new obviously
the spec not specs changing their
support for
the spec is changing I'm not sure what
the full status is on shadow Dom I think
it might be pretty well supported at the
moment I don't think there's any
browsers but particularly lagging you
can say I want to use completely native
shadow Dom and in angular's components
where uses these property bindings and
it does this because it can bind to web
components shadowed on this kind of
thing it will basically transform your
styles and embed them in the shadow Dom
so this is just gives you full
encapsulation without using a library or
anything like this and then the emulated
mode is where is currently the default
so this might change in a few years so
the emulated mode will basically rewrite
so you can I think with reacted create
there's different ways of doing styles
but let's say we basically can use a
sass file
or you can do styles and then write them
in a string so angular compiler will
basically rewrite them the Styles like
let's say you did dot hello as the class
name it would do it would rewrite it to
dot hello and then it would do square
bracket and then a random hash key so it
creates an attribute on the element and
it revised styles for you so it emulates
the fact that they are encapsulated and
it does assume uniquely po component so
it's not your styles are never going to
clash so it keeps them very clean and
you've also got I don't know how long
it'll be till everyone's using native
shadow Dom but when we're there I'm sure
they'll flick the switch to be shadow
Dom first over emulated and then remove
tons of code from the compiler nice all
right
I'm actually gonna skip the next one
we'll come back to it if we still have
time so Chris asked Ken components and
global events same as route scope
broadcast angular one for example how
would you communicate all your
components that authentication has
expired yes so does there's no route
scope emit or broadcast in angular
negative 2 onwards and so in angular 1
we basically had this idea of scopes and
the encapsulation would be done by
escapes not styles but data and stuff
like this so you create an isolate scope
and then you could basically use the
root scope emit so then ping an event
either up one component or whatever is
listening to it so this is the the
pub/sub way of getting around an angular
1 app in angular 2 and onwards the
dependency injection is much much nicer
it's observable based so you've
basically got rxjs baked into the core
and you can just a dependency inject and
subscribe to the state changes so let's
say I had an authentication service I
would set up some kind of subject or
behavior that can like fire was a good
angularfire to if you check out the
source code to this you can basically
subscribe to the earth state so you can
create your own subject and emit these
changes if you're not using firebase and
then in multiple components probably
state four components you would inject
that service to say our email full email
client injects the all state here here
and here for example you would then
listen you can see these just subscribe
to the changes so if the all state
changes there's so much more you can do
as well with like routing so you can
create a routing guard and if your all
state changes it will just redirect you
to somewhere else if you try and
navigate throughout the app so yeah
there's no route scope broadcast and
emit they were okay if you kind of
needed to dig yourself out of a hole but
in
a 1 there is the dock component API and
that makes this architecture decisions a
lot easier which is pretty new I think
that's in the last year and three months
the component api's been there
Thanks
next question was anonymous actually
debug workflow tools if the angular is
compiled compressed and delivered
locally
you mean browser gee thinkers clients oh
yeah that's I'm yeah my maybe my
question here is like what does he mean
like compounding press that would be
more production right yeah yeah
deliberately yeah I would have seemed
like I guess just maybe talk about like
what kind of debugging tools you get bug
in workflows so there's I mentioned the
ahead of time which we call a ot that
the a ot compiler which is there ahead
of time compiler
basically outputs compiled code so what
I was showing with like import this from
here and act component is not what is
delivered to the client so it's the the
a you can deliver it to the client if
but you want to compile the JavaScript
at least the typescript to JavaScript at
least however you can take an extra step
which is the äôt so what I tend to do
like for debugging workflow you can look
at the compiled output for the äôt
stuff so excuse rude hiccups so you can
look at the source code in github for
angular you say okay I've got this weird
box when you look at the function that
is causing the bug and you could look at
the compiled output and then match it
against the source code to see or try
try and see where something's coming
from and there's I think a not sure how
you pronounce it or Guri Guri one of the
two aug you are why i think is spelt
which is a chrome extension for
debugging angular apps which is useful
for check it out I think that's pretty
much the thing covered in typescript is
the biggest debugging workflow tool that
you can use so I was really against
typescript because I didn't know it and
then I started using typescript I was
like how have I ever not using
typescript so and me and my friend who
were kind of against typescript because
we didn't know it we're just like every
week we're like I can't believe we
didn't like typescript okay so it's kind
of kind of grim but once it one is one
side script clicks it's it's super finis
it's basically like a spellcheck like
the amount of times you spell something
wrong or a property name wrong for
example or just an import or a string or
type you go back to the browser and you
recompile a whole lot and then you
forgot to spell that right so it
basically just underlines the whole
thing in red it's like this does not
even exist so you know hey oh yeah
the type scripts probably the number one
definitely all right we'll take this one
as the last question and I'm coming
curious to because I'm playing with next
is have you seen that uh one on the
website but I didn't look any further in
terms of using it so one of the like
they're two big things are one that they
do service on rendering the other is
that they have web worker built-in that
will do like prefetch data for later
links that are on the page that go to
the same app and so it'll grab that data
ahead of time so that when the page
loads up its memory it loads it so
anyway that's one of the I liked I
really like that that web worker piece
that they have going on Brian asked can
you go more into what angular people
plan to do with web workers building
those in the framework could be really
powerful yes I think the web workers
support started off as a Google intern I
think they would I think this is a story
that they were asked to basically come
up with some kind of web worker
implementation and then they got to work
in and realized the benefits of doing so
probably similar to next I'm going to
flick across to the docs real quick
because there's our the API reference
Doc's API reference so the API reference
is actually really nice if I type web
workers there we go I can't share this
anyway if you go on angular Daioh and
then click on Doc's on the left hand
side by says a guy reference then you
can type into a search box I think if I
can link bother showing screen so
essentially you can type and filter the
whole API reference if you type in web
work or a platform web worker you can
basically see where we go up 6 12 18
different API s and then they've got the
bootstrapping
web workers dynamic for local dev if you
click on one of them yeah there's still
experimental so most of these if not all
of them I think are fully experimental
API so these may be subject to change
but you can go ahead and use them now
what you will say she need to do is
bootstrap your application in a web
worker rather than in the Dom as such
and you basically use the message bus
which you'll see
message burst yeah there we go
message bar says low level API used to
communicate between the UI and the
background say excuse me whilst the
other blonde
No
you
there we go that it doesn't have any
documentation this kind this kind of raw
at the moment say there you can you can
still use it and there are examples
online of how to be strapped in a web
worker but it's until basically because
it's experimental they can change it or
deprecated it or change it in any
versions like well I think the new
strategy versioning is like one ahead so
if they did if they deprecated something
could be removed in the next major
release so anything that's experimental
it's probably smart not to go too crazy
on until it is stable and all that if
the API Docs will have stable
experimental etc in the top
all right well thank you Todd we have to
get to the next session I did put a link
in the sidebar and if you're not in the
Select chat let me know because the
links are also in there you should have
new email and will be listening to Lynne
Clark talked about webassembly
with her cartoons which I'm super ton
and again you can see Todd's name on the
picture there his Twitter handle is
exactly the same
I didn't even notice that until now so
yeah nice alright guys see you like to
thank you
this video has been in space dojo
production you can click to learn more
button to find out more about
asset-based dojo comm or in quiz the
subscribe button to get notified about
new videos we put out each week thanks
for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>