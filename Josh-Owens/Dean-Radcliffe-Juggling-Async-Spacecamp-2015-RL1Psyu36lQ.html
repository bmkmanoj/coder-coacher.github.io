<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dean Radcliffe - Juggling Async - Spacecamp 2015 | Coder Coacher - Coaching Coders</title><meta content="Dean Radcliffe - Juggling Async - Spacecamp 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Josh-Owens/">Josh Owens</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dean Radcliffe - Juggling Async - Spacecamp 2015</b></h2><h5 class="post__date">2015-12-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RL1Psyu36lQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the meteor Space Camp 2015
video series these were a series of
videos recorded in the mountains of
gatlinburg tennessee during the meteor
space camp 2015 event that was held in
october if you're interested in more
information please check out meteor
space camp also big thank you to our
sponsors our gold sponsors were modulus
you can find them at modulus io for all
your hosting needs whether that be
meteor or node or PHP they can handle
all that for you easily modulus I oh and
also okay grow calm if you need to have
an application built okay grow is the
place to get it done give them give them
a shout over it okay grow calm and also
a meteor club you can sign up and join
me to club at meteor Jas club it's a
weekly email you get tips and tricks
about meteor and other relevant news so
if you're interested in that check it
out meteor jazz club and also compose
our Silver Sponsor composed I oh they're
a great place to host your database and
take care of any database needs you may
have whether that's Mongo or
elasticsearch or any number of platforms
that they're supporting now I use them
for all my production stuff so I highly
recommend it composed on Io thanks Josh
thanks everyone for being here it's
exciting other than missing my chance to
run off and join the circus this is like
the most awesome place I could imagine
being and I'm Dean Radcliffe I go by
genius in the slack chatroom and genius
dev on Twitter because someone else took
Dean yes I suppose my company's d Gnaeus
solutions and I'm going to talk about
juggling a sink and JavaScript this is
gonna recycle a little bit of content
that was about promises but I got I got
tired of talking only about promises
versus callback and the fact is there's
been so many new kinds of a sink
that have come up that I thought I'd in
instead of going like depth-first into
promises and stuff I thought I would do
a whirlwind tour of all the other
options that you that you've got so you
know we're going to talk about a sink so
we should first talk about what sink
synchronicity actually is we all might
remember right me remember that album
but uh before I continue any further
there's actually someone here that I you
know it was on national television
recently and I wanted to ask you Matt
which would you sign this for me all
right so you notice I didn't say
anything while I gave him the ball to
sign right and I I didn't proceed with
the presentation I didn't do any witty
banter I just waited till it came back
to me that's synchronicity that's
synchronous program and so you know just
basically anytime you're waiting on a
results you're doing synchronous
programming now any synchronous
programming has a lot of other options
and the first one that came to be in the
JavaScript community was callbacks and
then there are also promises and
reactivity is a form of a sink
programming as well and fibers also help
you do a sink and also generators have
come along with es6 and they're pretty
cool and so how do you make sense of all
of these options well how do you juggle
all of these options that's what i meant
to say and basically that's what i want
to explain using juggling as the
metaphor right because very often you
you you want to be doing something but
your hand is
tied right so in order for me to do
something else with my right hand so
here I'm doing this with my right hand
and in order for me to do something else
with my right hand I have to throw it
out of the way that I can grab another
another object and that is a sink so
you've seen juggling before right and
things happen so fast that you think
that there's a lot of things going on at
once but if I slow this down a little
bit you see there's basically one
operation going on and then you're just
switching back and forth between
operations so this is what the v8 engine
that runs in node and that runs in your
browser does it actually just alternates
tasks but does so rapidly so that it's
smooth so this contrasts with the idea
of one thread of execution is going
switching between things and then the
other thing is just independently going
around for the ride or doing something
completely not see like that now that's
multi-threaded programming and we're not
we're not talking about that although
there are ways to make that happen in in
meteor so where did we start in this
well we started with callbacks and a
callback is a function that may
eventually be called can I can i call
upon another person to help me here
you're closest so yeah I know it had to
have that cool short too so all right so
in order to free myself up I'm going to
toss this to you so the now I can like
you know advance to the next slide and
now can I have that back and then so he
calls me back right so I've been able to
free myself up by starting something so
that's like an AJAX request where I
begin an operation then i'm free to do
some other things and it comes back and
when javascript first started it had to
have at least two ways of doing
callbacks set timeouts and event
listeners and both of these kind of
throw some action into the future to be
completed in the first case where the
it's separated by a predictable amount
of time and in the second case where the
user is going to trigger something and
you need to do something once the user
after
so that's an eventual operation now
notice that like at the time that you do
document.addeventlistener and they're
going to click on something at the time
that you hook up that event listener you
can't know what they've clicked on right
so that's the that's where you're not
waiting for a return value from the user
so much as you're providing something to
happen once that occurs so here's a pop
quiz about event listeners everyone's
use them I'm sure so there are three
ways of setting up events for when the
document is ready right so this jquery
document out ready or the other syntax
of that is you know the actual raw event
is Dom content loaded so the question
here is if this document running this
code is already loaded which ones which
one or ones of these will actually run
the call back so what I'm not showing is
that there would be a call back in this
position there document ready and then a
function and then on ready does anyone
want to hazard a guess I wouldn't want
to hazard a guess you've seen the
presentation Paul no fair so so I don't
want to hazard a guess so I'll tell you
that only this one only this one would
run your call back if the document is
already loaded and that's kind of
non-intuitive right but there's a reason
for it and what's that reason well
you're adding the event listener after
something has happened and so if it's
already happened then and you haven't
added that event listener yet well then
your event listener or doesn't get
called so however this one in the middle
which for some reason doesn't behave
like the others I like it but it's kind
of an oddball it behaves like a promise
so in a promise you just want to say
once the thing has loaded and if it's
loaded already then just fire it off
right away so promises abstract around
exact points in time it doesn't matter
when you register your event listen
it's just once it's happened even if it
hasn't happened yet go ahead and fire
stuff off so if you had a promise for
the Dom content being loaded well the
way that you talk to a promise is you
chain a function it's not a call back
but it functions like a call back onto
the promise with dot then and what this
will do is it will return immediately a
promise now if your document is already
loaded your promise we'll be in the
resolved state and then the tiniest
tiniest amount of time will elapse
that's this dotted line showing another
turn of the event loop and then it will
print I'm ready so if your documents
already ready then attaching something
for to a promise for it being ready
we'll run it just about as soon as
possible if it isn't ready yet well use
the same interface and you know that
it'll get called eventually but you what
you is returned right away is a promise
in the pending state and then some time
goes by and then some time goes by and
then it has loaded and you have your
function being run so callbacks are
everywhere for sure and the we treat
them as though there is a contract about
how how they're used and in fact there's
naught but a lot of times you'll look at
a callback that looks like this the
first parameter is an error object and
the second parameter is a result object
and and what are what are you supposed
to do when you get this function the
first the first line you write is if
error console dot log error because you
know that's that's the way you handle
errors is just log Batman returned from
the function so we we've used this right
before everyone's use something like
this I know all the lot of the meteor
methods are set up to take callbacks
like this and you're never supposed to
get an error and a result right we kind
of maybe know that as a rule but maybe
you've never seen it written down as a
rule and also the error you know we do a
test for if err
so we know that the error supposed to be
truth II but the error should be an
instance of capital e error that
JavaScript type because that has stack
traces associated with it and other cool
goodness but if you're a library author
you might not know some of these rules
right you might you might violate these
rules and there's actually a lot of
other rules that I won't bore you with
by going into too much detail but you
should know that that when you're
dealing with callbacks you're dealing
with an informal contract and one that
callback even if your document is loaded
already and and someone gives you a call
back it would be nice if you were
consistent about whether you execute
that function on this turn of the event
loop or a later turn of the event loop
most callback libraries will execute
your call back later even if it could
execute it now but it's not guaranteed
can lead to some unusual edge cases and
there are some conventions about
callbacks being placed in the last
position you know like with meteor call
you do the method name and some
arguments i'm going to call back at the
very end but not every function that
takes callbacks necessarily follows that
convention and then if your callback
function actually returns a value most
of you wouldn't do that you just want to
handle the result but if you return
something out of that its proper form to
ignore it and error handling is crazy
and for all these reasons you shouldn't
use callbacks when at all possible and
i'll show you how to avoid them being
the reason being that the promise
specification specifies exactly how
these be it enforces it not only
specifies but it enforces that some of
these things occur the real reason is
that we don't want to write buggy code
right we want to check for and propagate
errors correctly and this example which
may be too small for those of you way in
the back row about five feet away can
barely see what's on the screen but this
is a function called do a sync stuff
that calls the function do stuff one
which is a sink and
then do stuff to which is also a sink
and in order to make that chain
completely airtight where you handle
both types of errors the errors where ER
r is an object and you call back right
away or the errors that you know are
try-catch synchronous kinds of errors
you need these this many lines to
actually be error tight and that's about
14 lines and you totally lose the signal
in the noise of this right like what are
the two things that are being done so
enter promises the second of the five
types of a sink that we're going to talk
about and what's right with promises
well that 14 line example boils down to
exactly this with promises it's just as
error as just as error proof this is
airtight as what I mean to say and it's
very very clear that you do stuff 1 then
do stuff too and what's really nice is
that you can consolidate the error
handling for the entire chain at the end
right no more if error console dot log
just you know put a robust error
handling function at the end of that
maybe even share that error handling
function and it doesn't commingle your
error handling code with your result
you're happy path code and the same
method so yeah yeah it can represent an
entire chain of events a promise can
with branching possibilities so suppose
that after the first step of a chain
occurs you have to decide between
whether you're going one route or
another route so like is the cache
warmed for example well this chain you
can return conditionally from one step
in the chain and if I you know draw this
out visually I wish I could have a
juggling pattern that invited that but
like you have a flowchart that this that
this linear chain represents a flowchart
with branching and then at the very end
you can await all steps so promises are
asynchronous
and so your code might not have the
result of them but if you want to
actually wait until all of those promise
steps have been done you can use
something that's new and meteor 1.2 with
the ACMA script 6 support Kyle promise
that await and I'll show a more
elaborate example so another great thing
about promises is that they give you
ways to combine eventualities so
combinatorics so kind of like jQuery is
really nice when you're querying the DOM
and you can like drill down and then
call dot parent and drove back up and
then drill back down again once you're
in jQuery land everything goes really
smoothly we have some really nice
combinatorics functions that are part of
of jQuery for that and promises gives
you a few very neat combinatorics
functions that I want to call out as
well promise dot race takes one or make
takes multiple promises and returns a
promise for the first one to complete so
it's just like a race we head out the
door and that can be really useful for
timeouts right so suppose you never want
your user waiting longer than two
thousand milliseconds two seconds for an
operation to complete and if every
operation is a is a you know is
represented by a promise well then at
each step of that chain you can race a
two thousand millisecond time out and
the eventual async action and as long as
you're a sink action occurs first you'll
remain on that happy pat but race is
just like using math.min on the amount
of time that it takes to complete for a
thing promise that all takes an array of
promises and gives you a promise for the
array of results so it necessarily has
to basically do math.max it has to wait
until the longest-running promise has
completed so that your array can be
fully populated so it maps an array of
promises to an array of results once
they've all completed
and then that promised daughter wait is
like thread join if you've done
multi-threaded programming where you
start off a thread and you need to wait
you need to then join the threads of
execution back together here's a visual
for that so um yeah they're very cool um
I thought I yeah still so still going so
yeah basically still going on these
promises each step in the chain just
like in jQuery like you combine your
selections the chain when you've done
that then that then this chain now
represents the completion of all of
these and so I had some baseball
examples before but now the cubs lost to
the Mets sorry so yeah so any any
eventualities can happen there yeah oh
no here here's the actual what I wanted
to illustrate so currently i'm in this
error handling branch of the promise
there yeah so yeah what they really let
you do is you know basically deal with
accept exceptions with impunity all
right so any exception that gets thrown
neer our object that gets populated the
promise sweet will handle it and you can
just tack a catch on at the end to
handle errors for the whole chain all
right now I've got a quiz what is that a
sink cat I finally got actual cat jokes
I'm not just incorporating them by
reference anymore all right so uh
meteors all about reactivity right so
meteors reactivity is probably why we
love it
and it's also a form of a sink and so I
want to show you that a lot of things
that can be done with promises can be
done with reactivity and and vice versa
so this is the third kind of programming
with a sink and so here's an example
that you might use reactivity for where
you have to reactive ours and of course
i'm using this new es6 notation but i
think you'll recognize it just the same
and you want to keep a VAR called
uppercase and sync with the VAR called
lowercase so you just declare them you
know / ends are optional for
constructors I learned that was kind of
neat and if you wanted to keep them in
sync you could use an autorun that says
get the lowercase value and set the
upper case to the uppercase version of
that and of course this lets us allow
assuming that the change comes in to the
lower case far tracker will keep track
of what which functions to rerun and it
will rerun and keep your upper case this
is very nice if you have no idea which
functions or which parts of your program
might be changing this lower case VAR if
you have this tracker auto on it doesn't
matter which parts of your program are
changing it it'll just do it for you but
another version of this if that's set on
a reactive are returned to promise and
if you were only doing this and maybe
one part of your program you could just
say lower case set then with that lower
case value that comes out of that you
could call upper case set so these will
actually perform exactly identically
right so I don't think promises and
reactivity they don't fight each other
right these just these ways just have to
juggle between them sometimes to get the
most expressive form for you and
sometimes it will be reactivity and
sometimes you'll just want to do
something this way another example that
I'll show later is like subscription
handles right like when you subscribe
you have a dot ready method you can call
and you can use reactivity to like you
know write a function that gets rerun
when the subscription is ready but I
also show you that you can just directly
call you know a function called ready
promise and then change something on to
that if it feels more like you want to
do it that way then go right ahead so
can promises invalidate computations oh
yeah they can through a package called
genious promise which adds a bunch of
promise helpers to your meteor methods
that there's a little monkey patching
going on I think nice people create
libraries that export their own Global's
and cruel lazy people just monkey patch
things into media objects and hope a
pull request will be merged and you wait
in vain like waiting for the cubs to win
the World Series but if you wanted to do
something like this like have a helper
that calls a server-side method let's
call it add with sleep and does two
passes two arguments can you use
promises with helpers and I know a few
people have tried in vain to do it with
you know just raw reactivity because
this is what you try you declare your
helpers and you want to use a method
like meteor call promise he slides are a
little bit out of order because I just
you know redid this very recently but
meteor call promise is the new way if
you're using genious promise to make a
meteor call but instead of passing a
call back it returns a promise for the
result so number one if you're doing a
meteor call and a helper don't do that
change it to a meteor call promise and
then but even still you'll be stuck
because the the way reactivity works is
it wants a synchronous value here and
when this computation gets invalidated
it'll rerun this function and that
synchronous value will change but
promises and other async stuff and
helpers they break that so if you've
ever been here anyone been here we are
trying to call
a method and well won't be too helpful
for you but if you do ever get there you
can basically wrap that function and
something called reactive promise and
then the body can return a promise out
of there and there's a few other things
that you need to pass it because a
promise has has 3 states it has a
pending state before you know whether it
has been resolved or rejected and so you
need to provide something for this
function to return before the server
call has come back and you can also
provide an error condition to an error
text or something to return from this
function if your ear call ends up
erroring out so reactive promise is just
a little like a decorator that allows
your helpers to to basically work with
async stuff better which brings us to
the fourth kind of a sink which is
fibers and you might have seen fibers in
meteor da trap a sink so particularly if
you're using a third-party library that
accepts callbacks and the same kind of
trouble that you get into on the client
side trying to use async in helpers well
media recognized pretty immediately that
you run into that same problem on the
server side if you're trying to use
async things and so they provided this
meteor da trap async library which is
well documented on meteor site and I
think a lot of people know about it by
now but I will explain something also
that that is similar to that but it's
using returning a promise from a meteor
method right so I don't like call back
so i'm going to show you like the
promises way of doing it and you might
have heard that you can return a promise
from a meteor method so i'll show you
step by step with that what that might
look like and the etymology of this
really is like it's not like you're
returning you're actually returning a
promise from
method and the client side receives a
promise it's not like here you return an
object you get an object you return a
promise you get a promise it's not like
that at all to return a promise from a
method means to return an eventual value
from the method which means eventually
return a value so what's going across
the wire is not a promise but some kind
of Valley so let's say that we had a
meteor method again this is the es6
syntax but you probably won't miss the
colons or semicolons it's just an object
literal that you know when someone calls
this meteor method they're going to
receive the time five seconds from now
in the future it's a method called
future time so remember you're going to
be doing something a sink and promise
dot await will wrap something a sink in
a fiber so that it can synchronously be
returned from the method so we start out
with the promise that awake and that is
not part of my library this is something
in the promised library that meteor now
ships so now we need a promise to a
weight upon so we call a new promise and
we give it a function and the function
kind of career it receives an argument
but I like to say that it creates a
scope with the word resolve in it and it
can also contain the word reject to do
error handling and so inside here you
can have any kind of callback code that
you want and all you have to do is
somewhere deep in your nested callback
pyramid of doom just call resolve or
call reject and you'll be all good so
let's use a simple example of set
timeout so 55 seconds from now it's
going to say hey it's the future and
it's then it's going to create the date
and then it's going to pass that to
resolve so can you see that this method
will take five seconds to complete but
of course your client won't be blocking
and and neither will your server be
blocking because fibers and and then
this will return
a new date and then in fact the reason
they talked about returning a promise
from a method is that you although i
think this eight promised out a weight
is handy for thinking about it you don't
actually need promise that await their
like it's part of the framework now so
if your if your method returns a promise
the meteor side of it will automatically
oh wait the promise for you all right
the fifth kind which doesn't have a
slide for it and this will be just
amazing if I can do this ah the fifth
kind of a synchronicity is generators
and has anyone seen this function star
syntax from es6 and wondered what the
heck it's good for like are we going
back to see see and function pointers
and things like that well this is a
generator and a generator as a function
that called yield and generators are
they work with es6 and therefore they
work in media and in CoffeeScript for
those fans of CoffeeScript you just did
the presence of the word yield in there
it gets turned into a generator function
for you so if you are I showed you the
way of chaining promises promised one
then promised to n promise three well if
you've been using fibers fibers are very
cool but they only work on the server so
having something like generators and
yields that can chain promises together
on the client and server the same way I
think are very cool so this is the
newest addition to the genius promise
package and I define this function run a
sink not wrap a sink but run a sink and
it takes a generator and imagine that we
call a server-side method well with call
promise you have a promise for that
server side method but if you want to be
able to capture that result into a
variable right like waiting for the ball
to come back
with a signature on it if you want to be
able to adjust assign that to a variable
you need to put it in a generator and
use the yield keyword and then this
whole promise dot a waiting thing will
happen behind the scenes for you so then
let's say that there's a function a bit
later that you know little later just
returns a value so you that's fine you
can combine a promise for that value to
and then just assign this to a result
just by calling a server-side method so
these are promises that are chaining and
then you get a promise for the entire
result of the generator so whatever the
return value is since any of these can
be a sink if you actually want to
capture the very last thing that the
generator returns you have to attack a
promise on to the end of that but but
how's that for you know writing your
code and synchronous style I'm the
client and on the server I think it's
pretty cool so you know long short you
can convert back and forth between a
sink Styles meteor wrap a sink is server
only it converts between callback code
and fiber based code there's something
that's in the promised package not mine
the meteor promise package called
promise d notify and notify assumes a
function that takes a call back in the
last position Saudi notify is turns that
call back we're taking function into a
promise returning function you can use
that anywhere reactive promise that I
showed you lets you deal with a promise
method and you know invalidate
computations and use it in helpers and
and such on the server that's the
reactive promise method and then these
two below are from the the promise
library that I've made meteor run a sink
lets you take a generator and get a
promise for it in addition you're
writing in a synchronous style and
that's pretty cool so you know long and
the short of it is that there are at
least five options these are not not
even the sum total of all the options
but there is more than one way to do it
people know Tim Tim toady cool get cool
guy Tim toady there's more than one way
to do it and you know use the style that
most fits the programming thing you have
I know it's a lot to keep in your head
it's like at least five options and it
can be kind of confusing but the truth
is five is five is not too many and you
don't have to use them all at once but
it is possible to do it so here we go oh
wait and you know exceptions occur oh
Jesus Christ third time's a charm hey
thank you very much all right let's take
some questions all right promises are
awesome and so are you thank you very
much I'm Dean read by me adding yourself
Oh the question is if I've used Bluebird
promises library no I haven't i've used
one called q no justjust q capital Q and
the thing is most promise libraries
interoperate fairly well right so they
might give you more you know promise
race promise all they'd probably give
you more of those Combinator's to do
more advanced stuff they probably also
define their special you know promise
implementation but because there's a
specification you should be able to like
take a bluebird promise and you know
pass it into any one of those other
functions in and it should interoperate
pretty nicely but I haven't used that
particular one any
all right ah yes I don't know I haven't
actually gotten there yet I was just
thrilled that it worked and if it
doesn't if it doesn't work for you you
know like let me know try it out someone
showed me Highland jayesh remind me what
that is though a high level streams like
right right I am intrigued by this
streams oriented approach that are xjs
and and highland implement but I haven't
worked with it that looks as huge on it
and it's very powerful it does some
things you know in theory even nicer
than promises Dave and I were talking
about either using doing a little
hacking on that this weekend to bring
our xjs in for example and I want to
talk to you about it suks i can imagine
like a stream of DDP messages being like
exposed as something that you can like
filter on maybe that would be useful
right
yeah you know you like and actually
instantiate a million length 1 million
like array iterate to array right yeah
great it's just like here are you
basically like so run a sink is a
function app run every time you lose
actually return it is returning yeah it
is returning a value so there's a
there's you know an illustration of this
that I wanted to do when the fibers I
forgot with something for that fibers
live demo right so so it's all about
context switching right so over here no
no this is this is everywhere right you
can know this doesn't use fibers it
receives promises right so so basically
imagine that there's some synchronous
code above this this bar out one right
so the browser is sitting there running
this synchronous code right here and
then it gets to yield meteor call
promise so it puts that down right and
then it does the work of you know
calling the promise over there and then
it juggles another call stack of
execution right it receives the promise
and then it puts that down and it goes
back and so there's an NPM library
called Co that this this run anything is
a thin wrapper around CO and so what
that what that does is each time it gets
a promise back
this your runny Sigma it expects
promises and uses the generator right
correct yeah yeah you can you can't like
the Fibonacci sequence like you can
write a generator that yeah and i found
it i didn't like invent it or write i
just pulled it out of the npm ecosystem
because there's haha
alright thanks everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>