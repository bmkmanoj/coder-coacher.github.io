<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cincinnati Meteor Meetup - September 2015 | Coder Coacher - Coaching Coders</title><meta content="Cincinnati Meteor Meetup - September 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Josh-Owens/">Josh Owens</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cincinnati Meteor Meetup - September 2015</b></h2><h5 class="post__date">2015-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rz2TskUGrYU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yep the air at the front of the room
yeah you're you're broadcasting the
phone room so welcome everyone to the
September edition of the Cincinnati
meteor meet up I one of the
co-organizers josh owens we invited Dean
Radcliffe to speak about promises and
drink beer on camera here Cincinnati um
yeah so I I think you can go ahead and
get started whenever you want to share
your screen and you know we'll watch
your slides and like I said your get up
on the the screen up there there I am Oh
guys so just so i can tell like like the
latency and stuff and so that we can
like think the beginning of the of the
video with audio we're gonna do a one
two three clap okay so everyone ready
for that okay one two three that was
better than Toronto nice and i was there
in person at toronto uh alright thanks
everyone also since i can't see your
faces i'll be i'll shout out to josh
okay so if i have any like questions all
I kind of single Josh out a little bit
just so that that goes smoothly alright
so let's way to do this here uh I guess
I can do entire screen and then you see
this presentation and then I go
fullscreen and are we good hello yeah
we're good okay lots of big bold so
hello everybody this is my first remote
presentation but since josh and i have
been doing things remote for quite some
time i'm sure it'll go
just as well as those podcasts and such
I hope you enjoy those if you see them
I'm Dean Radcliffe I work with okay grow
which is company that Paul down man a
bench Strahan work at and I really enjoy
doing meteor full time and I'm here to
talk about promises which I call the
unsung heroes of a sink in JavaScript I
can't ask for a show of hands perhaps
some kind of noise if you've used
promises before like a few people okay
one more one beautiful well I'll get
into the whys and hows of them perhaps
even a little more in depth than you may
have thought about them if you've just
used them casually but first I think
it's important to kind of know how to
think about promises and promises are in
maybe a strange JavaScript concept or
media or concept to people but we we use
them all the time in daily life so
here's a scenario of a promise in which
i bet you Josh hypothetically bet you
twenty dollars that the Reds won't beat
the Cubs at all this season the Cubs
will not lose to the Reds this season uh
anyone a baseball fan wanna want to see
whether they take this bet or not well I
happen huh someone says inhibit hahaha
and I don't know why you might take it
that's why I called it a hypothetical
that but why would you take it and who
who said that um Bruce Bruce why would
you take the back just cuz almost it's
almost 5050 via charley horses
yeah can you hear in fact I take place
and there's a cubs reds game tonight
that's kind of interesting coincidence
kind of making that cincy Chicago
connection stronger so this is a bet
there's nothing strange or unfamiliar
about making a bet like this and what it
means is that we're waiting for an
eventualities to it may have happened
already in this case in fact it has
happened already but um we're upon some
eventualities kering an action is going
to take place so um in fact if I were to
take this bed I'd lose my money right
away but these are the two promises that
are going on in plain English the season
begins then the cubs lose to the Reds
and then the season ends and I have to
pay you or the season begins it ends and
there hasn't been a loss in the middle
in which case you pay me so promises
exists to clarify certain semantic
problems that can occur when you make
bets like this for example if Cincinnati
had already lost it would or if she
comes had already lost to Cincinnati
what would happen to our bet and if what
we're really betting on is the top
sequence of events to happen then I have
to pay you because you can prove to me
by showing me this record that
regardless of the date that we made our
bet there was the beginning of the
season and then a loss to Cincinnati and
and then the end of the season so think
about promises as as bets that may
already be a lost cause so if we really
want to make this interesting this very
top line here time Chicago shutout
Cincinnati one so far times the other
way happened 0 so we could we could make
a bet that would be more interesting bet
if we bet on something that hasn't
concluded yet but uh there you go and
it's not quite 5050
but I'm actually not a huge baseball fan
so I'm not trying to like say anything
about about that just the Cubs happen to
be having a good season which is kind of
remarkable so that's basically the
nature of promises they are events but
they can occur at any point in time so
they may have occurred in the past and
when you can make something contingent
upon a promise what that means is that
thing like for example the payment has
to happen ASAP if it's already been
decided right so if someone shows me
that my bets already lost I don't have
any reason for postponing I mean if I'm
finishing my lunch maybe you'll let me
finish my lunch but then I have to pay
you um if it hasn't happened already a
promise represents the soonest possible
moment once it happens so that's one way
to think about promises as events they
also can serve as values so for example
the the value of the win-loss record
once a loss occurs you can create a
promise for that value which kind of
comes along with an event occurring but
the value may already be known it may be
being computed right away in this turn
of the event loop and I'll mention a
little more about the event look later
or it may be unknowable so a promise can
be set up for maybe we make a promise
for man settles on Mars well if we
really want we can do make a promise
upon that but we may want to combine it
with a time out just in case you know
this doesn't happen in either of our
lifetimes we might want to place a a
bounding box on it but that's a
irrespective of whether you're using a
promise or not you can you can make a
promise for that happening even if it
may never happen so the neat thing is
that a promise can represent an entire
chain of events including branching
possibilities so while you ponder the
code on this slide I'm not going to read
it
allowed it does use es6 function syntax
so that's just like regular functions
except without the word function and
without / ends in this case and without
the word return so here is a chain of
things that will do something
conditional in the second step and I
like to compare promises to jquery this
is my new favorite analogy so when
you're using jquery to select some Dom
elements and then you drill down and
then you drill down a little bit more
then you go up to the parent everything
is just really smooth you can just keep
chaining on things with promises you
chain on actions and everything is
really nice as long as you keep using
the return value from the previous thing
so in this case we kick off with a
promise for the first step we create a
new variable all steps that is this
entire series of steps and then using
some magic will talk about later we can
say promised out of weight all steps and
then make sure that the lines of code
the hypothetical lines of code below
promised out of weight all steps don't
run until we have every single step in
that chain completing any questions on
this all right I will move on and maybe
save questions for the end since it's
hard to to gauge am I still connected to
the audio here yeah okay great all right
so one or more conditions or actions
going back full screen all right so what
does our bet look like in promises well
what I really like here is line to
promise dot race and then two arguments
clubs lose two reds or the season ends
so we can think about the two promises
we made earlier the two halves of the
bet and we can see what we're really
racing is
whether the season ends first or Cubs
loose to read so just like jQuery has
really neat ways to combine Dom
selection the promise epi has really
nice ways to to do things like promised
race or promise at all and so we can
begin the season and and that's a
function call that returns a promise and
then chain on a race between Cubs lose
two Reds and season ends and then based
on whether the value that we get is true
the or falsity we can trigger the I pay
you or you pay me so in these examples
all the function calls returned promises
and in order to set something like this
that works the cubs lose event should
return truthy the season and should
return false e or throw or reject and we
can talk about those other things that
promises do when you know an exception
is thrown but that's basically it you're
erasing to eventualities and creating a
chain for for all of them happening so
really with this nice almost jquery like
api for a sink i think that they're the
unsung heroes of a sink meteors
reactivity is we already know how
wonderful that is and and that is
another way to allow events to occur one
after another in time but before the
meteor community came around with its
reactivity there were callbacks
everywhere and what promises do is
improve upon that by making the contract
of behavior very explicit unlike
callbacks and I'll explain a little more
about that so a promise can resolve or
reject there's a happy path and there's
the sad path they're called resolve and
reject and it's state will change only
once any given promise will only change
once from a state of pending to a state
of fulfilled and then
in order to pass a handler for the happy
path you pass it in the first position
to pee then typically when you do dot
then you only pass a single function but
the truth is you can pass a success
function and an error function or you
can split it up as shown in the bottom
where you specify a happy path function
and then any number of steps in the
chain and then at the very end of the
chain you can tack on dot catch and that
catch sad path handler will be triggered
if anything above it in the chain either
throws an exception or rejects its
promise so it is certainly nicer than
doing the callback version if error is
null okay so this is how promises work
you you create a chain of them with dot
then and each step into then chain
returns a promise for all things that
came before and doesn't get much simpler
than this promise one dot then promise
to dot then action 1 dot catch action to
if it were there each step in a then
chain may either return a value directly
or it can return a promise for a new
value so if you have a value available
synchronously you can return it in a
then chain so just like jquery wraps
regular Dom elements and kind of
promotes them to full jQuery elements
promises can take a value that's
available immediately and promote it to
a promise or it can you know just deal
with the promise so each step of the
then chain if you return a regular value
from it it'll be promoted to a promise
for that value and so you know you're
you're happy path parts of the Venn
chain can return a promise or an actual
value they can all
so raise an exception or return a
rejected promise so in this case I made
the promise dot race condition more
explicit where if the cubs lose to the
Reds then we'll return at ruthie value
for example the record of the two teams
and if timeout at season end will create
a promise for the end of the season and
if that season end comes we'll throw an
exception so um the if the exception
comes you'll fall into the dot catch
block and so our way of saying I'm
betting that the Cubs will be undefeated
well if the season ends and it throws an
exception then the you pay me method
will be triggered because it's part of
the catch block which catches the
exception this logic can be a bit a bit
funky if it's your first time seeing it
but you know just like jQuery was funky
the first time they used it you can't
really argue that this is pretty darn
concise if you don't know what each of
these means it might take a little time
to figure out what they mean but there's
a very small amount of noise going on
here I hope you guys will agree so one
of the best things about promises is how
they deal with exceptions so just like a
value can be promoted to a promise for a
value an uncaught exception can be
promoted to a rejected promise and so
what that means is that an uncaught
exception occurring in a dot then block
is okay you'll just fall through to the
catch at the end which can handle errors
for the whole chain and this improves
vastly upon how you have to do exception
handling if you're using callbacks I
think that's what the next slides are
about oh no when it's a baseball comic
relief cat picture or should I say cat
picture
cat picture and it's terrible doble all
right all right is that the reds or is
it some other team that is definitely
some other team double raised okay fail
on localizing presenting this in all
right so a real problem that that
promises solve is has to deal with you
know have events happened already so in
this case let's say that we have a
document that is already loaded all
right and we have some code that runs
each of these three different versions
which one of them we pass a few know a
callback essentially a function to be
run to each of these three ways of doing
Dom content loaded Josh do you know
which one of these will actually fire if
the doc document is loaded already do
you even want to happen no that's right
you don't cuz it's a trick but it's not
a trick I'm trying to trick you it's a
trick because only this one does it not
the second one on ready which is just
like adding an event listener for the
Dom content loaded event but only the
middle one this one in the middle
behaves like a promise in the sense that
you could call it at any time so why
don't the other two fire it's because
adding an event listener it's like
seeing you know with that with that bet
example that we had earlier you know the
timing of when you add the event
listener matters and with promises and
with these bets that we make we don't
want the timing of won the bet happens
where we want something to follow the
document being loaded and we don't care
whether it's loaded already we just want
something to follow it that my friends
is the use case for promises
right there so imagine that somebody
gave us something called a Dom content
loaded promise well I showed you that
you tack on behaviors to it using dot
then so if we had a variable called Dom
content loaded promise and you passed in
your little call back there what would
happen right away in your JavaScript
console is you'd get a promise back and
it would tell you that it is a resolved
promise and then those little five
dotted lines that's not a game of
hangman that indicates that the next
turn of the event loop occurs and then
the words I'm ready so an infinitesimal
amount of time passes between getting
the promise and the promise is action
firing but it is significant that it is
not firing in the same turn of the event
loop and i'll tell you the why why later
but basically I mean it's this simple if
your document is loaded infinitesimally
as soon as possible after your your
callback is run if your document is not
loaded well you get a promise back right
away and the promise is for the the
chain that you just created but that
chain an entire chain is pending because
everything hasn't happened so you get
this object back and then the event loop
moves on and it's loading and it's
loading boom now it is finished loading
and then as soon as possible after it
actually loaded you get I'm ready pretty
neat huh so huh now I now I get to be a
little bit grumpy but I'm actually
decided to spend less time on the scrum
penis and say you know you can look up
the scrum penis by reference and and
when I did this meteor interview if
you're going to ever go to meteor
interviews calm my boss Paul and I
talked at length about about promises
and so in the show notes for that I
point to a presentation where I you know
copied all
information from but in a nutshell when
when you use callbacks it isn't it you
assume that things behave a certain way
but they don't always behave that way so
one of the little call back trivia is
that you have an ER our object and a
result object typically that comes back
in what's called a node air back ER r b
ack a typical callback handler for a
node situation you're never supposed to
get an error and a result but there's
nothing to stop a library author from
giving you an error and a result not
saying it's a good idea but the point is
that the contract is informal about how
callbacks work the contract is formal
from our promises work so you will for
every library that takes callbacks every
ten library that takes callbacks you'll
find at least one of them breaking some
of these assumptions and they can be
very hard to track down if you're using
promises you never have to worry about
for example if the callback you're
passing in is going to slow down the
code and the current turn of the event
look so you know promises formalize this
point number one must never execute on
the same tick of the event loop the
promise that each step in a dot then
chain is guaranteed to execute in a
later tick than the other one and the
reason why that's good is because it
allows your in the web browser allows
the user interface to continue
processing events and in node it can
take it allows for the server to
continue processing so it's good it's
good now if you're not writing a library
you're just using a sink libraries
you'll be really glad that you don't
have to do this so if you this it
actually it represents to async steps
good luck trying to find them they're
buried in here amidst the
words function return try catch and
their do stuff one and do stuff too and
if you really want to do proper
exception handling you have to check for
the error and then you have to call your
steps in a try-catch because maybe that
library is you know misbehaved and it
doesn't populate the error it actually
throws an exception so here you see two
steps in a chain each one wrapped in a
try catch each one with if error return
c be error and it's just horrendous to
look at and horrendous to write and i
bet you none of you and I don't do it
either right your async code this way
you take shortcuts but the fact is
you're taking shortcuts this is actually
what you need to do to write bulletproof
call back code want to see what you have
to do to write bulletproof promises code
there it is so just as bulletproof far
easier to reason about and my other
comic relief point is if you ever play
buzzword bingo on a tech talk you should
or like a drinking game out of listening
to Tech Talks anytime someone says makes
it easier to reason about you have to
you have to drink there so on that note
I'm having another set so that is what's
right with promises I have a little
tangent to go into on the event loop and
it explains a few things a little bit
but I generally wave my hands a lot
during this talk and like walk up to the
board and gesture so I hope this will
play out similarly man it's hard to it's
hard to think about even doing it does
does anyone want me to go into how the
event loop works or can we come back to
that if I'm going to
what I think maybe you can come back to
it okay all right Oh to this you know a
couple of slides okay so in a nutshell
there are only two ways of coding
JavaScript that's synchronous style and
asynchronous style what gets us confused
is that there's different ways to do a
sink and to some extent you can actually
convert between them so in the async
family are callbacks a promises our good
friend reactivity from meteor and on the
server fibers I need to update the side
because there's actually a fifth one in
es2015 called generators and yield
functions not going to go into those now
but you can convert between these so for
example if you have a callback function
and you want to run it in a fiber the
lower-right example illustrates using
meteor app async passing it a callback
function and receiving a fiber function
which appears to block so that you can
use it synchronously also if you have a
callback function and want to turn it
into a promise function there is a
function called D notify as in like no
DJ s style callbacks you can d notify a
callback function and get a function
that returns a promise similar to the
way that meteor wrap a sync works with
fibers the D notify style will work on
the client and the server because
promises work on the client and the
server fiber version will only work on
the server totally fine to use it it's
really nice when you're using fiber
based libraries that just appear to be
synchronous but I've started to think
that it's a bit unusual that meteor
which try so hard to be isomorphic has
some server only constructs that are
different but to some extent you can
convert back and forth between these now
the reactivity style
is is a little bit a different example
to show not as simple as turning one
function to another kind of function so
I'll illustrate that a little bit more
later ah right here in fact so so let's
say that our goal is to keep an
uppercase variable and sync with a
variable called lower case and we know
about reactive VARs right there like
just a just like a session but only only
one key of the session so let's say that
we had two variables don't be disturbed
by the let syntax or the omitting the
parenthesis after new reactive are just
es2015 syntax so we have to reactive
ours and to keep them in sync you could
probably imagine how this would have
been done but I was going to ask you to
do it but here's here's an example of an
autorun which gets the value of the
lowercase variable and then sets it the
upper case of it into the upper case
variable right so if we do this we know
that sometime ASAP after setting
lowercase uppercase will reflect it
right well we can actually get the same
behavior if when we call set lower case
if that return to promise we say set
lower case and then set uppercase set X
dot to uppercase so the two are
equivalent and you know you might just
prefer one or the other for the kind of
problem you're working with sometimes I
find it's very handy at the time that
you're doing something to to to do
something else other times I want a more
pub sub where any other autoruns here
that are depending on lower case there
could be a hundred different autoruns
that
looking at this lower case variable nice
thing about reactivity as you said it
once and all those other autoruns will
fire but for simple cases you might just
want to use a promise syntax my point
being that these at runtime these two
behave exactly same way so I want to
illustrate a pattern that is be gained a
little fame in the meteor circles lately
we've heard that you can now return a
promise from a meteor method and if you
if you you know follow this about
promises you might wonder like what does
that mean like return a thing that waits
around for an indefinite amount of time
from a meteor method like what the heck
does that mean well I'll show you the
code but but let's let's break it down
returning a promise from a meteor method
well a promise is an eventual value
right so you're not returning a promise
from a method you're returning an
eventual value from a method or in other
words you are eventually returning a
value from a method and that's the same
thing that happens if you have used
meteor da trap async on some sort of
callback function you will eventually
return a value from that method so
returning a promise the caller doesn't
receive a promise they receive a value
the trick is in what actually happens
inside the method that's different so
I'll show you the code so here you see
some meteor methods defined and let's
say that we want to be able to call a
method on the client that gets the time
let's say five seconds from now well
that does mean that at the time that the
client calls it it'll have to wait we
want to make sure that that weight is
non blocking but as far as the server
goes we can create a promise for that
future time but in order to return the
promise for the future time we have to
await the promise
otherwise we don't have the actual
instance and time to return so the outer
block of this meteor method is wrapped
in promise await and promised that await
has to be given a promise or chain of
promises I hope the es2015 syntax for
method declaration isn't bothering you
let's just look at the return promise
data wait now inside of this you need to
create a promise and I haven't shown you
how to create a promise create a promise
by declaring new promise calling the
constructor and what that does is it
gives you well you must pass a function
to the constructor for promise but what
this gives you once you accept a
variable called resolve in your function
is a scope so all this empty space here
is an area where you can do any kind of
crazy call that code you need to but at
some point in that callback code if you
call resolve and pass it the value you
want returned well you will have created
a promise for that future value and the
future time method will await it so here
is set timeout code that fills it in set
timeout the first argument to set
timeout is a function the second
argument is the delay the delays five
seconds from now when that five seconds
he lapses we say hey it's the future now
and then the resolve function is called
with new date so it's a few layers and
this might look a bit uh weighty the
first time you see it but it really
builds up nicely while you're writing it
you're awaiting a promise you're
creating a promise and you're resolving
the promise that is how you return a
promise from a meteor method and it's
you know particularly useful when you're
dealing with
and p.m. libraries other libraries that
return promises all right we have a few
more things to go and my daughter will
be be joining me for for this so you
might hear some of that in the
background hey when we had a question on
okay d so these skates for this like if
you're on I was just trying to think I'm
like I know there are situations right
it hit this before and this would have
been useful like if you're you're
hitting an API from the server side like
maybe you're pulling you're pulling data
from an API but you want to pull it from
your server and said your client any
what is compared with and you want to do
it through a method this is probably a
good way right yeah absolutely and like
there's nothing wrong with using meteor
da trap a sink but limited to
circumstances where the callback
function behaves a certain way and I
just published a utility that looks up
versions of packages on DD over DDP and
the callback arguments and the shape of
it was just wrong for using wrap a sink
so using this pattern you can create a
promise around any gnarly code no matter
how gnarly that call that code is you
can create a promise around it and then
oh wait it and it's just as if you were
able to do meteor wrap a sec so yeah ap
is uh unless it's an HTTP API right
because on the server meteor zone HTTP
call uh doesn't need a call back but if
it's something like a github API or
something more complicated than
definitely good question um what do i
what am i showing here oh yeah that you
can here's a refactoring of this where
it's not also nested but you create a
chain of promises and this just shows
like
a different a different approach where
your chain the first two lines of the
chain create a promise that resolves
after five seconds with the new date and
then its tax on a little dot then and
dot catch and then does return promise
Dada wait action so this will do
effectively the same thing but you know
just a different structuring of the code
there is an async sheep I wish I had a
joke to go with that I do but I don't
think it's gonna go over well I'm
revising the joke it's in progress but I
hope you enjoy this black sheep
sometimes I feel like a black sheep for
using promises in meteor but hopefully
they'll be there'll be more of us
running around soon so that was like
talking about calling defining a method
that you know eventually returns a value
so how do you call the method well this
meteor dot promise it doesn't exist by
default in meteor and it does exist if
you have included a package called ok
grow colon promise it it patches the
meteor object maybe I have a few regrets
about that but not really because it's
been super helpful to people to
basically have an API that is works on
the client you don't need it on the
server because you don't need to meteor
call a method on the server but on the
client you do a meteor call of course
you pass a method name and then some
arguments in the last position you pass
a call back well I thought that meteor
dot promise could be the version of that
that uses promises so instead of passing
a call back you are returned a promise
that you can chain onto so that method
we defined future time here is the
client side if you're using okay grow
colon promise in your meteor app you do
meteor dot promised future time and then
you log it and that's it
um another thing you can do kind of
creating a chain of things together
suppose that you want to log the time
now and then log the future time well
here is an example of promoting the
present date to a promise the first line
says promise dot resolve so resolve
immediately with the new date what that
does is it promotes the date object
which has no dot n method on it into a
promise which has a dot been method so
with the new date we can log that right
away and then we can return a promise
for the future time and when that comes
back we can log that so take a look at
this and I'll just kind of be silent for
a second while you compare the output
remembering that the dashed lines are
different terms of the event loop
compare the output to the input where
the output consists of the current time
then the promise for the entire chain
that you've created has been returned
and then five seconds later the promise
for the future time the server has
responded with its future time and then
that was logged too so this also
illustrates that the value that is
returned from one step of the chain
becomes the first argument to the next
step of the chain so assuming we had a
function called log that did a console
dot log well it received the new date
and then it received the future date as
an argument any questions here I'm going
to pause here you were no no questions
cool so then there's one other little
trick here just to illustrate the fact
that the thing returned from one step
becomes the first argument for the next
step so look at the word future time the
string future time the method name that
you're calling
well i'm not saying you'd want to do
this but you can certainly return that
string future time from one step and
then it gets passed into the meteor dot
promise method as its first argument in
the next step and there is this kind of
a ridiculous code golf that i did here
i'm not saying that it's better to split
that up into two steps just wanted to
show you that you know you can
intersperse there's room for creativity
and in the way you create these steps
and then ah man i was going to find
another comic relief cat picture but
they're just there wasn't any on the
internet today i just it was plumb fresh
out of cat pictures I don't know they
should do something about that Josh
alright I hope there were groans there I
didn't hear any groans but I can kind of
feel them all right so the ok grow
promise library is I I think it's as
awesome as sweating to the oldies maybe
a little more awesome and the what I
didn't show was how you go from a
promise to reactivity and the key to
that is this question can the resolution
of a promise invalidate a computation I
swear to god I'm not just trying to
sound smart and use like long confusing
words the code might actually be more
intelligible than that question but
definitely you can set up a promises
resolution to invalidate a computation
so what's the use case for that well
suppose you have a helper that is going
to call a server-side method and you
want that helper to place to return a
value into this text area well I've
definitely had other people the inside a
helper and they're they're writing some
stuff the writing some stuff then they
have to make a meteor method call and
then they're like but wait I can't how
do i return the value of the method call
from a helper and you can't what you
have to do is create a promise for that
method call and then pass it through
this function that i'm going to show you
so this is the use case that you have a
helper called meteor promise so how do
you set up meteor promise well you'd
like to do something like this where you
you know do some reactive stuff depend
on some variables and whatnot and then
do you know a meteor dot call or a
meteor promise but what you need to do
with this okay grow promised library is
actually define a helper function just
as you would normally but then when you
set up the helper map meteor promise it
becomes a reactive oops reactive promise
you have to wrap your helper function
and reactive promise when you do that
you can give it some text to display
well you don't yet have the promise you
can also give it some text to display in
the error condition and so it's just a
little wrapper that allows you to return
a promise so here you're seeing meteor
call promise instead of meteor dot
promise this is what I they both work in
the library of the current version but I
decided to follow a convention because
there are other things that you may want
to have promises for so meteor dot
promise like I changed it to meteor call
promise but currently you can use either
one so I'll show you a site that kind of
shows you everything you can do with
these promises so we got okay grow
promised meteor calm and hmm here it
talks about what is implemented in this
package and you know including HTTP GET
HTTP POST all those HTTP verbs all right
though she is high sierra and then you
know I I'll let you go through this code
here
here is an example where your client
template has a a call server call with
latency and the code behind the template
wraps a helper and reactive promise a
helper that returns a promise and you
can go and type stuff and you'll see the
loading indicator the loading indicator
comes from where you've passed reactive
promise your helper function right there
and then you're loading text and you
return a promise from it so this one
includes a little extra latent latency
so that you can see that it's a server
kind of call and in these other versions
you don't actually use latency yet we
haven't added any additional latency it
just goes as fast as it can come back
from the server and in fact this one is
actually doing several round trips to
the server because we're chaining
promises we're adding the values of the
text boxes and then we get that back and
then we're adding the word server says
to it and then we're adding that back
and then we're doing the smiley face so
every single step this is like the first
server call and then the promise adds
this on to it and then it becomes that
also you have had HTTP GET where you
have to pass a callback get promised
allows you to get a promise for it to do
then and catch and so if we get a file
from a site that doesn't throw an error
we see the contents of it being put
there and in this case we're not using a
helper we're just you know forcibly like
updating the value of that with jquery
and in the case where it throws an error
then our catch block is being as being
hit
in either these cases and and then you
can get even crazier with this so the
fullest example here and like the one
I'll end on i think is the case where
you're writing a blog post and you want
the blog posts to have a link in it
maybe you're passing the link to share
it you know the the social sharing
meteor package that you know as a has a
link i'm not exactly sure how that works
i might be you know confused there but
suppose you want a link to your article
to appear in the article well you need
to create a chain of events here you
need to once you start publishing the
post you need to kind of note that it's
in progress the publish and then you
start off with some placeholder text you
publish the post you create a short URL
for it and you merge it back in i don't
actually like the way this reads it's a
little more confusing than just doing
the example so we can hit publish post
and a chain of promises will be put into
effect where we publish it once without
having the short URL and then we get the
short URL and then we merge that back in
and we republish it so you can go
through the code on here to see chain of
promises that is used to do that so you
can you know it can be a really better
consent of control flow then you know
basically any other way that I've used
and this isn't using Mongo for example
Josh and I own hats and conversations
where you know the question is and I
would be happy to answer questions from
you guys about this like can't I just
put it in Mongo and let reactivity
update these fields you know you might
be thinking but that you know we're
totally works and you can it's just that
some of the time you don't need to
persist things in
on go or you don't want to this is not a
replacement for reactivity I think it's
a supplement meteor runs on top of
JavaScript promises are part of the
JavaScript standard and so meteor
couldn't keep promises from you even if
they wanted to any more than they could
keep set timeout from you it's just part
of the language now so I figured that I
would do this work to you know show you
several use cases for promises for the
same reason that when you're traveling
in another country it's good to have a
guidebook that just explains your basic
phrases you know donde esta el bano I
wanted people to have a guide to using
promises if you don't have to use them
fine if you do have to use them lets you
know make sure you have a guide to use
them well and also have a meteor package
that not only gives you a promise that's
available in every browser by pulling in
meteors promise package but also just
one that gives you some conveniences to
and that's open to community improvement
because we all know the best way to get
something into meteor is sometimes just
to put it out there yourself right so um
that is what I have for now ah any
questions people they don't have
questions get a well done oh well done
questions yeah
see were you able to hear that no could
you uh rise yeah are there any anti
patterns or any places where you
wouldn't want to use promises that
wasn't no um I know I I don't think
there are any places where you wouldn't
were there'd be any drawback to using
them because like I said they're
equivalent to call backs except for
being standardized so like I actually
think they are a real improvement over
abusing callbacks but if you're getting
by without them you don't you don't have
to use them but when you do start using
them you'll notice that they bring a
standard contract of behavior and it'll
be like you know once you start using
jquery to to query dom elements even
when you go back to the year plan that's
that's what I any other questions what
that's it all right letting me first
remote a meetup I wish I could stick
around for you guys but I'm on a parent
duty thanks for giving the talk we
really appreciate it Dean yeah thanks
all right and if people want to find you
where would they find you out on the
internet yup I'm hub I&amp;amp;D Gnaeus on
Twitter I'm denius dev and then you're
in the media club slack chat room to
write I am on there as often as I can
and then also just for anyone that
wasn't here I'll say that's too bad
because modulus sponsored they brought
pizza and cookies and brought a bunch of
t-shirts so Oh bring one for me at Space
Camp yeah I will all right I man thanks
all right thanks Josh why</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>