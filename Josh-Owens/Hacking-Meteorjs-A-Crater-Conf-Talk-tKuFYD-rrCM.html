<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hacking Meteor.js - A Crater Conf Talk | Coder Coacher - Coaching Coders</title><meta content="Hacking Meteor.js - A Crater Conf Talk - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Josh-Owens/">Josh Owens</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hacking Meteor.js - A Crater Conf Talk</b></h2><h5 class="post__date">2016-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tKuFYD-rrCM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is a video of a talk from crater
remote cough given to a live audience in
February 2016 this video was made
possible by sponsors like modulus IO ok
grow calm and space dojo calm if you
would like to find out more information
about upcoming conferences be sure to go
to cough crater down IO and put your
email in the form that pops up in the
lower left corner enjoy the video all
right welcome back to the third talk of
crater Kampf
we have Pete Cory with us Pete runs East
5th which is a consulting company that
helps build meteor apps he has a really
interesting background in web security
so I I found that super interesting to
learn about when we were at Space Camp
together and he's gonna talk about no
sequel injection so without further ado
I will turn it over to Pete cool awesome
thanks Josh that's good to be here
thanks for coming everybody I'm gonna
take my headphones off my speaker
settings are a little wonky so yeah
today I want to talk about a little bit
of security stuff I want to talk about
no sequel injection in modern web
applications but before we do that you
probably want to know who I am as Josh
said my name is Pete Corey and I run a
small little web dev shop called East
fifth we mostly do media development for
a variety of different clients and I
also offer meteor security assessments
as a service and so at an assessment
I'll like go through your app with like
a fine-tooth comb you know looking at
your source code doing some hands-on
testing looking for common
vulnerabilities
showing you how to or how a potential
attacker would exploit those and then
how to remediate those issues as well I
also do a lot of blogging about meteor
and meteor security so if any of that
stuff seems interesting to you you can
check out blog beast v CO and see that
I'm all about so you're probably
wondering why a security talk right this
is a Developers Conference so why am I
here like harsh in the mellow you know I
think that security is is really
fundamental to everything we do as
developers we spend countless hours you
know day after day trying to build these
amazing products you know we build
amazing products when we try and attract
all these users and potential investors
and we try and build trust with our
users and investors and we try and make
the world a better place but all of that
can be completely washed away by one
small vulnerability everything operates
on this assumption of of security right
this linchpin assumption so imagine that
you have an application that has you
know a good number of users happy users
let's say that you have some type of VC
backing or some kind of funding
everything was going fantastically you
know you're on an upward growth trend
but then one day an attacker comes by
and he finds you know like a critical
vulnerability in your application and he
decides to exploit it and let's say that
he's able to you know cause direct
damages to your company and maybe he
causes some direct damages to a few
users so in that situation obviously
you're going to lose whatever whatever
he takes from you your company your
users will lose whatever he takes from
them when you tell the remainder of your
users what happened which you should
their trust and your company and your
brand will be severely deteriorated
you know your your investors trust and
faith in you will be deteriorated if you
lose investors you potentially can't pay
your payroll which means that you
potentially lose your employees future
users of your app the first thing
they'll see when they google your
applications name is this TechCrunch
article talking about you know how this
attacker stole you know whatever they
stole from you and you know however they
affected your users so everything
operates on this assumption of security
you know we're building cool things but
they have to be secure cool things
otherwise what's the point right so what
is what is no sequel injection well no
sequel injection is a relatively new
thing because no sequel databases are
relatively new thing you may have heard
of sequel injection a sequel injection
is basically an attack against a sequel
database like a relational database that
uses sequel strings has control
mechanisms so you've probably seen this
xkcd comic where this kid's name is you
know Robert single single tick
parenthesis semicolon drop table
students sequel injection is what
happens when you take unvalidated user
input and he just directly concatenate
it onto a sequel string and then you run
that new sequel command in a sequel
database so the user is input in this
case Robert single tick blah blah blah
takes control of that query through that
string concatenation and makes it do
something that it never was originally
intended to do so in this case by doing
a search for the students name for
example you would inadvertently drop the
entire students database so this was a
problem for sequel databases because
they use strings as control mechanisms
right like a sequel command would be a
string that's like select star from
table blah blah blah etc but what about
no sequel injection no sequel injection
or no sequel database is like like
MongoDB or Redis Redis is a bad example
but MongoDB for example or rethink don't
use string
as control mechanisms they use objects
so like a a MongoDB query is actually an
object that specifies kind of the
structure and the type of data you're
looking for it's not a string so how
could a user inject something into that
object to kind of take over the query
there's nothing you can inject into an
object that would really alter the
structure of that object right well to
get a better idea of what I'm talking
about I want to give you guys a demo I'm
gonna show you kind of a a demo meteor
application and I'll walk you through
some no sequel injections and talk about
what you can do to exploit the
application so let me get this set up
here okay
all right awesome okay so this demo is
going to be using an application called
meteor shop and meteor shop is actually
kind of an educational demo ecommerce
app written by Rob Connery and he
actually has a whole Pluralsight course
dedicated to building this from the
ground up
it is a meteor app using MongoDB MongoDB
is important here everything I'm going
to talk about is specifically targeted
at MongoDB and I'm going to be picking
them I'm going to be quite a bit and
we'll talk about why later in the talk
but the meteor portion of this is not
important at all I'm gonna kind of gloss
over quickly some of the the minor
details that you need to know about
meteor to understand what's going on
here but really everything I talk about
applies to any stack any framework Mongo
or sorry meteor vanilla node using
Express or something laravel whatever
else you want to use so this is all
totally applicable
the app is pretty pretty simple for an
e-commerce app you know you've got your
home page this particular ecommerce app
is selling like space tourism products
so you can like buy a vacation to Mars
and buy some add-ons for that vacation
and stuff like that it's pretty simple
you can add items to your cart oops
you can update your card and it updates
you can remove items from your cart you
can browse by vendor so I can see all
the products that Martian armament sells
so it's all pretty straightforward you
can actually add an item to your cart
and then go through with the purchase so
I've got some test data here and this is
actually wired up to a demo stripe
account so I can actually follow through
with this purchase let me give some fake
data here I live in Schenectady alright
so I'm going to purchase this trip for
89 thousand dollars and that purchase
was successful and if I actually go up
to my stripe dashboard and i refresh
this page I can see that that purchase
went through for 89 thousand dollars
everything is good this redirects a
little broken but we don't need that for
the demo so that's kind of a happy path
of the application that's what a normal
user would see but a malicious user
might see this apana in a very different
way right so they're not really
interested in buying products at whole
price they want they want to get
different things out of this application
so for example they may want to retrieve
information we see all these products
here but maybe there are other products
that are hidden or accessible only to
certain users a malicious user might
want to see all the products in the
system
to potentially be able to buy them when
they shouldn't a malicious user may want
to see information about your users
right they may want to see what other
users are using the system what they're
buying some private information about
that maybe they can take that
information and sell it to a third party
for a profit maybe they want to modify
some information if you know they want
to like modify others other users carts
add or remove things from their cart
remove their carts all together maybe
they want to be jerks you know prevent
people from using the software maybe
they want to change product prices right
maybe I don't want to pay eighty nine
thousand dollars for this maybe they
want to pay two dollars maybe they want
to give themselves admin rights maybe
they want to go through some kind of
privilege escalation scenario where they
become admins and they can modify prices
at will or see user data at will and you
know bar and all that if none of that
works maybe they just want to be really
mean people and prevent other users like
other good users from using this
software so they want to deny service so
these are all potential motivations that
we might have as attackers of this of
this application but how would we
actually go about doing any of those
things
so we'll start kind of simply and slowly
and we'll work our way up
the first thing we want to do is get a
list of all products here so let me open
up a console here this is just a browser
console let me increase my font size a
bit so I'm gonna skim over the meteor
details suffice it to say there's a
thing called a publication that is
basically a function that you can call
from the client and it returns data from
the server to the client so in this case
there's a products by vendor publication
and it takes a slug as an argument so we
can actually subscribe to that
publication on the client and this
client has already subscribed once
and we can see all the products
available to us
on the client so right now there are
three products available and that's
these three right here so there's the
honeymoon to Mars
there's the Johnny liftoff product and
the third one is the re-entry and so we
saw that it accepts this slug argument
right you can see it right there and
slug is intended to be so for example in
this case oops so in this case slug is a
string this string Martian - armaments
so normally when you call this
publication or subscribe this
publication you would say products by
vendor and then you would pass in that
slug and so your subscription goes
through and once again we can see all of
the products on the client and it's the
same three well there's four this time
because we added added this Mars mobile
one but what would happen if we passed
in something besides a string here right
so instead of this string Martian
armaments what if we did something like
- so the subscription works we just
don't get any anymore products but
that's interesting why can we pass in it
- we're assuming that slug will be a
string right so basically we want our
query to look like so this is basically
the Mongo query that gets created when
we do this products find on this
publication line and we're not making
any we're not we're not telling the
system what slug should be we're just
assuming that it's a string but because
we're passing as messages via DDP it can
really be
I could be a number it can be undefined
it can be no it can even be an object
and that's the key that I want to show
here so what if we pass in an object to
this publication but what if we make it
a very special object what if we say we
want to find all products whose vendor
key matches this object so this is a
special object we're saying we're
creating an object when I'm giving it a
key whose name is dollar sign GTE with
an empty value of empty string so if we
subscribe to this let me view all the
products on the page or on the client we
suddenly see a lot more products right
so there's only four on this page so we
should only have four here but now we
have quite a few more so we have you
know a lot of products we see here but
there's some here that we haven't seen
before and that we probably shouldn't be
seeing so why do we suddenly see these
well it's because we passed in a special
object to our query we passed in an
object that was actually a Mongo query
operator so our query looks like this
we're finding all products whose vendor
slug and this this special field
actually means greater to or equal to an
empty string so we're finding all
products with a vendor slug that is
canonically greater than an empty string
which is actually every product in the
system as I mentioned this is a query
operator so in this case it's the GTE
query operator there are lots of query
operators in MongoDB and they're
basically just feels that have special
meanings for the database when it sees
one and a query a query object it will
interpret it differently than it's a
normal field and in this case like I
said it finds all documents whose vendor
slug is greater to or equal to an empty
string and so that's kind of the
fundamental basis of no sequel injection
right we're not injecting strings into
strings we're injecting sub objects into
query objects and by doing that we can
potentially modify the flow of the query
and use it to you
get data that we may not be able to get
on a normal normal circumstance and we
can take this a little bit further so
the products example was a little boring
right we probably could have found all
these products through normal usage of
the page but what if we want to see
other users personal data what if we
want to see like the carts that they
have and you know what they're buying so
we can do the same exact thing there's a
carts collection on the client and we
can see what we have right now and we
have no cards available to us if we go
ahead and add something to a cart and
then we try again so we can see our own
cart and this is fine you know obviously
we have access to our own cart but we
can't see other users carts and that's
that's obviously for a good reason right
that's private data we should not be
able to access that but there's a
there's another publication that we can
that we can attack there's this cart
publication right so this takes in a key
and it finds all carts whose user key
matches that passed in key and in this
system user keys are supposed to be a
secret their hashes not hashes but
they're they're hex strings that
uniquely identify a user and they should
never be exposed to the public they're
supposed to be completely secret only
you know your key so only you can access
your cart but again we can just call the
subscription manually we can say meteor
don't subscribe and then we don't have
to do we could do the GTE empty string
but we can also do another query so we
can say find all carts whose user key is
not equal to an empty string
we fetch all the carts available to us
again now we have two carts one of these
is mine I think this one is mine
and this one belongs to someone named
Sarah Schmo so now we have Sarah's email
address her IP address all the items
she's purchasing notes about her cart
you know her cart history things like
this we also have her user key which is
useful later so this this could
potentially carry a lot of really
personal information right this is this
is a bad thing that we can get this if
we were malicious users we could
potentially take this data farm this
data sell it to third parties who were
interested in this kind of user data
things like that lots of bad stuff right
we can also get these carts in a
different way so both of these previous
examples we've seen have attacked find
queries right so this was also a fine
query this would have looked like DB
carts don't find user key whatever no
sequel injection isn't limited to find
queries though we can actually attack
find one queries as well so there's a
method in this application called get
cart and get card accepts a user key and
it passes that user key into a find one
so what would happen if we call let's
grab our user key just to have a base of
comparison so if you say meteor call get
cart and then we're gonna pass in that
user key and then we're gonna add a
function on the end that's an error
result function will log the result all
right so get cart returns a single cart
and in this case it returns our cart
this is our user key and we can double
check that let me drop this font a
little bit there we go
so we can see that this is our object
this is the item we're ordering
everything's good but what if we drop in
a Mongo query operator again what if we
say get cart whose user key is greater
to or equal to an empty string okay so
in this case we got Sara's cart which is
probably a bad thing right we shouldn't
be able to get other users cards through
this method but we can see that we only
got a single cart this time not not all
the carts in the system if we repeatedly
do this
we'll still only get Sara's cart because
the Mongo ordering of this collection is
such that this is the first document it
checks and this is the first document
that matches that query so it's the
first document that's returned and at
that point it just stops because it
found one and moves on but we can
actually tweak this query a little bit
to find all the carts in the system one
at a time so there's a query operator
called ni n and the documents say that
it matches none of the values specified
in the array and it basically stands for
stands for not in so we can say give me
a cart whose user key is not in this
array I'll pass in an empty array so
that gives us Sara's card again but this
time we're gonna grab her her user key
and we're gonna repeat this query so
we'll say give me a card whose user key
is not in this array and we're gonna
drop in that user key we just found and
if we run this it's going to give us the
next cart in the database in this case
it was our our cart object so we can
repeatedly do this we can grab this user
key push it back into that array repeat
the query find the next cart and
repeatedly do this until we have all the
cards in the system you can easily write
code that would do this I have some code
but it's a little long and not that not
that useful for a demo
so that's that's a lot of that's a lot
of data we can get right but what if we
wanted to move beyond just getting data
what if we wanted to modify data in some
way well the same things apply right we
can exploit finder queries we can
exploit find one queries we can also
exploit remove queries there's a there's
a method in this app called empty cart
so empty cart just as a Mongo remove on
all carts whose user key matches the
provided user key so again we can just
come in here and we can say meteor dot
call empty cart whose user key is
greater to or equal to an empty string
and boom suddenly it removed my cart but
we can also see that it removed all the
carts in the system so if we do a quick
fetch Sara's carts gone to now so I can
easily create a quick method that would
call this function or call this meteor
method right and then timeout call the
method again so if I run that that's
basically setting up a function that
will immediately remove the the all the
carts in the system and then in 1014 the
system call uh self again remove all the
carts in the system infinitely as long
as this browser tab is open so that
effectively will remove everyone's cart
every second rendering the app pretty
much completely useless for all users so
if I was a truly evil user I could do
that but we're not evil so we won't do
that
so what if we wanted to not really wreak
havoc on other users what if you wanted
to to do something that would benefit us
right so what if I wanted to I wanted a
jet pack right I wanted a liftoff rocket
suit but I certainly don't want to pay
eighty nine thousand dollars that's
that's a little extreme well let's play
with this a little bit so let's first
grab our cart so we know that our cart
is available to us we can see it right
here this is our card so let me go ahead
and grab this then let's look at cart so
if we look at the cart we see that
there's a few cool fields there's this
total field now I wonder what would
happen if we change that field and I
won't get into this now but I've noticed
that whenever I modify anything on this
cart it calls a meteor method called
save cart and it passes this cart object
in as an argument so I wonder what would
happen if let me say this I wonder what
would happen if I set total equal to
some other value and then I call save
cart with that new cart object
alright let me redo that there we go
okay so let's set the total on our cart
to some value and then save that cart so
nothing happened and that's fine as a
black box you know attacker sometimes
things don't happen so let's dig into
what exactly is going on if we if we
reget our cart we can see that the the
total didn't change so maybe the total
is actually affected by the the products
that we're buying so what if I come into
this first product this liftoff rocket
suit and I change its price so if I say
cart items let's say I set the price to
about thirteen dollars and then I can go
ahead and save my cart well okay now the
price is 13:37 will this actually hold
through checkout so let me try and buy
this rocket suit I can pay now let me
enter some dummy data okay fingers
crossed and there we go so the purchase
went through let's see how much it
charged me
yeah okay I think it's in there yeah so
originally we had a balance of eighty
nine thousand three hundred and thirty
three dollars and now we can see that
that thirteen dollar charge was added on
so if someone was able to purchase a
rocket suit for thirteen dollars which
is a very very big loss for your space
tourism business and while this isn't
necessarily sequel injection or no
sequel injection we didn't modify the
query anyway it certainly feels very
similar right
so there's a D normalization issue going
on here instead of storing product IDs
and polling products to fetch their
actual price from the database on the
server we were trusting user input we
were trusting that the product that was
denormalized into this cart object was
an actual valid product which in a way
is like the fundamental issue behind
those suits equal injection right you're
trusting user input which is oftentimes
a pretty big mistake so let's move on to
some other types of attacks let's say
nothing that we've previously tried
worked we couldn't get any data we
couldn't modify prices we couldn't
delete carts let's say we wanted to try
and become an admin and digging through
the client-side source of this app I
found out that there's an is admin flag
on the user document that determines if
you are or are not an admin and if I
look at well let me first sign up so
create account okay so now I have an
account if I look at my user document
again this is kind of media specific but
don't worry about this this is
applicable to any any framework if I
look at my user document I have no is
user flag or is admin flag which means
that I'm not an admin but I've also
noticed that there's a method to update
my profile or my user account I can
reach that through my profile page and
it's supposed to let you update fields
and your profile object so I can usually
do things like I can call update user
and add I can pass in an update operator
here so I can say set profile that name
and I can set it to my name and if I
look at my user document again and I go
into the profile object I can see that
my name was set to Pete so that's cool
but what if I know all of that as an
attacker well the first thing I'm going
to try and do is set my is admin flag to
true right but we get an error it says
that we're not allowed to do that so
maybe this system is checking for direct
sets against this is admin field so
maybe if it sees that your update has a
dollar sign set and it's trying to
directly set his admin it'll throw an
exception and that's fine because we
know as attackers there are lots of
different ways to modify data in MongoDB
that is the wrong tab so in addition to
set you can do all kinds of things like
Inc you can do add to set you can do
push you can do pull you can do X or to
keep it simple let's just do a simple
Inc so we're going to increment his
admin field by one and if we do this
suddenly this little admin button pops
up which indicates that we have given
ourselves admin permissions in the
system which means that the security
around the update user method is not
correct because it wasn't correctly
predicting all of the ways in which you
can update your account or directly
affect the is admin flag so let's undo
this let's say that the application
owner got a little more smart and they
decided that normal users can't do any
direct modifications to the is admin
flag so the code will basically look for
any operator in this position so
increment set push add to set whatever
you want and it will see if you're
trying to operate on this is admin flag
and if you are it will fail so there's
still ways to get around that as an
attacker so earlier we saw that we can
update our profile object in any way
that we wanted so we can set our profile
name what if we set our profile name to
true and then we set what if we rename
our profile profile name and we'll
rename this field into his admin so
rename is a valid Mongo update operator
and it basically takes the value in this
field the profile name field and it
dumps it in this target field and if we
try this suddenly we have admin rights
again so if you look at our meteor user
or user document we can see that our
profile name is no longer there and I
should remove those and now we have this
is admin flag except the true
so the security around directly setting
his admin fly wasn't enough right
because we can indirectly set that is
admin flag to true with a rename
operator so let's say that none of that
worked at all so we couldn't get access
to any information we couldn't update
any for any information we couldn't give
ourselves admin rights nothing has
worked and as an attacker we're getting
very angry let's say so we decide that
we want to basically deny access of all
other users to this application we've
seen earlier that if we could update
carts we could just repeatedly remove
them but that's not that big of a deal
is it if we can't if we can't update
carts we can't really do anything there
there is a publication in this app
called called vendors which takes just a
plain query object and dumps it directly
into a MongoDB find query so we can use
this to pass in a ware query so we can
say we do not subscribe vendors and we
can say where and where is an especially
powerful query operator and it basically
lets you do some type of JavaScript for
each document in the collection and you
can actually pass in a JavaScript string
that will be evaluated on the database
itself and if that JavaScript string
evaluates to true that document will be
included in your result set so you can
actually say like this doubt slug equals
you know Martian whatever I think you
would say return and so if the documents
slug matches the string it would return
that document as part of the result set
but the important part here is that this
string is executed as JavaScript on the
database instance and it's any arbitrary
v8 JavaScript which means
that we can do we can run any JavaScript
we want on the database so what would
happen if we run a piece of JavaScript
that looks something like D equals new
date do C equals new date while C minus
D is less than 10,000 so this is a
looping this is a loop and basically it
creates a new date and then tightly
loops creating a new date every time it
runs and then it will loop for up to 10
seconds basically until that new date
created in the loop is 10 seconds or
more older than the first date and this
JavaScript is executed once for every
document in the collection so in this
case we have 3 vendors so when we run
this it's going to basically Pegu CPU at
a hundred percent for 10 seconds for
each document so that's 30 seconds total
and because the CPU is pegged no more
queries can be processed during that
time so if we run this and then refresh
the page it's going to sit on this page
for 30 seconds and that's because like I
said it's it's busy processing that loop
in the background those 3 loops in the
background and the thing is the scary
piece of this is that this 10,000 right
here this 10 second delay is completely
arbitrary right I was being nice by
including that a true malicious user may
not include that timeout they may just
have this loop indefinitely and in that
case the only way to recover your app is
to either go in and kill that query
manually or restart your database so
this is kind of a heavy-handed approach
to do essing an app and it really only
shows itself when you can expose like a
where query in your application so that
that is basically the demo hopefully
that showed you some of the possible
dangers of no sequel injection when
you're completely unprotected from it so
how do we fix all these issues right so
I just went through like a huge long
laundry list of potential
vulnerabilities and you know how it
could totally destroy your app and all
this trust with your users but how do
you actually fix these things well the
good news is that fixing a no sequel
injection is actually incredibly easy
all you have to do is make assertions on
what your data should look like so what
your user provided data should look like
so if you remember back to the first
example we've subscribed to this
products by vendor publication and we
passed in a slug and the first thing we
saw was that the application always
assumes that slug is a string right and
we ran into trouble because the
malicious user passed in an object
instead of a string but what if our code
had some kind of check so it said if
slug isn't a string throw exception so
that would basically catch all possible
sequel injection right we couldn't
inject an object that object wouldn't
become part of the query object we could
only ever pass in strings which we can't
escape out of in any meaningful way to
alter the query object so there would be
no issue there so if we only have slugs
that are strings there is no issue and
in the context of a meteor app there's a
cool little library called check which
does that exact thing so in this case I
would have said check slug string and
now if a user tried to pass in an object
they would have received an exception
and it would have said expected string
but I got an object so that's that's the
basic idea behind making assertions and
what your data should look like and it's
not only applicable to meteor right this
is applicable to whatever framework you
want to use you don't have to
check the basic idea is that you need to
you need to know what the data provided
by your user will look like and then
make sure it actually looks like that so
if you're expecting a string throw an
exception if you get something besides a
string if you're expecting an object
with an ID field that's a string make
sure that what you get from the user is
an object that has an ID field and make
sure that that ID field is a string it's
really that simple once you know what
your users are passing you you can you
can deal with it safely and that's
actually becoming more and more of an
issue in modern web applications because
with meteor for example we have DDP and
/ DDP you can pass numbers you can pass
strings you can pass you know undefined
null you can pass objects if you have
any custom lis defined types using a
JSON you can pass those custom types you
know with an ode app using query string
or something qsr you can even pass in
objects through through a URL right so
more and more as we get all these
helpful middlewares around our apps it
becomes less and less clear what the
type is that a user is providing us like
what the type of their data is so it's
important to be explicit and make these
assertions and if you do this if you do
it well and you do it thoroughly your
application should be free of no sequel
injection so the demo was based on
MongoDB and I've been picking quite a
bit on MongoDB and there are a couple
reasons for that
this table is pulled from I think DB
engines or Garnett and it's basically
like a global ranking of databases and
as you can see MongoDB here is number
four in popularity above it you know
Oracle my sequel and sequel server are
all sequel relational databases Mongo is
the first and most popular no sequel
database and aside from Cassandra and
1/8 and Redis at 10 yes it's the only
database or no sequel database on this
list
further down the list are things like
rethink DB and CouchDB but in terms of
popularity Mongo currently is is number
one by kind of a longshot and Mongo has
an interesting I'll say interesting
design decision that I haven't seen in
any other no sequel database as you saw
it intermix is query operators with user
provided data so when you construct a
query you may have you know a field and
then in the place of a value can either
be just a primitive value or it can be
some kind of query query operator object
and by mixing data and control
structures like that it really opens
itself up for this kind of sequel or no
sequel injection and I feel like that
that sets it apart from other no sequel
databases in particular Redis doesn't
really isn't only susceptible to this
issue because on the whole Redis is just
a lot simpler of a solution right it's a
key value store so when you're operating
on Redis through either getting or
setting keys you may be getting or
setting hashed keys things like that but
you only ever have one operation you
don't really add sub queries or modify
that operation in complex ways you just
have your operation followed by data and
that data can't only be escaped and if
you're constructing your queries
properly no sequel injection rig isn't
really an issue couchdb is an older no
sequel database it's like Redis and then
it's a kind of a key value store except
it opens up the door for more
complicated queries through what it
calls views which are basically just
like pre-programmed filters and
aggregations that the developer creates
ahead of time and by creating those
ahead of time
you don't give the end user the the
option of injecting new control
structures into those into those views
they're already set in stone the only
thing that user provides is data and
that data will never affect the flow of
the query we think is a cool new
database that's that's gaining a lot of
popularity lately and in the same way
that couch CouchDB said it's queries up
in stone ahead of time Redis does the
same thing using a cool chained API so
you start every query with your table
and then you filter down by chaining
functions training filter functions and
again you can't alter the flow of those
queries they're set in stone at compile
time the only thing that user can ever
do is provide data and that data will
never will never be given the
opportunity of changing the flow of the
query or taking over the query and that
idea in general is kind of what has made
our EMM successful in a way right so an
ORM is basically just a library wrapping
around your your database query so by
chaining together these these filters
and update operations you can create
your query object without ever actually
dealing with the object itself laravel
if you've used that a PHP framework has
a MongoDB wrapper a wrapper around oh
it's a lara or an eloquent ORM wrapper
around MongoDB and it actually solves
the the no sequel injection problem for
laravel you build all your queries with
this ORM and it creates this nicely
formatted Mongo DB query object and
because you use the ORM your queries are
set in stone users can't inject
additional query operators into the
query so it kind of avoids the entire
issue of a user hijacking your query
object from you by bringing it back to
mom go that I feel like those two
reasons you know the popularity of Mongo
and that interesting design decision of
intermix and control structures and user
provided data I feel like those set it
apart
when it comes to no sequel injection and
I feel like if you're using mom go as
long as you're aware and as long as
you're thorough and you're checking of
user data you'll be fine it's just
something to be aware of and something
to watch out for so thanks guys
I shared a couple links here the first
is to meteor shop the Rob Conway app
that I talked about and the second link
is to a meteor plug in our package that
I've written called check checker and
check check ER just does some basic
static analysis of your meteor
application and make sure that all of
your publications and methods are doing
proper checking of user provided
arguments and if you if you're not
checking anything it will give you like
a linter style warning in the server
logs so I'll hand it back over to Josh
josh there any any questions indeed yes
many many questions so cool we'll get to
we can close that one we'll get to
Ramsay's question first our next speaker
had a question does using graph QL with
Mongo mean we don't have to worry about
any of this ever again ever ever yeah so
embarrassing I haven't looked in the
graph QL that much yet I feel like it
might I really I really can't speak
objectively here but because you're kind
of defining the structure of the data
you want on the client right and doing
actual queering on the server you should
have a lot more control over what that
query looks like I don't want to you
know talk about stuff I don't know about
but I have high hopes for graph you well
maybe oh yeah this weekend yeah just get
it done
come back to us because answer all right
I know we've talked about this before
but are there any good ways to find
available method calls or subscription
calls that a client could make without
access to the server-side code in media
so like definitely yeah there are a few
ways
I didn't talk about that in this demo
because I wanted it to be kind of meteor
agnostic but so if you're on a meteor
app you can open up your console and you
can look in the meteor object there's a
connection object and if you look in
connection dot underscore method
handlers that'll show you all of the the
client-side method handlers and you can
view the source of those by saying like
connection method handlers dot whatever
method to string those are methods that
they've made public to the client you
can also dig through the source looking
for just meteor calls and sometimes
you'll find methods that they defined on
the server so they're not visible to the
client but you can still see them being
called so you know they exist
right so you can kind of peruse out the
arguments and figure out what to call
them with and you can tamper with them
that way you can also just watch the GDP
wire to see what's being called yeah
okay are there any other security
concerns we should look out for besides
no sequel injection when it comes to a
meteor app specifically I feel like you
covered a few actually yeah yeah it was
mostly no sequel no sequel is for sure
the biggest one I mean there's always
you know the old monster of XSS that's
not really that big of a deal in meteor
though over publishing is a big one but
that kind of comes back to no sequel
injection I mean you should check out my
blog I talk a lot about different types
of vulnerabilities indeed all right huh
no I have you haven't I've blog posts
that we mean okay how did you get into
security was something hacked that got
you interested so I've always I've
always kind of been interested in it my
first job in college was actually as a
penetration tester for a company called
Citadel and that was like to this day
one of the coolest jobs ever had
so basically I would like run automated
scans on web apps and I would verify the
results and you know look through the
app myself and kind of try some hands-on
stuff and then show the application
owner you know your app is vulnerable
here here and here and you should fix it
by doing this and yeah I mean it I've
always loved it it's it's really fun
like it's almost like a little like a
puzzle
you're trying to solve yeah that's
awesome all right okay okay we'll
totally do this one maybe do you think
insecure meteor package should exist do
you think the default meteor create
should create a boiler app complete with
secure methods
yeah so there's been a lot of talk about
that right yeah to have it removed I
think it would be a good idea to make it
debug only but exactly exactly and if
you want the insecure functionality like
you can go and add I think you've talked
about this a lot like you can add a
package that's you know insecure you
know explicitly allow insecure in
production like a meteor a dance at your
production or something like that
yeah so you know I actually I totally
tried to figure out how to market be bug
only but like I don't I don't know what
exactly they've got going on who is
insecure but it's like I got like four
packages deep and couldn't find the
actual code and just like yeah these
older packages I've noticed yes yes they
do and insecure is one of those like it
it seems to trigger an if statement
way way lower down somewhere in another
package so yeah I totally think they
should remove that or make a debug only
and I also think you know same thing
with auto publish I don't really see in
reality right for like prototyping but
you really don't want to go to prod with
insecure or auto publish on your app
like bottom line don't yep don't ever
feel and people people have totally like
I've seen
professional level coding shops that
have let people launch with you know and
secure still left in there yeah yeah
alright alright one more will do one
more
is there a meteor ORM like library that
protects us from mongos issues like the
lore of l1 so have you used any of the
other ORM options out there not for
meteor know there's like astronomer
astronomer yeah I haven't used this rana
mer but that seems like the the kind of
prevalent choice right now if you want
to get that yeah up yeah but no I
haven't used it either to be honest all
right so we've got about five minutes
before the next talk starts so we'll
take a quick break and then we'll get
started with that talk again and I just
want to say thanks Pete for coming on
and doing this talk it was awesome yeah
it was a lot of fun if you guys have any
questions you know let me know I'm on
Twitter yeah whatever definitely or the
slack chat I was appearing there yes I'm
gonna keep this slack room running
forever I think it'll be awesome
and then also I'll put a link to the
YouTube video in the chat as well you
did a talk that was similar but slightly
different at Space Camp
- so yeah one thing crystal crypto quick
said simple schema and yes simple schema
for the win that protects you from a lot
of stuff so yeah yeah he even suggested
using you could use schema as an input a
way to check your inputs I'll check you
to say check
variable simple schema whatever you're
gonna yeah awesome all right thanks guys
we'll see in the next video this video
has been in space dojo production you
can click the learn more button to find
out more about us at space dojo comma or
in click the subscribe button to get
notified about new videos we've put out
week thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>