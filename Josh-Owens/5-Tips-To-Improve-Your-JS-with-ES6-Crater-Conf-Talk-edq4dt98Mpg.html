<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>5 Tips To Improve Your JS with ES6 - Crater Conf Talk | Coder Coacher - Coaching Coders</title><meta content="5 Tips To Improve Your JS with ES6 - Crater Conf Talk - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Josh-Owens/">Josh Owens</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>5 Tips To Improve Your JS with ES6 - Crater Conf Talk</b></h2><h5 class="post__date">2016-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/edq4dt98Mpg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is a video of a talk from crater
remote cough given to a live audience in
February 2016 this video was made
possible by sponsors like modulus I oh
ok grow calm and space dojo calm if you
would like to find out more information
about upcoming conferences be sure to go
to conf crater on Io and put your email
in the form that pops up in the lower
left corner enjoy the video hello
welcome everyone to the first ever
crater conference if you don't know me I
am josh owens and i'm pretty excited for
this so thank you for showing up and
hopefully i think we've got a number of
great talks lined up we're doing for
each day they all have different links
so if you're if you're in this one you
know there'll be another link coming
afterwards for the next talk and so on
and so forth and then also there's a
slack chat room if you somehow got this
link but you haven't set up slack I
would advise getting in there as well I
think it's a more general place to chat
also keep posting the links in there as
well so without further ado I want to
introduce derek bailey let me see how do
i switch from watch me code so welcome
Derek thanks for having me it's pretty
awesome to be here I love doing these
virtual conferences somebody in the
audience from Australia hey Mark weight
from Australia it's pretty awesome
waking up at 4am for this no joke that's
some dedication definitely yeah all
right well I will let you get into the
talk but just a little bit of
housekeeping before we get started if
you're watching the talk you can leave
comments in the sidebar on crowdcast and
then in the the main area there's a
questions and topics so you can come
cue up your questions there for the end
of the talk and we'll go through those
time permitting at the end and feel free
to upload we're going to start at the
top and work our way down based on
upvotes so all right leave it to you
Derek awesome i'm going to switch over
to my slides to start with here title of
my talk of course is five tips to
improve your javascript with es2015
formerly known as es6 i guess we are
officially calling it es2015 now and
people are trying to make more of an
effort to say es2015 with the es 2016
release upcoming as well so there's
going to be more of a movement in the
JavaScript language itself in the coming
years but even even with more movement
coming down the line there's already a
lot of movement in JavaScript these days
if you've been paying attention at all
even just the tiniest little bit to the
world of JavaScript you probably have
been either very excited about how
quickly things are moving and how
amazing the things are that we can do in
javascript or you might be on the other
spectrum where you're kind of getting
burnt out where things are just
constantly changing and it's impossible
to keep up and you stay up all night
trying to figure out what's going on and
what you should be using and where is
everything going and it can be a hassle
at times I mean even for somebody like
myself who does JavaScript
professionally for a living I do client
work with JavaScript I teach other
people how to do the JavaScript that's
my job it's overwhelming there's just so
much going on so kind of leaves you
wondering well where do you start
there's there's so much stuff already in
es6 that it's it can be overwhelming as
it is and and now es7 or 2016 is coming
down the line so so where do you start
what are what are the most important
features in es6 what are the things that
are really going to help you the most
right now and frankly I had a difficult
time picking which things i wanted to
show there's
so many great things in es2015 is six
that I use on a daily basis but I did
narrow it down to just five things that
i want to show you today and that is
arrow functions the object literal
shorthand which I've also combined with
computed properties in object literals
these spread and rest parameters which
are technically two separate things but
they're so closely related in syntax I
always show them together modules which
are incredibly important especially if
you're doing browser-based code these
days and want to do you know compile
down to a single file and then D
structuring assignments which is a
really powerful way of getting multiple
variables out of a single object or
single return from various places so
without really any more do in terms of
what features are available in es6 I
want to dive straight into the code here
and show you these five things that i
use on pretty much a daily basis
starting with arrow functions now I've
got some code here this is pretty basic
code this is the kind of workflow code
that I would build in on my average
browser-based JavaScript application or
even a node-based JavaScript application
I've got this function called add the
user and the goal of this function is to
run the workflow for adding a user the
first thing that's going to do is get
some user detail and i'm using this
callback style of continuation for the
function to say that there's some
asynchronous work going on but the user
is going to be shown some form there's
going to be a call to a server there's
going to be something asynchronous in
this case I'm just simulating it for the
demo code but the idea is that I want to
get some detail for this user once i
have that we're going to continue on
with processing this add new user
workflow at this point I've got a user
I've got some detail I stuff those two
things and stuff the detail into the
user object and now I want to show that
you had your info maybe as a
confirmation screen maybe as a what you
just did maybe you know for whatever
reason I want to call this show user
info screen
can we can any of you out there though
guess what's going to happen when I try
to call this show user info right here
and I can't really see me in the
comments at this point in time but i can
guess there are some people saying this
will or won't work and if you're
guessing that this won't work well
you're right this is not going to work
this is just going to blow up in my face
right now because the value of this is
not going to be correct it's not going
to point to this user workflow object
like I want this is a common problem in
JavaScript the notorious this keyword is
easily the most frustrating keyword in
all of JavaScript and there's been a
terrible history of misunderstanding it
and getting it wrong and being
frustrated with it and there's a lot of
great material out there that explains
what it is and how it works and one of
the most common solutions to solving
this is using that by creating a
variable and assigning it to that equals
this any place that I was previously
calming this dot whatever i can say that
dot whatever i'm creating a closure
around this that variable which I know
it's a confusing thing to say or on this
that variable but I'm creating a closure
around this variable and then using that
in order to call show user info this I
can't tell you how many times I've done
this countless number of times but with
es2015 and the arrow function I can
remove this I don't have to use var that
equals this anymore I can switch
straight over to this arrow function
syntax right here and now I have direct
access to this inside of that callback
function so if you look at the
differences between these two chunks of
code will notice that all I've really
done is removed the keyword function and
then insert it an arrow right here so if
I switch back to the file so they file
here there's no function declared right
here and i've added beef two characters
as equals greater than as an arrow
function so what this does is it tells
the JavaScript runtime to use the
surrounding
text of this callback function right
here and bind this function to the
surrounding this to this from the
surrounding code what that really means
is when i call vista user get user
detail i'm using this as ad using excuse
me i'm using this as user workflow most
likely i'm going to call user workflow
dot add new user which is going to set
this to be the user workflow object
since i've done that since admin user is
going to be called with user workflow as
the value of this beef arrow function
right here is going to bind this inside
of the callback to say this is equal to
user workflow so now i don't have to use
all those hacks and workarounds like i
previously done I don't need VAR that
equals this I don't need to do crazy
things in order to get the value of this
set correctly in my JavaScript I can
just use this simple arrow function and
know that the the value of this inside
of this function is set to the same
value as the surrounding code and that's
a very important detail right there the
surrounding code is that there's an
issue that I ran into once where i was
using mongoose inside of nodejs and
Mongoose is an object document mapper
for mongodb and mongoose allows me to
create a schema a minute allows me to do
things like virtual properties to say I
want in a property called full name for
example and I want to add a getter to
that property now I tried to use an
arrow function on this getter once but
remember a moment ago when I said that
the value of this is determined based on
the surrounding code well there's a
problem because what is the surrounding
code for this get its this empty space
out here that doesn't really have
anything going on there's nothing there
there's there's no surrounding code so
it turns out that using an arrow
function at this point is a kind of a
dangerous thing
to do I'm going to end up setting the
value of this inside of my function to
the module that contains the schema that
is definitely not what I wanted to do I
want to be set this to the actual user
model object the object instance because
I wanted to get the first name and I
wanted to get the last name and I wanted
to format that well there is some danger
to using the error function in this case
I don't want to use the error function I
want to use a standard callback function
as such so that I will have so that I
can allow Mongoose and this user schema
to appropriately set this for me so
while arrow functions do solve a lot of
problems in es6 and they are one of my
absolute favorite features in es6
they're not a complete solve everything
solution it's not a panacea golden
hammer that you can just pound any nail
with and it magically fixes things it is
unfortunately just another one of the
now six different rules for mastering
javascripts this it's an incredibly
powerful rule and an incredibly powerful
tool and I would highly recommend using
it just note that you need to know how
to determine what the value of this is
going to be when using that error
function otherwise you're going to run
into bad situations like I ran into with
Mongoose and the schema here Leon arrow
functions there's a lot of really cool
features in es6 to just kind of simplify
our code and object literals are one of
the things that I use all the time I can
have variables and functions and
everything all defined wherever I want
however many of these things that I want
and I can collect these things together
into an object literal so that i can say
do things about one thing do things
about two things do things out read
things whatever method i want to call
off of here this is just an object
literal it's got a key and it's got a
value key on the left hand side and
value on the right hand side the right
hand side happens to be pointing to
functions in this case but honestly it's
kind of annoying I don't like having to
repeat one thing one thing to thing to
thing
red thing right thing blue thing
blooping just obnoxious and it gets even
worse when we start adding in additional
features and functionality like trying
to determine how the object is going to
be composed at runtime based on some
variables so now i have do things with
just one thing to thing and then i have
color things which include red thing
blue thing and i'm using a variable
called color to determine which color
thing i want to assign to the do things
object well in this case i'm assigning a
red thing to the do things object so i
can say do things and I do have a typo
there but i can say do things that one
thing to thing and red thing at this
point well this gets again a little bit
obnoxious I don't like having to put all
of this code outside of the definition
of the object literal it just it adds
more code than I think there should be
inside of the definition of this object
inside of the composition of this object
and that's where object literal
shorthand is really going to come in and
help us out the first thing we can do is
just get rid of the key value pairs
instead of saying one thing colon one
thing I can just say one thing and the
JavaScript runtime it's going to know
that one thing right here references one
thing this function and it's going to
automatically create the equivalent of
that one thing colon one thing this key
value pair is being represented by only
the name one thing and whatever the name
of this variable is that's the name of
the key that you're assigning to the
object so when I say do things equals
parenthesis one thing calling to thing I
can still call do things dot one thing
and be things doc do you think down
below I have color things which I've
also used a shorthand for but I'm still
doing this new thing bracket color plus
thing in order to dynamically assign the
color thing that I want to the object
well this is where object property I'm
sorry I can't remember the name of it
now yeah well well there's a shorthand
that we can use for this now we don't
have to use
the long-form version of this code
anymore where I'm stepping outside of my
object definition in order to
dynamically determine which color thing
is going to be composed into this object
I can I can view exactly the same thing
inside of the object literal i can use
brackets and have color plus thing and
this will be evaluated at runtime to say
red thing because i still have color
being assigned to read so now i'm going
to take red thing and and pull that out
of the color things and then assign it
to this object so i can have do things
that red thing just like i did before so
this is some of the syntax that we can
add into our code just to simplify
things just to make it a little bit
smaller a little bit easier to read and
I find myself doing this a lot again
it's not really this crazy advanced cool
thing it's just less code to have to
write it's less obnoxious to have to
read one thing calling one thing to
think ol imputing and in my book saving
a little bit of code is definitely a
valuable thing to do when you're writing
code now I'm not always going to try and
write the least amount of code possible
I would rather have my code be
expressive than be short in this case I
don't see those two things in conflict I
see this being expressive and short so I
want to do the expressive and short
thing now there is there are a lot of
other features in es6 that i would like
to talk about of course but one of the
most important features that i found
other than arrow functions and optic
patrols for shorthand is the ability to
reduce array manipulations with the
spread and rest parameter operators now
if you've ever written variables that
are arrays and you've tried to
concatenate those arrays with other
values you may end up with a large
amount of cruft decode like this and
sure there are ways to simplify this
like you could say dot can catch and you
could pass in the B array right here and
it would produce a new array and there's
a lot of different methods in a lot of
different ways to concatenate
concatenate arrays together the ultimate
goal though is to end up with an array
that has
one two three the letter C 4 5 6 and the
letter D well with EF six and the spread
operator which is literally just a dot
dot dot in front of an array we can
shorten that amount of code
significantly this produces the exact
same output as this it's just a lot less
code and again in my book writing less
code like this is incredibly valuable if
it just makes all of my code in this
file easier to read I know with this dot
dot but I'm going to spread all of the
values from this array into the
resulting array that I'm creating and
I'm doing the same thing with be over
here now spread operator isn't just for
putting values from arrays into another
array though you hear some really cool
things with the spread operator
including replacing be food apply that
the dot apply call on methods hmm I've
got a Foo function here it does nothing
more than apply then console dot log
some arguments it's a really simple
method and I've got an array of
arguments maybe you have some dynamic
code being generated somewhere maybe you
have a function where you just don't
know all of the arguments that would be
going to be passed in and you want to
forward all those arguments to a
function call well in the old schoo old
school code we needed to use food apply
or function dot apply pass in a value of
this which of course we just discussed
and then give an array of arguments to
be applied to the function above it's a
really common thing to do but again this
code can be greatly simplified with the
spread operator so if I look at the next
file here we can see that I can reduce
that line of code dr. Jeff darks what
this is going to do is spread all of the
values of this array across all of the
parameters that are passed into this
food function if I have more value to
hear if I have some like six seven eight
it doesn't really matter I can pass in
as many arguments as I want to this
function and
function is only going to have these
five or five main parameters here but I
can spread all of these arguments across
this function and again reduce the
amount of code that I'm using to call
this food function but also make it
easier to understand when I look at food
not apply undefined I have to
continuously look at this and reevaluate
okay why is undefined being passed in
here what is she okay foo as a function
well is that function attached to an
object somewhere should I be saying bar
dot food apply and passing in bar right
here it's it gets confusing and I don't
really like having to deal with that on
a regular basis so with this spread
operator even if I have the Foo function
attached to a bar object I don't have to
worry about setting the context or
setting be this variable as the first
parameter I can allow the spread
operator to just spread these arguments
across all the parameters that are
passed into this Foo function and I
don't have to worry about anymore
anymore again it's just a nice way of
reducing the amount of code that I have
to write inside of my JavaScript lb rest
params looks very similar to the spread
operator in fact I got it confused for
quite some time and I tend to lump the
two things together because it is
essentially the same syntax it's just
the other side of spreading array
parameters array values across the
parameters of a function instead of
excuse me instead of spreading
parameters across this function one of
the most common things that you have
that you do in javascript is take
parameters that are passed in and split
it into an array of arguments that are
passed in so every javascript function
has this arguments object that you have
available and this will list all of the
arguments that were passed into the
function call now I don't like having to
do this but this again is a very common
thing to do you want to take all of the
arguments passed in and you want to
slice it up into an actual array so that
you can do something with it well the
spread operator is going to allow you
once again to reduce the amount
code there the spread operator looks
like the rest params that are I'm sorry
the rest prams operator looks like the
spread operator as I mentioned before
but it's kind of the opposite instead of
spreading arguments across the across
the parameters of a function we are
going to get the remaining arguments
from this function as an array so this
gets really interesting when you start
adding and other parameters at the
beginning of this function so I can say
something like ABC and what this does is
allow me to say ok hey it's going to be
assigned to one B is going to be
assigned to see is going to be assigned
to three and this args variable is now
going to be assigned to the remaining
values 4 5 6 7 8 9 and 0 so instead of
having to do what I did previously where
I would say a B C and then I would apply
this with the parameter of two in order
two or three whatever it is in order to
get the rest of the values after a B and
C well I can just use this excuse me I
can just use this rest parameters to get
the remaining arguments as a very as an
array inside of my function once again
this is all about reducing the amount of
code that you have to write in
JavaScript which ultimately is one of
the best things about es6 there's a lot
of great ways to reduce the amount of
code that you have in es6 and that's
really what i like to focus on when
looking at it keeping of reducing the
amount of code it's pretty common to
have something like array RX being
passed in here and to grab play my brain
just went blank that was what i wanted
to look at so it's pretty common to pass
in an array of arguments and take some
of those arguments and just kind of pull
them apart and deal with them and this
is kind of a terrible example normally
you would just do ABC but let's pretend
that this is something that you want
when I be somewhere you'll have these
args you'll have a B and C set up as
variables that you're pulling out of
this array well there's nothing wrong
with this code this works obviously this
is
something that you can be very easily to
get values out of your arrays but with
be structuring assignment in es6 once
again you get to reduce the amount of
code that you write right at this point
in time so instead of having all of
those variables each individually
grabbing values out of args we can use
be structuring assignment to say hey I
know that this is an array and I want to
create three new variables at this point
in the code and assign them to the first
three values of the RX now this this
code kind of confused me at first
because my look at this at first I saw
oh I'm creating an array as variables
well no but yeah this is the array
syntax but when the array bracket syntax
is used on the left-hand assignments and
being assigned to an actual array over
here the JavaScript runtime knows that
this is in reality destructuring
assignment so this code that's one line
right here is actually the equivalent of
these four lines out here instead of
declaring VAR a B and C and then
assigning them individually I am
collectively declaring a B and C and
then d structuring this array into those
variables so the first value out of this
array is going to a the second value to
be and the third value to see exactly
the same as it was doing here once again
reducing the amount of code that I have
to write inside of my JavaScript but I
gets better because we're not limited to
just a race we can also do this with
object literals so we can have object
equals ABC you know standard object but
I'll syntax here and then instead of
using the brackets we're going to use
curly braces to say I'm restructuring
from an object so I'm going to take the
key values out of this object and assign
them to the variables a B and C it's
pretty slick being able to do this if
you've ever had a function where you
wanted to return multiple values and you
end up returning an object literal or an
array and then pulling those values out
of that function well this is really
your solution this is the easiest way to
get those values out of that particular
function
there's some really cool things that you
can do by combining be structuring with
rest grams as well so in this case I've
got a spread operator as well whatever
it is rest are spread I can't remember
exactly again I get the syntax confused
all the time because rest and spread are
pretty much the same syntax just apply
to different places so let's say though
that I've got this object literal and
I've got ABCDEF well i know that i want
a B and C as individual variables but
then I want an array of everything
that's left over that's what this syntax
here is going to do this is d
structuring assignment using either rest
or spread I can't remember which to pull
all of the remaining values out of
object and put them into an array for me
so that's left over this variable here
is going to be an array with bemf inside
of that array so there's some really
cool things you can be with be
structuring and you can combine it with
different date with other things like
rest and spread parameters in order to
get some really cool effects Oh lastly
for the things that I find incredibly
useful in es6 I want to take a step back
from code that allows me to do more with
less and look at modules if you're not
using modules in JavaScript you really
need to get on that bandwagon modules in
JavaScript are an incredibly important
piece of where things are going the
ability to have an import statement in
my code and have it pull code from
another file and bring it into this file
so that I can use it as in my simple
math example right here that's that's a
feature that most systems out there
already have most languages already had
ruby has that Java has that dotnet has
that pretty much every system in the
world has that but javascript
historically has not had that until the
invention of the pre compilers where we
were doing things like browserify and
compiling common J's modules which look
like nodejs and compiling those into a
single file well now javascript has an
official syntax to do all that for us
not only to give us the ability to
import code from another file but also
of course to export and then to at some
point in the future dynamically load
those modules from the server as needed
so there's going to be a lot of really
cool things sort of happening with it
with modules in javascript in the future
and I've shown a really simple example
of here I'm just doing an export default
math which is just taking this math
object which of course I've used the
shorthand object literal syntax with and
it's exporting that math object from
this file inside of my index KS to
import my math from the math file and
then we're going to call my math not add
well this is what what it looks like
when you use the default export from a
javascript es6 module and if you're
familiar with nodejs or common KS you
might be more familiar with the module
exports equals maths index this is
essentially the same thing it gives you
the same effect the same end result it's
just doing it the es6 way but there's
more features and more capabilities
inside of es6 than just that default
method sure in the so in this second
example here it looks the same from this
perspective but when I look at the map
out GS file we're seeing some different
code we're seeing not only that import
add from ad which is the same import
that we saw previously the same basic
import but we're also seeing this import
with this curly braces around the name
and if you remember from the D
structuring assignment a moment ago well
curly braces when creating a variable
gives you destructuring assignment so
I'm saying at this point create a
variable called subtract as the import
from Reese abstract module and what
that's really doing in the background is
allowing me to have multiple exports
from my subtract module I'm no longer
limited to a single module exports like
I was in common J osorno jayus I can now
say export subs export this subtract
function right here and I can say export
this constant here and I can say export
some default thing here and I can have
all of these different
pieces of my module being exported on
different lines now it may look like
it's not really a big deal this might
just seem like oh well I just use object
literals for that previously in OGS but
the things that you can do behind the
scenes especially with editors and I des
that know how to support this export
syntax and imports impacts you're going
to get a lot of really cool features out
of intellisense and other things instead
of IDEs in the future you'll be able to
do more static analysis like you would
be able to do in Java or.net because
this export syntax is going to allow
IDEs to do cool stuff like that but even
without IDEs even if you're using them
like I am which I still think it's kind
of crazy sometimes having multiple
exports from a file is incredibly
valuable there have been countless
number of times where I've gone into an
imperial module and just set up a object
literal to have multiple exports exactly
like I'm showing you right here here's
an object literal and i'm exporting that
object literal with multiple things well
instead of doing that i can just view
multiple exports i don't have to export
it as one single thing like this yeah
sure in some cases it does make sense to
have an object literal that you're
exporting and in this case I don't have
a problem with that but I'm not required
to do this anymore in order to have
multiple exports I can actually have
real exports multiple times inside of
this file another thing that i want to
show you here is back in the SUBSCRIBE
file i have this crazy-looking object
literal syntax here which says export
subt as subtract well what this is doing
is aliasing this sub function as the
name subtract in the export so that
gives you the ability to have internal
method names that are different from the
external API that you are exporting from
this file unfortunately the way they did
this with all this export stuff export
const export objects export VAR i do
think it's a little bit obtuse in terms
of the syntax and i have to constantly
look it up it took me a few minutes to
figure out the exact syntax to export
and aliased function
at this point I was expecting it to just
be this object literal syntax but that
didn't work but actually through an
error there is a very specific
formatting that you need to follow for
your es6 module exports and imports so I
do recommend looking that up and
studying that because it is different
syntax then you're probably going to be
used to but the end result is well worth
the time as we can now have one common
format for exporting and importing files
in JavaScript and we can still use
compilers and pre compilers and
everything to package this up for either
nodejs or for a browser or whatever else
would want to do so there's a lot of
great stuff in es6 and i've only kind of
really touched the surface with these
five things that I really enjoy arrow
functions object literals spread and
rest parameters restructuring assignment
and modules but the reality of es6 is
not every environment we're going to
work in supports this yet sure we might
be able to get it to work on our
favorite browser we're in our favorite
server-side runtime with the latest
version of node but chances are the end
users especially in browser land are not
going to have all the latest browser
versions all the latest features support
it so that just brings up the question
well okay all these features are great
but how do I use them how can I use this
today and actually be able to deliver
code that works for my end users well
the answer to that in my mind is Babel
j/s Babel is quite frankly an amazing
little framework that allows you to do a
lot of really cool stuff more than just
es6 to es5 compilation which is what
we're really talking about taking es
suck es6 code and compiling it down into
code that will run in current browsers
and current run times so i want to show
you babble real quick i'll actually run
a demo in this case it's pretty slick so
I've got my math module will set up
again I've got this import my math from
math inside of my math module I've got
this object literal shorthand syntax
it's pretty cool it's pretty simple
stuff so I'm going to head over to my
command line here
let me bump up this font size real quick
go into my code I'm going to go into my
babble demo and I'm going to take the
code from this source folder and run
Babel across it and build it into this
output build folder over here if you
want to say babel source / be4
destination build this is going to take
a few seconds there are a lot of things
going on behind the scenes and Babel is
doing its thing back there for me once
that's done it gives me an output of
what happened and I can load up this
build folder and I can see exactly what
this code would look like in today's es5
code so i can look at the index j s
which was previously pretty short just
few lines of code and i can look at the
build output and there is quite a bit
going on here there's this required
statement here and there's this math
variable and this math two variable with
this interop require default is there's
a lot of things going on here that you
wouldn't write yourself but that's okay
honestly I don't really care that Babel
is producing more code for me because it
I still get to write really simple code
like this index ES File and Babel is
going to handle making it actually run
in whatever environment for me now in
this case if you've ever done any nodejs
you're probably familiar with this
require statement this is going to
require the math module from the current
folder well this math module has an
export stop default equals math this is
just the standard no Jay s exports so
it's great I can use this compiled code
in nodejs but what happens if I want to
use this in a browser well okay at this
point you're going to have to get at
least one more step added into the
process and that is probably going to be
browserify now if you're not familiar
with browserify it allows you to take
what was written as common j/s modules
or node.js modules and compile it into a
single package a single file single jas
file that your browser can actually
so I'm going to show you a simple
example of that I've got a basic Express
jas app set up inside this last folder
here I'm going to go into that folder
and I'm going to NPM start to set up my
little browser my little web server with
express and I'm also going to run grunt
now I have grunt configured to do some
stuff for me it's going to watch some
source files for me inside of this
client app folder and any time any of
the files in this quiet that forward
change it's going to run a couple of
tasks it's going to run Babel and then
it's going to run browserify on the
output of Babel so that's a two-step
build process really when I change any
of the files in this client app folder I
can go over here to source and I can
load up index KS let me just fix that
little vim thing real quick so I can
load up index Jas I can save this go
back to my command line and I can see
grunt is going to run babel for me and
then once that's done it's going to run
browserify for me so browserify is going
to take the babble output which I put
into this build folder right here and
see again the same output that we saw
before or me in this case I'm including
a source map for debug purposes but we
can see the same basic output right here
well this code isn't yet going to run in
my browser because my brother doesn't
understand this require function call
well browserify is going to take that
code and it's going to produce a single
index Jes file for me that my browser
can understand so if i look at this
public Java scripts index Jes file I'll
see here public Java scripts index
gotcha yes there's all kinds of stuff
going on in here that I don't even want
to begin to start tearing apart but this
is what browserify will produce for me
it will take all of the individual files
that I had in my source or in this case
inside of my build folder here which
were compiled with Babel and it will
combine them into a single file that can
be used in my browser let's take a look
at this actually running my
and my browser real quick i'll go to
localhost 3000 there's my express apt
i'll pull up my console increase the
font size here so we can see 2 plus 2 or
2 plus 234 equals 236 that's the code
that i had inside of this module year I
can change this to say 2+2 for example
I'll change this comment as well just to
make sure it's all good i'll save this
go back to the console I can see Babel
once again during the build I can see
browserify doing its thing go back to my
browser hit refresh and now I have all
of that code but I had written in es6
code with modules and imports and
exports and everything is compiled down
into a file that can actually run inside
of my browser and if I click on this in
order to see the file well I'm looking
at a lot of crazy things here I'm
looking at some junk that frankly is
kind of ugly to look at once again
that's where source maps are going to
come into play I don't have source Maps
set up really appropriately in this demo
so I can't show you the easy be bug
ability of source maps in my browser at
the moment but suffice it to say source
maps will help you solve that problem
when debugging code in your browser I've
kind of gone through a whirlwind tour
here of my five favorite features inside
of of es6 and i've shown you babble and
i've shown you browserify but there's a
lot of other features inside of es6 that
you're probably going to want to pay
attention to and some things that i
really wanted to show but i kind of
wanted to distill this down into things
that i would highly recommend that you
start using today so some other things
that you want to take a look at our
things like maps and weak maps now in
JavaScript your standard object literal
can only have strings for keys it may
look like a reference to an object
somewhere else on that left-hand side of
the colon but in reality it's just a
string maps on the other hand in es6
give you the ability to have objects or
other things other than strings
your keys for your objects for for the
key value pairs so instead of just
having a left-hand side of that object
literal be a string you can actually
create a new map and set an object to a
value more like a dictionary in.net or
other languages where you can have any
arbitrary value as the key and any
arbitrary value as the value now a weak
map as a slight as a slight variation of
that where it's a weakly held reference
that allows memory to be cleaned up even
when it's a part of that week Matt
that's a whole different subject but I'd
recommend looking into that additionally
in addition to maps es6 also introduced
the idea of a set the set in a
mathematical term is basically an unique
list of things and that's really true in
JavaScript sets as well if you've used a
set in Java or in.net or anywhere else
it's kind of the same idea here you have
a list of things and it is a unique list
if you try to have the same thing more
than once well the second time third
time fourth time you try the habit is
just going to be rejected from the set
there's also let which is block scope
for variables if you're not familiar
with how variable scope works in java
script VAR is always scope to the
function never to an if statement or a
for each statement or whatever else the
let variable allows you to scope that
variable to the individual block scope
like an if statement or for each
statement or whatever else there's also
const which creates a constant an
assignment to the variable declaration
that cannot be changed of course it's
not completely changed proof it's not a
frozen object so you do want to be
careful with Const although it is an
incredibly powerful feature feature for
simple values that are just hard coded i
use const for simple values as
configuration all the time promises
which if you're from not familiar with
promises they allow you another form of
asynchronous code and promises have been
around for a while but es6 now includes
a native promise implementation so you
no longer have to include additional
libraries like RSVP
or when or acing jas or whatever else
you can just use the built-in promise
object symbols in es6 are incredibly
powerful and i'm really sorry i didn't
choose to show those to you today
because they are something that i use a
lot but symbols are kind of an
across-the-board feature and really
advanced part of es6 that allow you to
have data privacy inside of your objects
you can use a symbol as a key for an
object and you can guarantee that no
other code well almost guarantee that no
other code can get access to the value
of that symbol on your object and then
in terms of simplifying things again
template strings and multi-line strings
template strings in Java Script allow
you to have a hash curly braces variable
name inside of an inside of a string and
it will evaluate a variable of that name
into your string so you no longer have
to do string and string plus some
variable string and string in order to
get variable values into your strings
multi-line strings are pretty much what
they sound like you can just hit return
over and over and over again you don't
have to do those crazy weird syntax
hacks so in order to get your strings
split across moulton lines so there are
some really good things to look at
inside of es6 beyond what i've shown you
here there are some other things that
you'll want to watch which i don't
really use right now generators they are
one of those things where there's so
much potential for generators to have a
ton of value inside of javascript but i
don't really see a lot of value right
now i really see generators as a step
toward what javascript will be able to
do in the future iterators are related
to generators and symbols you can use a
specific symbol called in symbol dot
iterator in order to get an iterator
into your code it's it's a little bit
confusing to me offhand why I would have
an iterator on my code I don't quite
understand why I would use iterators in
my objects except in the case of
generators generators if you're not
as I mentioned before they allow you to
do some really interesting things with
coding including what looks like in line
asynchronous code in some cases but
generators ultimately allow you to have
code that can be partially stepped
through one thing at a time and it does
that through the use of integrators
you're actually going to iterate over
the function execution every time you
have this yield keyword inside of your
generated function I don't really want
to go into more detail there I'm
probably confusing people already it's
an incredibly deep and powerful subject
in es6 and i would recommend reading
some articles and watching some
screencasts on generators and iterators
to really understand what's going on
there typed arrays being the last thing
to watch typed arrays confuse me at
first as well but it turns out they are
just a way to do binary data inside of
javascript javascript has historically
been terrible at binary data it just we
haven't really had a good way of dealing
with it directly in JavaScript we've
always had to go back to native code
implementations inside of whatever
runtime environment we were in with
typed arrays we can now properly handle
binary data you have typed arrays of
like you in 16 32 or signed integers or
whatever else there's a lot of good
features that are going to be built into
JavaScript using binary data now
including I think a lot of textures and
3d rendering and stuff like that so
there's definitely some cool stuff some
cool things to watch for the future of
JavaScript may not really be useful to
all of us especially not right now but
there's definitely going to be some cool
applications of these technologies in
the future lastly I do want to mention
my one dis honorable mention in es6 and
that is classes personally I think
classes were a huge mistake in es6 I
came from a background of dotnet and
other object oriented languages which
were very class oriented and I fell in
love with JavaScript prototypal
inheritance really quickly and I think
what they've done with classes in es6
was is nice from
spective of people that are coming from
other languages but all they've really
done is muddied the waters of prototype
of inheritance even further in
JavaScript instead of fixing the
problems with prototypes and prototype
syntax in JavaScript well they just
added more syntax around prototypes
without really calling it prototypes in
the mo es6 classes are still prototypal
inheritance but they add a new set of
syntax that you need to learn and new
sets of restrictions like you can't put
values directly into object literals at
this point in time you still can't have
hidden private data inside your classes
at this point in time both of those
things are supposed to be coming in the
future but they're not coming in es 2016
it's going to be beyond that probably es
2017 I really think classes are
something that you should look at to
understand because you're probably going
to see other people writing classes but
in my book I would avoid classes at this
point at least until they actually make
them really usable by adding all the
missing features that are out there but
with that that's pretty much my
walkthrough of es6 and what you should
be looking at you should be looking at
arrow functions you should be looking at
simplified syntax with object literals
be using rest and spread parameters
using the destructuring assignment and
of course using modules in your code
with probably babble and browserify in
order to make your code compatible with
your current JavaScript runtime
environments and if you're doing things
like meteor which I gather a lot of you
in this in this audience today are
you're probably already set up with es6
modules in media I think media or has
that built in at this point and if not
you should be able to add it pretty
easily so I do want to say thank you for
for watching and listening hopefully
this is this talk will give you a little
bit of an idea of what you should start
looking at in es6 and help you down that
path a little ways and i do want to say
if you do want a little bit more help
and assistance getting down that path I
do have some screencasts at watching
econet where I learn es6 live it's an
unedited no holds barred
according of me trying to learn some of
these features figuring out babel
figuring out error functions and symbols
and generators and more recorded for you
to learn along with me along with a lot
of other screencasts that i have for
nodejs and javascript in general so hit
up watch me go down net and be sure to
use the crater cough discount code to
get thirty five percent off you'll get a
subscription a monthly subscription for
nine bucks a month instead of the usual
14 so thanks again and I'll turn it back
over to Josh at this point hey yeah
thanks Derek that was a great talk
everyone seems to be loving it all right
so all right so do some questions real
quick so the first question is do you
feel like some of the es 7 plus features
are worth using today since we have to
use a transpiler any way to get it you
know into browsers and um I say
cautionary yes the the challenge that
you're going to run into with using ES 7
features and beyond is that syntax may
change at some point in the future
especially if you're using early stage
like stage 0 stage 1 stuff where it's
really it's a proof of concept that you
would be using so if you look more like
I think it's either stage 2 or 3 where
it's it's a recommendation that people
are trying to approve if you're in that
stage then yeah I'd say definitely start
using it if you're already using bable
bable is probably going to have that
feature built in you might have to set a
specific flag to get it enabled but
there's there's a lot of good features
coming in in the future of JavaScript
that may not be in es 2016 but are
already a part of Babel yeah yeah and if
you're using something like meteor the I
know in 13 we're going to get module
support up but also there's a polyfill
for promises for a sink and a weight and
so that's that's that's kind of
interesting too because they're they're
actually wrapping all that up in fibers
for you behind the scenes baileys
there's also a talk by Kyle Simpson
otherwise known as ghettofied
this talk at November just this last
November where he talks about generators
and doing a lot of really cool stuff
with async operations using generators
and I would highly recommend watching
that talk to see more what you can do
with generators amazing stuff and I
think there may be some some room for
compatibility and use inside of meteor
apps just based on what little I know
about meteor nice all right um so
speaking of generators I don't know this
is like bed and put this in a very
specific context but what are some ways
that generators can be useful meteor
apps well unfortunately I can't really
answer that since I've never actually
built a meteor app I don't I kind of get
the idea of what it is but I haven't had
a chance to sit down and use it so i
would have to defer that somebody else
okay we'll skip that one for now um so I
asked do you think that it was a mistake
or that it was bad that they left out
the skinny arrow with es6 no i don't and
I'm assuming you're referring to the way
CoffeeScript managed this inside of
skinny aero vs fat arrow I think I did
the right thing by not doing that
CoffeeScript aimed to solve the this
problem with skinny arrow fat arrow and
all they did was make it worse because
the way skinny arrow and that arrow
worked was dependent on surrounding code
and there's this horribly complex set of
rules that you hadn't understand around
those two different syntaxes keeping it
simple with just the fat arrow was the
right move in my opinion I never liked
the way CoffeeScript had two different
versions of that hmm yeah I guess I just
missed the shorthand like you referenced
like over you so fat arrow and I find
most people over use the fat arrow
because they just want the shorthand
syntax and yeah and and the fat arrow
isn't really about the syntax I mean
you're saving like four characters five
characters of typing which really isn't
worth the savings in terms of the syntax
it's it's the functional
aspect of binding this inside of other
side of the fact that really makes the
the error function valuable yeah all
right um I think I address this next
topic in the talk itself yes we do have
didn't worry about support when adopting
es6 and that's where babble is really
going to come into play if your if you
want to do is six in your browser
certain browsers have certain features
enabled i know chrome for example lets
you do generators it also has promises
and it has arrow syntax but at least I
think it has eros index but there are a
lot of features that aren't in browsers
yet and you will want to use babel to
support browsers yeah yeah and if if you
are using meteor that's you know that
stuff's all kind of built-in so already
getting babel kind of cross compiling
down and getting everything ready for
the browser for you so that's kind of
nice all right ah do I think es2015
beyond makes coffeescript obsolete um no
i I've never been a huge fan of coffee
script i'll admit i've worked with it
quite a bit one of my clients and now
good friend was madly in love with it
for a long time so that's what we used
on his projects but i think it was
brandon satram former co-worker of mine
and a product manager at telerik who
basically likened CoffeeScript as the
roadmap for JavaScript CoffeeScript has
done a phenomenal job of informing the
JavaScript community of where JavaScript
can and should go and I think
CoffeeScript still has a lot of value in
that front I don't personally like
coffee script I think they made a lot of
mistakes in the syntax and things that
they did with it but i still think
CoffeeScript is valuable as a forward
movement kind of map I no es 6 in or es7
and beyond in Babel kind of gives us
that now with the ability to play with
syntax and use it early on but I
something like CoffeeScript in
typescript and all these other
precompiler languages out there are
really good at showing JavaScript where
it can go yeah awesome all right so
we'll end it there if anyone else wants
to chat with Derek I'm sure he'll be
hanging out in the slack room and you
can put your Twitter and your watch me
code side in there to Derek yeah
definitely i'm everywhere at derek
bailey so dark vidcom twitter at derek
bailey all that good stuff awesome all
right well I I put the link up to the
next chat so if you're gonna follow on
along on that one hop in there and we'll
get started in just a minute all right
thanks Derek this video has been in
space dojo production you can click the
learn more button to find out more about
I set space dojo com or you can click
the subscribe button to get notified
about new videos who put out each week
thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>