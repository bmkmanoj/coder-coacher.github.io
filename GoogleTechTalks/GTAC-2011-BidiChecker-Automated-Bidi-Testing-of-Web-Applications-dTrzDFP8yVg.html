<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2011: BidiChecker: Automated Bidi Testing of Web Applications | Coder Coacher - Coaching Coders</title><meta content="GTAC 2011: BidiChecker: Automated Bidi Testing of Web Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2011: BidiChecker: Automated Bidi Testing of Web Applications</b></h2><h5 class="post__date">2011-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dTrzDFP8yVg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">our next speaker is the hardest one to
introduce because I don't understand any
of this right so there's a there's a few
if you're trilingual if you speak three
languages they call you trilingual if
you speak two languages they call you
bilingual and if you only speak one
language they call you an American and
that's kind of where I stand so but
apparently there are languages that you
speak backwards this is the only thing I
can think of right so anyhow this is
jana Margolin she's a Googler and she
speaks backwards and she's going to
teach you how to speak backwards as well
okay thank you everybody as Jim said my
name is the animal gaalan are from the
google israel office and today myself
and my colleague Jason album from same
office as me will tell you a bit more
about by the testing and specifically
automated by the testing for the web
let's just say that this is working
right okay so first of all what is this
bite I think pretty much any language
you can think of is written in a
left-to-right order for instance English
German Spanish and so on some languages
however insists on being special and
been written the opposite way in a
right-to-left order such as Arabic for
instance but not only that these
languages still includes some elements
that are written in a left-to-right
order for instance you can see here in
the first example there's a phone number
the phone number is always written left
to right or embedded left to right
strings in the second example here there
is a Hebrew sentence and the world cool
in English appears in the middle of it
and obviously is the read and written in
the opposite direction direct
than the rest of the text because of
that were referred to right-to-left
languages as being bi directional or by
dye in short okay so by the languages
include Arabic which has I mentioned
before Farsi Ordo Hebrew and some more
languages less common ones in total
we're talking about 500 million speakers
and about i would say 140 150 internet
users it is important to note sorry 150
million internet users quite a
difference yeah and it's important to
note that the internet penetration in
right-to-left speaking countries is
about twenty percent so there's a lot of
room for growth and it's quite an
important market share for us going on
words so that's why by the support in
web applications it's so important okay
so this is a quick example to illustrate
how easy it is to come across
bi-directional data on the web what we
have here is the google search english
you I without user input the UI contains
only left to right strings it's entirely
in English it doesn't have any right to
left or bi-directional data but here
comes the user and it's a right to the
left speaking user and its many of right
to left speaker speaking users it
prefers to use the left to right you I
why because it's the default one it has
more features or any other reason okay
so he opens the google search English
you I it types in New York in Hebrew and
you can see that already within the
snippet of the first search result most
of the snippet is right to left it's in
Hebrew but we already have three
appearances of New York in English so
voila that's bi-directional data for you
even though you thought that probably
the chance to get bi-directional data in
this English UI is minimal you can see
how easy it is to trigger the appearance
of such data okay so how does a web
browser knows to display bi-directional
data that's what the Unicode by day
algorithm is for you can see the entire
algorithm at the AdWords mentioned on
top of the slide its pretty long so i
won't bore you with the whole details of
it what's important for our tech talk
today is the following free key key
ingredients first of all this algorithm
divides characters into several types
according to their directionality right
to left left to right and several kinds
of neutrals the second thing which is
important to know about this algorithm
is that it determines the visual order
of the characters how they will actually
appear on your screen and it tries to
work properly without being explicitly
told we're left to right or right to
left text begin and end but it still
needs some help to function properly as
we will shortly see okay so in addition
to supporting the appearance of the
directional data within a regular
left-to-right you I if we want to
support by they properly in an
application we would usually want to
create a right right to left you I for
it to show you an example of how it's
done we have here the regular left to
right English you I of google books you
can see that the overall directionality
of the elements in this UI is left to
right Google Books logo and search
results thumbnails appear on the left
side of the screen while the ads appear
on the right side of the screen for
instance one more thing I want to note
here is you see
that the UI is once again completely in
English the user even typed in an
English query its search for Italy books
about Italy but the ads here are in
Hebrew and they contain bi-directional
data once again you can see how easy it
is to trigger be directional data
appearance within web applications okay
so we have this UI and we want to create
a right-to-left version of it for
instance turn it into a Hebrew light
what we get is pretty much a mirror
image of the UI we saw before if we
shift quickly you can see that it's
pretty much mirrored the logo of the
product and the terminals are now on the
right the ads are now on the left looks
pretty much like a mirror image but it
is not that simple obviously for I want
to illustrate this using these lovely
images of mona lisa george w bush and
margaret thatcher we took these images
and the mirror of them and can anyone
see anything wrong with them other than
the fact that they're upside down right
now they look okay good you must be a QA
person okay so yeah although they may
look quite all right like this if you
look at them in the right direction and
not being upside down you can see that
they don't look that good this is this
is what happens when your mirror and a
UI and don't pay any much thought into
it and don't provide by the support
properly you might think that DUI was
murdered properly but the a user that
will try to use it will immediately see
what's wrong with it okay so how do we
do it properly
first of all we need to declare the
overall directionality of our UI for
instance if we wanted to create an
Arabic you I in order for the elements
in the UI to appear correctly the first
thing we want to do is add the deer
equals LTL attribute to the body tag of
the HTML of the pages this attribute
effects default paragraph alignment for
an after you edit the paragraphs on the
page will be by default right aligned
instead of being the left aligned it
affects neutral items at the beginning
and end of block punctuation images
inputs and so on and it effects tables
the order of the columns within the
tables are now right to left instead of
left to right and of course all the data
within the table all the text is now
aligned to the right and appears with
right to left directionality one
important thing to note here this
attribute doesn't take care of most
layout issues the layout issues are
determined by CSS and we will not go any
deeper into it in this stock okay so
this is our beloved google plus we
decided to create a Hebrew UI for it we
took the English version of the UI
translated some strings and got
something like that well I writes the
left speaker user who sees that it looks
as incorrect to him as this does to you
for instance and you can see the data
within the false it's not very readable
it appears garbled in order to fix it
and create a proper right-to-left
version of this UI what we need to do is
add the body their equals rtl to the
HTML of the page and you can see it
looks much better now the text here is
readable appears with proper
directionality and it's properly aligned
okay so this is the first step that you
need to do when you create a right to
left you I you've done it the user
starts using it it's very happy he types
in rights to live data everything works
fine but then once again the user is not
a fool he wants to enter any kind of
data he wants so this is the google plus
profile page the about tab as long as he
enters right to live data peppers
properly but then he decides to enter
his work address in English 17 Main
Street and look at how it appears it's
not really readable the 17 appears on
the incorrect side of the phrase so is
the period at the end of the sentence
doesn't look too good okay so we want to
fix this problem but without breaking
the rest of the UI because the rest of
the UI is fine how do we do it we
surround this part with a span tag with
once again the deer attribute and this
thing we say 0 equals LTR to signify
that this part is left to right text and
shoot a peeress such you can see that
now the address appears properly it is
readable and the rest of the UI remains
unchanged still appears properly this
span dear equals LTR or our TL attribute
is also useful in the following cases
for instance in the second row in the
table you can see garbled leading
punctuation ok is not okay the opening
quotes appear in incorrect location if
we surrounded with span 0 equals LTR
this will now appear properly and resume
its original meaning same thing happens
if we have a left-to-right page
and we want to insert some Arabic data
for instance to say Marhaba which is
hello in Arabic followed by an
exclamation mark if we don't do anything
it will appear in correctly the
exclamation mark will appear on the
incorrect cell if we surround this piece
of data with span tag with dear equals
LTL attribute it will look properly and
once again be readable okay so one last
thing I want to mention before my
colleague Jason will come and tell you
how to find this type of buggers
automatically is the text input boxes
what we have here is the google maps
hebrew you I with the search box and
usually we would like to enable
directionality auto-detection for these
search boxes which means that as the
user types in the data the
directionality of the data is determined
on the fly the user doesn't have to do
anything and the data is displayed
properly in the first example 17 men
straight as the user typed it in it got
recognized as being left to right string
and it appears with proper
directionality and aligned to the left
in the second example the user typed in
right-to-left query New York in Hebrew
it got got recognized as being right to
left and got aligned properly and it
appears as a children having said that
for some input boxes we would like to
enable fixed directionality no need for
this auto-detection to take place for
instance input boxes that contain URLs
URL only contains English letters it
should always appear with left to right
direction ality so the directionality
for that field is supposed to be fixed
okay so thank you so much for your
attention I would like to invite jason
to come up now and tell you a bit more
about how
this bug is easily automate and
automatically thank you for everything
thanks Jana hi I've to apologize I got a
bit of a cold so I'll be steering clear
of Alberto so I understand that the test
is dead but let's try it anyway let's
see if we can be Manuel by I testers for
a moment we're looking at right to left
a search interface with the left to
right query string and what we're
looking for is opposite directional text
which is embedded somewhere and
typically we have punctuation or numbers
which surround it and which end up on
the wrong side of the letters anybody
okay I think we have a few spotted it
now it's quite possible that a space
odyssey 2001 might have been a better
title you have to take that up with
Kubrick and Clarke but meanwhile we
obviously what's going on here
essentially is that we have an embedded
phrase which is left to right
directionality and which is basically
needs to be wrapped in a span with
directionality LTR because otherwise
essentially the the browser sees 2001 at
the beginning of the phrase and the
beginning of the phrase from its
perspective here is right to left starts
on the right side and it gets it wrong
apparently everywhere else on the page
here they got it right that's already
pretty good let's try another one this
one is more subtle the one I'm thinking
of is up there the URL ends in a slash
now you might say this isn't very
significant it might not be very
significant in this case in other cases
depending on the actual data that
appears there the garbling may be more
severe may interfere with the users
actual ability to
the page correctly here's a map address
of a search result for maps and by now
imagine you've probably found this one
so if you were trying to find your
address in New York City you wouldn't
really be able to give this to a cab
driver you wouldn't know how to find
Fifth Avenue 350 well he might but maybe
if he spoke Hebrew there's another one
actually it's a little harder to spot if
you look a little closer just below that
we have the subway station which is on
thirty-fourth Street and it's not peril
dear 34 and so these are examples where
you might not be able to find a street
sign to see where you're going or we
might not be able to give this address
to somebody in the real world to get
where you're going so by da garbles can
actually cause real problems for real
users and you may also notice that there
are these are hard enough to spot
imagine if you're trying to debug this
in the other case where we have a
left-to-right user interface and the
data is in a right-to-left language the
data is in Hebrew or Arabic and you were
trying to spot these these instances
when you don't even speak the language
so now by this point you're saying to
yourself wow i wish i had an automated
tool which could find these problems for
me well you're out of luck so no not
quite so we have a tool we call by a
checker it's developed inside google and
it basically runs it's a javascript
library runs embedded inside the page
scans the dome for a number of common by
the errors the most common of which is
undeclared text which is the opposite
direction allottee of its context so
here for example pops up a little you I
on your page lets you browse through the
errors and gives you the description of
the error its location on the page it's
at streaked herald square which is the
English text which is not declared and
we have a little hierarchical a list of
start HTML tags to give you a sense of
where exactly on the page you can find
it if you're the developer this is
actually
somewhat primitive you I we're working
on release number two of the UI to let
you organize and browse and categorize
your errors more effectively but it's
it's effective for what it is and talk a
little bit more about how it's used oh
okay I'll talk about more about what's
there for so objectives number one to
make it easier to facilitate the initial
development of bite I support in a
product which means that as the
developer you can run by that checker on
a page and get a list of potential
errors scan through them identify what's
causing them and go back iterate your
development and fix them objective to
you might say well yes we can test for
all these things I can put in a unit
test and check that this field is the
clear left to right and that one is
declared right to left and that's true
but that only catches the things that
you're looking for that will only find
errors oh that you're explicitly
searching for by the checker scans the
entire page and therefore can find
errors and features which have been
added since your unit tests and features
which you haven't remembered to add test
for so it will it'll trap those for you
as well and then finally there's the the
whole or regression test use case where
it's running in your automated sweet
somebody adds a new feature forgets to
handle the by the by wrapping your test
fails the test suite fails product alert
goes up and everybody goes and does
something important about it so here's a
bit of sample code in the JavaScript
unit test we have the test function we
start with a little bit of code in your
application domain to navigate to
wherever it is what the navigate the
page to this the scenario you want to
test and then we call by a checker we
gotta check page function it takes a
couple of parameters one is a boolean
indicating the expected directionality
of the page right to left or left to
right and then there's the element that
you want to test usually we're testing
the whole page is sometimes you might
want to test a particular frame or a
particular element depending on your
test environment than the structure of
your application and it returns a list
of error objects typically we're going
to assert that that list is empty
if an error comes up invited i support
the list won't be empty the test will
fail your test framework will give you a
nice little message telling you what
went wrong and then you can get to work
say a few words about error suppression
why would we want to suppress errors and
this is actually a problem common to
many many automated testing tools first
of all not everything that the test
chill identifies is a real error false
positives examples for in our case our
product names which might always appear
in English for example even in a
right-to-left you I or an acronym like
HTML file format things like that which
appear on the page which we know what
they are they're fixed they're not going
to change and they're not going to
become garbled they're not going to be
replaced by the user with some phone
number or address so it's not worth
investing the engineering effort to fix
the directionality decoration of it it
makes much easier it's much more
sensible to just disable that error from
appearing in our list case number 2 is
known bugs we've already found this bug
we know it exists we filed the report
somebody's working on it or somebody
isn't working on it but there's no point
in in breaking our test suite for it
anymore and the third case we're
referring to is somebody else's problem
we have let's say text that we're
bringing in from elsewhere on the web
there's nothing we can do about it if
it's by date support is wrong or we may
have a module that we're inserting from
another team another project area it's
not our responsibility to fix it so we
can filter that from our results and
this is an example we have a little
navigation list with a number of other
products one of them is gmail gmail is a
name that's a product brand name we
don't translate it it just appears as
Gmail everywhere but it's not causing a
garble it's not disrupting the flow of
the page so instead of getting this
annoying error from by day checker we
can add a little code to filter it out
we are creating a filter calling our
filter factory at text filters out all
messages all errors which appear at the
particular of text string gmail
and we just add our filters to the
Nicole and now our test will run clean
again until a new error crops up that we
haven't yet encountered and we can
filter errors on basically all their
fields on the text on the severity which
I haven't talked about on the location
on the page either by the ID of an
element that contains it or a class name
or XPath we can match on a regular
expression or literal string we can
combine filters with and and or and not
it's both flexible and powerful and
simple error specification language
finally few words about designing test
cases in general there are two main
types of scenarios that we want to test
one is when we have a left-right
interface and we're going to handle
right-to-left data so we have a
left-to-right Google+ and then we are
inserting hear all kinds of
right-to-left content and we want to
make sure that that is correctly handled
so we would need to set up a test case
which seeds the application with
right-to-left data and preferably seeds
all of the fields as many fields as
possible which might handle our tail
data we want the seed so that when we
run our tests we're checking our check
is as comprehensive as possible this
sometimes is technically very difficult
because some test Suites some
application test suites are not designed
to be seated with data per test it's a
problem but it's a fact that you often
have a test suite where you run this
sailor on all your tests on the same
data set and you're not going to go
start generating special data just for
your bio tests so in that case the only
type of scenario we can realistically
test is the reverse case of a
right-to-left interface and your
existing standard left to right data and
then again every field preferably filled
in every field which handles left to
right data in your right to left
interface that handling will be will be
checked and flagged for our own
convenience it's ideal if our data also
starts or ends and numbers and
parenthesis and punctuation and other
sorts of things which are visually guard
by the by the algorithm that's that
doesn't matter to the tool by the
checker will catch any undeclared office
directionality text but you'll look at
that and say well I don't see the error
there it looks fine to me the moment you
have ! or parenthesis or a number on the
wrong side you can also ask the
developer visually spot the problem in a
way that you can't if the text is
visually unchanged but why do I want to
flag an error if it's visually unchanged
because the data is going to change the
user going is going to give me data
which has problems that my test suite
might not be covering so it's important
that from our perspective as the
developers or the testers for that
matter that we're seating it with data
which will visually be garbled by the
body algorithm again that's the tool
doesn't care but we do as humans and the
resources by their check ur is as an
open source project on hosted on Google
Code and you're welcome to check it out
download it give it a real world and
contribute back should you so desire we
also have a reasonably comprehensive
document about how to implement by the
support in a UI it covers everything
llanes got it covered plus a number of
topics that we didn't get to hear I'll
call it the by day how to and that's
also available and finally along with
the regression test the automated
testing scenario that I demonstrated we
have a bookmarklet that you can install
on your browser you drag a link to the
bookmarks link bookmarks toolbar and
then you just click on that on any page
in the browser it will install the the
JavaScript run it on the page give you
your little UI and let you figure out
what's wrong with your pages and your
competitors pages and and everything
like that now I have to remind you of
course that that's only really useful
when you have bio data on the page we
can run this on google search in English
with an English query and it's going to
do great really no problems there
whatsoever that's what we have for you
have to take questions comments tomatoes
sir
oh this is a really testing question but
you smirked my curiosity you mentioned a
couple times while she magical times
auto-detection of by I languages yeah
what processes and methods you used to
do that kind of detection okay well the
the simple answer to that is that there
is code JavaScript code out there Google
closure library for example has
functions which do this and you can just
hook that into the into the the what to
call beyond whatever whichever trigger
it is that you need to hook it into in
the in the input box and then every time
the user adds text to the search box it
will auto detect the directionality to
be a little more specific there are
different types of detection different
algorithms heuristics that are used to
determine if something is left to right
or right to left because it could be
mixed for example or it could have
numbers and then you have to decide do I
want to call this left to right or right
to left and that's that's a whole
different question of how you do it sort
of methodologically but technically the
other this javascript code out there
that you can hook into your page which
will which will do that and you can just
do that for every input box which might
be bi-directional sure so when you were
showing the Google+ interface UI I just
saw that the picture of the icon of home
is not correct if you apply by D ricola
now like avatars on the left and all the
texts and write whatever just so the
question is do you have any anger is of
very fine identifying be yeah obviously
I think that's okay by d text or
something on pictures because like I can
think of bears that have that were not
translated actually to MIT and you can
just you can't just mirror them you know
yeah so your question general is what do
you do about images some of which are
directional yes and some which most of
us usually are not directional and as
far as I know the only the only way you
can really identify that
is manually just because the picture has
a directionality doesn't mean it has to
be reversed for by that like you know
those circles have a particular
directionality but nobody would care if
they were reversed for example if you
have arrows then the direction can marry
it matter a lot to flip the order of
them and they look they look they look
wrong so the only real way to trap the
to trap that is manually I'm not aware
of an automated way to identify it now
we do have automated tools to flip
images and I think if I'm not mistaken
that HTML maybe html5 it'll never
actually has an automatic way to flip
the directionality of an image I'm not
sure it could be wrong on that so the
problem is that you can't really just
click any image no you can't flip all
the images you're kind of actually flip
images at all so like for the home icon
you can do that actually but mostly you
can't now in this case it might not
matter the other answer is yeah it looks
a little backwards but nobody's going to
notice it's an icon and that it's really
a judgment call it depends on the type
of image and it depends on the context
and so you basically all new automated
text checkpoints know me you know
basically all know to my text not not
like images at the moment this test tool
by the checker is only testing the
correct handling of the flow of the text
there are other kinds of ideas we have
for further types of automated tests but
that's currently what we're a little
covering yeah okay thank you sure
right yeah autocorrect why don't we use
the same tool to auto correct the
problems the short answer is that it's
not really possible that the of like
giving it we go back to one of the
examples let's say here right so we know
that we have a space odyssey which
itself should be declared as left to
right but where does the 2001 belong
there's a two thousand one part of this
introductory text in Hebrew or is it
part of the movie title in English
where's that where does that break occur
and then automated tool has no way of
knowing which the what the correct
answer is I'm back the only way to
really get this right is for the
application which embeds the data in the
string we have a string here that says
here are the video results for this
query and the application knows that
this is the query string and this is the
the surrounding template text but the
automated tool which doesn't see the
template system and it doesn't see the
the semantics of the different
components it doesn't know how to do
that it doesn't understand how to break
this now between template and embedded
and etc so in the general case there's
no real way to fix it automatically now
are there any more questions okay okay
great thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>