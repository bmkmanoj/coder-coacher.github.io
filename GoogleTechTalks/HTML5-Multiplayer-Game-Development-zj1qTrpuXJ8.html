<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTML5 Multiplayer Game Development | Coder Coacher - Coaching Coders</title><meta content="HTML5 Multiplayer Game Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTML5 Multiplayer Game Development</b></h2><h5 class="post__date">2011-07-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zj1qTrpuXJ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">forward face of Google's products api's
and services and we work with partners
of all different sizes and help them get
online smoothly productively with our
products and API so as part of Chrome we
work with partners who are building
things for the open web platform with
html5 soon Native Client launching those
apps and games in Chrome Web Store
we have Chrome Frame obviously as a
plugin for legacy browsers to bring
along all that great html5 technologies
Chrome Enterprise and Chrome OS and
Chromebooks a lot going on in the Chrome
world I like to focus on games game is
really obviously a lot of fun and it
also pushes the platform it really
exposes the areas that we need to
accelerate or optimize it also shows us
where we can go with new areas and new
features of the platform and obviously
games are very important for any
marketplace or any distribution channel
I think something like 60% of the
popular apps in the App Store are games
for instance it drives a ton of revenue
so it's important for both our
publishers our n chrome and Google so
games is really critical I love it we're
working on it working hard on it and so
I would like to introduce a talker for
the speaker for this tech talk Rob
Hawkes Rob Hawkes will be talking about
html5 multiplayer games with us today so
he's an author of foundation canvas a
new book on canvas which is one of html5
s new api's allows you to basically have
a bitmap 2d drawing context in html5 so
very important relevant to games
he's also technical evangelist at
Mozilla just recently started there and
he's also very passionate about games
and so he he started early building
multiplayer html5 games has learned a
lot of great lessons along the way so
I'd like to introduce Rob to tell us all
about multiplayer html5 games
this working Sun go yes I'm Rob so I'm
here today to talk to you about rockets
and which is a multiplayer html5 game I
created really sort of recently while I
was at university which I just finished
and so yeah it's a multiplayer space
shooter it's quite fun it was an
experiment into sort of gaming and
learning about WebSockets and stuff like
that so so throughout this talk I sort
of planned to go through that some of
the theories and some code behind it not
too much code and more just the theory
and sort of the interesting things the
lessons I learned throughout the journey
and yeah so it's definitely a
lighthearted talk to feel free to stop
me like at any point if you have a
question and it's it's not too formal
I'm quite happy to stop and you just
raise your hand that's no problem we'll
just off go from there
and so yeah so I work for Mozilla I said
I'm a Technical Evangelist there I've
been there for about just over a month
and sort of came out at university and
went straight there which was
interesting and so yeah it's my job to
engage with developers about new web
technologies like html5 and related
stuff like JavaScript so just as a sort
of clarification when I referred to
html5 I'm talking about html5 and
JavaScript and too much efforts to say
this the two things all the time
so yeah so aside from my work at Mozilla
I'm obviously sort of addicted to html5
and visual programming so you probably
recognize html5 logo and some nice guys
sort of created a custom version of it
for me which had sort of massive
background with my own rocket on the bat
and flying around it which was
interesting so my go down the t-shirts I
think I don't know but yeah so I'm
addicted to this technology I think it's
fun I like experimenting with it it's
easy to use it's quite cool it's still
sort of being developed at the moment
and just like constant changing and just
the ease of use it's just really really
interesting to me and and this
experimentation is sort of led to me
looking at so multiplayer games and
gaming in in particular on html5 and
Rockets is sort of a graduate from my
experimentation and like I said I
started studied at a university from a
desire to
WebSockets so the game now is much more
mature like I said it's graduated from
sort of my lab let's suppose and I'd
consider it a separate entity I'm sort
of using it now to sort of push other
new web technologies into orbit to use
as a base to sort of try out new
features and I think gaming isn't a kind
of process that you can apply so many
different sort of practices to it's a
really good way of testing at lots of
features all at once and something that
was sort of my process behind creating
it so don't know is anyone seen rockets
yeah a few people that's not too bad and
so Rockets is basically sure for rocks
WebSockets and rockets and rocks is my
personal blog it's sort of short from my
my full name and the names besides a
point really the game is as you can see
here like a detective around and swing
by your windows down very careful how
much you fight but um yeah so it's just
an interesting theory behind it I was
quite interested in it's not even that
would be to release yet and we'll get
into why in a moment so you've probably
realized that the graphics I show you at
the beginning aren't the graphics in the
game I'm sorry about that
and I don't think canvas or WebGL are
quite there yet maybe soon I don't know
so we'll see but yeah that graphic is
something I got commissioned for the
game actually and by an artist could
read seven and I think is pretty cool um
so yeah I mean maybe one day we'll see
so I mean yeah I mean that's a six foot
version of the banner that was me at my
university grad show and
I mean if you don't think that's that
big consider it's like eight feet behind
me and it's pretty big but yeah it's
pretty cool my girlfriend actually
wanted me to put it up in the flat for
some reason so I to actually say notice
its mother pink but anyway so yeah I
mean the technologies
thanks for now but if I need it and this
I can still end the meeting okay okay if
it goes wrong or I can stay in the
meeting okay hello can you please you
please mute your mic people on the bc
right thank you sorry I got confused
what's going on those always asking me a
question
so yeah technologies so the technologies
behind real kids hair there's quite a
few of them so you got a simple ones let
you HTML and JavaScript that's just a
given really so all of the upper
technologies are tightly related to that
in some way so for example you've got
canvas so that's doing the 2d rendering
of that of most of the game graphics
apart from the sort of the UI which is
CSS and HTML and so the canvas like seth
was saying earlier is a 2d bitmap
platform so and how many people have
played with canvas so far so a fair
chunk of you so yeah it's a good
technology to play with it's really
simple to use and it's getting better
with things like hardware acceleration
and stuff like that it's not perfect and
but it was something I wanted to play
with it was really easy to use and it
was new and it was exciting and the one
thing in the game that isn't HTML or
html5 even is I've got the flash audio
and I'll explain why I've got that in
there later on is basically a few sort
of problems with the html5 version so
yeah I mean the audio is just playing
with the background sounds and the sound
effects but you could use html5 audio
for this kind of stuff and there's also
WebSockets and it's anyone played with
WebSockets yeah a couple of you so yeah
and this is this is a really really
interesting one I mean this is why I
created the game and it's the concept of
and communicating between a client and
the server in real-time I think is quite
an interesting one and not just in
gaming it's basically just an upgraded
HTTP connection it's like bi-directional
real-time communication and stuff it's
it's pretty cool so I definitely look
into that and then I'm that's all on the
the client side on the server side I've
got no js' running and so it's
JavaScript on the server and it's pretty
cool language I mean is anyone he's
played with that one that's cool yeah
it's a good language I just find it
really easy to sort of used because it's
same language I'm right in the game in
the client-side and at the moment I just
use node for game logic and the
WebSockets communication and eventually
I'll be using it for like authentication
of players so you can have like and they
can log into the game and using some
sort of storage mechanism who read us or
MongoDB to add a layer of persistence so
they can play the game rack up some
kills I'd get some achievements and log
off come back on two days later and
they'll still have all their statistics
because right now there's there's
nothing there it's if you refresh the
game you lose everything that you had
before so it's something I'm definitely
looking into like I said there's reasons
why this isn't even at beta stage yet so
for other development there's been quite
a few issues and I was fairly new to
game development and multiplayer game
development in particular when I started
this game and sort of early on last year
um yeah I mean we'll go through the the
main challenges that I sort of hit but
you'll hit them pretty quick especially
in multiplayer gaming and it's important
to sort of be aware of them and the kind
of solutions that you can sort of
approach to get around them so I'll
cover a few of those now so just bear
with me
so the main one that I've had a problem
with is networking and with the
WebSockets but just the concepts
involved in networking in particular
yeah this probably stems from my like
inexperience with sort of socket
communications and all of that kind of
stuff I never really doubled in that
like desktop programming or and I hadn't
done much to play gaming in particular
before so a lot of these issues they're
probably fairly standard networking
problems but if you're a web developer
just looking to get into gaming or
you're I don't know that you've done
single-player games you want to do
multiplayer they're going to be things
that you get a bit weirded out by and
the original version of the game the
prototype even and the networking was
like woefully simple and and everything
was transmitted sort of raw in verbose
text format and it was just wrong really
really wrong and in hindsight now it's
obvious why and I was experiencing like
massive performance decreases and stuff
it was just simple little things and
we'll go after a couple of them soon but
I was basically the crux of it was
basically sending too much data way too
much data back and forth so there was a
couple of ways to go around there and
one of these was just coming up with a
simple sort of message protocol so the
way I did this was to sort of come up
with a way of structuring the messages
that are being sent back and forth so
this included assigning each message
like a type and the way I did that was
with enumeration so I was assigning it
sort of it was a number that type so it
was quite short and it was easy to
remember but I was using and sort of a
structure like that in JavaScript just
to so in the code I confused the the
word representation of the message type
so it made sense when you were reading
through the code but when I was sending
the message through the WebSocket I just
had to use the number and it was nice
and short and I didn't really care what
was going through the socket as long as
on the other end you have the same types
you can translate it back and this was
just a really simple thing to implement
and it cut down like length of messages
going through WebSockets because
WebSockets only uses text at the moment
to transmit there's there's no other way
of doing it so if you can cut down the
length of your messages even by a one
character you're really going to sort of
help yourself out and so doing something
like this you can cut it down by really
a lot and then sort coupled this with a
sort of overall message package so I was
using Jason to do this so you'd store it
as a JavaScript object on the server or
the client whatever and then when you
came to send it you would sort of pass
it through Jason or even a bison which
I'll get it onto in a second but all you
have a pieces of data and we're attached
to this JSON object so the Z that you
see up there is the message type and the
reason why it's called Z there is no
reason it just was M it was a letter
that I didn't think I was going to use
and you could use anything and the rest
of them is this just an example message
of like a player update so the idea is
the player ID and s is the state of the
player which is another object which has
just got the X the Y and the velocity
and the angle and you could probably cut
this down even further you might not
want to use Jason at all you could just
sort of is a really really short string
with some separators or whatever or not
even separators if you know how long
each section is going to be but what I'm
saying is you just need to be aware that
compressing the data is really important
and and I wasn't aware at least at the
beginning and it really bit me because
when you get more than 10 players in
your game and you've got them all firing
so 20 billets each you've got a lot of
data flying back and forth um so yeah so
the compression side of thing is quite
interesting so just cut the stuff down
reduce the length of words really simple
stuff and but like I said there's there
was something called bison which I was
looking at which is a binary
representation of Jason I don't know too
much about it myself all I know is that
in some cases it can cut say certain
characters down by even like 4
and so I know certain characters you can
say you got a string you can cut the
amount of characters within it done
enough to make it worthwhile to use but
it's worth looking into
and all of the slides and the notes and
the links and stuff I'll be putting up
online afterwards and there'll be sort
of links to my website at the end so
don't worry too much about taking notes
um so yeah aside from this or
compression side of stuff and there's
the rate-limiting and this is probably
the biggest issue I had with the
networking and and it was just like I
said at the beginning the sheer amount
of data that you're sending back and
forth and just bit me straight away and
I died took me a little while to work
out what was going on but it was fairly
obvious when someone pointed it out that
you're just sending away too much data
and it's not just because of the length
of the strings and stuff and it's about
how many players you've got in gaming
the way your game is sending that data
so having only one player in your game
and is fairly simple the way I set up
Rockets is you send a message to the
server the server then does some logic
can send your position back so you'll
have if you're one player one message
going in and one message coming out
pretty straightforward to two players
you got two messages coming in one from
each player and then you've got four
messages coming back out and this is on
the server's perspective so there'll be
two updates going to each player so
that's 4 so 2 into 4 out so it's not too
bad so if you've got four players and
four messages in sixteen messages out so
you can see now if you haven't already
noticed is that the message is going out
is the square of the messages going in
and so if you have 30 players and 30
messages coming in 900 messages going
out so you can see how quickly this
builds up and this is just say for
example if there's 30 players not
shooting anything they're just moving
around so and this is perfect as well or
pair update on the game and so I mean
say your games running I don't know
he frames a second 30 frames a second
you've got 900 messages going out just
for movement in that frame to imagine if
they all started shooting its numbers
going to shoot up really quickly but
let's go further still imagine you've
got a hundred players in your game so
you're getting sort of massively
multiplayer there's 10,000 messages
going out this is just you're not going
to be able to work this with WebSockets
at the moment so this tripped me up
completely I was aiming to do this
massively multiplayer game where you
could have thousands of players in the
game and it's just not going to happen
because your service going to die so
there's ways to get around this and like
this particular games like I think World
of Warcraft or other games they have the
concept of like range and visibility so
if you say can't see a certain distance
you won't you don't really care what's
there so you don't get the updates about
what's there so originally invoke it
that I was sending updates for everyone
that was in the game regardless of
whether you can see them which was in
hindsight a stupid thing to do so you
need to make your game intelligent and
that was the main lesson I learned
especially on the server side of things
where it doesn't really know what's
going on on the client side
so you need to tell it things so you're
using HTML Java scripts you can tell it
the dimensions of the screen it's really
simple you can you can tell it all sorts
of things so unfortunately there's a
wave wrap around this so you can
seriously cut down on the amount of
messages by knowing the screen
dimensions so if you know the screen
dimensions of each player you know what
players are within that screen dimension
what bullets are within that screen
dimension and and only send those
updates and by doing that simple check I
enroll kids I manage to cut down the
amount of messages sent back and forth
and mentally it was just incredible um
but it's just really simple trick so
another really really simple one that
you might not think of straightaway and
is I only send updates for players and
that I'm moving that have moved since
the last frame because if they're not
moving and they're not doing anything
then you don't need to waste bandwidth
sending messages about them it's really
really simple
things like that that make the
difference so another networking thing
that I sort of found interesting and
it's a bit of debate about this is
WebSockets is TCP based there's no UDP
support for this year a lot of people
think that's a reason not to use it I
kind of see that but I've not had a
problem yet you just need to respect it
you just need to be aware of what TCP
means and what kind of issues you can
get related to that so it's not a
problem really and you just need to play
by the rules so I should probably point
out that the I could have used that icon
because it's WebSockets and whatever but
it's not as a u.s. plug socket I kind of
liked it looks like a surprised face
which you don't really get that in the
UK and always makes me laugh I dunno why
so yeah so TCP just need to be aware of
the things that invokes and like obeying
the order there's the whole concept of
TCP is that the stuffs going to come
through in order and it will wait until
packets get dropped it will try and grab
them and put them through back in order
like I said I don't know too much about
the fundamental networking principles
here I just know what I've learned
through my game development experience
and and this is one that sort of bit me
before is is you've got players running
around and especially if say before I
did the compression and stuff like that
if someone likes out a little bit and
the messages get backed up you're going
to get this guy stuck for a moment and
then suddenly everything will catch up
again and will go zipping around the
screen as well the messages come in and
you updates so you need to be aware that
these things are going to happen it and
it may sound simple but it's the kind of
stuff that the average of web developer
or someone who's not done multiplayer
gaming before it's not really gonna
think about it till it bites them and
then what do they do and see ya in short
I mean the ordering stuff is going to
make it a bit jumpy and and with UDP
yeah this wouldn't be much of a problem
sorry okay
so yeah but you're still gonna have to
wait for the messages too sure yeah yeah
so yeah you could there's something that
we will look into in a moment is getting
rid of the jumpiness but yeah you could
effectively ignore the messages up to
the most recent point in time
definitely so yeah um like this man said
and there is ways to get around this you
just need to be aware that these
problems do exist and realistically it's
not much of a big deal I mean okay you
if you're making counter-strike perhaps
but if you're just working on so the 2d
space shooter or a platformer or not
even those kinds of games maybe a
massively multiplayer Scrabble game I
don't know which exists by the way some
of these issues it doesn't matter if
there's a little bit of like if some
things don't come from in order you just
just be aware of it I mean there's
something sort of a theory that I've
sort of heard of haven't put this into
play yet and haven't tackled it head-on
but it's sort of the idea of forcing a
delay and in the game so what I mean by
that is say if every player is solved I
don't know 50 100 milliseconds behind
what's happening on the server you sort
of have a buffer period and to catch up
if there's any issues now as for how to
implement that I'm not sort of 100% on
it I am I've seen a few sort of big game
companies talking about this kind of
approach in certain ways and so I have
to look into that more maybe I'll put it
on my website afterwards but it's just
hard to think about that there's say
certain ways to get around these kinds
of things as long as you're aware of
them and a really simple one just use
socket IO this is a node plug-in and it
gives you web web sockets so simple to
use and the actual website for is just
socket IO and and they've just released
a version 0.7 like two weeks ago which a
massive update for them and bring some
really really cool stuff but one of the
best things that came in with it is the
idea of volatile messages so the way
these work is
is if you send a volatile message using
socket IO which is completely voluntary
you would have to say I want to send
this as a volatile message and if the
person you're sending that to is having
connection issues or is busy doing
something else socket I will know about
this and it will just drop that message
you won't keep trying to resend it and
all of that kind of stuff so you can so
there's a question Oh
socket IO it's JavaScript so it's it's
WebSockets which is JavaScript yes and
so yeah it's got a node.js plugin for
the server and a client-side sort of
plug-in as well just to do the
connection stuff so it just uses a
really simple API it's a great way to
sort of put WebSockets into something
really really easily see how the
volatile messages you can sort of take
away a few of the sort of dodgy TCP
stuff that might trip you up but it's
not an ideal situation it's not an ideal
solution but it's going to help so it's
just nice to be aware of these kinds of
things and so another big thing that's
bugged me in the game is cheaters who
are both a blessing and a curse and so
there's no denying it you're using open
technologies you not compiling your code
your code open right so it's visible to
anyone who wants to view the source and
doesn't know whether you minify or
obviously scape pops pops whew Kate your
code someone's going to be able to work
out what's going on or just play around
with something in screwing something up
and that's just the way it works right
so I experienced this pretty much
straightaway when I develop rockets and
so I probably released it and then a few
hours later someone had decided to put
rapid fire in the game and wasn't part
of the release and so he had 300 bullets
the second flying around everyone was
dying it wasn't happy and the server
crashed which was even greater and I
actually talked about how I dealt with
that afterwards but straight after that
he was working on invincibility and
super speed and someone else then
grabbed his code because he was just
sharing it and allowed them to sort of
paste it into the web console and he had
his own features in his game so they
were just making new features to my game
and I didn't have to do anything and
accept it crashing so I wasn't expecting
it right so one guy I think my favorite
one he he managed to create an entire
new weapon he didn't just manipulate the
old one he created a cluster bomb and I
had only put bullets that fired once
every 300 milliseconds in and he managed
to completely manipulate everything
because of my naivety and fire say I
don't know 50 bullets all at once at
different angles and that just wiped out
everyone on the screen right so it's
pretty cool and don't get me wrong this
this this was annoying but it was
awesome to get this free testing that I
wouldn't have I would never have found
any of that I would probably still be
finding it today if I didn't have say 20
people all on that ones trying to break
my game not because I asked them to just
because they can see the code and
they're thinking well screw it I'm going
to break it and it's good I think that's
something that comes with these
technologies nothing is something to
embrace and that's why I say it's a
blessing as well as a curse as long as
you keep op of them and the other thing
with this is using
nodes with JavaScript on the server and
JavaScript on the client it's so easy
just to run into the server just make a
quick change refresh to restart the
server not even the whole server just
learn node and you've got to fix up in
say a few seconds and you don't have to
do any compilation in any of that and
they'd make a scrub the game might fix
it and they'd be annoyed but they'd
break it again we're doing something
else so it's a constant battle but it's
I think it's a good thing but the reason
why this was all happening was because I
was being naive with my JavaScript I was
I was using the global namespace and I
had no closures in my code and all of
those sort of things that you probably
should do and I wasn't doing and so the
cheating was prevalent because it was so
easy just to run in go into the console
have a look at what sort of variables
upset file into them and
so I drove down into them and say oh
look there's the speed setting let's
change that to see I don't know one
millisecond instead of 300 milliseconds
there we go I've got rapid fire it was
it was that easy
and so the easy way to fix that was
using a mine Rockets namespace and
putting some sort of closures in
incorrect areas and and private
variables which aren't technically
private but whatever and so just being
aware of the security of your app as
well it's not going to be perfect and
it's not going to stop people doing it
um but it's it's going to help at least
the ways to actually prevent cheating
completely I'll get onto after this so I
mean this was just a simple and
representation of how I put the Rockets
name spacing it's just a standard thing
I think that I got this out of a
JavaScript patterns book and I can't
remember your name of the author but
I'll put the link on the slides
afterwards and and in just this kind of
stuff just simple stuff it it helps so
the actual way to prevent cheating
completely is to not do this which is
what I was doing so I had anaphora t'v
authoritative client which she says that
you know is a bad thing right no way
exactly it's it's and this is what's
happening is like guys that haven't been
involved in this multiplayer networking
and whatever is with web developers that
have started looking into this and it's
another example ISM with canvas and
stuff we're learning from flash guys and
because they've gone through this before
right so it's quite interesting so I'm
yeah the first version of rockets was
way too trusting
so it was an affirmative client it meant
that whatever the client did it trusted
and send it to the server and the server
went oh yeah that's where you are right
now okay yeah I'm going to send that to
everyone else and all you need to do is
change that position on your client and
it sent that random position to the
server and you've got rapid speed
it's or invisibility you can just can
flick around all over the place it was
crazy it's a really bad way of doing
things and for single-player obviously
is fine regardless of whether you've got
a server doing anything is it's when
you're doing multiplayer and it gets
quite interesting and so this is
referred to as all sorts of things I
call it the Here I am approach and I
know if you ever guys call it that it's
the client just basically keeps going to
the server Here I am Here I am Here I am
and the server just goes ok and sends it
to everyone else so the right way to do
it is using an authoritative server um
and basically this means that it
prevents manipulation of the client
because whatever happens on the client
the server is the authority the server
is the one decides where the position is
it knows where all the information about
the player and if the player wants to
change that the server has to make sure
that's ok and send that position back to
the client the client has to obey the
server effectively and so invoke its now
and now it's fixed at least and all the
movement logic is is done on the set
client goes you press down your arrow
key and the client sends a a I want to
move forward requests and using the
Jason messages message typed in whatever
the server then goes ok this guy wants
to move forward he is at this position
right now and he's only allowed to move
because of his rocket type he's only
allowed to move say five pixels Ford but
it's not as simple as that here we use
physics and whatever but he'll move him
a certain amount forward and then the
server will then send the message back
to the client saying this is your new
position right so this is a sort of
approach called like where am I it's a
different one it's the clients going
where am I now
where am I now where am I now and
there's an issue here and has anyone
spotted the issue yeah the latency um
correct so the problem is latency and
what's happening is because it's not the
client is sending the update whenever
you press the key for us right so it's
got to take however long it's gonna take
to get to the server say 40 milliseconds
the server's then going to do its stuff
which is probably pretty quick anyway so
for the sake of this illustration its 0
milliseconds and then it's got to come
back again to the server to the client
so another 40 milliseconds a round-trip
80 milliseconds so if you press your key
down you've got to wait 18 milliseconds
before your position your new one comes
back so you've got this jumpiness now it
might not be that noticeable but it kind
of is when you're sort of trying to
rotate your real time gaming trying to
shoot people in the face and yeah you
want it nice and slick so the way to get
around this is client-side prediction
and like this this guy was saying it's
sort of interpolation and all sorts of
stuff like that and it's it's basically
saying that server authority isn't
enough and it's is going to prevent the
cheating but it's going to create a new
problem in that you've got jumpy players
and jumpy players is not a fun game so
what I mean by prediction is sort of you
need to put some power back on the
client-side and whether that's a similar
physics engine that you've got on the
server but what do I mean by this is you
need to let the client move the player
while the message is going off to the
server and and M being corrected and
moved and whatever and you're waiting
for that message to come back saying
you're here the clients already made its
move and kind of predicted as it says
where it should go and and this happens
straightaway like I said it happens as
soon as you've made the key press so you
make the key press the client prediction
happens and it moves you to and where it
thinks you should go because you're
sending just the input message
to the server you know that on the
client so if you have the same physics
engine and you can or whatever you can
kind of pretty accurately as long as
they've not done anything dodgy you can
pretty accurately guess where the client
is going to go now or where they should
be at least based on that input so then
what happens is once the messages come
back on the update you've got to erm do
something because you can't trust the
client you can't you're going to have
the same problem here if you're doing
the server authority and then you're
doing the prediction and you're not
doing anything and afterwards you're
going to have the same problem where
yeah okay everyone else is going to see
this correct position for this guy but
if this guy's screwing up his own game
he's going to be seeing something
completely different because he might
not be doing this deliberately he's
going to be something seeing something
completely different so you've got to do
something
so correction you've got to really some
sort of correction and whether that's
interpolation or some other kind of
interpolation so whereas the authority
sort of server would have been in
control you relinquish some of that um
you let the client do it stuff the
positive server goes right this is where
you should be right now and the client
then goes ok so the server's told me I
need to be here I'm here is this right
so uhm yes so the way to do this I mean
it may sound simple in concept but I
mean this is one of the hardest things
I've dealt with and I've still not fully
cracked it I've got the concept down and
it's there is a lot of work that's been
put into this in traditional like
desktop gaming languages and stuff like
that there is barely any body that's
tried to do this well that hasn't been
brought up in JavaScript and it's it's
pretty impressive there is whether
they've done it and that's besides the
point whether they've shared how they've
done it that's the main thing so it's
something that's really important right
now and it's kind of something I want
people to learn about
it's it's quite a sticky subject so you
know I mean don't worry about what this
actually means I've cut some stuff out
but this is my basic sort of correction
so function and and this is part of a
bigger class that doers of movement
history and stuff like that um and I
took this approach from a guy called
Glenn fiddler via Fiedler even I need to
really know how to pronounce his name
who runs a website called gaffer on
games which is a desktop gaming resource
it's fantastic and but the problem is
porting all that kind of stuff to
JavaScript certain bits and bobs I'm
going to work exactly the same see it's
a bit of guesswork somewhere and so yes
I mean the basic what's happening here
is you get a correction from the server
which has got a timestamp so the reason
why the timestamp is there because the
client and the server of synced clocks
effectively and right when you connect
to the game and the way you do that is
you to calculate the latency averagely
you're not going to get it super perfect
but it'll be near enough and you sync
your clocks you get a time in and
because you've got a movement history so
every time you make a move on the client
you sort of store that that input and
data from that move and the timestamp
and whatever when a correction comes in
you can go back into the movement
history and go and okay where were you
at that time and if it's really simple
like there's there's no change at all
you'll find out in the next bit so you
basically just take the values away from
each other and you compare the
difference and if the difference is a
zero or a really really really tiny
number
it's probably trustworthy they're
probably not done anything dodgy so you
can just sort of ignore it and let you
can to assume the moves that made sense
then are correct and continue if the
move is that the different story is
significant and something's happened
whether that's they've lagged out and
there's been some sort of discrepancy
and there is certain situations where if
you turn around really quickly in a game
especially my 1m and you can power off
in a different direction
quickly the change in velocity sort of
screws up and if there's a big latency
between the client and the server but
besides that what you then do is you
need to do some sort of correction so
you go into this function and there's
loads of different ways to do it valve
do it a different way and I think unreal
do it another way there's people are
finding their own ways but the concepts
are same then you go through this and
you basically find the move that was
nearest to the one that you're looking
for right if it's wrong you drop that
move because it's obviously incorrect so
you replace it with the move that's
coming from the server and because you
know that that move is the operative one
so it's the correct one what you can
then do is based on that move you still
got all your inputs that you've made
after this correction has been made
because remember you got that 80
millisecond gap right so you've got 18
milliseconds of inputs or I mean imagine
you've lagged out a bit you've got I
don't know 200 milliseconds of inputs
that have happened you can't just drop
those because then you'll snap back to
this in normal position you would have
lost everything you've done since then
so you correct your move whether that's
there's other ways of doing it as well
where if the move is slightly different
you can interpolate so you can sort of
blend it across so you can do I don't
know a tenth of the distance and you do
that enough times over a few frames you
gradually get there if the distance
distance is massive you need to sort of
just snaps in that position would you
look a bit jumpy in the players view but
at least they'll be in the right place
um but yeah so once you've got that
corrected move you just replay from that
corrective move all those stored inputs
that you had previously in your history
or whatever and you'll get back to this
correct like ultimately correct state
which should match up with the server
completely and that's it in theory in
reality it's it's not perfect I've still
not kind of I've got it working and the
issue is I've got something else
screwing up with my game so it's it's
not doing it right and but I mean it's
it's definitely worth looking at the
valve and documentation on this and they
I've got the title here it's latency
compensating methods in client-server
in-game protocol design and optimization
is pretty long and but I'll put the
links up so there's a valve
documentation is unreal documentation
they kind of both based off quake world
version that was years back and all of
these guys have solved this many years
ago but we just don't know this stuff
yet in the web development world and so
the other stuff is aside from networking
which is a pretty chunky topic and
worthwhile sort of digging digging
yourself into and learning a bit about
its the stability and I was saying how
when people were cheating the game they
were crashing my server one half of that
was my naivety with not putting error
checking into node and and whatever and
basically just letting it crash if
something went wrong because I was more
interested in rapidly moving up these
games I wanted to learn about WebSockets
and so which is a good thing about node
and but when it crashes and you're not
around it's not great for testing so
keeping the game running was something
that I was interested in and I needed a
way of automatically doing that so I
started using monitor as anyone used
monitor
cool couple people yeah it's a I didn't
know about this before I I created the
game it's fantastic so it's something
that runs on your server um and it you
can script it and pretty easily and and
the way I have scripted it is it I've
basically made it and look at my
WebSockets connection in node so just
looking at the port that the WebSocket
is meant to go through and this is the
script and it's four lines it's pretty
simple and so you just check the website
the domain which is the localhost
because you're running on the same
server you'd hope and and you're just
looking so ignore the the two lines in
the middle you're just looking for
whether the poor say the WebSockets one
I'm using me
port 8000 and TCP whatever so you're
checking whether it's active right and
that's just the way it does it by
default if failed and it checks in cycle
so you can change the the cycle by
default is like 120 seconds or two
minutes I've changed it to a minute and
in configurations files is really simple
but yes so if the connection is inactive
for two times so that would be two
minutes in this case then it's think's
right the games probably dead and
someone's probably cheated and crashed
it let's restart the game and it just
runs through how restart procedure and
just to boots the game back up so the
restart procedure is is just running
some shell scripts so there's the shell
scripts it just let me know don't eat
too much about it I just know that
that's how it works
and I'm more of a JavaScript guy but uh
it's effectively just the shell script
that runs at a command line and cool
which is just booting up node again and
if you run the start command afterwards
and if you've understood command it
stops the node process that you just run
pretty pretty straightforward in theory
and really really useful in in context
and it's really not that long it at
least anyway and so yeah I mean that was
it that was the all I needed and my game
was up and running permanently I've not
had to restart it but I can't even
remember the last time I restarted the
server myself and so yeah so as I was
saying at the beginning and I use flash
for the audio which is something I
didn't use at the very very very
beginning of the game but I couldn't not
use it and the reason is because html5
audio as good as it is for say music and
sound and video and not sound of video
but sound in general um is not amazing
at looping and and the consist the
consistency across browsers for looping
is just really pretty
bad so for example I mean if you're
using this for say a rocket thruster say
in my game and you've got this short
clip that's looping over and over and
over and over and over and over and over
again right so if you've got this
inconsistent looping and what I mean by
this is there's like a little gap a tiny
tiny little gap at the end and which
probably isn't noticeable if you're
looping so music music track which is
like five minutes long or whatever if
you're looping a tiny tiny tiny tiny
track you're going to hear this little
so gap all the time it's just going to
not sound right and that was the problem
I had and there's ways to look around
that opera actually have a really good
implementation of this it's like super
slick and every other browser there's
slight differences none of entirely
perfect um and there's ways around this
so you can use JavaScript to look for
the end event on the audio and push it
back to the beginning because sometimes
that might run faster and whatever but
none of it's perfect you're still going
to get a tiny tiny little gap and this
really really really needs to be worked
on
so each other question right yeah so
that is another approach and there
I mean I'm yet I've seen it in use and
I'm yet to see it be perfect but I mean
literally perfect and which is the
problem if it's quite a detailed loop
you're going to really notice a tiny
tiny difference but that is a sort of
this guy was just saying it you get two
audio clips the same audio clip and you
saw effectively nearly crossfade them
right at the end so they sort of start
at the same time when they go through
again so you've always got one loop
plane you have one sort of passes in
over the top just at the end right right
yeah yeah
so that is one of the actual what
approaches and it's probably one of the
best ones actually and but it's not
ideal what I'm getting at is that H my
book yeah html5 audio so it needs to get
better SEF
so yeah yeah so yeah I mean separase is
a good point that the the there's audio
API is coming out which are giving you
much more fine-grained control over the
audio and like giving you access to
waveforms multiple channels so have you
talking about yeah stereo and stuff so
it's that's definitely really
interesting and probably something that
would be useful in this context and and
you also raises another really good
point about how particularly when now
game in a bit more prevalent or at least
needed and people are looking into these
things
I think the technologies are gonna not
necessarily be created for them but at
least the kind of performance uses and
that kind of stuff is going to be taken
into consideration
I hope I'd really hope but I mean things
like hardware acceleration in canvas and
stuff it's stuff that's kind of going to
push things a bit further forward than
what canvas was originally intended for
and so yeah I mean there's no real
reason why I didn't use well apart from
the looping thing you can you take them
a fiber audio it's just thankful bad if
you want to make a whole patient alive
game and you have to use flash for be a
yo-yo web socket IO uses flash for the
WebSockets as a fallback so there you go
and I mean there's loads more stuff that
I can
it's been quite a long talk but I'm
stuff like canvas optimizations you can
also stuff related to that using events
to decouple your game logic just simple
things and if you use no JavaScript on
the server you can use your same code on
the client and the server if you create
it right saves you a whole bunch of time
with animations use quest animation
frame instead of set timeout because it
puts the animation in control of the
browser it so raises the performance and
if you click off your game and go into a
different tab it's not running this time
out in the background and ruining you
and processor and things like storage
like looking into things like Redis and
MongoDB these those kind of things that
you should be looking into if you want
to create these kinds of games and
something really important and control
systems as well like we used to desktop
and keyboard and mouse and that's great
but these technologies work on mobile as
well right so it's looking into
different ways of using javascript to
control these kinds of games so like
rockets I want to use a control system
that said bleed de lisle so flash
developers now doing a lot of cool stuff
javascript he's created one that's based
on iOS and implementations in games
where you got this sort of to fun
joysticks on the screen and it doesn't
matter where you put your funds these
two joysticks pop up and say for example
your left once your froster for your
rocket and you can fly around your right
one is the direction of fire and or
velocity of the fire whenever it's a
really simple control system and you've
created it in JavaScript and again I'll
put the link up with all the resources
for this and on my on my website so yeah
I'm in the future like Seb was saying it
sorry Seth even and if these
technologies if people start adopting
gaming and these high-performance sort
of uses of these technologies I think
things are going to get a lot better a
lot faster and there's some things in
particular we need to post him up live
audio being fixed and hardware
accelerated canvas particularly on Mac
and really bad at the moment
better documentation for making games in
JavaScript
like this guy at the front and I need to
get your name what was your name Scott
like Scott has been saying and this kind
of stuff people have solved these
problems before this is not new stuff
and it's just in a new context and so we
need documentation specifically related
to stuff like JavaScript and this is
something I'm pretty particularly
annoying but I want to do something
about and there are some websites coming
out now so helping this ingame
conferences like cam it's a new game new
game in San Francisco in November and on
game start in in Poland in September and
it's gonna help just over little things
like better ways of benchmarking game
performance and stuff I know Facebook
are looking into this and they're not
creating games but they want to look in
how to use these technologies better to
create games and so I mean things I
could some time I don't know measuring
FPS in an interesting way network
performance and then viewing this in
some sort of logical way rather than
just seeing it in single players
computer screens and and not just in a
log file system so I don't like Google
Analytics for game performance I don't
know something like that is really
needed I think to push this forward
rather than just experimentation to
actually proper game development so I'm
Rob Hawkes that's my twitter handle at
Rob Hawkes my blog is rocks calm this is
where I'll put up all the information
after this the slides and stuff I'll
also tweet about it and unrelated I did
some cool stuff at uni there's some
Twitter sentiment analysis stuff which
is quite interesting and looking into
emotion on Twitter and delving into
people's souls and so yeah my job
Mozilla Technical Evangelist I do a
podcast called explicit web which is all
about web development I don't really
need to talk about this Steph mentioned
at the beginning it's my book if you're
looking into canvas and stuff it's it
weather you know all about it that's
fine I mean if it's something you know
someone else is looking into canvas
might be useful there are other books
out there's one by O'Reilly and so take
a look at those and something we're
working on at Mozilla which is
interesting is Deb Debbie and
this is something we're doing every
month this month is html5 video and it's
just like a a monthly competition just
to create some cool stuff with the
technologies to sort of them see what
they can do have some fun and can win
stuff and Android phones and t-shirts
and stuff so it's useful like if whether
you want to submit something or not if
you know people that are interested in
learning technology students or whatever
it's a good excuse to get them sort of
playing with these technologies on a
regular basis and next month will be
interesting to sort of touch events on
mobile and stuff so yeah that's me
and thank you very much thanks for
having me and and if you have any
questions I'll be happy to take them
yeah so that was yeah so what was your
name sorry okay what Leo okay Leo so
yeah Leo was saying there is a there's a
technology out at the moment which is
allowing you to play games on the
internet effectively by streaming down
and the game is run on the servers is
correct and then you stream down audio
and video so you're playing a video
stream effectively and the controls are
stream back to the server and something
changes on the server it streams back a
different image yeah so yeah I mean this
is something that could be looked into I
suppose I don't quite know if we're
ready to do something like that
in sort of html5 and JavaScript with
video streaming streaming html5 video
and stuff some sure right
okay first you can play native video
native audio as I think the idea is like
how to get my guy higher on live stream
right now WebSockets really only send
message oriented text days you don't you
can't actually open up actual stream
actual binary data so we could have a
really good efficient way yeah I mean I
mean this is an interesting thing that
it's being worked on with console gaming
hasn't it well PC gaming at least right
yeah yeah yeah that's an interesting
thing that Scott was mentioning is gonna
be some sort of hardware requirements
involved in that but I mean it's not
impossible let's put it that way
so yeah I mean that is up to your game
but I mean you've got to add some sort
of win logic in there so whether that's
the first come first serve kind of thing
and the question was if someone if you
fire a bullet at someone and killed him
and but before the message comes back
from the server saying that was all okay
actually turned out someone else had
shot that person before you do you still
get the points or what happens so yeah
there's and valve had a problem with
this with when players are lagging out
say some guy might pop out out of a wall
and shoot someone and you won't have
even seen them because by the time they
pop back in they would have killed you
but you've not seen them pop out yep
right and and it's a bit screwy so the
way they do it is they on the server
they sort of rewind the time back to
when that player shot so it is a
first-come first-served basis it might
not look correct but it will be correct
based on the logic that the server knows
about and so in your in your case if I
fired and I had say an 18 millisecond
delay it turns out in that 80
milliseconds someone else had already
shot before me and killed that person
the server would have have done it the
correct way and yeah okay your
prediction might be then that player
died like you don't predict certain
things you might not want to predict
select the depths and stuff you might
wait until the server comes in and
there's going to be issues there's going
to be a particular delays there might be
it's better to have a little bit of
latency in the deaths and not any in the
movement and shooting I think but it's
definitely an issue to look into
right yeah so I probably didn't explain
that too well so that is an issue and
that is actually how I did that the
first time um so the question is the the
way I described it I didn't talk about
decoupling the network updates and the
graphics updates and the physics as well
and and this is true and this is I
didn't do that the first time around I
did learn from that mistake fortunately
because you're sending way too many
updates and so the way I do it now is
the physics are decoupled this and at
actually the physics and the network
updates right now are the same but on
the client-side the physics and the
graphics sorry the network physics and
then the graphics are separate so
physics and networking is running and I
have to look into that but basically I
have decoupled it it is an issue and
it's correct to decouple that kind of
stuff because you might want one thing
to run it much less and in frames per
second but then again if you using is
it's an important thing to be aware of
in the networking side of things you
don't send too much data but if you're
using things like requestanimationframe
and stuff the sort with the graphics
side of things the browser is going to
be dealing with it's going to stop the
slowdowns and stuff like that it's
something to be to be aware of
definitely and to definitely D couple
those updates sure cool thank you if
you've got any other questions just
tweet me or email me or and I'm actually
going to have to shoot off quite soon
after this so you unfortunately may be
able to grab me after but will then well
onto this
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>