<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>An Overview of the Coming C++ (C++0x) Standard | Coder Coacher - Coaching Coders</title><meta content="An Overview of the Coming C++ (C++0x) Standard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>An Overview of the Coming C++ (C++0x) Standard</b></h2><h5 class="post__date">2008-11-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JffvCivHEHU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning welcome to Halloween's
tech-talk here we thought we'd dress up
as the scariest thing we could find
which is to language lawyers in front of
a large room so yeah so this is Matt
Austin he's going to be handling the
second half of the talk and I'm Lawrence
prowl and we have a fairly whirlwind
talk here so what we'd like you to do is
hold on to your questions until the end
of the talk because you might find that
your question turns into something more
interesting and the other thing we'd
like to ask is that you can ask your
question in a way that's not Google
confidential that would allow us to put
talked up on YouTube so let's get
started and the first thing we are going
to do is go a little bit of history C++
has a very long history and it developed
through the 80s and then about 1990 the
international standards committee formed
to try and get a formal standard coming
out that was successful in producing C++
1998 which was the first real standard
everything else before that was de facto
and then five years later we produced
what's called technical correction one
so that's a formal update to the
standard but it was mostly a bug fix
release and now we're working on the
first major revision of the language
which is currently scheduled to come out
in about 2010 where that X is the Roman
digit
there are four major thrusts of the
language right now the first one is
concurrency because multi-core is
arrived the second one is a lot of
cleanup in the language to make programs
easier to write and more robust in the
face of of working programmers and a
major feature is concepts which helps do
type checking for templates and then we
have a significantly expanded standard
library that helps us get through of all
first major topic is concurrency this
work is not something that you would
find a big stretch however there's an
awful lot of details to make it all work
together and play together and none of
this is going to be particularly new
except perhaps in the memory model which
is at the bottom layer here the first
thing is that you don't get to read and
write to memory at random
once you have threads you have to
control how each thread reads and writes
to memory so if you write in one thread
and read from another thread as in the
first example here that's a data race
your program is undefined it could
launch the missiles and order anchovy
pizza so don't do that the procedure to
make this work is with release and
acquire so you write to regular variable
on one thread then you write to an
atomic variable with release semantics
then another that reads from that same
variable with acquire semantics and now
it can see the write to the regular
variable that you did earlier and you
can do this with locks as well but it's
very important to note here that you
have to use the same variable here we've
changed from A to B those are two
different atomic variables they don't
carry that same information you have to
make sure it's the same one
and the Atomics have a bunch of useful
stuff reads writes atomic increment
atomic XOR and in addition we have a
compare and swap member function which
allows you to get the full generality of
the kinds of things you'd want to do
linked lists all of that stuff you can
now do and that's designed to work with
a loop where you try and figure out what
you want and see if you can get to what
you want and there are weaker primitives
available for super experts I won't go
into those global variables need to be
initialized and once you start having
threads you have to start having
initialization scenarios there's two
approaches one is for regular global
variables the initialization is a bit
weaker so you used to be able to rely on
a global variable defined in another
translation unit either being fully
initialized or being zero initialized
you now cannot rely on that you have to
either not use it or know that it's been
initialized for function local static
switch is something near and dear to the
hearts of Google those initializations
are now synchronized so you can rely on
those things being right the language
also has thread-local storage a lot of
compilers already have the first line
with simple primitive types and pods
that's being formalized and extended to
allow types with constructors and
destructors but when you have
thread-local variables their addresses
are not constant so you can't use them
as arguments to templates the probably
the biggest use of thread local storage
is in two areas one is if you have a
multi-process program that you're trying
to turn into a multi-threaded program
and the other is for thread local
caching
we have mutexes and lox and there's a
distinction here a mutex is a data
object that will live in your in your
objects a lock is something that is a
local variable and creating the lock
then acquires creating the lock then
acquires the mutex and when it goes out
of scope it releases the mutex you can
do that without the the slot guard here
but then you have to worry more about
exceptions and a special case of mutexes
is the once from pthread and this has
been formalized to be more general than
just simple functions and it says we're
only going to call this argument once so
for any given flag you'll only fire once
we also have condition variables which
allow you to move locks and from one
thread to another until certain
conditions are met and in particular if
we have a buffer there are two
conditions that are important to
controlling the flow one is whether or
not it's full and one is whether or not
it's empty and typically you want to
know when it's not full or not empty and
then you can wait for a certain
condition to be true and that has to
occur in a loop reevaluating the
condition because you may get spurious
wake ups so this is not guaranteed that
the condition will be true when you
return from the wait but that it's
likely to be true you still have to test
and then of course when you've achieved
some condition you want to make sure
that you notify that condition as well
the way we create threads is there's a
standard thread class and then when you
construct that thread you give it
something to execute which could be a
function or or a class that has a call
operator and once you create that thread
that function starts executing in the
thread and then when you want to
synchronize with the termination of that
thread you can join with that thread
later the big problem with threads as
they stand is that if you get an
exception in here the exception will
then destroy this thread which will
detach the thread and detach threads
have much weaker semantics and are
really hard to get a hold up so you
really want to avoid having detach
threads and so those exceptions cause
problems we have mechanisms to deal with
that in particular you can catch an
exception find out what that current
exception is copy that current exception
into a global variable or some other
data structure and then in another
thread you can Reath row that exception
which allows you to catch an exception
in a thread and then pass it to another
thread to be wreath roan which shows up
in futures and so forth so what happens
here is that we are creating our work
and now we have an intermediate so we
create a packaged task this wraps the
work and then we will move that task
into the thread and now the thread is
executing that task but before we sent
that away we grabbed a future from that
task which we can now wait on that
future and get its value and if that
work happened to throw an exception when
we called the get we would get that
exception so now we have an exception
safe way to deal with the threads
the next major area of talk is this sort
of general bucket of making programs
better and some of its c99 compatibility
and some of it is just moving around in
different areas the simple things from
scene you see 99 if being carried
forward all the changes to how integer
types work have been carried forward the
preprocessor work has been carried
forward so that's all the same now and
you can right see proxy C preprocessor
stuff that's agnostic to the language a
lot of the headers have come forward
there are some things in c99 that didn't
come forward in particular variable
length race and the reason is the typing
of variable-length arrays and c is just
incompatible with the C++ typing model
some things that just didn't have enough
support to go anywhere like the restrict
qualifier compound literals also didn't
match C++ semantics complex numbers C++
already had complex there's been some
adjustments but the basic syntax is
still going to be a bit different the
current language only lets you put pods
in unions and that restriction has been
eliminated so you can now put classes
with full constructors and destructors
inside of unions but it's not free among
other things you have to define the
special member functions yourself so you
have to define the default constructor
you have to define the copy constructor
all of that you have to do yourself
because the language doesn't know what
to do with it and when you want to
change fields you can't just assign a
new value to the field you have to first
delete the old field and then construct
the new field with the placement new so
you have to say that one's gone this
one's coming into scope so you have to
remember where you were we also have
generalized constant expressions now
what this does is
basically allow you to have function
calls in constant expressions so we
declare a function as something we want
to be in constant expressions the body
of it has to consist of a single return
statement and the expression here
assuming the parameters were constant
would have to be a constant and now we
can use this in array declarations we've
extended this to also allow you to
create classes that can be constant
expressions so we have a complex number
here we declare its constructor to be a
constant expression and it has to be
initialized with full-member
initializations and the body has to be
empty and because we have a constant
expression class we can have member
functions on that that are also constant
expression and we can define a constant
P which is a complex number and we can
initialize that so now P is a constant
expression and we can use that constant
expression later in particular here real
the real member function is a constant
expression so all of this is a constant
expression which means we can now
initialize this double statically based
on all of that constant expression work
falling through and we can extend this
with user-defined literals which is a
way to add a little suffix like you see
in C with you know 2.0 F that F is a
suffix that helps you extend the literal
space we can write a function that
extends that and and recognizes this I
as a suffix matches it to this function
and does the right thing and so now we
can get a full constant expression Z
that is a
a constant and the committee has plans
to do ISO units you know for length
meters kilometers in that but it's not
going to be in in in the current
standard we also have delegated
constructors this has been a
long-standing complaint of programmers
where you had to repeat all of the
Constructors every time even though one
constructor was very similar to another
now you can define your regular
constructor and define new constructors
that appeal to the earlier constructor
and just reuse all of that code now it's
possible to write mutually recursive
delegated constructors that's undefined
behavior don't do it there's been a lot
of work trying to regularize and extend
the power of initialization syntax so
the current language has like five
different ways to initialize things the
goal was to get that down to two exactly
one way and the syntax we use is these
curly braces basically instead of
parentheses or assignment operators and
so we can initialize a variable X with 3
B using the curly braces we can
initialize member constructors with a
curly braces and here we have a list and
we can initialize the vector with the
lists to think Python here where you can
just write a list and the right things
happen there's one place where we
couldn't quite make curly braces do
everywhere and that is that vector has
its constructor has the parameters to
say how big you want the vector to be
well we need to distinguish that from
how big do you want the vector to be to
a vector of one element so the
parentheses here are going to say you
want three elements if you were to use
braces here
that would say you want a list of one
element whose value happens to be three
enumerations in the current language are
kind of weak because they will decay to
an integer at the earliest opportunity
so there's a lot of syntactic problems
we now have stronger enums with this
enum class you can specify the base type
so it's not necessary can specify it
ahead of time this allows us to do some
forward declarations you can have the
elements as per normal the the
enumerators as per normal but you don't
automatically get those enumerators
exported to the containing scope so this
is an error because Green is not in
scope in order to get to the green you
have to go ahead and qualify that
likewise because there's no automatic
decay to int this comparison is wrong
because the color yellow is not the same
as the alert yellow those are two
different types the language now has
static assertions which allow us to at
compile time check certain things so
this template parameter we want to make
sure it's greater than three we stay
that with a static assert and this text
message is what comes out in the error
Diagnostics from the compiler we can now
say I want the default behavior so in
the past there's always a big fight over
whether or not you declare the default
constructor and so that everybody knows
you've thought about it versus not
declaring it and getting efficiency well
now you can get both this says I want
the efficiency and here's the D and use
the default behavior this is
particularly important when you want to
have a
to find copy constructor but still want
the default default constructor there's
no way to do that in the current
language likewise we have it for the
copy assignment operator and the
destructor we also allow you to get the
default behavior without having it be
trivial so the problem with writing this
is you're now committed that's part of
the ABI if you don't want to commit to
it in the ABI you sort of have to write
a non-trivial constructor this allows
you to write that non committed
interface and still get the default
implementation the language also has
move semantics which is implemented with
a language feature called r-value
references which is a kind of tricky
feature but basically what allows you to
do is have structures that aren't moved
rather than repeatedly copied and this
can substantially improve the efficiency
of code particularly things that want to
write in a functional style or that
where you don't really want multiple
copies of something so here we have a
wrapper for file star and we don't want
there's no suitable default we don't
want to copy it so what we're doing is
we're deleting that function the simple
the symbol still exists but if you try
to call it that's a nil formed program
and the compiler will catch that and
here we have a move constructor what
this says is I will only accept
parameters that are sort of our values
and not L values and then we can close
we can close that file and here we're
opening a file foo and the pushback
operation is declared to take and our
value reference parameter so it can now
move from the file created this allows
us to shuffle data through many calls
many call parameters without actually
doing any significant copying we also
have explicit conversion operators so
given this class here with its
conversion operators and these two
functions this call would be ambiguous
because there are two matching
conversion operators and sometimes you
don't get the right ones so if we
redefine those conversion operators and
make one of them explicit now if we do
this call the explicit one doesn't apply
because this is an implicit conversion
so it can only be this one and the
conversion goes through what's probably
better is that if you make both of them
explicit so that the right things happen
so typically you only ever want one of
these to be not explicit and all the
others should be explicitly the language
also does a better job of type inference
so a common thing you'll see in C++ code
is these common sub-expressions PF PF
with different trailing function calls
and this occurs a lot because people
don't want to figure out what the return
type of F is and write that and so forth
so we get a lot of duplicate execution
of code now we can make the type
specifier be Auto and this says infer
the type of auto from the return type of
this expression and now we can go ahead
and use this variable later and avoid
the redundant call to F sort of simple
don't have to think about it way to
optimize your code we also have what's
called late specified return types the
problem with putting the return type in
front of the function is that if you
want to infer the return type from the
argument types you're out of scope the
argument type arguments are in scope yet
so we now can move the return type to
the
end of the function and we can then use
the deckle type sort of like the GCC
feature to compute the type from the
arguments and away we go now there's
still a little bit of debate about the
exact syntax here and that will get
resolved before the final language we
also have a new style of for statement
which infers the appropriate iterators
and ranges and so forth so given an
array this will do the appropriate
inference for iterators and you can run
the body and it's even more powerful
when you combine that with the auto
keyword so we can take some data
structure we don't even have to know
what the elements of the data structure
are right now say we want Auto reference
to each of those and then we can modify
those
on the previous slide you said you had P
pointer to F I noticed that at the end
you had auto followed by an ampersand
but at the beginning you didn't well if
P pointer Def returns a reference does
that first Auto variable also a
reference or is it not a reference it's
it's not a reference so the next major
feature of the language is lambda
expressions so this is the lambda
introducer which says here's a lambda
coming and then the parameters to the
invocation of lambda and the body of the
lambda this lambda introducer also
allows you to specify a capture list
this says what do you do about the
containing environment that ampersand
says okay I want to get to the
containing environment by reference
which means that if we were to modify an
min salary here that would be reflected
in the environment I can alternatively
say well I want to capture min salary so
when I create the lambda expression the
closure this will be captured and it
won't change so if I try to modify min
salary in here it will actually not
escape the lambda so that gives you a
great deal of control over what you do
about your referencing environment this
is good if you're trying to simulate
something like a traditional C for loop
capturing variables is good in a
multi-threaded context where you really
don't want a lot of concurrent access to
the environment and then there are a
number of syntactic improvements that
have been dropping in one is being able
to put the two angle brackets right next
to each other there's now a syntactic
name for the null pointer instead of
doing inference on 0 you can apply
sizeof to member variables there's now a
full attribute syntax which allows you
to sort of get away from all of the
vendors
specific ways to write attributes and go
to a standard way and I'm gonna hand it
over to my colleague Matt Austin yeah
well Doug Gregor came here last year and
spent a hour-long talk on concepts I'm
going to have about five minutes so
let's try to get going quickly so first
thing to know about concepts is in a
sense they're a language feature in a
sense they're also something that we
have in any language not just in C++
people started thinking about this idea
in the context of scheme and data and
all sorts of other languages and we've
always had them the basic idea of let's
say this style of programming of generic
programming is you classify the things
that you're talking about what's the
fundamental category you write
algorithms in an abstract sense instead
of relying on the details of any
individual or one of these things and
then you write specific models that will
conform to these abstract concepts this
is the way mathematics has always worked
and this is essentially programming as
mathematics well that works reasonably
well whether you have language support
for it or not
but we found in the context of C++ that
we really do want language support for
it in C++ the way we typically think of
this kind of programming is with
templates and templates just need a
little bit of taming so one way to think
about concepts as the language feature
is that they're constrained generousity
you can think of them as type classes if
you're a Haskell fan you can think of
them as types of types so let's first
talk about why we need them what's
painful about programming in C++
templates as it stands right now well
the first thing is we've written this
very nice template here are copies
things from an input range to an output
range what are the requirements on this
if I'm a user and I want to plug classes
and objects in here what do I have to do
for it not to explode I I haven't told
you I've just given you names here if
you happen to be familiar with the
naming conventions of STL then you can
make a pretty good guess or you can read
the implementation and just figure out
something that will satisfy this
implementation
I'm really not a fan of requirements
that can only be expressed in comments
we're naming conventions or where you
have to read the implementation
requirements ought to be in signatures
and here they're not so another pretty
painful thing let's suppose that you are
familiar with STL you know that sort
takes iterators so you know if I want to
sort a range I pass it a couple of
iterators okay
well you're not super familiar with STL
so you know that you have to pass in
iterators but you don't happen to know
that list provides the wrong kind of
iterator oops I was actually a little
pleasantly surprised KCC has gotten
better now it only provides 18 lines of
error messages for this unfortunately
even though GCC has gotten a little bit
better something you don't get in these
18 lines is the one fundamental thing
you passed in the wrong kind of iterator
you should be passing in a random access
iterator and that's a problem too we
don't have a way of specifying this in
the language itself so the compiler
doesn't have a way of talking about it
and then the third problem is when you
do get these errors they come too late
everyone sees the bug in this code right
it's just glaringly obvious be this this
is the bug that's that should be Bank
equals not less than and the bug here is
that this actually would be correct if
we were taking in random access
iterators instead we're taking in input
iterators but oops the compiler doesn't
have any way to know that because input
iterator is just a name the compiler
doesn't know there's anything special
about that so we've got this mismatch
and the worst thing about this bug is it
won't show up in testing because
probably when you test this you're going
to give it vector iterators to try out
and it'll work and it'll only be a month
later when some unlucky user sees the
problem in their code so what does this
look like within concepts what we want
to do is actually constrain what a
possible what a template parameter can
be instantiated with you have to say
something about what the types are in
these questions in case and here's the
syntax for doing it we're saying I have
a concept less than comparable and any
type that conforms to that concept has
to provide this kind of operation this
is simple this is very simplistic
by the way first of all it's a simple
concept and second of all it's not
actually even enough constraints for
this very simple concept but you know
you do what you can to get things onto a
single slide so here's how you use a
concept to constrain code you've got
about the simplest kind of operation
that you can imagine that requires less
than comparison you take two objects
return the smaller of them and this is
very simple but it provides the error
checking that you want if when I'm
writing this function I make a mistake
if I provide perform some operation here
that the concept doesn't guarantee is
there I will get an error and the error
will be you've used something that isn't
in the concept so that last example
where I use the less than by mistake
that's taken care of the way you use
this is the same way you use any other
template you just call the function and
if you are calling it with the type that
does not conform to this concept you
will get an error message you've passed
in the wrong type you need to pass in a
less than comparable type you haven't
and before I move on to the next slide
notice this one word here Auto that word
Auto means if a type provides the
appropriate operations then we
automatically agree that it conforms to
the concept that's not always what you
want it's you find for a case where
you've just got less than greater than
you don't want to go through the
nuisance of specifying for every class
you define that it conforms to less than
comparable equality comparable is
copyable blah blah but for a bigger type
like say an iterator then it probably is
good for you to express your intentions
explicitly you've written some kind of
an iterator I've put in a bunch of
ellipses here because an iterator is a
fairly large class even in a simple case
and the way you explicitly declare your
intentions then the way you explicitly
say that this conforms to the forward
iterator concept is with the concept map
the keyword you're explicitly saying my
type who conforms to forward iterator
and ultimately that's all that it comes
down to you declare concept a set of
requirements there's special syntax for
doing that you declare when you define a
template what the concept
are that the template parameters have to
conform to and when you define a class
if appropriate you say which concepts
they conform to there are a whole lot of
other features with concepts some of
which I expect will be used commonly
some of which I expect will only be used
by experts in rare circumstances just to
name a few of the more important ones
we've got refinement or concept
inheritance you can say anything that
conforms to this concept also conforms
to that one if you're familiar with the
STL the sort of classic example of this
is the iterator hierarchy you want to
have the random access iterator concept
inherit from the forward iterator
concept there's I showed you the
simplest kind of requirement on types
just saying that a template parameter
has to conform to a concept there are
more complicated cases where you have
multiple template parameters and there
has to be some kind of a relationship
between them that's what the requires
keyword is for and then the concept map
keyword I showed how you can use it to
say that a type and conforms to a
particular concept there's also a sort
of interesting case what happens if a
type can fill us in some philosophical
sense conforms to a constant concept but
doesn't have exactly the right syntax
and the classic example here again is
from iterators you want to be able to
say that pointers are random act access
iterators but pointers don't have member
functions so you have to say a little
bit about how they syntax maps from one
to the other and that's what the other
feature of concept mapping is for that's
how syntax adaptation works and I think
that my five minutes are up so if you
want to know more about concepts ask us
after the talk or go watch Doug's talk
again or wait for the tutorials to get
written so that's there have been other
new template features concepts are the
one that probably took the committee the
most time I think it's sexually fair to
say concepts were ten years in the
making but there have been other
interesting template features and the
one that is actually worth well I'm
going to mention to spend actually
spend some time on one this falls into
the category of why didn't you do that
earlier it's it's restricting that there
was never any really good reason for it
that you couldn't have template type
desks well now you can the syntax looks
a little bit funny for uninteresting
historical reasons but the feature is
there something that's a little more
interesting is very attic templates so
again the first question isn't so much
how the feature works but why do you
care about it why is this something you
would want well this is the classic
example you'd like to have a tuple and
type and you'd like to just be able well
it's obvious what it does it's an
obvious generalization of pare-pare
takes two template arguments stores two
things of arbitrary types this takes n
arguments stores and things of arbitrary
types it is actually possible to
implement this without very attic
templates but it is extraordinarily ugly
and there are limitations this is really
the way that you want to do it another
pretty obvious example you'd like to be
able to take pasion n arguments and find
the minimum of them and a slightly less
obvious but still interesting example is
o type save printf with this probably
looks pretty familiar to you if you've
got Python we've got three percent s
things here and the semantics is just
you can pass in anything that converts
to a string the conversion will happen
at compile time it will just work so how
does it work
well if you're actually defining very
attic templates if you've used Haskell
or ML it'll actually looked fairly
familiar to you it's pattern matching
you this is a very attic template
declaration it says that you can have an
arbitrary number of arguments and then
you have to define partial
specializations this is where the
pattern matching comes in here's a
partial specialization for the case
where there is at least one template
argument provided here we've now named
that head you can do something with it
here's all of the rest of them you then
recursively invoke the template again
and finally it bottoms out because
here's the specialization for there are
no arguments and you can use various
tricks for how you work with one
argument at a time it's I'm not going to
go into this in
but if you're familiar with this sort of
pattern matching style of programming it
should be fairly obvious well that's uh
all I'm going to say about template
features now so we've got about five
minutes now to talk about everything in
the library the library is now about
twice as large as it was in C++ 98 and
one the one-line description of what's
in the library is everything in TR one
except special functions sort of and
then just a few other things so this is
an this list even isn't quite complete
but it contains most of it and I'm just
going to touch on a few of the
highlights this regular expressions it's
not as if nobody has been using regular
expressions in C++ before but there have
been a whole bunch of different
libraries none of them standard and this
is the standard syntax for doing it
again if you're used to Python it should
look fairly familiar it's more the
Python model than the Perl model you
have a reg X class you invoke it you
invoke the constructor passing in a
pattern for the regular expression and
oh yes here's another language feature
that we hadn't mentioned before you see
this R here before the string literal
this is a raw string and in a raw string
you don't have to escape back slashes
and you can put in new lines having
regular expressions without that would
have been pretty painful so you create a
regular expression pattern you invoke
the match and function on the input the
pattern and a object here that gives you
access to the individual fields then you
cannot just extract each of the
individual fields you care about and of
course there are more things that you
can do it's got search and replace or
format depending on which way you want
to think about regular expressions we
can iterate through matches match one
thing that match and other things that
match another thing but in the in the
simplest case it's really as simple as
this random numbers the again it's not
as if we haven't been using random
numbers in C++ since forever we've had
the rand function the model here is
we want to distinguish between the
engines where do you actually have your
underlying source of randomness is it
the linear congruential is it Mersenne
twister is it some kind of physical
entropy generation and then once you
have this physical source of randomness
how do you actually get a set of numbers
distributed in some pattern you've got
the uniform distribution you've got the
exponential distribution poisson normal
log normal all of these things so here's
a simple example where we take one
engine this is recommended as the one to
use if you don't want to think about it
too hard it's just a reasonable default
you've got a distribution here a normal
distribution here with the parameters
and you get to hey yeah it's a number or
well presumably more than one number
from that smart pointers these are
pretty familiar from tr1 we've got the
shared pointer model which is simple
reference counting if you make a copy of
a shared pointer then they point to the
same thing and the underlying object
gets deleted when the last smart pointer
to it disappears unique pointer is a
little bit less familiar because you
couldn't have it without the move
semantics that was introduced in C++ Oh
excellent that lawrence talked about
unique pointer the model is an object is
owned just by a single a smart pointer
but that pointer can change you cannot
make a copy of a unique pointer because
then the ownership wouldn't be unique
but you can do a move so here's an
example again of how you might use
unique pointer we have a function that
creates something there's a temporary
variable of type unique point you're in
here but it goes away when you return it
so it's still unique you have a vector
of unique pointers you can put something
into the vector at any moment the
ownership is still unique at any moment
there is still only one owner but that
owner can change over time
no copy but move and I think at Google
that's probably going to be fairly
popular since the moving but no copying
is a fairly common technique here a
whole lot of new features to support
manipulating function objects I'm not
to go into all of them in detail just
show a simple example that combines a
lot of them this is a way of naming an
arbitrary function like thing that takes
a single argument of type person returns
a string and this combined to a member
function it can bind to a function
object to combine to an ordinary c style
and function this just abstracts away
all of these differences and just lets
you talk about the argument types and
the return type and here is an example
of how you can use this to return
something that takes a string and
returns a bool and that's the result of
a fairly complicated bind expression
that lets you test whether a person has
a name equal to something arbitrary
that's passed in this is this whole bind
facility is probably largely redundant
now that we have lambdas there might
still be cases where it's more useful
than lambdas I can't actually think of
very many this is probably still useful
it really is useful to be able to talk
about function like things without the
specifics of the syntax we've got some
very very limited support for talking
about time this was really an adjunct to
the threads facility because you really
like to be able to to say when you're
talking about threads run this in five
seconds sleep until such-and-such a time
it can be the basis for a more
complicated than time library but at the
moment it at the moment let's think
about it let's think of it as a somewhat
more explicit and somewhat more typesafe
way to talk about in clocks and it's a
little bit more explicit mostly because
again the question of what a clock
represents you've got this integer is
that microseconds milliseconds
nanoseconds what have you now you're
actually able to talk about that in the
type system so it's at least a slight
improvement over what we had before and
it's something we can build on well a
lot more library features that I'm not
going to talk about you can ask us later
or again read things probably the most
interesting of the things that I've left
out or improved Unicode super
we've got new types to represent wide
characters we've got them extended into
the library somewhat we've got some
features for converting between utf-8
and utf-16 and utf-32 and we've made
some some other relatively minor
improvements in string notably we've
made it a little bit less thread
unfriendly so a whole lot of things that
didn't get into C++ o X suddenly the
committee has started feeling time very
short this is a list of some of the
things that didn't get in but that the
committee has reasonably committed to
towards the future probably what's going
to happen is the next major revision of
the standard will still be awhile from
now but we're going to be releasing
these things as technical reports one at
a time those won't officially be
normative but it'll at least be a way to
design and describe the features so that
compiler writers can get practice
implementing them and everyone has their
own hot list of what features they think
are most interesting from this list I
suppose I would probably have to say
that improved thread support would be at
the top of my list we've got very
limited support for a high order and
thread Pro higher order concurrent
programming in the C++ standard it's not
really much higher level than POSIX
threads you can create threads you can
do locks you've got condition variables
but we don't have all of the other data
structures that we're used to we don't
have thread safe queues we don't have
thread pools it would be very nice if we
could standardize those things using our
low-level thread structures as a
foundation and that's something where I
would hope that Google can help by
defining some of these facilities and
try and open sourcing them and trying to
get them standardised so what is
happening now well officially C++ Oh X
has not been released yet and in fact I
should take out that word officially it
just isn't finished yet what we have
right now is called a committee draft
meaning this is the first draft of the
new standard that the committee is even
willing to talk about in public and it's
now we're in the middle of the public
comment period we're asking for
people to find bugs in the standard find
features that should be removed find
some features that aren't as complete as
they should be
notice the deadlines there is a reason
that this is in red we have some time to
submit public comments Laurence and I
are collecting them I'll tell you in a
minute
some ways that you can help with this
and we should try to get them in soon
what's going to happen after this is the
Standards Committee is going to look at
all of the defects that have been
reported it's going to look at all of
the defects that committee members have
found on their own and it's just going
to be well you can think of the CD as an
alpha so what we want to have one year
from now is our beta the final committee
draft there are still going to be some
more comments on that but we expect them
to be much smaller we expect that here
things are going to be really feature
complete and it's going to be small bugs
that we're looking for a year after that
we would be shipping the final draft
international standard that's still not
officially officially a standard but
except for typos you should think of
this as final it's just going to take a
six months or a year after that for it
to get through all of the official ISO a
bureaucracy so I think we've left enough
time for questions now and I would
encourage everybody to use the mic for
questions since some people are
listening to this talk remotely
I think between the two of you you have
a reasonable idea of what the C compiler
team is up to what GCC's up to and what
kind of how the C style people think so
when do you think we might be able to
start using some of these in conforming
Google 3 code at least some some fun
subset of them I think that some of
these features will be easier than
others one problem of course is that we
use more than one compiler at Google so
we're not going to be able to use any
feature until let's put in generally
until whatever code that feature is in
can be compiled by all of the compilers
that are ever going to be touching that
code that's probably the biggest concern
because it's a big company and we don't
necessarily there isn't necessarily a
single person who even knows what all of
the compilers are out there and if we
solve that procedural concern we'll
probably be able to get these features
into use sooner the style issue well
some of these features are going to be a
little bit more controversial than
others I would expect that say Auto
there probably is going to be very
little resistance to I would expect that
some of these features address areas of
the language that Google just stays away
from in generals and that probably won't
change very quickly so currently C++ is
the slowest compiling language that I
use how do you expect these changes to
affect the speed of compliation so the
speed of the compilation will go down
the current the current estimate it a
lot of it comes from the concepts and
and the improved checking on the
templates the current expectation is
that in full production compilers there
will be about a 10% loss in performance
for code that uses the standard library
and
Hevy way for code that doesn't use the
standard library and isn't using these
features you probably won't see a major
slowdown in the compilation the other
answers that I should give to that is
that the range of compilation speed in
different compilers is much larger than
you might think I we used to work at
Apple before I came here and people at
Apple were constantly comparing the
speed of GCC and Metro works on
wondering why GCC couldn't be anywhere
near the speed of code warrior I am
hoping that it would probably be hard to
modify GCC to match that speed but other
compilers that are better than GCC are
entirely practical and there are work
there is work on new C++ front ends I'd
also like to point out for optimized
build most of the compilation time is in
the backend and the optimization and so
forth so the front end speed is really
only an issue when you're doing debug
compilations yeah to clear questions I'm
glad to see they address the thread
safety of the strings does that mean
that the copy-on-write is gone are they
using the Atomics for that and also what
about other reference counted semantics
like locales and facets strings
copy-on-write is gone so yes that's the
existing standard has very complicated
guarantees that were basically designed
to allow but not require copy-on-write
the new standard has guarantees that I
think basically cannot be satisfied with
copy-on-write that doesn't bother me
copy-on-write is one of these things
that sounded like a great performance
improvement at first but that most
library vendors have decided to move
away from anyway and the question is
what about other reference counted
facilities shared pointer is just plain
thread safe it's designed to be it uses
and every implementation that I know of
uses Atomics internally locales and
facets the
yeah trying to think what terminology to
use here there is a general guarantee of
thread safety in the library
introduction essentially unless anybody
says otherwise using two objects of the
same class in two different parts of the
program in two different threads it
won't explode you and the implementation
has to do whatever is necessary to meet
that guarantee my question here is there
going to be template specializations
based on concept conformity so could you
have sort work for leak list just as
well yes yes that was that was that was
on the list of other concept features
that I would not discuss I think of it
more as overloading on concepts and it's
actually a pretty essential feature one
of the classic examples of why you need
this is in the existing STL we've got
this advanced that takes an iterator and
account if it's a forward iterator you
just have to advance it one at a time if
it's a random access iterator you just
add so yes you can do that overloading
is the committee considering any actions
that would make c++ easier to parse for
automatic refactoring tools so the the
problem with that is that it's very
difficult to make c++ easier to parse
and make it compatible with the past so
we the general approach of the committee
is to try not to make it too much worse
it's part of the price of dealing with
you know a trillion lines of code it's
very hard to remove features there's one
feature that wasn't necessarily the
feature I hate the most but it's on my
list and it's one that I thought was
completely unused so I proposed to the
committee that we get rid of it and the
IBM rep said no no we have all of this
code internally that you can't find with
Google Code search that we would break
if we removed that so we are still going
to have progress and and if you can't
even get rid of trigraphs you can't get
rid of anything oh ok so with the
introduction of threads and especially
all of the mutexes and condition
variables it was thought given to the
ability to automatically do thread
safety reasoning well the the GCC
compiler has facilities in it to
annotate the association between
variables and locks and so forth so that
stuff is going forward there's no
specific language design feature to
address that but it was it was in the
mind of the people putting this together
that that should be possible
C++ is a might prefer the language for
more than 10 years and usually when
people complained that C++ was
complicated and complex I used to
explain that is kind of misperception
it's a lengthy you won't give it here
but now that the new standard is almost
twice longer than the old one isn't that
too complex was the committee considered
these situations their first is the the
standard is much bigger but most of the
growth has been in the library so the
and that's fairly isolated you you know
you can not read a chapter and and not
be be upset the the core language part
has grown but it hasn't grown a whole
lot the third answer is everybody on the
committee agrees that C++ is too large
now I mean everybody it's unanimous
everybody agrees that we shouldn't add
too many features and everybody says but
just this one feature and I we we've
tried to strike a balance between
restraint and growth I hope we've struck
the right balance there there are some
features we've added that I wish we
hadn't but not very anything and and the
other thing to remember is many of the
features that have been added are in in
the way of generalizing things so C++ 98
there are if you try and mix this
feature in that feature you find out
well you can't really do that and so a
lot of the complexity comes in things
you couldn't do and a lot of those
barriers have been reduced the
initialization you could simply not
learn the old way to do initialization
and go with the new syntax and cover
almost all of your needs so there are
simpler ways to approach the language
but if you want to know the whole
language it has gotten a little
more complicated I mutexes re-entrant
I'm you Texas re-entrant oh so there are
regular mutexes time to new Texas and
reentrant mutexes and time granted mutex
now what we don't have is reader/writer
locks that was something the committee
decided they didn't have enough time to
put into this standard if I think it's
fantastic work I haven't looked at this
for a long time and just surprising the
number of features you put in this how
are you going to name this new language
more seriously the perfect forwarding
issue is that gonna be taking care of
the reference to a reference or Bell
r-value references one of the design
goals for our value references was to
take care of that problem yes and that
that's used heavily in the standard
library now I think we're out of time
now so thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>