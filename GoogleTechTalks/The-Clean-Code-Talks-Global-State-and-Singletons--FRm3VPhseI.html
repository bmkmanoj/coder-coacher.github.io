<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Clean Code Talks - &quot;Global State and Singletons&quot; | Coder Coacher - Coaching Coders</title><meta content="The Clean Code Talks - &quot;Global State and Singletons&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Clean Code Talks - &quot;Global State and Singletons&quot;</b></h2><h5 class="post__date">2008-11-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-FRm3VPhseI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming to our another
clean call talks and we are going to
today talk about global state and
basically the idea of Singleton's which
is a formal global States and
encapsulation and how Singleton's make
your API really deceptive and how this
really makes the whole thing really
difficult from a testing point of view
so it's a global state you know I like
to point out that somebody once told me
that this is this condition of insanity
which is that you repeat the same thing
and you expect a different results and
Singleton's allow you to do this single
things allow you to repeat the same
thing and keep getting the different
results which will slowly drive you
insane so let me point this out suppose
I have a class X and there's a method
that does something and computes a value
called int and I'm going to instantiate
it twice and I'm going to call the
method twice that way I'll have the a
and B value now here's the question does
a equal B or not necessarily what do you
guys think so you don't think it has to
okay let me ask it slightly differently
which code would you rather be in in the
code where the two are equal or in the
code where the two are not equal where
they are equal so you will much prefer
to be in the code base where it's equal
and so I'm going to agree with you I
think the same exact way that if you
have a if you basically do the same
operation twice I very much would like
to get the same exact results so the
thing is that the object state is
transient and subject to come yes and
could you could I trouble you to use the
microphone because we're recording this
so one thing is that the function was
called do something so do something
doesn't tell you whether it's only
getting something or doing something it
does something that it doesn't matter
actually that this could be different
okay it that actually doesn't matter the
fact that it's built two at two away
container suicides of whatever here if
it actually doesn't matter the key over
here is that there is no information
flowing into the system right there is
nothing I'm passing through the
constructor and there's nothing I'm
passing through the methods and
therefore whatever is being computed and
because this is a computer which is a
final state machine it better produce
the same exact result every single time
I run this and if it doesn't produce the
same result every single time I run this
that means there is some global stable
we're getting ahead of ourselves
so here's the thing object state is
transient and it's subject to garbage
collection right which means if you lose
a reference everything inside of it goes
away and this is a good thing now a
class state is something very different
the class state is persistent to the
lifetime of the JVM yes I said I just
wanted to point out that of course it
doesn't necessarily mean global state
right because it could be something
coming in from the outside world that's
a global state to actually we'll get
there in a second man you guys are today
very much ahead of me
all right so class state on the other
hand is persistent right this is where
you use the static keyword and you
basically are tying the value not to the
instance but basically the whole JVM so
let me point look at this thing it's a
little further if I do new X I'm
basically building some graph of objects
though the X constructor can instantiate
a whole bunch of other objects and so on
and so forth and some graph objects gets
built so if I do new X again again I'm
constructing some graph of objects and
it better be the same object graph
because I didn't specify any other
parameters right there's not no other
input coming from the outside so now if
I do the two operations I better get the
same value if I don't get the
same value that means that those two
graphs are secretly talking to each
other and that the fact that they're
talking to each other secretly is what
the problem is here it's not explicit
it's hidden and it creates all kinds of
mis mishap in our code base and it's
what will drive you eventually insane
and crazy because you will keep on doing
the same operation and different things
will be happening in other words there
is something that's getting into the
system something that's being persisted
between in locations that's causing this
and I'm going to argue that this kind of
way of coding actually makes it a lot
worse to understand the system to
understand how to debug it to find bugs
and so on and so forth so if you have
global state you're basically in a
situation where multiple executions can
produce different results and as a
result of that if you're running tests
your tests are flaky you run a test once
it works your and again it fails you run
again it passes and that kind of test is
really hard to debug and then of course
you have to ask yourself the test is
supposed to have a control over all the
parameters so if I run the test over and
over or over again it's consistent right
either the code works or it doesn't the
fact that it's flip-flopping black and
forth and it's flaky really implies that
somewhere there is global State
something that we don't fully control
from the testing point of view it also
means that the order of the test matters
so if I run a test in isolation the test
passes if I run it as part of the test
suite
it no longer passes because one test
sets some global state another test
expects the global state to be in a
certain state and it isn't and all of a
sudden your tests are starting to fail
and it also means that you cannot run
the test in parallel you know if you
have a multi-threaded CPU it would be
great if you could run all the different
tests on different threads but because
there's global state these tests can
talk to each other in the back through
some Singleton's and as a result you
can't do that now there is some there is
even worse format of this thing and that
is you have a test that
asses two together but if you have a via
the test as part of a suite and let's
say your suite takes an hour to run and
the last test and the suite fails and
you're trying to debug it and you try to
run it in isolation and it passes all
right good luck debugging anything like
that so from a testing point of view
global state is really a horrible
problem for us and we try to avoid it as
much as we can now there's a couple of
hidden global State inside of the JVM
something that you might not think about
but there is system that current time
there is some secret process going on in
the background that secretly updates
this global variable called the current
time and it's being updated continuously
and this can cause flakiness if you
expect certain things to be returned
from your current time same thing as new
date right new date internally called
system data current time and so the
global state now is inside of date as
well another one is math.random there's
no such thing as random in in software
but there is pseudo random sequences and
in order for the pseudo-random sequence
to happen it has to be initialized by
some kind of a seed and so internally
the math function keeps hold of the seed
and every time you call math that random
it uses the seed to generate the next
pseudo-random sequence otherwise random
will always return the same value so the
seed itself is is somewhere secretly
global and so I'm gonna make an argument
that if you have code that uses any of
these things you will have hard time
writing tests for these a really hard
time this will be flaky you can't run
them in isolation maybe you can't run
them as part of the suite the order of
the pessimal matter and so on and so
forth how many of you guys have test
suites that are flaky oh come on I can't
believe nobody has them all right that's
better and I'm gonna argue that all of
your flakiness will come basically from
some form of uncontrolled global State
so let's talk about Singleton's for a
second so people say there is an object
that I only really need to have a single
instance of something inside of my JVM
because typically you have one
application per JVM and the application
only needs a single instance of an
object and so they say okay because I
only have one application per JVM
therefore I'm going to instantiate the
object and put a reference into the
global space that's what a singleton is
right singleton has a dot get instance
method that has instance field which is
attached to global space which is part
of the class which means it's no longer
subject to garbage collection and so on
and so forth but here is here's the
problem from a testing point of view in
the test each test basically wants to
instantiate a small portion of your
application it wants to apply some
stimulus to it it wants to assert
something and then it wants to basically
take whatever it had and throw it away
that's what the garbage collector is for
right it just wants to be garbage
collected and then the next test runs
and that test instantiates a small
portion of your application apply some
stimulus and throws it away
and then the next test goes on right
when you have a global state that's part
of the JVM unless you run every single
test in the separate JVM which we don't
for performance reasons it doesn't
really work does it so you really want
to make sure that you you don't have any
Singleton's that are tied to JVM and
this is where the ambiguity kind of
comes into play and I like to
differentiate it as in singleton the
capital S and singleton the lowercase s
if we use capital letters for the names
of something so if you have the design
pattern singleton
then we are referring to the fact that
the singleton has a private constructor
and it has a global instance variable
right that's what the design pattern
says it is there's also the the idea of
a lowercase singleton with lowercase s
meaning that I only have a single
instance of something but that instance
does not have a private constructor and
it's not attached to the global my name
space I only have a single instance of
it because
only called the new operator once those
are two kind of very distinct things so
I like to differentiate them singleton
with big s and the singleton with
lowercase s or the good singleton versus
the bad singleton so let's talk about
the classical singleton with capital s
suppose you have a class called
appsettings
and most applications have something
like this they have that the global
field called the instance which is
declared with the keyword static which
is what makes it global and it
instantiate s' the class in line by
calling the new operator on it directly
and then we have a a private constructor
so that nobody else can make a copy of
this this is classical singleton right
guys all agree right um so let me ask a
question now and that is how many global
variables do you see on the screen
so you said three you said or the state
one two and three is that what you're
saying four um correct yes four because
of instance yes actually I'm going to go
a step further and I'm going to say it's
in theory infinite because the state one
can have a pointer to an object which
internally can have state and then
object can have a pointer to another
object that can have state and so on and
so forth and so really it's infinite
number of different variables that can
possibly affect the execution of my code
so the problem with global state is that
it's transitive right once uh once you
cross a global variable which in this
particular case is the instance field by
calling the get instance everything
behind that everything that's accessible
from that global variable is global as
well now let me ask over here how many
people think the global variables is a
good idea
no one how many people think Singleton's
are a good idea people are raising their
hands okay so what gives I just proved
to you that Singleton's make a whole
bunch of global variables and you're
telling me Singleton's are a good thing
but you all agree that global variables
are bad thing so think about it now
here's the next problem because the test
doesn't control the instantiation of the
object and we kind of covered this in
previous talks how it is important that
the test can instantiate a small portion
of your application apply some stimulus
and assert something right the test need
to be in control of the instantiation
process here the tests are not in
control of instantiation process and
therefore the test can never get a hold
of the state one two and three and
because the the tests cannot get a hold
of the state there is no way to assert
anything
there's no way to reset anything and
there's nowhere to work with this in any
way so what most people do
is they'll have custom methods that are
for test only how many of you guys have
done that good so in other words we took
a singleton design pattern where we
fought really hard to make sure that
it's singleton only one instance is in
there which means private constructor
and global variable and then we secretly
put in a whole bunch of backdoors so
that we could replace it at a runtime
for testing purposes and modify it and
get a hold of that right so I mean isn't
that kind of weird like you want to make
sure and then you don't want to make
sure like which is your battle pick what
you want and stick with it right and in
this particular case the problem really
is that from a testing point of view you
want to instantiate a whole bunch of
small little tiny subsets of your
application and do something with them
we can already covered this right that
the internal state of a singleton
becomes globally accessible in other
words you have a whole bunch of global
variables as far as the code is
concerned and we all know all the
badness of global variables so let's
look at a code that uses singleton
suppose you have some methods some kind
of class called app and there's a method
on it and the method calls app settings
that get instance dot do X how do I test
this any thoughts out there how do I
assert that do X actually gets cold
you cannot there's no seams right in
order for us to assert something we need
to have seams and again we talked about
this earlier that you need to be able to
instantiate the class under test and you
need to have control not just of the
instantiation of the class under test
but you also have to have control over
the instantiation of the class under
test dependency or its collaborators
right in this case the class app
collaborates with app settings but in
order to get a hold of the collaborator
it doesn't ask for the collaborator to
be the constructor that instead it
reaches into a global variable gets a
hold of the collaborator anything
collaborates with it and this makes
testing essentially impossible now
usually again the way people saw this is
they'll have a special for the test
method which says app settings dot set
instance and they undo their singleton
as' the property that they fought so
hard to introducing so let's see what we
can do how about we make it so that it's
public app settings so I understand that
within your application you only need a
single instance of app settings class
but the requirement is the single
application needs a single instance the
requirement is not that a single JVM
needs a single instance now it is true
that in most cases you're only running a
single app inside of your JVM but it's
not true for tests each test is a small
sub sub portion of your application
being instantiated and if that section
of the application needs to get a hold
of the app settings it wants to control
how it gets instantiated wants to set
things on it and once it's done setting
things it wants to be able to throw it
away in other words the garbage
collector should be able to get rid of
it so what we're changing here is the
class no longer enforces its own
singleton s and this is the key this is
really where the problem is from
Singleton's point of view if classes
enforce their own singleton s all kinds
of hard things happen from a testing
point of view
we have to basically have some other way
of making sure that our application only
creates one instance of it because the
application really needs one instance
but it's not because we enforce it
through a private and a global variable
instead we do so by simply making sure
we only call the constructor once that's
a different topic
so now in this case we can inject the
app settings into the app class and then
we can call settings that do X now from
a testing point of view I know how to
test this because I can instantiate the
app and I can instantiate the app
settings maybe with the correct State or
maybe I can instantiate a subclass of
app settings which will be my mark or
maybe I can use easy mark or J mark to
put a app settings in its place the
point is from a testing point of view I
have a choice I can do all these
different things then I can call the
method under test and I can assert the
right stuff happened so Singleton's are
the one greatest evil that makes your
code absolutely untestable now but it
gets worse
have you ever seen api's that lie about
what they do let me show you some pretty
deceptive API so once upon a time I was
on a project and I wrote this particular
test and it said new credit card and I
had to pass in some numbers and I said
credit card that charge $100 and of
course the credit card constructor
insisted that the credit card number be
valid so I had to close this credit card
number I could find was my own wallet
and I ran this test and wouldn't you
know it on the end of the month I got a
bill and I was out of $100 this is what
we call by spooky action at a distance
here's the thing how did the credit card
know how to talk to the server how did
it know where the server was how didn't
know how to authenticate how did it know
who was the person to be charged how
doesn't know what the account was like
all these questions
are hidden right it just sort of
happened and it worked not actually it's
more complicated than that because the
test never really passed in isolation it
only passed as part of a suite when
every remand out of a suite I was out of
a hundred bucks when I ran it in
isolation I actually get some weird no
pointer exception I didn't know why I
was getting all pointer exception so
instead I went to talk to the wiser and
older members of the team and I said I'm
trying to do this what's going on can
you help me out and they said oh well
come on man you should know this you
need to call credit card processor that
innit really how was I supposed to know
this the api's didn't tell me that I had
to know this it's just kind of I had to
do this okay so I wrote credit card and
in that pass the whole parameters to it
and I ran it and I got another exception
this time in a different location so I
was making progress and I said okay now
what I do so again I went to the older
and wiser and they said oh yeah the
credit card processor actually needs to
use offline queue and so you better call
offline queued start again that wasn't
obvious to me how was I supposed to know
this so I did that and I ran the test
again and wouldn't you know and I got
another exception again so again I went
to older and wiser and I said what am I
doing wrong here I can't figure this out
and they said well come on man
offline queue needs a database really
like how was I supposed to know this ah
and so when I passed in the database
then the tests around and I was under
out of a hundred bucks again so the now
look at this thing a little further the
credit card is lying to us
it basically says it pretends to not
need the credit card processor even
though in reality does write the code
didn't work without the credit card
processor but the credit card didn't say
it needed it
nowhere in the constructor that it
doesn't say I need to get a hold of
credit card processor no we're in the
method
is that a setter on a credit card
processor there is no way for me to know
that a credit card processor is needed
but it gets worse if I initialize credit
card processor again I have no way of
knowing that the credit card processor
needs an offline queue and it gets worse
if I initialize the offline queue there
is no way for me to know that I need to
get a hold of database these things are
just are the way they are and you don't
know now in the real system you don't
have three Singleton's or even four or
five you have hundreds of them and they
all have to be initialized in the
correct order have you ever seen the
main method of most of the applications
where all the singletons get initialized
it's like black magic like nobody knows
what's going on in there like in some
bizarre order they have to get
initialized and if you change the order
nothing works
are you guys agreeing with this or you
never seen an initialization of a main
method like that
now here's another problem I've read the
code I leave somebody else comes after
me and looks at this and says looks at
this red part and looks at the green
part and says I don't think those two
things are related in any particular way
as a matter of fact I think I can
rearrange them because I think it's
gonna improve the performance or
something or rather I have some reason
why I want to rearrange the code and
change the lines of code and I think I'm
allowed to do that because there's no
parameters getting passed in those
states getting passed and I should be
able to rearrange this maybe I can
change the order of things you think
that's gonna work it's not right so
here's the thing that here's the
assumption that I would like to make and
then it's if I have a code like this or
I simply instantiate a and B and I
perform some operations on it
I would significantly prefer to work on
a project where I can freely rearrange
the order of things and I expect the
order to still work
and the reason I'm allowed to rearrange
things is because the only dependency as
far as I'm concerned between a and B is
on the method why when it says in order
to call method why you need to pass in a
method B so clearly I better be calling
the
don't be right but it doesn't say that a
has to be instantiated before B or vice
versa
it also doesn't force me to call a dot X
before I call B dot Z right all of these
things I should be independent about
calling them in any order I want and the
only way I can assert that is if there
is no global State in other words the
only way to objects can talk to each
other is if I have specifically allowed
them to talk to each other by passing a
reference if I pass a reference from A
to B then a is allowed to talk to B if I
don't pass reference between these two
objects then they are in two independent
graphs and that's a good world to be in
it makes our cognitive load a lot much
better now here comes the pendency
injection I mean it's the thing that
solves this particular problem what if
you know we come back to our test again
you know we have all this static
initialization on the bottom and all
this credit card thing on the bottom of
there what if I okay so we kind of said
we can't change the order over here
right because that's not going to work
let's get back to this thing here what
if instead of new credit card we're
inside of the credit card somewhere
secretly I say credit card processor get
instance what if I simply said I asked
for the critical processor in the
constructor see how it says so new
credit card here's the credit card
number and I ask for the credit card
processor in the constructor when I did
if I would have done this and some new
person comes on to project and he wants
to instantiate a credit card there's no
black magic going on the credit card
says I need a credit card processor it
declares it explicitly there is no
hidden secret communication channel
between the credit card processor and
credit card it's explicit it is clearly
stated what it is so you go in and you
say hey credit card processor new credit
card processor and look what happens
over there the critical processor says
but I need a cue again no secret channel
of communication
plus it it says this is what I need so
I'm going to do new offline queue and
that says but I need a database so you
say no problem I'm going to instantiate
a database and you go on and on and on
until the whole thing is provided for
you now here is what happens over here
notice I cannot rearrange the order of
things anymore it's very explicit in
what I need to get my job done and it
also is not possible for me to say new
credit card processor before I call the
new database it simply doesn't work it
won't compile so dependency injection is
actually your friend when it comes to
initialization and if you don't have
global states and everybody asks for
things explicitly in their constructors
your main method becomes a lot clearer
you know who needs what in which order
like all the mystery disappears as a
matter of fact if you try to initialize
things in the wrong order
you won't even compile you guys see how
that kind of helps out
so the coolest part of it is the
dependency injection enforces the order
of initialization at the compile time
and this is a big plus this is a really
a big plus it really helps when a new
person comes onto project and looks at
the code and says I know in which order
things have to be initialized because I
can't do it the wrong way it also allows
me to test things in isolation ah for
example if I wanted to write this and it
said I need a credit card processor in
order to get my work done I could have
stopped over there and said hmm maybe
instead of instantiating the real credit
card processor I'm going to create a
mock of a credit card and pass you a
mark and then I simply cut the whole
dependency right right there and I'm
going to test now credit card in
isolation and now by providing a mock I
can prevent my hundred dollars
disappearing out of my wallet every time
I run the test but maybe I'm going to
say to myself now maybe that's not a
good place to place a mark maybe I want
to have a real credit card processor a
real offline queue but I fake database
or vice versa all right you have a
choice the point is they by doing
explicit dependency injection you have a
choice where you want to draw the line
and these choices is what is what makes
the testing much easier so I'm going to
argue that global State is kind of the
root of all of your testing problems not
all of them actually that's kind of
maybe a little too strong but it's good
90% of them the other one is structuring
your cold properly but most of the times
most of the times when we're having a
really hard time instantiating objects
etc is because there's some secret
global state that allows us to objects
to communicate without actually knowing
about each other and the problem with
global state is well it cannot really be
controlled from the tests and if you do
want to control it then we have to put
all kinds of setter methods and then we
have to remember to clean up after
ourselves and it's also a problem
because it's very easy for people to add
global state you know so maybe you write
a test and you remember to set up your
test correctly and then clean up the
global state after yourself but then
somebody else comes along and adds a new
global variable and it affects you in
some way and you're not sure you don't
know about it and you don't know which
test you have to go and change to make
it work again
and so Singleton's
is this common form of encapsulating
global State it's it's this weirdness
which allows us all to basically say
yeah global State sucks but single
things I love like what gives here like
Singleton's are like the global state in
sheep's clothing
like they pretend to be all hey look
there's only one static variable called
the instance somewhere at the root of
the object tree but guess what that
static instance variable is transitive
it makes everything else below global as
well and you know again there's a
difference between Singleton as in
there's only one instance of this class
and the object in singleton which
enforces its own singleton s through a
private constructor and a global
variable instance method there's nothing
wrong with having a single instance of
something the only becomes a problem
when it's tied to global states and we
already talked about the fact that a
global State is transitive so I want to
open up the questions
so in one of my programs there's can you
speak a little bit yeah sure there's
there's a a widget where it will show
messages for various things that are
happening and who's that have occurred
warnings whatever and at the moment it
is stored as a static global thing and
that way it's accessible from anywhere I
can just you know show a message mm-hmm
if I don't do that then you know I might
be somewhere way down deep someplace and
I need to show a message now in order to
get at that thing if I want to do it
this way I have to go back through all
the dependencies and make that it
something that gets passed in all the
way up the chain and that seems some
somehow excessive like yes so this is
like dad yes it is bad and this is a
very common myth so basically the
problem is that you need a single done
like a database somewhere on the bottom
of your application because it's the
bottom layer that talks to the database
or main your own singleton and you have
all these layers on top of it and so
clearly you're going to instantiate and
initialize the database somewhere inside
of the main method right and that
question becomes don't I have to pass
the database through every single things
all the way to the bottom and the answer
is no you do not the reason for that is
because you're mixing two things I'm
assuming that in your code you simply
when you need an object you simply
instantiate it okay when you instantiate
an object in line you're mixing the
responsibility of construction with the
responsibility of doing business logic
and this is a this is a problem on
multiple levels first of all I can never
mock out the object you instantiate in
line it also means that your call graph
in your object instantiation graph are
pretty much the same so whoever you're
calling is you also whoever your
instantiated or vice versa whatever is
instantiated you're also the first
people who are calling now if you
separate them out and say I am NOT in
the business of instantiation I'm only
in the business of getting a whole I'm
only in the business of doing the
business logic and he's simply declaring
your constructor I need a database then
the person above you the layer above you
is not responsible for calling the new
operator on it which means it's not
responsible for worrying about the
database so the layer at the bottom can
say hey I need the database in this
constructor the layer above doesn't say
I need a database so I can call the new
operator on the layer below and pass in
a database it says I need the layer
below right the layer above it has no
clue about a database whatsoever let me
give you a different example suppose you
have a house and it houses a door and
door all of a sudden the door let's say
has a doorknob okay it's not that the
new operator of the house calls the new
operator of the door which calls the new
operator on on the doorknob and then the
doorknob all of a sudden says I need an
attribute called color and now we have a
problem right now we have to pass the
color all the way up instead you have to
structure the application differently
you have a house and a constructor of
the house says I need a door it doesn't
say I'm going to call the new operator
on the door it just says I need a door
the constructor of the door says well I
need a doorknob and a constructor of the
doorknob says well I need a color and
there's a separate class somewhere else
called the factory that is not
responsible for wiring all the pieces
together so the factory looks at the
house and says I'm instantiate the house
let me stand she ate the door let me
Stan shoot the doorknob and it passes
all the references around and notice
what happens
needed the house nor the door nor the
door in the house or the door know
anything about how the doorknob got
instantiated know what its dependencies
come from know about the fact that there
is such a thing as a color right so you
have to have a simple rule that is you
don't mix object instantiation with your
application or logic and then you in
your constructor you always ask for what
you need
so our credit card asks for the credit
card processor our credit card processor
asks for the offline queue and the
offline queue asked for
ah the database the Korean car didn't
know about the database neither did the
credit card processor or the offline
well the offline you need about the
database right but only the layer that
directly needs it only the object
directly needs it knows about the object
that he wants so this is a very common
myth by the way that a lot of people
immediately when they look at the
patterns injection that's exactly what
they come up with
ah but all it means is that you did
dependency injection halfway through you
didn't fully go all the way does that
answer your question
all right and you grab the microphone
for the house example isn't it kind of
inconvenient because house needs
thousands of things and you are going to
pass creator in the factory and pass
them as a parameter the constructor of
the house okay so ah if house needs a
thousand things then your house has a
design problem which is it's mixing
concerns or too many responsibilities
you're violating too many
responsibilities let me demonstrate
if I was to design a house I would
probably say something like in the
constructor of house I need the living
room I need the kitchen and I need the
bedroom and that's where I would leave
it at that
I wouldn't say in the constructor of the
house I need the wiring I need the
plumbing I need the sink I need so on
and so forth
the constructor of the kitchen would say
I need the refrigerator and the sink in
the plumbing
that's true what I mean is that I have a
dozen of members right member variables
you know trivial not it so now I have to
expose them as a man as the parameters
toward constructor all of them well if
you all had it was you know this was a
constructor with no arguments and I was
constructed a on the fly right yeah and
so how did the construct how did the
object get ahold of its collaborators
what you said we have to create them
outside and just pass the ownership to
the object right okay is it so is that
what you're saying correct
but I'm trying to understand it so if
you have it okay let me back up a second
there's really two kinds of objects and
I'm struggling with a good name for them
there has the objects that do work like
service objects like in this in our case
we had a credit card processor offline
cue the database right these are your
services one way to look at them is you
would never serialize them like if your
application saves its internal state you
never save an internal state of a of an
offline queue or a credit card processor
right when you call it when you
instantiate the application again you
make the new things but you do save
internal state of a credit card now I
call the credit cards kind of like the
value objects forgive the name I'm still
struggling with that and then is the
service objects which do work now for a
value object such as a credit card it's
perfectly valid to have a constructor
that takes no arguments and then you
have setter and getter methods to set
the the first name the last name the the
credit card number the expiration date
the bank kind and so on and so forth
right
the reason it's ok is because the value
object is really the the end of the call
graph or the end of the extension graph
like there's nothing on the other side
of it like that I mean maybe the credit
card is made up of address but like it's
pretty much the end of it right whereas
if you look at the credit card processor
it's hardly the end right it talks to
the offline queue it of the database the
rest of the JDBC JDBC it close to tcp/ip
tcp/ip has five layers underneath that
finally goes to the wire then there's a
sequel server that has like there's so
many layers before you get to the
hardest right it's a completely
different beast
and so in situation like those you
definitely want to ask for that
everything in the constructor now if you
have something like an offline queue and
the offline queue has let's say it has
ten fields ten collaborators it
collaborates with then yes you need to
have ten fields in your constructor now
if you look at and you say well that's
too many well then perhaps your offline
queue has too much responsibility and
you should consider about breaking it
off and saying well there's really the
scheduler and there's the
the persistent storage and really the
offline queue needs to only take know
about the schedule and the persistent
storage instead of trying to do
everything and know about the database
and the schedule and the parameters and
all these pieces right it's it's it what
the dependency injection makes gives you
is it makes your dependencies explicit
it doesn't make it worse or better
it just says this is what they are and
now most people freak out and say ah
it's too many lets blend dependency
injection like no no their dependencies
were always there whether you like him
or not you coded it that way I just made
it explicit so if you don't like it
don't don't blame the penance injection
for that it's you are the one who made
these you know 20 different
collaborators that you collaborate with
and that's going to make it hard to test
by all means yes because now I have to
mock out 20 different things but the
solution to that isn't to go back to our
pretend there is no dependencies world
as dependents are still there it's just
to structure up differently hi since we
are talking about dependency injection
this more practical questions um
basically there's this framework that is
used by a lot of people juice and it's
no it's a it's basically a scanner
framework which asks for no argument
constructor so Gallifreyan scanner it's
basically a some Oh like a servlet Oh a
big table yeah so basically us for uh no
argument construct yes yes and then it
makes it really miserably difficult to
tell yes and I already thought that only
all the other classes like I have a
classifier everything it asks for
dependencies but I ended up doing this
thing in the constructor of this
whatever I'm gonna write at the last
stage it looks like this is in charge of
the object graph but that's not true
because it actually does some work so
practically what are you going to do to
like yeah so let's do a concrete example
servlets are exactly what you're talking
about
servlets api sort spec says you the
servant has to have a no argument
constructor and it's a huge problem
because clearly servlet has to talk to
all kinds of things gets all kinds of
things done right
how does it get ahold of these things
the spec doesn't say and so what most
people do is they have no choice but to
use Singleton's but we know how much we
hate Singleton's right so how you get
around this thing well first of all many
frame was realized their mistakes and
corrected it so for example if you use a
GSE which is our all inter Google sort
of engine or if you use jetty or there's
couple other frameworks out there they
actually allow you to control the the
instantiation of your classes in which
case you are responsible for calling the
new operator and you can inject anything
you want in there so those frameworks
realize their mistakes and they solve
them for the frameworks where they
haven't solved it you are going to be
forced to somehow get the information
there through some kind of global State
but you need to separate the stuff out
instead what you're going to say is that
the service whole purpose is to isolate
me from the horrible API and the first
thing the server does is it goes and
grabs the singleton which is usually the
injector or some kind of a global
service locator where all the objects
can be registered and the first thing it
does is it delegates everything to an
eisley dependency injection class and
then because there's nothing inside of
the servlet it just all it does is it
does the evilness of looking at the
global State and passing it and then
doing the the nice stuff
you can totally test the rest of your
application because the the nasty bits
are limited to this one area and they're
only there because somebody screwed up
the API does that make sense
yes it does so basically what you're
trying to say is that even though
originally this whatever class I'm
supposed to do is supposed to do some
work what I'm going to do is I'm going
to create some kind of a double of this
class and exactly everything down to
everything delegated on and I can test
this and I can do all the good stuff
that I normally do dependency injection
everything and then this this horrible
poor class will become basically this
ugly duckling that all it does is does
the evilness of things that I try so
hard not to do but because it's forcing
me because somebody else screwed up I'm
gonna do it but I'm gonna
do as little work in there as possible
so that everything else can happen
somewhere else it's basically a strategy
from isolating yourself from bad
untestable api but thanks yes it still
seems like there are situations where
having global state is unavoidable and I
guess he was pointing at this but I mean
with webpages you know you it's not like
you you can just somehow I don't know
you don't have a main where you can just
instantiate all the things you need and
then have a be sure you have you have
main if you have if you use jetty if you
use a good servlet engine who doesn't
insist to be the container and control
the world instead it gives you the
control domain method so in the jetty
world you have a main method you
instantiate jetty you register all the
servlet and you control the controlled
instantiation so in the world like that
you can totally do what I'm saying I
think we're talking about it relating
sorry I was thinking of like maybe an
AJAX II app women's you have everything
almost everything happening on the
client there it seems like JavaScript
and so doesn't like John should problem
or yeah I mean it seems like you're
pretty well forced to supply can't you
why can't you do the same principles in
JavaScript as well if you have an object
that JavaScript why can't the object
says please pass all these references to
me through the constructor sure I mean I
think you can do a lot of this in there
but I but it seems like there's there
are some situations where you're you're
not going to be able to escape because
the thing is you already have a lot of
global stage just because of the Dom yes
but you need to separate yourself from
it otherwise you're gonna have a really
hard time testing it so don't just have
different methods reach in and to grab
Dom which is the document in JavaScript
right and manipulated its said instead
insists that all the objects that need
to manipulate with Dom ask for it in the
constructor so an interesting thing
happens when you ask for it in a
constructor and that is because methods
ask for it and you know if this one
needs it and the other Factory will need
it and so on and so forth whenever you
get to the situation where some method
is asking for a document and you don't
think it should you can like step
back and say something's wrong over here
because in order to get its work done it
asks for a document and I don't think it
should know about document therefore I
must have made a mistake somewhere so by
doing these things explicit you actually
find that a lot of these weird
dependencies come to light and you
realize oh that dependency shouldn't be
there and it's there whereas if you hide
all the dependencies all kinds of weird
things happen and you don't know why
Thanks it is possible basically to build
an application purely without global
state whatsoever especially if you
choose your technologies correctly such
as jetty for web servers you know and
you have proper separation of dependency
you know factories and so on and so
forth and you really get in the
situation that we talked about this
couple of weeks ago that every object
should only know about the its direct
collaborators you should never be in a
situation where you are asking for
something that you don't directly need
what it means is you don't dispatch any
method on this object you're only asking
for to pass it on somebody else okay
that's the dead giveaway that
something's wrong because you should
always only know about the objects that
you directly need yourself you never
should be in a situation where you're
asking for something just so you can
give it to somebody else because when
you're in that situation what it really
means is that object that you're passing
it onto you're either constructing it in
which case you're not supposed to be
constructing you're supposed to be
asking for an instance in your
constructor or it means that that guy
support that object is supposed to ask
for that object through its constructor
right in each case it's the same thing
it's it you don't want to know about
things that you don't need to know about
that makes it really hard to from a
testing point of view
any other questions
a comment from Road office yes hear me
yes we can um I I want to just add that
I'm a big fan of having no Singleton's
and the reason is I work on a system
infrastructure project where we have a
lot of communicating servers that
usually run on different machines but if
you want to actually crank them up at a
single address space and you want to put
in a mock transport let's see are we
actually you want to put in a mock
transport for example you can't you
can't do that if there's if there's
global state because the two objects
can't keep their state separate correct
so so we actually are able to test a
distributed application in a single
units address space by creating several
objects asking to the Mamaki transport
and then they all have their own
completely isolated State so I just want
to put in a plug why you know not having
single this is a good thing right yes so
you're agreeing with me right just make
sure in the same thing I'm agreeing with
you it isn't one of the one of the
pieces of evidence you gave you were
saying well you know you don't want to
have four of them yeah you can only have
one application inside your JVM and I'm
saying we deliberately want to set up
both full copies of the application
simultaneously running in the same
address space correct correct
I'd like to actually just add something
to what you just said and that is
suppose you have something like jetty
which is a web server which is a
container for web servers right if jetty
internally had a global state that it
would mean that I can only have one
instance of jetty running which can be
ok for most of the applications but what
if I want to have an application running
in a single JVM that serves the user is
on port 80 but on port 8080 I have
administrative UI where I can do some
extra stuff that the users cannot do in
essence I want to have two separate
instances of jetty right can't do it if
you have global State exactly what you
point out over there
so yes and the the other way of looking
at it is really every single test is a
new application being accentuated right
and so if you have Singleton's like the
game's over and you haven't even started
testing you can essentially have one
test per JVM and that's not very useful
so I'd like to make a meta comment about
global State so even the if you if you
invoke static methods from class files
right the whole class hierarchy no
java.lang java oh and so forth that's
that's really all static State and the
existence of methods you know like
system load library and and you're doing
file i/o all of that is is really rife
with with global state and and I I only
know of one programming environment in
existence that tries to systematically
remove all of it so that you know you
have a main method it doesn't just get a
list of arguments it gets a platform and
the only way you can do I always by
calling methods on platform all right or
getting calling methods that will return
you with no file objects or whatever on
on your platform object and that is the
the Newspeak system that's derivative of
small talk but I don't think any so
every other programming language it is
around has some kind of notion of this
of there's some static state somewhere
so in the real world you you can't get
away from it yes but what you want to do
is you don't want to make your
application world worse right so you're
absolutely right there's tons of global
State inside of JVM whether you talk
about class loaders whether you talk
about there's just tons of it right but
I don't have to test the JVM I simply
trust the JVM works right but I have to
test my application and therefore I
don't want to make my life more
miserable than I had then I have to by
adding global States into my application
yes
actually as far as I know although the
JVM has this a lot of static global
states you could actually pass them as
an interface that means like you know if
you want a date
you ask for date so I can pass you
either a new date or whatever mock day I
can pass so same thing with math dot
random instead of using math dot random
I can create a new random or even with
system in system I can pass a
bufferedreader buffer writer yes so the
system and that works perfectly and only
my object graph actually needs to know
about system in system out or whatever
yes but you have to code your
application in a special way right yeah
so the the honest is on you the
developer to code your application in
such a way so the later you can test it
and global state is gonna really make
your testing life miserable all right
any more questions well thank you guys
for coming that's great to see that
there's so many people interested in how
to write good testable code and we'll
see you guys next week we have these
every every Thursday at 3 o'clock and we
also have these cards on how to make
your what to look for in term in
testable code it would look for when
you're doing code reviews to make the
code a lot more testable so if you guys
want to have some of these cool code
review cards stop by and I have a couple
of copies with me and I can give you a
copy see you next week</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>