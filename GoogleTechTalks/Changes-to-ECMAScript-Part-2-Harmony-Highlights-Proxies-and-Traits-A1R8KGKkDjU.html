<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Changes to ECMAScript, Part 2: Harmony Highlights - Proxies and Traits | Coder Coacher - Coaching Coders</title><meta content="Changes to ECMAScript, Part 2: Harmony Highlights - Proxies and Traits - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Changes to ECMAScript, Part 2: Harmony Highlights - Proxies and Traits</b></h2><h5 class="post__date">2010-04-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A1R8KGKkDjU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">EXO ball and expressive metaprogramming
system which is also securable and those
constraints seemed ideally suited to the
work that we needed to bring to
javascript
so here's tom thank you mark for that
introduction so I'm going to start off
by briefly describing the new features
added to echo script fifth edition this
is the latest edition of JavaScript just
published in December of last year so
I'm trying to get everybody on the same
page here introducing some of the the
features of this language so one of the
more important features added to echo
suite 5 was the addition of strict mode
so strict in strict mode the language
helps the programmer guard against
common pitfalls which is certain
confusing features from the language
like the with statement and will throw
exceptions rather than failing silently
for example when you try to assign non
assignable properties so the other major
addition to this addition is the
addition of an object manipulation API
so for those of you that are familiar
with with Java I would call it the or
you could consider it to be like the the
JavaScript language of JavaScript so
what does this API look like well it's
an API that allows you to distinguish
and define data properties from accessor
properties and allows you to define
certain property attributes so here is a
example of a point declaration the point
has a data property called X and an
accessor property called Y so data
properties are just bound to values
accessor properties are also known as
getters and setters they will run when
the property is accessed or assigned to
and so
in eco script 5 there are these new
functions which are defined on the
object building called for example
gather on property descriptor so these
functions they take a as a first
argument an object that you want to
inspect and second arguments sort of
like a name for which you want to have
meta level information and what it
returns to you is an object called a
property descriptor and depending on
whether you're accessing an data
property or an accessor property this
property scripture will have a different
API so for example in the case of data
properties you see that it has a slot
called value that says that the slot is
bound to value 5 and it has a number of
what we call attributes like writable
and numerable and configurable writable
determines whether we can assign to its
innumerable determines whether it shows
up in foreign loops and configurable
determines whether you can delete a
property or whether you can change these
attributes and so if you ask the same
information for a property bound to an
accessor property it instead has a kept
an a set slot that contains the actual
accessors Decatur's and the settlers
okay so you can carry the system for
this information
there is also an object defined property
which allows you to either add new
properties with custom attributes or to
redefine some of the attributes of
existing properties there are lots of
other methods I won't describe them all
your interesting method is object dot
create so it's a function that given a
an object that will act as a prototype
and this strange record here will create
a new object and this this is a record
it's called a property descriptor map
that's how I call it it's so it's an
object whose keys represents the keys of
the object you are about to define but
whose values are not directly the values
rather they describe the property
descriptors associated with those values
okay so this is a property descriptor
map it allows you to
new objects sort of at the meta level
you can specify more information about
your object than you can normally can
with JavaScript literals okay one final
addition to execute five which I like to
discuss before I discuss proxies is the
addition of ways to create tamper-proof
objects so in JavaScript there are now
these three methods called object or
present extensions object on Sealand
object op freeze and for example if you
call object op present extensions on an
object afterwards you cannot add new
properties to that object if you seal it
you can't delete properties if you
freeze it you can additionally not
assign properties so a frozen object
really is frozen you can't add stuff to
it but clients can't access to it
clients can delete stuff from it clients
can't assign properties okay so I'm
going to need these these functions
later when I discuss proxies so proxies
are a new addition that we are proposing
for echo script harmony that's the
codename for the next edition of the
equipt language and so they complement
the existing metaprogramming API by
allowing JavaScript programmers to
define generic handling of property
access and this allows basically will
allow JavaScript programmers to write
generic wrappers generic wrappers useful
for enforcing access control for tracing
gathering profiling information and so
on and so on so for those of you
familiar with SpiderMonkey which is the
engine that's running Firefox it has
this non-standard method called no such
method well so this with this feature
you can do all the stuff you can do with
no such method method in a standardized
way and in a more stratified way I will
explain later
what I mean by that so the other thing
is that these dynamic proxies as I will
soon describe don't only allow you to
generically handle property access they
will also allow you to generically
handle handle other operations which
basically allows JavaScript programmers
to create fully Verte
realized objects so that would mean
objects that don't really exist as
objects in the system like for example
persistent objects which are stored on
disk or for example remote objects which
live inside of another address space and
you can create local proxies for them
furthermore it allows them to emulate
the peculiar behavior of certain what's
called host objects so host objects are
JavaScript objects that have differing
semantics because they're actually
implemented in as native object has
built-in kind of built in object so
first of all I'd like to point out that
with the new metaprogramming API I just
introduced it's already possible today
in echo script 5 to implement what I
would call static proxies so for example
if you want to create a trace or
abstraction that will simply trace all
property accesses of a given target
object then what you can do is you can
actually go ahead and create an object
that will have all of the same
properties as this object so I'm not
going to go into the details here the
important thing is that for each
property in the original object I'm
defining a new property with the same
name and I'm going to define all
properties as accessors where I include
some tracing information and then go
ahead and delegate the call to the
original object so of course this
tracing information it's very simple
here you can imagine how this could
generalize to profile collecting
profiling information and and and so on
so the problem with creating proxies in
this way is that they don't reflect
structural changes made to the original
object or vice versa that means if you
add new properties to the existing
object you're wrapping or add new
properties to the proxy or delete
properties these changes won't be
reflected after the proxy has been
created that's why I call it a static
proxy it's not really connected to the
object it's proxying okay so what
dynamic proxies will allow you to do is
to create proxies that are can be made
to reflect these structural changes on
the object they're wrapping so here
we're creating tracer object we're going
to trace all property access of of this
object here and so we're proposing the
addition of a new built-in called proxy
it has this method called create and
when you invoke proxy dot create it
returns a proxy whose behavior will be
controlled by this object here and this
object is called a handler object it
defines a number of methods that will be
invoked whenever property access is
performed and so this allows you to
intercept property access and property
assignment perform the tracing behavior
and then delegate the property access to
the original object okay so I'm going to
have to introduce some terminology here
from the reflection community so what
we're dealing with here is these proxy
objects they are what I would what's
called base level objects they they are
regular javascript objects they so the
application will directly communicate
with these objects here now this handler
object that controls the behavior of
this proxy is what's called a meta level
object its sole purpose is to describe
the behavior of another javascript
object okay and so proxy and handler are
implicitly connected by the call to
proxy don't create now so this proxy
does create call you give it a handler
and a prototype that and this prototype
arguments this is an object that will
serve as the prototype of your proxy now
so whenever the in in the system in the
in the JavaScript runtime some objects
access a property of this proxy objects
a property foo this will get verified or
represented at the meta level as a call
to the handlers get method and we call
these methods methods like a get we call
them traps by analogy with operating
systems you're sort of trapping the
property access and representing it at
the meta level and so you see that the
get trap here takes as argument the
proxy on which the info
was performed and the name of the
property being accessed now so likewise
for for property assignment
whenever the code executes the property
assignment where the receiver is a proxy
this will get ratified at the meta level
as a call to the handlers set trap which
takes all of the necessary arguments
okay
so method invocations in JavaScript are
not really special here if when you
perform an invocation in JavaScript
what's actually going on is you're
retrieving the property with the name
foo and then the system exit expects it
to be a function and we'll apply the
function we'll call it passing the proxy
as the receiver and the arguments so
from the point of view of the of the
meta level here there's nothing special
it will just trigger the handlers yet
trap okay now the title of the slide is
stratified API so what does this mean it
means that so the proxy and the handler
are cleanly separated and these methods
names like get and set have no
particular meaning for the base level
application so let me illustrate this by
means of an example if for some reason
your application defines properties
called get and set which is a perfectly
viable thing to do and you so someone
accesses the get property of a proxy
notice what will what will happen is
that the get trap of the handler is
invoked because we're doing a property
access but now the property name that's
being accessed is just called gates so
there is nothing special about the name
get at base level so that's an important
part of stratification so the namespace
of these special names are defined on
the handler which is completely separate
from the proxy now another reason why we
could call this API at stratified is
that the prototype property of this
handler is completely distinct from the
prototype property of the proxy so this
this proto property here is being
defined when you create a proxy and that
will specify what the prototype is of
proxy object the handler can have a
completely separate prototype and these
two don't interfere with our completely
distinct okay so I've talked about
intercepting property access priority
assignment that this API actually ray
Phi's a lot more than just that for
example if the based of all code
executes SAN in operation asking whether
a certain name is in a certain proxy
this will trigger the handlers hash trap
and it passes the the property name and
the hash trap is expected to return a
boolean that will then be used at the
base level likewise if you try to delete
properties from proxies this actually
gets trapped at a meta level the handler
can provide a sensible semantics for
property deletion more interestingly if
you perform a foreign loop over a proxy
the proxy is allowed to specify what
it's enumerable properties are so what
will happen is that the enumerate trap
of the handler is called and this
enumerate trap is expected to return the
array of property names that are the
innumerable properties of the proxy and
from that point on from the programmers
point of view what will happen is that
the implementation will perform a for
playing for loop over this return value
and will access the different properties
and perform the for in loop body on
those properties so so proxies can even
intercept foreign loops likewise this
new meta level API that I just described
is also properly intercepted so if
objects are trying to add new properties
to proxies using for example the define
property method this again will be
trapped it will be verified as a call to
the handlers defined property trap and
the handler can then define what it
means to define properties so proxies
can trap quite a lot of operations
defined on objects but they can't drop
everything and there's good reasons for
that there are certain operations which
you don't want to depend on user level
code for example
proxy's have their own distinct object
identity and if you compare them using
triple equals to any other object then
well this this check is performed these
operations performed entirely by the
engine the handler has nothing to say in
this regard that's because we want to
make sure that triple equals maintains
all of the properties that programmers
expect it to have like reflectivity
transitivity monotonicity in the sense
that if two objects ever compared triple
equals then you expect that relationship
to hold throughout the entire lifetime
of the program okay
so likewise notice that because we pass
this we we force the meta-level
programmer to specify the prototype of a
proxy at creation time this allows the
system to answer the get prototype of
query which returns the prototype of an
object without asking the handler for
the prototype again there is nothing in
current construct standards that allows
objects to have a mutable prototype link
and so we didn't want to allow this meta
API to break that invariant so handlers
cannot break that invariant so because
this prototype link is fixed if
programmers use instance of this will
not be this the outcome of this test
will not be affected by the handler if
the left hand side is a proxy and
finally if you perform a type of
operation on a proxy this again will not
allow the handler to determine what type
of a proxy is it will simply return
object so clearly there is a distinction
between some operations which we allow
handlers to implement and some
operations which we don't for purposes
of maintaining internal consistency so
if you're interested in what the full
API looks like this is it it's about
twelve different traps that are defined
on the handler each corresponding to a
different base level operation so this
appears to be quite complex but I mean
as Albert Einstein concept everything
should be made as simple as possible but
not simpler so javascript is a con
phlex language and trust me this is sort
of like the minimal amount of traps you
need to be able to faithfully emulate
the behavior of a JavaScript object so
clearly if the language is complex it
will show in the metaprogramming API so
having introduced this concept of
proxies we can now have a look at
regular objects in a different from a
different point of view which is that so
in the current JavaScript systems we
have a base level which is JavaScript
Territory that's where your JavaScript
objects live that's where you can really
define your own objects the meta level
is currently completely dominated by the
that's VM Territory the JavaScript
programmer has no access to it and it's
usually implemented in something like
C++ so what you can see so normal
objects which are not proxies can
actually be thought of as proxies whose
handler is specified by the virtual
machine
so which handler is sort of fixed by the
virtual machine and implements the
default JavaScript semantics and that's
an interesting model because already
there are some deviations on it which
are what's currently known as host
objects so there are certain objects
which are also currently whose semantics
is currently implemented in C++ in the
virtual machine but which deviates
slightly from the built-in JavaScript
semantics ok so what proxies enable
JavaScript programmers to do is they
they enable JavaScript programmers to
invade this meta-level world and define
new semantics for exists for JavaScript
objects ok so you are really giving a
lot of power here to JavaScript
programmers and this is quite important
as Brendan Eich recently said on on the
es discuss mailing list this basically
allows JavaScript programmers to
experiment with useful new semantics of
the language without either the VM
implementers or the standardization
committee having to be a bottleneck for
innovation so it really is a game
changer and but while I have this figure
up here I would like to stress
that okay sorry so what it allows you to
do furthermore is that proxies can sort
of be used to create the behavior to
recreate the behavior of host objects
entirely within JavaScript allowing
these objects to be sort of self hosted
so they no longer depend on VM internals
but so I'd like to stress though that if
the API doesn't allow you to redefine
the semantics of existing JavaScript
objects okay so these links are sort of
hardwired and adding proxies to the
language doesn't allow JavaScript
programmers to redefine the semantics of
existing objects only of new proxy
objects that's very important for two
reasons first is security it's not
because you have a reference to some
object that you should be allowed to
install a new handler on that object and
completely take over control of that
object okay second reason is performance
so of course the the semantics of these
objects is heavily optimized in virtual
machines and we don't want our
metaprogramming API to interfere there
so the metaprogramming API should only
have an overhead on these proxy objects
so it only costs when you actually use
it okay so most JavaScript programmers
will not actually be interested in
redefining the semantics of the complete
semantics of a JavaScript object they
will rather want to make small changes
to the existing behavior of JavaScript
objects and to that end the one of the
most useful handlers that you can define
it's sort of like a handler with job it
is to simply forward all operations
performed on its proxy to a certain
target object so this this forwarding
handler here takes an object that you
want to wrap stores it in a target
property and then goes ahead and
implements the entire API of the entire
handler API by simply forwarding the the
trapped operation to the target object
The Situation's is like this proxy traps
all operations Raiffeisen on handler
handle dispatches them onto a target so
this allows you to implement small
deviations of the existing semantics so
here's a simple very simple example a
profiler that simply constructs like a
histogram of all it simply counts the
number of times certain properties have
been invoked and so if you want to
create a simple profiler wrapping a
certain target we start off by
implementing a forwarding handler which
encapsulates sort of the default
semantics of the language and now we're
just going to override its get trap such
that it's it performs the count access
and then delegates the call to the the
wrapped object okay and so this this
abstraction here it returns a proxy
which wraps the target object and then a
method that allows it to allows clients
to retrieve the statistics so if you
have a certain subject that you want to
monitor you just make a simple profiler
for its run your application with the
proxy and when your application has run
you can sort of read out the statistics
from this profiler okay so this shows
that you don't have to always implement
this full handler API if you want to
make good use of this metaprogramming
API just have to define the Delta with
respect to the default semantics so up
to this point I've not talked about
functions at all so in JavaScript
functions are objects but not quite
JavaScript functions are objects but
additionally you can also call them and
you can also construct them so they have
some capabilities that normal objects
don't have and if you want to verify
these at the meta level really the best
way we could come up with is to actually
distinguish between object proxies and
function proxies so if you want to
create a proxy for a function what you
do is you don't call proxy dot create
you call proxy don't create function and
so this returns a function proxy whose
behavior is again determined by a
handler
and this handler is completely identical
in API to the handler you pass to proxy
dot create so it completely handles all
of the duties of a function as an object
but additionally you can call and you
can construct functions and that's why
this create function method also has a
call and a construct trap these are
functions that will be called when the
function property is called or
constructed for example if we call this
function proxy what's actually going to
occur at the meta level is we're going
to call this function instead okay
likewise if if code constructs the
function by prefixing the new keyword
this will trigger the construct trap
instead and this is actually very
interesting because for this would for
the first time allow JavaScript
programmers to faithfully distinguish
between calling and constructing so
there are certain various ways in which
you can try to figure out whether your
function was called with the new keyword
or not but they're not foolproof so this
is a foolproof method to allow you to
distinguish between calling and
constructing so again functions are
objects you can store properties in them
and access them etc and all of these
accesses will simply be ratified as
traps on the handler entirely analogous
to object proxies and like with object
proxies there are certain aspects of
functions which we choose not to
intercept for example if you ask what
the type of a function properties it
will always return function it won't
consult a handler for that so we want to
uphold this constraint that the type of
a function is simply function and
likewise notice that proxy don't create
function unlike proxy dot create doesn't
take a prototype as a second argument
why is that well the system enforces
that for function proxies if you query
it for the prototype it will simply
return function
since that's what functions are supposed
to delegate you okay so I've talked
about these for various operations that
allow you to create the tamper-proof
objects in the script five like object
dot freeze object dot seal and object of
prevent extensions and so the problem
here is that if we have proxies and we
are not enforcing these these
constraints then programmers can be very
surprised for example if you freeze an
object as a programmer you know that at
that point no more properties will be
added to the object but if the proxy is
a if the object is a proxy with a
handler the handler can decide whatever
it wants so we have to somehow restrict
the power of the handler so what will
happen is if you call any of these three
operations on a proxy this will trigger
the handlers fix trap and this fixed
trap either
returns a property descriptor map or
undefined if it returns undefined that
means that the handler isn't willing to
fix the proxy and at that point the
system will throw a diaper informing the
programmer that this operation is not
allowed if it does return a valid
property descriptor map then the system
will use the property descriptor map to
actually go ahead and create a new
object it will then perform the
corresponding operation on that object
so if you froze the object it will
freeze it or otherwise seal it or make
it non extensible and then as a final
step the proxy will become this new
object okay so of course become is an
operation you cannot implement in
JavaScript itself but VM implementers do
have quite easy ways to accomplish this
so really you should you should think of
proxies as being in two possible States
a proxy is born in what's called a what
we call a trapping state in which it
sort of intercepts all all of these
operations and and passes them through
to its handler but from the point from
the moment it's fixed in turned into a
turbine
fixed state and at that point it no
longer needs its handler it will never
again invoke it and for all intents and
purposes this is now a regular object
and because it is a regular object we
can enforce the tamper proof nosov
freeze seal and present extensions so
I've presented this proposal at the
Achmat visitors 9 meetings this proposal
is now an official proposal for across
script harmony you can find the detailed
semantics of it at the given URL and
there exists a prototype implementation
so Andres call from Mozilla has actually
implemented an extension of trace monkey
that supports this and this has allowed
me to write to write a couple of micro
benchmarks so here I've measured the
time it takes to perform an operation on
an object versus the time it takes to
perform the same operation on a proxy
that simply performs this default
forwarding behavior so there's no proxy
that's simply delegates the same
operation to the wrap object so it's
interesting to see that type of triple
equals get prototype of etc these incur
no overhead that's logical because they
are they are independent of whether an
object is a proxy or not most of the
other traps incur an overhead of between
1.2 and 1.8 which is what you would
expect because they have to perform the
original operation anyway and you also
pay for the overhead of a an extra
method invocation on this Handler object
so innumerate is somewhat off that's
because the API is currently very
awkward because the the handler has to
construct an array of strings has to
pass this to the implementation and then
the implementation has to perform a loop
over that so the goal here is that if
echo script harmony has a good proposal
for generators or iterators we will
adapt our API to make it fit with this
new proposal which will probably speed
up this the cost will bring down the
cost of this
a trap so to summarize proxies dynamic
proxies there are really two main use
cases here first of all it allows
JavaScript programmers to write generic
wrappers for for example access control
profiling writing adaptors for existing
libraries etc furthermore because we
allow so many operations to be
intercepted you can actually go ahead
and really create virtual objects so
objects that represent persistent
objects objects that represent remote
objects you can emulate the behavior of
certain host objects so these are all
very useful things so with respect to
the metaprogramming API as I've
presented it here I would call it robust
because it's stratified so this the
namespace of this handler is completely
separated from the namespace of the
objects that you're intercepting and
furthermore we don't blindly allow all
operations to be intercepted so certain
operations like typeof and triple equals
are not intercepted it's secure in the
sense that you can't take over existing
objects you can't redefine the behavior
of existing objects and furthermore the
properties of tamper-proof objects are
maintained so proxies can circumvent
those and as far as performance goes
really the important thing here is that
there is no overhead for non proxy
objects so you only pay for for the
overhead when you really need the
metaprogramming API so how am i doing on
time yeah I think we can continue to the
sort of the second topic of this talk so
and now for something completely
different
I'd say traits so what are traits traits
are a way to do object composition you
can think of them as an alternative to
mix-ins or multiple inheritance really
and so essentially if a trait provides a
set of methods and requires a set of
methods
in order to implement those and really
the composition of different traits I
would call it robust because name
clashes that occur when two traits
define properties of the same name lead
to explicit conflicts so contrary to
mix-ins or multiple inheritance where
one of either one of the methods will be
preferred depending on the order of the
composition with traits you will always
get a name plash no matter what your
ordering is and the name clash must be
explicitly resolved before you can
actually use the trade furthermore the
composition of traits is a commutative
and associative operation what this
boils down to is that the order of your
composition is irrelevant it's
irrelevant
first more declarative it's easier to
reason about larger compositions as a
programmer so traits were first
implemented email and squeeks maldark
circa 2003 and have in their short a
lifetime received quite some adoption in
other programming languages for example
have been included in Perl 6
PLT scheme uses and them extensively in
its libraries guy steals new fortress
language has picked up on them etc so
here at Google together with Mark I
define this library we call trades DOJ's
which allows you to perform trade
composition in JavaScript and we were
motivated by two reasons first of all of
course trade composition is more robust
than the existing composition mechanisms
that JavaScript offers which is
prototypal inheritance and mixing
patterns where you simply copy all of
the properties of one object and add
them to another object so it's more
robust in that way and another important
motivation was that even though echo
script 5 allows you to define
tamper-proof objects with this object or
freeze call it's still fairly wordy so
it's it's fairly inconvenient to create
your own tamper-proof objects so it
trades in threads GS instances of traits
will by default be tamper-proof objects
so it's also an easy way of creating
tamper proof
in scripts five so the library is based
on this property descriptor API that
I've introduced the beginning of this
talk and but we define a small backwards
compatibility layer such that it will
also run gracefully on existing echo
script engines except that of course
straight instances in an e s3 system
will not be tamper proof if the library
works both in the browser and standalone
at server-side for example so the API of
this libraries the core API is fairly
minimal if you include the trace library
you there are basically four things you
can do you can construct new traits
compose existing traits resolve
conflicts four traits and instantiate
traits into objects so constructing
traits you do that by calling this trait
constructor capital T it takes as its
sole argument a record describing the
provided and the required properties of
the trade so provided properties are
just normal properties if you want to
express a required property what you do
is you define a data property bound to
trade not required so a trade node
required is kind of like a single tone
value like null or undefined which is
exported by the trades library so trade
composition is performed by the trade
dot composed operation it takes a
variable number of trades and returns a
composite trade so again the ordering of
trades here is completely irrelevant
trade resolution allows you to deal with
conflicts it allows you to avoid
conflicts by renaming properties so for
example you can rename property in this
trade the property a we renamed it to C
and you can if you rename something to
undefined this basically means you you
don't want it anymore you exclude the
property from and then finally if you
want to instantiate trades just like
there is this object of create methods
in es5 we define trade to create which
has a similar signature it takes a
prototype which will be the prototype of
the trade instance and a trade to
instantiate and in this case
is the object being returned here is a
is a frozen is a tamper-proof object so
let me give a brief example of what you
would use trades for so here is a trade
that captures the reusable behavior of
innumerable 'ti so an innumerable trade
defines properties like map filter and
reduce higher-order operations if only
the composer wants to give it a for each
method that will enumerate the sequence
and so based on these for this for each
method so it can access it using
substance it can provide these
higher-order operations
okay so I'm not going to go into the
details here if you want to use this
innumerable trade for example say you
want to create an innumerable interval
you do this as follows so here's a
function called make interval you give
it a minimum and a maximum it constructs
for you
an interval bound an open interval with
minimum inclusive maximum exclusive and
so the instance will be a trade instance
it will delegate to object or prototype
and so the trade being instantiated is a
composition of the innumerable trade
which defines this reusable behavior and
a sort of anonymous inline trade that
defines the semantics of intervals in
this case it defines like a start and an
end property it's method to check
whether element lies within the interval
and then it defines this required for
each method simply by viewing the
interval as yours starting from minimum
up to the maximum okay so when you
construct the interval by calling to
make interval function you can then go
ahead and invoke operations like
MapReduce and filter so they it's as if
they are defined directly on the
instance so this our trace library
actually represents straights as
property descriptor maps so when you
create a trade using the trade
constructor it will
transform this record that you give it
into a property descriptor map recall a
property descriptor map is an object
whose keys represent the keys of some
other object and which values are bound
to property descriptors that describe
all of the attributes of a given
property and notice also that we add
additional metadata as in the form of
attributes to some of these properties
so required properties for example have
this required like and the data property
is bound to functions will be tagged as
methods I will explain later why that is
the case so but it's fairly important to
to notice that so we just represent
traits as this standard property
descriptor map format that was defined
in es5 so if you go ahead and compose
for example these two traits t1 and t2
then you'll see that they both define a
B property so when you compose them this
B property will be replaced by something
we call a conflicting property and if
you would then try to create an instance
of that trait you will get an exception
saying that there's a certain conflict
which you need to address if you want to
resolve that conflict what you do what
you could do in this case for exists for
example to prioritize tyonne's B
property over t2 s B property and you
can do that by using the trade dot
resolve call you can create a new trade
whose be property is actually redefined
to a required property so it sort of
excluded from the trade composition and
then later when you compose this
resolved trade with t1 now we are
composing a required property B and a
provided property B and we will simply
so define B to refer to T once properly
so if you done create an instance of
this trade you will get a valid trade
instance so final operation trade
instantiation
so that's done using this trade create
Karl and you give it a prototype and a
property descriptor map that represents
the trade and really what's going on
here is very similar to calling object
dot create except that in addition to
what object would create this trade
would create will also throw an
exception if it encounters any remaining
conflicting or required properties in
this trade furthermore it will bind the
dis binding of all property status
methods to the new trade instance so
this is to ensure that the object is
tamper proof in the sense that clients
are not able to trick the trade into
rebinding it's this value or this could
also happen by accident if clients would
extract a method from a trade use it as
a phone arc in which case it would be
bound to two undefined or the global
object so to prevent that we explicitly
bind this upon instantiation and
furthermore we freeze the resulting
object and we freeze its methods so this
make sure we get tamper-proof objects
without the programmer having to write
all of these tedious object or create
object of three scales okay so there is
one open issue here the because we bind
the dis binding of methods when we
create trade instances that means that
if you create multiple instances from
the same trade they won't be able to
directly share the same method instance
rather they will each have their own
bound method instance and so that really
is a quite it's an overhead in terms of
space which is really very tricky to
deal with as a library author without
support from from the runtime
so to summarize trades GS is a very
minimal trade composition library for
JavaScript which represents traits as
property descriptor maps and the
interesting thing here is that you can
you can use you can actually pass traits
to the object that create built in es5
function and that will simply generate a
new object instance which is not tamper
proof and which will also ignore simply
ignore the trade metadata now if you
pass the trade to trade not create you
will generate a new trait instance which
is a tamper proof object and of course
there is still this open issue that I've
just described you so if you're
interested in in this library you want
to play around with it or look into it
in more detail so the URL is dub dub dub
the trades Jess dot org so I'm about to
conclude my talk here just to summarize
the different things I've talked to you
about today so first of all with the
addition of es5 strict mode you can
really think of well that subset of
JavaScript this is a very robust
programming language it really is very
robust it really made sure that
programmers don't fall into like there
will no no it falls for the unwary now
proxies are a new meta programming API
for es harmony and I would characterize
it as a robust metaprogramming API it's
stratified and we've put a lot of
thought into what operations should be
intercepted what operations should not
be intercepted so then I've talked about
this new traits library that already
works in es5 which really is a robust
composition API robust in the sense that
name clashes have to be explicitly
resolved and the trait composition is a
declarative because ordering doesn't
matter and so as Mark discussed in the
introduction this is sort of the second
in a series of talks
changes to to acting script so hopefully
mark or Tyler will in one of the coming
talks talk about new abstractions that
were devising for robust event-driven
programming in echo scripts so following
with the robustness theme here so if
you're interested in any of the things
that I've discussed about that they've
discussed here today we've set up a
little google code project called es -
lab so if you go to the following URL
you can find further information so that
concludes my dark and I would be very
happy to answer all of your questions hi
Brad Neuberg it's great to see the meta
programming come to JavaScript it's
gonna help a lot of frameworks maybe
this is a larger question but one of the
issues with javascript is really
programming in the large both from a
Productivity standpoint and from
deploying so much script what primitives
do you see in es5 to help with that with
programming in the large I can't really
think of any relatives that are directly
supported one of the more relevant
topics here is modules so currently in
echo script harmony there is a big
discussion going on on various proposals
for module systems that would allow you
to define modules with explicit imports
and exports which I think would would be
a big help for programming in the large
but yeah that's not available in es5 and
that's not something that that I flipped
into we have as an answer to your
question we have other plenty of other
things on the table for es5 modules and
classes and some kind of rudimentary API
enforcement's are four years harmony
right it'd be nice to see those because
es4 had some of those but maybe it was
too java centric and sometimes
you have to be a bit of a JavaScript
wizard to do programming the large and
that's causing some folks to go towards
abstractions like Google web toolkit and
be nice to be able to kind of help go in
the other direction against that so I
agree well the question was yeah go
ahead okay I think that you have to be
when you get to I think javascript is an
amazing programming in the small and
medium language in a way that I think
other languages aren't then you can get
started quicker
I think jQuery shown that but for
programming the large when you're
getting into a really substantial code
base something like Gmail or really sort
of biting off a big app I think you have
to be too much of a wizard knowing the
specifics of the language to kind of get
day in and day out work done for example
you just have to have a deep
understanding that it's a prototype
based language that everything is
actually a function understanding
closures and that makes it hard I think
for large distributed teams to pick up
and also have good encapsulation between
different parts of the system mm-hm and
it requires I think a great deal of sort
of programmer good habits and it'd be
nice you know I would think I love
seeing about the traits and and and the
proxies is it's it's it's a JavaScript
approach to these things so it would be
nice to find the JavaScript answer to
being able to have I don't when I see
more junior programmers I don't mean
that in a negative way but not having to
be a wizard of the language to build
systems and I think that's one of the
problems with JavaScript and that's just
a Productivity level in terms of
deployment page load latency is so
important you want to glom everything
together and so you need lots of build
time tools but I think when you get to a
certain scale really hits your
productivity and it'd be nice to have
more support that maybe slightly outside
of JavaScript but it'd be nice to take
the larger picture like html5 is done
they've said okay let's look at the API
is not just markup so maybe widening
that scope
any more questions i Jimmy Lane I was
just curious so for the trade stuff do
you see something like that going
directly into the language or does it
even need to be census since to me
JavaScript library so we had we've had
some discussion about that I think well
as they stand they don't really need a
lot of support from well the language I
think the problem is that having
tamper-proof objects be able to
efficiently share methods is a big issue
which we currently don't know how to
solve at the library level so that would
definitely help I also know that well I
think if something like this would
actually make it into the language it
would probably have its own syntax so
better support with its own dedicated
syntax which will also enable the
JavaScript engines to much more heavily
optimize them because currently such
assistance in this library the sort of
the implementation has to infer that
you're actually using trait composition
it's not native to the language so but
yeah I mean there we were actually
surprised at how usable traits could be
without dedicated syntax because of Java
scripts excellent object literal
notation syntax so it is it's fairly
doable
any more questions
okay so thank you all for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>