<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Google Faculty Summit 2009: Frontiers in Systems Research | Coder Coacher - Coaching Coders</title><meta content="Google Faculty Summit 2009: Frontiers in Systems Research - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Google Faculty Summit 2009: Frontiers in Systems Research</b></h2><h5 class="post__date">2009-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zgng4C18nNk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Brad Chen is in here about a year and
three years now okay and had previously
she time flies I guess I wasn't here
when you join so Brad had most recently
been at Intel a director they're doing
work in performance technologies and the
like and performance management and
measurement technologies was a professor
at Harvard a prior to that did his PhD
at CMU and undergraduate degrees and
master's at Stanford right so bread take
it away thank you all okay this morning
I'd like to tell you a little about a
different area than may be used to
hearing at Google I spent the first
couple of years at Google working on
system infrastructure looking at data
center systems and studying performance
and when I looked at those systems
sometimes I felt that like I was looking
at something kind of like this Wow huge
massive incredibly solid you know maybe
I could find some polishing to do but a
lot of the time was really hard to
figure out how to really you know change
the world about a year ago actually made
a change to work on the desktop systems
I'm talking about you know in the in the
general area of the chrome web browser
so this is still in the engineering
group but and what I feel like when I
look at the state of the art and the
desktop there's something more kind of
like this now this metaphor is a little
bit exaggerated but I am trying to make
a point let me let me tell you a little
bit more substance of what behind what
I'm seeing here for example privacy the
desktop systems we work with today
sometimes seem to have paper-thin walls
sometimes the walls are actually
non-existent and for many users it's
incredibly difficult to figure out what
happens with their data and who they're
actually sharing with safety your system
was probably vulnerable the day you
started using it and and the defense is
that we create are not keeping pace with
the threats that are emerging hygiene
the systems we work with are so complex
the api's are so intricate that they're
practically impossible to clean and as a
consequence of all of this I don't think
we deliberately built systems that that
were you know had these kinds
problems but the fact is that they were
created in a different time and times
have changed and so as a consequence
ownership of personal computers is
commonly violated by things like box and
spam and viruses and theft of
information is also very common these
are huge problems that they don't really
feel like we've dealt with and and
that's sort of what I want to want to
think about as we move into some of the
some of the work that we've actually
been working on in the client area so
the next thing I want to tell you a
little bit about is at more of a
technical level what has changed in
desktop systems that actually you know I
think there's some really substantial
changes that as a community we haven't
actually done a very good job of
recognizing then I'm going to tell you a
fair amount of detail about my project
which is called Native Client and then
set that in the context of some of the
other Google client area projects to
sort of give you a shape for the whole
and how we think about these problems
then I want to close briefly with a sort
of a research agenda some of the
problems that I see as being the most
best opportunities are most urgent in
terms of ways to help with this so let's
talk a little bit about desktop systems
and what's changed now I think all of us
almost almost all of us are old enough
to remember multics and the wonderful
idea they had of four rings of security
really really interesting idea the
problem was nobody could figure out to
do with all those what to do with all
those rings right and so by the time we
got to the 70s things look kind of more
like this unix and pdp-11 introduced a
much simpler security architecture that
just had kernel mode and user mode and
practically everybody knew what to do
almost everybody and and this kind of
this kind of system was reinforced by
wrist microarchitecture in the 90 so I
thought we were done I was in college
backed I thought yeah this seems about
right let's you know get on with it but
then around 2000 a company called VMware
resurrected the idea of the virtual
machine which obviously had had a lot of
traction earlier as well companies like
IBM and and okay fine whatever you know
we'll live with that at the same time
that this was happening though something
even more disruptive was happening and
that was the web now originally I'm sure
we all remember the web was just a bunch
of static web pages HTML you know you
edit it with emacs VI and you were done
course then web two point O happened and
so
effectively instead of the program's you
wanted to execute being installed on
your hard drive now the program's you
want to execute are coming from any
place in the world and here we are back
to four rings is that amazing I think
that's really great but recognize that
the programs in this outer ring are
totally different than what you've been
thinking about in most of our careers
this code could be from anywhere you
don't know who wrote it you don't know
where it's been before it got to your
desktop it could be infested with all
the worst possible things you could
imagine of course you know we all try to
avoid those kinds of problems but my
point is that people expect to be able
to switch to these programs with the
with the same kind of a band and they
change the channel on their television
set and yet there's some very dangerous
systems out things out there and
obviously our systems are not designed
to deal with these kind of problems so
this I see is kind of an opportunity I
think there's there's some progress
that's been made in some places but
there's a lot of places where we really
haven't fully embraced and dealt with
the problems presented by untrusted code
and this is one of the major changes I
wanted to highlight next I want to talk
a little bit about you know on a single
machine thinking about the structure of
the actual operating system itself back
in the 90s people were pretty
comfortable with a picture that can
maybe look kind of something like this
you got an operating system kernel which
is really doing all the hard work it's
got the hardware extraction abstraction
layer so you don't have to deal with
devices directly it's got resource
management you know like a file system
and protection for files and and
accounts that you can log into and then
an application environment that gives
applications to sort of stable place
from which to you know build from in
terms of libraries and all of that sort
of thing so this was an incredibly
useful model and actually I think it's
still pretty much the right model if
you're looking at the data center but
when you look at desktops I just don't
think this model works anymore the kind
of thing I see on desktops nowadays look
some are a lot more like this so yes we
still have an operating system kernel
and yes people still do not want to
write their own device drivers at least
most people don't want to write thrown
device drivers but the resources
actually aren't really on your system
anymore think of your I think in my
system these days is becoming a kind of
disposable thing like a cell phone you
don't really want state on your system
you want it in the cloud that's
direction that things are going and when
resources are in the cloud you can't
really build the application environment
into the operating system anymore it's
got to be up someplace high you're
floating around in the cloud someplace
and and so that's a part of why there's
a lot of effort at Google going into
open web platforms in html5 to establish
a better a stronger open standard as far
as application environments go so this
is a really huge change in terms of how
desktop systems are used and the system
infrastructure required to support those
and again I don't really feel like we've
we've recognized or addressed all the
problems involved in this really
significant change so those are the two
problems I wanted to highlight next
we're going to talk a little bit about
Native Client and I'm just going to
point out that it's a part of the
application environment okay native
client is a project that I manage here
at Google and we're going to we're going
to go into some detail now the idea
behind Native Client is to be able to
run native code as a part of a web-based
application now some of you might be
sitting there saying native code so
what's the big deal I mean Microsoft the
Netscape did that 15 years ago with
activex and NPAPI well this audience I
probably don't need to advise you know
you probably shouldn't just run any
activex control that you happen to see
or any NPAPI plug-in that comes down
some of them can be very dangerous and
the reason is that the NPAPI and activex
controls they do more than just give you
access to execute native code they don't
give you just access to the native CPU
they also give you direct access to the
native operating system and therein lies
the problems because through the
operating system you can have side
effects like creating files or modifying
files on your disk like creating network
connections to random places you never
heard of and sending them spam and and
it's that direct access to the operating
system that's actually the source of
virtually all the problems that we see
with with native code today so the idea
with Native Client is actually give you
full and direct access to the CPU but no
access to the native operating system
and that will allow us we hope to
provide native code speed with the same
level of safety that people expect from
JavaScript and other kinds of web
technologies
take for granted so the way we pitch
this is close the gap between the
desktop and web applications and that's
really a high-level goal of all of our
efforts in the client area and a part of
that gap the Native Client address is is
performance we really want to be within
you know within small percentages of the
best you can do on with with a native
desktop application a choice of
programming language is also very
important i always get frustrated with
these systems that seemed to assert you
will only use such and such language i
think that's just silly i mean there's
lots of languages and there's a reason
for that they all have their all useful
for different things related to that is
leveraging legacy code there's millions
and millions of lines of open source c
and c++ for example that is very high
quality code but you can't really use in
the web browser because you're kind of
stuck with javascript so we want to we
want to solve all these problems but at
the same time not sacrifice portability
the web is portable right you expect
HTML to work anywhere and that's
critically important that's you know an
absolutely essential part of the web as
we see it and also safety the obvious
problem we've been dealing with all
along so well that's why native code now
I wanted to give you a little bit more
detail by what i mean by performance and
some of the key performance features the
system include firstly POSIX like thread
support if you look at where computer
architecture going is going you're not
really going to get much more
performance through serial computation
it's all going to be through parallelism
and threads seems like you know the most
direct abstraction for providing that
and this by the way is one of the key
distinctions between the performance you
can get from Native Client and a system
like JavaScript because the browser is
very single threaded another performance
feature is straightforward access to
vector instructions I kind of see
multi-core as one order of magnitude of
performance looking forward and vector
instructions is another important as
another order of magnitude for code that
actually does any sort of numerical or
compute intensive work vectorization is
is because of the boxed data types on
JavaScript and also in Java by the way
they're really can't get any benefit
from vector instructions and lastly hand
coded assembler now it's not it's not
really that easy
right hand coded assembler but for the
people who are ready to do it we intend
to not make it any more difficult than
it already is and this is actually very
important the people who are working at
the frontiers of performance people
doing things like video decoding
real-time animation high performance or
you know sort of the latest game
technology they they caver care very
much about this sort of thing so in
summary we want to deliver substantially
all the performance all the CPU
performance of a desktop application but
make it in the browser as safe as
JavaScript so that's sort of the
high-level what is he doing in this
project now let's talk a little bit in
about the architecture of the system and
I'm going to explain that by running
through an example hypothetical web
application that uses Native Client for
some physical simulation so maybe we're
implementing a game and and someplace
inside the source of the game it's going
to say I want to use a Native Client
module it'll do that by either using an
object or an embed tag you know in in
the HTML content and this is the same
way that flash or activex controls
commonly get activated as well so when
the browser sees this it looks the mime
type of the file in question and and and
in this case native client has been
installed in the browser and so will
activate a container that is there to
support the Native Client module that
can at the same time that it does that
the browser is actually also going to
fetch the file that contains the the
content in question now our physical
simulation we're going to assume is safe
but for a moment let's assume that oops
you went to an evil website and and
somebody was actually trying to play a
trick on you and compromise your machine
okay the first thing that native client
is going to do before it actually allows
you to run this thing is run it through
a static analyzer it's going to
disassemble the module very carefully
and make sure that it's following a set
of rules that we've created that we
believe allow us to ensure that the
behavior of the module is constrained
and that it can't get this direct access
to the operating system in this case it
would it would look at this module and
say ooh you know bad stuff happening
here sharp edges I don't like it and say
I'm just
not going to run it on the other hand
for a physical simulation let's assume
that that looks safe so the static
analyzer is going to say this is fine
let's let it through at that point the
browser will create the container for it
and load it into memory and it'll
actually load it into a kind of a jail
we think of it as being like a jail
because there's a set of things that
this module is simply not going to be
allowed to do so now that it's loaded
into memory we can start it running we
also establish a communications channel
between the untrusted module and the
browser and at that point it can do
things like physics or animation or
whatever kind of high performance
computing you need so that at a high
level is how our native client systems
is activated inside of a web application
let's see so a really fascinating an
important aspect of this system is
security how is it that they think they
can make this native code safe and it is
if you talk with people in the security
community or binary analysis you know a
long-standing problem is reliable
disassembly of x86 code and the
existence of a phenomena such as
self-modifying code overlapping
instructions these are all things that
has made this problem very difficult and
and it's sort of a key part of like the
secret sauce if you will of the
innovations that made as possible so
let's talk a little bit about this what
do I mean by safe when I say as safe as
JavaScript I mean no side effects except
for explicit security interfaces the the
system the system call like layer that
Native Client provides now what do I
mean by a side effect well here's one
example if you started your day by
running this program you might not have
a very good day it's going to try and
move all the files in in your local file
system clearly Native Client modules
should not be able to do this other if
it was as simple as looking at the
source code and seeing you know the
exact ve call you know no problem
unfortunately things are quite a bit
more complicated than this there's a lot
of variance to this kind of program and
here is an example is one of them this
program does exactly the same thing as a
pro game you just looked at a minute ago
as long as you run it on Mac OS but it
does it in a sort of a sneakier way that
I claim is pretty hard to discover and
to make the explanation a little bit
more straightforward I'm going to
highlight a few key instructions the
first highlighted instruction is
initializing an immediate variable with
a with a 32-bit value the 32-bit value
looks just like some random number but
it's not it turns out that the last two
bytes are a system call instruction the
instruction one of the instructions that
Native Client will not allow you to
execute directly the next constant is
computing the address of that same
instruction of that system called
instruction using the base address of
other procedure now clearly this is very
dependent on what compiler you've used
to build this and all that but you know
the people who are actually breaking in
your systems they have no problem with
those kinds of challenges and then the
last highlighted statement is a jump
instruction it's actually going to use
the address you initialized in that code
address variable and jump to the system
called instruction the middle stuff is
just setting up the stack so it looks to
the operating system like exactly East
is call and voila we've just blown away
all your files so so this is a trickier
example and it and yet it's an example
of a kind of program that native client
has to make not possible ok so another
kind of threat that we're very concerned
about is memory stores loads are also
kind of interesting as well and you just
can't let let this untrusted code have
write access to arbitrary parts of your
web browser or other other places in
memory that you might want to be
protected so Native Client is also the
sandbox that we use to run this
untrusted code needs to be able to
secure memory accesses as well now a
basic assumption in the system and this
is really driven by our portability
goals is that the operating system is
not necessary sarily cooperative and
it's not necessarily bug free I mean how
many of you use a bug free operating
system right I don't think anybody was
going to be able to raise our hand this
is a basic requirement for for
portability so so those are that's a
threat model those are the kinds of bad
things that were
not trying to prevent now let me tell
you a little bit about the system design
and how we achieve these goals the
system is constructed with an inner
sandbox in an outer sandbox now the
outer sandbox is actually fairly
conventional technology you can read
about it in a lot of papers and there's
references in the research paper on our
website so I'll just mention that in
passing for now the inner sandbox is a
place where we've really done things
creatively and why there are two
sandboxes well we believe that Google
and in my group in what's called a
notion of Defense and depth multiple
layers of redundant defenses make a
system quite a bit stronger than if you
just hope that your single layer of
Defense actually works so our inner
sandbox is constructed using a technique
called software fault isolation that was
actually originally suggested by wawa be
leuco anderson and graham from UC
Berkeley in the in the 90s and it
basically is using instrumentation
before or possibly after key
instructions to constrain their behavior
in a way that has minimal impact on
performance we put that together with
actually x86 segments remember segmented
memory I think most people probably saw
this in in their architecture class x86
it turns out has a wonderful mechanism
that almost nobody uses to to sort of
reduce the amount of memory that you can
look at and so we rely on that very
heavily to a wonderful thing about the
understand box is that to a first no
it's just a little bit of a lie to say
there's no OS dependence is very minimal
OS dependencies and that makes it very
portable the same sandbox basically
functions identically on all the
operating systems we support Windows Mac
and Linux and and and all the NPAPI web
browsers including opera and Safari
because there's no less dependencies is
relatively immune to operating system
defects now the one caveat restless
tendencies is a thing called ldt local
descriptor table initialization which
ironically it turns out is not supported
on 64 bit windows and I don't have time
to go into that in detail but we talked
about it quite a bit in the paper and
I'll just say we are you know converging
on a solution for that particular issue
now as I kind of alluded to before we're
going to actually change a set
of instructions that the program is
allowed to use and because we we prevent
you from using certain instructions
we're going to need a modified compiler
a modified assembler and a modified
loader to to follow all the rules that
we're going to create to make this
machine code safe fortunately the
modifications we've been deliberately
designing them to be very simple and
open and I'll describe some of the
details in the next slide or two but the
part of the point I want to make is we
really want to encourage other people to
generate code for our system we have no
intention of having any sort of control
or constraining effect on on who can
create Native Client modules the last
point about the inner sont sandbox or it
has been very carefully designed to have
very low runtime overhead on the average
of about five percent across spec 2000
cpu and i'll show you some details about
that later in the talk so now how is
this inner sandbox actually implemented
let's look at some details firstly I
mentioned the problem of data and memory
integrity we don't want wild stores and
writes and reads going on all over the
place and and so the way that we do this
is we use segmented memory on the x86
the green arrow indicates the data
segment that's going to be constrained
by des and SS segment registers and by
initializing those registers properly
you can actually prevent the thread in
question from making any memory accesses
accesses outside constrained region an
attempt to make an Access outside the
region will cause an exception and that
in turn will cause the module B
determinated so it's sort of a fail-safe
kind of approach similarly we constrain
code to the area of the little blue area
arrow using the cs register and this
turns out is like incredibly fortunate
we get this level of really important
protection for free just by using
segmented memory so so that's that's one
key part of the sandbox and it takes
care of our data references now next I
want to tell you about how we can get
control of control flow how do we
prevent an x86 program from branching
into the middle of an instruction like
that six-fight instruction that was used
to initialize the immediate variable in
the previous example and the answer is
we have a set of rules that we use to
make x86 disassembly reliable
I'll go through these briefly first all
valid instruction depend Rees are
determined by a top-to-bottom
disassembly of the text in other words
we just disassemble from top to bottom
and the instructions we see defines the
instructions you're allowed to use in
any and the instructions we didn't
happen to see we're going to prevent you
from using those a second rule is that
all aligned addresses and we use 32 32
byte alignment and most most most of the
time in the system must be a valid
instruction boundary in other words if
an instruction crosses a 32 byte
boundary we will not let you run that
piece of code computed jumps use
sandboxing to force alignment if you're
jumping through a register or in any
case in an address we cannot understand
statically then we're going to use a
masking instruction before the jump to
make sure that the address jumps to an
aligned boundary now since in the
previous rule we've checked that
instructions never crossing the line
boundary we know that the target of a
computer jump must go to an instruction
that we've already inspected ok and this
is a key part of the reliable
disassembly branched targets have to be
within the code segment we get that for
free from segments and we don't allow
mixed text or data you can't have
arbitrary data in the code we don't
allow overlapping instructions or
dynamic code generation those are just
you know sorry you can't do those
anymore had to give up something right
so let me tell you a little bit more
about what the masking sequence looks
like for a computed jump now normally
people look at you know x86 machine code
you might see a call instruction like
this it's going to a known address in
that case of that first call instruction
we know exactly where it's going we can
statically check that that's an
instruction we saw during our top to
bottom disassembly and and if so then we
can make sure that it's safe the second
call is a little bit more problematic
because it's using an address that can
only be known at runtime so to make sure
that's safe we're going to use a pseudo
instruction Knakal call and that will be
expanded by the assembler into the three
instruction sequence that follows that
masks off the bottom bits of the address
before doing the control flow transfer
so that way we know that you're only
going to go to a line
and remember we checked all the aligned
address before to make sure that they're
safe so this is our strategy for making
sure that you can never branch into the
middle of an instruction or otherwise go
to instruction that we haven't already
inspected and that's the reason why we
can a given this as a tool is reliable
disassembly we can actually exert some
power over the binary and prevent you we
can actually remove instructions from
the instruction set and this is where it
kind of gets fun so so this next slide
describes some of the restrictions some
of the additional instructions that
we're going to put on Native Client
modules firstly we're going to leave out
some instructions now I already
mentioned syscall it turns out int is
also problematic because I think there's
a way to do a cyst call with an int
instruction furthermore we're going to
prevent people from using the return
instruction now this one kind of
confuses people sometimes even how are
you going to do a procedure call if you
can't return well well don't worry
actually you can just replace your
return with a pop and a jump and it does
the same thing but the question the
weird question is well why can't you use
the return instruction and the answer is
like I mentioned earlier were really
committed to first-class thread support
and if you check the return address on
the stack and then jump to it you could
have an evil thread someplace else that
was trying to construct a little race
where it changed the address between
when you checked it and when you jump to
it so for threaded programming that
wouldn't work by doing a pop in than a
jump you actually have the address in
state that's specific to the thread it's
in a register so no other threads can
see it and that makes that the check
safe in addition to emitting some
instructions we're also going to
restrict prefix usage and I won't go
into this too much but people who know
x86 assembler know there's a lot of
prefixes some of them do very strange
things some of them just don't make
sense sometimes and so we're really
going to clamp down on that and only
allow prefixes that make sense and at
most one prefix per instruction now mind
you I'm talking about 32 bit x86 code
for 64-bit we're going to have to bend
these rules a little bit but we're still
going to have the same relatively strict
policies and another interesting aspect
of this we really are aggressive about
wanting people to be able to use
instruction set extensions like sse3 and
you know mm x and and all the other
wacky wonderful new stuff that AMD and
Intel are continuously trying to provide
us with there's a problem though imagine
that you have a piece of code with an
sse4 to a instruction and you happen to
have a machine that only has sc2 your
sse2 machine is not going to know how to
decode that SSC for instruction and if
we let it and if we let you just go and
try and execute it we might you might
get the instruction length wrong it
might behave in an unpredictable way and
that could possibly be an exploitable
defect so what we're going to have to do
is when we're disassembling and
analyzing the binary we're going to use
the cpuid information from the processor
to recognize exactly which instructions
are not supported by the cpu in your
machine and when we see an instruction
like the SSC for instruction on an SSC
to machine that shouldn't be executed
we're going to override it with halt
instructions such that if the program
ever actually tried to execute that
instruction it would halt but it would
not cause any damage and that's sort of
an example of a kind of a general
philosophy in the system that we can't
force developers to write correct code
we can't force them not to write buggy
code but we can constrain their code to
a certain set of safe to behave
constrain the behavior to be more safe
question yes
actually the omron is coming with a
microphone yes all right yeah but I
never thought I would see a day when
somebody would love segments that's the
question I had though is that you have a
whole bunch of restrictions to sandbox
but then you know intro did have rings
024 and and and then you have platform
evolution where you have on the platform
things like DPMS and you didn't consider
using any of those hardware sister
actually sandbox your is it really
because as you pointed out is a
expansions are very common and they will
keep happening yeah you're you know I
you know the general a high level answer
that question is that priority one of
the highest priorities in the project is
portability and a lot of the cool
features that might make this easier on
certain operating systems or certain
hardware simply do not allow you to
create a portable system so the Rings in
the Intel microarchitecture for example
you know it's kind of the right idea
except you can still use the system call
instruction in the outer ring we've
actually you know we I would like to see
a new ring or modifications the existing
ring where you could actually remove
instructions from the instruction set if
if you gave me a microprocessor that did
that I could significantly simplify and
you don't think the vtx a extensions and
there nothing helping on that they don't
have what we need yet okay sales let me
plow through the rest of this we are a
little bit time pressured and then there
should be plenty of time for questions
at the end though so if any of you are
paying attention then you probably are
worrying about security life like Jesus
sounds like pretty cool research but you
really want me to use this on my laptop
I don't think so well what I wanted to
try and assure you of is that we're
really worried about security to and and
we're doing everything that we can
possibly think of and in all cases
applying best practices to try and make
this thing as secure as we possibly can
so some examples of some of the kinds of
steps we've taken we do multiple its
internal security reviews and this is
not just
native client or client practices for
anything that gets released and this
customer facing in Google there's a
design review and an implementation
review we have very smart people who are
really good at breaking software and and
so we've been through that several times
we've open sourced our system because we
strongly believe that public review and
public scrutiny will make the code
better towards that and we've also
published a paper and I Triple E
symposium on security and privacy this
year and we held the security contest
and that was really fun actually um the
security contest we put money on the
line 8192 dollars to the first to the
person that's our team who found the
most blogs and some interesting
statistics about the contest there are
about 400 teams that registered about
600 individuals and among them there
were 22 bugs reported so that means
there were probably a lot of frustrated
people out there the bugs that we saw
were actually very very good some of
them were you know complete exploits
that you know totally destroy the system
but they were also mostly almost
entirely implementation defects we
didn't see anything that was a
fundamental issue with the architecture
and almost all the issues we saw were
things that we could fix in a couple of
days and I'm just really pleased that we
found them before we put this on you
know 10 million desktops right so so the
security of contest was great we're not
done with that either we've got more
security reviews plan and and new kinds
of testing before we would expose this
to end users but this is the kind of
scrutiny that I think a technology like
this needs in order to approach the
level of safety that that is you know we
feel as our obligation before we would
put this on a large number of desktops
so so that's what I wanted to tell you
about Native Client implementation
security let me tell you a little bit
about what we've done with the system
now we ported a bunch of stuff mostly
demo type code but some of it is you
know non-trivial a quake to for example
the computer game from the 90s with some
of us wasted a lot of time on runs
really nicely a native client we've part
ported video decoders we courted a lot
of big Linux libraries just to see how
it would go and and then we've
implemented some applications on our own
as well and I'm going to demonstrate one
of those in a min
it I mentioned something about
performance earlier I wanted to show you
the numbers Native Client on average
tends to have about a five percent
performance impact and I'm the average
number is the red bar all the way to the
right now sometimes we have a larger
performance impact for 32-bit linemen it
can be as much as twenty percent and the
reason for that is generally instruction
cache pressure because of the alignment
rules and because we change some of the
instructions and add instructions we can
actually increase the text size up to
fifty percent in some cases fortunately
most programs have a working set size
it's much smaller than the huge caches
and modern machines and so it usually
doesn't matter at all but if you have a
program like some of the unusual code
you find inspect two thousand that's
right at the border of where the
instruction cache kind of ends then you
can run into sort of unusual behavior
other cases we actually make the code
faster and that we thought was really
kind of strange and irritating at first
it turns out that our alignment is
actually has a very positive interaction
with branch prediction another in and
you know keeping cache lines full and
that sort of thing so because we're
aligning all of these instructions that
weren't aligned before we sometimes make
code actually run faster and and
actually that's not just a random
weirdness in spec we actually see four
kind of typical code that we work with
plus or minus three percent is sort of
what we expect in terms of how will
impact performance so next I wanted to
show you a little demo let me see if I
can actually this might be tricky okay I
wanted to show you a little demo of a
program running in Native Client give
you a feel for where it's actually at
these days and and this is also
representative of one mode of usage that
we think is going to be common this is
called Native Client dark room and it
was really inspired by Adobe Lightroom
as a place to work on you know make
modifications to photographer graphs so
over here we've got a bunch of controls
all of these controls and the whole user
interface actually was implemented in
JavaScript in you know using fairly
ordinary
straightforward methods but this area
here is controlled by the Native Client
module and it's going to be doing the
image processing so I'm going to load an
image into into the module I haven't
really done anything impressive yet
right i mean you can certainly do this
in a web browser today but the place
where it gets interesting is when i
start using these modifications now if i
did image processing in javascript we
would talk be talking about seconds per
frame right it would probably take 15
seconds to do anything to this image but
with the Native Client module I can
actually do these kinds of updates like
changing the geometry of the image in
real time we're seeing about 15 to 30
frames per second here what you get will
depend on the cpu in your system but you
know the point is don't try this in
javascript because you know it just
won't be much fun and and so this is
sort of making the point that if you
give a real live cpu speed for web-based
applications you can enable things that
that people might not have imagined
possible so with that let me get back
and in finish off the rest of the talk
ok that was the Native Client dark room
so there's a lot of related work in this
area sandboxing work like i mentioned
started in the 90s with Wahby leuco
Anderson and Graham I don't have time to
go through all of this right now but
it's covered in quite a bit of detail in
our research paper I really encourage
people to have a look at that it talks
about a lot of what we're doing in more
detail now we started earlier in the
talk talking about desktop OS structure
and I wanted to give you a little bit of
a notion of how this project fits into
other desktop projects at Google so like
I mentioned native client is is is
something we would like eventually to
become a part of the application
environment that's available to web
application developers I wanted to
mention some other Google projects that
also fit into the space so if you think
about the application environment it's
really built around html5 open standards
for web applications and they're
becoming more and more powerful each day
and there's a lot of things that they do
extremely well we're very very
supportive of that
one thing that they don't do is high
comp you know compute performance and so
for that we have Native Client to
provide direct access to the native CPU
another thing that they don't really do
very well right now is hardware
accelerated graphics and that's what the
o3d project is for now all of these live
inside the chromium web browser or
Firefox or Mozilla or you know whatever
other browsers you might want to use and
and over time we want to move all of
these things towards being web standards
today they're probably best supported in
chromium and the browser is also
becoming the important thing that takes
care of this resource management it
actually has the infrastructure you need
to manage resources that reside in the
cloud then on top of that we have a hard
drips traction layer and you could use a
full-blown operating system for that but
the full-blown you know linux or windows
actually has a lot more stuff than what
you actually need to run this
environment properly and so that's sort
of some of the motivations behind Google
Chrome OS a much simpler foundation for
for building this kind of web-based
application stack so some of you are
probably sitting there thinking okay so
he told me about the problems and then
he told me how Google solving all of
them thanks a lot have a nice day that's
not really the message I want to deliver
and and the fact is you know yes I think
our projects are interesting and
ambitious but there's also a sense in
which I think we're really just kind of
addressing some of the stuff that we
should have been doing in the 90s and
looking forward I think there's some
much more difficult and equally
interesting challenges so I just wanted
to spend a few minutes talking about
those ah internet security is it really
impossible designed software to be safe
few people will argue with me about the
notion that the web today is a cesspool
and I'm not really even talking about
offensive content I'm talking about
crime spam botnets fishing fraud in
short and and the status quo is is the
result of an accumulation of things that
have come together over these systems
incrementally patched over the last 10
or 20 years I don't really see a
fundamental reason why the world needs
to be this way I think what we're
lacking is a principled foundation for
secure systems that run internet based
applications and there is research out
there that gives me hope for example the
High star work by mozzie heiress and
Zeldovich I think is is making a lot of
progress that not only applies the
principal foundation from information
flow control but also makes tremendous
improvements in the usability of that
kind of technology which was really the
big problem in the past so so I don't
think this problem is something that can
be neglected and indeed I think it's
really timely and you know when I think
about other kinds of context for example
designing a wall surface that is
resistant to graffiti or designing an
airport entryway that can be secured I
don't really buy it that things are
harder and software I think it's just
that there are other constraints that
make it very challenging some of them
are technical some of them are non
technical but the technical part of it I
don't think that it's that much harder
than than problems in these other
contexts I just think that you know we
need to draw our attention back to this
area and think about a little bit harder
another area that I think is really
interesting is power and so this
challenge I think of as being really
wireless computing get rid of the power
cords now you might be thinking Brad
he's actually he's totally nuts I mean
what is he talking about can you
possibly do without power well I I
brought a couple of props at Brian
Bertsch adds group sent me from Seattle
these devices are called a radish and
they actually will see them outside the
conference rooms in this building this
is the device that runs totally on solar
power it has a 1 megahertz processor and
right now this one is only useful for
showing cat images and this one I think
I think I broke it so so you're not
going to be able to get much of a demo
out of these things but the point is
that it's not absurd to think about
computing based on ambient light there's
actually a you know an existence proof
that you can do something that's not
exactly trivial and so I think the
interesting challenge is pushing forward
on that and pushing the envelope on what
you can do with ambient light I'm going
to pass these around and then talk a
little bit more
and these are obviously not the only
devices that would fit in this space
there's you know there's interesting
cell phones at our solar charge than
that sort of thing so if you think about
what are the technical challenges to
doing this I actually come down to three
words all of which begin with p power
performance and parallelism in terms of
power you know it's kind of neat to hear
people talk about laptops it can run for
eight hours but personally I think
that's a crock I think we need to be
much more ambitious than that now to get
better power certainly there's some
hardware work to be done but I think
there's actually a lot of software work
to be done as well because the inverse
of power power is directly related to
performance and if you're going to work
on the performance problem then the the
perspective that I think is useful is
think about the fact that over the last
30 years all of our behaviors been
conditioned by a world where cpu speed
doubled every two years right well we're
done with that that's not really going
to that's not really going to be the way
things are right now and if you if you
think about that assumption and all the
implications has had for how we build
software I think that provides some
vision some some notion of how you can
actually start to think about software
that computes interesting things on
extremely low power devices the third P
is parallel ISM and a lot of people in
the audience I know we're already doing
wonderful work in this area I think of
Lewis says day's work and Sasha fedorov
and there's there's a lot of lot of
really great work going on in this area
but the fact is that it's the only way
you're going to get substantially more
computing performance without totally
rupturing the power envelope so I think
of this as being a really interesting
challenge and I would be delighted to
see research progress that actually
pushes the envelope in terms of what you
can compute compute with ambient light
the last challenge I want to suggest is
reliable software what it would it take
to make software really reliable now I
really like the work by people like
Dawson angler and and Lewis has done
some of this as well where you analyze
programs to check for what kind of bugs
they have the thing that's a little
frustrating about that is sometimes it
reminds me of my experience owning a car
in the 80s where the the industry
responds to a broken autumn
Beal was a worldwide fleet of service
facilities let like not like the car
better just like extract more money for
her service I really don't think I mean
it obviously it didn't work terribly
well for the auto industry ultimately
and I don't think it's the right
approach to take my software either I
think that we can do better than that
I'm actually so so there's a lot of
obviously a lot of interesting work
going on already and one of the things I
saw most recently that really gave me
hope in this space it's an article
published in the most recent
communications of the ACM by xavi a
l'heure wah from inria roco newer he
actually discusses a C compiler that he
has not just implemented but also proven
correct that's a really complicated
piece of software and if you can prove a
C compiler correct then I think that
there's more that we can do for other
kinds of programs as well so that's my
soapbox at the end of my talk and I'd be
happy to take questions on any of any of
the things we talked about today also I
saw Matt papa ki post here a minute ago
well maybe he left ok apologize that I I
want i do want to mention Matt Papa
Kiko's he was instrumental in starting
the Chrome OS project as well as o3d and
Native Client and and he's really
responsible for a lot of the vision
that's that's driving many of the things
I haven't talked about so I'd be happy
to take questions
hi there Brad so right at the end of
your talk you mentioned said somebody
had proven to c compiler correct have
you taken any stabs at proving your
sandbox correct do you think that that's
feasible and attach this kind of
attached to that would it be easier if
you could say convince Intel to make a
small change or two to their hardware to
enable the kind of security reading
instead of doing all of this work in
software that's a great question i have
thought about trying to prove our system
correct I've even thought about asking
other people to do it as a research
project it's obviously a very hard
problem I did have a conversation with
Dawson angler about this once and and
you know the the kinds of let's see I
have to think a little bit about why it
was that that was a difficult problem
but it's it's it's you have to be able
to state what the expected behavior of
the system is and so so so it's
something that we'd like to work on it
is perceived as more of a research
problem than a product problem so it's
not the easiest thing in the world for
me to get staffed but I am you know
eager for collaborators people are
interested in that and by the way one of
the coolest things about working on
client software at Google is it's almost
all open source and part of the reason
for that is because we want to encourage
collaboration and independent innovation
so so and I think that's part of the
reason why I'm really happy to be able
to talk to people about it this morning
now the other part of your question was
talking to people like Intel for example
there are definitely things that they
could do and and we're definitely going
to talk with all the you know
interesting CPU vendors that we can get
get a have a conversation with and
indeed we're talking with a bunch of
people already keeping that in mind you
know Google t usually thinks in time
frames of about like three to six months
and Intel thinks in time frames of like
five years so no matter if even if they
did everything we asked for we would
still have to do everything that we're
planning anyways so don't imagine you
going to get any any quick fix from that
kind of company but there are huge
opportunities and I think some of them
are relatively obvious and some of them
are actually
like interesting research so so yeah
other questions Kim okay so I had a
question about Native Client really cool
project one of the natural critiques
that you're obviously going to run into
is that everybody has to recompile all
of their software some people don't have
the source anymore there's legacy
binaries that are around so have you
thought about and are you exploring the
notion of binary translation dynamic
optimization to do some of the things
that you want to do on the fly yeah
that's a very interesting topic actually
some of the best translation systems
right now are kind of dynamic and that's
a handicap for us right now right now
our system requires that it can
statically analyze all the code before
we run anything but but we are thinking
about if there's a way that ways that we
can loosen that and even if you continue
to have the static analysis requirement
there is a lot of code out there that we
think could be analyzed and translated
effectively one of the neat things about
the project former systems at attempted
doing binary translation were often
designed to run on the desktop and
that's actually the hardest place to
solve this problem because because the
desktop user obviously is not going to
know what to do if things don't work
with Native Client if we had a
translator it should be possible
actually for the developer to run all
the tests that they have available
before they shift the software and if
something isn't quite working they can
you know maybe go back and tell the
translator how to improve things so so
you won't find any binary translation
work in the in the source code base and
and it's it's it's something that we're
thinking about using in some scenarios
all i can tell you honestly we're not
working on it yet but we are highly
hiring all the best compiler engineers
we can find and so feel free to send
these students yeah it's a very
interesting and it's also you know like
i said the compilation we don't want to
have a corner the market on compilers
for this thing we'd be thrilled for
other people to be generating code for a
system as well so other questions
sure yeah this can be the last question
oh it's about to say I have two
questions once upon time x86 is only one
of the native environments so do you see
your system actually I can surfing
imagine desktop disappearing into
palmtops and probably x86 may not be the
only choice and how much is this really
neat solution you give this such a
convincing them oh how much of that is
tied to x86 specifically yeah well your
question is a good one and it's actually
one of the reasons why inside the team
we have little model of full employment
employment for compiler engineers but we
have stated publicly that we're working
very hard on an arm fort we also need to
support x86 a 64-bit version that is an
x86 environment without segment
registers that is only a part of the
solution to achieving the the level of
portability that people expect from the
web and the rest is kind of like
research actually if you think if you
start thinking about instruction set and
neutral distribution formats for high
performance code you know and keep in
mind that we're really not willing to
sacrifice anything in terms of
performance then you're definitely
outside of the range of like common
practice and into some of the kind of
you know the scary ed edgy kinds of
technologies so we should probably let
you take your break I've already burned
through most of it I apologize about
that but I will be here pretty much all
day today and I'd be delighted to talk
with people more about these projects
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>