<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clasp: Common Lisp using LLVM and C++ for Molecular Metaprogramming | Coder Coacher - Coaching Coders</title><meta content="Clasp: Common Lisp using LLVM and C++ for Molecular Metaprogramming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clasp: Common Lisp using LLVM and C++ for Molecular Metaprogramming</b></h2><h5 class="post__date">2015-06-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8X69_42Mj-g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm very happy to host Cristian Chhath
Meister to give his talk that I've
witnessed on the European Lisp symposium
in April and London and I think you are
in for a real treat
Christian chef Nissa I thank you very
much and thank you very for inviting me
this is really really a treat to come up
and be able to present what we've been
what I've been working on for the last
well my life really okay so what so I'll
tell you a little bit of my background
so I've been programming since I was 12
I was one of the kids in RadioShack
program and a terrace ad and that's in
my blood some people read to relax some
people knit to relax I write code to
relax but I'm also now I'm the chemistry
professor at Temple University and I
build molecules as well because what I
want to do is I want to build molecules
as easily as I can write software I want
to build molecules that can do things
like act like machines and go into the
body and fix things basically inspired
by Richard Feynman I gave this talk in
1959 called there's plenty of room at
the bottom where he for the first time
sort of proposed the idea of building
machines on a molecular scale that are
atomically precise where you know where
every atom is in space and that idea is
what has propelled me into the field
that I've gone into and basically my
background I've done biophysics where I
was making proteins and solving crystal
structures of proteins then I got into
chemistry and I'll show you what we've
done in chemistry in that time so
basically we understand a lot about how
a molecular machinery works the
molecular machinery that makes us work
are called proteins they are chains of
amino acids that fold into these
three-dimensional structures let me get
this pointer up here we are
so they fold into these
three-dimensional structures and they
arrange atoms and groups in precise
three-dimensional constellations so that
they can do things like this one here
speeds up chemical
action this one's actually being
developed by the Department of Defense
to hydrolyze nerve agents to detoxify
nerve agents this is a molecule called
an antibody it's a huge molecule that
has these two binding sites up here and
up here their pockets that can recognize
surfaces of other proteins like viruses
and and proteins that don't belong in
our bodies and and start the process of
where the immune system will attack them
and then we have things down here like
channels
these are aquaporins these are molecules
that let water pass through a membrane
but don't let anything else pass through
and they keep ourselves from bursting so
they maintain the osmotic pressure
across cells now if we could build
things like this we could solve most of
humanity's problems I mean if we can
make catalysts I could pull carbon
dioxide and water out of the air and
knit them together using sunlight we
could make fuels that way we could solve
most of our problems and the solutions
to most of our problems are down there
at the molecular scale we just have to
figure out how to make molecules like
the ones that I showed you now I know a
little bit about this because as a
graduate student I built one of the
first unnatural proteins it's called dhp
one this is the crystal structure
I designed it on paper
really I designed a gene that expressed
the protein I put into bacteria I
express the protein purified it
crystallized it this is from the crystal
structure and showed that it formed this
sort of a four helix bundle which is a
very common motif in proteins it took me
four years to put this thing together
it's a molecular boat anchor it doesn't
do anything and I didn't know how to
make other ones and I got very fed up
with proteins because they're very soft
flexible floppy molecules then I looked
at synthetic chemistry I see chemists
making all these wonderful natural
products as huge molecules and I said I
can do that I could design new building
blocks that are easier to design with
and so I did my postdoc actually down
the street and the chemistry department
at Harvard and while I was there I
invented these things this this is an
idea where we stabilize small sections
of proteins called peptides in a very
common sort of shape that they adopt
which are these Gila seeds and what what
I what I did was i synthesized these
unnatural amino acids that we could form
a cross-linked across one or two turns
of a helix to stabilize it in that
structure but it's a very sort of subtle
stabilization yet it is being developed
down the street about five blocks away
by this company called aileron and it's
called they call it stapled peptides and
Roche several years ago put 1.2 billion
dollars into this to develop these as
drugs so something that I invented is
being moved forward and is currently in
clinical trials as of February they have
a molecule in clinical trial for cancer
okay but I don't do this anymore I work
with different kinds of molecules so I'm
very inspired by proteins you take a
bunch of proteins and DNA and you hold
them at 38 degrees for 35 days and you
make these wonderfully functional things
like us and eagles and trees and
everything but you take them out of that
comfort zone for even a little while
right and they turn into scrambled egg
they're delicious but they're not very
functional proteins are very fragile and
they're very difficult to design with
and I know because I've done this so I
came up with something else
I came up with new building blocks that
are easier to design with so these are
building blocks are sort of they're
synthetic you have to make them using
chemistry there are rings and they've
got an amino acid on one side another
amino acid on the other side you can
display functional groups other groups
hang it off of the off of the building
block and they have different shapes so
we have these five membered rings we
have six membered rings we can move
where the amino acid is relative to the
other one move it around and there's
also a thing in here called stereo
centers so this carbon here can have
this this is a carboxylic acid can have
it projected out towards you like it's
shown or into the screen these are
three-dimensional objects
and basically what these things are is
are like little Lego bricks and they
connect to each other through pairs of
bonds so unlike proteins which are amino
acids they're strung together through
single bonds and then floppy inflexible
and they have to fold up that's great
for biology because it needs to take
them apart again and recycle the
components I want something that's more
rigid and more designa below these
building blocks connect through pairs of
bonds and that's quite a trick to get
all that to work so we synthesize these
building blocks so we can now do it
hundreds of grams it's process chemistry
we can make we could make kilograms and
tons of this stuff but there are little
bricks they have a functional group that
hangs off of them and they all have
different shapes and when I started out
I didn't really care what the shapes
were as long as they were different and
they projected into three-dimensional
space I figured I could just do the
geometry and build molecules that adopt
any three-dimensional structure I want
and so we make a lot of these little
sticks that have functional groups
pointing off in different directions and
we can control the shape by controlling
the sequence of building blocks and by
controlling what we hang off of the
building blocks all right so that's the
basic technology that's the instruction
set so what we want to do with this
going forward is I want to make all
sorts of things this is an idea to make
channels that can act as anti microbial
compounds basically they're their rings
that have a water-loving sort of a pore
that is accessible to water we put
greasy groups on the outside and we mix
this with bacteria they would drop into
the bacterial membranes
hold open a hole and cause the bacteria
to bleed its guts out okay an anti
microbial general antimicrobial compound
there's a lot of compounds in nature
that work sort of like this but they
have to self-assemble and so you need
large concentrations of them these could
be very active another thing that you
can use pores like this for us to do
single sequencing single molecules of
DNA we are the only people who could
make atomically precise pores that you
could thread a piece of DNA through to
read it's sequence and this is something
that we're just getting into now these
are concepts these are things that we
can do like
next ten years here's another idea we
make these triangular molecules and we
stick greasy groups into the middle and
they can basically create boxes with
different internal shapes that small
molecules would go into so you could
make all sorts of sensors for small
molecules and by making a raise of these
you could create things like artificial
nose that would detect all sorts of
molecules a good thing about the
molecules that we're working with is
that they're very robust they don't get
degraded by nature by proteases they
don't unfold they're very robust so they
could last they can be put on a sensor
and last for years you can put into cell
phones and last for years this is
another concept here of making molecules
that could act as channels so by
creating bundles of these molecules and
making setting them up just right
designing them properly you could create
molecules that could be pores and they
could do things like separate ions from
seawater we could separate gold from
seawater I wouldn't need to write grant
proposals you you could create molecules
that could act as water channels and
pack them as close as densely as
possible so that you can make membranes
that are work at theoretical limits of
efficiency for purification of water
water is going to become a big problem
in the next decades we can make
molecules that act like artificial
antibodies that project multiple sort of
pre organized arms out and instead of
like pharmaceutical chemistry makes
small molecules that bind into greasy
pockets on proteins we could make
molecules that wrap around proteins like
antibodies do and I have schemes on how
to make a billion of these and then just
fish out which ones bind particular
proteins the big thing though that I
want to do is I want to make catalysts
molecules that make other molecules
because then I can make molecules that
make our building blocks and we wouldn't
need to keep synthesizing them all the
time we can start bootstrapping this
technology and make it very very
inexpensive and I think I know how to do
this we've already done and made some
catalysts with the little molecules that
we're able to make till now a couple of
things that we really have done already
is we've assembled this molecule here
this has our building blocks here on the
backbone it presents these three groups
and there are 256 different shapes that
this can adopt because of all these
stereo centers they can this group here
can either go into the screen or come
out of the screen so it is one bit of
information and there are eight of these
centers that can each be what are called
s or our configuration so there's 256
stereoisomers about six of them present
all of the groups on one side so they
can slot into the groove of this protein
called mdm2 and this molecule goes into
cells binds this protein and stabilizes
it you can see when we add the compound
as you add more compound the levels of
the protein go way up and another
molecule that Roche was developing to
bind this protein called nut Lin does
not do this so our molecules do things
that are different from small molecules
and this just shows that these are sort
of confocal image it slices through the
cell and you can see the compound is all
throughout the cell the compound is
green because it carries a green
fluorescent group so we published this a
couple of years ago 2012
here's another molecule we've made it's
a catalyst this is a molecule that
speeds up a chemical reaction it will
take methanol here and vinyl tri fluoro
acetate and you add our molecule like 1%
so one molecule of our catalyst here for
every 100 molecules of this and it will
turn over and create this molecule and
this here is a graph of product with
time and you can see when we have the
optimal version of the catalyst where
all of the stereo centers are set up
properly all of these groups have the
right arrangement of groups when we set
everything up properly and there's
thousands of permutations here we just
made a few of them that we designed with
earlier versions of my software that
I'll tell you about and when you do it
design it optimally you get the maximal
activity we can measure the rates of the
reaction when you change anything like
you move this nitrogen here to this
position here then the rate drops off
it's a slower less efficient catalyst
right so and so what this thing does is
it the backbone arranges the groups this
is a pyridine base this is a benzyl
alcohol here and this is a urea and it
ranges all of the groups so that the
substrate the material that goes in and
gets transformed can interact properly
with all of these groups and we set
everything up properly it speeds up a
chemical reaction all right so we can
design molecules that do things and we
can use with these building blocks we
can use software to design these
molecules and I'll show you how sort of
that works so but the ultimate goal is
to build bigger things build things the
size of cells where we use this
chemistry that I've described to make
bundles of these sticks and we set them
up properly so they can self-assemble
into larger materials and those
materials would include catalysts they
would include motors they would include
things that can do information
processing and ultimately we might be
able to build things like this like
little robots I could inject it into the
body go and find damaged tissue kill
things repair things fix everything
that's the ultimate goal here I don't
know if I'll reach it in my lifetime I'm
working as hard as I can okay so
basically these molecular Lego we call
them spare leg immersed the molecular
Lego are an instruction set for making
molecules that do things that bind to
things and that speed up chemical
reactions and we're also working on
making pores the small versions that
we've made so far they're inherently
limited because they're small but when
we can start to tie multiple molecules
together tie them together into a big
molecules where we can create pockets
and we can create large surfaces then we
could start to achieve the things that
proteins can do but there's going to be
a lot of design and a lot of development
to get there the design I basically have
a design problem now because I can
synthesize molecules that are much
larger and much more
Plex than I can design now synthetic
chemists normally they design things
with plastic model sets I should have
brought one there are these little balls
you've probably seen them and this kind
of a size molecule would be something
about the size of a washing machine all
right and with so many configurable
parts to it that it's just impossible
designed by hand
we need software now I so basically I'm
out of okay so a little animation there
okay basically what I need is an Oracle
I need something where I can go in and
specify what the molecule needs to do
and I sort of know what that means it
means where do functional groups need to
be in space for a catalyst it means
arranging them around a what's called a
transition state of a reaction for
binding a protein it means just
arranging them in the in a way that
looks like the groups are arranged from
a protein that we've already determined
the structure for but we need something
where Wiccans makes specify a problem
like that and then have it come up with
a design from the molecular device based
on this molecular Lego so design to
build I decided to write an Oracle and
basically went off on a big side project
for the last four years so the
expression here yak shaving this is
referring to this expression of where
you're doing any apparently useless
activity which ultimately allows you to
solve a larger problem for the last four
years I've been developing software to
design these molecules and I've done it
in a very unusual way what I think is
the best possible way really what I need
is a language I need a language it has a
lot of chemistry functionality built
into it because I don't really know what
the problem is that I'm trying to solve
I want to be able to quickly write you
know try something and then if it works
great if it doesn't want to throw it
away and I want to try and build
something else and the sort of software
that's available now to design molecules
is really there's a lot of sort of
graphical user interfaces where you can
draw them all echoes they're way too
slow for me it takes like 20 minutes to
draw one of these molecules and then
do an energy minimization it's it's just
you know working with one molecule at a
time like that is completely pointless
what I need is something where I can run
build and run simulations on a million
molecules at a time on hundreds of
thousands of CPUs so what I need is a so
what I've done is I've written a C++
library that builds molecules and does
all the stuff they need but I don't want
to write this stuff in C++ it is a very
difficult language to write it I also
need to use you know I also need to use
a lot of libraries that people are
writing in C++ and I again I don't want
to write in C++ I want to write in some
sort of higher-level scripting language
so where I started is I started first
tying this into Python and so I use
Python and I use this template library
called boost Python and C++ and I had
all this stuff working and I almost went
nuts with it because you spend all of
your time dealing with getting the
interface to work getting the memory
models to work connect together to get
exceptions to work just to get all this
stuff to work that's got absolutely
nothing to do with chemistry so I had a
friend who worked at NASA and was trying
to convince me for 10 years to get into
Lisp and finally I started looking at it
I wrote a little Lisp interpreter took
me about two months I hooked it into my
C++ code I had it running on 40,000 CPUs
on kraken which was a machine on the NSF
tara grid at the time it was wonderful
it's saying and I built designed the
molecules that you've seen so far with
that it was great
it wasn't quite fast enough and so I
decided okay if I'm going to do lists
I'm just going to go whole hog I'm going
to pick the best listen implementation
that there is and that's Common Lisp and
I'm going to hook my code into Common
Lisp four years later I've gone and
implemented a new Common Lisp
and it's called clasp okay I did a
couple of things different there are
about a dozen versions of Common Lisp
available but
of them had what I needed unfortunately
and I'll explain that basically what
I've done is implemented a new common
list that uses LLVM as the backend so
you write Common Lisp code the compilers
that I have will generate LLVM ir and
then LLVM lowers that to optimized
machine code and it all works we
explained to you sort of some of the
things that I want to do in the
chemistry software that I use there's a
lot of math there's a lot of non-linear
optimization there's a lot of simulation
of dynamics of molecules and i need to
be able to describe energy functions and
i need to be able to calculate forces
and second derivatives first and second
derivatives of energy functions i need
energy functions that don't exist in a
lot of molecular mechanics force fields
so a force field is just an equation
it's a bunch of terms like this is a
Hookes law spring this is what we use to
describe bonds okay so you here we've
got ethane and we describe the bond
between the two carbon atoms by a Hookes
law spring we say that there's an
optimal bond length l0 and there's a
force constant and any time the length
of that bond is deviates from the
optimal the energy of the system goes up
okay so that tends to restore the bond
to an optimal length and we know what
those bond lengths are from crystal
structures and chemists have been
working on this for hundred years okay
we've got all that pretty much sorted
out and then we've got terms for bond
angles
we've got terms for dihedral angles
where bonds are rotating around so this
is a molecular mechanics force field and
all these parameters we have tables of
those that I can draw from to bring them
into my code now what that gives us is
for a complex molecule like what I'm
building is a huge multi dimensional
space that we have to search and the
energy changes very quickly as you
change the shape of the molecule and
what we're interested in is one thing is
finding where these
low these energy minima are because
those are sort of stable shapes that the
molecule likes to adopt and since mine
are all lateral molecules tied together
through multiple covalent bonds they
don't have a lot of flexibility to them
so finding a global energy minimum is
something I can achieve with with the
mathematics and the kind of molecules
that have designed the other thing we
want to know is how these molecules move
how to simulate their motions and so
that means basically putting it in one
point in space and then letting it shake
around to do all this stuff you need
derivatives you need the forces you need
second derivatives and these are huge if
you put them into Mathematica and you
say calculate the derivative of just the
Hookes law equation you get these
massive expressions that are absolutely
useless for doing calculations because
you're constantly re-evaluating the same
stuff over and over again so what I want
is code that would where I could write
an energy function and then have it
automatically generate the do the
symbolic differentiation and then
automatically lower that to optimal
machine code I've done this I've built a
prototype it's in Mathematica you're
welcome to use it basically what it does
is it take all this nonsense here and
turns it into optimized C code and it
this is graphical representation here
are the inputs the coordinates and the
force constants and then what I try to
do here is minimum the number minimize
the number of read operations reciprocal
square roots those are expensive so
minimize those I think blew our products
and green are additions and oak on the
other side come all the first second
derivatives and the energy all right
this is the simplest function if I put
anything more complicated it is just a
mass of green and blue but this stuff
runs at about 110 percent of the speed
of hand optimized C code or Fortran code
I think I can do even better if I could
lower this to LLVM ir that's what I want
to do I want to be able to put in
equations
maxima is the predecessor of Mathematica
I can generate derivatives I can
generate common lists I can generate
code basically and then generate LLVM IR
and generate native code from equations
on the fly that's one thing I'd like to
do with with the capability that I'm
developing here the other thing I want
to do is just write programs in Common
Lisp comma lists all these wonderful
features it just haven't made it into a
lot of other languages and and I want to
just add a whole bunch of new chemistry
packages and functions like low to force
field load molecule assign atom types at
assign atom charges a lot of pattern
recognition that goes on in these
processes here and then run molecular
dynamic simulations by calling out to
C++ code that will do the actual
calculations on using libraries that I
don't want to have to write so so why
choose common list well it's basically
Greenspan's role that any sufficiently
complicated C or Fortran program
contains an ad hoc informally specified
bug written slow implementation of half
of Common Lisp and I was there when I
had the list and the C++ the cut that
Python and the C++ stuff I was dealing
with garbage collection and you know
path names and and just all sorts of
stuff that I was having to sort of
reinvent and it was buggy and nobody
else would ever I'd have to document it
and it just seems simpler to pick a
language it had all these features
already and then just use those and hook
into other people's Common Lisp
libraries and be able to use like you
know regular expression libraries from
Common Lisp if I could reuse all this
work that other people have gone and
hook it into C++ it would be fantastic
so I put these in more for archival
purposes because a lot of you guys work
with you folks work with Common Lisp but
the real thing that I wanted was macros
true macros that are written in the
language that I'm in
maintain so I can write programs that
write programs because I've reached a
point now where I'm tired of writing for
loops I'm tired of writing the same code
over and over again and I can write I'm
pretty good at writing macros it turns
out writing code that generates code
metaprogramming it's I just love it I'm
there it has all these other features
dynamic variables multiple return values
I can go on and on and on this other one
is really important a tunable compiler I
really wanted a compiler that I
understood where I could write high
level code and take it all the way down
to native code by myself so if I want to
do things like use GPUs to solve
something that I could hook into the
compiler to do that and Common Lisp
would give me this ability it's a
programmable programming language okay
what about the C++ how do I tie it in ok
so what's missing from every common list
is a way of interfacing to C++ C++ has
kind of exploded over the last 28 years
lots of people are writing libraries in
it and it is hostile to interaction with
other languages not not by design or
anything but just to add all these
higher-level language features to it it
keeps growing and it's just getting
harder and harder for other languages to
hook into it's really easy to hook into
C there's very simple ABI there but C++
has you know name mangling virtual
functions overloading exception handling
move semantics and it's I hook into it I
can tell you it's tricky and the problem
here is always the interface between
scripting language and the and the
low-level libraries getting all this
stuff right the wrapper classes and
memory management exception handling
it's it's it's very tricky it very
quickly takes over the project ok this
interface starts to grow and take over
over everything
consumes all your time so the current
state of C++ Common Lisp interoperation
is foreign function interface --is
you have to basically write a see
interface to for your C++ library and
then Common Lisp almost every common
list of implementation can hook into
that and that becomes the problem okay
so the thing is C++ so has this facility
in it called template programming it's
an attempt to achieve something like
what we have in common lists with macros
but C++ template programming is too
common list macros what IRS tax forms
are to poetry alright because basically
you can write this code with slots in it
where you can stick in types and a
little bit of information and stamp out
a new chunk of code but you don't have
the expressiveness it is turing-complete
it's accidentally turned complete
whatever that means but it is awful to
write with your what you want to do is
spread so wide across all these
different repeated blocks of code that's
impossible to understand what another
programmer tried to do but it is
powerful enough to build an interface to
another language and it does know
everything about the functions the C++
functions and classes that you want to
expose so we I could use C++ template
programming to do this and this has been
done before what inspired me was well
what I really learned about this from
was this thing called boost Python it's
one of the boost libraries and it's a
c++ template programming library that
lets you hook into Python and basically
all you have to do is give it the name
of the function in Python a pointer to
your function in C++ and it builds the
wrapper for you at compile time it's
really complex and and hard to
understand there's another variant of it
called lua bind for the language lua
that's the one i actually stole and
hacked to create cl bind a common list
version of it the model here is develop
something like scientific python so
scientific python is becoming sort of
the de-facto high level script
language of science and it's only
because of boost Python that it lets you
hook Python into C++ without wrapper C
code it's all done by the compiler
so I implemented a new common list
called clasp it's 150,000 lines of C++
code what I did was I took all the
Common Lisp code from embedded kana
lists from ECL which ultimately came
from Kyoto Common Lisp I owe these guys
a lot it's wonderful code took these
2600 lines it's running on top of my new
underlying engine which is written in
C++ I took about 10% of the C code in
ECL and I translated into common less
but the rest of it's all written by me
and I own all the bugs so knowledge ah I
did not use their compiler because I
don't understand it I wrote a new one I
wrote this library called CL bind which
lets you exposed C++ code to my common
list I first wrote a common lisp
interpreter exposed wrote CL bind then I
expose the LLVM c++ api's for building
modules and finalizing those modules to
generate native code hooked all that
stuff in so then I could start building
LLVM modules from common list then
progress started going really quickly I
could I wrote a compiler I've never
written a compiler before I've only been
programming common list for about four
years
so I sorry so I exposed LLVM and then I
also exposed a lot of the clang ast
library and I'll show you why
so the clang is the C++ compiler built
on LLVM I hook that into clasp as well
it's sort of a side project recently i
implemented tagged pointers immediate
fix noms characters and single floats so
that I can do generate really fast code
that's only about a month old now I've
gotten it all working to the point where
I've got a SDF slime and quicklist
running in
clasp it all it needs to bootstrap is a
C++ compiler so I've got this s
expression walking interpreter which is
pretty slow it loads up a compiler
compiles itself then the bootstrapping
compiler generates pretty slow
inefficient code but it does get close
running with class running what I can do
is I can import Roberts trans cleaver
compiler now Roberts friend is a
brilliant computer science professor at
the University of Bordeaux brilliant
methodical snappy dresser he's been
writing this new Common Lisp
implementation called sickle and he's
really doing it sort of for his research
sort of looking at what people have
implemented in Common Lisp and trying to
do better and doing better cleaver is
the compiler component it's not quite
finished but it does do take s
expressions and take it to an
intermediate representation that I can
then convert into LLVM and lower the
native code and I've got that working
now but basically clasp looks like ECL
it's so similar to embedded common list
that implementation-dependent systems
that you get with a SDF you can make
them run with class by just converting
all the pound plus ecl's to pound plus
clasps and you know I've replicated a
lot of VCL ok so I've talked a lot about
this I'll just point out some highlights
here so clasp is to see both plus in
LLVM what armed bear common lisp and
closure are to the java virtual machine
he sort of sort of takes a similar place
it uses LLVM to generate native code it
does both just-in-time and ahead-of-time
compilation and the just-in-time
compilation is all done in memory it
doesn't allow the files to do anything
it's using the C++ API straight up it's
very easy to expose C++ functions I'll
show you an example of that let me check
the time here
I'm good I also exposed the claim some
of the clients C++ compiler and all of
this what it lets you do is do things
like I can profile Common Lisp code and
C++ code together because they speak the
same underlying language they're all
LLVM I are ultimately it generates dwarf
debugging information okay so I'm
generate so you can use gdb to debug
Common Lisp programs and I've hooked in
a serialization component so that I can
serialize all my chemistry classes that
are written in C++ you can extend class
by adding C++ classes that get managed
by the garbage collector so you can
basically add sort of classes that
become first-class citizens in class and
I do that in my chemistry code and
currently class supports to garbage
collectors the main one is going to be
the compacting garbage collector by
Raven Brooke called the memory pool
system it's a sea library that I've
hooked in and it allows me to take my
sort of 350 C++ classes and do
compacting moving garbage collection
with them stuff that people on the plus
plus C++ per pound pound C++ IRC channel
said was impossible I am moving C++
classes around updating all the pointers
in memory it works it's like a jet
engine the thing works
I use the Boehm garbage collector to
bootstrap the system because you
describe this part okay so this is a
fancy thing that I did to get the
compacting garbage collection to work
with class with C++ what I did is I
exposed the clang abstract syntax tree
and ast matchers libraries to clasp to
Common Lisp so I can read in C++ code
and search the abstract syntax tree
that's built within common list I can
analyze do pattern recognition on C++
code I can even
actor C++ code I can do I can generate
refactoring this is something that
Google has put a lot of time in Chandler
Carruth stalk he gave a couple of years
ago on this where Google is using this
sort of refactoring facility to you know
improve the api's in the Googleplex the
all the C++ code you guys use I've done
that sort of a small version while you
guys have developed the Battleship that
works on hundred million lines of code
I've developed a little Volkswagen here
that is good for individual product
projects what I've done with this is
I've written a static analyzer that
tracks down every pointer in every class
that needs to be managed by the garbage
collector and it builds and it's parsing
currently 173 C++ source files and all
the headers it generates about 20,000
lines of C++ code that interfaces with
the memory pool system it updates and
move allows all these about 300 C++
classes to move and be compacted in
memory and it updates 2600 global
variables it tracks them all down and
updates them all if one pointer is out
of place the whole thing tears itself
apart
it runs okay and the really nice thing
is you can then extend clasp and add all
you know lots of additional C++ classes
that also get garbage collected as
first-class citizens you can also hook
in libraries that are completely naive
and that don't use the garbage
collection facility so there's two ways
to sort of embed and extend class ok so
just quickly I'll show you how you can
expose C++ libraries I don't use
anything like a foreign function
interface this is it if you have a C++
function like this one that takes two
doubles adds them together and returns a
double all you do is you call Def you
give it a string which is the name and
Common Lisp you give it a pointer to the
function which is in C++ and it builds
the wrapper function at compile time
that's all you have to do and you can do
a lot of things I'm just showing you a
really simple example here here I've
created a class called Veck - it
contains
x and y-coordinate x and y values here's
the constructor set x and y calculate a
dot product you pass it another vector
calculates the dot product returns a
double and then I wrote a function here
that just prints a string and the vector
and then here I expose it so you declare
a new package common list package called
Veck you expose the vector class and the
constructor here make Veck - so it will
call this constructor that takes do
doubles and returns a vector I expose
the dot product function I expose the
print vector function then you build
that library you load it as a dynamic
library in Linux it's a dot SML file
then you can make vectors and then you
can do operations on okay in the memory
management everything is dealt with you
can take possession of pointers or not
take possession appointees by setting it
up in the interface but basically you
can hook in C++ library this is a simple
example I have hooked in the clang
library huge complex library that
doesn't know anything about interfacing
with any other languages works great and
I was able to write the static analyzer
with that so where am I going with this
the next thing is to make it fast
currently the code it generates is about
a hundred times slower than steel Bank
Common Lisp that's because I'm doing
everything in the safest stupidest way
I'm calling out to C++ functions for
everything I add 1 to X I've got to
promote them all the big numbs do the
addition if they fit I take them back
down to fix nums terrible I know how to
fix that it's basically using cleaver I
can make this fast I can use I can
generate a lot more LLVM I are cleaver
lets me do aggressive inlining of
functions cleaver also does type
inference and it will basically
eliminate all the type checks and the
code that's not necessary based on you
know the type information that it infers
from the code or that you provide
with declares there's just a little
taste of cleaver my bootstrapping
compiler just takes s-expressions
straight to LLVM ir there's no room to
do optimizations in there cleaver has a
bunch of additional layers where it'll
take s expressions generate an abstract
syntax tree it generates these really
nice little graphs using graphviz and
then they'll take the abstract syntax
tree and turn it into an intermediate
representation where the rectangles are
all instructions and the solid arrows
show the flow of control and then the
dotted arrows are the flow of data and
these ellipses here are variables right
now there's no determination whether the
variables belong on the heap or the
stack it does escape analysis and it
figures out all these hexagons can go on
the stack if something needs to go on
the heap it builds a closure for it and
built that into the code and then my
code will use all of the bootstrapping
compiler to generate LLVM ir from that
and then LLVM takes it the rest of the
way okay so I wanted to build molecules
I am so deep down the rabbit hole now
there's only one way out and that is
forward to make this thing fast hook it
in I've already hooked in my chemistry
code in the last month I got all back
running again three years that stuff's
at now I've hooked it all back in I have
can do running so I can build small
molecules with it the ultimate goal is
to build molecular machines all right
I've done a little side project here
then I hope to tie into my research I
hope other people can use it as well
because maybe then I'll get help
working on it but the idea is to design
software that will let me design
molecules assemble these kind of
molecular Lego this instruction set from
matter for building molecules speed up
chemical reaction act as new drug drugs
you know access channels it's available
on the internet github.com dr meister
clasp there if you want to work on the
front end the bleeding edge of
development the branches are all up
there and it runs right now on mac and
linux all lots of distributions and oh I
didn't mention there's a chat room on
freenode called pound clasp where a
bunch of us hang out and talk about
clasp and common lisp
I'm also very active in the lisp chat
room on freenode
so with that I'd be happy to answer any
questions that you have
right on time yes and if you could come
forward I was asked to point people at
the microphone there so in the end
what's better about this than Python you
said that Python was very painful
because you had to use booth Python and
you ended up implementing something that
is almost the same as booth Python
except for different language yes um so
python is slow will it I will be faster
than Python once I'm done
Python doesn't have macros Python
doesn't have all the other nice features
of common list that I've now want it's a
little hard to describe because I've it
was kind of like 2 years of pain and
then I finally decided to stop and try
something else
so I'll just leave it at that I think
Python is a wonderful language my
students that's how they learn
programming or by one student who
decided to learn some programming
learned it with Python it's a wonderful
language I think for it's pretty nice to
read but I just find it when I when I
need to do big hard things it it's for
me it's very limiting so
I noticed that you said that you that
your system generates dwarf debugging
output yes and you like macros yes have
you ever actually tried to use the dwarf
base to bugger with stuff that has
macros in it that's a that's that's a
problem to solve
tomorrow yeah it's uh I I still don't
know quite how we're going to deal with
that but it's it's not working perfect
it's not working perfectly and cleaver
doesn't have support generating dwarf
yet the codes all in there I just
haven't hooked it in yet but I my stack
traces are common less C++ Common Lisp
C++ they're interleaved and occasionally
I will crawl up the stack trace and I
will see Common Lisp code in ll DB and I
don't know I know I set it up to do that
sometimes it works and sometimes it
doesn't work and it is wonderful
I've got to tie it in better but it it's
it's really nice to dwarf is really nice
macros are you know there aren't a lot
of language there aren't a lot language
that macros like Common Lisp does it's
it's going to be an issuing problem to
try and solve there yeah yes I was
wondering you could tell us a little bit
more about the sort of chemistry
algorithm point of view of trying to
solve the common toriel optimization
problem of I want a catalyst that does
this yes I've you know as soon as I have
a non-trivial number of these pieces
together
I accept array out you know too many
possibilities you know even if the first
item X R is very very fast I still have
to search a huge space and Excel quite a
woman I forgot to bomb yeah so basically
Monte Carlo Monte Carlo solves every
problem
what I know for like a catalyst
development so I like all the catalysts
that I showed you and there's there's a
couple we made three catalysts that
we've published so far we're
collaborating this is Department of
Defense funded work - funded by the
defense Threat Reduction agency they're
interested in their mission is to
protect the country from chemical
radiological and biological threats and
one of the things they're interested in
are catalysts in particular that can
hydrolyze nerve agents nerve agents are
very nasty molecules that kill us in
very very small quantities and they're
pretty reactive and if you could just
speed up the reaction where they react
with water you could turn them into
stuff that's in coca-cola
phosphoric acid and but you need the
right shape a molecule to do that now
nerve agents have only been on the
planet for about a hundred years but the
bacteria that are in cornfields have
started to develop resistance to nerve
agents because we use weak nerve agents
as pesticides and so they been coming up
with these molecules these
organophosphate hydrolase molecules that
I showed you and we know what the
insides of those enzymes look like we
know that they hold two zinc atoms in a
precise constellation with a couple of
other groups around it and there's a
pocket where the nerve where the
pesticide can go in and it activates
water and Cleaves the right bond and
then the stuff is detoxified we know
where those groups are Nature has
already given us the plan okay
so the problem is those organophosphate
enzymes they don't work with the nerve
agents that kill us they react with so
what we can do is on the computer is we
can sort of rearrange the groups so that
we could react with nerve agents we know
where the groups are in space all I need
to do is find a scaffolding behind them
that will hold them in place and one
that I can synthesize since our
synthesis is all modular that problem is
kind of solved but the design so what do
you do well you you take a computer
model that shows where the four five six
seven groups are in space and then you
try and build a scaffold behind it that
can hold those groups in place
projecting off of the points on the
building blocks so we can
analyze the goal there is then what
you'll get is a molecule that's a few
percent the size of this enzyme but it's
indestructible the problem with those
enzymes is you make a gallon of it and
you dump it on a tank to try and
detoxify the tank the protein will just
unfold they unfold when you look at them
the wrong way they're very fragile
molecules the things that we could build
would be indestructible small you could
store them on a shelf for a hundred
years and they would still work and they
will work for a long time they won't
just work for a few minutes and then
unfold okay so you're that's basically
the idea well come up with a bit okay
the algorithm is basically come up with
a scaffold with the groups presented on
it do a root-mean-square calculation for
how far the groups are from your model
to where they need to be randomly mutate
the backbone score them again if it's
improved keep going if it's gotten worse
roll a dice based on a temperature
factor decide to keep it or go back and
then just repeat that it's an
embarrassingly parallel Eliza basan
hundreds of thousands of CPUs in
parallel starting from different
starting configurations and look for
local Optima and the idea is that
there's not just one solution to the
problem there's a million solutions out
of the trillion that I could make and I
just need to find some locally optimal
solutions then we'll go make them and
see if they work and if we get any kind
of activity then we can make variants
around that they're you know real
molecules and then screen those for even
higher active ones but fundamentally
it's Monte Carlo yes I so you might have
just kind of answered this and also this
might be premature but so what would
actually programming like designing in
this look like let's say you were trying
to make something similar to you know
the little like walking protein that
that pulls arrived its own down DNA and
like you're written to what that feels
like when you're actually writing it so
these first ones are more just about
getting four five six groups in the
right place in space
doing something like a motor yeah that
means designing a catalyst that will
hydrolyze
a fuel molecule and transducing that
chemical reaction into a molecular
mechanical motion across a hinge haven't
figured all that stuff out yet I need to
be able to build a lot of these things
and start messing around in that space
to develop that kind of capability but
it absolutely can be developed because
we our biology doesn't and and we just
need to build our own versions of it
yeah but but that kind of a molecular
motor there are people in making
molecular motors and very clever I want
to build it in this kind of substrate
where I can attach other functionality
to it so you could have grippers that
could grab things and then move at the
same time so you said a few times that
these are essentially indestructible and
that just brings one question to mind
clean up right so you can burn them
they're there they're basically made out
of the same kind of atoms and groups
that peptides and proteins are I don't
think they're inherently going to be
toxic but the best thing to do is fish
them back fish them back out of the
environment and we're and build
catalysts that would break them back
down again that's what we would have to
do because there are no natural cat
enzymes that break them down and this
this is a problem right now in society
right we're building all these plastics
and nature isn't a breakdown and there's
a fascinating story to tell you about
later about about just trees you know
trees lignin first biological plastic
for 100 million years that stuff was
building up in the environment
eventually became coal until an organism
fungus figured how to break it down
again and then the Carboniferous period
ended that's an example of where nature
made something that accumulated in the
environment until something figure out
how to break it down
for these things at first there aren't
going to be a lot of them but as the if
they do start to build up we'll have to
build catalysts and break them back down
again okay
Oh
so I make common list compilers that
generate Hardware computing hardware for
FPGA so instead of generating
instructions how do you run a computer
processor I'm generating gate basically
yeah and let's use four of us are
massively parallel multi-car luke and so
if you looked at that kind of things and
do you think yet the commutation you are
you need for this optimization would fit
in in right sure the other way I think
we're trying to we're solving very
similar problems using very similar
approaches I mean that that sounds great
I'd like to talk to you about that yeah
but so you do use Monte Carlo to do this
no I generate political machines in fact
okay job show all the way so they are
gate so if you need to do 1,000
multiplies for instance yeah we'll do
them with 1000 multiplier so in one
clock you will you will do and it has
been used for finance Monte Carlo
solution and yeah basic is 1,000 times
faster than the CPU yeah and you're
doing the same colonise yeah the
commonly generates all the the gates and
the connections to the gates and no
that's yep yep I I'd love to talk you
more about it
Christian
well thanks so much and thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>