<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Update on the Natural Programming Project | Coder Coacher - Coaching Coders</title><meta content="Update on the Natural Programming Project - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Update on the Natural Programming Project</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xPpdfgXMd0w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is John schedule and I'm a UI
designer and I work on some of the
developer products and i'd like to
welcome Brad Byers to Google today he's
going to be talking about the natural
programming project and I think a lot of
his research is very applicable to some
of the things that Google's trying to do
around organizing information and
providing api's to users and making mash
ups and and all those things much easier
to do and create so without further ado
let's get started Thanks well thanks
very much for inviting me I'm from
Carnegie Mellon and the human-computer
interaction is too in case you're not
familiar with it is a whole department
focused on user interfaces that we have
about 20 faculty with backgrounds in
computer science like me but also
psychology and design so it's a very
much interdisciplinary group the
presentation I may give today is
intended to be an augmentation of one I
gave for about two years ago here so if
you're not familiar with my old work I'm
sure you have the video somewhere but I
will be covering some of that in
addition to all the new work we've done
in the last two years but I wanted to
you know particularly focus on the new
work because this is a fairly old
project the natural programming project
has been something we've been working on
for about 12 years now we started in 95
with one of my students the fundamental
goal is to try and make programming
easier to try and think about suppose we
were to take a human centered approach
to programming and how can we how can we
think about making programming easier
and the general idea is to try and make
it more natural and by natural i don't
mean english I don't mean natural
languages like English or friends I mean
natural in terms of the way people think
you know it's natural to just type in
regular words into Google doesn't
necessarily mean that you have to use
natural language and the methodology is
also fairly unique especially for
programming research and that we start
off with studies
so we do studies of how people work we'd
study do contextual inquiries into the
field we do a lot of background research
in order to inform the actual systems
that we build so then we always build
some systems we are computer science
group after all and then we actually go
the next step and evaluate the system's
we've created to try and get actual data
about how well they perform and that's
also fairly unique in the software
engineering field you know if you look
at software engineering research it's
mostly just claims about how good
something is going to be without any
data to substantiate it but we really
definitely try and get the data you know
that talks about whether our results
work or not so if I'm talking to a bunch
of people who are you know hardcore
computer scientists or language
theorists they're very skeptical of this
idea their programming should be more
natural if you talk to you know the
programming language researchers they
want programming to be more mathematical
they don't want it to be more natural so
what is this idea of trying to make
programming more natural well we're
basically coming at the perspective that
programmers are by and large people
right that even professional programmers
are mostly people and you know probably
how many people here are programmers so
pretty much everybody and you guys are
all people so you know why should we
ignore properties of people when we're
thinking about how programming is done
and there's been a lot of work in kind
of the social aspects how people
collaborate around software things like
that we're focused mostly on the
individual programmer and the way they
interact with their tools and how can we
deal with that in the same kind of using
the same kind of techniques that HCI
uses when you're building a consumer
product like if you're building you know
Gmail and you want to test it for
usability or you want to see what gmail
should do you do certain HCI processes
we apply those same processes to the
programming problem so why would whiten
is natural a good idea if you think
about programming the whole point
of writing a program is that you as a
program or have something in your head
that you want the computer to do and
programming one way to think of it is a
way of transforming what you have in
your head into something the computer
can understand right so you have to take
the task in your head you want the
computer to display this box or whatever
and you have to think about how you're
going to get the computer to understand
it and you write code as a result so our
thought is that instead of trying to
make the person do this transformation
entirely we can make the computer
understand things that are closer to the
way people are are trying to think about
their problems if you think about direct
manipulation it's the same idea you know
trying to reduce the difference between
what people want to express and how they
express it and then theorists like green
and Petry have also identified this and
with the parameter they call closest of
mapping how close what you want to do is
to the way you have to express it and
you know it's easy to see examples of
this if you want to sum up a set of
numbers and a spreadsheet you write some
and then you give it the list of numbers
and in Java you write a loop and you
have a loop variable and you need you
know three different kinds of
parentheses and all these syntax and
stuff like that so clearly a spreadsheet
for the operation of summing numbers is
a lot closer to your goal programming is
not just for the professional
programmers programming is pretty much
for everybody so there's a statistic
that thirty percent of new jobs may
require programming skills this is us
numbers but of course programming has
always been complicated and it certainly
is still today and another trend that
we're seeing and hopefully you guys
aren't feeling this as much as
programmers at other companies is that
there's intense pressure on programmers
to be more productive you know if they
can't produce more code there they'll be
offshored off to India or something
where programmers were cheaper and
you know you can get more lines of code
per dollar so programmers are motivated
now to be able to produce more code per
dollar or whatever then they have been
necessarily in the past so there's
professional programmers who have CS
degrees there's novice programmers that
are people who want to be professional
programmers like students and there's
this new class of programmers that have
been identified that we call end user
programmers and these are people who
program because they have to not because
they want to okay their programming as
part of their job and their job is
really something else entirely so
they're not paid their program they're
paid to do something else and
programming is the way that they do
that's something else so it's not a very
satisfying definition but it certainly
gives you a sense of this big group of
people we're talking about and if you
look at the charts and the numbers it's
really a much bigger than this little
group of professional programmers these
are us numbers 3 million professional
programmers in the US if you ask people
what they do at work 13 million people
say they do programming as part of their
job so that's already a factor of four
if you include people who write
spreadsheets who write databases who
write web forms you know then you've
gotten up to 55 million people and then
if you look at all the people who use
computers at work that's 90 million
people I just ran across similar data
from Adobe this is worldwide numbers
they think they have flash in their
programming environments in about 2.4
million you know sites but there's about
3.8 million what they call creative
workers you know designers and so forth
you might use flash so that's kind of
this group but then there's like 80
million people who you know are the
potential markets okay so you see these
kinds of numbers pretty much in any
field that you look at that there's
these very small number of professional
programmers but there's a much bigger
group of people who are doing
programming as part of their job and you
know we need to have tools for them as
well
what about debugging this has been a
particular focus of my group for many
years it's expensive bugs cost companies
a lot of money and your average
programmer if you do a survey of you
know what they spend their time on their
spending about three-quarters our time
testing and debugging buds are hard to
fix by and large and takes a lot of
negotiation among people and a lot of
problem-solving to figure out and I
think they really scandalous thing is to
think about how you're debugging writing
print statements we're setting
breakpoints where you're watching
variables it turns out if you look at
the computers from the 1940s they did
that stuff too what's new and debugging
virtually nothing though we're debugging
today the same way we were debugging 60
years ago when computers were first
invented what other part of computer
science has not changed in 60 years
right our programming language the same
programming environments everything else
has really advanced significantly why
aren't we spending more time on
debugging given that it's such a big
problem so that's one of the things that
really been focusing my group and why is
relevant here well this you know kind of
three classes of people that can benefit
from this kind of research there is
internally you guys have lots of
programmers that work here suppose you
could be twice as effective suppose you
could produce code eight times faster
than you do now certainly some of the
techniques that we're looking at have
enormous potential for increasing your
own productivity on your own tasks and
we've done lots of studies of
programmers at Microsoft and an essay p
and some other companies in order to try
and validate and find out where people
are really spending time what the
barriers are and stuff so forth you are
also producing what are called api's you
know programming interfaces you're
producing you know things for other
people to use for professional
programmers to use by and large
we have lots of data about how that
should be done and about you know how
you can make those programmers lives
easier and how you can really
significantly affect what they're doing
one study we had show that if you do
something wrong it takes twice as long
to use an API as if you do it a
different way okay that's a really
significant barrier you're putting up in
front of people that are going to try
and use your API and then finally you
know you guys are getting into the end
user programming market with things like
google gadgets and mashups and stuff
like that we have data that helps inform
how you can create those kinds of
environments so that people can use them
more effectively so as I mentioned this
is a fairly old project john Payne
pretty much started it and he graduated
five years ago now now he's working at
Rand in Pittsburgh he started off by
studying how people naturally express
computer algorithms okay what are the
standard things that a computer has to
do has to execute a sequence of
statements it has to make a choice
conditionals has to iterate have loops
their variables so we took all these you
know fundamental computer science
principles and asked people to express
them without telling them they had to do
anything about programming just to see
what sort of things people would say and
from that we gathered a lot of
interesting information about how people
think about programming concepts so just
for example all the men and women in the
room rate your hands okay so for the
people who can't see pretty much
everybody raised their hands except for
some of the programmers who understood
that because I asked for men and women
that's the intersection and so only
people who are both at the same time
should have really raised their hands
and I won't tell it you know who felt
like they actually matched that criteria
so these are you know people who are
programmers have to learn that the word
and in programming has nothing to do
with a word and in natural language it's
just a completely separate concept that
doesn't really have any correspondence
between the
to another thing that was very strong
about the strong result is that people
when you're talking when you're thinking
about a set of objects and you're
thinking about a single object you think
about him pretty much in the same way
you know move a chair move all the
chairs right you don't have totally
different constructs for doing dealing
with groups that you deal with
individuals whereas in almost every
spreadsheet every programming language
every end user programming language
requires you to have totally different
structures for dealing with iterations
and loops then you have to deal with
Singleton's okay why is that well you
know historical reasons and then another
thing so we talked about Anne's and ors
precedence doesn't make sense to people
go to the store and buy something that's
not an apple or pear so you come home
with a pair because everybody knows it
not binds more tightly than or so it's
not apple or pear right so these kinds
of things that we take for granted in
computers really don't make any sense
unless you have a lot of training to
understand what they mean so we another
thing that was pretty obvious was a
event based programming people like to
say when pac-man hits a wall he stops or
when all the ghosts the dots are gone
but some people like to talk in terms of
constraints pac-man is never allowed to
walk through walls ok so both of those
made sense to people and so you have to
think about do the implications of that
so we took all those results and built
an interesting programming language
designed for kids called hands and
that's handy the dog and it basically
embodies a lot of these results in a new
language which we then did a user study
on and showed it was better than you
know the alternatives and so I don't
have time to go into any more detail on
this but as I said this is a long
project lots of results lots of studies
and I wasn't really sure what to focus
on so if you're interested in any of
these results I'd be happy to come back
to them or point you to some of the
papers
so we've been mostly working for the
last I guess eight years or so on the
programming environment on debugging on
tools on how you understand code and not
on the programming language itself as
much and I have a for PhD students and a
whole bunch of other students who have
worked on this recently and we've been
focusing again on all three classes of
programmers novice programmers expert
programmers and end-user programmers so
one of the things we did early was look
at novice programmers as their debugging
and seeing what kind of errors they made
okay what are the bugs that people make
in code what are the implications of the
bugs that they produce and it turned out
maybe not very surprisingly if you think
about it that almost all the questions
people asked about their code were why
questions write a bug happens and then
you're wondering why did that happen
right it's usually pretty obvious what
happened and so now you want to know why
write an interesting result that really
nobody had meant nobody had observed
before was in almost three quarters of
the cases it was a why not question why
did something not happen i wrote some
code it didn't seem to work I expected
this to turn blue and it didn't happen
okay so that in this particular case why
not questions were a vast majority and
if you think about the debugging
techniques you know breakpoints print
statements they're particularly poor at
why not questions write this code didn't
get executed why not well I put a
breakpoint on it sure enough it was
reached well yep that's why I knew that
already so then you have to somehow
trace backwards and put a breakpoint
somewhere else and see if that was
reached and so you know the why not
questions are particularly difficult so
what we did was what people do is they
make up hypothesis I think I know why
this is the problem I will guess what's
wrong and then either try and do some
debug
to figure out to verify my hypothesis or
what novices tend to do and of course
experts never do this they just go write
some code to try and fix it even though
they're not sure that that's really the
problem or not right so it turned out
that ninety percent of the time people
were wrong in their hypotheses and
two-thirds of the bugs in the programs
were as a results of people guessing
wrong not sufficiently verifying their
hypotheses and adding more bugs on top
of the existing bugs as a result of
guessing wrong you know so that they
would add some code in to try and fix
something that wasn't broken or they
would fix it incorrectly so we've got
two thirds of the bugs ninety percent of
the time people are wrong this is one of
the reasons debugging is so difficult so
we had the inspiration to say suppose
you could directly ask the question you
have in mind and so we actually
implemented that we implemented a system
called the Y line that has a button that
says why and you push on it and it gives
you a menu of questions why questions
and why not questions well how can you
have a why not question obviously
there's an infinite number of things the
program didn't do it didn't go get me
coffee right well it turns out you'd
only have to ask why not questions about
things that could have happened and so
it's pretty if you think about it
there's a finite number of things the
program could have done because you can
look at the branches that weren't
executed you can look at the event
handlers it weren't fired and so forth
and come up with a reasonable set of
things that go in the why not menu so
the Y line like most of my systems is a
silly acronym workspace it helps you
link instructions to numbers and events
you'll see many more silly acronyms to
come so the initial version of the wide
line was done in Alice which is a
programming environment by my colleague
Randy Pausch we picked Alice because we
had control of the whole source it was
fairly easy to instrument and the other
nice thing about Alice excuse me is it
you can instrument that you can let me
you can create code really quickly
because it's a syntax directed editor so
that made it really easy to do
experiments so we could take an expert
programmer and say write this code in an
hour and they could actually produce
something really effective because of
the debugging so this is the Alice
environment and we augmented it with the
y line and had incredibly dramatic
results people were eight times faster
using the Y line than the alternative
and their overall productivity went up
by forty percent ok so these are fairly
dramatic numbers how many people have
increased our productivity by forty
percent or a factor of eight or
something recently and so we want to see
and the question is ok you did it for
Alice you know that won't really work in
the real world well so what Andy did
over the last summer last year or so has
been re implementing this for java so
now we have a system that will do the y
line for the complete java language
complete java system all the api's real
java code you know 30 eighty thousand
lines of code java programs you can get
this kind of interaction where you ask
why questions about the execution and
you know systems programmers you know if
you're working on your systems you know
multiprocessing you know well maybe you
can't afford it for that this kind of
overhead that the system requires but
for every day programming that most of
the world does and remember we're not
just talking about your operating system
programmers or your assistant
programmers we're talking about the 80
million people who could be using these
kinds of environments why not use the
incredible power of today's computers to
give you this kind of capability so what
what is the Y line do as you're
executing your java program it keeps
track of every single thing that happens
every assignment every method call every
process switch ok keep that in a trace
and then separately you can load up this
trace and then debug
see what happened and in particular it
has as you're executing to collect this
information it slows down programs by
about a factor of five which is a
comparable to most profiling tools so if
you've ever run you know memory checker
or performance tools that they also do
tracing it generates a trace at about
two megabytes per second so you know
it's you know not insignificant but how
much you know can you fit on your desk
or in your memory and then Andy's
invented some fairly clever real-time
algorithms for using this trace data to
generate these why and why not questions
now you might imagine that a Java
program does a lot of stuff how could
you possibly know what goes in your why
menu right so if you wanted to ask a why
question about what recently happened
you know 300 million instructions
recently happened which one do you want
to ask about it doesn't make any sense
so we have this neat interaction
technique where you can point to
something in the screen that you see
that is wrong and that focuses the
questions just on that object and
remember we talked before about
hypotheses well isn't this an I pollicis
you have to say what you think is wrong
well our we've observed that programmers
are very good at seeing what's actually
wrong people don't have to make a
hypothesis about what they see that's an
error they just have to hypothesize why
so we let them show the system what's
actually an error and use that as a way
of focusing both the questions that are
asked and the answers and so then the
pop-up menus just have a very small
number of questions that are about the
thing that you are pointing to because
any particular thing only has certain
numbers of things they can either happen
or not happen so let's see if I can get
this video to run
unfortunately the video is a little bit
too big for the small screen that
they're making me use here so one
promising way to help people debug is to
record a program's execution and then
provide a user interface to explore the
recording this is the approach we take
with the while I'm a new kind of
debugging tool for example here's a
program with a problem with its sliders
blue slider seems to have no effect on
the color drawn as we demonstrate this
our tool records these interactions when
we quit the program the Y line loads of
the recording it then recreates a
history of the program's output this
allows us to choose a particular point
in time to ask about them so it's going
back up all your am wondering what this
color was black instead of blue so I
click on the stroke and ask why it has
its current color the y line then
determines the cause of the color and
shows a visualization explaining it as
we can see the selected event is the use
of the color that we asked about the Y
line shows the source code corresponding
to this event above on the current state
of the call stack of locals on the right
find out where the color came from we
can click on this data dependency arrow
when they hover over the arrow the same
dependency is shown in the source code
when we click on it the Y line finds the
origin of the value and jumps there in
the visualization this updates the
source file on the call stack
automatically here we can see that even
though the blue slider was moved all the
way up values used to generate the color
that was drawn on screen were all 0
making it black instead of blue when we
look at the code above we see that the
blue slider was never used there are two
references to the green slider instead
so we found our bug in addition to the
features we've seen the visualization
also supports collapsing and unclamp sin
groups of events y line also knows what
code the user has source for and
de-emphasizes code that might be
unfamiliar this includes single events
but also unfamiliar calls that happen to
invoke familiar code we can also
separate threads of execution to help
detect unwanted interleaving
okay so hopefully that was pretty clear
but can talk about more later so we did
a user study of this just a preliminary
user study so far we're certainly going
to do more elaborate study eventually we
took the Y line and gave it to some
novice novice programmers and compare
that to professional programmers using
eclipse for exactly the same bug and we
get you know about a factor of two and a
half speed up in time as you might
imagine you know the right line takes
you right to it in as little as one
minute where to go yeah from one minute
up to 12 minutes whereas professional
programmers with eclipse took you know
32 38 minutes so it can be fairly tricky
to find these kind of things without the
right tools yeah so we have a whole
formal user study plan and that's going
to be in these final thing for a thesis
we haven't done it yet but we're pretty
optimistic that when we do the you know
experienced programmers novice
programmers the whole you know we're
definitely planning a complete set of
studies and this is just you know wanted
to make sure we're in the right ballpark
you want to repeat the question yeah
okay so another system that I reported
here before so the Y line for Alice I'd
reported before but the Y line for Java
is brand-new we just submitted a chi
paper and a Nixie paper about it so
that's really you're the first people to
hear about it this is a again some old
work the idea is you know why debugging
of programs is good but you know
Microsoft Word is doing weird stuff to
me all the time why can't I debug that
too right so the picture just moved or
something changed to a weird font and
things like that so we always want to
ask why about these so-called
intelligent applications you know why is
this menu item grayed out and so we
added the same kind of
capability where there's a why menu or
you can click on things and ask why
about them to a simulated version of
Microsoft Word and one of the key things
was you know sure enough we show that
people could figure out why certain
weird things happen very effectively
this way but also we designed a toolkit
to show that if you have an undue stack
which course every most applications
very few of your zoo but most other
applications do if you have an undue
stack to keep the extra information
needed to answer the why questions was
only about twenty percent extra code
okay because most is what's in the undo
stock is how did you know is how to do
something how to undo it so all we
needed to add really was a dependency
information of what it actually affected
kind of the back pointers right so if I
click on something that's bold you know
how do I find out what was a command
that executed so the toolkit
implications of providing this very
useful feature for users was fairly
minimal and part of the innovations in
crystal was it doesn't just give you why
something happen but it shows you the
particular user interface option that
causes it to happen right so we figured
that people really don't want to know
why something happens they want to fix
it or they want to make it not happen
anymore so when you ask you know why is
it text change from teh to th e it says
because this option cause this button to
be you know check and so actually what
we found was experts if they wanted to
get to this checkbox it's often faster
to use crystal even if you know where it
is because it takes you right to the
right option I'm always forgetting where
that is right and if you used you know
word 2007 it's just even worse finding
things that they totally we organized it
now you really don't know where they are
so and also crystal puts down objects
where things used to be so if something
moves away
aight it leaves down this invisible
object so you can point to it and ask
why things used to be there we also
studied novices trying to learn things
nowadays programming languages are very
tiny part of what you have to learn to
do anything right think about Java and
then think about swing and all the other
libraries you need to use you know C++
vs msdn right or you know the Google API
is you know basically the language
itself is a very small part of what
people need to know and so what is it
that people have trouble with and we
came up with a model that describes all
the different barriers that people have
learning to program very few of which
have anything to do with the programming
language itself all right you've got to
figure out all these different things
you want to use how you're going to pick
which one to use how you're going to
combine them together and then how to
figure out what actually happened but we
did another study of professional
programmers that was really interesting
and we got a lot of mileage out of this
study we've actually used it in detail
for three or four different papers an
interesting observation was for
virtually any change to a modern program
you're going to have to touch code in
lots of different places we call it the
working set okay and it's fundamental to
object-oriented programming and
aspect-oriented programming that you
know anything that you you know
implement has to be distributed right
you put some stuff in the initialization
part and stuff up from the pink methods
and then the event handlers so if I want
to add a new kind of you know button to
my system you know where do I have to
put code to handle that button well all
over the place and this is really
fundamental to you know architectures
because if you reorganize your software
the other way well then a different set
of things might be you know co-located
but some other things that we want to do
would then be distributed so it's really
no way around this problem it's
fundamental how come today's programming
environments provide you no help at all
with this so we
spent a great deal of time annotating
these very detailed logs of what people
did so we could really have a good
understanding of where people were
spending their time during these tasks
and you know you're probably pretty
comfortable with these names they had to
read the code this is code they were not
familiar with they had to edit it they
were navigating and so forth but if you
look at these in detail one of the
things that really jumps out is the
amount of time that they were spent
navigating is thirty five percent of the
time that they were trying to do an
activity and a lot of these navigations
were you know just using the scroll bars
okay they had all the eclipse fancy
jumped to my source kind of things and
search with texts and things like that
but a substantial amount of the time was
actually wasteful navigations that
really were back to where they were
things that they didn't know how to get
to an effective way so again we're
getting a third of people's time wasted
on something that could relatively
easily be fixed and so we tried to build
a tool to help fix this michael koblan
did a master's thesis on a tool called
jasper java aid with sets of pertinent
elements for recall that basically
collects together lots of snippets of
code and tries to present to those
exactly the pieces of code that you need
to do any particular task the grand
vision for jasper is it would
automatically collect these for you we
didn't ever get anywhere with that so
I'm waiting for a PhD students who do
that work but since he was just a master
student we just had the ability to hand
collect these pieces so it's an eclipse
plugin that lets you take little pieces
of code also you can take pieces of
documentation they might be useful and
you can make clit you know textual notes
that might be useful there
remind you what you're doing or things
that you discovered and so forth and you
can collect all these together in a
window and then save it with your
project you know check it in the CVS and
so forth and so the idea is that you
know if you're working on a particular
set of code you can get the
initialization and the paint and all the
score nerd stuff all together in one
place and and deal with it together so
it was just a first step but I think it
is you know interesting kind of
implications of doing this kind of study
figuring out what people are wasting
time on and then trying to fix it
another tool I report here before which
again grew out of some of the
observations from the same study is that
when people are trying to learn api's
nowadays they don't go to msdn and type
something in anymore they type whatever
they were interested in into google and
see if they can find some relevant code
as an example code right so if you're
using an API chances are somebody has
discussed it in a newsgroup somewhere
and Google is indexed it somebody has
posted some example code there's
probably lots of code out there and so
there's also the vocabulary problem if
you don't know what it's called it's
really hard to look it up in the
documentation whereas probably somewhere
in the you know newsgroups or discussion
groups or something somebody has
mentioned this word along with the right
API call you know in the discussion
somewhere so this is a lot more you know
using Google's a lot better than just
searching code examples because if you
have the wrong word for something it's
not going to be in the code examples but
it's likely to be in the discussion and
the bug requests and things like that so
what Micah does micah makes interface is
clear and accessible is it uses the
google api's does a search so here i'm
searching for how to do full screen in
java and if you know it turns out there
is a get set full screen window command
in java that's handy but there are all
these other things that are also quite
related and so what it does is
it takes her search send it off to
Google then looks at all the pages that
result pulls any java keywords out and
puts them over here and sorts them you
know in it Ristic way to try and get out
the most relevant ones it also tags all
of them research results that have code
in them code examples and then they has
a mechanism for pulling the code
examples out so it's just a cute little
application that you know seems to help
people find a much more quickly what API
call they want if they're trying to get
something done we also use the same data
set to look at how people do text
editing okay so when you're using
eclipse how do you edit compared to when
you're writing a document in Word okay
so the the editor the commands are
fairly similar you can go forwards and
backwards you can click with the mouse
you can type spaces and tabs and
characters and you know you can delete
words and stuff like that so back in the
old days with emacs we had all sorts of
special commands for doing code but you
know mostly people don't use those
anymore and if you remember the Alice
it's a fully structured editor you have
to drag and drop everything people don't
like that so is there something about
the way people edit code that's
different then the way people edit
regular documents and sure enough there
is and so we take advantage of that in
this tool kit called barista I've rishta
somebody who makes coffee and this makes
Java code stands for basic approaches
for rewriting instructions as structured
textual abstractions and the idea is
that to try and find a middle ground
between fully structured edit errors
that nobody likes because it's to
noxious and plain not helping me at all
kind of text editing that you get with
the clips so it obviously is going to
have a scape completion or intellisense
whatever you want to call it where it
pops up you know the completions of
things but it has a lot of other things
too there's no particular reason that
you have to look at your code in the
usual you know drawn-out way right
because
the scenes it's all representatives XML
anyway so we might as well reformatted
in a way that makes it easy to read
because everybody knows that ninety
percent of the time you're reading code
and not typing it so why you know make
that more difficult than it has to be
people often want to look at
alternatives you know they're trying out
different techniques or and they have to
use comments and things like that to do
that why doesn't the environment help
you with you know keeping track of sets
of alternatives so there's a whole bunch
of different ideas you know special
commands you can provide and other kinds
of visualizations they can make editing
a lot easier and not penalize the expert
that really you know wants to use their
mouths really I mean their keyboard
really quickly and use our keys and type
in backspace and so forth so it's a
pretty clever idea that's a new work on
AP is so you know google makes api is
that professional programmers use and
you guys use internally and it turns out
that the design of an api is a user
interface right so that you're providing
to a set of people which are the
programmers a way of getting at the
functionality that you're trying to
provide them so suppose we treated the
API itself as a user interface and did
testing on it and so that's what we've
done and we've done various studies of
different aspects of api's you can take
a particular API and do a conventional
study on it you give it to somebody and
say what's wrong with this and they try
and use it and give you feedback but
then you have to do one after another
and that's kind of boring so we're
trying to go up a level and say are
there some principles or patterns
software patterns that we can talk about
in general as a way of making it easier
for everybody who wants to design api's
in the future so we've done two detailed
elaborate studies one of default
constructors in one of factory patterns
and we look at things like learnability
what kind of errors people insert into
their code as a result of the api's
robustness what they like you know
things like that so first one was
required constructors so this is a for
all you object oriented programming
people how many people understand
code most people in a room okay the idea
is that normally when you have an object
the way that created is to say new
object right so if you want a fool you
say new food okay and this one style
says that you can create an object and
it's empty and then after you create it
then you can start filling it up with
things okay so I have an empty object
foo here and then I'm going to start
filling it with things and eventually
I'm going to use it okay there's another
thing where you say there's no way to
create an empty object you have to
already have the values for it before
you can create it so it's called a
required parameter required constructor
and the conventional wisdom is that
required constructors are better because
the API author is now telling the
programmer you not allowed to have a
fluid at a bar in this case right a bar
is fundamentally essential to having a
foo ok and so be having this required
parameter in theory is telling the
developer that however in our studies we
found the opposite in fact having this
required parameter confuse people no end
everybody wanted to create an object
first and then fill it up that the one
of the reasons was that it really
interfered with people's learning of how
to use the API that they really wanted
to figure out if they had the right
object first it's this object going to
be the one I want and then they fill it
up so we as I mentioned we we studied
both expert in novice programmers he
asked what kind of people we studied it
was both expert in novice programmers
and it's this is universal it's across
the board and in fact we we looked at
very specific api's with which people
were already familiar and they still got
this wrong okay so and you know maybe
it's a small effect okay in this
particular case you might imagine people
could figure out ways around it
uh you know but it wasn't you know
people's first reaction right so if it
also it did not succeed in telling
people that they always needed a bar
because people would just figure out
ways around it they pass in a no bar
right so you know then a compile-time at
least they get through the compiler if
they passed a null here and then
eventually at runtime you know it's not
like as a foo implementer now you can
assume that you always have a valid bar
because they could have passed in null
so you had to check anyway as a
programmer and you know get your runtime
errors if they try to use it without
passing in a valid bar anyway or they
destroyed it and then you know then when
you use it it's gone anyway and the
other point is that the normally if
you're going to require the parameter
that means your programmer has to
allocate a whole bunch of temporary
variables right so it's my temp temp are
holds my bar as I created up and then I
tempt you know this and that another
thing and then so you have this long
string a temporary variables whose only
job is to hold this thing that you're
only going to assign in something later
right and so that doesn't seem like that
more structured than saving it where you
want it to go which is in the object
itself so another one that's very
controversial is this idea factory
patterns this is a very strong result
and everybody hates this result every
professional programmer I've given this
lecture to says now wait i love
factories so the idea of a factory is
normally you want to create an object
like we said you say new object well
with a factory pattern you're not
allowed to say a new object you have to
go to this other thing called the
factory and get one tell the factory to
give you one so instead of saying new
foo you say give me a factory F and F
give me a food or after create widget
okay so the idea is that for some reason
you don't want the user to allocate
objects with new you have to go this
other place and get them it's actually a
fairly common pattern
used 61 times in java least 13 times in
net the SI p software package if
anybody's ever programmed to that just
disease all over the place turns out
that lab study with and these were all
experts nobody likes factory patterns as
a user okay it's when you ask people to
design an api from scratch nobody's ever
going to come up with a factory pattern
when you present them with real code
that uses factory patterns they're all
confused when you present them with a
programming task that requires using a
factory pattern the current tools do not
support that very well and so they find
it difficult they add more bugs their
code and it has a really dramatic impact
on their performance it took two to five
times longer to write code using factory
patterns than it does to write code that
uses new and you may be familiar that
with the factory pattern is designed to
provide certain ability certain features
like avoiding allocating memory and
reusing objects and things like that and
there are often other patterns that you
could use to replace what the factory
pattern does and still provide you know
the ability for people to create it in
the way that's much more natural so you
have to think about whether you want to
make this trade-off of making it more
difficult for your programmers or not
right and this is not a consideration
that most API designers have ever made
question
so you asked about the Builder pattern
or dependency injection I guess I'm not
familiar with those patterns
specifically but you know one of the
things would be delighted to hear about
is if you have pattern do you think
would be good candidates for studying it
would definitely be interesting to see
what your insights are in terms of your
thoughts about whether they're you know
problematic or not particular results
corroborate but as far as I know what
that collecting data which is that the
more concrete the less tiring work
the expression the more to it so my
dad's an asshole for example I explained
them mathematically in a few lines of
math people who use it well can say
mazing things in a few lines of code
it's very robust but those whose brains
don't take to that look that many order
remove from the actual data being
vigilant it can take years for learning
I'll soon will be programmed by example
software which had these things of
trying to take the programmer down the
abstraction hierarchy to where they feel
much more like the programming so the
question is you know is this just a
matter of concrete versus abstraction or
levels removed from the actual code I
think it's definitely plausible you know
but that's really not the only thing
going on here all right I mean so in
some sense you know the factory patterns
you know it's a little more abstract
than than just allocating things but in
terms of the you know previous result
neither of these really is more abstract
than the other
at the time setting its bar right you're
operating on the instance as opposed to
providing full so it's you can certainly
explain this as being more concrete but
I would posit that no one would have
proposed that as a trade-off here if we
hadn't done this experiment first okay
and so you know if you ask somebody
without having presented this data first
which of these more concrete they
probably would say oh they seem about
the same I'll not to mention to me so I
think that and some of the other things
we have don't follows neatly into that
dichotomy but certainly you know taking
these HCI principles and making things
more direct trying to make things match
the user's mental model certainly you
know encourage that kind of design
thinking and you know one of the real
principles of this line of research is
to say we should be applying that to
api's as well and that but in other
cases you know using these kind of
high-level guidelines both sides can be
arguing for their design based on
exactly the same principle and so we see
this in design meetings all the time oh
I want it this way because that'll be
more concrete know if the other way will
be more concrete and you know it depends
on what you think the users mental model
is and we're providing a mechanism here
that will let you actually do an
experiment to answer that question to
provide a mechanism methodology if you
will for how to do user tests on AP is
to answer these questions and come up
with something that you know has a
potential of having a big impact on the
way things are used we've also done a
lot of studies of reverse engineering
how people understand code they're
unfamiliar with how many people here
have been on a project where they've had
to pick up somebody else's code pretty
much everybody so it's a universal
problem in real companies people tend to
stay at a company four or five years and
products last longer than that people
are moved around
projects and so it's a very difficult
task and the question is can't what what
is the why is it hard what are the
fundamental aspects of it that are hard
is there something that tools can do to
make it easier well you can't really
build a tool unless you know what the
tool is supposed to do for you and so
certainly the Y line is going to be a
really important tool for this but we
have other thoughts as well and so we've
done this very detailed study of a
fairly complicated architectural tasks
that we gave people to do in the lab and
see how they try to approach the problem
and we did both novice and expert
programmers to see what the difference
was and we came up with a model of how
people approach this task and they are
basically trying to discover a set of
facts about the code okay what is this
doing how is it working these are the
kind of questions they're asking so
they're seeking facts that will explain
certain aspects of it and they learn
things they critique facts so there's
something wrong with this code or I
wouldn't be looking at it either i'm
trying to add a new thing to it or i'm
trying to fix something they're trying
to explain things that happen either
things that they've learned or things
that they think are wrong you know what
are the implications or weather causes
they proposed changes and then they try
and implement them okay so we have a
model of what steps people are doing and
then we have a model of what information
needs they have at each level okay so
for each process what do they need to
know what do they need to look at what
do they need to keep track of in order
to achieve that task effectively and not
very surprisingly experts do a better
job at this and they're not all so not
surprisingly is that they are able to
come up with root causes you know kind
of abstractions of what's going on
compared to novices that basically just
look at the symptoms okay so they will
recognize higher-level patterns like oh
all this code is trying to make a cash
or this is the update you know mechanism
that's causing this to happen and things
like that so that this kind of confirms
our prior work that has shown this kind
of novice expert difference
but we also came up with a fairly new
model of what this information seeking
task looks like as a investigation of
what we call update paths so you're in
modern code there's all this you know
stuff that happens information flows
from here to there and a lot of what
you're trying to find out when you're
trying to understand code is how data
moves around when the user clicks on
something what is the path through the
code that causes eventually something to
happen on the screen when some data
changes on the network what happens
eventually to get it onto the screen and
you don't just want to know individual
ones you need to know in order to do a
change all the possible update paths
because if you change it down one path
you might break it down another path so
there's also two really interesting
implications about how you might
investigate an update and these update
paths and it turns out that today's
tools are really poor at helping you
understand update pass you there call
graphs but that tells you everything
that could possibly be called and they
immediately get really branchy and
they're pretty useless when whereas you
want to know after I click on this
particular you know object where are the
implications in that particular case and
they're very specific questions that
people want to ask you know what
implements this trigger when I trigger
this what are the implications or tell
me all the different triggers that cause
us to be happened and so forth and so
there we've come up with a set of about
ten questions that seem like they're
going to be able to give you lots of
great information about update paths and
we're optimistic that just like we did
for the y line we can come up with a
tool that will visualize the answers
have a menu of questions and allow
people to get the information they
actually need much quicker so I think
once again we're seeing this result of
doing a very deep and thoughtful study
of what programmers really do what they
really need to know
as a way of guiding what the tools
should do I have another student working
on something we're calling topes but
really it's natural data types so if you
ask an end user what type of data they
work with they're not going to say
integers and bullion's and strings
they're going to say you know people's I
have people names or dates or project
codes or you know social security
numbers things like that so suppose we
had a system where you could describe
the properties of those kind of data
okay what does a person named look like
well the problem with this and the
reason programming languages don't have
anything in them is that most you almost
all the rules are only sometimes true a
lot of them are have exceptions they
usually true or they're rarely true
things like that and so we need to have
the ability to say you know things like
area codes never end in 11 turns out to
be a rule that's true on the other hand
last names usually start with a capital
letter so that's not always true but
it's usually true and you know if you
see a lot of lowercase letters and
you're less likely to believe it's a
capital that it's a name and so using
very specific rules like this the system
can give you more intelligent error
messages it can help validate things and
you can cuss convert from one format to
another how many different date formats
are there well there's a finite number
Google's products do a fairly good job
of letting you type in freehand and you
know figuring out what you mean but most
other web-based applications require you
to use all these pop-up so they don't
have to do this conversion us you know
with this kind of tool it can do the
transformations for you if you just
describe what the date looks like and
another important point is that office
workers spend a lot of time taking data
from one place and putting it in another
they take it off of spreadsheets and
type it into web forms they take it off
the web and type it into spreadsheets
they take it off one web form and put it
into another web form in a different
format and so there's a lot of this you
know transforming data they take it off
of paper
or email messages and put it into forums
you know you can think of all the stuff
secretaries have to do or clerks and so
the question is you know can we help
automate that using this kind of tool
that can help you with the data and the
data structures and so another important
point is that we built this thing where
there's a calculus for describing these
and code to actually parse them their
works in both the web and Excel so that
you can use the same types across both
environments and we built an interactive
editor that lets that we've shown end
users can use to successfully describe
patterns that are more accurate than you
can describe with regular expressions
and other kinds of you know with random
code to describe how data is structured
and how to parse it so the study we just
finished that was sponsored by Adobe is
kind of interesting it's a little
further afield from what you guys are
probably interested in we were looking
at interaction designers you know people
who use flash and photoshop and you know
produce pretty user interfaces they also
producing you know most of the websites
and things like that and we're looking
at how they author interactive behaviors
and what sort of results people have
about why that's difficult then well
what people are doing with it 31 results
that was really the community took it
very seriously we got lots of really
good feedback and sure enough people
agreed that behaviors are a lot harder
eighty-six percent agreed that behaviors
were harder than the appearance for
prototyping probably these were
programmers didn't know how to draw not
very surprisingly virtually everybody
uses sketches you know to design stuff
you know when they're thinking about it
they use storyboards and a bunch of
other things wireframes site Maps things
like that flow charts but interestingly
everybody agreed that
those are not sufficient okay if they're
trying to explain the behavior to
somebody they take their sketch and they
write a lot of stuff on it or they take
their pretty photoshop painting and they
add all these annotations to explain
what all this stuff does right so the
pictures by themselves do not describe
the behavior it's all these annotations
that really have the information about
what the behavior is another interesting
thing is that if you think about
programming environments and what how we
talked about programming when I started
the talk the concept is you have in your
head what you want the computer to do
and the programming environment is all
about letting you express what you
already have in your head into the
computer that's not the way designers
work designers have a problem and have
no idea what the solution is until they
start working so they actually talk
about designing by sketching so they
aren't drawing the thing they have in
their head they're creating the design
as they sketch and the same thing as to
our behaviors they want to explore the
behavior but today's tools do not let
you do that there's no way to explore
ten different versions of something so
here she's saying maybe this one maybe
this one I don't know I'm just sketching
and trying to explore some ideas maybe
I'll cut this in half right so she's
actually you know very quickly able to
explore two different choices here how
would you do that with a behavior you
know you take two hours to implement one
version and then two hours simply
another one and how will you run them
side by side you can't even think about
doing that and most editors like flash
only let you have one window open a time
well that's kind of dopey if you're
trying to compare things so nobody's
really thought about how you might
incorporate this idea of designing
through the implementation designing
through the actual behavior creation as
a way of guiding what the tools should
do and how the tools should be organized
so that's one of the things that we're
proposing to do in the future is try and
think about how you might do that
another important point
because the designers are generally
producing their behaviors not as the
final implementation but rather as a
prototype so that means there's much
less requirement that it be really solid
and you know really you know software
engineering kind of working really well
so maybe this kind of exploratory
programming makes more sense in that
situation that it would in you know for
a professional programmer so I thought
there was you know some pretty
interesting results the other thing is
that the obvious way to make programming
it a lot easier is to say let's get rid
of programming or just give you a menu
of the 12 different behaviors you need
on their tools out there where you can
drag and drop a set of predefined
behaviors from the menu well what we saw
the designers saying is that won't do
they really need fairly sophisticated
behaviors they want to explore behaviors
in the same way they want to explore
what it looks like right so they're
fundamentally about making things you
know innovative interesting beautiful
and they want to apply the same
creativity to their behaviors as they do
to the look and if you think about tools
like Microsoft expression blend if
anybody has looked at that it
fundamentally says no you're not allowed
to do that expression blend 22 minutes
I'm so stop okay that you're not allowed
to do that you really fundamentally have
to separate out the behaviors and give
those to the programmers and the design
and give that to the designers so i have
this unrelated tool that i don't have
time to talk about which is really fun
it's a it doesn't have anything to do
with the natural programming project
it's just a search tool that searches by
association so the idea is that
sometimes you remember words and then
it's really good to use you know google
stuff and sometimes you remember where
you put it and then you can just browse
to it but what happens when you remember
oh it's the guy that I met at this
conference and he gave me a card and I'm
a card I wrote
this name and now I want to go find the
name or something like that so sometimes
you remember things by what they go with
and so feldspar is a tool that
specifically helps you find things by
what they go with instead of what they
are and so you basically and I've got a
really cute little video you make these
chains that eventually get down to
something you remember and by giving
this set of constraints it's built on
top of the google desktop it lets you
you know trace down where the where the
thing you're looking for is so i can i
have a three minute video of this but i
guess we have time to show that and when
we used it in the user study not very
surprisingly when we asked people to
find things by association you know it's
twice as fast well you know that's what
was designed for and sure enough it
works and people didn't have any trouble
using it so to conclude what is this
whole natural programming project really
it's about taking HCI methods and using
that as a way of guiding how to build
programming environments we do studies
first that tells us what to build we
build it and then we then we evaluate
the results and the result of systems
that really do work better thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>