<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>PyPy - Automatic Generation of VMs for Dynamic Languages | Coder Coacher - Coaching Coders</title><meta content="PyPy - Automatic Generation of VMs for Dynamic Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>PyPy - Automatic Generation of VMs for Dynamic Languages</b></h2><h5 class="post__date">2007-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GnPmErtqPXk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it is my pleasure to introduce four of
the ten or so current members of the
pipe I project by pi is a new gene
important open source project whose
contents will be briefly presented today
it's been going on for four years it's
got more than 100 contributors in
various proportions but somewhere the
padroni armand regal Laura Creighton and
Jacob Elena as much title as anybody to
be described as a core of the pipe I
project and so to be it's a pleasure and
an honor for me to introduce their talk
can you hear me hello can you hear me
can you hear me
oh hello can people hear me now okay you
hear me now
people can hear me down good okay great
wonderful hi by torturing for Jerry
virtual machines and it it's powerful
amazing but it started off with the
store shoppers somewhat small as witness
with a Python which gets me idea that
it's not about as an invitation with
Michael Ripley present and now it's a
has known but the original history and
motivations are fairly simple to
understand dynamic latitudes type in in
particular are considered to be have
problems in that there are trade-offs
you have to make between speed
flexibility and maintainability and we
know that I can ISM faster so that so
that's the compromise make England in
the skin the speed thanks a present is
actually fairly maintainable until you
decide that would be a good idea to
start running on say the Java Virtual
Machine or maybe like to run a botnet or
maybe you got to do something like that
and then weíll see park and
interpretation
from the community itself and while this
is a theoretical interest to some people
for the people the 500 it's a it was an
intense burning personal interest over
here we have Armand rigoberto which is a
hand written judgment at specialized ER
for see husband and every time secretly
moved and there were changed to the
language I don't have to do a whole lot
work to keep to keep the psycho and
already they are sitting down into the
top later someone at the brownie and the
time they rejected and every time she
came by he would have and not here is
one of the one of the other campers of
the projects and coop or they're from
different cities christened isner he's
produced a version of michael cult
status wisely because co routines it's
basically a great big patch that you
can't fight back to us to the sea
version hyphen you want this and of
course when the leg exchange he would
have around and have to make changes for
this too so for sure while maintaining
your own type of programs maybe reason
to say typing is maintainable if you're
actually between let's assume our point
of view it was a lot more and we'd like
to do something about that and the third
thing that you have to give up on or
make compromises wolf is flexibility and
we really didn't think the Python was
flexible and opportunity to suit us and
for flex of what we want to do things
like plug in our own garbage collector
and the tabot jet let's go here and
let's go there and let's go everywhere
and so what we sat down we sat down and
decided that we wrong what we wanted was
a python eats fast and if ison that was
a whole a lot easier to maintain and if
I thing that was really really really
really really really flexible and these
are rather ambitious goals but that's
what we wanted and so we decided to do
it and after two years working away at
this the European Union who puts up
academic calls and things like that for
all sorts of scientific research put out
one and we looked at it we found
something then if you squinted look
sideways look kind of like what we're
doing so we all excited that it would be
a good idea to get paid to do this
full-time so for tuefel for two years we
have been and have just finished being a
European Union sixth framework is T
computer science research project so in
addition so so in addition to be loose
from starting off as our own open source
projects like any other one thing that
happened to a bunch of
together and say let's do something we
ended up as big impressive important
research project and Iraq to being an
open source project and that's about
where the where the project ends today
so that's the history and that's the
motivation and I think we'll go on to
somebody else to give or start teach me
how to get it home and I talked about
compositional of our goals
selection
you have your program written in Python
which is submitted to the interpreter
written in C it takes it as its input
something written in Python the program
is written in C and it has as its
assumption a Python virtual machine and
POSIX as its platform to run off and
then it does whatever you want the
original program here to do next one of
these spy programs you can write is an
interpreter for Python which runs on top
of the original see interpreter for pipe
and that's what we've done so we have an
implementation of Python in Python of
course if you do an interpretation of a
program on top of an interpretation /
program this becomes extremely slow so
we're about 2,000 times slower than
ordinary C Python when running this way
and this is of course not practical
however what we do have is a fully
testable nicely implemented interpreter
in a high-level language and this is one
of the great benefits here but how do we
regain speed what we do is that we take
this same interpreter and run it through
a translation tool chain to produce an
interpreter in C running on top of the
POSIX environment in order for this to
work we can't use the full Python
because we're going to translate it into
C which is a static
typed language so we must be able to do
it type inference on this program so we
have something called our Python
restricted or reduced Python which is a
limited subset of the full Python
language which we can do this
translational and out of this we then
get an interpreter that takes a Python
program just like that the other Python
programs and runs them so this then
becomes essentially a replacement for
your C implementation implementation of
Python if we focus on the translator
this takes a program written in our
Python and translates it to see and it
in itself is implemented in Python this
is actually the big achievement of the
project because writing an interpreter
for Python in python is a relatively
simple thing while the translator tool
chain which yields the fast interpreter
is a lot more complicated
but when we do automatic translation in
this way what we can do is that we can
have plugins which generate code for
different backends so instead of
generating 4c and the POSIX environment
we can and we have done an
implementation for the Java Virtual
Machine where we have java bytecode and
the same thing for CLI and dotnet so
from the same source code we get code
for different environments so instead of
having to make totally different
implementations for the java like Jason
and for.net like ironpython we have the
same source code to start with and we
can expand this to other platforms we
have done experiments with small talk
scheme and you can imagine your own
platform you can do this on it is not a
huge project to make one of these
plugins the translator I said was
something that takes a program written
in our Python and translated city to see
or the Java Virtual Machine bytecode etc
it's really general so it can translate
any interpreter written in our Python
for whatever dynamic programming
language you like run it through the
tool chain and get an interpreter out
the other end indeed you can if you want
take any program written in this reduced
subset of Python run it through the
translator and get a C program out the
other end this can be useful for
producing a see extension module for
Python for instance and there are some
people who do that but it is not the
point of the pipe I project that people
should be writing things in our Python
this is only a tool for implementing the
interpreters really so to sum this up we
have a tool the translator which allows
us to take a number of different
programming languages and run them
through the translator and yield a
version of the interpreter for that
language on whatever platform you want
so we essentially get an end times in M
matrix of different interpreters we can
produce now we will make a quick look
inside the interpreter for the Python
language which has some interesting
architectural features we start with a
program implemented Python and like
other interpreters we run that through a
compiler and get bytecode out and then
we run this bytecode through a byte code
into interpreter and usually in other
implementations this is done in one big
monolithic piece of code what we've done
is that we've separated out the actual
objects and the operations on the
objects in an object space so the
bytecode interpreter here sees the
object space and the operations on the
objects as black boxes it doesn't know
what the objects contain and then we
have a clear API in here this allows us
to take this object space and exchange
it with another one with a different
behavior and it also allows us to put in
proxies for the object space which add
behavior or change behavior to the
original object space over here
and this turns out to be really really
useful for the flexibility of the
programming language an almond will now
show you a demo of what we can do with
this flexibility so this program here is
a version of pie pie that was compiled
into a big c executive so what you get
is basically something that looks and
feel like a regular Python interpreter I
mean it's hard to see the difference
basically there is one essentially
different that some of you have probably
noticed it's a prompt you have for
greater than sign instead of three okay
in this case there is another difference
this is a version of pie pie that was
compiled with a proxy in visions so we
have other the special capability
especial semantics as a language level
which which allows you to manipulate
objects that are computed lazily it's
exposed in this special module and thunk
is a function that means the lazy result
of calling a function so let let's
imagine that here write a function that
does some horribly complicated
computation that is going to take ages
like X plus 1 right but now if this is
going to take ages and if I'm not sure
that I'm going to need the result I just
want a result and pass it around then
maybe someone will inspect it then i can
say X equal funk f5 which works like the
apply function but doesn't really call
it an aunt in its necessary so now can
do things like pass it around get it
back okay on only if I do any operation
on why is value computed and by any
operation and mean really any operation
it is not something you could do in C
Python for example if you ask for the
type of why you're not going to get an
answer like oh I man lazy proxy object
or whatever no something is recomputed
on
the answer is really an integer a
perfectly regular interject so i'll let
you imagine what kind of feature you
could implement with this kind of thing
the point of this demo is also that to
implement this lazy object capability we
only had two wrote to write one of these
when of this proxy object space that's
about 200 lines of code in total in a
corner of pi PI it's not a challenge
everywhere in the source code as you
would need in C button and another demo
which is maybe a bit more obscure unless
you know already what stenting is is
well tainting CID is that you get some
data from some untrusted source and if
you mark the data as tainted then well
you can do basic operation with it but
basically the tainted value cannot
escape to unexpected places for example
if the tainted data is I'm just input
from the CGI form then you don't want it
to go to your SQL query before you have
done checks on it or for example it's a
credit card number and you don't want it
to end up in a log file by mistake or
these kind of things so in this case I i
can do basic operation with X but I
cannot really inspect the value on
tending propagates to any results like
this so I cannot inspect the value in
any way unless I am in a specific
position in the program where i know
that are going to get 10 v stains and
value and i know that here in my program
oh i agree to be here careful in just
these few lines of code instead of
having to be careful in the whole
program about what you do with the value
so where you want to be careful Yusei
untied and then you get the value on the
kind of cool things you can do because
it's Python you can say this so we know
it's zero ok but we cannot inspect it
then you can save this no explosion that
would leak information so then you can
save this
okay well what is V and the point is
that it explodes on you at the point
when you wear it try to inspect it on
the rd bugging ways to recover that it
was real 0 division error but it doesn't
leak information basically okay so with
this is also another proxy object space
implemented in 200 lines of code and on
the point of this is not what I don't
know how useful exactly this set of
features is the point is more that you
can go and design set of features that's
useful for you by extending this or by
using something similar so that's it for
the demonstration about the flexibility
we have in the interpreter itself and
now yakap will continue on the
architecture of type I we should also
mention that we have other things we've
done with object spaces like transparent
remote object invocation and transparent
persistence so now we take a look inside
the translator where we take an
interpreter like we saw before with a
compiler a bytecode interpreter and if
we're doing the Python interpreter we
also have a flow object space so we've
replaced the normal object space with a
specialized one in order to be able to
do flow analysis so we take the entire
interpreter we do flow analysis on it
and we generate a flow graph this then
goes through a step where we do type
annotation so we go through the entire
flow graph and we deduct what types
everything has and this is why we have
to write things in restricted Python
rather than full Python because full
python is too flexible for total type
deduction
so we're out of this we get a type
annotated flow graph which then goes
through a step called the art I / which
transforms the high-level types we have
here into low-level types for the
platform we are are doing so we have two
different kinds of trans translation
here one which goes for a c-like
environment which we use in the sea back
end and the llvm back end and one which
goes for object-oriented back ends like
the JVM and.net and out from this we get
low level flow graphs we can do
transformations to these low-level flow
graphs as well so thus tactless
transformation is one thing that we add
at this point and then we do two parts
of code generation we generate code for
an interpreter using the plug-in we've
talked about before for whatever
environment we've selected here and we
have another path which is optional
where we generate a just-in-time
compiler we're not writing a
just-in-time compiler with generating
one from the interpreter we've written
before and we add a garbage collector
and this is a plug-in framework so we
can select which garbage collector we
are and all this generates a pipe I
interpreter with Justin time up to
optimizations for the platform you've
selected in your back-end generation so
now we go on to some more demonstrations
so I have I have a couple of demos of
versions of pipe files that have been
compared with special features whereas
the special features have been
inserted during translation essentially
by modifying the low level flow graphs
of the interpreter itself so basically
we add features to the interpreter by
this regular transformation of the
interpreter while it's being translated
to see in this case so the first demo
shows bouncing balls so what this is
really is you have a while it sells
pugging as usual see patent process
running tie game that runs a pi PI sub
process and the pipe a subprocess the
pipe a subprocess compute the position
and velocities of older balls and it
does so the bypass the process was shown
is a stuckless enabled bypass the
process which means that it has
coroutine support so all the state of
the bouncing balls is in in one
quarantine and now I've stopped the
bouncing balls and what occurred is that
visco routing was serialized so I get a
file here this is a pickle file in the
python sense and the pickle file
contains the sterilized quarantine so
that means all the internal state like
the local variables on all this stuff is
saved in the pickle fight so it's one
line i say i want to save this correct
this court in here now you imagine that
a grease oil which is five kilobytes and
I'll put it I don't know send it over
the Internet or put it on a USB stick so
imagine a USB stick and say there is my
running program on this USB stick frozen
put it back in another machine and on
the other machine I can restore it and
you get exactly the same state restored
and you can continue from there so it's
a pickle that includes the ability to be
running programs or parts or running
program it's not a whole image it will
be larger than five kilobytes it's only
one specific coroutine so you can
imagine program with many co routines
when you send some of them around in a
distributed way
and under the pickle format is really
not an image is completely portable you
could reload it on a pipe i compiled for
the jvm for example and continue running
over there okay next demo is another
kind of transformation this is a version
of pi pi that is fully son boxed it's in
in the same sense as you would have an
operating system level sandbox which
which would prevent any which will
prevent the Python interpreter from
doing anything bad like accessing files
or doing consuming too much cpu or
memory this is exactly the same set of
capabilities with no operating system
support we just compiled pi PI 2 a.c
executable and in the sea executable all
the things that could be done shows like
coals to the open function of C for
example all these codes have been
replaced systematically with with
invoking some external controlling
process on the external controlling
process can do whatever with the coal
including giving including denying or or
giving a another answer well basically
get completes unboxing on virtualization
here I cannot write any Python code that
does anything bad to my machine here
it's completely impossible by
constriction an additional I cannot
inspect but things you see here if you
look at the last line that it pretends
to have only these two directories in /
because it's a brutal file system that
the outer controlling process is
presenting to the sandbox process and
blue and purple lines are debugging
information printed by the controlling
process so that we know what's going on
so with this was a feature that was
inside I mean that's again on the order
of 200 lines of code to get this result
now imagine if you want to do the same
thing in see if often you have to go
everywhere and even if you go everywhere
you're not sure it's correct because
well there are ways to SEC 40-person
maybe an attacker can exploit this this
is safe basically
so that's it for the demo now will let
some jalapeño Johnny sorry yes last
demo is the Jets generation demo here is
a completely arbitrary and borrowing
function doing nonsense stuff with
integers it runs on top of the normals
even in about 0.9 t 3 seconds per
iteration and with a pipe IC widget
enabled while you get the bugging output
but then it 10.0 14 seconds which is
about six times faster so we have a jit
that works well if your examples look
like this one under the key were working
on making it work well for any example
but a pointer should notice that the G
it works completely correctly in all
cases if you do if you do random stuff
like this sis get frame F locals and I
want to get the value of x and print it
or whatever this works you kill a bit
the performance by doing this but it
works this is an example where the
psycho doesn't I'm compiler would give
you just a warning and an empty
dictionary for f locales because it's
cannot do it so
so can we change yes well here x is an
integer so obviously I cannot but if it
were if you try something else with a
use different ads and yes basically we
get just some compilers that's correct
by construction in our approach and then
we have to work a bit to make it really
fast that is correct by construction at
any point in time which is another
result in sandwich and on Samuel
attorney is now going to explain a bit
how we can get this kind of effect is
this working yes now it is ok but I'm
going to talk about is indeed our main
research result and is indeed that we
start from this forest of flow graph
that the translation process produces
and now we generate a just-in-time
compiler from that versus having to and
write one and the technique that we use
are basically partial evaluation
technique there are is a paper from the
70s that says it theoretically should be
easy to take an interpreter and produce
a compiler the fact is Jesus kind of
hard especially because what people have
mostly try to do is generating a static
compile and the problem is that if your
language is a dynamic language usually
you cannot produce a good static
compiler because the important thing
when you try to improve the performance
of our dynamic language we still is to
be able to use runtime information and
feed it back into this compiler and to
achieve that you really need a dynamic
compile now the process that we use to
generate our compiler is we start from
the graphs of the interpreter that is
the intermediate representation that our
translation tool chain use and we want
to convert them into something that that
is able to do partial evaluation means
some value are going to be known at
compile time one typical example for a
dynamic language would be the bytecode
that we want something that would
constant fold in some sense interpreter
as given the bytecode as accounts
and the first things that we need to do
to be able to do such a transformation
is kind of to know the for the value
that flows in the interpreter which one
indeed are going to be compile-time
value versus which one are going to be
runtime bodies and this process is
called binding time analysis in the
partial evaluation technology and will
produce a coloring of the graph and to
do this we we use our we use our
framework for doing type inference and I
an important UFT strange terminology we
call the process of creative of
transforming the interpreting to a
compiler time-shifting because in a
normal interpreter the interpreter runs
at runtime which is the time at which
also the user program runs and near
instead we want to generate something
that will compile I adults of time the
program that will then run at runtime so
about the coloring the coloring the
point of the color mutual achieves that
we know we split the variable in the
flow graph in such a way that we have
green variables that are going to be
compile time values and we had red
values that are going to be run time
buyers and the process altis process of
generating the interpreter from from
going from the interpreter to a compiler
needs to be driven by a few int the
implementer of the ink of the day of the
dynamic language need to add a few in
some of the ins are needed in need to
drive this process or find the colors
one of the things that we want to
achieve here is for example to indeed
mark the bytecode and the places where
bytecode the right value flows into the
interpreter as compile time value so one
of the typical means would be to say
that the each single byte code that we
read out of the bite of the full byte
code sequence needs to be compiled a
compile-time value and from these
introduced we do basically dependency
sort of analysis and we find out that
the bytecode the full sequence needs to
be compile time and in usually the
program counter
needs to be compiled time to now once we
have achieved discoloring of our flow
graphs teasing use our coloring on the
operation to we are going to evaporation
that are green so the operands are green
too and the result is obviously green
then until this propagation is done when
we indeed do the time p inference to
find the colors and then we are going to
have read operation which in the inside
our operation on the red values what
will happen when we transform the
interpreting the compiler we are going
to get code in which basically the green
value are going to be compiled time
value so they are simply values instead
the red that the red values are going to
be runtime values which means when we
are going to run this commemorated
compiler we are going to use boxes that
are sort of placeholder that will tell
during the compilation process this
runtime value is going to leave in two
specific register or disposition on the
stock but then what it means what should
happen with this operation in the graph
when we do the transformation well this
here we have a simple example you should
imagine that his f is one of this graph
inside the interpreter it maybe even the
a value the graph of the other loop
function and in this case we have an
ecstatic green that would be the
bytecode and and I why that is read that
would be the runtime value for example
the argument to the bytecode that we are
analyzed and then here we have two
operation one is green and one is red
and then we have an operation that mixes
the two now the idea is that if we
transform this interpreter into a
compiler the first operation is green so
is going to be left unchanged by the
transformation the second operation
which is a multiplication is going to be
transforming something that instead of
being a multiplication is something that
is going to meet a multiplication for
the values that live in the position
contain in the placeholder why when we
compile now it means that if you take
the compiler that we produce from F we
will get this sort of result and you
should think
of these two as assembler code or
machine code and in the case that our
bike cause what was three we will get
this the first operation is not there
anymore at all because it's going to be
executed at compile time and is is
folded and so we get is nine here and
design right here but instead is one is
indeed is going to appear again because
the compiler contain instead of this
multiplication the operation please the
mitten a multiplication and this is
about the operation in the graph but one
important aspect in the graphs of the
interpreter is the control flow of the
graphs and now we need to do something
about that too in the transformation and
there are money one aspect here well in
the control flow graph you are going to
have decision point like ifs and artis
ifs can be on green value which are
compiled n value this is not a problem
such and if we'll just be left unchanged
in the compiler because the value is
known so we know which but we need to
fall but if you ever a decision point
and if on a red value we are going to
need to produce in the result of the
compilation both passed the true and the
false paths now as I said the comp the
generated compiler as a state where
white comprise and the state is mostly
the position we are in the compilation
process and all the value of the compile
time value and then all these boxes for
the runtime by use and what we need to
do if you have such an if is that we
need to to clone this state and
scheduling in our way both states such
that we are going to compile both paths
but the true and false paths of the
eighth and then an important point is
that the program of east which are
splits there are two parts out of them
but then at some point the problem the
program flow will merge again any at
that point we would like not to explode
because if you just continue then in
your the merging we will just produce
kind of exponentially produce a tree of
code so what we do is we have logic at
marathon that we insert we
receive this various state that have
been scheduled and what it will do we'll
use some kind of a unification logic to
see do you ever have already code that I
have produced for this kind of state and
in that case it will generate a jump in
such a way that we can reuse code that
we have already produced for a given
compilation state and Intel so means
that we don't have this explosion now an
important point that I that I introduced
when I started is that what I described
so far would be good if our goal what to
produce a static compiler then but with
a dynamic language so the result would
not be that good because indeed we are
not using any runtime information so
what we really want to be able here is
to have some kind of primitives that are
primitive that allow us to feedback
runtime information back into the
compiler and really get a dynamic
compiler that can use the fact that it
it is in a dynamic setting and we have a
running program from which we get values
that we can use to produce better code
that much is what's really happening at
runtime to do this our technique which
is similar to technique uses more
general in a more conventional dynamic
compiler for example for the GBM is that
and they're testing the sort of thing
are called polymorphic inline caches for
people don't know about them is to
generate some kind of open an open-ended
switch that we can expand and what we do
in the places where where we want to
indeed after the effect of promotion
from compile time to run time and this
promotional need to be inserted as in
two people the implementer of the
language need to go in places an obvious
place is usually the dispatch logic in
your dynamic language that's usually the
place where you have the runtime type of
your object in the program you want to
use this information to know what should
I do next which method is going to be
cold here
so that's our place in which implementer
of the leverage will put an inch in
which from one side from the point of
view of coloring you would get this type
and the type is going to be red and the
M promotion what it does it produce a
green value now when the compiler gets
to such a point where such an interest
placed is going to produce this sort of
expandable switch and the first time
around stop there and just producer the
full case that contain a call that is
going to call back into the compiler
with the value seen at run time now to
see something more concrete here we have
an F which takes two values that are
both runtime values and we have such an
interest I've described that takes one
of these red values and produce a green
value teases a promotion here and now
when we run the corresponding compiler
to generate code that we want them to
run the first time is going to produce
this kind of code you should think this
is going to be some kind of machine code
and so we get a switch onyx and on the
full case that is going to call back
into the compiler feeling it the runtime
value of weeks now we fee if we run the
teeth produce code we start running it
and the compiler stops here because it
has no idea what to do further because
it would really need to notice value at
compile time if you run it with three
which we tix being tree is going to get
here 53 back into the compiler and then
the compiler is able to continue because
now t61 is 3 and it can fold this
multiplication and a meter
multiplication forties one so it's going
to add a case to the switch which is the
case for tree and produce this 9 plus
the multiplication or why and why now t
shows some
code that doesn't really exist in the
fight on interpreter of pi PI but gives
an idea or what kind of concrete
situation you would use promotion you
should think these are two run time
values and they're going to be box
objecting in in Python for example boxes
for int values and then what what is god
here it implements indeed the addition
for in values if both Bach is the type
of both boxes is a man inte box a money
into object class then I can read out
the value from the boxes do the addition
and produce a new integer value man now
if you if you add what we can do here to
improve performance when we create the
the compiler is indeed two proteins that
will promote the runtime value the
runtime interpreter type of these boxes
which means that when the compiler
generated cost of DC with first track it
will generate two of these open ended
switches and then when it is for example
you really two integer without a check a
case to both switches that check if if
these classes are going to be the int
object class and if it goes through both
these cases and will end up here and
then is going to be able to simply omit
one additional instruction
now I'm going to show as an example in
which a practical example of this do you
want to do to do more because it well
our mean is going to do this part okay
so this this well we have a generator
that works when applied on the full pipe
I language but we have also written
small toy languages in which we can try
our generator of course so which is one
of the toiling wages which looks
completely unreadable it's just a stack
machine kind of thing you push for you
and you do multiplications like here so
this is a factorial yes answer toy
language the interpreter for this
language looks like this may need to
look around bits jit TL plc here it is
so it manipulates box subjects which
look like this it is a abstract base
class for boxed objects now you have a
sub class which is an integer box which
stores an integer value on you see
method for example here is here is the
add method how do you add myself as a
box with another book and there are
other features not used in this
factorial example which are these
projects which are council nil object so
you have more bite goes to manipulate
this kind of stuff so interpret I itself
starts here on you see well here is code
which is a string of byte code which
have been compiled in some way to hear
coda just a string of byte codes you get
the next byte code and you have if a
leaf well switches on the different byte
code that exists for example addition is
here if you ignore these two lines then
you can see here oops sorry you can see
here the addition it pops to object of
the stack call the add method and push
back the result
but as somebody described with these two
hints when we turn this interpreter into
a compiler we will the compiler will
generate code as text and promotes the
class of these two boxes and the result
of this you want to run the test or just
go to the cross yes no thing IBM I feel
it's a real bit of looking around ok so
if we now take the generated compiler
and feed its blood the factorial the
bytecode of the factorial function that
I showed in the slide it's going to
generate assembler code this is well you
have to think about this assembler code
actually we have several backends for
adjusting on compile it can generate
assembler for x86 for powerpc or it can
generate again this soda assembler which
is what we use normally do in debug and
inspect stuff around so here is as the
important point in this while you have
to think that this generated assembler
and in order to compute this factorial
its first this box here is the promotion
point this is saying I want to read the
type of my sauce I mean the factory gets
an argument so argument is with v6 6026
which is a box so i first read the type
of the box and for technical reasons the
type is cast to nim's just because a
switch well can only occur in an int and
twit is a switch which has only a
default case because we haven't
generated any code for I mean we had
seen any concrete value for the type of
his book and the default case contains
here in the middle a call to the
compiler so the generated assembler code
contains a code that goes back into the
compiler and feed this value here which
is so so value a switched on
feed it into the compiler and then comes
back to the switch looks like an
infinite loop but the trick is that the
compiler is going to modify this switch
to add cases when they are seen so so so
with initially generated code and now if
we really run this code by really
passing it a concrete integer value then
compilation will continue and it will
generate an extra switch an extra case
and we get this code and we can see here
what is the same as before but now there
is this extra case we fit integer values
that's well that's a integer value of
the pointer in memory basically is
address in memory and so this is all the
generated code below here is so the
thing you get for the case where the
input argument was really an integer box
on the first thing it does is unboxing
so reading the value of the integer
value out of the box and the interesting
point is then in all the rest of the
generated code now it was able to deduce
that all the objects were integers I
mean for the input argument it had to
check with this complicated switch
mechanism here but for all other objects
manipulated by the bytecode it could
deduce that they were actually integer
objects boxes because they were produced
just now just before by the previous
operation in the same function so here
we get where there is a bit on unrolling
but at the near the end if i zoom out a
bit you can see this loop which goes
back up here and down all this way on
this loop now contains there are a bit
of checks to see if the loop is ended
but then essentially it contains only
these two operation an integer
multiplication on that integer
subtraction as you would expect from a
factorial and this inter milan it served
it's really easy one assembly
instructions that says multiply subtract
so when you really compare this to
assembly you get really a multiply
subtract jump back check if I might
the end by this into jello is on check
if the contour smaller than one
basically exceed if it's so so basically
get excellent as some record out of this
and everything is completely unboxed
also a location on reading likely of all
the integer object that you would
normally have if you were to interpret
three factorial all this was completely
melted away and there is only one boxing
left here which is at the exit because
the answer is an integer which escapes
in some way and then goes back into the
outer world so you have to really
allocate it so we got so well that the
same that shows the techniques that we
use and we get the same kind of result
with with for example the f1 function
that I showed running on top of pie aunt
aunty yes that's why you get this kind
of incredible speed ups you get good
machine code and no boxing so no memory
allocation anymore you can we go back to
the first slide and we'll take questions
so that it this concludes this concludes
this talk and now I guess you can take
questions and an important point is that
the ins are introduced in look into the
interpreter not the user program doesn't
have in that we have seen f1 was simply
f1 f1 without in themes are for the
language implementer to add to the
interpreter yes so far we have added
about I don't know 10 20 hints into the
source code of pi PI and that's it it's
not also like we need to add tons of
hint everywhere it's just a limited
number so so the purpose is really
sudden it's possible to evolve this
language miss Python language to add new
features to it and we always have an
up-to-date Justin compiler because sad
very few hints to maintain
yes sir generated hint is correct by
constriction we have a trick that we are
using an advanced feature basically
which is the Python frame objects the
pattern frame objects have well have a
complicated virtualization mechanism
which means that they are they are white
sofas are really allocated on the heap
but they are kept empty and when the
beggars try to inspect the Python frame
from from code that is not necessarily
determine the degree itself is not
seeded obviously typically when you try
to inspect the pattern frame it contains
logic that can actually inspect the
values from the sea stack from the
system shots that supports the running
cheated god so basically we generate the
very friendly kind of tits out of the
box pi PI tracking the use me tracking
the C Python picture sir so how closely
is fight by dragging the sea baths and
feature set when so far we well the
answer is that it's extremely easy to do
so Anton in practice while we have
really the last two years or so focused
on the translation tool chain so we are
still at mostly at 2.4 versions with
some 2.5 features because simply d-will
showed up and wanted to add them but
basically the point is that it's easy
ok
suppose that's it so what is the plan to
get to something that people can
actually use in the word well I think we
are almost there basically I mean we
have a Python interpreter it's very
complete it's missing a few extension
modules but I mean things like sadly but
on most of these standard C extension
modules we have some so so we need a bit
more polishing basically that sometime
next year we should be really use usable
and for specialized use cases we are
already I mean if you are looking for
some books by PI interpreter just use it
it's here it's safe box so so I mean we
we want to be a more than just a
research project from the start that's
clear I'm Thunder oil it is available
it's an MIT license you go and download
it it usually works
well right now our own extension module
are written in our Python 2 we have
started to think to get a seat types for
pi PI we have some way to my we tried
for a while to use the kind of see types
definition to express out to to link to
see libraries now we have a slightly
different way based on our own internal
type system these low-level types that
we use in the grass and what we are
thinking next indeed to have some kind
of see types that application level and
for large library like googoo toolkit we
will need to think more because one
aspect that we don't support right now
is separate compilation soul extension
modular are compiled together with pi PI
at some point we will need to start
thinking about that which is mostly in
some sense fixing the API of the other
object space i started as well known
name for for the external model to link
with but are some terms that they have
well known name in the generated see and
once we have that I think you could use
we could go to tools like swig and
change them in ways that you that you
can get extension for pi by 2 there are
also some some very well not concrete
idea so maybe emulating the C Python API
in some cases but we are not sure we
want to go there because there are
performance trade-off you may get some
extension working but with the speed
that you would not like so there is not
much pointing into that but that's the
situation about ex extensions right now
ok
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>