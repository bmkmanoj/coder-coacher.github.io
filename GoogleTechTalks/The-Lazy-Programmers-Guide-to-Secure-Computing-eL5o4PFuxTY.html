<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Lazy Programmer's Guide to Secure Computing | Coder Coacher - Coaching Coders</title><meta content="The Lazy Programmer's Guide to Secure Computing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Lazy Programmer's Guide to Secure Computing</b></h2><h5 class="post__date">2010-03-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eL5o4PFuxTY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody I'm Mike Samuel from the
applied security team today to talk
about the lazy programmers guide to
secure computing is Marc Stiegler from
HP research he's going to be talking
about a bunch of techniques to get
towards decomposable security and he's a
great person to talk about this because
he's been trying to and you know with a
lot of success get that on two systems
as complex as the Windows operating
system as part of the Polaris Project
which you guys should definitely check
out if you're interested in computer
security and so mark thank you of course
the key today is to talk not so much
about security but to talk about
laziness it is it is a generally
well-known by everyone in the world that
security requires vigilance and that the
only solution for vigilance are to for
security is vigilance and you must
combine that vigilance with a variety of
special-purpose exotic api's with which
you write special purpose code that has
no purpose whatsoever except to apply
security vigilance here we are going to
consider an alternative we're going to
consider focusing on laziness rather
than on visual vigilance for one thing
laziness has a very striking advantage
over vigilance which is that you've
always got it available to you 24 by 7
so even at 3 o'clock in the morning when
the clock caffeine has run out you can
still be lazy even though you can't be
vigilant and we're going to combine that
laziness in fact the foundation of our
laziness is going to be simply using the
object or an techniques that you use
every day all the time so let's go on
we're going to divide this talk into
three sections we're going to show how
laziness appropriately applied actually
saw security problems at three different
levels of abstraction we're going to
talk about security in the single
address space the sort of security that
you need to run when you're doing a
matchup with several different pieces of
software from several different
third-party vendors who you do not know
how much you should trust we're going to
then look at lazy security across in the
distributed system domain including
client-server systems service service to
service systems and peer-to-peer systems
fine we will look finally we will look
at security in the medium to large
application and see how these same
techniques help make your your larger
applications more robust in the face of
serious professional attackers we have
one paradigm that we use to cover all of
these things and we're going to
introduce four rules of laziness along
the way now these are not the only rules
of laziness laziness perfect laziness is
a goal to be strived for and we will
never achieve perfection in the field of
laziness but we're going to take some
importance in that direction so the
first laziness rule is pretty obvious
even even programmers a very modest
success in achieving laziness know this
rule implicitly here we have a function
a function area receives an X and a Y
and returns the area of that rectangle
and now we're going to look at a hard
worker who is going to use that function
okay this guy is not lazy and what he
does is first of all understand that
this guy has a password and a Z and an x
and a y so what this guy is going to do
is he's going to invoke the area
function and he's going to pass the X
the Y and the Z and the password now
this will work it works perfectly fine
but it's not at all lazy
why is he typing all those extra keys
why he's pissed why is he passing all
those extra parameters that's working
too hard so any any sensible person
would of course just simply pass the X
and the y because that's all the
function needs now the decision to not
pass the argument Z is simply a matter
of laziness
but the decision not to pass the
password is not only lazy but it's
actually a security decision we have
decided not to cast the password to the
four winds okay so so here laziness has
has served the purpose of being more
secure and we run this I mean it's
obvious and you know we have we have a
rule for this in programming and it's
simply don't give an object something
that it doesn't need to do the job you
want it to do for you right don't don't
give it to them if they don't need it
now that rule is so special and so
powerful and so important in the
security world that it has a special
name it is called variously the
principle of least privilege the
principle of least Authority we practice
proper laziness call it Pola because we
use this concept so much on a daily
basis that we are too lazy to use more
than two syllables to describe it okay
so Pola now the print the idea of Pola
is very simple again you you get you
give the object or the person everything
that they need to do the job that you
want them to do and nothing else so this
is really power
is the typical razor's edge we're in to
the left of the razor tip you have the
area where there's not enough Authority
you haven't given the guy enough stuff
to get his work done and on the on the
other side we have handed the guy more
power than he needs to get the work done
now handing the guy just a little bit of
extra power is not a big problem
you know handing the z-value to that
area function would not have been an
issue but as you move farther and
farther to the right here you are
increasing the amount of abusable power
and now you're in trouble
meanwhile over here on the left hand
side since you can't get your work done
unless you do something radical like
engaging credential sharing and at that
point suddenly you leap from the left
hand side where you can't get your work
done all the way to the far right hand
side where you're getting your work done
but you have maximized the potential of
the other party to abuse you so I an
example is recently pointed out to me
over at HP there's a business achieving
some considerable success on the web I
am told this business does looks looks
at all of your gets the data from all of
your financial services aggregates it
and shows you beautiful views of your
financial situation and this sounds
really very nice and I would like it
myself except that in order to do this
for you
you have to give them all of your
credentials for all of your financial
services so they hit so they wind up
with full authority not only can they
show you how well you're doing but they
can change it for you okay now not on
neither I nor anyone who pays attention
to my advice is ever going to use this
service because of this gross amount of
abusable power that has to be granted to
them in order
give you this service so there's another
name for Pola and that name is maximum
business opportunity so now we have the
same principle playing out with slightly
different words to each of several
different audiences the security people
call it Pola the marketing people call a
maximum business opportunity we the
programmers just simply call it don't
give them anything they don't need okay
let's look at another example here on
the left-hand side we're going to use
the value out of a table so what we're
going to do is going to send that
function at the table and the index into
the table so that it can extract that
value and use it while it's there of
course we pass a whole table it's going
to grab up the password and why not
since the password is one of the
elements on the table okay
now an ordinary oow programmer would
never have this problem because the
ordinary yellow programmer would knows
that for modularity sake in this
circumstance you would not pass the
index on the table you would just simply
pass the element and so here we are
we're receiving the element and here we
are we just simply shipping the
particular element that we wanted them
to have so far so good again very
obvious a implementation of Pola for the
purpose of laziness and modularity okay
now I'm going to surprise some of you I
know this is going to come as a shock
but laziness is not always identical to
security okay and so here's an example
this is something that I myself have
done now suppose we have this table but
this time instead of using the value out
of the table we expect this other
function to actually update the value
you in the table and so now what we're
going to do is we're going to send in
the table and the index so that the guy
can write the new value into the table
of course he's still going to grab up
the password while he's there and he's
also going to corrupt our copy of the
password so that he can sell the
password back to us at a modest fee
later in the day okay no problem well a
serious problem but this is definitely
lazy okay so at this point we have to
introduce a new distinction and that is
the distinction between the professional
lazy programmer the guy who takes his
laziness very seriously and the amateur
lazy programmer the amateur lazy
programmer has a lot of trouble telling
the distinction between what is lazy
what is careless what is sloppy what is
thoughtless okay what will get him into
trouble the following day the
professional the professionally lazy
programmer knows that yes most of the
work that he could do today would
probably be wasted by the time tomorrow
came around but every once in a while
he'll look at something and say I know
that if I don't do this right the first
time you know I can do I can do this
right I can spend an extra half hour now
or I'm going to spend a week of agony
tomorrow oh I don't want to go there I'm
going to go professional I'm going to up
my game in laziness and I'm going to I'm
going to spend just a little time now
okay so now let's go back to that
example where we're updating that table
and suppose that we already know
professionally lazy programmers that we
are and I see a lot of laziness out in
this audience so I'm very excited to
have you all here the suppose that we
just know that the data structure is
going to be modified in the course of
the upcoming weeks it's probably going
to eventually wind up being
an update to a relational database but
we don't really know for sure and so
what we want to do is minimize the
amount of code we're going to have to
modify when this maintenance phase comes
around and bites us well in that case we
might want to consider doing something
different instead of passing in the
index and to the table what we might
want to do what we would surely want to
do in this case is pass in a function
that accepts a value and updates the
table here locally so that when the
modification to the data structure comes
rolling around I don't have to modify
the function that is doing the editing I
only have to modify this one line of
code okay now at this point once again
we have achieved the principle of least
Authority the guy this function that is
going to be doing the editing only has
the authority to update the specific
element that he's supposed to update and
he does not have the authority to
manipulate our password field so so this
is this is the professional version for
making your system more maintainable and
now here's the interesting thing which
is that this this version isn't any
longer than the first version so maybe
it was just as lazy all along okay okay
but the problem gets harder okay now
we're going to bring in a subcontractor
and the subcontractor is going to have
to do our editing function but there are
some important rules okay he's got to
only modify that element
one time and when he modifies at that
one time he must notify us well we could
just simply document it for him and pray
to the gods of programming that he pays
attention to the documentation we
actually have three different choices
here we could just give him the power to
manipulate everything which is in
security terms the moral equivalent of
giving him our user ID and password so
that he can do one little function you
know the same idea of I've got to give
him all of my financial credentials so
that he can read the data we could give
him two little functions like the ones
that we just saw the updater and the
notifier but he could still accidentally
forget to notify or he could update
twice or we could give him one reliably
correct function that does exactly what
you need him to do and nothing else this
is an example of becoming meta lazy
because at this point we are wise enough
as professionally lazy programmers to
understand that that other guy is lazy
too and in particular he's too lazy to
read the documentation okay so let's
take a look at what and how we might go
about solving this problem this time
we're going to hand him an edit function
again notice that even with these new
requirements we did not have to change
the the contract for the editing
function okay the the contract remains
the same okay very a very simplifying of
the maintenance problem once more the
red line here is the boundary in the
reliance set we in programming would
refer to this as the reliance set
wherein the things about the correctness
of our table depends on all of the
things that are below the line but
should not be dependent on the things
that are above the line in
security world this would be referred to
as the trust boundary okay so we're
going to come down here and we're going
to make again we're going to manufacture
an edit function that specifies a
particular element in the table and ass
particular listener who will be
receiving the notification here's the
guy who's receiving the notification and
here's the function that manufactures
the function that we're going to send so
what happens here is this this this
function maker receives the index on the
table and the observer it loads the
table into a revocable very into another
variable and it manufactures the
function which when it gets the new
value updates the table then sets the
variable to null so that the next time
the guy tries to do an update it will
throw a null pointer exception and then
finally it notifies the observer okay so
it's all packed in here now this time
you'll notice that I am sending the
index and the table to a separate
function which was something that I
avoided earlier this time I'm doing a
separate set of trade-offs one of the
things that has changed is that
implicitly earlier I was assuming that
the reliance set was within the
boundaries of the individual function
this time the reliance set and a trust
boundary is in a different location and
I've extracted it so that if I have
other functions down here that are also
going to have to send values up to this
guy they can simply reuse this function
maker so we're getting more reusability
down here inside our trust domain
so here we are in each one of these
cases we have implemented Pola but each
time we've implemented Pola for a
different reason that had nothing to do
with security so the first time we
implemented it strictly for the purpose
of being lazy the second time we
implemented it we implemented it for the
sake of maintaining object-oriented
modularity the third time we implemented
it we implemented it for the sake of
enhancing our maintainability and last
we we implemented it to improve our
reliability in the face of multiple
people and multiple organizations there
are so many different reasons for
implementing Pola in addition to the
security properties that we got each
time protecting the value of our
password and our other special data that
that one has to ask the question is Pola
really a security principle or is it
just a darn good engineering practice so
let's stand back and talk as if we were
security people for a moment as security
people you know I mean security people
through usernames and passwords huh
weird all the authentication go we never
passed we never set an Akal we never
passed an object ID and a password to
prove that my object was authenticated
as being the right object to be allowed
to send a message to your object where
where'd all the authentication go and
the answer of course is that we we
weren't doing all that kind of
authentication that security people are
famous for what we were doing was what
we refer to as authorization based
access control as opposed to
authentication based access control with
authorization based access control you
do not go around authenticating the guy
every 15 minutes okay instead
you authenticate him once when you hand
him the authority and once you've
authenticated him and handed him the
authority you don't have to authenticate
him anymore he uses the authority it's
all cool it's all cool it's good and in
that sense it is very much like the
object oriented professionally lazy
programmer it's not merely simpler it's
more composable and it's more Pola again
because it's simply object-oriented
programming done with a little bit of
extra sincerity so now we're going to
talk about the remarkable properties of
the ordinary object-oriented message
send but before we do that I'm going to
talk just briefly about the letter
envelope okay so here's the letter
envelope it's been under evolution for
over 2,000 years okay
I would like to see us achieve the same
quality of security as the letter
envelope in less than 2,000 years you're
welcome to join me in that hope so I'm
going to look at this envelope from the
point of view of my mother-in-law and
from the point of view of a security
guru so if you ask my mother-in-law why
the why the envelope is opaque well she
says so that the mailman doesn't get
confused with all of the writing that
would get in the way of him reading the
address okay
the security guy says oh that's your
encryption okay you ask my mother-in-law
so why do we have this flap that seals
down on the back she says so the letter
doesn't fall out the security guy says
that's my tamper resistant tamper
detection system on the front in the top
left-hand corner he asked my
mother-in-law well what's the stamp for
and she says so that the so the postal
office can get paid
the security guy says oh that's my spam
filter
and finally you I asked my mother-in-law
what the point of this little Clear
Panel is in the middle of the envelope
and she says snow that the mail guy can
read the address the security guy says
that's my principle of least Authority
grant of just enough authority to the
routing system so that they can deliver
the mail here is the very interesting
thing about all of this all of the
security in the letter envelope is
serving some other function in addition
to the security purpose and that is what
I have been showing you it down all the
way through here at every step the act
the the same thing that you had to do
for security was something that you had
to do for some other reason and if you
and if you do this properly then your
security disappears into the background
and people are not annoyed by it anymore
and people don't have to do credential
sharing anymore and everybody is less
vulnerable so now we're going to look
with our new eyes at the object-oriented
reference which is also very interesting
from a security perspective so here
we're looking at the object Alice
passing the foo message to Bob that's
carrying the argument Carol and we can
see it down here basically Alice is
saying Bob foo hears Carol okay
so what's interesting here well first of
all when Alice sends food a bob have you
ever worried that some other object in
the middle of the system was going to
interest was going to eavesdrop on that
message being sent and either read the
carol reference or modify the Carol ret
reference and maybe slip a Dave in there
of course not
that's not like that that can't happen
in
donated programming it's well in memory
safe object-oriented programming so that
is giving us the moral equivalent of
what a security guy cheese by encryption
when Alice sends the message food Bob is
she afraid that are you afraid that the
message will accidentally be rerouted to
Mike you know is there you know some
sort of centralized service naming
service like DNS whose cache can be
poisoned in the middle of your
object-oriented program and cause the
eart your the message that you're
sending to Bob to go off to Mike no okay
so that is what a security guy would
achieve by authenticating the recipient
and the only way Alice can possibly be
sending a reference to Bob is if
somebody else who already had a
reference to Bob has explicitly
involuntarily decided to give Alice a
reference to Bob which is to say Alice
is authorized to send messages to Bob
and manipulate Bob okay so we have all
the essential characteristics of
authorization based access control
embedded right in the object-oriented
paradigm you don't need anything else
alas doesn't work hardly at all and the
reason is that object oriented
programming languages all the popular
ones uniformly supply access mechanisms
that break the object-oriented paradigm
and in doing so they they discard all of
the cool security properties that you
have acquired for free in embracing oo
in the first place so JavaScript we had
a lot of fun with this I did a truck
review of this presentation for some of
the people who have practiced a hacking
JavaScript systems and this was there
was an argument about which one of the
ways of breaking the examples I've shown
you already would would be the most fun
way of presenting how breakable
javascript is this is one of them the
function area which is receiving only
the X and the y throws an error looks at
the stack extracts all the arguments in
the lazy user and grabs the password
alright so so it seemed real good for a
while there I have really good news for
you uh Google has been the leader in
developing a write rewriter the caja
rewriter for javascript that fixes all
of these violations of the
object-oriented principles in javascript
so if you feed javascript code into the
caja rewriter and it comes out the other
side rather than being rejected you now
have JavaScript that is doing two things
one is its enforcing the security
principles but the other one is the the
way it's enforcing the security
principles is it's simply enforcing the
object-oriented engineering best
practices that you depend on anyway so
so we have more than just kaha here
there are actually a lot of verifiers
and rewriters that are floating around
in the world
some of the ones that are amusing for
different reasons the caja rewriter was
developed by google the largest user of
it at the moment is actually Yahoo they
use a kata to confine all the widgets on
all of their pages the ad safe verifier
was also written for Java Script ax was
actually developed at Yahoo Joey
developed at UC Berkeley is a verifier
that enforces the same capable inferred
a
and there's a couple of exotic ones
there's a verifier for Oh camel and the
only reason why that one's very
interesting is that Oh camel runs at
approximately c++ speeds so if you need
to write code that has these kinds of
security properties that runs as fast as
c++ then you could investigate using oh
camel well okay so let's step back from
laziness for a moment and ask another
question and that is so you guys you
know you've been working for weeks
adding functionality to the software and
it's getting to be a grind and you're
looking over at the security guys and
the security guys have these really big
api's and lots of documentation that
they're reading and you're thinking you
know that looks like a lot of fun and
you'd like to do some security work for
a change of pace rather than just simply
uh you know implementing more
functionality for the users so so so is
there any way of having fun doing
security anymore when you move into this
this approach the answer is you're not
going to have as much fun but you are
going to have some fun one of the things
that you will need to do that's not
quite lazy is learning a little bit
about the various patterns of secure
cooperation that have been developed
across the course of the last couple of
decades for authorization based access
control now this is one here so here we
have and we have a slot maker a slot is
just simply a variable with a sub it's
it's an object with it with a value
inside you can set the value you can get
the value and here's the thing that
makes slots and thus law once you've
made a slot it is an authority right you
have read and write authority on the
slot once you have the ball once you
have reference to the object and one of
the things that you've got here is
object dot freeze okay we were talking
earlier about the fact that javascript
actually doesn't supply these properties
but kaha does object dot freeze is
method supplied by the caja rewriter and
if you freeze an object when you
construct it then you can't do any of
the really funky things to that object
that will bust it open and steal its
private variables so that's a very
important piece of making this all work
right in JavaScript the anyway so here's
the slot now suppose you want to hand
somebody a revocable authority to that
slot
here's a general-purpose revocable slot
maker so you hand this guy a slot it
returns a frozen object that has a set
method and a get method that's simply
forward to the inner slot and it
includes at the end a revoke method when
you invoke the revoke method it sets the
slot to null and thereafter any
attempted to do a getter asset will
throw back a null pointer exception okay
so and then then you can make a
revocable slot simply by making a slot
and then making an invoking make
revocable on that and now you've got a
revocable slot you can mix and match
these things if I hand you a revocable
access to my slot and you want to turn
around and hand a separately revocable
access to my slot to somebody else you
just simply wrap your revocable slot
with another revoke ur okay hand it off
to the next guy and now you can revoke
his slot separately from revoking your
own slot access okay
onward to let's let's let's see how this
works when we go distributed so the
first thing we're going to do to
implement these same principles in a
distributed context is we're going to
reproduce the virtues of the
object-oriented reference in the
distributed environment
so you'll remember that the marvel of
object-oriented references was that
there was no man in the middle the
recipient was authenticated in the
sender was authorized so here we have
two examples of web keys the input let's
see the couple of the things that the
two kinds of web keys have in common
they're both HTTPS so they're encrypted
so there's no man in the middle attack
the other thing is that the actual
resource has an ungainly way you can
find and access that resource is if
somebody who already has access to the
resource explicitly hands you a
reference to it okay just like in the in
the object-oriented shared memory case
and so we know that anybody who can
reach the resource has been authorized
the thing that separates them is let me
talk about the is that with the simple
one you use some random standard domain
name and you depend on a certificate
authority to assure that if somebody
goes there and there's some DNS cache
poisoning going on that that the
certificate authority check will throw
up the exception dialog box that the
user can then click OK on on the other
hand so that anyway so that's one
version of the web key in the other
version you actually embed the
fingerprint of the public private key
pair for the service that hosts this
authority right there in the in the URL
and this is I refer to this as the
professional version because in the
professional version here is for people
who are too lazy to coordinate their
activities with a certificate authority
ok the user of the
professional version here can use
self-signed certificates in one of the
applications that I built they use this
we were actually building a system where
we were putting servers on every
individual person's machine indeed we
were putting individual servers with
individual sort of certificates on every
machine for every user and so attempting
to so being able to sell signed
certificates in that in that system was
not merely a matter of being lazy it was
a matter of being able to survive okay
so in any event the in either of these
cases either the certificate authority
or the fingerprint is ensuring that the
Sippy n't is authenticated and now
you've got all the properties of an
object-oriented message send and these
are the professional version of the web
key is implemented on the water can open
source platform if you're interested in
playing with these things go out and
check out that site or I asked me or I
asked Tyler close yes as part of the
domain is a fingerprint yes it's the
fingerprint for the public private key
pair of the that is being held by the
server by the service that holds the
resource so what happens is you you use
the fingerprint to challenge the guy to
prove that he holds the private key only
if he proves that he holds the private
key do you then reveal the the name of
the resource so here are some examples
of Java code in the water consistent
water can platform is Java based and we
have reproduced the slot example that we
had done earlier in JavaScript so over
here on the left hand side we have a
slot with a get and a set in the middle
in the far side we have a revocable slot
that it is both both of the types lot
and is also of the type revoke er so it
has the get and the set method and the
revoke method and works approximately
the same way in the middle we have a
read-only version of the slot which when
given a slot what it does is it forwards
get requests to the inner slot but it
throws an exception when you try to do a
set okay and so this is a read-only
version and again you can mix and match
these
okay these you can build arbitrarily
sophisticated compose dynamically
composable security policies out of
these simple building blocks so let's
take a look at this for a slightly
larger example this is digital money
okay it's digital money secure that fits
on a PowerPoint slide I'd like to see
other implementations of digital money
that fit on a single PowerPoint slide
okay and and we come down here this is
based on the purse protocol a protocol
was designed for authorization based
access control systems uh like ten years
ago and the basic idea is that I have a
purse and I can withdraw money if I
withdraw money from my purse I will
create a new purse and put some of my
money into that person then I can hand
that second purse to you and if and then
you have a purse and you can deposit the
money from the purse that I handed to
you into your person now it's your money
okay so that's the purse protocol for
doing digital money and so we have a
purse with a with a balance and we come
down here and so we've got the three
methods we've got get balance which just
simply returns the balance this is all
done in
again in a waterken system we're
returning a promise for an integer for
reasons having to do with the way a
water can server returns values over the
wire it has nothing to do with our
security discussion let's see and we've
got the withdraw method which
manufactures a new purse with some
amount of money in it and returns the
new person D ducks the appropriate
amount from our balance finally we have
the deposit method which receives a
purse we deducted the appropriate amount
of money all the money from the purse
that we received we set that purse to
zero balance and then we add that amount
of money to our purse so where's the
security in here well you know I looked
at this and I thought well there are a
couple of things that look suspiciously
like security one is is these assert
statements I've got this assert to make
sure that the amount of money is less
than the balance and more than zero and
a security guy would say well that's to
protect you from the malicious attacker
who is going to try to corrupt your your
money supply but you know what I look at
that and I say well I'm just trying to
make sure that the program runs
correctly okay a similar lady down here
we do another assert this assert is to
make sure that we didn't do an integer
rollover we're using pure integers here
so if we if we were met you if we
managed to build a system that had
enough money put into a single / so that
rolled over you'd have a you'd have a
problem again an attacker might try to
attack that but I need to fix it so that
it's correct
the closest real thing to a security
item is when I take the purse that I've
received in the deposit and I cast it to
a concrete type rather than an interface
type
before manipulating it now huh
the security guy says the reason you're
doing that cast is so that is so that
you know that it's a real persons not a
forged purse okay but the other reason
for doing that cast is I was too lazy to
put a set balance method on the purse so
that I could manually set the balance on
the purse interface type and this
actually takes less code then doing it
the other way so yeah it's security it's
also lazy because it's less code so
let's take a look at what this stuff
looks like when it's brought out to the
user okay now at this point we're into
the sing-along part most of you received
I handed out authority at the beginning
of this session okay it looks like Mike
has one left so in any event so so this
is the sing-along part I have given you
two authorities and one of them will be
be looking at both of them right here in
a moment
so I'm going to come up here into my
secure block bookmarks and I'm going to
pop open one of my web keys I'm going to
pop open this purse okay
did you catch me typing in my user name
and password which I had forgotten okay
so I'm going to withdraw some money from
my purse so I'm going to withdraw 14
credits and here's a purse with 14
credits in it
and I'm going to show you that has 14
credits in it because I'm going to open
it in a new window there it is and it
has 14 credits in it and now I'm going
to withdraw 7 credits from that ok now
I'm going to deposit that into the first
purse ok I mean questions about how that
works everybody understand why that's
actually a secure transaction ok so
anyway let me move the rest of the money
back up here every time I run this demo
I run the risk of leaving some money on
the table ok and so in any event so
that's the purse demo very lightweight
digital cash yes what what's that you
try to deposit the same first twice oh
did I okay and it didn't work and it
didn't work isn't that satisfying
well that was a sweaty moment ok let's
see you won this okay now here's the
other well here's here's my authority
I've given you all an authority we will
look at in a moment on one of my servers
this is the share shell this is an
approximation of a bash remote bash
command line it's a serves approximately
the same purpose as SSH it's not
actually quite SSH but you know it
serves much the same purpose and I'm
going to come down here and you see that
I have this field where I can type in a
command a shell command and it'll come
out and it'll pop all that stuff up for
me ok so now one of the things that I
have here in my shell in addition to a
place where I can type in arbitrary
commands I
so have a list of quick commands so I
can come up here and just simply
allistic come up here and run a command
there we have it and so far so good now
let's take a look at how I manage this
this is my this is this is this is the
attenuated authorities this is my Maya
window for creating and managing
attenuated authorities for other people
on my HP server so here we have two of
these things one is a Thor ''tis I hand
it to Allen who is a guy I work with I
don't trust him hardly at all he's
sitting right here in the audience and
so I gave him very limited authorities
far less than I'm giving you guys and
and here's the authority that I hand it
to you guys so anyway those of you who
have the CD can just simply click on the
link and bring this puppy right up and
now you can come over here and you can
do a listing on my home directory
anybody see anything interesting here
root password text that look like fun
fun stuff I have a twenty dollar bill
for the guy who can tell me my root
password okay so yeah you can see it but
I seem to have forgotten to give you the
cat command on the root password dot txt
even though I did give you a cat command
on my log file which we can sort of see
down here okay so now suppose that you
want to turn around and attenuate this
even further for somebody else you can
see I already did this once but I'm
going to do it again so so I'm going to
delegate super limited super limited I'm
going to make a delegate it gives me
this new authority down here and what
I'm going to do is I'm going to come
here and I'm just simply going to delete
a bunch of the commands okay now I can
handle this authority to somebody else
on the only commands they can run are
these three commands I can come back up
here and I always have a clear
visibility into what authorities that
I've handed out if I were doing this for
real I would have said in my my note
about this who I was giving it to as
well as how limited it was and of course
I can revoke it simply by going in there
and pressing enabling revocation and
pressing the revoke button okay so
anyway so that is our attenuated shell
that's what it looks like when you use
this kind of stuff at the user level
I've been able to use this one of the
more amusing things that I use this for
is I've been able to give my I have
another server that goes down
occasionally so I was able to build an
attenuated attenuated shell for my
administrative assistant that allowed
her to relaunch the server you actually
have that authority there on your
version the ability to relaunch my
server so if you press that by accident
you may be relaunching the server that I
needed to bring back up anyway so thank
you and so she can do that but you can't
bring it down and neither can you
okay
okay let's go on to how this works in
larger applications this time we want to
talk about another interesting
characteristic of Pola okay
people like to talk about
defense-in-depth Ola is the ultimate
poster child for defense-in-depth
we have through these examples that
we've been running here we have been
achieving Pola at the object level of
granularity okay man are you getting
depth of defense when you use Pola at
that level so this is a very rude and
crude picture of a system that I built
scoops the secure cooperative file
sharing system it's a peer-to-peer file
sharing system that the closest of
things similar to it in the world is
Microsoft Live Mesh the difference is
that you need a giant server farm to
store all the data and Live Mesh so that
the government can come in and read it
all and in scoops it's all peer-to-peer
there's no central server so you don't
have either the expense or the central
point of failure or the the central
point of vulnerability let's see and
some of the pieces here we use a mailbox
metaphor actually one of the little
things that you get when you set up a
scoop system is you didn't get a secure
mail like system we're not using SMTP
it's got it uses the mail metaphor and
it's secure basically you send an
attachment in an email and when the guy
saves that attachment someplace when it
whenever either one of you modifies that
file and saves your copy on your machine
it automatically updates the other guys
I don't care how many firewalls are
sitting in between you and so here we
have this is an application built on top
of the water kin
framework so here we've got the
application framework kernel water kin
which is running at full user power and
it invokes the the the part of scoops
that launches at the beginning that you
can think of it as the main and it is
granted all of the authorities that that
the scoop system needs and then that
main starts handing out only the
authorities appropriate to each one of
the things that it invokes so the
powell's manager has references to all
the PALS which is a pretty pretty
powerful authority but the PALS manager
does not have authority to reach the
file dialog box which is able to confer
to one with a user action the authority
to actually read or write a a file at
some location of the users choosing in
the users a space and then the pal
manager has a references to all the PALS
the individual pal doesn't have a
reference to much of anything except the
out channel and the end channel for the
particular part for the particular
person who is that pal the only part of
this system that's actually exposed to
the outside world with a web key pretty
much is the in channel so that makes the
natural attack that makes it a natural
attack vector the only two real points
of exposure for this system are the the
Palin Channel and the the at that you
know basically a lower-level attack on
the application framework and the
operating system in the tcp/ip stack and
that's a possible attack but these are
all the parts that are are worked on
once very carefully and then hosts a
large variety of applications
the waterken server in particular went
through a week-long immersive review by
a team led by David Wagner so it's
pretty secure as such things go on the
other hand the entire scoop system was
written by me all by myself
no one's ever reviewed it okay you
expect
this to be the vulnerable part so so in
any event so the problem here is that
this being the vulnerable part means
that you've got to go traipsing through
here in order to be able to get any any
power out of it the only thing that the
the in-channel has the authority to do
is to light off the notifier for the
email manager with a notification that
mail has arrived okay now let's look at
this the way software normally works and
I'm going to be using models that are so
simplified that they make my point too
well and so after having made my point
way too well I'm going to back off and
tell you the truth okay so this is a
picture of the way most software
normally works this is a this is the
normal simple model of the way software
works which is that all of the objects
in a software application are loaded up
with enormous amounts of authority okay
they all have great excesses of abusable
Authority and so basically breaching any
one part is as good as breaching any
other one part and that is the basic
model that Ross Anderson used to prove
that security is impossible for economic
reasons okay and so basically so you've
got this series of pieces that you can
reach more or less running through here
and you've got a twenty if you've got a
twenty percent risk of the guide finding
a breach in each one of these major
pieces by the time you've ordered them
all together you've got a sixty three
percent probability of a breach okay
you're basically you're screwed now on
the other hand let's take a look at this
when we're running it under Pola
defense-in-depth
and now all the really hot authorities
are back here in the application
framework kernel even breaching the main
doesn't buy you a lot of exciting
authorities
so and so what you've got to do is
you've got to breach this guy to the
point where he will breach this guy to
the point where he will breach this guy
breach this guy and finally reach this
guy in the last picture we ordered all
of those risks together this time we get
to end them together and the consequence
is if you and all those 20% risks
together you get a point zero zero eight
percent chance of a breach now like I
said it's not actually this good however
here are some things that I'm starting
to be able to say with more confidence
having built scoups is now the largest
system I know of that has been built
basically following these principles
it's got about 15,000 lines of code I've
done some informal assessments and it
looks like somewhere between around 60
the way I wrote it about 60% of the code
just simply does not have enough
authority to be dangerous and you don't
ever have to look at it and by just
changing a few things about my coding
style I could have lifted that up to
about 80% at that point where where 80%
of the code simply does not have enough
authority to be interesting you're
looking at getting a factor of 5
increase in the value of the dollar that
you put into security review because
your only review you only have to review
20% of the code we have we have
experiences pointing in this direction
going back to the beginning of the
century when David Wagner did a security
review of an earlier system and you can
read his review in which he talks about
this this very interesting
characteristic the next interesting
thing is under maintenance you get a
reliable improvement in security as you
move forward the reason is
that in general under maintenance you're
adding lots of new software out along
the edge and along the edge it turns out
that the software generally needs very
little Authority so you're adding a lot
of code that doesn't have enough
authority to be dangerous while
meanwhile you're fixing the security
vulnerabilities in the inner core and so
you're reliably moving forward it
actually does get better finally okay
even though you're not going to get to
the kind of whopping improvement two
point zero zero eight percent risk of
security breach I was talking about
earlier you're getting a big improvement
this is no longer low-hanging fruit and
last but not least even though it's not
not as big as a point zero zero eight
percent risk it is a fundamental change
a fundamental change in the rules
governing the relative advantage of the
defender and the attacker
so here's rule number four do not play
by the enemy's rules you know I had
seven delightful years during which
every year for some different reasons
some different organization would asked
me to write viruses and it was
satisfying work you could always tell
that you were making progress because it
was so easy uh but every once in a while
I think so why would I what would I do
to make it easier for me to attack a
system you know what sort of propaganda
would I try to bring watch programmers
with to make my job easy and I came up
with a number of very interesting
strategies the first one would be to
tell people to use C and C++ for their
code okay just a delightfully hazardous
language a very satisfying opportunity
for the attacker I
particularly make sure that they
understand that automated garbage
collection always causes terrible
performance problems and causes your
program to pause for seconds at a time
in the middle of the most important
operation and in that so it is
consequently utmost important to use C
and C++ anytime that you're writing code
that has route privilege okay okay
these are really important rules to help
the attacker I would as an attacker
embrace complicated security toolkits
subtle api's with lots and lots of
features I would join the committees and
help them add new options that are
subtly different from each other to
maximize the confusion in the mind of
the programmer giving me more
opportunity and of course I would make
sure that the security software is
something that you write separately from
writing the main software that does the
work and encourage the programmers that
since it's being separate why they can
write it last and they can slide it in
as a module I would not mention that the
place where you slide it in is as a
module right between the quality module
and the reliability module I wouldn't
mention that part uh-huh and I looked at
those rules and I thought wow we're
following them are we are we the victims
of a conspiracy did we do this to
ourselves well so we need to take we
need to take a page from Buffy Summers
and james t kirk okay james t kirk
Kobayashi Maru okay what he did was he
changed the rules so that somebody could
win the unwinnable game Buffy Summers in
season three her her her mother makes
the criticism that every security person
needs to pay attention to okay at one
point in season three Joyce says to buff
me but what's your plan you go out
everyday you kill a bunch of bad guys
and then the next day there's more bad
guys you can't win this way you need a
plan and finally Buffy and the last
episode of the last season comes up with
a plan she changes the fundamental
physics of her universe to permanently
favor the defender what could be lazier
than forcing the other guy to play by
your rules
okay laziness it's not just a good idea
it's a requirement because laziness will
stand by you it will be your friend no
matter what the circumstances but to
submit but to make laziness really work
for you to really rise to the top of
your game in the laziness field you need
to be using the right tools and in
particular you need to be using tools
that fully support laziness notably
tools that turn OOW best practice into
enforced security tools like kaha and
Joey and the water kin web key you need
to learn a little bit about the patterns
of secure cooperation and there are
documents that you can read or you can
ask me about these patterns and you have
a number of people now here at Google
who are experts in these patterns as
well and above all you have to make them
play by your rules don't don't play
their game anymore it is time to stop
working so hard
let us work securely instead thank you
what questions does anyone have
hi-yah I have two questions the first
one if you go back to the slide where
you're talking about anding the risks
together yeah um are you assuming that
somebody can't attack the framework
kernel directly because otherwise how
does he risk it below 5% oh the reason
why the framework kernel got a lower
risk factor on this slow notes are in
the next slide oh where you get the
point oh eight percent chance of breach
why isn't that a 5% chance of breach
because I can just attack the kernel
directly oh the the so there are two
ways that you can attack the kernel one
is by doing a direct attack on it
externally okay which it's pretty
resistant to because of the security
reviews that's that's one kind of an
attack you can do the the application
that running on top of it has ways of
interacting with it that are different
from what you can do from the outside
your ability to just hammer it from the
outside is really very limited right I
mean all you can do is submit things
with web keys that are bad web keys and
see if you can expose some sort of a
failure but if you can actually cause
the main to to make calls of your
choosing on the framework then you're in
a better position to try to exploit
something so yes there's there's an
attack vector for attacking the the
framework directly from the outside and
I'm not talking about that part I'm
talking about you know the extra
vulnerability that you get by coming
down through the very poorly reviewed
application running on top of it okay
the second question I had was if you go
back to your secure person 'pl yeah
is it possible to corrupt the integrity
of the purses by subclassing the purse x
class and passing in something with a a
negative balance that you've constructed
um the like what said I call it deposit
I hand you my own subclass a purse it's
got a negative balance right uh what we
have one of the things that I didn't
mention although I did put on the slide
is that this is actually only
this particular implementation which
fits on a PowerPoint slide is only
secure if you run it standalone on a
separate on its own waterken server in
its own JVM and so nobody is in a
position to manufacture a new subclass
of the purse if you're going to if
you're going to do something like if
you're going to run a purse in a shared
memory environment with other things
going on
you need to do a fancier version of this
you can go read the original document on
the purse protocol published in
financial cryptography 2000 or 2001 so a
basic idea of what you're saying is that
is that that line 34 where you're
casting to the purse says no this is
really a purse it isn't a subtype or
something masquerading as a purse yes
okay yeah I know that because of the
rules that I set up for this particular
example okay thanks and again there
there is a there is a solution that does
the that does the job more generally but
it didn't fit on a slide yeah hi mark
one of the hobgoblins that you didn't
directly address is the hobgoblin of
Singleton's and more generally mutable
static state yes mutable static state is
a bad thing I know that in Joey for the
Java verifier that ensures capability
security it will reject programs that
have static mutable state I would hope
that you can tell me what kaha does with
this well it's not really a question of
what caja does but I'm trying to address
your issue about the laziness mm-hm
so generally it is fairly true that
programs written with mutable static
state can be far lazier to write the
programs without in the amateur it's far
more amateur it so lazy in the immature
sense it does not merely violate
security principles it also violates the
design mental object-oriented design
principles which actually protect
professional levels of laziness right
the problem that we get though is that
what the argument that one makes to
people is to say things will be better
in the long term if you adopt this good
practice now the history of human
enterprise over the millennia is that
people do not look out for their long
term interest they rush in foolishly and
deal with the miseries later I mean I'm
just presenting this as one of the
foundational problems that the things
you are talking about or up against
right it's something that comes up again
and again and and I think it has more to
do with human behavior and yeah yeah
well all I can hope for at the moment is
to see this group of people who look
like they're pretty lazy to me you know
raise their game into professional
levels of laziness okay and leave it
there amateur status is behind and go
for it
okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>