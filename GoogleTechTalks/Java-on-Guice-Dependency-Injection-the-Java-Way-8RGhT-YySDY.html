<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java on Guice: Dependency Injection, the Java Way | Coder Coacher - Coaching Coders</title><meta content="Java on Guice: Dependency Injection, the Java Way - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java on Guice: Dependency Injection, the Java Way</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8RGhT-YySDY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to our talk it's called Java
on Jewess Tsinghua means Java on juice
dependency injection that Java way I'm
Bob Lee
I'm Kevin Burley not ok so first off
does this sound like you are you ever
known to be caught saying to your
friends at lunch my application is easy
to unit test
I don't worry about dependency blow my
code is clean it has high
signal-to-noise my test never
mysteriously fail when run out of order
and I don't think I will have any of
these problems either if so what the
heck are you doing here you're in the
wrong place go outside enjoy yourself
this seriously cannot have much to offer
you know yeah go buddy oh no ok we're
going to talk about what juice is and
how you use it and that's pretty much it
and I'm gonna progress the slides
that's what do you think ok any
questions ok good so we're done actually
no wait the reason that was there is
because I wanted to point out that we
will take questions as we go we have
tried very hard to make sure that we
fill in all of the logical you know
we're trying to take you on a nice
logical journey here from the simple
through to the complex so if we miss
something I got to stop doing that so if
we miss something then we would rather
hear from you so we can fill in that
hole rather than keep on going and have
you just be totally lost
speak for yourself I'll take all my
questions at the end ok I'll be doing
all the questions in flight and I know
that everyone always says like you know
I don't want to ask a stupid question
and you know like the speakers are
always supposed to say there's no such
thing as stupid questions but we all
know there's such thing as stupid
questions and I'm here to say please ask
us stupid questions ok there's so much
easier to answer okay so this
that if you could just ask us the stupid
ones then I can answer those you guys
hard ones got to go to Bob that'd be
great
yes I gotta think about that so that
makes it a really good question though
the question was I had to repeat the
question was is this a stupid question
and I don't know how to answer it so
it's a very good question I should give
a prize for the stupidest question all
day free copy of juice oh okay he's
making yeah because I wrote the slide so
I have to say it so here is one angle to
look at what dependency injection is you
can come at it from a couple different
angles and maybe one of these angles
will work for you more than others
here's the angle that we're coming at it
today the fact of the matter is that
static references have problems they are
can be useful because sometimes you
don't know any other way they do it but
they make your code very tightly coupled
you have one piece of code in one module
that's depending not just on the
interface but on the implementation of
code in another module it's not very
polymorphic or object oriented you're
sort of a restatement of the bullet
before it's also very global if you have
a static reference that you want to be
available outside your package at all
you therefore are publishing it to the
world there's no such thing as like
these are the people who are able to
obtain instances and these people aren't
they just reference your class and there
they go and really the big one for me is
that it leads to all or nothing' testing
if you write some code and you want to
test your code guess what you're testing
the connection all the way back to the
database across all these chains of
static references because you really
have no other way of doing it the
biggest problem is that static
references force you to use other static
references with force you to use other
static references it's viral in the bad
way not in the YouTube way and someone
coined this term static cling whoo that
was actually it gets on you
get it off like the saran wrap okay Bob
whatever the next one is you're given so
I guess the idea is what if we right now
with plain Java you really have no other
choice but to use static if you're just
trying to do plain java so what if that
wasn't the only option and that's what
juice is going to enable and I kind of
like to think these things in concrete
terms so how many of you have written a
test written it's unit testing at some
Stata or against some code which used to
static factory and you have to pass in
up one you have to pass in so you start
off the unit test you remit the existing
implementation of that static factory
and then you pass in your mock
implementation then you run your test
and then you have to remember to pass in
the original implementation again at the
end of your unit test right what happens
if you don't do that anybody if you
don't remember to restore the bad things
bad things if you run your tests out of
order your tests interfere with each
other sometimes they fail sometimes they
don't and also it results in a lot of
boilerplate code and it just adds
friction to writing unit tests stick to
the slides Bob while bob was talking you
probably read everything that was on the
slide anyway you touched on clean up
after tests blah blah blah we'd like to
be able to think in terms of objects
because that's why we do object-oriented
programming
once you get static cling you end up
thinking in terms of procedures all the
time we'd like to fix that but how does
a factory pattern help we didn't show a
snippet of code for the factory pattern
because I think everyone is seen a
factory pattern you have some piece of
code that creates something and returns
it as a type of you know some abstract
type does it help us avoid statics not
really that much you've still got to get
the factory somehow how are you going to
get the factory from a factory factory I
don't know you're pushing the dirt
around you're also still having a
compilation dependency on that
implementation if you want to build your
code it's going to build the factory
which is going to build the
implementation code you haven't really
removed the dependency you've just
removed it one additional step then you
have all the boilerplate code you have
some factories you have the factory
factories the hammer factory factories
the and then like I pointed out on the
last slide you have all the boilerplate
that's added to your unit tests I mean
it's a mix of unit tests about twice as
big to have to passing a mock factory
clean up a factory and then your unit
test has to worry about three things not
just the code your testing code your
testing against it also has to worry
about a factory
you're on a roll Bob factory does a
service locator help so how many people
are familiar with the service locator
pattern looks like about a quarter j2ee
so for those of you that aren't the
service locator pattern is basically the
idea that okay the factory is not good
enough because we still have this static
like compile time dependency on one of
the factories producing we need some
kind of a generic way to replace that so
the idea with a service locator is you
can give it some token it can be like a
name or it can be like a type or
whatever and it gives you back an object
so I can say give me an instance of the
mahler service and the service locator
gives you back innocence of the mahler
service one example implementation of a
service locator is like jndi I'm sure
plenty of us have used that so the
problem is it's virtually just as static
as anything else you still have to get a
handle to the service locator somehow
which means that your test has to do
some setup before then test itself and
then remember to revert it back again
and several of the other disadvantages
of statics it's also hard if not
impossible to validate that everything
you're going to ask the service locator
for at runtime you know you want to
validate that stuff upfront early on and
you don't really know what you could ask
for anything at any time
we also it also makes it hard for your
tests to know exactly what set up the
test needs to do it has to start
searching around through all the code
that it's going to be testing and
all the things that are going to be
queried from the service locator so it
can know to set those things up then it
also ties your classes to a single
context right I mean you have your
service locator could take configured
like one time probably for your whole
application well what if I want to use
this same class two different ways with
two different implementations of its
dependencies so these methods are both
sort of pull methods where your your
client code is going to try to pull
references to the objects it needs and
they sort of don't quite work but what
if there was a way that we could push
instead so that by the time your object
code that you wrote is executing you've
already been given references to all the
things that you're going to need so that
is what dependency injection is it is an
anti-static mat for your code like they
sell it fries you should always touch it
first before you touch any of your code
and it simply injects which means gives
your objects the references to the other
things it needs which are its
dependencies that's it
some of the things we like about it over
the service locator is that you can look
at anything and you can see right away
up front what that thing depends on and
you can use those objects with or
without the framework present and your
dependency graph is explicit now these
things I'm stating them now but you're
going to see them illustrated with code
as we go further still not see many
hands so we must be doing well
sowhat's juice what's this juice then
yeah that's Kevin's joke oh so you can
do
dependency injection by hand really the
idea is it's as simple as Kevin just
described it it's don't call me I'll
call you your object doesn't call out to
someone to get your dependencies someone
passes them to you but without juice you
also have to write the code to do the
passing into which like factories is a
lot of boilerplate code and it's a pain
to write and it's not quite as flexible
so juice saves you from having to write
a lot of code and it saves you from
having to worry about things but which
we'll get into such as scoping and what
else does it let you do I think we're
going to find out okay the main thing
that we want you to understand about
juice is that it is a dependency
injector that is the only thing that it
exists for that's the only thing that it
does in this world except for the other
thing that it does which we're not going
to be talking so juice also does some
AOP stuff we're not going to talk about
the AOP stuff we're just going to talk
about juice as a dependency injector
unless you ask okay so here we have a
example of a complete running
application that uses juice it uses
juice for absolutely no purpose in the
world yep this code doesn't make sense
to you it's because it doesn't make
sense yes so it is an example of the
simplest possible application that uses
juice of course this application did not
really need to use juice because it is
so simple this is the starting point
from which we're going to start to build
in more juice concepts progressively as
we go although we're going to add more
interesting stuff to this example as we
go the examples are still going to be
toy examples that's because they have to
fit on slides and actually we have we're
working on the beginnings of another
talk which would be sort of techniques
for migrating real-world legacy
applications to use juice that's sort of
a whole complex topic in and of itself
so we're just going to stick to the
basics here
so what's happening here is we have a
class called greeter and you're going to
want to get an instance of it
what juice is capable of doing is
creating instances of things and doing
lots of fancy stuff we're going to get
to but for now it's doing no fancy stuff
it's just simply we're creating an
injector and we're asking it for an
instance and we're calling a method on
it that's it
so oh oh that's really it oh there we go
ah it truncated the slide there we go I
think that's in it all right oh we have
a question yes yeah that class that we
got could have been any type yeah and we
will certainly get to an example of that
okay let's make it a little more
interesting okay so as you as we
explained in the last slide there was
really no point using juice you could
have just set a new greeter
but now let's kind of see what juice can
do for you let's say for example greeter
has a dependency on what we'll call a
display er we don't want to just always
do system.out.print line so the way you
tell juice that you want this dependency
is you just use this @inject annotation
and you can apply this @inject
annotation to as you see here a field or
also a constructors or arbitrary methods
so and then basically what's going to
happen here is that our code up here
hasn't changed at all but behind the
scenes whatever juice creates us this
greeter instance it will find an
implementation of a display or it'll
create an instance of display ER and
pass it to greeter and then return that
to us so this is again a working piece
of code that displays hello world we
have a question still pretty pointless
sure yes displayer could be private
final in this case I think that next to
the magic of reflection yes you could
yeah these are like these would only be
in three different files that we tacked
together into one slide and the key
thing to notice is the difference
between the application and all of the
code that makes up your modules of that
application and that application code as
we go through this presentation is
really not going to get very much more
complex than what you see there it's
going to stay simple all the fun stuff
is happening down below what I mean by
an application is this is basically the
entry point to your application if you
have a command line application this is
the thing that has your main method if
you have a web-based application this
might be your main servlet if it's a
struts you know it may be your struts
configuration that points to your module
you I'm actually not going to be showing
the application on most of these slides
because it doesn't change too much from
what you see here all that it does is
creates an injector and then it does
what we call bootstrapping basically
creating the injector gets all your
stuff set up and you just have to sort
of hit the button that says now go and
and start doing what you're supposed to
do and you know we need some entry point
into our implementation classes so for
us it's say hello so ideally this would
be the only place in our application
where we would come into contact with
the injector and what I mean by that is
so imagine if all of our classes in our
application ask the injector for for the
implementations that for the
dependencies that they need what would
we have we'd have a service locator so
what sets a dependency injection
apart from service location is this idea
of bootstrapping and what I mean by that
is so we bootstrap our application with
this kind of root class and in this case
its greeter but from then on like I said
we want to deal with the injector
anymore greeter has display or injected
into it display like the implementation
of displayer has its dependencies
injected into it and then those
dependencies intern recursively have
more dependencies injected into them and
the end result is we just have a bunch
of nice clean unit testable classes
that's our whole application that don't
worry about where they get their
dependencies
from the back the question he has a
great question you're talking about if
you needed to pass parameters and when
you create the displayer or so he's
asking okay so we have this we have this
class we need some of the parameters
injected as dependencies but we also
want to provide some at runtime in our
code and the best way that I found to
handle that is I'm somebody who likes to
make everything final right so you could
either let juice create your object and
inject all the dependencies and then
call some setters on it but what I tend
to prefer what I prefer to do is I use
the Builder pattern how many people are
familiar with the Builder pattern good
pretty much everybody the idea is you
use this builder object and you can kind
of populate it piece by piece
incrementally and then you create this
fight you create this object using the
Builder that's final so we're getting
into like an advanced topic that we
don't have a slide about so it may not
make sense without the slides like they
will we'll work this into our next talk
yeah if if that if that answered your
question great if it didn't let's go a
few more slides and I think you might
find what you're looking for so the
point I was getting to is you inject the
Builder object and then you call a
method on the Builder object to create
the final object with your runtime
parameters one more
we will definitely come back to that he
asks how you get more than one instance
per injection we will definitely get to
that in a few slides here okay so first
we're just going to give you a quick
tour the fact that we have filled
injection we also have whoops I went the
wrong way we also have Method injection
which works the same but you put the
inject annotation on any method that you
want that method can have as many
parameters as you want and juice will
try to satisfy all of them and it will
call your method there's also no need
for it to be a setter method you can
name your methods anything you like
named anything you want and thirdly we
also support constructor injection like
maybe yes Bob's favorite my favorite the
favorite of the elite I don't know
immutables um the reason that juice
supports all three is that each of them
have their relative pluses and minuses
which we will try to get to edit slide
near the end if we can but just know
that whichever of combination of the
three you decide to use they'll all work
you don't have to configure juice and
tell it which kind you want to use you
just do what you want it will try
constructor injection then it will try
fuel injection and then it will try
method injection and it will all happen
so constructor injection you may have
one constructor that has the add inject
tag on it you may not have to because we
don't want to guess for you which one to
call and other than that it works much
like the method injection and that you
can have as many parameters as you want
but the really nice thing is in green
because now we can finally finally we
can make our fields final which is nice
because when our code starts executing
we know for a fact that they have been
set and they won't change question okay
- okay so add inject is a tag which you
can stick on any of your fields your
methods or your constructors and juice
will never call any of your code that
doesn't have this tag on it this is how
you tell juice I want some dependencies
from you and this is where it wants you
to send them so in this case we're
saying we don't have any methods we want
you to inject we don't have any fields
we want you to inject we just want you
to call this constructor when you want
to create our class and if you have no
constructor that has ADD inject on it
juice we'll just use your default
parameter list constructor to construct
your class okay and this just shows you
that you can have multiple parameters as
I was alluding before this is really
where juice shines versus other
frameworks and versus doing dependency
injection by hand this initial setup
that we've shown yeah it's kind of like
it looks like a lot of work for a little
benefit but what we really built juice
for is kind of like development
scalability as you know you're going to
create these dependencies one time but
you're going to use the dependency
probably a hundred times right so in
this case you can see that if we want to
all of a sudden we want to add a
dependency to our class we just add to
the constructor and take it okay I'm
going to try to speed up a little bit
without without speeding up too much
that's because I think we're about a
third of the way through our slides
someone earlier on asked about this so
what if we want we don't want to depend
on a concrete class because that's hard
to test then we have to know about that
class at compile time what we want to
ask juice for an interface and have it
give us a concrete implementation and so
as you can see this is we're kind of
starting that refactoring here we've
extracted and all we've done here is
it's our previous example still but we
just extracted an interface out of
display and renamed to the
implementation standard out display now
let's try to run our application and we
get an error because we never told juice
how to figure out which implementation
we were going to want to use of that
interface so it tells us that
and it tells us that it wants something
called a binding so we're going to learn
what a binding is in order to learn what
a binding is we first have to tell you
what a module is modules are how you
supply extra information to juice that
it cannot glean automatically from your
code some things we've seen already it
can just get from looking at your code
if there's more it needs to know that's
when you use a module the binding is the
most common example of something that
you would put in a module binding
basically takes a particular job at it--
whether that is a concrete class or an
interface or an abstract class or you
know whatever you want it to be and then
you associate information various
configuration options to juice that deal
with that type in this case you're
telling it use this more specific type
whenever somebody asks for the more
general type go to this more specific
type when it goes to this more specific
type it'll see this is a concrete class
I know how to instantiate it and you'll
be off and running
does everyone see what's going on here
great the other thing that's going to
say is that juice what you're binding on
the left and what you are injecting with
the add inject tag those types have to
match exactly we don't do any guesswork
for you where we say well you bound this
subtype and you're asking for super type
so we think this is the one that you
want it's totally a literal match and
now we simply need to tell our
application remember the application we
haven't seen that in a while this is the
only modification we're going to make to
this application during our whole talk
we're going to add a pointer to our
module in it and then this is going to
be our application for the rest of the
talk and now our code works and I put
this little that was sort of like a
what's the word for that click a little
dig maybe so like to us the idea that
you know you write some code and then it
doesn't work until you go and write some
XML is annoying to us so we like that
you can stay in the Java world as long
as you want and make your code work
today wait wait whoa okay do you want it
here I'll go ahead oh you said me go
ahead yes okay so we showed a picture of
your application including a module and
this relationship is many to many and
that's key to the whole idea of a juice
based architecture you can write a
module one time and included in as many
different applications as you want and
your applications can include as many
different modules as they want your
module can be as granular as you want if
you want to do every single binding that
you ever make in its own individual
module then you'll have lots of control
to pick and choose exactly what you want
if you want to group things together
because you figure you know nobody's
going to want three of these without
wanting the other two as well they kind
of go together so you group those
together into a module the module is
simply the unit that can be composed
into applications and the original
driving factor for this was a Kevin and
I worked on AdWords together which is as
many of you know a multi-million line
application and it's really hard to
check that all out and build it all at
once and run the test again so it takes
a long time so what this enables us to
do is that we can break AdWords down or
any big application down into multiple
modules that have no compile time
dependencies on each other and then what
that intern Able's you to do is you can
just check imagine just being able to
just check out one module and instead of
installing the other real modules that
pull in another few million lines of
code you can just install these like
fake modules that provide just enough
implementations for you to be able to
compile and test your code okay and you
can use modules to install other modules
in a tree type of structure you may or
may not want to do this I don't
personally like doing this because for
me the whole point of this architecture
is to have to keep your modules from
having compiled time dependencies on
each other to keep them independent so
if you start having one module that
installs for that installed each for and
then they each go and sell Tupperware or
whatever you have just left yourself in
the same situation you were already and
a big connected massive code it's mostly
for the ability to do that it's mostly
so you can do utilities like someone
just send out some code that can take
integrate with our flags framework and
automatically create bindings for all of
those so you don't have to have these
static dependencies on flags anymore you
can just have the flag values injected
right into your code so imagine how much
easier that makes testing right oops
okay how do I use juice to unit tests
it's a trick question because you don't
what happened is that juice led you
naturally to create your test in such a
way that it's trivially unit testable
because in your test you simply
instantiate your class directly and you
pass in whatever whoa don't do that okay
you pass in whatever implementations you
want it to depend on if you want to take
a handful of real implementations and
connect them all together and test that
you can do that or if you'd like to test
as would be a proper unit test with
capital u if you want to test just your
class by itself you pass in a mock
implementation of the dependency so you
see in this example we're not invoking
any juice specific code at all if there
any questions in the back presumably it
doesn't work for field injection very
astute observations you hopefully this
is why it does is why field injection is
I'm not what kind of language are we
capable of using in the field injection
is bad sucks yeah it has its uses but it
is not testable because in order to make
it so your tests can set it you would
have to make it public but guess what
you can't make it final
because juice needs to inject it after
it creates your class so now you have a
public non final field in your code
which I don't think anyone really wants
Jesse fuel-injection is great for slides
it does make your code concise because
okay field injection is most compact way
to do an injection that's why we use it
on slides that's why sometimes I cheat
and use it but it's not that great
hello okay of course some would say that
an interface with only one
implementation is like a cactus with
only one fishing pole because it does
doesn't really make any sense so let's
say that we have our display interface
we want to have not only a oh this font
is really small isn't it
you want to have okay not only is
display er that displays two standard
out but let's just have another one
that's similar that displays it in Times
Square on the big electronic billboard
same interface you're doing the same
thing just one goes to a screen one goes
to Times Square so we have to figure out
how we're going to tell juice about both
of these if we try to do just the naive
thing and just bind them both we get
this error a binding to example dot
display was already configured and it
gives you the line number both where you
first configured it and when you tried
to configure it again if you use it
ideally it'll automatically link these
two yes so we can't do that and if you
have two different modules they can both
bind the same types and that's fine but
if you try to put those together in the
same application that's when you get the
exploding so it always looks like it's
skipping a slide when I do this but it's
not okay so other frameworks well when I
used to write service locators I would
typically differentiate these things
with a string other dependency injection
frameworks tend to do the same thing and
one of the new ideas that juice
introduces and this was actually Kevin's
idea is instead of using these arbitrary
string identifiers we can use
annotations and I can't I can't tell you
how great of a fit this was and so the
basic idea is that instead of just
binding display or directly to an
implementation now we did we use this
combination of both the type display and
what we call a binding annotation this
is something that kind of describes the
binding and in this case Kevin used for
standard
and for Times Square to annotations to
differentiate between these two so in
your in your module when you're
configuring these things as you can
probably see by now Kevin I was I was
moving to the module because I heard you
say in the module okay so in the module
as you can probably see by now juice
uses this kind of like nice little
expression language and all these types
are checked and whatnot so you say bind
display or annotated with for standard
out to whatever implementation you want
to use for that so now when I want to go
use this thing it's really nice and
clean instead of just doing it and
checked I also include the binding
annotation so and as you probably know
like the benefits here over arbitrary
strings is that it's more concise you
don't have spelling errors and what yes
you can if you're looking at the
annotation in your IDE you can find
usages to find all the places that are
using it etc and the thing I want to
point out is that we're showing you the
simple case first the simple case is the
case that each client knows at compile
time which imply of implementation it
always wants so we're going to look at a
more complex example maybe next not next
but soon where do these binding
annotations come from well you just make
one whenever you want one they're yours
you put them in your package structure
where you think that they belong and
some people have some trouble getting
used to the idea of creating a lot of
these things but annotations what I want
to emphasize in green down there is that
annotation types are cheap they don't
really cost anything create a hundred of
them create a thousand I mean whatever
well and the truth is a lot of those
people I think are coming from the
string world where you have to have a
unique identifier for every single
binding that you would need and another
framework whereas in this case you can
reuse these annotations across multiple
bindings like we might have a binding
named at transactional or at secure or
at active and you can reuse that core of
that core annotation multipliers at
read-only at read-only add yeah consider
ok question in the back first
blasting bins we need to declare a class
of that mean and put packages for it yes
so these four lines in the middle of the
slide this is what the class looks like
that you so you you create a file called
four times square Java and these are the
four lines that go in and the import
statements and package location can be
wherever you want it to be basically
you're going to be binding an injection
that uses this annotation as part of
your API so people who want to use your
API are going to want to be able to find
this so you locate it close to the other
stuff that it works with I don't know
how to make it more specific than that
but usually when you look at a
particular case you can decide where it
belongs pretty easily
pardon I said basically these are the
only four lines in the file and then I
added well you would also need the
import statements for retention
retention policy etc but this is
basically what the code you write looks
like yes and good oh wait finally we get
a stupid question okay it's mine oh no
please
well it really can go back to the
previous line that's that's not that
stupid of a question at all no can you
back to the can you back to the previous
slide real quickly okay so the question
is how is an annotation really better
than a string anyway because you can
always define string constants and you
can reuse those same string constants
just like you reuse an annotation that I
sort of get that ready okay you want to
look at this one yeah so I just wanted
to kind of pull this up you couldn't do
something like this necessarily with a
string constant so that's where that's
really kind of where the annotations
shine and what I'm pointing out here is
that you put the binding annotation
directly on the injection point and in
this case it's directly on the field if
it was a method or constructor you would
put it on the individual parameter
parameter okay and this one
in the application good question okay
repeat the question if you look at just
this code you don't see what connects up
the fact that we're using for Times
Square the annotation up in this module
and we're using for Times Square the
annotation down here in this
implementation code you know you can't
really see what connects those together
and the answer was back a few slides
when we talked about the application
this is where we say for this
application we'd like to use display
module and then I might also write fake
display module or you know any other
type of module in somebody else's
application might use that one but
because we're running with this module
in place that and and we're
bootstrapping this new this greeter
class this is where we were yeah that's
how it knows did that help
usually when you get the returned
injector so the question is do you after
you create an injector do you have to do
anything with the injector or do you
usually not and usually there's just one
thing that you have to do to sort of
touch off everything and so in this case
we just get an instance of greeter class
and called say hello but even if our if
our application was much more complex it
might look like get an instance of
servlet engine class and call servlet
engine start but you still once you do
that then we just discard the the
reference to injector because we don't
need it anymore okay one more question
we will get to that yes the question is
how many times does juice create
instances or does it reuse instances is
that the question
okay we'll come to that soon very soon
yes okay move on multiple using creating
ok this is it your turn now I forgot
that I don't want to talk about this I
didn't want to include your slide if for
whatever reason you don't want to create
an annotation you can use a string name
like this just make sure that you spell
it Times Square exactly the same way in
both places or it just won't work and
you'll have no idea why it actually this
is kind of useful slide in that it
illustrates that annotations don't just
have to be markers in juice you can they
can actually have attribute values not
just one attribute attribute value
multiple which we'll cover in our
advanced public tech talk which will be
given at an undetermined date and by an
undetermined speaker okay constant
bindings so now it's your turn so I can
touch up okay
so there's a lot of situations where you
have this like configuration
configuration information ports host
names say you want to specify a class to
use and a properties file or that sort
of thing well juice has addresses these
separately and what we call constants
and it looks very similar to the binding
code we've already seen except for the
fact that you don't have to specify the
type and the reason for that is that
juice can figure out the type from the
value will probably move we have to move
quicker so we can definitely do that so
questions on this kind of the one
interesting thing here that I just want
to point out juice has worked for type
conversion and it can convert strings to
any type of primitive type classes and
neumes that sort of thing and where this
becomes interesting is you know as I
said sometimes you want that external
configuration juice can do something
like slurp in an entire properties file
and then automatically figure out every
place you need those properties based on
where things get injected and then it'll
convert those and check their types at
startup so that's kind of one of the
interesting factors as you can see here
like we bound a string
to that annotation but juice is still
able to convert that strength to an INT
and inject it okay now I mentioned that
we showed a simple example before when
the client always knows which flavor it
wants does it want the Time Square
display or does it want the standardout
this player but sometimes if the answer
to what dependency do you want is well
it depends and so here's an example of a
class of a method called get which picks
based on whether it's Tuesday today is
Tuesday I must want to go to Times
Square if it's not I must want to
display it on the standard out now how
would we get juice to make use of this
logic somehow and the answer is if juice
doesn't know what it's supposed to do
you just tell it who does know what to
do so this class that we just created
called display picker we bind it using
this to provider directive here which is
I think before we're using just dot two
so now we specify that it's to provider
and then with the display picker class
all we have to do is make it implement
the provider interface and since we
already named our method get' because I
cheated that way we didn't even have to
rename the method so now because we've
done this juice we'll use this class to
figure out how to get instances of
display and this class itself is a
first-class citizen it can have things
injected into it when we talk about
scopes it can have scopes it's just a
class like anyone else it just happens
to have this extra capability of being
able to provide other types and I saw a
question from Jeff yes in real life I
would never do this I would always
inject a clock and I would get the time
from the clock because that would make
my code testable on what I could test
the code on Wednesday yes this is a
perfect example of what not to do thank
you very much for embarrassing me
horribly not kidding I don't use clock
on slides but I use it everywhere else
question in the front
today
so the question is would this code
choose an implementation based on the
time that it currently is when you're
requesting it or the time when the
application was started and to
understand that we really have to
understand the idea of scopes because
only it's or I could just tell me that's
it if you don't use scopes which at this
point you aren't because we haven't
covered them yet then every time that
juice needs a provider for this it will
create it again and it will call it
again so basically you're going to get
the current time but if you have some
class that needs a displayer and then
you hold on to that class for a long
time and you hold on to that display a
reference then yeah of course then in
that case you will be still getting the
old behavior so that's a good point did
I remember to repeat the question I
forgot yeah Noel and question near the
back
okay so the providing of a parameter is
that is an advanced question which we
will not have time for in the talk but
the answer is that it's kind of hard and
in Joost 1.1 it'll be kind of easy is
that right provide a parameter well we
don't
so I deliberately chose an example where
I could switch just based on information
I could find without needing something
to be told to me about the context in
which I was being inject I
yes so he's asking so you have some
context that you want to pass in and
decide which one to return based on that
biggest so here this is kind of it this
is kind of a convenience for us right
I'm sorry so yeah you could you can do
that this is kind of a convenience here
being able to bind like right now we're
we're not binding provider of displayer
to this we're binding just displayer so
the users aren't getting this provider
they're gonna the users get a displayer
and so and every time that we need a
display or juice is going to come to our
provider but if we get a little more
complicated where we got to pass in a
parameter and stuff then you just
instead of doing this and injecting
displayer directly you need to inject
kind of like some kind of intermediate
class okay let's see introducing that
was supposed to say custom provider but
anyway the slight problem here is that
you see calls to new and when you see
calls to the new keyword that's a signal
to you that guess what juice is not the
one who's instantiating these classes
hopefully that will be obvious my code
my code right here is instantiating
these classes with the new keyword and
so I could have peppered @inject
annotation Sall over x squared displayer
and standard out display and nothing
will happen because juice has no idea
that these instances even exist so this
is an example of a sort of a best
practice with juice which is try to let
juice do as much of the instantiating of
things for you if you want to be
stubborn about and say no I want to
instantiate my own stuff go ahead but it
will just be a little bit more confusing
and a little more difficult it's better
if you can sort of accept juice
into your life as your own personal
instantiate er and just sort of get over
that you know that reluctance and then
you'll be happy it's the only thing
standing in between you and happiness
and I use the expression a lot in the
club out of the club it's sort of this
this exclusive club you know the objects
that were instantiated by juice they get
all these features and then the ones
that you instantiate yourself well
they're like these second-class citizens
so there are workarounds for dealing
with that but usually the way to proceed
involves figuring out how can we make it
so that juice is the one creating this
class and you can think of it as a
compliment to the garbage collector
which is where things go to die juice
injector is where things come from to
live so I you know made my famous joke
where I said I was going to rename the
injector to be the garbage producer said
of garbage producer garbage collector
yes I think that was on The Tonight Show
wasn't it I'm Sasha first I put the
switch statement in deliberately because
I knew that my friend Sasha would love
it
there's a question in the back
interesting question let's see how we
would get this thing in the club thank
you
one way we could do it and the question
is would we have to pass the injector
all over the place and the answer I
always use to that is I hope not you
know let's try to see what we can do to
avoid that and that's our last resort
because when you do that then you become
service locator and it's not pretty so
here's the case that works you just you
know you have two instances injected
into you and then you return the one
that you want to return so we I
mentioned earlier that the provider
classes are bonafide
objects like everyone else with the same
rights and privileges as everyone else
and that includes getting things
injected into them so this works we
don't even have to change the module at
all and the only problem is that it is a
little bit disowned
about its dependencies it tells you that
it always depends on two things but it
might not ever use one of them and
you're going to end up having to create
both of those things a lot anyway so
that would suck to construct Times
Square every time we write a priori we
don't want to open the like you know
wire connection to the little box at
times where when we don't have to so
unfortunately we won't be able to spend
the kind of time on the next slide that
I wanted to but the solution is a little
brain twisty we're having providers
injected into our provider so let that
percolate through your brain for a
little bit provider is just an interface
it just means something that can provide
so you can use it in two ways you can
implement it when you have something to
provide and you can ask to have it
injected into you when you have
something that you need to have provided
to you and by I just confused myself and
I knew we should have named them through
different things by doing that we go
down here and so I only call the get
method on the provider when I know that
I'm going to need it
I can't highlight I only call the get
method when I know I'm going to need it
that way I don't do any early
initialization of anything this is
called provider injection it's an
important feature that gets explained
more on the next slide anytime that you
can inject a foo you can always inject
the provider of foo automatically you
don't have to bind make a special
binding save this is what you do if
someone asks for provider of foo it just
works and we saw one reason why you'd
want to do it another is that your class
might need to get multiple instances of
this object over and over and this gives
it a way to do that and you can also be
ultra lazy like we just showed in the
previous example also and only retrieve
you only initialize your database
connection if somebody happens to hit
the link that says whatever I didn't
think that example out very well
questions we're using yes Laura if you
bind a provider and you also inject a
provider they may not be the same
provider so it's a little bit head you
know head exploding but we use provider
in two different ways from two different
angles and you can't assume that because
we wrote
fufu provider class and we're having
injected into us a provider of food here
that it's necessarily the exact same
thing juice puts it through a whole
bunch of you know decorators of proxies
of wrappers of proxies of decorators and
whatever okay Walter yes he said on the
last site we introduced two new
providers these providers that get
injected yes if we also have to
implement those and the answer is no so
so long as you have bindings for Times
Square displayer or and standard out
displayer juice can juice automatically
provides providers of those two and
really all those do is just call us
right back into juice and over here
absolutely he asked if he asked about
generic types so is there a difference
between lists of string and list of
users yes juice does see those
differently and you can bind them
separately not only can you bind them
separately but if we were using a
non-generic so we're framework we could
declare add inject list of user and we
could later bind a list of string and it
would just pass it in it would not even
know that anything was wrong and so
later when we tried to get from the list
and then it would blow up so that would
be really bad and that was one of the
things that you know one of the many
motivations for us writing juice to
begin with by which I mean Bob writing
juice to the human juices generics aware
it'll be in the advanced slide that's
actually thanks to Neil gecko for coming
up with Citrix to get around a racer on
that okay I feel bad that we don't have
much time for scopes
should we Lenny at time Lenny a plenty
of time have a lot of people been
holding back questions that they want to
wait for the end or they've been asking
them as they go okay so this to me is
one of the most important features of
juice there was one of the main reasons
I created it I was building web
applications and how many people here
build web applications
there you go do we do that kind of thing
here I think so I got so tired of
writing this code to like look on the
session if I didn't find the object on
the session I'd create it and then put
it on the session and then return it and
yet to make it synchronized and same
with the request
so what juice does is it enables you to
look at scopes like that like request
scope session scope singleton as a scope
it enables you to look look at these and
describe these in like a declarative way
so what I'm saying is I can have I can
take any provider I can take any binding
and say I want that binding to be
session scoped and what you still do for
you is anytime it's say I say I say bind
foo - like foo imple and session scope
when do sees that it will every time it
injects it'll automatically do that work
of going to this session and see if
there's an instance already there and
does this canonically and then if there
if there isn't it creates one if there
is then it returns the existing one so
and the nice thing about that is you
don't have to go through and write the
same boilerplate lazy loading code over
and over again it's just it's completely
declarative and reusable so by default
there's no scope and that means that
every time that juice sees a request for
an injection it creates an instance
injects it and forgets it next time
creates a new one injects it forgets it
a scope is nothing but a policy or a
strategy for how instances should get
reused singleton means once you've got
it always reuse it and session means
look in the session if you have one
there reuse that if you don't create it
and put it in the session etc etc that's
really all that we're talking about here
and these are terribly easy to write to
you can provide your own custom scopes
so you can imagine like a transaction
scope if you wanted to scope if you
wanted to cache objects for the current
transaction Singleton's have gotten a
bad name in many circles because of the
pattern of having classes and forced
their own singleton nests the problem is
that it's difficult it creates
difficulty to think of singleton nests
as something a class is it's better to
think about it as a way that you use the
class and that means with juice you use
your module to configure that in your
application you would like
you use this as a singleton and then
juice will do it all for you but
somebody else's application could do
something different and your tests can
always do something different your test
can new up as many of these things as
they want to so if you use juices
concept of singleton then all of the
laundry list of complaints about
Singleton's that I just saw in the
bathroom when I was in the bathroom
above the toilet they go away testing on
the toilet testing on the toilet we love
it two ways to make a singleton I guess
you'll have to refer to these slides
later two ways to make an eager loaded
singleton refer to these slides later we
have two minutes left
talked a bit about web applications so
this kind of goes back to the whole
bootstrapping thing you know it's like
so we saw how to bootstrap like a
command-line application how do you do a
web application
well we provide integration with struts
to for example so that every one of your
actions is automatically injected so
really if you're using a struts to
application you never have to deal with
the injector hopefully hopefully um
questions on this slide
also when in web application land there
are a couple of scopes that juice
provides in a sub package called com
Google inject servlet they are request
scoped and session scoped and in the
future we hope to have conversation
scoped I describe these as a two way
guarantee all scopes are like this it
not only guarantees that one instance
will get reused for all requests within
that scope but it also says that the
instances will not escape from that
scope and get used you know for other
people so it's a pretty useful thing and
skip the last bullet because it's
complicated here's some stuff about how
to choose the scope we're out of time
here's some stuff about whether you
would use field or method or constructor
injection we'll tackle this in the
beginning of our next talk and we'll put
the slides up on quick rule of thumb I
pretty much always use constructor
injection unless it doesn't work yeah me
too
so there you go just use constructor in
general let's I can
ah we made it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>