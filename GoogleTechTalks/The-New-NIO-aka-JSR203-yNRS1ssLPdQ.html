<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The New NIO, aka JSR-203 | Coder Coacher - Coaching Coders</title><meta content="The New NIO, aka JSR-203 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The New NIO, aka JSR-203</b></h2><h5 class="post__date">2008-05-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yNRS1ssLPdQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to our talk my name is
Karl Quinn and this is Alan Bateman from
sun-hi we are talking today about a new
new new i/o or time or many more new i/o
that's the official name this is the
same talk that will be given next week
at JavaOne on Thursday so if anybody's
going they could go to that and see it
twice we might be a little better next
time so we're just practicing on you
guys you're the guinea pigs we'll get
our timing right in and what will hold
off questions till the end so that we
can go through it as if we were giving a
JavaOne talk okay yeah I hope that's
alright it's just we wanted to get a dry
run in here it kind of worked out well
for um put it in this week okay guys
dark yeah you start okay alright so um
where are we here okay sorry mandatory
slide here just introduce what we're
going to talk about so and Carl and I
are both working on something called GSR
203 that's actually defining a new set
of Iowa Iowa P is for for the next
version of the Java platform so three
objectives that we want to get through
today and they they fit really the goals
of what this jsr is about so we want to
teach you a little bit about just what
we're doing around defining a new file
system API and we talked about some of
the work that work she's going to do to
complete the soccer channel API that was
put into Java back in 1.4 so there was a
lot of things that carried over from
that that need to get finished off and
the third thing that we're going to just
talk briefly about is is a new
asynchronous i/o API that we have for
sockets and files that we've been
working on as well
so the agenda basically reflects the the
goals that we've here we're just going
to go through them in this order and I
think Carl you want to start talk about
this so the first thing we're going to
just talk about is the file system API
so and the Java platform today has has
got something called Java IO file that
has been there since GDK wound up one it
provides very primitive access to the
file system so there's been a lot of
problems with that and a lot of issues
that we haven't actually addressed
there's a lot of features that it
doesn't have so we want to deal with
those so I was just actually just wanted
to quickly check whether I have no idea
where people are coming from here do
people actually use Java file are people
happy with us okay so and what hopefully
some of the work that we'll actually do
in jdk 7 with this GSR will actually
address a lot of the things that people
have so on the next slide we have a list
of the generated private problems that
we have with it today and you want to
start on that ok sure we've identified
just thought about a high-level summary
of some of the things that we thought of
as goals these are the issues that we
want to solve with the new file system
API so definitely one thing is it
doesn't work consistently across
platforms you're always having to fiddle
around understanding what platform
you're on when you're working with with
file many of the methods return a
boolean to indicate success or failure
so if something goes wrong you get back
a false if you don't know why you know
there is no more information about what
went wrong you don't really know how to
handle the problem so something richer
return type or exceptions were in order
there and the current files API lacks
many of the basic features such as you
know copy and move and and just
accessing a lot of the information that
you would need for a minimal application
symbolic links file change notification
none of that exists in the in the
current old file API and permissions and
things so it's definitely not extensible
you had one class and a few methods on
it and that's basically all you had
access to so the new file system API so
this is part of the the nioh package so
everything in the new file system API is
under Java and IO file pretty much
there's there are some methods
retrofitted in existing classes to make
things work nicely and fit together
this is where they all pretty much live
so file contains most of the classes
interfaces exceptions that that you'll
be using and then file attribute the sub
package contains everything to do with
attributes accessing attributes on files
there's also a service provider API
which we'll talk about a little bit at
the end or you can talk to us later but
so that's mostly for people that want to
write a file system so the main four
classes that you would deal with when
you're using the new file system API is
the file system class itself so this is
the interface to a particular file
system and if our system is an
abstraction of a file system it's not a
particularly more store it's just sort
of the abstraction on to a system of
files like in UNIX all of the files in
the file system would go through one and
there is a default file system that's
that's created and available to every
application every java application that
they can they can retrieve that default
file system and work with that directly
every file you can access has a file
reference type which provides the basic
interface in methods that you can access
to manipulate or access information
about a particular file but not
necessarily know about its name so
that's where the path type comes in and
that's a file ref that also knows about
its name so probably when you're
creating paths like if you're replacing
your old code that worked with file
you'll probably be using path a lot so
that's kind of it the replacement for
file you can you can use a factor to
retrieve one of those you work with a
file you can just will go into more
details about how path works like a lot
of slides on path and in a file store is
sort of the representation of a logical
volume or some kind of mount point
within a file system so you oftentimes
you won't need to use that but if you do
need to poke around and find out a
little more details about a particular
part of the file system like how much
storage space is left or what's consumed
or any particular constraints about
attributes that are supported on a
particular volume the file store takes
care of that for you
so here's a quick example of some code
using the new API so you can see path
being used at the top we use a factory
method on path the path class to
retrieve a path in this this one uses
the default file system just for
convenience if you wanted to get a path
from a specific file system you go
retrieve that file system and do the
same kind of thing
but this is just a quick way to do very
common all very common problems so we
get a path using using a string then we
resolve a file below that path with the
resolved method just a home dot resolved
is resolving this particular file you
get back another path that represents
that file and then we're executing the
copy2 method in this case we resolve
another path to you know as a backup
name for the file and then we're going
to do a copy to so we're copying from
the profile to the backup name and so
the copy to method will actually perform
sorry about that
go away Google notify the copy tool will
take care of copying everything you know
all the bits of the file take care of
any of the attribute copy there's some
options that you have there you can play
around with it but it does all the work
it's completely self-contained
for you in another example of using path
and how it interacts with the other
parts of nioh here we're creating a
sequel byte channel on top of or given
given a file name and then we have a
channel that we can work with until in
this case this example we're writing
things to the file and then when we're
done we close it so using path we can
get to other parts of an i/o and other
parts of the older i/o system okay so
there are methods on path to access the
components of the path so path generally
represents a name in a hierarchical file
system so you can you there are methods
that you can go through and find little
segments of the path and walk through
there and and test and compare paths
with each other to find out if one path
is a prefix of another or if they're
equal and you can sort them lexa
graphically there are methods also to
combine paths so you can find paths you
know combine a path that's a sub part in
a relative path below another path
and combine them together to create a
new path so sort of all of the
arithmetic that you might want to do
that you might do previously with
strings or with files and sort of mixing
that together now you can take care of
it all with with paths and then there
are the file operations so you can
actually trying to think of what what
falls in this category sorry yeah you
want if you have some to mention that's
fine well file operations would be you
had a couple of them back there which
was opening a file to get a child care
file moving or copying a file open
directories there's a whole series of
those okay yep and the other point here
is that all of the methods that access
the file system
you know once that aren't just in
tactical manipulation of the
representation but they really go to the
file system they'll all throw an i/o
exception so they're not going to just
return false if something goes wrong
they'll actually throw a subclass of i/o
exception that that contains much more
information about what went wrong you
know other files that were involved in
details about the error so that you code
can actually respond to that and handle
or resolve the situation so opening
creating files
so from paths you can go to the old i/o
system so you can create new input
streams to read from a file you can
create output streams so that way you
have complete interoperability with
programs that are using the older i/o
package so you can have paths open them
and the streams to existing code so it
makes it much easier to interoperate
with with your current applications you
can also work with code that's using
nioh so that we can create channels and
we've introduced a new interface called
sequel byte channel which is a byte
channel that also has the ability to be
positioned which is nice that's
retrofitted into the existing channels
package so that then you can make use of
that's a little richer interface that's
sort of the neo equivalent to random
access file which is a very common thing
you might want to use and also the
channel has interruptible channel
semantics so you can handle asynchronous
closing and interrupting of operations
so support all the standard read/write
up in trunk
etc of files and when files are created
also support the ability to set
permissions and other attributes at
creation time so you don't have to do a
create and then following set which
leaves a window of attack open where
file might end up momentarily with
default attributes or permissions this
way you can get them all configured and
set before it's created so copying and
moving met files is also supported the
copy to method can copy a file so the
farm file that you're calling a method
on to a target file in their various
options so that you can replace the
existing file or not and you can check
that as you pass in so you can see the
flag they replace existing and whether
or not you want to copy the attributes
or not or have new attributes when you
when you make the copy so you can you
can effectively use that to do a
complete clone of a file and basically
get a replica of the original file that
way and the move to operation is it
works in a similar way in this case
there are slightly different options
whether you want to replace an existing
file when you do the move or not and
whether you require the operation to be
atomic so if if the move operation is on
the same file system in the in the
platform supports it the move can be
done with a single oh s call and it will
be atomic other cases it might actually
have to be a copy and a delete and so if
if your application requires the
operation to be atomic you can you can
require that you can pass that flag and
it will check that for you ensure that
it does it that way
symbolic links so I think this is
probably the one biggest thing that was
missing at least from my perspective
because we were using symbolic links a
lot in our application with with the old
i/o you could fake a lot of the stuff
that we were doing that I mentioned
before you can always write your own
copy two methods move two methods but
really you couldn't do some bought links
without native code so now we've got
this in new i/o they follow the UNIX
semantics so the way they work is
modeled after Unix
most operations will just automatically
follow links and do the right thing as
if you were you know using regular IO
and the platform the links look like
like they're regular files except for
the delete operation and the move to
operation and those Street links
specifically so by default if you delete
a link a file that is a link it will
just delete the link of just do an RM of
the link it won't delete the target file
and the move to also doesn't follow
unless you specifically asked it to so
those operations have a flag that allow
you to specify but the default is sort
of the way you would expect it to be and
each of the different file attribute
views when you retrieve information
about a file about the path you can tell
it whether you want to follow the link
or not at that point sort of the stat
versus L stat and generally the default
would be to follow but you can that way
you can take a look and decide whether
it depends on what kind of work you're
doing there you can look at the add the
the link or the or the target so there's
also methods then to create the links
and read the targets and find out if a
particular path is a symbolic link or
not and this all works on Windows Vista
but not quite so well on Windows XP
right and there's a number of things
that you might not think you need but
but they're there they're important with
when working with symlinks is same file
the test if two paths are really the
same file they might have different
names but actually represent the same
file so it's nice to have a single API
do that for you then with current file
at Java IO you have to do some tricks
with canonicalization and see if they
end up the same and it doesn't always
work it gives you a rough idea
in copy2 operation to copy a link those
various defaults to real path is a
method that will sort of normalize a
path and there's an option there to tell
you whether or not you want it to fully
expand so one case it will just do some
cleanup and normalize a name
if you pass in the flag to say you want
to expand links it will basically fully
canonicalize it and there's also support
whether it's okay walk file tree method
is a utility method that's provided that
takes care of all the details of walking
entire tree of files which is mostly you
know it's it there's a lot of details
there that you can get wrong we've
written those before and it's tricky
especially with symbolic links you have
to watch out for loops and so this takes
care of that there's some options on
whether or not you want to follow and
detecting loops and everything for you
and there's also some basic support for
hard links so we can create a hard link
and find out link counts on a particular
path or note so here's a quick example
of how symbolic links look and are used
so you get a get a path in this example
user spool maybe it's a symbolic link or
maybe not we don't know we just we have
a path to it so we retrieve the
attributes so reading the basic file
attributes from this file and false
tells that they're not to follow we just
want the attributes of that specific
path itself and then we can ask is it a
symbolic link and if it is we can then
read the link target and find out we get
the target out of the link and we have
the link and we can then check to make
sure in this case we're just asserting
that this one should always be true that
the that the file resolved to its target
will be the same as the file we started
with so they should both point to the
same place you get that right
so directories in old file you basically
grabbed a whole blob of directory
contents all at one time and walk
through that and that didn't really
scale if you had thousands or tens of
thousands of files and the directory
things which just don't you fill up
memory things would go right slow is not
good so the new i/o we have a directory
stream which is really like an iterable
over the directory contents so it makes
it really easy to just set up a for loop
in this case we use an external iterator
with a new for loop pull the directory
stream from from the directory this case
we want to grab all Java files so we can
pass in some filters there walk through
every entry in the stream and then the
entry is really a combination of its
it's a file ref itself and a name
relative to the directory so it's just a
little tuple there that you can then
grab things from it you can grab the
name you can actually perform operations
on it that are all the basic file
operations so you could walk through and
you know change mod or manipulate the
files as you walk through the directory
and at the end you close the stream when
you're done there's also a shorthand way
to do that we've provide an internal
iterator approach in a helper method so
you can there pass everything you needed
the directory itself the wildcards that
you want it to match and then
effectively a callback method or a
closure so this is really designed for
use with closures later on if they ever
end up in the language there's a perfect
use form but that way all of the the
iteration and the closing and exception
handling is done inside the method you
don't have to worry about it you just
write the code there
so directory stream filters is a class
which contains a bunch of factory
methods for very convenient you know
convenient for you to create the filter
objects that you would use to filter the
results of the directory search you
maybe you want it you want to pick up
from here
I don't know this class as well okay
sure yeah
alright so the directory stream filters
is just a basically a factory for
different useful kind of filters and one
of the common ones would be that we just
give an example about there would be
something like people won't be able to
and filter the files in a directory
based on their mind type so one of the
things we're not going to cover today is
is is how mime type detection works and
how it actually plugs into this to this
API but it's just one demonstration
there of how you might actually filter
files in a directory there's also
methods in there for combining filters
so things like logical operations and an
our complement and when you want to
actually do filter files you can
actually combine them then together into
the form little expression so it's very
very simple and the walk file tree
method is easy utility method on our
files class is something that Carr
talked about in the previous slide which
is for basically for and and walking a
file tree but being able to then be able
to use it for recursive operations that
and on all the files that are in your
trees you basically give it a starting
file here's my what we call my file
visitor that'll get invoked in for each
of the files and the directories that
are in that tree it's a very simple to
use internal iterator more advanced
applications will actually go and want
to develop their own kind of iterators
but this is really for the for the
average developer to be able to develop
simple recursive operations and
important thing about it is is is that
it handled things like a loop detection
you can set maximum depths and a few
other little parameters to configure so
it's actually makes it very very easy to
use okay so file attributes so I'm file
attributes we talked about here we're
talking about metadata and other kind of
information that's associated with a
file in a file system so things like
timestamp file permissions and there's
lots of are very very platform-specific
and metadata that gets associated with
files and files
and the big problem we have when
defining an IPA pipe for this is because
it is soulful system-specific is how do
we fit it into it into a an API that's
used by applications that want to be
portable so the approach that we're
using is is to group related attributes
together and we define what's called a
view or a file attribute view in this
case that provides a view of those
attributes and every implementation
supports what we call a basic file
attribute view which is a view of it's
kind of a lowest common denominator of
basic file attributes that are very
common to vary file system so people
know about timestamps like the last
modified time creation time what the
size of a file is what type of file very
basic information that is very common to
many file systems and that is available
through this basic view we then define
all of these other views that are more
specific for other kind of common file
systems but they're not required to be
there so we have views that provide a
view of Plastics file systems of provide
we provide a view of access control
lists based on a model I'll talk about
in a few minutes an implementation then
of the platform is required the support
basic and then you may actually support
all of these other views that we define
in it in the end in the API and in
addition to that a platform may support
some other very specific and file
attribute views that where it would only
be interesting for some of us developing
for a particular file system or
operating system that we know nothing
about okay so yeah let's move on so we
have a little example here and so this
is e this is sort of the Java quipment
of stat in this API and one of the other
things that in one of cars original
slides there we talked about some of the
problems with Java of file and one of
the big issues that we have to deal with
is performance and many of the methods
in fact all of the messes in Java you'll
file today go to the file system you ask
a fire what is your size what is your
directory what is your last modified
time every one of those if you actually
profile out it's doing stats that's that
are equivalent on a platform and we end
up with performance issues plus as
potential security issues related to
that as well
so what we wanted to do here is provide
essentially a bulk read or a stat like
equivalent where you actually read all
of the file attributes in one go so
there's a little example here as how how
we do that but in order to explain this
example I just need to just explain how
the API works so because we've got all
of these file attribute views installed
it's like how do you actually select one
of these and the way the API works is
you select these these file attribute
views using this type token thing you
basically tell them what what what you
want and you get back an instance of
that so in this example here and if I
have a laser pointer I'd show it to you
here we call the new file attribute view
method we tell it we're actually asking
it for the basic file attribute view
that true or false that at the end there
is telling you whether you're actually
following links or not and and because
sometimes you want to be able to look at
the attributes of a link result by
default if we pick up on scar slider
you're on we follow links by default
sometimes you want to know is a file a
link so you you can select whether it
follows links or not and then once we've
got this view we invoke it's got a
method here called read attributes we
invoke its method and it returns you
back an instance of this container which
in this case is a basic file attributes
and that has all of the basic things
that we would expect so you can add you
can ask it what it's sizes what is
directory and there's few more the
examples there of the methods that are
defined by that now when you look at
this code here it's a bit long-winded to
do to do something very very simple so
we have an attributes utility class and
that is defines various static methods
for doing and most of the basic things
that we expect developers to be doing so
Carl is to switch down there and that
code is shrunk down now to a single line
so we invoke this one method called read
basic file attributes view on the
attributes class and so it makes a
little bit easier so that's that that is
our privilege of stat in in this API
come on yeah okay so here's another oh I
thought we'd remove this slide but ok so
here's another example this is the POSIX
file attribute view so this is defined
in the in the API is providing access to
file attributes that
are supported by by operating systems of
generally implemented POSIX and family
of standards this a POSIX file accurate
view is actually a basic file attribute
view so it extends basic viola review
with some other interesting things and
we have the equivalent of a read read
method we on the last slide we had a
really basic file attributes have
returned these basic attributes here
we've got to read POSIX file attributes
so this is this is more like a UNIX type
stat and so a POSIX file attributes
again is another container it's actually
a basic basic file attributes plus some
additional methods and in this case it's
returning us back interesting things
that we may want to do with the plastic
type file so there's a notion in here of
file permissions and file owner file
group and so on so we have objects to
represent these different things so this
little example here we just walk through
it very very quickly is is we read the
attributes and we're actually going to
print them out there's a this useful
static to string method there that
actually converts a set of permissions
into something that is useful for
display purposes and do we do a system
data format so and to print out here we
call the the file permissions a file
order in the group and they get printed
out and in in in a format that we will
recognize the example goes on there to
show the equivalent of changing file
permissions here we're actually invoking
this static method on our hp's class
again to set some permissions we're
using the VAR arc syntax here so we're
giving it a file and then is basically
the array or the the list of them of
file permissions so this is like doing
the equivalent of a shoe mod on unix
it's very very simple to use we have a
number of other file attributes views
that we actually define in the in the
API we've got a dot file attribute view
this provides access to legacy gas
attributes so we're always getting
requests from developers that want to be
able to access things like the read-only
the hidden bit and all these other bits
that you would actually have and so
that's very useful for developers that
are working on Windows one of the
interesting things as well is that we
actually can we this this file act
review is designed to be supportive as
well on non Windows systems so for
example if you're using a Samba server
or some other kind of sip server then on
the server side you can actually change
those those attributes and our
implementation allows us to do that
we've got an apple file attribute view
and this provides access to read and
write and view of access control lists
the model that we're using here is based
on the nfsv4 apple model that's the only
standardized apple model that we're
aware of and so that's that's that's
quite interesting and we also support a
named file attribute view that's dealing
with name value pairs or named
attributes that are associated with a
file so when you've got this other
typically user defined or application
defined metadata and on file systems
that support this then this is basically
providing a kind of kind of a setter
Gator type api to that we've designed
this so that it's also mapable to other
types of file systems so it can be
emulated by file systems that support
and what we were called name streams of
those various file systems out that that
support multiple streams and this is
this is implementable using the undos
type of file systems ok so we're moving
on we're just talking about file change
notifications so this is something that
comes up a lot where you've got
applications that want to be able to
gated events from the file system to
tell them when files have changed or be
able to monitor files so this has been
popularized in the last few years
typically by things like Linux is I
notify and other operating systems have
various other kind of notification
mechanisms and stiple example you have
would be your in your your in your in
your editor or your IDE the file gets
changed outside of that environment and
the application pops up and tells oh hey
the file has changed you want to load it
so that's a simple example I think a lot
of developers relate to but hasn't been
possible in Java today a lot of what
applications are doing is and we see
this when we're looking at performance
of problems is there polling at the
profile system checking is last modified
checking is last modified and that can
be very expensive so an operating
systems where we can get the
notification then if we nice to be able
to use that mechanism and that's what
we've actually done
the way it works in this API is that we
have a notion of a watch service a watch
service is something that you can
register what we call watchable objects
with so so with you might say I want to
register this file here give it give it
the name of the of the the path of the
directory and I want you to tell me
whenever a file is added to that
directory whenever a file is removed or
if file is modified in there and then it
provides a notification when when
there's some event for that object and
the way this actually works in terms of
the API is it's a relatively low-level
API and it works kind of a like a ven
port type of model where you actually
get events in ugq where you retrieve
keys that represent the they tells you
about the object that has changed and
another interesting thing I guess about
this API is is it's actually designed so
that actually you can have multiple
threads actually dealing with events and
so and you've got server applications
where you actually have to do some
expensive work we won't be able to
dedicate more than one thread to dealing
with events then this is actually
designed to be able to to deal with that
so when you have let's say a couple
hundred directories that you're actually
watching it'll actually give you events
for this directory and then some other
trade would be processing events for
another directory and by using the API
you can ensure that they actually
coordinate and don't interfere with each
other one final point then do we have in
this slide is as I said earlier that
this is quite a low-level API it's very
much to the reason for that is this is
that the actual use cases for this or
can be actually relatively complex and
what what we can do is very very easily
it's very very easy to build a listener
type of API on top of this and we have a
little channels of that one so here's a
here's an example and I'll just run
through this very quickly because of
time and so we get a watch service here
by invoking this estatic method called
filesystems get default gives us a
reference to the default file system
when we instantiate here a watch service
so you're actually asking the file
system for its watch service and I'm
building up here is set here of events
that I'm interested in in this case I'm
interested in creation deletion and
modification events are register than
a directory with this watcher and I get
back this key that represents it and so
here we're registering a directory maybe
that you're actually representing other
types of original other types of objects
as well and I've got here a little
simple loop here that's actually waiting
for an events to be signals is actually
DQ's it retrieves a key here and the key
has all the events that are associated
with that directory the way this
typically works is that events come in
in bulk for example someone creates a
file then you're going to get creation
events and modification events and you
typically retrieve them in bulk here and
we're actually going to process them I'm
not going to go through because of time
reasons the details here but this is
basically a loop there that's actually
going to process the events and deal
with them so in this case is going to
tell you when a file is created tells
you what the name is if the file is
modified it tells you this file in this
directory is modified and so on ok so
quickly moving on just want to talk
briefly about interoperability so
there's a Java file has been around
since JDK wonder there's a huge amount
of code in there that of code using that
and one of the things we were
consciousness is is that it will not be
possible to migrate existing
applications use a new API overnight so
we want to make it very very easy to be
able to make use of the new features in
applications that are currently using
the existing Java elf file so we define
this method on Java il file called a
gate file ref and that returns you back
a file reference that accesses the same
file as the the Java il file does today
and what that allows us to do is address
some of the problems with Java il file
without making extensive changes to
existing code so this here's a little
example where where we're using Java il
file today to rename a file so this is a
bug that people submit and almost every
month the rename to method returns a
boolean to say whether it succeeded or
not the rename method returns false if
it fails and you have no idea why it
failed and people get very upset over
this because it's very hard to diagnose
problems you guys work on on Linux I
guess but people working on windows have
to deal with a whole bunch of other
scenarios ensuring violations that
you don't have to worry about so in this
little example here if the rename to
method fails this little this little
code fragment prints out your guess is
as good as mine and because we don't
know and so if we will just replace that
code we just change anywhere that's
using Java file now to source suck it
get file ref that returns as our file or
F and then we invoke on the file
reference the the equivalent method in
the new API so rather than using a
rename to with Java L file we're using a
move to method so this is just replacing
in a very localized way the existing is
the dis existing code so our renamed to
is now using the move to method the move
to method is Carl talked about earlier
on is a method access is the file system
therefore it throws an exception we've
got some information as to why it failed
and we're not covering today some of the
other details around exceptions and but
you can find out there a lot more
information about why it failed so we're
just printing out the exception here so
at least we've got in this particular
case we've got a simple message or
useful message we would hope to explain
why they what why we weren't able to
rename the file another little point
just about interoperability is is that
we've updated really important classes
in the packet in the in the Java
platform so classes such as
java.util.scanner and formatter
and which are really really useful for
accessing files so that they work with
the new file system API just briefly
talk about the provider interface so the
provider interface is there too for more
sort of advanced developers that are
interested in actually creating a file
system for other things and it has a
number of usages and first thing is for
the real adventurous you can actually
replace the default file system so if
you don't like the implementation that
comes with the JDK then the its
configured so that you can actually
replace the implementation completely
another more interesting thing is that
you can interpose on the default
provider so for for people that are
interested in putting their own caching
or their own logging layers in then and
you can actually do this and this is
stackable and
it's relatively easy to do but the other
thing then which is where people want to
be able to their own goofy filesystems
is there is a way that you can be
plugged into the platform so you can
actually develop your own files and so I
want a file system that accesses files
and zip files or inmate that's
completely in memory or when I want to
treat this HTTP server as a file system
then you can go and create your own and
deploy your own provider and that
provides this API at to your own file
system okay so the question the question
is is what file systems by default we
have it just access to off the platform
and then we have sample code that
accesses zip and jar files and Karl I
believe is actually going to donate a
another file system provider and if you
do that we can include it maybe as a
sample we'll see I volunteered to do it
in memory file system so we have
something very similar parallel in in
that blaze VFS that we use for unit
testing which is very handy okay so just
a couple of things just about custom
file systems of the way it works is that
we have an SPI package service provider
interface package that defines in there
something called a file system provider
and you basically build a cursor create
a concrete implementation of this and
and you deploy it and there then is
these factory methods and on at this
file systems class that allows you to
create them and we identify all file
systems by by you our eyes and and you
provide the URI to the file system class
and it'll actually it will locate a
provider for you that supports that the
the URI scheme and gives you back that
file reference and one thing just to
explain is is that each of the file
systems here are actually distinct file
systems we are not actually supporting a
federation and at the moment if someone
wants to go and develop their own
higher-level virtual file system that
we're able to mount various different
heterogeneous file systems that they can
do that we're not actually doing that in
the indian tin what we ship with
this so file system providers are
currently in our API are deployed as jar
files are just using the standard
service locator facility that's in the
platform and if the modules work ends up
in JDK 7 then we'd be able to and make
use make use of make use of that ok so
just moving topics completely that's
that's all we're going to talk about
file systems today I'm just going to
talk briefly just about some of the work
we've been doing on the channels API and
just explain what we're doing some ok so
the as part of jsr 51 and in jdk 1.4 and
a new channels api was added which
provides and non-blocking and multiplex
dial these socket channels which is
there's a number of those that are
defined in that in that package are not
a complete abstraction of a event of a
networking socket and so there was
carryover work that was not completed in
that GSR that we wanted to deal with
eventually and so that's what we're
working on so and so with those channels
today you're actually forced to mix
api's in order to do basic things like
binding sockets bar for binding the
channel sockets to ports setting socket
options and so on and some api ugliness
in that we've got some compatibility
issues with that and it's very hard to
to have it have these sockets emulation
the legacy networking package so we've
attempted to address this problem and
the way we've done this is we define
this new interface called a network
channel that is a channel to a network
socket each of the existing channel
types have been retrofitted
to implement this this new interface and
they provide the the methods for setting
and getting options and binding getting
your local port and so on
another point just to make on that is is
all for it for all the socket options
this has all been made extensible so we
defined a new class that defines the
standard socket options that need to be
supported by the platform but it's
extensible so that we can make use of
platform specific socket options and
where we're required so instead of
having a setter and getter method for
every saw
option and you can actually you can
actually implement Sauk adoption and
just use a set option method or get
option method and just reference your
your socket option okay another thing
that was missing that comes up very
regular laces is is multi casting
support this we've had multi cast and
support in the platform in the legacy
networking package since JDK 100 but
we've never had support in the channels
and package and so we've added support
for this and so if a new interface here
which you call a multicast Channel that
any of the Datagram oriented network
channels can implement and that provides
the ability then for these channels to
join and multicast groups and so
Datagram channel is implementing this
and we also have an asynchronous very
interest that will also support this
when you join a multicast group by
invoking this join method you get back
this key the key then defines that's the
key is your is your token to represent
your membership of the group and it
defines then methods for dropping
dropping your membership or blocking
addresses and and order another queries
to be asked asked it information about
the group we've also used the
opportunity to try and modernize some of
the multicast support because it's
actually got quite old in the platform
so there's been new new standards
dealing with providing deter defining
and source specific and multicast so
we've actually used the opportunity to
update that so we have support in there
for both inclusive and exclusive mode
and multi casting so there the standards
there I GP v3 and then there's the ipv6
equivalent as well so here's a little
example that just demonstrates the this
API there's a bit of code here but let's
say we're all will go on doing this as
we're creating your Datagram Channel and
so we're opening opening the channel and
then we're going setting a couple of
socket options on it we're binding the
the channel to a local address setting
another socket option and then the the
channel is going to join the group and
multicast seems a little bit complicated
that you're actually you're actually
specifying a number of pieces of
information you're selecting what it
what network interface you're going to
join the group on what
ooop is and that's the reason for all
this code here but but the important
points start to to look at here are the
creation of the data gram channel and
you can see here we're actually using a
method method chaining here so we're
invoking the open method setting some
options and all of this chains change
change quite nicely and we skip down
then to the membership key equals DC
join and then you're giving what the
group you're joining what the network
interfaces this is a two argument join
method we also have a three Argand one
for a source specific multi casting and
we're receiving a packet and then later
we're actually going to drop our
membership and so it's it's it actually
this is this is actually turned out
reasonably reasonably well okay so
moving on I just want to briefly talk
about asynchronous i/o and which is
which is something that we also working
on in this GSR and so what I synchronous
i/o is about is defining an asynchronous
program model for both files and sockets
and one of the motivations really is is
to be able to to make use of
asynchronous i/o completion port type
facilities that are available on many
operating systems and so what are
multiplexing and selector support today
and we map quite well to operating
systems that have a scalable polling
facility and what it doesn't it doesn't
work as well when you're actually
dealing with operating systems that have
event ports that are designed to be able
to be used by multiple threads so
instead of one threading I'm polling a
selector we can have multiple threads in
the kernel actually retrieving events
with this kind of API the API itself
defines is is has basically sports to
two kind of asynchronous programming
styles one is we will be calling a
future style where you initiate an i/o
operation you get back a future this is
a Java util concurrent future that it
represents the the result of the i/o
operation that the Java Java children
current futures been in the platform
since 1.5 it defines methods for and
getting the result of an i/o opera
getting the result of a computation or
i/o operation in this case methods for
testing whether it's done polling it and
so on
and so the second style and we've been
calling a callback style is where you
specify a valise of code which we can
calling a completion handler that is
invoked when the i/o completes so we
start a read on on a network on a
network socket and we want this
completion handler to be invoked when
the the i/o completes our fails so
here's a little example and so if we
have a new set of channels with four new
channel types that are like the
synchronous equivalent of the existing
channel types so for stream oriented and
connections we have an asynchronous
socket channel we have an ORAC open
method here that we invoke to create one
of these and in this case we're going to
do a connect method this is to establish
the connection and to some remote system
we get back here a future in this case
the the the we're just going to wait for
the result and so get back our future
here that represents our result and I'm
just going to call it get method which
is an existing method on future that
just waits for the result to be
available here I can establish a
connection is usually not that
interesting there's no information to
write back the connections either
established or it fails move on then and
we're actually going to do a read on
this channel and when you do a read I'm
going to do I'm going to do a read into
a buffer I'm getting back a future and
this Q in the indicates of a read the
result from a read is the number of
bytes that have been transferred into
the buffer so and so my future is is so
if I come down here I do my get again
I'd like to connect I'm just waiting for
the result in this particular case and I
get back here a the number of bytes
bytes read in this case it's actually
being in being unboxed to a primitive
engine here here but that's okay now the
future the future interface trolls what
when you're waiting for resulted throws
an exception I checked execution
exception and so we actually have to end
we have to retrieve the actual exception
later on this a little bit of ugly sign
on that but if for the most part it fits
in quite well with a with that API
moving on this is the callback style
which is our completion handler I'm
going to do the equivalent read here
except rather than returning a future
I'm going to ignore the result instead
I'm going to give it a completion
handler and in this example I'm just
using in an anonymous inner class so I
do my read and my buffer ignore the null
for now and I've got here completion
handler the and the completion handler
is a very simple interface that defines
a completed method the completed method
is invoked when the i/o operation
completes and the parameter to the
completed method is something we call an
i/o future that's actually a future but
with more specialized for i/o operations
it defines this method called get now
which is a slightly simpler version of
the get method for when the result is
available and that returns you back the
number of bytes and so this is this sort
of designed again with the idea of
having closures potentially in the
future so this could actually work quite
well and so it's it's it's relatively
simple to use this is this is a simple
example with the anonymous in our class
but it may be that the completion
handler is a much larger piece of code
in which case passing it as an anonymous
inner class wouldn't be the best thing
to do so just quickly just talk about
group so and one of the big things when
you start adding in a kind of callbacks
or completion handler type of API is is
is that one of the first questions you
get is as well with which threads are
going to invoke those the completion
Handler and the way we deal with that is
is that we have this notion of a group
in a synchronous channel group all of
the asynchronous channels that we create
here are somehow associated with a group
by default there is one group which is
the default group if you don't specify
the group then your channel will be
associated with the group you can if you
want to create your own group and and
when you create the channel then you can
put it into the appropriate group
a group encapsulate the various
machinery that deals with IO completion
and so retrieving events doing any IO
completion retrieving completion events
whatever the platform mechanism might be
and then more interesting for developers
is is that it also manages the thread
pool and which are the threads that
execute the completion Handler and so
when you create a group you can
configure it with the various with
various parameters for for what what
threads you would like number of maximum
number of threads the thread factory
that gets invoked when you create
threads and so on the group is created
with that and then the when I always
complete then one of the threads in that
group are the initiating thread will
invoke the completion Handler I said
they're about the initiating thread
invoking the completion Handler that's
an optimization in the specification to
allow for scenarios where the IO
completes immediately for example I'm
writing something to a channel the
chances are that that the write will
complete immediately because there's
space in the socket buffer you don't
want to have a context switch there to
some other thread that's going to deal
with the completion you can deal with
that the the completion notification on
the initiating thread so that actually
works quite well from a performance
point of view a couple of other things
just to say about asynchronous IO is is
that we have built timeouts into the API
and this works quite well and because
dealing with timeouts and networking can
be complicated so every each of the read
and write methods that are sorry in the
a similar to soccer channel it we've got
variations of the read and write methods
that and can specify timeouts if the IO
completion does not I've sorry if the
i/o operation does not complete within
this given time then it completes with a
timeout or interrupted by timeout
exception and that's that that's very
useful when you're and
dealing with servers and you want to
timeout connections if you don't get a
response from some client after 30
seconds or 30 minutes or whatever it
might be and like like interruptible
Channel today we also support
asynchronous clothes so at anytime
HHA one of these new asynchronous
channels can be closed and any
outstanding operations are required than
to complete and with what we call an
asynchronous clothes exception and one
of the things that often people ask
about is is cancellation so the future
interface if I've got back this token
that represents the the result and how
did you look with the cancellation
cancellation typically doesn't make much
sense or typically not feasible with i/o
operations and so the way we deal with
this in the spec is that we allow we
allow and we allow forceful cancel to be
able to close the connection so a bit
like an asynchronous close and there's a
few other little details in that as well
so on platforms where we may have some
some support for cancellation then
there's a requirement that the
underlying connection and the channel is
never left in a consistent stage
otherwise we're into a lot of tricky
little problems where you don't know how
many bytes have been read or written or
written or and so on and that gets that
that gets complicated so the spec has
has a lot of wording in there in terms
of leaving the connection in consistent
state if you support cancellation and
finally then for the adventurous there
is a provider interface which is in the
channels SPI package and which is if you
want to put in plug in your own
asynchronous i/o implementation than you
can okay we just we just do this one
slides a couple other little things that
we've been we have in this GSR as well
and we have we have we have to find a
new set of buffer classes which we call
big buffers this is kind of a little bit
niche in that it's it's really designed
for cases where you want to have and
multi-gigabyte containers in native
memory it's very much designed for the
sort of the 64 byte 64 bit type
application where you have loads and
loads of memory available and you want
to be able to be able to map very large
files into memory or you want to have
other big large native data bases in
memory
and so these new this is a parallel set
of buffer classes everything is indexed
here by a long rather than an int and so
we have then some way that you can
actually create views 32-bit views are
the eggs of into these larger buffers
for interoperability with existing
applications one final little thing
which is a small thing that we included
in there with this we've also included a
management interface for and for buffers
and the motor for that is is to be able
to forge MMX and other other type
monitoring applications to be able to
monitor the resources that are
associated with direct buffers and
memory mapped memory rot files let's
skip the next one yeah okay so just
conclude and so we've just provided an
overview there a quick overview of what
we have in this API and this is this is
still ongoing this API we hope to get
into JDK 7 and we hope by going through
these slides that we've given you an
overview of the type of problems that
we're actually trying to address what
the api's might actually look like and
hopefully you find it useful so we have
a couple of links there this links to
the GSR page so we just recently got set
up as a project just in the last last
week on open JDK and so that purple data
at the moment it's it's because it's
only just set up it's it's only just got
the the current snapshot of the code and
so you can actually download that apply
the patch here open JDK and it'll it'll
work and in a few weeks time would be
will actually improve on this so that
there'd be a proper repository there
we'll have binary is Java doc and
everything else is that because we've
basically got two two audiences for
these people I want to play with the
code and people that don't care about
the code they just want to try out the
API so we'll have all of that set up
soon with two mailing lists then and so
we've got a development mailing list
that we're going to be using and then we
also have general questions and
discussion
ellee's okay I guess that's uh that's it
you wanna yeah take questions now we
have a mic I think that's set up you
could do that or a passed around we can
repeat the questions as oh there is one
okay let's try that sure I have two
questions the first of which I hope is
quick I noticed that when you retrieve
an attribute view you seem to be passing
in a boolean wareness in other cases you
have this nice follow link nofollow link
attribute is there a reason behind that
okay so the quite well okay so you have
the mic so and so anyway anywhere where
you and where there's a choice as to
whether you follow it or not is a
boolean argument there okay now I think
what you're what you might have noticed
is is is a nofollow link which is like
copy options and the reason the reason
for that is is that something like a
copy to method you're actually giving it
a we're using the VAR arc syntax where
you're giving it a list of options and
you can't just can't just put a boolean
in there one of the options is is is is
nofollow links for the for the for the
rare cases where it's more interesting
to copy the link rather than the final
target of the link and this is so
there's this I think there's only two
places where we actually do that I think
maybe he's asking for arguing for having
the enum being used instead of yeah I'm
wondering why you ever use a boolean hey
we could do that static final rule we
could do
no follow no follow links yeah we could
we could actually do that I think one of
the other things we want to do with
those as well is for them for most of
the time you're only interested in
following links so we can actually just
eliminate that argument completely so
yeah okay so you're right there's a
little bit of inconsistency there and
for people like me who are interested in
implementing their own file systems your
source code showed a path dot new or get
with a with a string and then operations
on the path to obtain a channel how does
it tell which file system to use to get
a channel okay so okay so that path get
method which was was is specified to
make it very simple for developers to be
able to actually just reference the
default file system that actually
invokes a get path method on the file
system
so the code that I'm using has to know
that it's being written correct and file
systems correct yes the Father well it's
not so much that a custom file system it
just has to be able to take a file
system instance as a object work with
and from a given instance of a file
system Yui and then right so if we
eliminated those get methods which is
what we could do that means that
everyone then in order to access a file
they've got to call file systems I'll
get default and then call its get file
so it's a bit bit it's a little bit
harder for the average developers now
you can also get a path from URI yes
your I can have the encoding of the URI
that the type can indicate which file
system to go retrieve it from so the
file systems manager will look up the
right file system so you could have like
jar colon
you know foo will know to go get the jar
file system or mem colon or anything you
want so there is only one method there
is only one method that that that always
goes to the default file system and
that's that that's the get method it
takes a string
yes Jimena and that and it's because is
to make it simple for the common case
yes you can
okay Martin has a call so Ellen it is
you know I have a one-track mind the
only application I really care about is
RM dash RF and
and which is surprisingly difficult to
get right
that is a really that is a really really
hard system problem okay so one of the
things that we did not cover today is
something which we call the secure
directory stream and the secure
directory stream isn't is it is a
specialized type of directory stream
that allows you to deal with race-free
operations in the file system so you can
actually cast your directory stream when
you open the directory to a secure
directory string and the secure
directory stream provides then
operations that work relative to the
open directory so your attacker which i
think is what you're thinking about is
moving the or swapping the directory
right so so someone leaves the company
and they leave the leave a program
running that that makes symlinks to
slash and then and then removes them and
write an infinite loop and meanwhile the
system in estrella does RM dash RF
except it's written in Java and you want
to not remove all the files in the
company right and the only thing I can
give you is the secure directory stream
for that because it's a really really
hard problem now you could actually
provide something like a higher level
thing to say
remove this redirector we recursively
which you could provide the higher level
thing but it would be nice if if there
was enough infrastructure to provide the
lower level as well yeah so the interest
do the infrastructure we have for that
really is is the is the secure directory
stream so we're not providing the
equivalent of a cheater which is what
was the way a lot of these UNIX
utilities actually work is the best we
can actually do is the star at type of
API which is what they secure director
stream gives you
it's that it's just within a directory
you can there's actually a name matcher
there so if you want to do something bit
more complicated with star star then you
could do that okay yeah give you the mic
okay go get those static methods that
you have which actually go out and
access the file system do they all have
alternatives that would just be instance
methods on the file system instance or
via the file system instance yep so if I
wanted to make sure that all of my
accesses outside you know all of my IO
was happening not through static methods
but through a chain of instances I could
I could just do that I wouldn't have to
use any static methods yep yes that's
what I wonder here okay yeah the static
methods are generally just two
convenience methods that wrap some
existing instance methods Oh Mike to the
back I'll just be the Mike guy I guess
I'm curious for using a file system for
multimedia applications do you guys have
any way of reserving performance or
promising performance or you know are
there any calls to tell you how well
that system performs you know that you
can string things out of it or we
haven't to cover that time up that would
maybe be something on file store but
kind of an extended attribute on file
store yeah yeah potentially oh yes okay
yes so today we just talked a bit about
file systems attributes or file
attributes but we also support access to
file store attributes and I don't know
whether that whether the information
about performance is something that's
available for a particular file system
or a particular volume or whatever if it
is then the this this is potentially you
could actually get to that information
so and the work the one the only the
only file store attribute view that we
require in the platform in the current
version of the API just provides
information about space information
so and how much space is used how much
is free that kind of stuff but as per
the file attribute views this is
extensible so if if someone wanted to
actually develop their their own view of
some other more interesting and file
store or volume attributes and they can
actually plug this in yeah I guess my
kids would be that done if you want to
guarantee a certain performance while
you streaming something with it right no
there is no third you have reservation
happen right door yeah there isn't there
isn't reservation API in there yeah no
more questions well thank you all for
all right mate oh yeah
thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>