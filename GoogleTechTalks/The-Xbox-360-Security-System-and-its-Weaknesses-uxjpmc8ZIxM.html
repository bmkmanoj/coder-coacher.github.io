<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Xbox 360 Security System and its Weaknesses | Coder Coacher - Coaching Coders</title><meta content="The Xbox 360 Security System and its Weaknesses - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Xbox 360 Security System and its Weaknesses</b></h2><h5 class="post__date">2008-08-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uxjpmc8ZIxM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody so this is a talk that
involves video game consoles a lot of
lots of us like playing games on our
video game consoles and I have two guys
here Michael and Felix who like playing
with their consoles a bit too much and
so much so they make them do things they
were never intended to do and we all
like doing that in some walk of life but
let's hear the story of Xbox 360 and the
security and what kind of things that it
can be made to do that it wasn't
intended to from both of them
so welcome so hi I'm Michael and I'm
going to do the presentation part and
later for Q&amp;amp;A Felix is going to join me
so I'm going to do the talking and he
did the actual work behind all this the
Xbox 360 security system and its
weaknesses whatever okay the purpose of
this talk and we've given several talks
about console hacking especially Xbox
one hacking before and it was all about
bashing the security system bashing the
work that Microsoft has done with that
one but it's a lot different with the
Xbox 360 the security system is really
great but the problem is that few people
know how it works or how great it is and
the whole industry keeps making the old
xbox one mistakes over and over again
because there's just not enough
documentation out there there's no
scientific paper or anything from
Microsoft so the idea of this talk is to
educate people on secure hardware design
to see how Microsoft did it and still
the mistakes that they made what could
be done better in the future um yeah
well first first of all let's do all the
QA afterwards and yeah I'll come to the
point
why it's a great security system in the
whole talk I guess so let me first talk
about why it's necessary to have a
security system on a gaming console is
pretty obvious copied games shouldn't be
permitted and licensed games the
industry has always had this problem
cheating is pre interesting for online
games today and also if you can lockout
modifying consoles to run Linux or
alternative operating systems or
homebrew program programs that you don't
want to have on your platform that's
also a nice thing and what Microsoft has
done and what pretty much everyone else
is doing is just have one security
system that controls what software may
and what software may not run on your
platform so in order to talk about the
Xbox 360 model let's just spend a few
minutes on revisiting the Xbox one model
again and see what mistakes have been
made there and what has to have to be
made better for the second console that
Microsoft made the Xbox one had the
problem of they had little time
developing it in just over one or two
years they had to start from zero and
get a full gaming consoles of what they
took was a standard PC basically and
their existing Windows so after Windows
kernel DirectX and all these
technologies and they put this system on
top of it which is a chain of trust
which means any time code hands
execution to another piece of code it
will have to verify the authenticity of
the next piece of code and only in that
case it can hand over execution so in
the case of the Xbox system startup
hands execution to the Windows kernel
which is rot in ROM if it's ok and the
Windows kernel will launch a game only
if it's also signed so these are
typically RSA checks or hashes mmm let's
look at the first step here how the ROM
can make sure that the Windows kernel is
authentic and hasn't been tampered with
this is the main board of an Xbox one
with a CP
you GPU Ram Southbridge flash normally
an x86 compatible cpu as in the Xbox one
would run would boot from flash but of
course then you could just replace your
flash and the first instruction you
would be in control of the first
instruction that is executed so what
they did is they added some special code
secret code 512 bytes of it into the
South Bridge chip which on boot gets
transferred over the bus and which is
the first code executed which does some
verification decryption of the flash
image and then jumps to the flash image
the problem with this is it travels over
bus although the bus is pretty fast
there's always someone in this case and
that's funny who managed to build his
own hardware to sniff that bus so the
secrets leaked and also the code leaked
so the first successful attempt that was
made there is bus sniffing and this is
the code that was extracted the purpose
of the code is does some basic machine
initialization which is done using a
small virtual machine which takes code
which which takes its instructions from
flash image does the CPU setup decrypts
and in theory also verifies but in
practice doesn't really the flash image
and if it doesn't succeed panics so if
we want to use this we have to look at
the board and what we see is this port
here which is an LPC port we add a pin
header and add a modchip which is
nothing more than just a ROM chip which
works because when an Xbox is
manufactured they have to use this port
for bootstrapping
the first time they boot it they booted
off this bus because the internal flash
is not written yet and then switch to
the internal flash and write that and
that's still present on on a retail box
and because the flash verification in
that code that was extracted wasn't
really working this was made possible so
the second thing was manufacture time
override the second successful attack
so it can run anything like this
bootloader that runs your favorite
operating system the chain of trust the
first part was hacked but if you don't
want to go the hardware way but try to
exploit something in software the second
check from Windows to the game looks
pretty secure because you have a lot of
code variants I mean buy a lot of code I
mean you have enough space to fit a real
RSA implementation from the windows
source code base for example so this
this looks pretty secure but games load
their own data and this data can be safe
games and there's always the possibility
of buffer exploits there and the nice
thing is that all the games run in
kernel mode on the Xbox one so this is
where this gentleman enters
double-oh-seven is one of many games
that have string vulnerabilities in
their safe game loaders and because as
soon as we have a few bytes of code in
in the system in kernel mode we can
chain load as many bytes as we want this
is this third successful attack chain
loading any code which can be your own
operating system if you want to have
everything a little more permanent but
not install your own hardware you can
boot into a Linux system and then
rewrite your flash image by with another
boot loader this doesn't work by default
because the flash is write-protected
Microsoft does not has not planned in
field upgrades of ROM chips but if you
just add two wires to the mainboard this
will be successful so flash
reprogramming is a fourth thing that
happened which shouldn't have happened
and one more thing that has happened is
it if you don't insert a game it'll load
the dashboard which allows you to do to
manage your saved games to play CDs DVDs
and that also loads some data which also
is not checked so by installing fonts on
the hard disk we can convert this into
this note the subtle difference
and one more hack that has actually not
been done because there have been so
many other hacks so this one wouldn't
have made sense to do is the DVD Drive
should be untrusted but the DVD Drive is
the one that basically checks whether
it's an original game or it isn't
so the CPU trusted it tells the the
drive tells the CPU we can just lie and
you can replace the firmware with your
own firmware which will just always lie
so this would be a fifth attack of the
DVD attack as I said there are no in the
field down upgrades by Microsoft I mean
yeah upgrades not downgrade so but still
if there are new revisions new new boxes
manufactured they will come with new
system software and you can use the old
software to just downgrade the newer
boxes because there is no Rev locking
anywhere so sixth successful attack is
downgrading let's look at all these
attacks again the sniffing flash
reprogramming manufacturer time override
chained load code downgrade DVD attack
and there's one more then that has not
been used on the Xbox one because
there's no way the hardware would have
supported it there have been a lot
weaker points in the system it's code
injection via DMA which means if you
look at the busses inside a computer
system the DVD drive the hard disk
networking USB and also the graphics
chip they all share the same bus so they
can all read and write arbitrary memory
from a physical standpoint without all
the paging without any protection so if
you manage to make your device right
somewhere you can change anything if you
know the address where something is but
this that seems to be pretty constant at
many systems so you can just modify your
code to not check anything anymore you
can just attach a chip waits for
something triggers on something and
inject something into RAM when it gets
read for example there's this famous
firewire hack you just attach something
on file
by our bus and you can inject anything
onto that machine because the firewire
cable is pretty much sits on the bus of
your computer so they had to do
something against this too so let's look
at these attacks again and let's think
about some different ideas how to
mitigate those attacks the first thing
and the major weakness of the Xbox one
was that it didn't have enough ROM for
startup just these 512 bytes which
weren't nearly enough to do any secure
authentication of whatever it ran
afterwards also it didn't have any
internal RAM so all the keys everything
it's dealt with while decrypting while
verifying was stored in insecure Ram so
what we need is an lot of ROM in the
order of magnitude of 16 32 64 kilobytes
for the decryption verification code and
also a little bit of machine setup and
in big enough internal Ram so that we
can store all the intermediate data this
way we can boot up we can make Buddha
really secure so that by keeping it
minimal it's we can be pretty sure that
nobody finds an exploit then we can
chain load something that is really
trusted so the first thing bus sniffing
doesn't make any sense anymore if we put
the ROM and the RAM directly inside the
CPU there's no bus to sniff anymore
there are no secrets going over any bus
also this way flash reprogramming is
pretty much impossible if we implement
it right and by having like 32 kilobytes
of ROM and 64 kilobytes of RAM we can
make that possible then the next thing
to do is decent privilege separation
which the Xbox one did not have like
everything ran in kernel mode now on the
360 everything will well the everything
will run in kernel mode - except for the
hypervisor that will run in hypervisor
mode and the hypervisor has some extra
privileges that kernel mode does not
have this is pretty much the same setup
as kernel mode user mode just shifted up
by one level into hypervisor mode and
car
which has speed advantages otherwise
it's basically the same hypervisor mode
manages your MMU it manages the page
tables and TLB it can enforce write X or
execute which means that a page in
memory is either writable or it's
executable but it cannot be both
so whenever a program or whenever an
exploit wants to write its own code
somewhere it can write it but it kind of
make it executable so a game has no
means of making data executable it will
always have to go through the hypervisor
and the hypervisor can then decide by
using signature so this way chain
loading code is pretty much impossible
something like return to Lib can still
be possible but this is yeah pretty much
the best thing that can be done here so
chain loading code can be made
impossible using this but now if we were
an attacker we had the system that boots
safely and has a hypervisor how would we
attack it we would use something like a
DMA attack to inject code into the
hypervisor we couldn't just change some
key in the hypervisor by by attaching
something to the USB bus or to any bus
so we have to make sure that DMA
injection does not work the way we can
do this is memory hashing which means
that this is implemented in the must be
implemented in cache so anytime a cache
line is written back back out to RAM
then a hash will be stored in the CPUs
internal memory and every time a cache
line is read back it will be compared to
the hash and if it's wrong then the
system will just lock up so this pretty
much guarantees that every time this
guarantees that all the memory that I
ever read that is under this system has
been written by the CPU and has not been
written by any device because if a
device writes it then there is then the
hash will not match of course we have to
do DMA in the system so we cannot make
the whole the whole system not olive Ram
and be under the system so this needs to
be an opt-in feature or opt-out for all
those pages that require DMA this is a
nice system it's very effective but the
problem is we need extra storage inside
the CPU and this can be very expensive
in order to solve a cache line on the
PowerPC CPU as it's used in the 360 is
128 bytes and in order to have a secure
hash of that we need about 16 bytes so
for a 64 kilobyte internal Ram internal
to the CPU which which is pretty
expensive we can only access or we can
only secure about a megabyte of external
RAM the Xbox 360 has 512 megabytes of
RAM so there's no way we can secure
everything using this so in practice we
can protect the hypervisor which is way
below 1 megabyte of code so code
injection via DMA we get 1 star for this
if we also want to protect everything
that runs in unprivileged mode which is
the Xbox kernel and the actual game if
we want to protect that as well from DMA
injection attacks then memory encryption
can help us it's not as good but it's a
lot cheaper it also works on the cache
level so every time memory is fetched it
is decrypted and every time it's stored
back its Rhian cryptid the same applies
here it this cannot work with pages that
require DMA because of the very idea
behind it whenever you have DMA it
shouldn't be able to write anything
which is marked encrypted and therefore
secured but while DMA into something
protected by hashing will lock up the
system in this case it will only destroy
the data because if you DMA something
then it will be in plain text in memory
but when the CPU reads it it will try to
decrypt it so it will get gobbled data
so this can be used for some attacks
like if there's a blacklist somewhere to
blacklist some application
we can just destroy that black list and
the compare will not match anymore also
some jumps on PowerPC or well a jump on
PowerPC is if I remember correctly just
six bits so six bits encode the the jump
and the rest is the offset so there's a
pretty good chance that if we try this
over and over again we might hit the
correct six bits for a jump and just
jump somewhere and then can fill the
whole memory with knobs to catch our
jump so this is not perfect and not as
effective as hashing but it's cheap and
we have it's there is a small
performance penalty but we don't need
any extra RAM so in practice we we can
use this to protect the hypervisor and
also all the game code and what's nice
about this is it offers Cades everything
that is in RAM or everything that we
want to protect in RAM so all the code
in RAM cannot just be sniffed by a DMA
device so we can make the whole system
obscured so that no code will ever be
visible anywhere if we encrypt the games
if we encrypt the flash so an attacker
will have a hard time to find any code
that you can look for security
vulnerabilities in so code injection via
DMA that gets us another half a star a
random number generator is another idea
which can improve the effectiveness of
the previous techniques the problem with
the encryption that I've described so
far is that it is that it would be
predictable so I can do
replay attacks if I dump my memory at
one point and replay it at some other
point the encryption would still be the
same all the time and I could inject a
different state or I could inject a
state of off previously into some part
of the system and keep the state in
another part of the system to make
things mismatched and to make them
behave as I want them to so by choosing
by having a random number every time
this the system boots
there's no way to replay anything
anymore and
all the data will just be garbled again
this will give us another half a star
for a code injection now if uses is
another interesting technology invented
by IBM and implemented in some of their
products and the PowerPC chip on the
Xbox 360 is also done by IBM it's a way
to well any fuse they are cheap you can
have lots of them you can have hundreds
of them on side CPU and you can blow
them at runtime so there is no way to
undo this later so one nice feature that
we one nice way to use this would be to
disable features that we only need at
production time for example JTAG all the
things that we need for verification for
testing in the manufacturing process can
be disabled later on by blowing a fuse
also we can make every CPU have its own
unique per box key by also blowing a
couple of fuses and burning the key into
the CPU and that key will be inside the
CPU and will never leave the CPU if we
don't choose to this key can be used for
crypto on the flash chip so that the
flash chip will be encrypted just for my
box I cannot swap any flash chips and
also indirectly it's used for DVD
pairing for keeping a secret in flash
which is a key to pair with my DVD ROM
Drive so that I cannot use another DVD
ROM in my systems I cannot swap those or
I cannot manufacture it just a DVD drive
or a device which emulates a DVD drive
but in reality is a hardware and just
emulates those games on the hardware
because those are changed together my
DVD drive needs to have the exact same
key as the Xbox also whether it's a deaf
kid or it's not a deaf kit will be
stored in the fuses deaf kids behave a
little differently they allow a lot more
things and update revocation whenever I
update the system
blow a fuse and even if someone down
grates the flash chip by disordering it
or by doing anything fancy it will not
accept this flash anymore because the
revision count in the flash is not the
same as the number of blown fuses so
this will give us a few nice extra
features manufacture time override
we pretty much mitigated that
downgrading can be made impossible if
implement implemented properly and dvt
DVD attacks are made a lot harder
you'd have to dump the key of the box in
order to make a device that emulates a
DVD drive and also code injection via
DMA is harder using this because we have
a per box key which can be used as a
seed for the random number generator and
other things so everything we need
hypervisor SRAM in the cpu some
additions to to the to the caching to
the yeah to the way addresses are
generated fuses and a random number
generator the nice thing it can all be
implemented inside the CPU there is no
dependency on any external device this
is easy version of what three core
PowerPC system would look like with the
three processors their own mmm use each
connected to their l1 cache and that
connected to the l2 cache and what can
be done to add all the security without
changing any of the actual architecture
of these components is just adding stuff
outside of it so yeah this is the
standard core and we can add a random
number generator if uses ROM and SRAM to
the system external to the actual CPU
and by adding some logic which does the
hash
calculation and does the crypto for
loading and storing l2 cache which is
and which is connected to s Ram because
of the hashes that it stores we can yeah
adds the whole security external to the
actual normal CPU but what we have here
is still one die so nothing travels over
any buses everything is inside the CPU
which has to be a custom part anyway for
the Xbox one it was a standard
off-the-shelf Celeron CPU but you won't
be able to find any three core power pcs
out there so this has to be a custom
part anyway but still all the
modifications are done outside of the
critical regions so it is a cheap and
easy modification if we look at the
board
CPU North Bridge South Bridge flash ram
everything is contained inside the CPU
and nothing travels over any buses
anymore now let's look at some details
in practice for secure boot we have 32
kilobytes of internal rom and 32
kilobytes if you compare that to the 512
bytes of the Xbox one this is really a
lot you can fit whole RS a algorithm
sha-1 for verification in there to be
really sure that the code there that
you're running from flash is okay and
also 64 kilobytes of internal ram which
should be fine for your calculations
hypervisor mode is something that is
supported by 64-bit PowerPC processes
anyway the hypervisor code is about 128
kilobytes and as I said before it's it
manages the page tables enforces write X
or execute all the impractical the pages
from the hypervisor itself or hashed and
all the code pages in the system
including the high power of hypervisor
code end data are encrypted too and only
the hypervisor can make code executable
the hypervisor dots is very lightweight
it pretty much only does memory
management on a very low level it does
not interact with hardware at all that's
all the job of the kernel which is
running in untrusted kernel mode but it
has to catch all the interrupts and
exceptions and most of them it just
passes up to kernel mode now about
hashing an encryption that has been done
in a very interesting way on top of the
existing PowerPC architecture so a 64
PowerPC would support 64-bit physical
addressing but we don't need 64-bit
addresses on an Xbox 360 we only have
512 megabytes of RAM and some more IO
ports so everything should fit within 4
gigabytes which is 32 bits
so there are addresses generated which
have spare 32 bits on the top and this
is where some extra flags are
transmitted these flags mean something
to the l2 cache for the l2 cache this as
we can see in this example if we have
this magic value of 100 means that this
page has to be encrypted and hashed so
the CPU doesn't know anything about it
it's just a matter of setting up the
page tables to point to addresses like
these with the upper 32 bits set to
something besides 0 and the l2 cache
will take care of hashing and encryption
as we choose it yeah so hashing is
implemented in l2 cache for every 128
bytes which is a cache line we have 16
bytes si sha-1 and hashes are stored in
64 kilobytes internal CPU s RAM which is
the same SRAM which is used for boot up
for the crypto routines that run at the
very beginning of CPU startup so this is
enough for hashing one megabyte
encryption same thing implemented by l2
cache which looks at those extra bits
and the key has to be set up by the CPU
and taken from the random number
generator at startup
we have 768 bits 768 efj users that we
can blow individually the features of
those are for example JTAG disable so
the cpu supports JTAG but after all the
testing is done this is disabled the
unique key for flash decryption and for
many other things so many many things
are based on this key is also burned in
the fuses the Deaf Kaduri tire tail
identifier and the update sequence
counter now with I've just described the
whole security system in theory now how
does how do some things work like let me
explain some things in practice paging
so everything that runs in kernel mode
which is the Windows kernel Windows 2000
derived kernel and the actual game they
run in a paged environment so there are
page tables set up somewhere which are
controlled by the hypervisor and the way
encryption and hashing is managed is
just by putting those bits into the page
table so in this example the virtual
address on the left will be mapped to
the physical address on the right which
in the end is just the lower 32 bits in
this case but which also tell the l2
cache to in this case turn encryption
and hashing on so the hypervisor will
just enforce that every time a page is
executable it will also have the bit for
encryption turned on this is nothing
that the hard was enforces but that
hypervisor will enforce every time it
lays down a page table entry the
hypervisor itself is not paged although
it's encrypted and hashed so for some
reason it might be performance it might
be simplicity it's it runs without
paging which is called real mode but it
can still be encrypted and hashed
because of a feature called the
hypervisor real mode offset register HRM
o are every time you have every time you
have an address which has the the
uppermost bit bit 63 or
if you think powerpc then it's bit zero
which has this bit set means that the
the offset of the HR mor will be added
so every every time so the hypervisor
thinks it runs at offset zero and Ram
but this offset gets added which
effectively adds just the flags and
these flags mean that hypervisor will be
encrypted and hashed at manufacturer
time so how it does manufacturing work
all the e fuses when the CPU is
manufacturers is zero so the the ROM
that is embedded in the CPU will know
the special case and can behave
differently so it can boot a generic
flash image and then as download some
special code for the first time generate
its unique key and store it in the e
fuses it can personalize the flash image
and encrypt it with its own key and also
generate a DVD key encrypted with its
own unique key and store it in flash
loading and executable is something that
the Windows kernel cannot do by itself
because it needs to be verified and
verification can only be done by the
hypervisor so while the xbox colonel in
untrusted mode loads the executable into
memory it will hand chunk by chunk to
the hypervisor which will then check the
authenticity of the code and if it's
signed properly or if it's hashed
properly and the header will be signed
then it can make the code executable and
the way it can make the code executable
is pretty interesting if you have an
address and the same address with the
upper 32-bit set so that it's encrypted
and hashed and you just copy from that
one address to the other dress you will
implicitly encrypt it so it just goes
over the whole area and encrypted by
copying it to the same address plus
encryption and then lays down the page
table entry to make it executable
firmware updates look pretty
straightforward the way it's done is you
don't replace the flash for safety
reasons I guess they just append
patches to the flash binary patches and
every time you add an extra patch it
will have a secret sequence count or you
can count the number of patches and
every time you add a add a patch you
also burn one fuse so in case the last
patch is missing or one more fuse is
burned then you have patches then the
box can refuse to boot but still so this
was the system but there have been there
well there is at least one vulnerably
that has been found which is quite
interesting because it's in one very
prominent location which is the Cisco
handler of the hypervisor on the left
you can see the disassembly it first
compares the argument with 61 so you
have roughly a hundred or so sis calls
if it's greater or equal then it's
illegal otherwise it shifts it left by
two so it indexes an array of pointers
loads that value from the jump table and
loads it into the link register and
jumps there on the right you have the
same thing in C but can you see the
problem it's not about sind it's more
subtle it's these two instructions the
compare works on words the rotate works
on lungs
so it only compares the lower 32 bit but
then it takes the whole number and
shifted left so if we give it something
that is four million four billion above
four gig and has something very tiny at
the end it will pass this test but still
be way above this so we can feed in
incorrect values we can control bits 34
to 63 of the effective address
so the way this would work normally we
have siskel number of 2a we shifted left
by two we add that offset which is 1044
and then because the hypervisor runs in
real mode this offset gets added which
is because the uppermost the MSB is is
clear which means that must be added we
have this effective address with the
exploit we can do this we feed in this
address or this syscall number that's
fine that's lower than 63 if we only
look at the lower six lower 32 bits but
then we shift the whole thing left by
two so we have the MSB set now we add
the the offset again but now the base
does not get added so what we get is
this address which doesn't have the
protection bits which doesn't have the
bits that we need to fetch this from
encrypted and hashed memory so if we
have a way to store something at the sis
call in the SIS called jump table at 2a
which is not encrypted then the code
will read it from this address
unencrypted so we just need to do with
DMA injection into this one value and
then make it somehow that it executes
this disc all with this with these
parameters now how do we do that
shaders games cannot just sign
everything that they come with and it's
normally not necessary because you
cannot change that anyway because you
cannot copy a game but of course you can
copy a game if you hack the DVD drive
that's the first step then you can have
your own copy of King Kong then the all
the graphics data is not signed that's
pretty much fine the shader code that's
a problem that should be signed because
shader code is actually executable
code which runs on your graphics
hardware and that can access all of
memory and if you write good shader code
you can just write anything anywhere of
course you will not do the encryption
and all those DMA attacks won't work but
you can write those that that syscall
index unencrypted which we later need
unencrypted but the question now is how
do we do this
hyper call that's called the SIS call
into the hypervisor the interesting
thing and I regard this a bug is that
the thread state so the register states
of the threads are saved in an
unencrypted data segment so when task
switching is done this thread state
including all the registers needs to be
saved in RAM is it code is it a code
segment so that DMA attacks don't work
with a data segment it's a data segment
so we can just overwrite those registers
so we overwrite those registers using
the DMA attack using a shader to that
next time the registers get loaded from
that thread state will have the
registers for that sis call and then
we'll set the program counter to some
sis call instruction which is in in our
game or in the column so what happened
was this was reported to Microsoft it
was fixed by Microsoft in just six days
and but still there are lots of
vulnerable systems which can at least be
upgraded to that version so that you can
run anything on your box which includes
for example the Linux operating system
now let's look at the mistakes what has
been made wrong here the design looked
pretty good also what I like about the
design is that it's pretty easy pretty
simple it's I find it's pretty easy to
understand and it's all contained inside
a very simple system all all they're
simple ideas and also the implementation
has been quite good but still there have
been mistakes there's always three kinds
of
mistakes that you can make strategy
mistakes design mistakes and
implementation mistakes strategies
mistakes are the worst ones therefore
let's first start with implementation
mistakes so hypervisor interface
obviously that was a mistake but we
haven't found any other bugs although we
or actually lots of other people have
have looked at a lot of code and not
found any vulnerabilities there the
implementation was really good which
might have been caused also by the fact
that the code has always been kept
minimal so it's not just linked
everything in it or look at every case
just keep it simple keep everything
minimal so that you don't have all those
mistakes as it was shown with the Xbox
one in just 512 bytes they managed to
fit three or four security
vulnerabilities with the design I think
they have made a few mistakes with the
design first thing is the thread state
and also all the stacks are stored in
data segments registers are something
that should be regarded as code they are
just as valuable as code so they should
not be stored somewhere where DMA
attacks are possible they should have
put this into encrypted data it makes in
a way it makes sense to store them in
unencrypted data because encryption
gives you a tiny performance penalty and
having your stack in encrypted area
which gets read and written all the time
might not be a good idea performance
wise but still this attack wouldn't have
been possible if those had been in in an
encrypted area also the hypervisor runs
without the MMU and with this system it
was possible to use that hack with the
uppermost bit if the hypervisor had used
page tables too it would have been a lot
harder it's if you look at it if you
look at it from a design perspective you
might think that the hypervisor is the
piece of software that is in control of
the whole system why should I
limit the powers of that single piece of
software would
has full powers anyway or which requires
full power but it does make sense that's
the principle of least privilege even if
you if that code must be absolutely
trusted not every part of the code needs
to do everything so if the hypervisor
runs with an MMU and cannot just access
all of memory can it just access
something unencrypted by just having a
different pointer but would have to set
up a page table in order to do that then
it would have made this hack a lot
harder at least if not impossible and
well DVD security also was pretty much
absent the I guess the reason was that
Microsoft was not in control of the DVD
drive itself they had several
manufacturers make the DVD drive and the
DVD drive itself is not a secure system
so it couldn't really be trusted
so there was always this possibility of
the DVD drive lying to the system now
the most severe mistakes that have been
made over and over again by pretty much
any company which are the strategy
mistakes point number one never use a
single security system to lock out two
independent groups of attackers or in
other words don't protect the
interesting assets with the same key as
the important assets and by interesting
we mean interesting from a hack respect
perspective and important as from the
companies from the manufacturers
perspective because this has happened a
lot in the past let's look at devices
since 1999 the PlayStation 2 released in
1999
I don't really know about how the
security worked or how and when it was
hacked but it was hacked for piracy and
yeah the effect was obviously piracy but
after that there's this German set-top
box D box 2 in 2000 her sign kernel
pretty lame security from today's
perspective but it had something just
didn't just run any code was hacked in a
very small amount of time it was hacked
in order to run Linux but it had the
side effect of people decoding pay TV
GameCube encrypted boot it took quite a
long time because people weren't so
interested in that platform they were
interested in running well it came out
at the same time as the Xbox and the
Xbox had a hard drive and was a PC it
would have run anything and the Gamecube
was this limited small system so it
wasn't all that interesting just when
the Xbox was finished all the Xbox
hackers went over to the game view so
why was hacked was also yeah for
homebrew for the good cause and the
effect was piracy Xbox it was hacked for
Linux for homebrew and yeah these hacks
have been abused for piracy because any
time you can run your own code you can
just run any game that doesn't have all
those checks that might be embedded in
the game anymore do you see a pattern
here
Nintendo DS same thing for homebrew used
for piracy PlayStation Portable same
thing happened to the 360 it happened to
the Wii what's really interesting is it
was quite quick on the Wii but wait
there's one that is different there's
the PlayStation PlayStation 3 the
PlayStation 3 has had has a security
which is comparable to the Xbox 360
security but yet it has not been hacked
although the Xbox 360 has been hacked
and why is that well they provide a
means of running anything you want they
have this this this run other OS and you
can just run Linux or you could port
your favorite operating system to it so
the hacker community just hasn't been
that interested in it
there's the piracy community and that's
the homebrew community and the homebrew
community are the really good people as
it shows
so yeah if someone wants to design a
good system the first and most important
thing is to keep out the hackers by just
letting them do what they want to do
okay we're up for Q&amp;amp;A now and as I don't
know anything
felice is your man Hey so anybody Wow
well must be a pretty good presentation
then where everyone is confused so
there's all this there's all this
encryption and decryption going on at
runtime during the course of playing a
game
is there any measure of what are the
cost semantics behind that is it does it
detract from the power of the system to
have this to have to encrypt and decrypt
every page of memory in terms of
performance yeah so um I was told I'm
not completely sure if it's true that
there's a cost of latency but not really
of true port so the memory latency is
like 500 clock cycles or something
anyway so it doesn't matter much if
they're like 16 additional cycles so
that's basically the key like hiding the
latency from the encryption because the
true put isn't the problem the latency
is and that's high enough anyway so that
doesn't really matter so I was told
there is no real yeah
coast of this encryption because
otherwise I mean performance costs money
especially in that console market so
they wouldn't have done it if it really
costs performance so apparently no
there's no real cost of the decryption
yeah they please step up to the
microphone Thanks
with all this data and code hiding in
inside the CPU could detail what it took
to actually and find the hex and you're
in this question would come up so given
enough time I think every secret can be
exposed and it was the same on the
system we don't really want to disclose
how we initially got the hypervisor code
but it was not Likud and I think M it's
not a hack which can be repeated to
something but it was another heck so you
shouldn't rely on the fact that
something is secret or secure in a
system you should rethink that at some
point the hacker will know every secret
of a last one specific device and your
security should still work all those
things are known so your code should be
secure even if people know it I mean
that's nothing new but I think this that
the Xbox shows again that this is an
important thing so I'm sorry I can't
really answer your question so it's a
long story
with all the increased security in terms
of hardware checking how does that
affect the cost of fixing broken parts
so it seems that if we've got these efj
users linked in to a DVD Drive and the
DVD excuse me the DVD drive stops
working how would that affect replacing
that part so um while the actual DVD key
is not encoded in the e fuses the e
fuses encode a key which is then used to
encrypt the so-called key word which
contains basically all the interesting
that the power console stuff like the
DVD key so because Microsoft can sign
any code they want they could just do a
binary which is signed and run that to
basically dump the internal key to
decrypt then the key word or encrypt the
new one actually this is done a bit more
intelligent the CPU key never leaves it
CPU so even why production and even
while upgrades and repair at no point
you need to know the actual key like
this an API
I to the hypervisor where you can for
example set a new DVD key provided you
authenticate yourself for the challenge
which is even another API and the
hypervisor so it's all based on knowing
the right keys if you know the right
private keys you can authenticate to the
hypervisor and basically do whatever you
want so that's what I do for repairs and
production and development and
everything else
you
why is that the shader code can read all
of memory and so your question is why a
shader can read and write memory so this
is a unique feature of 360 GPU it
actually can do it has a features called
memory export which is basically the 360
is a Direct X 9 based platform so it
doesn't have those geometry shaders and
stuff but to to have some new feature
they added this called memory export
which basically allows a vertex shader
to write its the generated data to the
memory so a later shader can pick up
that memory and do a second pass over
the geometry or something so that was
intention to at this memory export
feature which is actually just writing
an address to a special GPU register and
then writing the data to a special GPU
register and that will actually put the
data into memory so it's used for multi
pass geometry and although pixel shaders
if you really want but we abuse this
feature for writing stuff we care about
into memory
so what's the current state of homebrew
how safe it is and maybe a little bit
about the tools that are out there so
the thing is that Microsoft quickly
patched the problem at first day just
patched the single instruction which was
wrong which is that the shift
instruction they patched it to doing
just a 32-bit shift so the upper 32 bits
are dropped which fix the issue in later
versions they also improve the memory
protection so now that red data is
actually in encrypted memory they added
an API for this and they did some other
things so unfortunately it's not so easy
to downgrade and exit and up-to-date
xbox360 - back to the burner burner
mobility version f sorry so M there's
been another attack which is called at
the downgrade attack or the timing
attack um we're just yeah a bit
complicated to explain but basically it
allows you to with some small hardware
heck to downgrade an existing Xbox to an
older corner which has the problem again
so we can be exploited unfortunately the
really recent Xboxes which have the
reduced power like the the 65 nanometer
CPU don't run the old carnal anymore
this is not an intentional fix or
something this is just because they also
have a different GPU version where the
old colonel doesn't know anything about
so um oh it Xbox is like old hardware
can be downgraded using small hardware
heck which basically involves like some
timing measurement and some flash
overwrite so you can do a timing attack
on some specific data and the newer
Xboxes cannot be down with it so there's
currently no way to do homebrew on this
the disadvantage of all those methods if
you downgrade your carnal you cannot run
any recent games anymore so you are
forced to not buy any games anymore if
you want to do Home Rule so and you need
a separate mission for Home Rule and
yeah that's the disadvantage of the heck
it you have to run the heck every time
you boot your machine because there's no
way to we haven't yet found it back in
the boot loader and the ROM
of the CPU or something which can be
used to automatically start the kernel
every time you boot so you're all the
time you have to lounge that game with a
heck trader and run our code so the
xbox360 had a bunch of hardware glitches
right it it's just not as stable as the
three sick as a original Xbox was do you
have any clues on why that is so or if
it's because of the security to put in I
don't think it's security related I
think they had some some manufacturing
trouble I don't know exactly there was a
lot of media coverage about this those
issues and I think nobody except
Microsoft have except numbers on this so
I have like 10x boxes at home and not a
single one of them failed so the numbers
telling you that 30% or more of those
are failing they are just not true at
last for me I'm not sure about the
greater number of X boxes but it is a
problem I'm not sure how large the
problem really is but I don't think it's
related to security it seems to be
related to some thermal stressing of the
GPU actually I'm not a hardware designer
so I don't know exactly and it took
Microsoft a long time to get a real fix
for this so it seems to be a harder
problem than it yeah then it would seem
the first side so
okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>