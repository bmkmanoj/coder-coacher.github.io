<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Issues and Experiences in Designing Real-time Collaborative Editing Systems | Coder Coacher - Coaching Coders</title><meta content="Issues and Experiences in Designing Real-time Collaborative Editing Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Issues and Experiences in Designing Real-time Collaborative Editing Systems</b></h2><h5 class="post__date">2008-11-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/84zqbXUQIHc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon all right it's my
pleasure to be at Google to deliver this
seminar
the title is issues and the experience
in designing real-time collaborative
editing systems
my name is tendon sound from the School
of Computer Engineering Nanyang
Technological University Singapore this
talk will consist of two parts the first
part is focusing on the collaborative
editing algorithms and technique design
the second part will be the system
design and both parts are based on over
15 years exploration of collaborative
editing technologies from 1b text
editing to 2d word processing and 3d
digital media design collaborative
editors first algorithm design and this
part we need to have a clear definition
of what is called collaborative editing
a general definition is that a real-time
collaborative editor allows multiple
users to edit the same document at the
same time over the internet as you can
see these are their familiar logos for
the famous collaborative real-time
collaborative editors and Google Docs is
there that's the experience why I'm here
to give this talk and also to systems
and I'm going to explain in more detail
that is from my group Kamiya and the
code word for this general definition we
can have many different interpretation
about what is real-time collaborative
editor I want to elaborate the following
points a real-time collaborative editor
is an editor which is no different from
the ordinary editors you are using with
the completion of functionality still an
editor secondly a real-time
collaborative editor is different from
the editor you are using because it is
able to support multiple users to edit
the same document at the same time
and finally the lowering of editing
is generic in this context an editor can
be used to edit a wide range of
different documents including text
graphics spreadsheets image documents
and also includes say ad digital media
design digital media models computer
game states and virtual environment
States another important point in c c/e
system is that human users are part of
it and in this context we see a
hierarchical structure of communication
protocols in this structure on top of
that we have two users sorry two users
and they are also communicating with
human protocols and collaborative these
editing designers are not interested in
anything below the application layer in
the hierarchy starting from application
layer we design application protocols
and if we are restricted to this area
this is a conventional distributed
computing or internet computing research
focus and we cover this this part in our
research but our system is not just a
distributed system it is also involves
human-computer interaction human user
part of the system and this is also not
a single system it involves multiple
users collaborating over the internet so
altogether this is the scope of our
study it involves distribute computing
human-computer interaction and the
collaborative computing and involve
human users and with user in the system
we have some special challenging issues
and also human users can make some of
the solutions easier some of the problem
even harder
the first issue which is related to
human users is the interactivity
experience human users have been using
editors for so many years they had good
interactive experience with single user
editors they would expect to have
similar experience so we should aim at
achieving the same interactivity
experience however in the internet
environment communication latency is
much larger than this interactivity
requirements much higher than 100
milliseconds latency is threshold value
and also we should realize latency can
be improved by technological improvement
advancement but there is an ultimate
limit that is limited by the speed of
light determined by the law of physics
eventually the wrong tilt around the
trip delay around the door is 200
milliseconds we can't go beyond that and
200 milliseconds is doubly days 100
milliseconds threshold value so we need
to weigh out we can't get rid of latency
but we can hide it a technique to
achieve quality interactivity in the
internet environment is latency hiding
that is to create the illusion that
latency is lower than it actually is so
that's what we call the magic of latency
hiding widely used latency hiding
technique is replication in the
collaborative editing context the editor
and the shared document are replicated
at all collaborating sites in the
collaboration session the operations are
forced excluded locally to achieve high
responsiveness and then propagated to
remote sites for lotia vacation also for
maintaining consistency of replicated
copies the main challenge in the
replicated collaborative editing
environment is how to maintain
replicated arguments consistency in the
face of concurrent editing operations
there's has been a lot of research in
the past decades and one consistent
model specially designed for
collaborative editing system was
published ten years ago in
1998 with three consistency requirements
convergence causality preservation and
the intention preservation in the
following slides I will go through the
three requirements one by one
convergence requirements is a but is the
requirements that all replicas of the
shared document must be identical after
executing the same group of operations
taking text editing as an example these
two users starting from the same text
string one to two characters initially
the document is identical and two users
can independently generate two editing
operations one is to insert X before one
to another to insert y at the end of the
text these two independent operations
can be executed immediately to achieve
high concurrency and also achieve high
responsiveness and also generate
temporary divergence this divergence is
tolerable and acceptable to these users
but after these two operations
propagated through the remote sites we
require they count after excluding the
two remote operations the final
documents should be the same should be
the same that is the recording record by
the convergence secondly we need to
achieve preserve intention what is the
intention intention is the local effect
of operation when you generate the
operation it has a local effect but when
the operation is executed at remote site
that effect should be preserved in the
face of concurrency because maintaining
car I 10 I think identical document is
not good enough for the correctness of
this system we need also to preserve the
intention taking taxation as an example
initially document states ABCDE and then
at same time two concurrent operations
generated inserts one to add to the
occasion two
the intention of this operation is
insert one two at position two that's
clear and another operation he needs at
position three two characters that is to
T need C and D that is the intention
that's the local effect when the
operation is generated we want to make
sure that effect is preserved at all
remote sites in the face of concurrency
now after propagating these two
operations to remote sites on the right
hand side the operation is executed in
the original form and this exclusion is
able to achieve the original intention
and that entry is to insert 1/2 between
a and B that is done locally and
remotely and the Denisha also happened
to Accord to the correct tool characters
City are deleted but on the other hand
when this delete operation is propagated
to this side if the operation is
excluded in the original form the
Tunisian were incorrect in it he needs
two characters which is not CD but wise
is to another is is P these two
characters are not intended by the
original pressing so this is called in
thanking validation the correct result
should be this one should be this one
now you may ask what's the difference
between intention preservation and
convergence convergence only recall the
two copies are identical they could be
identical on the wrong result the
intention preservation add another
criteria so you should be correct on
this copy not this one so if we are able
to force both sides to achieve this
result we achieve convergence but we
lose the original intention that is
intentional violation so both criteria
together ensures a correct and
consistent result the third criteria is
about causality preserving
operations must be performed in their
Letcher causal effect order take this
time we need to take three sides as the
example still text editing suppose one
user just type a question artificial
question very simple - what is the sum
of two plus three and propagates this
operation to other remote side and
suppose this operation arriving at the
middle side forced on this side see
these results and then respond with the
answer
the sound is five so sum is five
following the previous question this is
the right result but we noticed this
operation arrive at the middle side
first and then arriving at the third
side but this operation caused only
after this operation because it's
generated answer to the previous
question happened to arrive at the third
side earlier than the question itself
their natural causal effect order has
been reversed and in this case the user
at this side will be confused by saying
the answer before the question and in
other cases it could be the one
operation is to create an object the
other operation is to Denise the created
object the Denisha may arrive earlier
than the creation in that case the
system can be confused by saying the
clinician before saying the creation and
in all cases causality violation can
cause the conclusion to both the system
under the user and this has to be
corrected by delaying this exclusion and
in this order in that way we have
maintained causality and I should point
out maintaining causality is a classical
technique issue in distribute computing
there are many different techniques to
ensure this and I'm not going to explain
what technology can be used there are
plenty of them to choose from whatever
folks are the technique which is able to
achieve both convergence and in thinking
preservation that is the special
technique invented by
collaborative editing researchers
technique has the name operational
transformation they as I said this
technique is able to achieve both
convergence and the interim preservation
but at the same time it doesn't impose
any restriction on the users that is the
very important feature of this
technology unlike unlike other
traditional supercomputing technology
like locking and serialization they
impose restrictions on the user side and
as we point out users are part of the
system the technique should meet users
needs and students restrict users
interactivity and there is a paper on
these Soviet paper on operational
transformation that was also published
ten years ago and you can find a variety
of operational transformation techniques
they are in detail now in this context I
will give you one slides to explain the
basic idea of operational transformation
still taking text editing as the example
starting from a technical document one
two and two independently generated
operations and look at this this or
begins to insert character y at position
3 now with operational transformation a
remote origin arriving at the remote
site it will not be excluded in its
original form it will be transformed
against another concurrent operation
concurrent operation in this case this
transformation can change anything with
regard to this parameter there is no
change for what reason I will explain
later but on the other hand this
operation when it arrived at this site
operating tool will be transformed
against operation 1 the parameter
position reference parameter 3 will be
transformed into full the reason is to
take into account taking into account
the effects of this concurrent operation
because it insert 1x
on the left side of this string and that
pushed the correct position by one to
the right so to compensate this push we
change this parameter to make this
operation right that is the basic idea
of operation transformation and to make
sure operation transformation works
correctly there are a large number of
properties for the transformation system
to maintain one of them which is
directly related to this scenario is
this the following the two concurrent
operations can be transformed in any
order and also can be executed in
different order like illustrated in this
scenario and we must make sure after
transformation and after execution them
in two different orders so a 1 followed
by o2 Prime that's transformed now if
you exit the auto force then followed by
a 1 Prime the final result must be
identical must be identical that is one
of the many consistency requirements
transformation property requirement
another fundamental assumption for
operational transformation is that data
objects are linearly addressable we use
text editor as an example to illustrate
this but actually these objects can be
any other type of objects the essential
requirement is not to be the text to be
the character it is their relationship
must be linearly or traceable it can be
a graphics object can be a slides can be
any other objects really - didn't really
matter but that relationship is
fundamental now that's the basic idea a
system or ot system is a compact system
consists of two major components why is
the control algorithm at the top which
determine which operation are
transformed against others according to
their concurrency concurrency or context
relationships these are the generic
relationships independence of operation
type ii apart is operational change out
each transformation functions these
functions directly change
form a pair of operations based on their
types there are position parameters and
other operations specific attributes in
between we also have implicitly define
the divided responsibility between
control algorithm and transformation
functions these functions these
responsibilities are formulated in the
form of criterias conditions properties
and we can use them to formally verify
whether consistency weather
transformation function or come to our
garden meets these requirements and
ensure the aspect of correctness because
the crack knees is defined by a set of
properties now with this framework I
will give a very brief coverage of using
examples to explain the transformation
functions and then control algorithms
for functions I give you just one slide
to show account a whole ot
transformation function for two
primitive operations T needs and the
insert can be expressed in a single
slide and in the only formal
specification formal specification this
in this context we we deal with common
characterize single character editing
and I should point out all the text
editors can be based on these two
primitive operations in other words this
slide contains the full set of
transformation functions for plain text
editing now look at this key what I
means transformation between to insert
operations I stands for
insert and take one insert another
insert and we compare the position
parameter left or right to determine
whether the NATO operation should be
shifted by one position under certain
condition otherwise no shifting and we
do similar things to minus one plus
Malus one for other compilations the
idea is simple just compare this whether
it is the left or right to determine
what action to take the idea is very
simple but I should point out actually
transformation function design even
though this this is a looks very simple
there are a lot of intricacies involved
particularly related to to tie breaking
issues why is the insert card insert
type when two operations targeting at
the same location how to break the tie
to ensure consistency when routine it's
operations targeting at the same des
needs caret same character how to
resolve this conflict and achieve a
consistent result for inserts type
breaking it is straightforward
we'll use some serialization actually in
this example we use user identifier
suppose user identifiers are identical
to break the time for 40 needs
serialization any kind cannot achieve
the correct result the correct result is
to to maintain to ensure that only the
force that in it takes effect the second
init should not have any effect and this
in effect is not achievable by any
sterilization protocols and now this
seems to solve this problem but actually
is far more complex than what I have
shown there for the needs type breaking
for concurrent exclusion of these two
operations the result is correct and
easy to achieve but when we have Groupon
do if we want to undo one deletes what
happens what's the effect if both users
undo the same operation the same day
needs then what happens so this caused a
lot of problem for undo and insert type
breaking also is non-trivial there are
some well-known forced hi problems they
are not exercised the forced ties can be
caused by under various circumstances
and that is not easy tasks and you can
find literature and also if we extend
the transformation from single character
to a string of characters the complexity
also increase and that is why still
there have been quite some research
going on and both of the problems have
been solved and they the system and also
they are usable robust the system
available out there now control
algorithms the first ot control acronym
was proposed by the team net by Ennis at
MCC and published in 89 that was 20
years ago
and this was the pioneer work on ot and
this work has inspired many researchers
to follow the this this line of research
part of the reason was the original
rhythm the puzzle the oh the flow inside
the origin algorithm and less for it has
the name the topped puzzle the name of
topped was the original algorithms name
the puzzle can be illustrated in this
way in my previous slides I showed the
basic idea of ot with two concurrent
operations and I show how that can be
transformed correctly and the origin
algorithm works for this kind of
scenario but if we add one additional
operation to the scenario we can
immediately defeat the original rhythm
immediate effect and this counter
example was discovered independently
discovered by several research groups in
90s and this operation is obviously
different from this operation in their
relationship with this one this
operation and their concurrence but they
are sheer in the same document state all
we call them same context this operation
is also concurrent with this operation
but this opens definition context is
different from this one because the
document has been changed by this
operation so the parameter of this one
and this one are not compare
cannot be used using the simple
transformation function to adjust the
opposition and this is the simplest
scenario to show the intricacy in design
OD control algorithms but actually in
this system we allow user to generate
operation at any moment of time and if
you add one more operation there they
same scenario becomes more complex and
if you add one more user there with one
additional operation the picture is
getting messy messy and if you have an
arbitrary number of users and they
generate operation editing any object at
any time then the Senora is overly
complex fortunately over ten years
research researchers have found
solutions to this problem and one of the
solutions was from my group and we
designed the generic operational
transformation algorithm the court
algorithm and which is based on the use
of two a pair of reversible
transformation functions wines I T
stands for increasing transformation
another is ET exclusion transformation
and this is the just a paragraph for
this algorithm we take the new operation
as wine input and also we use an in your
buffer called history buffer to lock all
the executed operations fit into the
algorithm which use these two
transformation functions and then
produce the output the Internet is
theatres are intricate this is not the
place to explain but it's important to
point out the use of these two
transformation functions this IT means a
oh is a new operation oh so Oh a is
input Oh P is the operation stored in a
history and when Oh a transform accurst
o P in the exclusive in crucible way we
produce Oh a prime and this Oh F prime
is another version for Oh a which has
taken into opus effect into
consideration in divine
in the parameters that's the meaning of
the increasing transformation to his
plus malice listing is to exclude the
effect of this operation exclude the
effect means if this operation was not
excluded then what their parameter
should be then will produce another
version of this operation and we must
ensure these two functions are
reversible in the following sense
when oay transformed inclusively with
against OB and then exclusively against
the same will be we should be able to
get to the original operation back and
since this work we had a number of
follow-up work on top of cut algorithm
the first one was 1998 the co 2
algorithm it was an optimized version of
code and any undue algorithm is to
extend the concurrency control to group
on do to support undo any operation at
any time and this OP this algorithm is
integrated with this and in recent year
at the newest result published two years
ago and also extended in this year it's
caught algorithm contacts based
operational transformation this is based
on ideal framework of theory and also
with the new capability with the
integrated capability for supporting
tool and undo at the same time with
formal proof with form of proof and
implementation in over 20 years
ot has evolved to support a range of
collaboration functions including the
original function that is to maintain
consistency also called concurrency
control and later it gains the
capability to support undo undo any
operation at any time and the conflict
resolution based on object never much
perversion e also based on OT workspace
a well as can be supported by out here
as well and we invented the new
technique which is called objects
associated ten pointers and read our
views
optional locking Loki is useful for head
to help solve semantic consistency
problem and with the support of ot we
supports a more of a level
optional locking technique in the
internet environment that is more
fine-grain and also responsive flexible
operation notification and compression
is a set of techniques penalty which is
able to bridge real-time and non
real-time collaboration so we can use
the same OT technique to support
real-time editing and non real-time
editing by multiple users and most of
these techniques were invented in the
context of group text editors which will
develop many for research purpose as a
research vehicle such as the reduce
projects are conducted by my research
group and in recent years ot is
increasingly being adopted by commercial
collaborative editors and one example is
the SAP data editor this is the
commercial text editor and why so well
known and it is based using a key
technique and there are others as well
ok so much about the technique aspects
of collaborative editing now we move to
the next second part is how to design
useful systems using the advanced
collaborative editing technology we have
developed over the years and there was
article published two years ago which I
used which is about how to transform
converts
single user applications existing single
user applications for supporting multi
user real-time collaboration first the
design of the collaborative editor in
our view we we have an important
observation in about the system a
collaborative system contains two
orthogonal sets of functions
the first part for sassette is
conventional editing functions the
second part is collaborative functions
these two parts should and can be
separately dealt with separately dealt
with based on this observation we have
to design goals the conventional
functionality of collaborative editor
should have as rich functionality as
they are single user counterparts this
is the set of single user adjust a
sample set of single user editors out
there available if you want to develop a
collaborative version of something in
that domain make sure your collaborative
version has similar comparable functions
as we point out collaborative editor
still editor conventional functionality
should be as the same now because we
have large already mature widely used
commercial products they are can we take
advantage of this existing single user
editors impeding multiple user
collaborative editors that's the
question the second of design goal is to
make sure collaborative system editing
systems to have collaborative function
comparable to Advanced Research
prototypes as I point out most of the
advanced techniques were invented in
research prototypes these prototypes do
not have rich Commissioner editing
capability they are not regarded as
useful application but they have
advanced capable collaboration
capabilities this is just one example
this is the old reduce text editor with
the list of advanced collaboration
capabilities but this interface is very
simple with limited editing capability
and it was implemented in Java applet
and in a web environment that can be
regarded as earlier one of the early
Weber based real-time collaborative
editor in 90s
now the question is can we avoid
reinventing collaborative technology
impaired in various collaborative
editors for the end users can we tarik
to use the developed technology rather
than reinventing them in the commercial
system now motivated by these object
design objectives we propose the
transparent adaptation approach to build
useful and advanced collaborative
systems without reinventing the wheel
this approach taking has one component
single user option component another
component is a collaboration engine
single user application component
provides conventional functionality
which can be either existing or new
application can be proprietary or open
source can be desktop or web-based don't
matter but the engine part should be
able to support a range of collaboration
functionalities such as concurrent work
well as relaxed what you see is what I
see and good responsiveness and grooving
do etc we further refine the
collaboration engine part by decompose
the application specific collaboration
functionality from the generic
collaboration functionality the generic
collaboration functionality is OD based
and can be used for a wide range of
different applications and the adapter
is providing this application specific
collaboration capability and bridging
the general engine with the application
using their API and with this approach
the design of a collaborative editing
system is reduced to the design of the
adapter of the adapter which is
significantly simpler than reinventing
functionality there and reintegrating
functionality there
but still I should point out the design
now of collaborative adapter is not only
an engineering challenge it also
involves research particularly when you
apply this approach from one from one
domain to a new domain you always needed
to do initial research for open offer
for office if we have done office for
one example it's easy to apply similar
adaptation technique to another office
application but if we extend that to 3d
design the new research is needed so
this is a the approach we propose we
won't want to reuse the engine reuse
single user functionality and focusing
on inventing bridging techniques we
apply this technique to Microsoft Office
tools the initial research choose
Microsoft or world and PowerPoint as our
initial target as you can see these two
systems share the same architecture they
use the existing application they use
the same engine but we build two
different adapters and this tooth
adapters are quite similar because there
are all office elements and also from
the same vendor quite similar
now the furnace writes our show some of
the technique challenges in the adapter
what we call transponder adaptation
happening inside this adapter so we use
word as the example what kind of
technique challenges there first from
the single domain one domain print text
editing to tootle main word processor as
you can see from the interface this is
directly matching the OT linear
addressing space but this one tantalate
these two dimensional objects can be
positioned in the visual space at any
place and has not no relationship
whatsoever so this appears to be the
main obstacle initially to apply our
generic engine to this application but
the men discouraged
made by collaborative word cohorts
project is that we find the application
world API the general public API
actually provides a wide range of ways
of addressing the these objects even
though these objects visually unrelated
to this Ninio addressing system but the
API has something related not obvious
we use our overview our technique to
extract a subset of existing world API
and map all these objects into an inner
system and that is existing in their API
we are not inventing anything we are not
changing anything
also we don't have access to their
source code and in this way after this
altercation the engine can be plucky can
be plugin and we did similar thing for
the PowerPoint PowerPoint this time has
a hierarchical ninja addressing system
action the world also is hierarchical
the previous slide is is a simplified
version powerpoint document has the
sequence of slides at this level will
have a linear sequence and for
individual slides it has two independent
addressing domain wines text it is
directly correspond to linear addressing
space this graphics part also actually
has api to address them linearly
existing in their APR you don't need to
invent it and just find the way we call
this as discovery rather than invention
it's a discovery it can be used in this
way then after you establish this
mapping of course the original OT data
model is a single linear model we need
to extend the OT code technique to a
hierarchical linear address space this
is the general tree of ninja adjacent
domain we don't need to go to the detail
suffice to say that all the data models
toad
data objects in word processors
PowerPoint documents can be mapped into
addressing space compatible with this
there are just some instance of this
generic general form the so-called X
extended ot beta model this is a one
part of the adaptation we call a beta
adaptation another part is the
operational deputation because the
commercial application has comprehensive
also sophisticated high level user
accessible functions which is far more
complex than inserting it to operations
and in original automotive there isn't
even there is no appetit operation
so our first extension is to add one
generic primitive operation updates into
the coal-hole key technique and in this
way many user naval operations can be
mapped to update including text update
operations and also graphics operations
like the the this file feeling moving
and also rotating they are all update
operations and can be captured by this
single primitive with this call
extension this is still not enough users
generate operations much higher level
than we need application specific
extension to ot that the extension on
one side will take the call ot three
primitive operations another side take
the AP AP are a comprehensive complex
API providing various operations methods
for the application programmer to access
for user interaction we generate
operations we call adapted operations AO
this group of corporations should be
with the art of operation adaptation
naturally inside this part we should
include the user interaction at a higher
level which captured sufficient
information for ot processing and all
for API replay and also we do two-level
adaptation why is to adapt AO user
generated operation to the OT required
primitive operation to handle any issue
caused by concurrency consistent
maintenance group hongdo etc this
adaptation is down there and also we use
another level at a petition to get in a
semantics right this never is get syntax
right and this is the the art of
operation adaptation so after solving
these problems we get the code word up
and running but I should point out the
system initially with we we advocate the
collaborative editor should support
multiple users to edit and attack any
object in the document at any time and
so user are unconstrained free access
and that model is what we call multiple
actor multi purview so anyone can edit
the document at any time so highly
chaotic uncoordinated process and the
technique we invented in the
collaboration engine is able to support
it once we are able to do this hard work
where it's easy to extend to support
other different compilations for example
we can have multiple actors they are
editing or synchronized view the same
view you can anyone can edit it but they
have a sync rest of you if the view
change everyone will change to a
different area also we have a single
actor single view if you want to
sequentially impose sequential
interaction among crew members that can
be easily done and also we have single
actor but allow multiple users to view
different parts of the document and
these are the just the full compilations
will have more compilations on top of
that they what we learned from this once
you have a infrastructure which is able
to support this it's easy to support
other more restrictive form of
interaction but if the technique was
invented only for a risk
form of interaction it would be very
difficult if not impossible to support
more liberal interaction that's the
nursing women now there is a public
available demonstration at this location
in Singapore until and this picture
gives you more detailed internal
component description of the adapter and
the engine we are not going to explain
this detail rather than that I would not
utter it to to help to give a live demo
for this there for this system that most
will be born interesting and we switch
to the real system ok all right so this
is the code system and to Microsoft Word
and on the right we'll have this
collaboration widget called the reader
view ok the reader view provides
information about where users are
looking at in this document so if I
scroll through this document you can see
that this reader views me updated and
it's being synchronized to the remote
site so he can't he knows where I'm
looking at in this document and when L
viewports overlap we can see each
other's mouths pointers so that's that's
his mouse pointer and this is mine this
is called a teleporter it gives you more
fine-grained user level interaction in
this shared workspace ok so we can
actually you know Co point to a
particular area in this document and and
say we want to we want to discuss this
area ok so that's the main user
interface we want to first demonstrate
collaborative editing so and to do that
we're gonna just jointly come up with a
list of features and Co weird ok and to
do that to help you see what we're
typing I'm gonna turn on this
highlighting feature which color codes
out our text so this is the list
in forward so so we're gonna just start
editing this and on I'm the green guy
and he's the red guy okay so it has
flexible erection
I'm doing okay as I'm typing on going I
realizes that he's got on through up
here so I can use the undo button to I
remove what I just typed okay and I
actually want to turn this into a list
so let's just do that let's turn it into
a list I want to elaborate on workspace
awareness of support by saying that we
have reader views and interests and I
realizes that he's got a made a typo
here so it's not current its concurrent
and it's tracking track and that's
update whoops that's update the font to
bold and make it sighs okay so as you
can see we can collaboratively edit not
only in the same paragraph we can also
cleverly edit in the same line in very
close proximity okay so that's so we
want to demonstrate what we mean by well
there is a this is currently directly
linked to BES over there but if you want
to try out the latency effects you can
link to the Singapore server so there's
a featuring covert called a multiple
versioning by by a single display and
we're gonna demonstrate that using
graphical objects so I'm gonna create is
just gonna type that up I'm gonna create
a ellipse here and the first thing we're
gonna try is I'm going to move this
ellipse to a different location
and concurrently he's going to change
its color okay so let's do that one -
just move it okay okay one two three
okay so because these two concurrent
operations are targeting different
attributes of this object the system
should be able to merge those two
concurrent changes together in the same
object okay so it's moved and the colors
you updated
well you might ask what happens if we
update the same attribute okay what if
we change the same color actually boot
two different values
okay that's let's try that and see how
we are handling this in our system I'm
going to update it to our red and he's
gonna try to get a yellow okay so one
two three nope okay so as you can see
it's actually pretty hard to generate
concurrent operations in the local area
network so we're gonna try that again
I'm gonna do red and you can do blue
okay one two three
oh okay it's a little hard okay red
again yellow yes one two three all right
okay
I'm trying to get okay that's right
let's just do that one well it's we did
sure this is interesting feature to say
if if conflict occurs concurrently
because generate concurrent conflict is
difficulty but once it happens what
action would take and what kind of
interface will provide it is something
of interest to many people all right
that's just one more time one two three
something is wrong okay that's what's
that's we can try this offline people
want to say this basically what happens
is I would bring up an interface that
records all the possible versions that
people create so if I change it to red
and changes to blue we record all these
versions and it would provide a
scrolling interface a browsing interface
that allows the user to choose which
version they like and they can commit to
that version okay so okay so this is
with we both we try
in this object to two different
direction okay so I'm moving to the Neff
I'm going to the Lord
okay one two three let go okay so there
we go so that's a conflict and the
system detects that is conflict and if
you click on the object it brings up an
interface it can scroll through the
versions so that's the original location
for the object that's the location that
he moved the the ellipse to and this is
the location that I moved the ellipse to
and we also generate this intermediate
version by additively combining these
two moves so it's sort of taking the
coordinates and doing an average in the
middle okay so and a user can of course
commit to a location so I want to commit
to my location and there we go
all right I generally took not the
trouble so sorry let's see one more
thing we want to show is what we mean by
single view a single actor multiple of
you actually it's multiple actor single
fetus so oh yes you can see okay okay so
we're logged in so this this thing
synchronizes both of our views to the
same area of the document so this is the
facilitate cross-collaboration processes
that require sort of revision or or
structured discussion so you know they
whoops as I as I scroll through this
document you know you can see that both
of our views are synchronized at the
same time and there's a variety of
different models that you can implement
on top of this okay so that's and there
are lots of other features and you can
try them out the system is online so
it's freely distributed you can drive
various features and report the Box you
find and so we this has been shown for
over five years
so we receive a lot of
Parker reports and also interesting
feedback from the users we learned we
appreciate their feedback and also we
have the system here after this seminar
you can always interact with the system
if you wish now let's continue with our
story of the this work so after doing
Microsoft Office several representative
members they we extend this technology
to open office system just want to show
this is not only related to one vendors
product actually we can apply this to
open-source we aware we use an
open-source office but we never change
their internal source code so we use the
same approach only attach their API
you'll need their HR without changing a
single line of code even we don't need
to reach the internal code to do our
work and this work was reported two
years ago in sales tab module conference
associate workshop and our next step and
the the step is still ongoing is to
apply this to Weber based office
productivity applications and we find
currently will have word processor
prototype proof of concept prototype
which use the same technique can also be
used they are without actually for
office applications they are quite
similar whether it is open source or
proprietary or Weber based or desktop
doesn't really matter now the more
powder step of extension is Technol
technique is to apply to 3d design tools
and the one we choose for our research
is my autodesk maya and maya is 3d
design tool and we worked on this Boden
2 years and produced a working prototype
with similar quantity as the cohort and
that was demonstrated in this month in
says
a new conference in San Diago and we
also had a paper there and we haven't
write much about this system and but
today I can also give a short demo of
the system here just to show the same
engine driving a totally different
applications 3d design - all right so
because of time you can we do this on
offline all they can wait for about ten
minutes five minutes five minutes do we
need to make a room for them okay okay
couple minutes let me just finish this
and to the demonstration of lon yeah so
we don't have time to do the cool Maya
demonstration but I finish this right I
have nos the slide is to summarize this
talk master decades have seen
significant research development
activities and achievements in real-time
collaborative editing technology and
systems existing or new desktop or Web
APIs the single user editing systems can
be adapted to provide rich conventional
functionalities in collaborative tools
as proven by the transparent adaptation
technology collaborative technologies
can be encapsulated in reusable software
package like ot paste the GCE to support
a wide range of editing applications
from 1 D to 3d that's what we meant in
over 15 years what's the future of C II
we believe collaborative editing systems
were become commonplace and provide
seamless support for single and multiple
users for real-time and non real-time
collaboration on desktop and web or
toothpaste a platform oval worlds and
Wireless local and world wild area
networks so in other words any user any
time and the platform anywhere
collaboration will be the future and the
harder we work and the collaboration
collaborative editor will lose its
identity because
the future there will no have no
differentiation about single user or
multiple user
it's just editor it's a naturally 404
also single user use multiple user use
use the same thing whether you do
real-time collaboration or non real-time
collaboration the same the same
technology the same tool on which
platform there is no different seamless
support and but as we say the best way
to predict the future is to invent it is
to amend it so we have time for
questions in another room and thanks for
your for attending this seminar and I'm
will be very happy to take questions and
have detailed discussion of nine with
people interested in this technology
okay we need to move to another one
facts</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>