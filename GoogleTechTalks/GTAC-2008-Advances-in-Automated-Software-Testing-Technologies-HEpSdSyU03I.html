<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2008: Advances in Automated Software Testing Technologies | Coder Coacher - Coaching Coders</title><meta content="GTAC 2008: Advances in Automated Software Testing Technologies - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2008: Advances in Automated Software Testing Technologies</b></h2><h5 class="post__date">2008-10-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HEpSdSyU03I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I welcome everyone like Lydia said my
name is Alfredo Dustin and I'm here with
my colleague Marco sport we're here to
talk about advances in automated
software testing technologies and
implementation we really appreciate the
opportunity speaking here and thank you
Lydia and Jessica for organizing this
conference we currently work at IDT what
we do it i dt is we design develop and
implement automated cell for testing
technologies we also research the latest
and greatest technologies so since my
entire career we spend on automated
software testing I'm very excited to be
working at a company that spends its
entire entire time on researching
automated software testing technologies
so here's today's agenda for the purpose
of this presentation I actually want to
define what automated software testing
means for us then I want to talk about
some of the research and findings that
we have done and i also want to talk
about how we applied our findings at IDT
and what i really mean by automating
your test automation so here's our
definition automated software testing is
the application and implementation of
software technologies throughout the
entire self protesting life cycle with
the goal to improve so for test
lifecycle efficiencies and effectiveness
so what we mean here is you know to some
of you automated cell phone testing
means capture playback testing to some
of you it might mean automated unit
testing or memory leak detection a
performance testing but what we're
saying is automated software testing
should be applied throughout this awful
testing lifecycle so what whether you
want to automate your middle world
testing or your infrastructural testing
whether you want to automate your
requirements traceability matrix or your
configuration management and your defect
tracking we're talking about all of the
above
we look at automation frameworks and
testing tools and as part of this
presentation I want to present some of
the research and finding that findings
that we have come up with the important
thing that I want to mention here is we
do believe in automated unit testing we
do believe in nightly builds we do
believe that as much as possible that
you can automate for yourself for
testing is the most effective way to go
so sometimes we say software testing
really seems to be the stepchild of
innovation when you read Businessweek or
some other magazines like the CIO o
magazine everybody talks about research
and development very few companies or
magazines or research agencies talk
about research and development and test
so you know R&amp;amp;D has resulted in high
technical innovation but our ability to
test these technologies has not been
able to keep pace because really we
hardly ever hear about research the
development innovation and this is how
you will test it so at IDT we spend time
determining how we can research these
latest and greatest technologies so
here's what we've done we decided to
look at an area where testing seems to
be done correctly we said well hardwell
testing hardly uses any human inner
inner face or interaction in order to do
it right it's pretty much all automated
so there's many automated test
generators for manufacturing circuit
testing all sort of hardware automation
exists so we said well let's take a look
at that many of you will say well how
about testing is so much different from
software testing you know you have the
software challenges you have changing
requirements you have GUI interfaces you
have solution flexibilities that are
maybe not required from hardware but we
said well let's look at how poor testing
how
the same from south for testing and we
said well components so James Whittaker
talked about component we use I had
never seen his presentation but it seems
like we came up with the same ideas
because how is hard when testing the
same they they use tested components
over and over again in various different
hardware also autonomous computing we
looked at the autonomous computing
because sometimes it seems that
automated software testing is a paradox
because really will developing software
to test suffer so you know the question
I get asked a lot of times at
presentations is well who tests your
software that's automating this this you
know the system under test so we said
well what about autonomous computing
when Patrick Copeland gave the keynote
last year at the Google conference he
talked about how they Google
infrastructure and servers already used
some of these autonomous computing which
is actually self-healing self
configuring and self testable components
so we said for our automated testing
research let's look into that and see
what that means for us or how what we
could reuse there and then we said in
order to scale we need to be able to
automate the automation by that we mean
we were talking about James Whittaker
was talking about having to recreate
test cases over and over again well we
said what if we use a header file or an
interface design language and some sort
of document that exists for system under
test and generate test code from it
instead of having to develop the test
cases by hand over and over again in
order to automate them so we said let's
look into that so we looked at
components just like hardware we said
well maybe for automated testing you
know we can take advantage of component
we use so different research agencies
Gardner and Redmond developer they
talked about being able to cap
relies on existing components and then
put our new user interfaces and
interactions and transactions behind the
scene and make up a new system so the
concept here is if I have a set of
components that have already been tested
and I plug and play and put them
together I will have a higher quality
system than if I created something from
scratch over and over again so we said
let's reuse some of these components is
part of our automation framework not
only should this be applied to
developing new systems but also when you
build your own automation framework so
we actually go to component we use sites
such as kodos in krogl and we believe in
the library concept of reusable
components where you say well I'm
checking in a piece of code I will check
it out and we'll use it for this
application i will use it for this
framework because the point here is we
already have tested proven components
that we can just put back together so
here's a little bit if you want to do
some more research on this autonomous
computing because it's really an
approach to self-manage computing
systems with a minimum of human
interference so you're looking for
dynamic self configuration cells
optimization self-protection and
self-healing features there's a lot of
research being done by IBM as I
mentioned Google is already applying it
in some areas and some other research
agencies here that talk about self
testable components and even some tools
available that allow you to self-tests
pulls out self testable classes so we
realized that since we implement
automated software testing for different
companies and different projects in
order to be able to scale we realized we
need to automate as much as possible so
automate our automation short of route
using robots instead of you know we
wanted to kind of recreate what the hard
one testing is already doing well
they're removing the human interaction
as much as possible so we wanted to
start of our automation we wanted to Ryu
and apply how about testing efficiencies
we wanted to borrow from software
development research and development and
then of course we use open source and
existing components we also looked at
frameworks automated frameworks instead
of developing things from scratch we
wanted to reuse the framework that's
already out there and available and see
if you could apply it to our environment
or to all the different projects that we
will be automating for our different
customers we looked at test data
generators we lose looked at our code
generation test vendor provided test
generation compare utilities log file
analyzers GUI testing tools and so forth
and each one of these I will discuss in
detail next we're also working with NIST
the National Institute of Standards and
technologies to produce additional tools
such as code coverage analysis we they
currently have a tool that's called fire
I that allows for test data generation
that I will provide more details for so
our automation framework we said we need
an automation framework instead of
building anything from scratch we wanted
to see if there's an automation
framework available that allows for
automation startups so I wanted to be
able to kick off my automation script at
any time of the day or from anywhere
remotely I wouldn't want it to have to
sit on their system under test I wanted
a framework where I could be able to do
our create system setup so for my system
under test maybe it required some
configuration changes I wanted it to be
able to do test case execution and
output analysis then clean up results
notification automation complete
completion is part of the execution I
wanted to be able to monitor synchronize
and manage to resources and we actually
found such a tool available open source
provided by IBM supported by Ibrahim it
was originally created by IBM but now
it's avail
open source and it's called software
test automation framework that runs on a
softball test automation engine so
stacks and staff they provide us
everything we needed it allows for
system product set up test case
distribution test case execution and it
provides the right technologies that we
needed to make this framework extensible
so it provides XML Python Java the nice
thing about this offworld test
automation framework it comes with all
these building features which they call
services that provide all this
information provide all the features
that we need to expand our automation
framework and really we want to have a
framework that we can just say
components get plugged in and it's a
plug-in flu and play component in
framework so here for example for the
internal services were able to take
advantage of everything that's available
here for example file system so if you
have to copy files across the network it
has external services if you want to
kick off the test cases at a specific
amount the specific time of day weekend
it has email capability if you if your
chest fails you can send out an email
saying you know here's a defect it
pretty much provided us with the basic
framework that we need it for our
automation so here's how framework
component it's also available for all
the various operating systems actually
any anyone in here familiar with
staffing stacks okay so actually quite a
few people are already using it so
really staff in stacks provided that
into end automation for us we had all in
services necessary and needed for us to
build onto and build upon this framework
that's available open source so so far
for this is what I wanted to talk about
about our framework the next thing we
looked at we said okay test data
generators test data is so important
because we
so in order to find the effects we need
to have the correct depth and breadth of
test data we also know the complications
if we reuse production data other times
people reuse production data and say
okay this is our test data but if you
reuse production data a lot of times we
have security issues or we don't really
know what the test coverage is so
together with lists this tool was
created called fire I it's actually open
source you can freely download it and it
allows you for combinatorial test data
generation so a lot of people use
pairwise combinations in order to do
test data generation but this tool will
allow you to use a thaw vanilla race so
to not only generate pairwise
combinations but also three wise for
whites or in wise combinations because
it's been proven if you combine various
parameters in your test data that your
chances of finding defects are higher we
also use MATLAB which is really a
scientific test data generation tool
that meets our needs when vector data
generation or matrix data generation so
here you can take a look at this list of
test data generators that this actually
provides a comparison of testing data
generators and you can take a look at
that link provided here so the next
thing we said okay so now we have our
test framework we have our text data now
we want to look at automated test case
generation because again test case
generate creation is very time-consuming
and can be very cumbersome so we looked
at the industry and said what's
available in regards to test case
generation automated test case
generation and we found that a lot of
you know test generation tools available
based on uml models rules checking
algorithms test descriptions abundant
papers are written by industry but few
products are
actually built and the limitation that
we found is that in order to use these
test case generators you actually need
to buy all the tools related to that
vendor so you have to buy if you want
for example you going to use the
automated test generator from Tel
illogic you have to build a by their
modeling tool Rhapsody so the limitation
is really that these all these test case
generators are really vendor specific so
we decided we'll develop our own
in-house using open source provided
tools so when we said okay how could we
generate our test code or how could we
generate this clewd that glues out test
framework to the application under test
we said well what about using various
input types such as I DLC style header
files and so forth to generate the code
every time because even though we have
this great framework that we can expand
on we will have to be able to talk to
various different applications and we
wouldn't want to have to generate that
code that talks out that uses our
framework every time manually so we came
up with this automated test code
generation and the same without test
case procedures that we wanted to have
generated in an automated fashion and
really that's that's what the demo will
be about so why do I talk about it
really high level here but when you
actually see how it's done in practice
and the demo it will make more sense so
again you know you need to develop this
software interface test code that
provides the interface between your our
test framework any application under
test so the interface could be DD a
score by could be any sort of middle
layer or simple multicast layout it you
can generate the software interface code
from various formats and its really the
glue that that that Clues the test
framework and interface code together
here's just a quick picture so for
example if
your system under test has an IDL file
in the face design language follows a
specific standard you can parse this
ideal using again an open-source tool
called antler which parses the code
generated from antler grammar and then
it generates the interface code and then
you have your source code the next thing
so that's really the part of how you
generate the code that interfaces your
framework to the system are no tests the
next thing that we said well what about
test case cogeneration again if you do
automated testing you might have a lot
of manual test cases your manual test
cases don't automatically translate to
automated test cases so we had to come
up with a way to make that to automate
that translation where we said well if
all the test cases are in a standard
format then that's easy but
unfortunately most test cases are not
using a standard format so we actually
you know currently we're using a CSV par
so to use any type of test case any type
of format whether it's in world or PDF
and no matter which woman it is in and
we put it in a standard format and then
each step in the test case procedure has
actually associated code generated to
execute its behavior so and string
templates are really provided and used
for common code set as well as a unique
project set so here are some of the test
case generation tools that we use and
again all of it is open source so we
have Angelo string template inch XP and
Marcus we'll talk about all of this in
more detail so here's his demo come on
everybody
okay Oh how's the free to have mentioned
our order order generating the code for
our test cases really is really paid off
tremendously for us what it's allowed us
to do is basically take a test case to
test the system under test our customers
system under test in any standard format
kind of like what we're seeing here now
this is just in a spreadsheet format and
we basically have all the all the
information that we need to test the
system in this case we're testing a
system through message based testing
which is an interface testing so excuse
me as you can see for each step we will
have some sort of an action that
indicates whether it's a sin to receive
we have this is a simplistic test case
and we have some sort of a delay as well
and that's more just intended to control
the overall test case execution flow so
what we would do with this is we take
this test case and we have some
scripting and some Java code in place
that uses the IE bin library is put out
by Apache which gives you a Java
interface to Microsoft artifacts and we
can strip out the information we need
from that spreadsheet and create an XML
file its follows along with the scheme
of the we've we've defined on our own
and within a spreadsheet or within the
xml file is going to have the test case
information and we need messaging
information that we need all the all the
data we have available in the
spreadsheet is going to get put into an
xml format which is then going to be
used as an input into an auto generation
driving engine and what that engine is
going to do is using jack's b which is a
again an open source product and it
provides an xml to java object binding
we can parse in the xml file and create
a java code using string templates now
string templates the string temple i
rated we decided to go with is the same
library that's put out by the the the
author of the antler library which is a
Terrence bar and what that does is that
allows you to define a a template that
accepts just like any other template
like a code template would
except certain parameters that are used
to define the actual output so in this
case here we have a a sending test step
which would be one of these steps that
we see here and we have certain
parameters that we're defining for that
template a test case step label
interface type so on and so forth and we
use we have those parameters that are we
use the excuse me we define the
parameters based on the elements values
that are defined in the xml file that
again we've extracted from the
spreadsheet now from that template file
are our order generation engine can then
create Java code that implements that
test step so now here we have test step
one which again is going to going to be
involved in a sending sending a message
out so here you can see an example of
how the the string template the
parameters are come into play where we
rip out the the test step for that Java
object that Java objects role is
involved in and we build a Java file
from it now the big payoffs but this
templates is that it also will allow you
two to get specific with it with the
data structures themselves so in this
case we have certain fields that are
allocated or excuse me they're part of
the definition of a one of the messages
that we're using the test the system
under test so with that information
contained in the in the test case itself
we pull that out and now we can put that
in again it back into that XML file and
generate the code now what that does is
that takes us that allows us to take a
test case format and apply this to other
test cases that we develop for the
system under test and in our case we had
I think for the first go-around we had
roughly 12 test cases we're able to go
from one test case i set a test case
code to implement one test case to
implementing 12 test cases within about
a day okay so that took over a lot of
the monotony of having to to write all
of this this code here
it has data specific code in it tests
case specific code in it we generalized
all that into into templates and now we
could output a majority of our code our
test case code for us and then there is
some manual editing they had to be done
after the fact we go back in but still
I'd say probably about a good eighteen
eighty to eighty-five percent of the
code was generated for us now the other
piece now that that's that's as far as
generating the actual test case code
that that implements the procedure now
the other piece that elfrida had
mentioned was converting a customer's
data structure from an IDL or a header
file into into a class file again in our
cases Java because of most of our
framework is in Java but not only doing
the conversion but adding in the glue
code that we need to get it to be
pluggable into our framework and part of
that glue code is in this case here we
have this is just an example message
where we have a Java class that we when
we generate the code based off of a see
header file we're going to have this
Java class implement one of our custom
interfaces and part of that custom
interfaces to find a a method called
Marshall bytes here and the whole point
of that is that we use that in the
system under test two to convert header
files directly from our customer that he
had into a Java class that we could use
in our framework and be able to connect
to the cuffs to the system under test
over in this case it was a socket
interface so that was all done again now
that that that part is done through
string templates in conjunction with
with which which works in conjunction
with antler and what antler bought us
was antler is a a combination lexical
analyzer and a parser and it the it's
open source so on website it also has a
slew of of readily available grammar
files for you it's already download we
found the C syntax grammar already
available for us so we didn't have to
develop any of that from scratch it
already had the IDL syntax for our
grammar for us so we didn't have to
develop any of that from
so we basically were able to take those
grammar files and build on him as
necessary in a relatively short amount
of time in one of the cases so this is
part of the conversion piece we took a C
syntax that this is grammar file to the
interpret C syntax and we added a subset
of a smaller grammar file that we use
when we wrote when we were parsing in
the the code so we would parse the code
and as we're walking through the ASC we
had this grammar file that as is parsing
tokens within that within that tree it's
going to invoke custom custom template
functions that we define to convert C
style long definitions into Java
definitions so now in this case we have
a data structure that has a long a field
is declared as a long type it will
convert it with the Java syntax and
provides us with the getters and setters
and we added a two-string method as well
and that's basically where we get to to
this point so now we have a working Java
class that is a copy of what the
customers data structure is that we can
now work within our framework so to be
pay off with that was again it really
short in the development time as far as
developing the test cases because we did
spend a lot of upfront time getting the
templates together doing the debugging
with the the degenerate auto jet engine
but once that was done we were literally
able to go from one to twelve and you
know a day and still have to go back
with minimal amount of a manual effort
after the fact and the other big thing
the other big payoff with with the
templates is using well using common
templates now you can with the templates
you have some flexibility where you can
develop a set of common templates that
you're going to use across test cases
across projects or whatever if there are
some some you know generalities that you
can apply or you can also swap them out
with more project specific templates if
I have a project that has a really
unique interface but I still need to do
kind of ascending mechanism for that
project let's say it's a proprietary dds
or something like that I can still use a
I can create a project specific template
that still accepts the same parameters
and just plug it into my my same origin
engine without having to touch the code
for that so it's really the string
chaplets really give you a lot of
flexibility with that they'll let you
out put different types of different
types of source code files if you didn't
want to work with Java you could
hot-swap to the templates and work with
C++ and all it gives you again a lot of
flexibility and as you're working with
the code is generated if if you find an
error that is in and they should be back
fit into one of the templates you can
fix the error in one template file or
you know a set of template files and
just regenerate all the pieces for your
projects that that bug had affected so
if I have 20 test cases and you know I
had to change one line in a TCP socket
class then I can just change it in a
template and regenerate all of those
test steps that are affected or all the
test steps that use a TCP interface in
that project you know in a small amount
of time yes I again I think I think
origin is really really paid off
auto-generated code is really paid off
at least for our purposes thanks Marcus
so this really demonstrates a lot of
times people think automated south for
testing is taking a CAPTCHA playback
tool in putting it on a manual testers
desk and say now automate really if you
want to do automated software testing
right it's really software development
so you know to to generate this
automated test code and you know whether
it's for your test cases or the glue
that clues to your system under test it
really provides predictable test
software something that James Whittaker
was talking about he was saying you know
we want predictable reusable test
software well we are generating it in an
automated fashion it reply it applies to
you know large systems it's scalable
it's portable you can fix problems in
one place I know if you showed that
Marcus but the important I think that's
very important that if you know you
generate all these test cases but you
need to make a change instead of making
the change in all the different test
cases you make it in one central
location you can reuse it across project
and like Marcus already mentioned it's
really a seventy percent test case
development reduction if you generate
the code for your automated testing in
an in an automated test cogeneration
manner so going back to our you know
reusing components that are already
available and reusing the efficiencies
of already tested stuff so as part of
our framework we also wanted to have
monitors and log parcels and here's a
bunch of tools that we found our that
are useful that are available on the
market we wanted to talk about capture
record and playback because you know
there are times were that really is
necessary because some of the testing
that our customers are doing are done
through the user interface only and a
lot of times they say well we really
want you to automate our capture
playback or you I want you to automate
our GUI testing because unless I see it
on the GUI I don't believe the test is
complete even though we try to convince
them you know we can say you know if you
do message testing and a message get
this far you know we can test other
things wait where you can circumvent the
GUI but a lot of times a customer feel
more they will feel more comfortable if
they actually see the final test display
on the GUI so we're
that capture playback tools for the for
DoD for example one of our customers
they have their stringent requirement
data automated testing tool cannot run
on the on the system under the tunnel
tests so they really want to keep a
pristine environment they think that if
you install anything on your system
under test that will mess up your
configuration and you really didn't test
the system as it will be delivered so we
had this requirement that we needed to
find a captcha playback tool that can
actually run remotely and do the testing
remotely without it being installed on
the system under test and we found a
tool that actually uses V&amp;amp;C and where
the tool actually acts as the VNC client
so we install the tool on another
application and it remotely connects to
the system under test how many of you
actually have this requirement that your
testing tool cannot be installed on the
system under test okay so very few it's
like 33 of you who raised your hand but
for the deal for DoD that's very common
you cannot install actually a tool you
know on a system under test so we found
this tool it acts as a VNC client and
actually for those of you have heard
that bitmap recording is the way to stay
you know it's the way to not record and
not to do capture playback they have
come out they have come up with a pretty
good way of doing this automation where
it's actually reusable and practical for
us so again as I go through this
presentation you see I'm just taking
components various different components
of open source tools that are currently
available that builds that we can plug
and play and add on to our already
existing framework so whether we want to
test a GUI application whether we want
to test just the Middle where whether we
want to test the database or anything
our framework will allow for that
different plug and play where we
components and where we you know allow
for cogeneration and automating the
automation we our results reporting
that's pretty common we made sure that
the results reporting was generic as
possible and we really you know in the
end you just really want to make sure
you keep the comparison logic and the
utility and don't put it in your results
reporting the one neat thing that people
our customers really like that we also
did is we automatically after test run
populate a test table test a bug table
so if a test failed we can say well
here's the failure and here's the test
that was run and here's the information
and here's you know the sum of the
automation code that you can link back
to and then somebody can take a look at
it and say yes this is really a bug and
populated the defect tracking database
in our case we're using bugzilla again
an open source defect tracking tool and
again everything is then in one central
location you have everything connected
all the different components connected
to do your automated testing so this is
really what our framework looks like it
can run on Windows Linux it you can like
I said you can hook up a capture
playback tool well it's you know your HP
mercury or your IBM rational or your
eggplant you open source VG robot it
connects to your required crates or
requirements traceability matrix your
defect tracking pretty much have it all
automated so we're saying and this is
where Tom comes from automate the
automation that will allow us that
scalability that's required in order to
be able to you know create automated
testing here's some of their support
tools that were used and we didn't list
everything we also use VMware as part of
our testing like James Whittaker says
it's very useful you can just take an
environment and just hand it over to
your testers or your
we also use we're not listing on here
subversion our configuration management
tool or eclipse our IDE so those are the
sort of tools that were using pretty
much again reusing existing components
so really our the automation that we
developed and that we really think and
then we're going to keep building on and
we're going to keep developing and
making it better with each new
requirement but we have a framework now
that supports applications running on
multiple computers it supports
applications developed in all kinds of
languages different os's applications
that have a GUI and that don't have a
GUI pretty much what Marcus was
demonstrating was message interface
testing at the middleware layer you know
you were really at the dds layer we will
support applications which use different
types of networks and again you can
integrate all kinds of tools any tools
take advantage with what's out there
already instead of you know redeveloping
and reinventing the wheel so really in
summary what I want to say about the
greatest and automated automation
advances that are out there really apply
Hardware automation efficiencies look at
component reuse look at the autonomous
computing the self testable components
self configuring self-healing borrow
from software development advances
because really automated software
testing is software development and
until we have a better way of doing
automated south for testing we should
really reuse some of the software
development advances and just continued
research and development and testing
needed and we're continuing to improve
our automated testing efforts so you can
read more about this but we presented in
the last 30 some minutes you can read
more about this in our upcoming book
implementing automated cell for testing
thank you guess we've we have taco
questions when you're talking about code
generation you mentioned things that I
thought were kind of conflicting with
each other where you mentioned if you
need to regenerate the tests you change
the excel sheet generate all your new
code but then you also mention that
sometimes you have to edit the code and
I was wondering what do you do to
synchronize if someone makes a change in
the excel sheet and someone else makes
us change in the resultant unit test how
do you synchronize those changes to
avoid blowing away one of the other okay
right yeah yeah when I said that uh we
just regenerate the code but what I
meant by that mainly was that I mean the
test case itself for the most part the
test cases are going to go through a
review process so I mean they're going
to get to a point where they're not
they're going to be somewhat static I'm
talking about more more along the lines
of things like if we were adding fields
to data structures things like that
where we would just generate regenerate
code excuse me Java code like that that
test step that I saw now you right there
are some there are some limitations with
the least of the first go round where
you will need to go in and some of
certain sections of the code for the
test cases that we're implementing at
least a really small portion of it we're
going to have to go and visually inspect
it to make sure that the do degeneration
didn't squash any of that okay that make
sense yeah and I guess just as a quick
follow-up have you considered doing a
runtime generation instead of generating
static java code having java code that
reads excel sheet directly in runs
testicle yeah i had to start looking a
little bit about you can alter generate
bytecode things like that um I haven't
gotten too far into it but that's
definitely on a on a table thanks
sir so you do you have spread sheet and
the you can read concrete has go from
that another approach would be to write
a library which knows how to interpret
the test parameters and then your test
can just go into that a library to
execute the test so I'm wondering why I
decided to pick the codeine regime pass
and can you compare this two approaches
right where the as far as when we
generated the code we had to generate
the code specifically because of the the
variation in the data structures that we
were dealing with when we go when we go
into a project to test the system eunos
message based testing specifically we
really have no up beforehand knowledge
of what the data structure looks like so
we get the data structure definitions
from the customer we have to be able to
work with that so as far as creating a
library that we can just kind of tap
into in some cases that might be okay
but for the most part when we go from
project to project the data structure is
going to change completely yeah I
understand that the data structure part
and may not be doable with a library
approach but and views that as a
separate issues like for the test logic
itself you're also expressing that in
XML and wondering whether it's really
necessary and that's benefiting well for
the test case that we had here I mean it
the test the test case logic itself you
mean I mean that the flow of the test
case was really controlled by how it was
written we send messages we pause we do
things like that it was a really simple
example I mean you're right we do have
we would have cases where we would have
we might have some more more logic based
dependencies between the test steps may
be some sort of oil dependency you no
one steps relying depending on other
steps like that in that case we would
probably yeah we were honor if it's
generic enough that it isn't relying on
again the uniqueness of the data
structures and we could abstract it into
some sort of a library component thank
you and they ll thing about I had were
also limited a lot of times by our
customers they already have a set of
test cases they already have a you know
they haven't documented enough in an
Excel spreadsheet and so they really
just say come back to us and tell us
whether it passes and fails and they
want to still see that you know they
want to see the exhaust
treat for Matt I want to see the output
pass/fail and so they really don't care
what goes on behind the scenes but so
we're really also limited by you know I
will test our customers providing
different types of formats different
types of scenarios and they want to
still get the results produced back into
that same kind of documentation so how
long between the time you get a new
application under test like a new one
delivered to you you haven't seen before
until you're generating cases like what
are the steps in between that you have
to do to get ready to generate cases or
do you just say I've got the Excel and
I've got this thing and I just press a
button depending on depending on the
stage that the project we're going to
test is under the program we're going to
test is under I mean there's things like
defining requirements if they have the
fire requirements already defined we
need to you know go through them with
the customer and decide which one of
those are our possible automation
candidates then from that point we
either define help them define test
cases for those requirements that are
automatable if they have test cases
already defined we can work with them to
make them automatable into the format
that we're expecting so I mean I guess
it's really kind of project specific it
depends on the size of the project I
mean it could be any number of factors
right well the idea is that you you
build the interface template for the
project and then if you go to another
project that hopefully let's say we have
a dds template and the other project
uses dds and ideally we should we should
be able to reuse that template if we
come across a project that has a unique
template yes we'll have to develop that
the first time and then just carry it
over to a subsequent projects right and
just to clarify we we don't say automate
everything not everything lends itself
to automation right so we generally take
a look at the test cases they currently
have and well they may be spent most the
time or just like James was saying maybe
the most complex areas take a look at
that and see if you know automation can
pay off because a lot of times they they
may be test 10 data combinations because
one test takes them you know four hours
you know just to set up and then run
and if you automate it you know we can
reduce that for them so it really is
return on investment what should be
automated so it's really difficult to
say it will take you know one hour from
the time we get started to so it really
depends on the project you have a a lot
of core that's being generated for
automated testing uh as we know test
keep changing the test scenarios keep
changing requirements for the product
keep changing that affects a this code
that you have generated have you thought
or have you implemented any automated
testing for the automated test code
guess the south for testing paradox
right does the automated testing paradox
um yeah I don't I don't I think at least
with with the projects that we've dealt
with so far the requirements don't
really change that much we're dealing
with a lot of DoD companies are excuse
me programs and in those cases the
requirements are pretty much set once
they get once they get written but now
we haven't we haven't uh haven't decided
to tackle that haven't come up with
approach on that yet I was just
concerned about automatic defect
tracking so how are you doing why was
the failure being locked on
automatically in the open source bug
tracking tool with all the fields filled
in automatically from the jump that was
being generated or how are you doing it
so there's one important step missing I
would never want to populate a defect
tracking database automatically because
we know what we get a lot of maybe false
positives which really you know there
might not be any defects so we have an
in-between step where they you know you
can look at a summary and say yes this
is really a bug and then and then you
populate the database but you don't you
don't want to miss that what most
important step of you know you don't
really want to go directly to the defect
tracking database so what were the
fields that were being populated
automatically when you've just pressed
the button was it
severity also been populated or just the
steps at the test case name step number
requirement number that failed test data
used and description of the failure okay
so it will no no mention of the severity
of the defect that has been failed you
know that's something that you could
actually add because you know when you
write your test case exactly you could
say you know this is a high priority
when this one I absolutely have years
pass and then along with that because we
had a customer a couple of customers
saying you know that would be nice and
along with that then populate okay but a
lot of chatter sometimes the test case
priority might not match the defect
paradiso you know it depends yes but if
we just fill in this severity because
according to a tester a a particular
test case was an important or severe
defect severe test case that has failed
so we could at least populate the
severity and you know the priority could
be decided later on so right even that
would be quite and thats one approach
right yeah sure thank you that's
somebody right here
hi Steve McCain from Microsoft with
auto-generated automation did you find
that you had so much automation and if
you had failures those you couldn't get
through the investigations of all the
failures did you find it scalable to do
the investigation that's actually a
really good question because you know we
always say what's the point of
automating your tests even now you have
thousands and thousands of tests but
it's going to take you weeks to analyze
the results so I think the results in
our analysis also has to be automated so
that's another area that we've looked
into or that we have developed for some
customers where they you know for
example for performance testing they had
so much theta so many values and they
used take it and put in spreadsheets and
evaluate and we help them automate that
you know process so that's a very good
question i'll be helped by the time
sorry thank you everybody
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>