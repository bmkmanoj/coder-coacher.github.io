<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Aspect Oriented Programming: Radical Research in Modularity | Coder Coacher - Coaching Coders</title><meta content="Aspect Oriented Programming: Radical Research in Modularity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Aspect Oriented Programming: Radical Research in Modularity</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cq7wpLI0hco" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my mind at least is more synonymous with
aspect-oriented programming although
there are several other people in the
audience who could come close to that
title if I'm wrong in any case I invited
him here today because I think that
aspect-oriented programming is part of
the future of programming and I think
that at Google we always want to have
our eye on the future as it were so
without taking up too much more of your
time
here yes hi yeah I think that's an
overly generous introduction John
lamping is here without John lamping
none of the park AOP work would have
happened so it's hard to give this talk
because he could correct me on both
sides you know I wasn't quite sure how
to set this talk up I have I have some
slides that are fairly nuts-and-bolts
about what you can do today with
aspect-oriented programming I have some
slides that are fairly conceptual about
how I think about aspect or any
programming in terms of opening up a new
space of language research the nuts in
both slides are blue and the other
slides are yellow so what I'm going to
do is I'm going to start with the blue
slides and I'm going to count on you to
interrupt me and ask questions and we'll
see where we go figure
dynamically adapting to the audience was
better than my guessing what the
audience would be so what I want to try
to talk about is what AOP is how it
works what it means to really think
aspects when you're designing a system
and again the this set of slides is
fairly practical and in this set of
slides three themes threes cross-cutting
themes that I want to be looking at or
expressiveness abstraction and structure
and modularity whichever you prefer
whichever word you prefer to use for
that concept so just to start imagine
you know a simple drawing tool j-hat
draw some of you have seen this example
before countless times I apologize and
imagine sort of trying to think about
the design for that and you probably
start thinking in terms of objects and
you start thinking in terms of maybe
points and lines and if you think about
it for a while you maybe even come up
with a piece of UML that looks something
like this or if you don't believe in UML
you can just use a napkin you got a
display there's different kinds of
shapes points and lines and there's
other kinds of shapes dot dot dot and if
you think in terms of expressiveness
abstraction and structure and modularity
this this little piece of code and
design does pretty well kind of how it
works is pretty clear abstractions
working pretty well for you you could
sort of look at point at this level of
abstraction or that level of abstraction
the structure and modularity are pretty
good if you want to change something
about how point works you kind of know
where to go if you want to add a new
kind of shape like maybe a triangle
you kind of know where to go now it
would be sort of sad if in 2006 a piece
of code this simple was confusing but
let's just say that the piece of code
this simple is not confusing the thing
is that even in 2006 or at least in 1995
with that simple piece of code there
were some things that were confusing so
imagine just taking an observer pattern
and putting it in that piece of code
right the role that the observer pattern
has to play in this piece of code is
that every time one of these shapes
changes somebody has to let the display
know to refresh itself and we sort of
say that doesn't fit one way to think
about that is now that we have the word
observer pattern we had what I'd like to
think of as sort of fair design quality
because you could sort of say well
there's this nice thing and there's an
observer pattern but we didn't have
great code quality because you sort of
say well there's this nice thing and
then there's an observer pattern and if
somebody says to you well where is it
you say well it's kind of all over okay
so what AOP is about is it's about
making things like observer pattern
which we'll call cross-cutting concerns
and I'll try to give you a couple of
different definitions of that term it's
about making them fit in the sense that
sort of does
you can kind of say there's a single
thing the observer pattern and at the
code level you could kind of say a
single thing this observe the observer
pattern and you'll have the kinds of
expressiveness and abstraction and
modularity that we like and I've got
this code greyed out because you're not
supposed to try to read it now although
I know the kind of people you are and
all of you are and if this works then
you kind of get that good design quality
and good code quality back this just
shows that there's another way of coding
it and I've got this point here just to
just to point out that already you could
sort of see that there's something here
that's not quite like objects or quite
like procedures because you know you
can't name a single class observer
pattern obviously you can write but you
can name the class observer pattern but
then there's nothing really to put in it
that implements the observer pattern for
the entire application
so in some sense that you know the the
10,000 foot version of this is that
today most any programmer looks at hijae
hot draw and kind of immediately sees
this picture and the interesting thing
is that most AOP programmers guy like
like Nick whose mind is now permanently
damaged immediately see a different
picture just as immediately as you might
see points in lines they see these other
kinds of modular units of cross-cutting
functionality the observer pattern and
some other examples that we'll look at
and of course there's tons and tons of
other examples security optimization
distribution and of course logging which
even though everybody's tired of it
turns out to be a more interesting
example than you think
and I'll talk about some of those so
that was kind of the blast introduction
remember you supposed to be asking
questions and interrupting me and not
letting me get away with anything I'm
counting on this audience to do that the
way the rest of the blue slide deck
works is I'm going to use aspectj
aspectj is sort of the de facto standard
for AOP it in certainly in Java and in
some sense in other general-purpose
languages as well it just kind of says
look here's what a thing would be it's
not the only one it's not the only one
for job
it's not the only one for other
languages but if you look at aspectj
first you kind of get the general idea
so we're gonna use that one we'll look
at this is a peek ahead this the really
underlying central concept in AOP is
this notion of joint point models and
we'll see that aspectj has two of them
and the way the blue slide deck works is
i reimplemented pattern over and over
and over again and then after you've
seen more of those than you could stand
i'll show you some other examples and
I'll do a tool demonstration to show you
what it's like to program with this and
just kind of talk about how it works so
let me start getting into some of the
aspects a concepts I walk a lot and
you've got long legs I'll try not to
step on you so the first concept in
aspectj is a thing called a method
execution joint point and one way of
understanding it is using this sub
sequence diagram the method execution
joint points correspond to the execution
of methods in the runtime call graph so
this is a method execution drawing point
and this is a method execution joint
point these are Method execution join
points and an interesting thing you can
see is that the same method of course
might have to get multiple times but
those are two different joint points
right some method execution joint points
are what aspectj calls dynamic joint
points the aspectj has eleven kinds of
them method execution constructor
execution
it also has method call right so the
execution happens here on the call
called object and the call join point
happens here on the calling object and
there's field getting set and for this
talk you don't need to know them all but
there's a bunch of them so that's not
really a thing that aspectj adds to Java
that's the thing that was already there
but aspectj is giving it a name here's
the thing that aspectj adds to Java so
it's the first sort of explicit piece of
language it's called a point cut and
what a point cut is roughly speaking is
it's a predicate that matches some joint
points right because a running aspectj
program is going to have billions and
billions of join points all the time
this point cut matches only sir
ones in particular it matches join
points that our method executions and
our executions of this particular method
so that matches every joint point where
the set p1 methods running because their
predicates you can compose them so this
is a compound point cut that matches any
joint point that is either an execution
of set p1 or an execution of set p2 now
there's a bunch of primitive point cuts
I'm going to give you a quick peek now
and talk about some more later there's
two basic families of them there's kind
it primitive point cuts and non kind of
primitive point cuts and the kinda
Dwayne cuts match join points of only a
particular kind like an execution join
point or a call join point or a field
get join point and the non kind of join
points match join points of any kind but
they match them based on some other kind
of property like this one happens to
match any join point that for which the
corresponding text is within a certain
type and so for those of you might be
getting bored at this point you could
start to think about that the power in
this thing comes from a compositional
language and different ways of talking
about the same join point and those
kinds of compositions let you say some
very interesting things that we'll see
in a minute John what I have to do to
get them ask questions ok I got one
I'm going to give you a concrete example
yes the question was about understanding
what point cuts are and hoping there
would be a concrete example such as this
one yes
the question is would it be true to say
that what I've defined so far is a
language for matching patterns on the
call stack I'm gonna say yes with a star
the reason I'm going to put the star on
it is that what you mean to say is
probably the right thing but you're
saying in a very implementation specific
terms and we worked pretty hard to
divorce it from implementation specific
terms so that's what the star is about
let me get to the concrete example so I
showed you that I could take to
permanent point cuts and compose them
what i'm doing here is i'm giving a
composition and name as an aside here
Abelson and Sussman's say that you have
a language when you have primitives and
means of composition and a means of
abstraction what's really going on here
is there's a little mini sub language
here for point cuts because I have
primitives I can compose them and I can
abstract over the composition so I'm
building the example now that I know
that he's asking questions again
okay I'm gonna say some more about it
but what I'm gonna say is I have a
user-defined point cut called change and
the implementation of that point cut is
that it matches any joint point which is
either an execution of the set p1 method
or an execution of the set p2 method if
you'd like it matches both set P 1 and
set p2 methods right because of the way
predicates compose whole hold on just a
second let me just get to the exam I'm
very glad about the questions I'm still
trying to answer his I'll just show you
two pieces more code and then I'll I'll
take a good question pause so here's one
construct point cuts
here's another construct this is a thing
called after returning advice and what
this says is it's another declaration it
says after returning from any join point
matched by this point cut I run this
code so you could sort of think about it
as I'm bombing along I hit a join point
that the point cut matches and on the
way back out I run this code and so now
here's your first concrete example this
is an aspect called observer pattern or
maybe it should be called my observer
pattern and it says
here's this observer pattern aspect of
the system and some points in the
systems execution are going to represent
what I call a change and if you want to
know which points it is well it's these
points here and after returning from any
such chain any such joining point after
returning from a change update the
display so there's a concrete example
and what's important is the way I want
you to read it so let me now I push
somebody's question aside I think it was
yours
you know one man's point is another
man's it's a node in the car graph so in
that sense it's a point right oh he's
wondering about why we're calling them
join points because in some sense they
represent a range of time and and that's
right the reason we're calling them join
points is when you take the broader
perspective of AOP in general you want
to be able to think of all these
different kinds of aspect mechanisms and
they're not all arranged like they're
more like join points so join point
turns out to be a better name in general
but the intuition behind your question
is exactly right
does not correspond to any
after we can eat somewhere in the
foreground
right the kind of senior question the
question is does every point cut have
the property that you could do after
returning on it modulo a minor issue
that has to do with the difference
between with one of the few differences
between the JLS and the jvm the answer
is yes yes so there's a slight way in
which what I'm saying is wrong but I'm
going to explain the real point the real
point is that there's three concepts
here there's join points which are
points in the collagraph there's point
cuts which match join points and there's
several different kinds of advice and
modulo this little detail the three are
orthogonal meaning you could put any
kind of advice on any kind of point cut
in or you can put any kind of advice on
any kind of joint point so every join
point has the property that it has a
notion of returning unless it throws an
exception in which case it doesn't
return but every join point has a
property have you come to it you do it
and you leave so the answer to your
question is yes
there anyway
we're coming to that
coming to that I just had a question up
the syntax after the after if Isis is
after the keyword
the name of your returning action after
the keyword well in aspectj these advice
are unnamed in some other ALP languages
they're named and there's a little bit
of math a little bit there's some debate
about which of those is the least about
idea yes
and why is it live that's like typing
I'm going to take one more that we're
coming to if either of these is one
we're coming to I'm going to go a bit
farther yeah
right so there's a big there's a big the
question has to do with and he's using
some of the terminology that this
research community uses and pointing out
that there's still sort of a dominant
with what what the research community
calls a dominant decomposition in that
some parts of the code are done with
classes and some parts of the code are
done with aspects and how did you decide
this was some of the that we used to
talk about a lot we called it strong AOP
and we aÃ§Ã£o P right is there a world
in which kind of everything is sort of
aspects and waiting to register with
something else or is this more aspectj
model of there's classes and then
there's cross-cutting aspects the way to
think about it I personally have come to
believe two things one strongly and one
a little less strongly which is that in
terms of the adoption of this technology
for the near-term future just to say the
next five to ten years this model this
this so-called asymmetric model is the
way to go
because most people have big systems
already and those systems build on very
large infrastructure libraries and so
there is this sort of dominant
decomposition out there that you've got
to work with I believe that pretty
strongly I think I also believe that
even if you rebuilt the world the quote
right way to go would be to have block
structure as your primary composition as
your primary structuring modularity
hierarchy as your secondary structuring
modularity and cross-cutting as the
third I don't think that a world in
which everything is cross-cutting to
start with is going to be a simpler
world to work with even though it's
quite clear that the the primitive
mechanism of join points could do that I
don't think you would I think you would
find that world much more interesting
than this world but I don't think you
would find it easier to work in that's
but but that's unproven and there are
there are other people in this field who
disagree with me about that point
the first point which is an adoption
point I feel pretty strongly about I'm
going to go a bit sorry sorry a quick
point I want to make here is the way I
read this to you is the way I want you
to think about it it's a declarative
semantics this slide here is what you
would write without aspectj the single
most common first mistake in
understanding AOP is to think about the
semantics of this as meaning this and
that gets you into sort of this program
transformation oriented semantics and
the reason people make that mistake is
of course the first implementations of
this word transformation oriented and
then people don't distinguish you know
the the implementation from the idea
right the better way to think about it
is in this declarative way and then how
it works behind the scenes who knows it
may be that a compiler does something
like this it may be that an aspect
oriented virtual machine never does
anything quite like this and I probably
don't need to belabor this point here if
I had to belabor it I would just point
out to you that in today in 2006 most
people think about objects like this
unless they're trying to answer certain
kinds of critical performance questions
they don't tend to think about objects
like this right now you know when the
world first started learning about you
know the third time objects were
invented in the mid 80s people talked a
lot about dispatch tables and thought
thought thought thought right but you
know Kristin's group and Ann Allen's
group never talked about that they
always talked about it at this higher
level I just think that's the way to
think about that idea scales you can't
do object oriented design if you're
thinking about dispatch vectors right
you can think about critical performance
issues that way and I'm going to claim
that the right way to think about
aspects is to think about them in a
declarative unit and now if you want to
ask
to ask a performance question well think
about what the actual machine
instructions are but don't make that the
only way you have of thinking about the
idea I won't belabor that point anymore
here I'll pause again in just a second
point cuts of course don't have to be
restricted to one class I could build
them up more and more and more and
here's a revised version of the observer
pattern which is now really capturing
most of the observer pattern behavior
for this application I'll pause here for
a second yeah your question still
anyway yeah it looks like the program
has gotten us one
there
right
how do I say this
you might think that did what he's
saying is in the effort to make program
more modular it seems that in some ways
it may have become less modular because
now if I go refactor like the pointer
line class where I make some edits to it
I might break how the observer pattern
works I'll come back to this a little
bit more particularly when I show you
the tool thing let me point something
out to you
imagine that the program is only a
little bit bigger like there's only 30
such shape classes okay and that those
30 such shape classes are part of a
system in which there's only 5000
classes and imagine that in that program
where there's only 5000 crosses there's
only 250 of these things going on okay
so we're talking about a small program
in that small program the likelihood
that you would be able and and there's a
couple papers I I have a paper but other
people have papers that that make this
argument in detail but the likelihood
that you would necessarily be able to go
and make a so-called local edit to here
without in some way screwing up this
cross-cutting functionality without
having to go read a lot of code very
small and I'm gonna argue that yes it
may be that changes you have to make
will break this aspect but because the
aspect is now captured in a declarative
way that has a well-defined interface
the tools are going to help you not
screw up whereas previously you were
completely on your own to not screw up
that's going to form of the argument
going to be because that's the only
thing that modularity technology can
ever do for you it can't solve the
problem that changing this might change
that all it can do is give you a
declarative interfaces that you can get
some kind of automated support for
reasoning about did the thing I do here
caused me to have to go look here and
I'm gonna argue that the aspect version
of the code does better on that hands
down okay and what you got to hold me to
is whether I make that kiss thankfully
I've only got 30 more minutes and then
you're all out of the room
so hold that thought I'm gonna talk to
that slide this is very good there's
lots of questions now what was I
thinking
and what I'm going to claim is that the
corresponding change in the ALP version
of the color versus the nominal
conversion of the code in the ALP
version of the code you're going to have
better support for making change
correctly
it's true now I've dug myself a hole
which I need time to dig out it oh
there's other ways to write this in
aspectj and all other AOP tools aspectj
has a very very restricted pattern
matching language that would let you
write this piece of code any subtype of
shape any method that starts with set it
takes one argument of any type there's
some question a lot of question is to
what degree you should feel comfortable
writing those kinds of wildcards most
people believe that in Java code where
the naming convention for setters is
highly enforced that's a reasonable one
to write but we'll talk some more about
that
here's the attribute question who was
that that was yours so now that c-sharp
and java have reinvented syntactic
flexibility you could also do this with
annotations you could tag these things
as changes and then your point cut would
get to be simpler your point cut would
just be well anything that's tagged with
a change do this right what if say
there's only five thousand of these
places
explicitly declaring them so travel to
specific behaviors so whoever go into
backbone and you figured oh I did
something that actually now does let me
change the way I can
for this specific project we don't have
to look for all the classes that try to
figure out whether this
so part of the answer here is going to
be tool support here is the best
practice that's emerging the best
practice that's emerging is if there's a
small number of places and the
annotation tells you something that's
true about this code notice that the
name of the annotation here has nothing
to do with the observer pattern if both
of those things are true then use an
annotation and write advice like that if
either of those things is not true in
other words there's a lot of places or
what matters here is not really true of
the code but it's true of some
particular context the code runs in then
you write these more what are called
oblivious point cuts that's that's
that's a term that that Bob admitted
having to do with sort of writing
writing point cuts in a way that this
code has no explicit marker for and I
think there's some pretty good arguments
for doing it that way I'm going to show
you that tools support gives you a
little bit of the best of both worlds
who asked about values there was
somebody here somebody said can you get
the values of the thing right so I I'm
not going to explain how this works in
detail but this that point cut uses the
special this point cut primitive for
getting access to the object which is
executing in other words the shape
that's changing and picks it up down
here and so I can write this advice here
where I actually know which shape is
changing and there's a couple other such
primitives there's one called target
which I call join point gives you the
thing being called and there's one
called ARBs which gives you the
arguments to the method and those let
you get some of the values that are
going around at the call in question and
those can be used in useful ways now
somebody right in here said that I
didn't have the behavior of adding and
removing the observers and stuff like
that that was yours so here's a revised
version
that uses what I said was going to be
called the second join point model and
aspectj the way to read this code is
that's a field declaration right it says
there's a private field of type display
called display what that shape dot means
is it means that the field is associated
with shapes that particular one means
anything of type shape you could write
something else if you wanted you could
have written just point there but in
this particular code I wrote shape it
affects the type shape and all of its
subtypes it's not global at all it
follows the type hierarchy okay it's the
type shape and this method here is a
setter that sets it I'm headed for the
full-on pattern without observer and
remove observer but I'm taking one step
at a time and now down here instead of
doing a static display update I update
just the displaying question the
interesting thing is notice this private
here this private is a funny thing it
says it says the field lives on shape
but shape doesn't see it only the
observer pattern aspect sees it it's
it's a property of the shapes but it's
private to the observer pattern this is
wonderful thing actually it replaces
this piece of code that you're used to
writing which is when you go and stick a
field in an object and again our method
on a setter method for it and then
there's a comment that says actually
this is only here for the benefit of
that guy over there right this piece of
code basically says that declaratively
it says you know there's a property of
these objects that really belongs to the
observer pattern yeah
Oh
question is the aspects have their own
names face to the dig avoid name
conflicts the answer is the answering
the simple answer is yes because this
field is private
another aspect could have a private
field of the same name and in fact shape
could have a private field of the same
name and all three fields would be
separate if the aspect had defined a
public field and the class had a public
field then that would be a name conflict
because in that case really the
semantics of your program is in conflict
right yeah
there is and the question is is there a
way to sort of attach the state
properties of aspects to define the
state properties of aspects to objects
in a particular context and the answer
is yes but it's more hair than I'm going
to get to but we can talk about it after
but not arrays we don't do a race that's
not a property of AOP that's a property
of the current version of aspectj in
java it's sort of it's arguable as to
whether it doesn't make sense to do it
for a race
and that's right you could have
different kinds of shapes so for example
a ship's triangle could have a set X and
set Y method I got that part of it
yes I okay good I can understand your
question the question is suppose that
there's a case where if I call said X
from over here I want to do one thing
but if I call said X from over here I
want to do something else and in fact
that's that's exactly the kind of thing
remember the comment I made about the
two kinds of point cuts and that the
game was going to be composing them
that's exactly what that's gonna let me
do hang on a second and I'll show you
I'll do one more now yeah
to many of the training is mass spec
Jase that problem
yes the follow-up question was within
the aspect itself can you get
circularity and the answer is yes right
aspectj has there's the canonical way of
writing infinite recursion in aspectj
right you write a piece of advice that
actually applies to the advice and stack
you get Stack Overflow you do that three
times and then you never do it again
it's it's kind of like learning infinite
recursion when when you're learning
recursion the first time I'm gonna have
to pick up a little little speed I won't
do this slide I will do this slide
because there's something to think about
what's happened to the structure of your
system here and one way to look at it is
in terms of refers to relationships in
the original plain java code the line of
code that was going to associate a
display with a shape looked like that
and the refers to relationships are that
that line of code refers to both display
and shape
and moreover shape and display refer to
each other because shape knows it has a
field of type display and display knows
that it has a list of shapes right and
so of course whenever you have a cycle
in your first two graph you have
something that can't be shipped in any
meaningful configuration without the
other thing right so from a product line
perspective cycles and they're a first
to graph potentially problem what
happens in the aspectj implementations
is that you get you basically get rid of
shape knowing about displays by moving
all of that into the observer pattern
and what that means you could do is you
could ship shapes with this observer
pattern in this display or you could
ship shapes with no display at all or
you could ship them with some other
observer pattern and some other display
because you've sort of separated the
core functionality of the things from
the presentation layer in this
particular example TV I wasn't sure TV
has this wonderful thing this Emax that
reads to him that works exactly this way
right
he's got advice to find on the Emacs
that basically preempts it doesn't
preempt it adds to the normal
presentation layer a second presentation
layer and it works exactly this way was
the original one his text I skipped a
slide that let me make this more nuance
point as I was running out of time
it's this slide it's the big shift
happens here and then a little bit more
shift happens here I don't want to talk
about that right now so I said before
the key idea was joined point models I
just go up one level of abstraction a
little bit and say that joint point
models basically have three parts
there's the join points there's a means
of identifying joint points and there's
a means of affecting the semantics at
joint points there's a typo there so the
first thing I showed you point cuts an
advise the join points were nodes in the
dynamic car graph the point cuts were
the means of identifying them and the
advice was the means of affecting them
the second thing I showed you the inter
type declarations to join points of the
member declarations there's a language
of patterns that I didn't show you for
identifying them and you can define the
member aspect J calls these the dynamic
join point model and the static join
point model because this basically has
dynamic semantics and this has static
semantics because by defining a new
member on something you really change
the type okay this is a bit more subtle
point but if you want to start thinking
about making your own AOP language for
your own custom thing the reason I put
this slide here is is to start to make
the move towards the the higher level of
abstraction of which aspectj is just one
particular instance
I'll talk a couple minutes about this
the AOP community talks about this
notion of cross-cutting structure and
says well you know way back in the day
we had block structure and then came
hierarchical structure and here's this
new kind of structure called
cross-cutting structure and we're still
sort of struggling over exactly what
that means that how to think about it
right incent into it's an intuition
thing I'll give you a couple different
ways of thinking about it one way of
thinking about it is this which is that
you've got a dominant decomposition and
you walk up to it and you use constructs
like point cuts and Inter type
declarations to slice a new interface
through it and then you program against
that interface that's one way you're
thinking about it I'm going to give you
three another way of thinking about it
is that you have these different D
compositions and in some sense the
aspect the whole aspect kind of slices
through those those two are quite
similar in some sense the the
intellectually most precise definition
is this one which is to say that two
concerns the primary functionality here
and the aspect functionality here cross
cut each other with respect to a common
representation if and only if they're
projections onto the common
representations overlap but don't
subsume each other sounds very good
it's what's going on here right the
projection of the red stuff into here
overlaps both blue and black but nothing
contains everything else right so
there's not hierarchical structure can't
help you with this problem because in
order for hierarchical structure to help
you with the problem it would have to be
that some things subsumes everything
else right so this is cross-cutting
structure personally intellectually I
think this is a powerful way of thinking
about it in terms of programming I think
this is currently the most useful way of
thinking about it hang on and this is
the way that some of the people who are
getting the most power out of this
technology or thinking about it which is
they say you know here's a big thing in
the interface that I want isn't there
but it really ought to be there it makes
good sense so I'm going to cause it to
be there and then I'm going to program
against it and you have these
consultants that are going into places
and saying oh yeah you can't figure out
what you do to any applications doing
five minutes later they're telling you
interesting things about it and the
reason is that they're not bothering to
sort of say well I have to go live in
that code they're saying I've got a
library of point cuts that gives me a
meaningful abstraction of that code I
can just cut through it program against
those point cuts and no interesting
things right away so I think that from
the power perspective this is the most
useful way of thinking about the
intuition of cross-cutting I think that
from the sort of intellectual
perspective this is the underlying thing
that's going on and I could say much
more about this than this but I'm gonna
leave it at that I cut off somebody else
over here I think
dude dude help anybody this time I was
wondering if any of the IET plugin
so I'm gonna come to that so let me do
the Aikido and this is going to address
a lot of the kinds of questions that
people are asking go ahead
there are people who say that it does
they're wrong no it's it's a point of
debate it comes all the way back to his
question right so I will argue and and I
think I have a very clear and convincing
argument that the old story about
encapsulation was a lie and it was a lie
for the following simple reason which is
that in the old story you said right you
stood there and in all honesty you said
line has an interface and point has an
interface and the interface you've heard
this room
imagine that I'm Barbara Liskov or
something and the interface described
the functionality of the thing we're in
the interface does it talk about the
call to display doubt updating nowhere
what happens with the call to display
the update is that some programmer who
doesn't own the line class or the point
class checks them out of CVS in the
middle of the night and adds this stuff
all through them and then checks them
back in and it's not documented anywhere
because there is no high ground on which
to stand to do it so what's happening is
that social practice is very clearly at
conflict with the story that we tell
about encapsulation and I sort of
believe and this is one of the things I
got from you know years at Parc is you
really ought to check the story about
your technology against what the users
are actually doing and if you did that
with integrity you would realize that
the current story we tell about
modularity is bunk no it didn't it
didn't the observer pattern gave a name
that you could if you chose to put on
the comment at each of the 47 places
that you did it
so it almost fixed it it gave you a
concept but hang on let me show you this
so a thing what I want to look at first
here this two microphones thing is a
problem um so I question that nobody
actually asked this time but many of you
were thinking is you know how do I
understand how my code is working da da
da da I'm sitting here looking at stead
X and I don't know there's this advice
and that's exactly the same problem as
I'm sitting here looking at said X and I
don't know whether it's a method that
overrides an inherited method in other
words the modularity technology objects
has given me something that I don't
understand necessarily and the way the
IDE solved that problem these days is
that they put a note they say well I've
read your whole program and I understand
it's declarative structure and there's a
little note and that's what happens here
this note says this is advised and in
fact it's advised by two things it's
advised by a tracing aspect and a
display updating aspect and I can go
look at that display updating aspect and
I can basically navigate that
cross-cutting structure so what's
happening here is that because I made
the cross-cutting structure declarative
the tool can show it to me and it can
show it to me in different ways here's
another way it can show it to me
what I've got here and this is just a
very small system but what I've got here
is a this system has two aspects in it
and what this is showing me is for each
of these classes where the two aspects
effect okay
so if I had say 50 aspects and I wanted
to see about the interaction of two of
them like it unselect all but two of
these aspects just select the two that I
want to understand the interaction of
and really zero in on that and try to
understand that behavior the language
has well-defined rules for that and
there's several mechanisms for
controlling it
so the point here is modularity always
has a cost and the cost it has is that
in some sense you get in indirection
and it's only worth paying the cost if
you get something back and what you're
getting back here is a couple things one
thing you're getting back is sort of the
raw the raw benefit of modularity which
is in some sense I could ship point
without display updating this tiny
program doesn't matter much but I could
ship point without display updating but
you ought to get a second thing back for
modularity which is the try to get an
ability to reason about the structure
now and I will argue that we're giving
you this in a much better way than you
could possibly have before because
before what you would have done is you
would have done with saying let me see
if I can get this right you would have
taken growl and you would have grabbed
against the files and then what's the
name of the thing that gives you the ten
lines before and the ten lines after
yeah why yeah minus B this guy's got
these guys done this 1,000 times you
taken the minus B and minus a thing and
then you would have wrapped that against
some second string and only the places
that matched both of them were the
places where these two things applied
provided of course that nobody changed
the names of any meaningless variables
that caused your grep string to break
everything that's right about that is
writer about this we're giving you a
compositional language for reasoning
about that kind of structure
I'm gonna run massively out of time so
I'm not gonna take any more questions
but I'll be here the rest of the day
until I escape I just want to show you
some other examples quickly I'm keeping
this part of cookies gives you skip I
did this to do this here's some more
examples who asked about the too many
updates ok this solves the too many
updates thing it solves it by saying
well I change and then here's another
primitive point cut it's called C flow
below and this point cut matches any
joint point which is in the control flow
of any joint point match by this point
cut so this is an aspect geranium that's
is the top level foo here you're
starting to see what it's like to be
able to program with compositional
cross-cutting structure because you've
got this notion of change which cross
cuts statically and you've got this
control flow which cross cuts
dynamically and you intersect those two
things and the thing you're trying to
say very simple to say that's right it's
it's exactly dangerous as any other way
of solving the problem here's another
nice one we actually didn't know aspectj
would do this for us until quite late in
the project this code has a factory
pattern in it the factory pattern says
that you're never supposed to call the
constructors of these directly you're
supposed to call the factory that's
unenforceable with Java but it's
enforceable with aspectj because it has
cross-cutting structure you say well a
new shape is a call to a constructor on
shape I'm in a factory if here's a point
cut I haven't shown you but this just
says I'm inside of a method called make
star on shape and it's a bad thing if
there's a new shape that's not in a
factory and this says if I do a bad
thing I should complain and this is so
useful that you'd actually like to get
these warnings at compile time because
this is this is what's called a static
point cut and so aspectj has a very
special kind of compile time advice
called declare error which roughly
speaking says if such a joint point
exists complain at compile time
one of the classic adoption strategies
for for a spec J in general and aop in
particular is to start by doing
architecture enforcement you don't write
any aspects that ship in the running
product you start by doing architecture
enforcement because you reduce your risk
let me go more quickly
oh here's the full-on implementation of
the observer pattern with lists of
observers and lists of lists of just
subjects the nice thing about this is
the completely reusable version of the
observer pattern which reads exactly
like the story in the goth book
here's another one this is an
accessibility finite state machine the
power of this example is to show you
that you could write a specs first cuz
this just says well what has this finite
state machine work well there's three
states
it starts out initialized there's some
authenticate operations and some access
operations if I return normally from
authenticate I become authenticated if I
return with an exception for my
authentic aide I become rejected and
before any access I better be
authenticated basically shows that you
could do prototype based development
with a specs in advance of the other
code being there because you could just
think this way and I'm gonna wrap up
I'll just say one thing here there's
lots of examples of this for other
languages and special frameworks and
da-da-da-da-da
you guys asked a bunch of questions so
that's great but we ran out of time I'll
say a quick thing about business
strategy and I'll tell you why the
logging story is so important when we
first demo aspectj for the websphere
team the thing that got them was when
the business analyst said so this means
that we could sell different qualities
of logging for different prices
the point here is that I don't know if
this works for you guys because you guys
are kind of different but the point here
is that this is a modularity technology
and if you want to think about it in
strategic terms the question to ask is
what can I modular eyes now that I
couldn't lodge allure eyes before and
that's what they were thinking right
they were thinking I can sell different
qualities of WebSphere to different
people for a different price point
there's this really wonderful book by
these two economists from Harvard
Business School it's worth reading on
that subject there's a ton of other
other resources there's a wonderful book
here by Nick there's a whole website I
will send you these slides so you can
get these links off of it he's telling
me I have to stop roughly speaking this
idea of cross-cutting modular
functionality when used properly makes
your code cleaner makes your code
modular makes your code look more like
the thing you were trying to say in the
first place but these guys are worried
about here is that used improperly it
could be a disaster and that's true but
used properly it makes code a lot better
and so it's worth playing with and if
nothing else it makes programs just look
a lot better and makes me feel better
about right now so I'll stop there</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>