<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript: The Good Parts | Coder Coacher - Coaching Coders</title><meta content="JavaScript: The Good Parts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript: The Good Parts</b></h2><h5 class="post__date">2009-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hQVTIJBZook" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everyone it's great to
see a big crowd here my name is Steve
Souders I work here at Google on latency
and I wanted to do a couple plugs for
these talks I'm trying to see about
starting up a series of tech speakers
coming in so a couple weeks ago we had
John Resig come in and you can see that
talked up on the Google developer
channel up on Google code and next
Thursday at 11 a.m. right here is Rob
Campbell who works at Mozilla and he's
one of the people leading the Firebug
effort and he's go to a talk next
Thursday at 11 right here on Firebug and
the new releases that are coming out and
some of the new features and but today
so today we have Doug Crockford I worked
with Doug at Yahoo that's where I met
him
and I remember the first time I met him
and he told me his name I said I know
that name somewhere I know that names
where oh yeah I've been using this stuff
on your website a lot and and so I was
really excited to meet him and he's a
really nice guy I enjoyed working with
him at Yahoo I have a little bit of
hesitation because when my book came out
it did pretty well and then Doug's book
came out and just kicked my books but
and so I just checked and I'm like at
6,000 and you're like 4,000 on Amazon
sales rank Doug so that's really good
and I I'm I believed that this talk is
largely based on his book JavaScript the
good parts and so we'll run for about an
hour and have time for Q&amp;amp;A so without
any further ado please help me welcome
Doug Crockford
I forgot here's your google Tech Talk
goodie bag this is what makes it all
worthwhile right here so thank you
everybody I'm Doug Crockford from the
Yahoo and I'm here today to talk about
the good parts now when I first started
talking about JavaScript there are a lot
of people who just could not accept the
fact that JavaScript has good parts but
in fact it does but it's not well
understood even now javascript is has
become probably the most important
programming language in the world
there's more JavaScript processors on
more computers than anything else by a
very large factor but despite that
JavaScript is is not held in very good
esteem even within its own programming
community for example if the c-sharp
community loves anders and the java
community loves Gosling and the PHP
community loves Rasmus but in the
JavaScript community there is no love
and there should be and I think it
indicates a lack of understanding and
that's why javascript is still the
world's most misunderstood programming
language it's the only language that I'm
aware of that people feel that they
don't need to learn it before they start
using
it kind of looks familiar and the idea
yeah I've seen this before I know how
this works in fact it works in a really
radically different way it just looks
very similar and then when people misuse
it as inevitably they do because they
don't know how it works they get angry
at it and misunderstand it which is a
shame because there's actually good
stuff in this language and because it's
everywhere
javascript is now becoming the virtual
machine for the world which is a really
odd mission for this little
misunderstood language you know you're
doing it here at Google with the with
the quit and there are lots of other
examples of the same kind of crazy thing
you know it amazes me the lengths that
people will go to to avoid having to
learn JavaScript but it's learn about
and you can actually write good programs
in it and like everything else knowing
what you're doing you know makes a
difference and so I'm here to enlighten
the world about javascript javascript is
a language of many contrasts it contains
some of the best ideas ever put into a
programming language and it contains
some of the worst ideas ever put into a
programming language and a lot in
between there is no other language which
has this amazing range of the ridiculous
and the sublime you know if you look at
the community people use Java scripting
it has the broadest range of programmer
skills of any programming language we've
got people at the very high end doing
computer science on this language which
it does really well because it's
basically skiing with C syntax and we've
got cut and paste Ruiz who don't even
know that their programming we're
putting stuff together and making it
happen if you gave those kids Java
compilers they would never get whole
with HelloWorld running but they can
work with JavaScript so the language has
amazing expressive power and it supports
everybody in between I contend there's
no other programming language that can
support this really broad audience of
users and I'll offer that as further
evidence that this language is getting
something right which again may be
surprising to the people who think this
language didn't get anything right
one of the reasons people think that is
that they have a lot of complaints about
it and I think these complaints are all
valid and I'd like to go through them
one at a time the first one is that
javascript is not a language I know if
you're programming in any environment
the desktop or embedded systems or the
server generally you get to pick what
language you're going to use but if
you're writing in the browser or if
you're writing in one of the
applications that has embedded
JavaScript in it you don't get a choice
you have to use JavaScript and a lot of
people get resentful about that you know
why should I have to learn this stupid
language I already know lots of other
good languages why can I use one of
those you can't and so they try to write
without learning the language which i
think is really a bad thing to do my
advice is man up and learn the language
if you need to be writing in JavaScript
there's nothing like knowing what you're
doing second complaint the browser
programming experience is awful which is
absolutely true but that's not
JavaScript fault I contend it's the
dog's fault the Dom is one of the worst
api is ever imagined and that's what you
have to use when you're using the
browser fortunately there are a lot of
Ajax libraries available now which all
do an amazing job at correcting the Dom
model and turning it into something that
you can actually write good applications
in so there is a solution to that I'm
hoping eventually we can push that
solution back into the browser but for
now the Ajax libraries work really well
Yui I'll mention that one comes out of
Yahoo is actually very very good I think
maybe the best of them there are lots of
others that are also very good there's a
complaint that it's not fast enough and
in the browser that's mainly because of
the Dom again if you look at the
fraction of time that your program
spends running a tiny fraction of it is
actually running in the JavaScript
interpreter most of the rest of it is
wasting time in the Dom interface so if
you could somehow make your programs go
infinitely fast most web applications
are going to look about the same there
are other applications for which having
a faster language would actually be a
benefit and so I'm happy to see that
mainly I think because of leadership
from Google we're now starting to see
higher performance JavaScript engines
which i think is really really cool and
very much to be encouraged
although practically I don't think it's
going to make much difference to web
applications for a long time then
finally there's a complain that the
language is just a big pile of mistakes
and I I contend no it's not just a big
pile of mistakes that hidden under a
huge steaming pile of good intentions
and blunders there is an elegant
expressive programming language because
javascript has good parts and if you can
recognize those parts and use those
parts exclusively and avoid the bad
parts you can actually write good
programs in this language and I'll offer
again as evidence of that that
JavaScript is succeeding very well in an
environment where Java was a total
failure
I don't know if anyone here in number
Java applets now they're going to change
the world didn't happen crap Java Scala
turned out to be an OK language and
found a niche in the server where it's
doing pretty well but it was absolutely
awful as a client programming language
JavaScript is doing really really well
there the influences on JavaScript were
self from which it borrows prototypal
inheritance and dynamic objects dynamic
objects are really clever clean and they
work really well in this language from
schema gets lambda which is maybe the
best idea in the history of programming
languages and loose typing which is
pretty controversial the style of most
languages today calls for strict typing
the theory being that strict typing
allows for the compiler to check a large
class of errors at compilation time
avoiding and catching any error early
reduces the cost of the errors and so
that's a good thing in JavaScript
doesn't have that so in JavaScript any
variable or any parameter can contain a
value of any type and that's really
frightening to someone who's coming from
a strongly typed tradition like how can
I have any confidence that anything is
going to work right it turns out that's
drunk typing doesn't absolve you of the
need to test you still have to test
everything because there's an even
larger class of mistakes that type
checking doesn't find
for you and I found in my own practice
that the amount of testing I have to do
writing in Java or writing in JavaScript
is about the same that those type errors
get down really quickly anyway so that
they're not really a problem there is
that are a problem the ones that keep me
up at night
type safety wouldn't have helped me
there the benefit of having loose typing
is you don't have to mess with a type
system and so that turns out to be
liberating your programs tend to be a
lot smaller and a lot simpler so which
one do you like well it doesn't matter
if you're working in JavaScript it's
going to be loosely typed and that's
just the way it works from Java we get
syntax which is a source of a lot of
problems because it's basically the C
family of syntax which we've all learned
to deal with we've gotten so good at it
that we don't even recognize anymore how
defective it is but because javascript
is used by beginners those problems are
intensified and then finally from Perl
JavaScript gets a really horrendous
regular expression notation so before we
get to the good parts
let me gentle eyes you with some of the
bad parts the worst part by far global
variables javascript doesn't have a
linker so the way compilation units get
bound together is they all get tossed in
a common global namespace where all the
variable names can't collide and
interfere with each other it has
terrible reliability problems it has
even worse security problems you've all
heard of cross-site scripting attacks
those attacks are fundamentally enabled
by Java scripts use of global variables
Java JavaScript uses plus to both add
and concatenate it got that little bit
of overloading from Java in Java it
wasn't too bad because it strongly typed
and so you could predict which one it's
going to do in JavaScript you can't so
this is a very common source of errors
semicolon insertion was something
intended to make the C syntax easier for
beginners
see syntax the rules for where a
semicolon goes it's kind of complicated
and you really have to understand the
syntax of the whole language in order to
understand where to put them and so to
make it easier for them JavaScript says
we'll put them in for you so you don't
have to use them the way it did that was
when the compiler gets an error it backs
up looks around for a line feed turns it
into a semicolon and then tries again
that should freak you out
it sometimes puts them in the wrong
place sometimes doesn't put them in
places where you'd expect my advice
figure out where the semicolons go put
them in the right place you'll be much
better off JavaScript has a type of
operator which allows you to determine
if the type of a value is a string or a
number or something like that which is
really good if you ask it what the type
of an object is it says it's an object
it's great you ask what the type of an
array is it says it's an object which
isn't very helpful if you ask what the
type of null is it says it's an object
which is wrong it has a width statement
which was well-intentioned but doesn't
work right I highly recommend you avoid
it simply by being in the language it
causes programs to be a lot slower than
necessary whether you use it or not
and similarly eval is the most miss you
miss most most misused feature in the
language if you ever find yourself
needing to use eval you're probably
thinking about things in a really wrong
way so step away from the computer read
my book and then take another run at it
javascript has phony arrays in most
languages you've got an array which is a
linear sequence of memory which is
divided into regularly spaced pockets so
you can do address computation to very
quickly get to an element JavaScript
doesn't have anything like that in
JavaScript arrays are essentially hash
tables in which the keys are turned into
strings and then hashed to locate the
buckets this has a terrible performance
penalty but it has an advantage and that
it makes the programming model quite a
bit easier because you don't ever have
to dimension an array dimensions don't
exist on this language it has a equality
operator that does type coercion which
turns out to be problematic I'll show
you an example in a moment and it has
too many bottom values which is a
problem because beginners tend to get
confused by having all these things
which almost mean the same thing but are
slightly different in their meaning so
these are some of the consequences of
type coercion on the Equality operator
there are rules that govern this this
isn't random behavior but it's certainly
surprising behavior and it's and the
rules are not memorable so this all
looks very mysterious fortunately the
language has a triple equal operator
which does not do type coercion so it
would answer false to all of these cases
which is the right thing so I highly
recommend always use the triple equal
operator never use the double equal
operator just don't use it so one of the
nice things about the dynamic objects in
this language if you ask an object for a
property that it doesn't have you don't
get an error it doesn't throw it just
returns the undefined value which is
really nice so you can you know
reflection is just automatic on things
like that so if you then ask if the
thing is undefined then you can do
something about it but because a lot of
beginners don't understand the
difference between null and undefined
they use null and they use the wrong
comparison operator which often works
it's a case of two errors that cancel
each other out
that's not a good way to write program
so the right way to write this program
would be to use the proper Equality
operator on the proper value and that
will work for all cases there's another
case where good features interact badly
in this language I'll give you an
example objects can inherit from other
objects which is good that's and one of
the interesting things about this
language is you don't have classes
inheriting from classes objects inherit
directly from other objects which is
really powerful it turns out objects can
be members of our functions can be
members of objects which is good that's
how methods are created in this language
and we have a for in statement that
mixes inherited functions with the
desired data members which is not useful
at all and is a common source of errors
so how did that happen
there was a design question in the
making of the language should the
foreign statement which iterates through
all of the members of an object to a
shallow skim of the object's own
properties or should it do a deep dredge
going through its inheritance chain the
decision was to do the deep dredge and I
think the thinking was that if we do the
shallow one and what people really want
is the deep one
we're screwed that they just can't get
at that stuff whereas if we do the deep
one and what they wanted was the shallow
one they can do the filtering themselves
except that they didn't tell anybody
that that's why they did it and that's
how it works and so as a consequence
there's a lot of confusion about how to
use for in and how to attach methods to
prototypes I think a better decision
would have been to not release the
language until they had enough
experience with the language to know
what the right answer was but to put it
into historical context at Netscape
getting it right was not an option which
is why there's no longer Netscape ah yes
isn't the real
people are using hash tables members
like dysentery no we can get to that in
the Q&amp;amp;A so these are things which are
wrong with JavaScript which are really
wrong going all the way back to be
actually but I'll talk about them here
because we're talking about JavaScript
we have the option of using blockless
statements which is a bad practice it
creates code which is more likely to get
damaged under maintenance so I recommend
always putting the curly braces in it
allows for expression statements in
which you can just have the name of a
variable or a simple expression and do
nothing I think the reason for that was
it made specification of the syntax a
tiny bit easier they were able to save a
production or two but as we're going to
see it just messes things up the most
often reported error in the language is
that point one plus point two is not
exactly equal to point 3 and this is not
really a problem with JavaScript it's a
problem with I Triple E floating point
that floating point is the only number
type in the language having just one
number type in the language it turns out
to be really nice particularly for a
language that beginners use because
there's a whole lot of compatibility
problems that just go away everything is
the same type but unfortunately they
picked the wrong type that you tend to
do a lot of computations involving money
in this language and the sums come out
wrong and generally when you're adding
people's money people have an
expectation that the results going to be
right it's hard to do in this language
unnecessarily hard it has the increment
and decrement operators which are very
convenient that have been implicated in
buffer overruns and other security
hazards I found in my own practice that
when I used then I would tend to write
code which was too tricky and code which
is too tricky is too often wrong so my
own practice I don't use them anymore
at all ever just part of my discipline
finally has the switch statement the
switch statement was modeled after the
Fortran computed goto and has the
property that one case can fall through
into the next case I'm going to tell you
later about a program I wrote called
jslint which is a quality code quality
tool for JavaScript
one day someone wrote to me and said you
know the language has switch statements
and sometimes you can have one case fall
through into another case and it's
really difficult to see that when
reading the code you know so can you
have Jace Lynch generated a warning
anytime that happened and I thought
about it deeply and I wrote back to him
I said well there are cases where it's
actually beneficial to have that falling
through and you could have code
indicating you know whether you intended
that or not but you know that that
doesn't really work you know so
imbalance I think maybe it's better just
to leave it alone that it's actually a
good thing to have in the language next
day the game same guy sent me a bug
report that I had something that jslint
was miss classifying so I threw in the
debugger and it turned out I have a
switch a statement that was falling
through
so in that moment I achieved
enlightenment there are these moments in
your programming career where you
actually learn something learning turns
out to be really hard and in this case I
actually learned my lesson and so I now
never intentionally fall through in a
switch statement and because of that I
can now much more easily detect when I
accidentally fell through a switch
statement so as a consequence I think my
use of that statement has improved
significantly so you've been waiting for
the good parts here they are it's a
short list but it's a good list at the
top of the list is lamda this came out
of skiing which came out of Karl
Hewitt's work on the Akhter model I
think this is the best thing ever to go
into a programming language it's
powerful it's safe it's smart it's good
it's flexible great stuff
javascript has dynamic objects which
means you can take any object at any
time you can add a new property to it or
remove a property from it you don't have
to go to some class and and make another
derived class in order to have an object
which is slightly different than the one
you've got that turns out to be
amazingly powerful makes this language
especially easy to use it's got the list
typing in it which some people look in
look at as a severe disadvantage I think
it's actually an advantage this language
is better off I think for having loose
typing and it has object literals object
literals are a very nice notation for
describing objects javascript object
literals were the inspiration for the
json data interchange format there
inheritances object-oriented code reuse
and there are two schools of thought for
how to do that there's the Classical
School which was represented by almost
all present-day languages and there's
the prototypal school which is
represented pretty much just by
JavaScript the no other languages in
broad use which have this property
turns out the prototypal inheritance is
amazingly powerful but it's not well
understood it's so powerful that you can
program as though it is classical and it
mostly works you can't do the opposite
you can't go to a classical language
as though its prototypal so in
prototypal inheritance its class free
there are no classes objects inherit
directly from other objects and in this
language an object contains a hidden
link to another object from which it
inherits stuff in a process called
delegation sometimes called differential
inheritance so each object contains only
what makes it different from the object
it inherits from and it allows for
objects to be much smaller for a long
time the language was ambivalent about
its prototypal nature and so never
included an operator for actually making
new objects which inherit from other
objects we're correcting that oversight
in the next edition of the language with
object create which will make a new
object which inherits from an old one
it's not in the current browsers but
it's easily implemented until it becomes
standard equipment you can realize it in
this way
what javascript has and instead of this
operator currently is a weird trio of
constructor functions prototype members
and a new operator which we're intended
to provide a friendly object or friendly
classical like notation for dealing with
prototypes but it didn't work the Java
community smelled this immediately and
said wow that's alien that's clearly not
something we like and so what it really
did was confuse what the language was
actually doing so in as part of that
sugar for trying to look classical
JavaScript has a new operator which is
absolutely required when you're calling
a constructor function if you call a
construction constructor function
without the new operator instead of
creating a new object initializing it
your constructor will clobber the global
object which is a very very bad thing
there is no compile time warning and
there's no runtime warning for this so
for this reason i don't use new anymore
i think it's just too dangerous so it's
time to look at some code here i'm going
to make a simple little function called
digit name which i'll pass it a
number and it will return a string which
is the name of the digit so I've got an
array of strings which I create using an
array literal very nice and then the
function returns looking up the argument
in the array so everybody understand how
this works all right
problem with this is names as a global
variable so if there is anything else in
my application called names either it's
going to fail or my program is going to
fail or we're both going to fail which
is really bad particularly as pages
become really dynamic
I may be linking with libraries I've
never seen we'll never get a chance to
test with I maybe having to run with ads
which I will never see which could
interfere with my program so I want to I
have really good reasons to try to avoid
global variables in the language gives
us a couple of options for doing that
one approach would be I could define the
array of names as a private variable of
the function and that works just fine so
we have function scope in this language
we don't have block scope so you need to
understand the difference and do it
right but having that this will work so
names is no longer global variable so I
avoid that hazard the problem with this
is that every time this function gets
called we're going to reinitialize the
names array now in theory an optimizing
compiler could detect this case and
factor that out but today nobody does
that so I might want to write this
function a different way to avoid that
so one way I could do that would be to
put it in a closure so here I've got a
function which is going to return
another function and the outer function
gets executed immediately
okay the inner function has access to
the properties of the outer function or
to the variables of the outer function
and will continue to enjoy access to
them even after the outer function has
returned so this allows me to have so
when it returns the function goes into
digit name and that function will have
names bound to the original array and
will continue to have it for as long
lives this is an amazingly powerful
thing that this language does very very
nicely and we can generalize this into a
constructor pattern so if you think of
an application or any kind of singleton
we don't have to make a class in this
language to make a singleton we can just
make it and the property or the methods
that that singleton has can enjoy
private shared access to stuff we don't
have to put it in global variables so I
can again I've got a function which I'll
execute immediately and return an object
literal which contains some methods
which will do useful stuff and those
methods will have access to the private
material that the outer function
provides for them we can take this and
turn it into a constructor which is a
very nice way an alternate way in the
sandwich for making objects so here's
the recipe step one you make an object
in there are four ways we can make an
object we can use an object literal we
could use new I don't do that but you
might we could use object dr8 to we get
something from an existing object or we
could call another of these power
constructors which gives us a another
inheritance model step two we did define
some variables and functions these will
become the private members of the object
that we're making step three we augment
the object with privileged methods
privileged methods have unique access to
the stuff defined in step two then step
four we return the object so pretty
simple recipe let me turn the recipe
into a template so step one I'm going to
make a new object I'm going to put it in
a variable called that that because it's
reminiscent of this and I can't call
this because this is a reserved word
step two I'll define a variable that
will be secret that be private shared by
these guys
step three I'll create a privileged
method which is a function which will
have access to the state of the outer
function and step four I return that
that's it a really easy way to make
objects which can hide their stuff and
be private so the reason this works is
because we have closure in this language
which means that a function object
contains the function itself which has a
name and parameters and a body and it
has a reference to the environment in
which it was created in the context you
know which in this case is the stuff
that was in the outer function this is a
very good thing this is one of the best
parts of this language now concerning
style if you get any two programmers
together they could argue all day about
matters of style like should the curly
brace be on the left or on the right and
they may get really emotional about
which way it goes we feel very strongly
about this stuff even though we don't
know why it you know we can't agree that
whichever we do we should be consistent
but it's hard to to find agreement on
should it be on the left with right it's
sort of like what side of the road
should we drive on there's not a
compelling reason for why we should
drive on the left or right as long as we
all drive on the same side if if we
don't then bad things will happen and we
have a similar thing here so if you look
at why people get emotional about this
stuff where did the idea of left Nisour
rightness come from you know you could
trace it down to where they went to
school or what they learn on their first
job or am deeply impressed by somebody
early in their career they may give you
a lot of reasons for why the left side
or right side is better than the other
but they don't fundamentally know they
just get really emotional about it well
it turns out having them on the right
side is the right way on the left side
is the wrong way in JavaScript I can't
testify for any other language but it's
absolutely true for this language and
I'll show you an example why so here we
have a return statement which is
returning an object literal we saw an
example of that in the earlier
construction pattern the one on the
right works right and the one on the
Left silent error it doesn't return an
object it returns nothing returns
undefined which is deeply surprising and
and wrong you don't get a compile time
error you don't get a run timing
you don't get nothing in the log this is
really bad so how does this happen
because the two statements look like
they should be equivalent so let's zoom
in on a little bit look at what's going
on all right you remember I told you
about semicolon insertion how will
sometimes put semicolons where they
shouldn't go this is one of those times
so it puts a semicolon there so a return
statement with no value after it no
expression after it will return
undefined in most contexts occasional
return is so but there's a lot of other
junk here that should cause some sort of
syntax or something give us some serve
warning well no because it turns out
that curly brace can mean start an
object literal or it could mean a block
now it turns out in this language we
don't have block scope so so having an
empty block is not useful but we have
one the syntax prefers a block to a
literal in this notation so that's what
we get okay so okay doesn't look like a
statement well actually it does it looks
like a statement label
well false doesn't look like any kind of
a statement but remember we have those
useless expression statements that we
inherited from C so we'll evaluate false
go yep that's false and ignore it but it
doesn't have a semicolon after it well
that's not a problem because semicolon
insertion comes in repairs that one now
we've got an empty an extra semicolon at
the bottom there that that should
trigger an error no because from C we
also get the empty statement which
allows you to have this many semicolons
as you want so all of these things tend
to work together to mask errors then
finally we've got some unreachable code
here but JavaScript doesn't care so
there's nothing in the language in the
grammar that says there's any problem
with unreachable code so here's a case
where bad style produces a very bad
result we've got code which you think
means that which means that that's one
of the worst things a language can do to
you now you might be looking at this you
might be wondering how did how did this
ever become a standard
and you might be wondering why am i
betting my career on this piece of crap
on getting back to the question about
standards this shouldn't have become
standard but there was nobody paying
attention and this stuff went through
and JavaScript became the world's
biggest programming language completely
independent of its merits given the
process by which all of that happened we
deserve a language which is far far
worse than javascript in fact given its
amazing success despite some of these
obvious shortcomings I think we got
lucky
so there's actually enough goodness
smartness built into the language with
that if you can just avoid the bad parts
the good parts are really good and are
worthwhile so I call that working with
the grain I spent a lot of time
struggling with his language trying to
figure out how to make it work right how
to make it do good things because all of
the examples that were published by
Netscape at the time that you could see
coming out of Dreamweaver all told you
to do really awful stuff and it took a
long time to figure out what this was
about I remember one day I had an
epiphany
wait this is scheme you know I there was
no documentation which said that how
functions worked and and the properties
of it it was an accidental Brendan Eich
the designer of the language always
intended to implement a scheme language
at his bosses at Netscape wouldn't let
him do a scheme language because it was
too weird-looking they told to make it
more like like Java or Visual Basic or
something so he did this to it so it's
not accidental that the good stuff is in
the language he put it there
intentionally so he very quickly put
together a prototype in an amazingly
short time and presented it to
management and it seemed to work
they said it seems to work he said yeah
so they shipped it
then Microsoft observed it and decided
to knock it off and they reverse
engineered it to amazing fidelity they
found all of the errors that were in
that first implementation and copy them
exactly when it went to standardization
all that stuff dropped into the standard
so this bit I showed you before this
amazingly silly bit of silliness that's
not due to errors and implementations
it's required behavior by the standard
and in fact all the browser's
implemented exactly that way
so when JavaScript was first introduced
late in 1995 it was intentionally
mispositioned by Sun and Netscape they
decided they needed to join together
against Microsoft and there was some
confusion about why they needed two
languages because clearly that Java was
going to be the language that was going
to rule in the future
Netscape didn't want to give up on this
language which was called JavaScript at
the time and their Alliance almost broke
down until mark increase and perhaps as
a joke suggested that they call it
javascript that way Sun wouldn't have to
hate it I'm sorry
it was live script so I looked at the
the first version of the language and
like all of you I said well this is
incompetent crap I'm not going to waste
any time on this I had an occasion
several years later to take another look
and between that time the next some
goodness had been added to the language
that was missing from the first release
my company was approached by Turner
Broadcasting to do a website for
children based on Cartoon Network and we
had a chat system that we had that they
wanted to adapt to this online
children's community so I went down to
Atlanta and learned about the
requirements it was pretty clear our
chat system wasn't going to be good
enough to do this and I didn't want to
give the money back because this was
like the biggest contract in the history
of the company and I really wanted to do
this
so I don't know where it came from but I
got this really silly idea maybe we
could do it in the web browser just as
it is so I growed up a little prototype
and it ran on ie 4 I think at the time
and on Netscape 4 and I sent it to
Atlanta and they liked it you could drag
and drop little cartoon guys they'd
never seen anything like that in a
browser before and they liked that it
wasn't a big installation that was just
a little thing that ran the browser so
something they could ask kids to do so
that was really good so I went to my
team and my team I had some of the best
childhood developers in the world we'd
been together for a long time we had a
lot of experience of doing this stuff
and I said ok this is how we're going to
do it we're going to write the client in
the browser in JavaScript
and they all said and you may remember
that's great what's plan B
FAQ we should start plan B right now
because there's no way this is going to
work I said no we're not gonna do plan B
we're going to do plan a and it is going
to work so who wants to do the
JavaScript and everybody took a step
backward so it was like I have to do
this and I'm gonna have to give the
money back and I really didn't want to
give the money back so I had to do
JavaScript and like everybody else I
started doing it without learning it and
was hating it the whole time and it
wasn't until I had the the scheme
epiphany which came late that I
understood what it was about it was like
oh ok well this isn't so bad
there's actually goodness in it and
discovering the goodness it's like
there's Jason in it Jason came about it
from my experience in using the language
and recognizing hey this little bit of
the language could be used for doing
data interchange it was great it was
already there was free and it was well
done so Jason just as a consequence of
my recognizing that has become a world
standard the Jason story in 2001 chip
Morningstar and I read state software
and we had an early age ax platform
really amazing stuff I think it's still
better than what's out there today and
we use Jason for the data exchange and
we went to potential customers and we
explained how it worked and they said
where's the XML and so we don't need XML
we're doing this it's really so much
easier and faster and then go oh we just
committed XML I'm sorry we can't use it
or say it's not a standard and said well
yeah it's the standard it's in
JavaScript because it's not a standard
we can't use it
so I declared it's a standard so I
bought JSON org and put it up one page
or that described it because it's really
simple it's all the description it
needed a few years later I also wrote an
RFC to describe it a little bit more
formally and it's become a world
standard basically I am a standards body
it became a standard just on my say-so
so anyway getting back to the electric
community story so we that JavaScript
program we finished we shipped it we got
paid all that stuff was great
unfortunately while I was making the
money the other half of the company was
spending the money so by the time it all
got done the board fired the CEO in the
CLO and made me CEO again and I had
about two weeks cash and anyway when
you're going through bankruptcy you get
a lot of spare time and so I remembered
a paper that von prat had written years
ago at the first Popple conference about
top-down operator precedence which was
this amazingly clever elegant
lightweight way of writing parsers and
he used it for putting an alcohol like
syntax on to lisp but it turned out the
list community has never wanted syntax
but the JavaScript community like syntax
and so it occurred to me that I could
write a JavaScript parser in the
language and I did and it turned out
really well and then I had this
JavaScript interpreter or JavaScript
parser and what will I do with it so I
turned it into a code quality tool for
JavaScript called jslint and so with
jslint does is it parses your program
and analyzes it for the sorts of
weaknesses that I've been showing you
identifies the bad parts
and if you can get it to stop
complaining about your program then your
program probably just contains good
parts and it's more likely to be a good
program so it imposes a programming
discipline that makes me much more
confident in being in this very dynamic
very loosely typed environment the sort
of confidence that strict typing gives
you chance Lynch gives me in the silly
little language and it's free if you're
writing a JavaScript you need to be
using jslint so go on the web and get it
if you're evaluating other people's
JavaScript it's good at that too so say
if you're comparing Ajax libraries you
don't know which one to use right
through jslint see which one is coded
well it'll tell you very clearly
well that one bit of warning jslint will
hurt your feelings it'll it'll hurt them
really bad it stings from time to time
people will write to me and say hey
here's another thing you could test it
if it makes sense I'll put it in and
then I'll run all of my old programs
against it and realize well I really
suck you know even though I wrote it
even though I know what all the rules
are it still hurts when I run into this
stuff and so I can imagine your pain
when you go through this stuff I do feel
it despite that I recommend do
everything it says because it's right
and even though you've been programming
in you've got a good career and you
really know what you're doing it's
smarter about JavaScript than you are
it's certainly smarter than I am highly
recommend you use jeaious linton one of
the things that makes it hurt is that
unlearning is really hard I get letters
from people all the time saying jslint
said my stinks what's up with that
and they they always use the words
perfectly fine I did this thing and it
was perfectly fine we're I think
perfectly fine it's double equal to
faulty and they're arguing with me why
should I have to fix that and I don't
care if you fix it it's not you know
nothing to do with me you're not even
paying me for this I'm just putting it
out there free if you want your programs
to be good make them good but you know
we get really invested in this stuff and
ultimately it's because I'm learning
this stuff when you learn something
wrong it's really hard to get it right
on in JavaScript if you're a capital
programmer you're coming to the language
with baggage from other languages and
because it looks like Java but works
completely different than Java it's
really easy to get stuff wrong unless
you're paying attention to what you're
doing or if you're a beginner you
probably started by reading a view
source on crap that ultimately traces
all the way back to Dreamweaver and it's
awful and that's the way people learn
and once that stuff gets in your head
it's really hard to get it out but you
need to do it
Josh billing said it's not ignorance
does so much damage just known so during
much that ain't so any thought the truth
so maybe the best part about this
language is its stability there have
been no new design at her since 1999 and
this is a consequence of that's the last
time the language spec was revised was
in 1999 but I think it's a good idea to
every ten years or so revisit the
specification so we're about to lose
this best part we're about to come out
with a new edition which is codenamed ES
3.1 which will probably be labeled echo
script fourth edition there's a weird
story you might ask me about later for
why it's called Ekman script or not
javascript this new edition will contain
a lot of corrections both corrections to
the specification and some corrections
to the language it turns out there cases
where all the browser makers did
something different than the standard
and they all got it right so we're
recognizing that and making standard
better there are also places where we
saw three out of four of the browser
makers we're doing one thing and
Microsoft was doing another we're fixing
that now to the next version of jscript
coming out of Microsoft we'll be in much
closer Alliance to the common language
than everybody else so one of the key
benefits from this language is that
cross browser compatibility will be
significantly improved now it turns out
javascript is already I think one of the
best languages in the world in terms of
compatibility with multiple
implementations you know two javascript
engines are much more likely to be
compatible at a really deep level then
say to see engines javascript gets
knocked pretty hard about cross browser
compatibility but most of those problems
are due to the Dom the language itself
tends to be pretty good it's going to
get even better we're providing support
for object hardening so objects right
now or maybe too dynamic where
everything in them is completely
malleable all the time so we can now
make objects immutable we can lock down
individual properties or lock the whole
object down this will be particularly
good as we start looking to some day
towards secure mashups where you can
have a hardened object which you can
give to other code and it know that it
cannot be compromised we'll also have a
new strict mode for reliability so there
are a lot of things in the language
which are just intolerable but the
biggest problem with the bad parts in
this language isn't if that they are
useless they actually are occasionally
useful and so the web has found useful
uses for all of the really bad parts of
the language so we were very greatly
constrained in what we could take out
and we've tried to be respectful for
existing code and try to minimize the
breakage that the new language will
cause but there's some stuff in the
language which really has to be fixed so
we now have an opt-in mode you can say
strict mode and put it in the top of
your program or in the top of your
function and that says I don't want the
crappy behavior I want the rational
behavior I recommend you not put the
strict mode tag into your program unless
you understand what it does and what it
means and that that's the language you
want to be writing in but I recommend
that's the language that you want to be
writing in so right now we're waiting on
implementations the specification is
just about done Microsoft and Mozilla
both committed to public testing if that
testing goes well then the standard
should go to the ECMO General Assembly
in December and I'm hoping that it will
pass and then we'll probably see it
appear in web browsers even before that
if you can hold it to the end it we're
almost there
something that's not coming soon is a
competing project called es for that
project has been cancelled there were
some good ideas in that project though
and they've been resurrected in a
follow-on 23.1 called harmony so far the
project doesn't have any defined goals
or rules so it's a little vague as to
what it's going to turn out to be we'll
keep an eye on that there's been some
really interesting work lately in secure
subsets javascript is not a secure
programming language but it's not far
off from one if you correct get rid of
the global object to make a few other
changes hold much closer to its scheme
nature there's the kernel of a secure
language in there we've seen some
experiments like f bjs out of facebook
kahan kajita from the google + ad safe
which is my own work ad safe is intended
to make advertising safe currently it's
not we can talk about that another time
these subsets will be informing the
design of a new language which will
ultimately replace JavaScript and
there's some exploration going on now a
tech ma for such a language so to review
the good parts this is maybe the best
part of all your javascript has
application has the potential to reach
an audience of billions there is no
other programming platform that has
anywhere near that kind of reach and you
know just that I think should be enough
to encourage you to to want to be on
this platform if you avoid the bad parts
JavaScript works really well there's
even brilliance in this language there
should be love in the JavaScript
community for this language and it's
designer is there is goodness here and
it is possible to write good programs in
JavaScript there are a lot of people who
thought it's not possible to write good
programs so you shouldn't even try and
my message is it is possible and it is
necessary to write good programs if you
don't want to write good programs I
recommend you find another line of work
then finally here's the commercial plug
I wrote this cranky little pamphlet
called JavaScript the good parts so if
you want to know more about this silly
language that's where to go
so that's it that's all I got for you
today thank you so how did do we do
questions here sir Michael do I repeat
or what okay
yes strictmode does it change behavior
it does it take things out it actually
changes some behavior so one of it does
take some things out like you can't have
a with a statement in strict mode so it
does take some features out of the
language it changes the way some
features work like it greatly constrains
how eval works and reduces its ability
to do harm to the state it also changes
some error behavior for example
currently in the language if you do an
assignment to a read-only property of an
object you get a silent failure which is
a bad thing in strict mode you will now
get an exception which is a better thing
I've heard you and some other people I
know talk about ideas or projects
you can turn the update on what's what
question is what are we doing about the
Dom problem one bit of difficulty about
that is there are two independent
standards bodies that control two parts
of the system Eckman controls the
programming language and w3c controls
the API and these two organizations as
far as I can tell do not cooperate with
each other they don't talk they don't
share plans that's a problem and so
there's much in the Dom or fixing the
language will not solve any of our
security problems if the DOM is left the
way it is because it is also hopelessly
insecure so I'm hoping that we can put
Ekman and w3c together and do a more
collaborative approach to revising the
Dom I see work going on on html5 in the
web api stuff and it's really alarming
to me I think they're going off in a
very very bad direction I think it's way
too complicated I don't think it's
addressing our real problems it it just
seems more like a standard makers
holiday to me so I'm hoping that we can
do a reset there start over with a
better set of goals that we can go into
the future together I'm optimistic about
it because of what I've seen in the Ajax
libraries you know the the Dom model is
just really awful there was originally
the Netscape model which was even worse
Microsoft improved it Microsoft gets
beaten up a lot for making the Dom so
bad and I think the thing they did wrong
was and they stopped too soon um but it
is bad but the Ajax libraries are all
very thin just you know little bit of
code you know generally on the order of
20 to 40 K which makes it so much better
you know so eventually I'd like to take
a look at the lessons that we got from
the Ajax libraries and then refactor the
Dom based on that push it down and that
becomes the new API
oh yeah about Lisa lambdas good eggplant
oh you had lots of praise for it but
lambdas boards and closures how do you
spell lambda in JavaScript um how do you
spell lambda and JavaScript function um
so you don't you don't get everything
that you get in scheme you know so we
don't have continuations we don't have
tail recursion optimization there's a
lot of stuff that's missing but the
basic notion of lexical scoping is there
and functions as first-class values yes
mention the worst mistake in JavaScript
was the use of global variables for
linkage what's your preferred way of
solving that problem so I said the worst
problem in JavaScript was its use of
global variables for linkage how would I
solve that I'd like to have some
discovery pattern in which each of the
compilation units is initially
completely isolated but is given a
capability which allows it to introduce
itself to some other capability manager
and so on they can make introductions to
each other and form a network yeah
okay so Waldemar is getting after me
about javascript objects are not
strictly hash tables or defective hash
tables I think is maybe more correct in
that there are some names which will
cause collisions and in fact some of the
stuff we came up with in 3.1 is a little
odd and the way it's put together and
that was in order to not worsen that
problem so yeah and it's not perfect
like like so much in this language it's
not perfect yes
you're saying that you think this web
web apps and html5 is going in the wrong
direction
what what what things do you think that
we're doing wrong is it just that we're
not solving that problem
are we actually adding it what do I
think is wrong with with html5 and the
web apps I think it's doing too much you
can look at any individual thing and say
oh that looks nice but they're way too
many of those things I would like to see
a more disciplined approach I'd like to
see a more minimalist approach you know
so if you look at the two proposals that
were competing for the fourth edition
yes 3.1 and es4 I preferred yes 3.1 it
was less ambitious but it was less
likely to cause problems and it was
moving more toward minimalism which i
think is something which is way
underrated particularly in standards my
view of minimalism particularly after
the JSON standard is that the less we
have to agree on in order to work
together the better and so I would like
to look at a way of
re-engineering HTML and all the stuff
that goes around it to be much smaller
and worked better and you know I see
html5 and and the web apps going in the
other direction which is just you know
the the emperor's old clothes approach
we just keep piling more stuff and more
stuff more stuff it just gets too big
it's easy to make things bigger it's
harder to make things better okay yeah
the same almost but yeah so I had to
come about that Jason and JavaScript
have almost the same syntax it's I think
it's just in the two line ending
characters yeah yeah it's because I I
missed that line in the in the standard
was putting it together I when I
specified what the whitespace characters
were carriage return line feed tab in
space and I missed that
what PS and nls were also recognized
with whitespace we tried to fix that in
the ACMA script standard and we couldn't
so we're stuck with that a little bit of
difference as far as I can tell nobody's
ever used PS in LS in this context so
yeah but I've never seen anybody use
them so it hasn't been a problem yet
there's a potential security hazard in
that the two systems view it differently
particularly when but we never
identified an exploit that came from
that and now that there's an explicit
JSON parser built into JavaScript that's
one of the new good parts by the way
that problem goes away completely
yes so the first time I was using JSON
the first column I drowned - like first
object I tried to parse with a JSON
parser in wooden cars and it was because
it's I didn't put quotes on company
names their reason for why that is come
about yeah so why does Jason require
quotes around the property names there
are three of the reasons one of the
reasons is that I wanted to align it
with Python and Python the quotes are
required another reason was it makes the
grammar of the standard much easier to
specify and I like simplicity but the
real reason the true reason is that
JavaScript has a a calcia a stupid
reserved word policy that there are
certain words that you cannot use in the
key position of an object literal and
many of those names are not even used in
the language they're reserved
unnecessary unnecessarily and there's
just no reason for it and at the time
that I put Jason together it wasn't like
I was writing on Java scripts coat-tails
because nobody was using javascript at
that time and everybody hated javascript
so it wasn't like I was basking in
JavaScript glow so in order to not have
quotes but still use it in JavaScript I
was going to have to have a an appendix
of the Jason spec which was going to be
at least as big as all the rest of the
spec describing how the preserved words
worked basically what it said this is
something that's really stupid in
JavaScript you no need to point it out
and at that point I didn't want to make
JavaScript look stupider so I said okay
we'll just quote the keys and then we
don't have to tell anybody about this
shameful thing one bit of good news we
fixed that in the next language
preserved words are now allowed in key
position and also in top position in the
language so that's better
but that took a long time
of one more question yeah all right one
more yes prospects for Eddie
are there any prospects for adding
concurrency to the language it depends
on what you mean by concurrency Brendan
Eich is pretty adamant and I completely
agree with him we should not put threads
in this language I would like to see
some sort of messaging model I don't
know there belongs in this language more
likely than it belongs in some layer
beside the language I would definitely
benefit from that Firefox three one is
going to have support for KPIs that
allows you to create separate threads
that Candice the message
yeah I like that model a lot yeah that's
all I got for you today Thanks that was
an amazing talk Doug thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>