<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Life of a C++ Standard | Coder Coacher - Coaching Coders</title><meta content="Life of a C++ Standard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Life of a C++ Standard</b></h2><h5 class="post__date">2012-06-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/M9RSyJCX5gA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone my name is Dean
I technical solutions engineer in Google
I've been in Google since April last
year I've been using C++ for a longer
time than that i'm also an alternate to
the iso c++ committee for google we have
our representative here lawrence krauss
so he is the man the official
representative to the committee so and
i'm here to talk about changing c++ i
also call this top the life of a c++
standard top if you have any questions
please feel free to ask them any time
interrupt me raise your hand if you're
here if you're in the remote PC just say
something we're gonna try and make this
top a public talk so if you have any
google specific confidential questions
please save them for later when we say
it's it's time to go please keep that in
mind um or not we can we can do this
other ways so I've already given this
talk to Sydney but we're gonna do this
again here for a wider audience you
still know people that are gonna try and
make it in please you know make it
happen now all right here to start so
once again my name is dean i am going to
talk about changing c++ and how it
happens for everyone okay so let's start
with a few acronyms we like acronyms so
I so stands for international standards
organization and we have the JTC 1 SC 22
WG 21 and you read it as iso c++
committee so jdc one stands for joint
technical committee 1 and c 22 is
subcommittee 22 this is for programming
languages and WG 21 stands for working
group
number 21 which is specific to C++ more
acronyms so I'm gonna keep saying these
acronyms later on they mean a few things
so ewg is the evolution working group
I'll get to the definition of these
things there LW g is the library working
group and see GG is the core working
group so clear so far all right okay
it's going to be in part a little era so
okay the evolution working group this is
the group of people that evolve C++ so
evolved meaning add features to the
language support nuke instructs define
the syntax semantics etc and this
working group is headed by BR nuh true
strip the Creator c++ so he's still
involved with the process and there's a
study group within this evolution
working group and the study groups
concentrate on just one area and in this
case we have one for concurrency and
Lauren scroll is part of this study
group as well and we also have others
from other companies working on the same
working group and study group so the
library working group is where changes
to the standard library usually the stl
it's called the standard template
library it this is the group that
discusses what mu language not not
language specific but standard specific
libraries come into the next version of
the language so that's a mouthful this
group talks about libraries that use the
features in c++ the language so there is
one study group right now for networking
another is for file system and i think
there's a new one that's coming up
for synchronous i/o but this is now part
of the networking study group so yes any
changes to the standard library new
algorithms new containers new utilities
etc this group actually deals with that
part of the standard so the core working
group on the other hand is the group of
people that work on the core language
and the wording as far as a standard is
concerned so if there are any issues
with the current standard we raise
things called DRS or defect reports and
the core working group primarily deals
with figuring out whether there's
something wrong in the standard what has
to be changed if there's any wording
enhancements etc so this group is the
group that keeps it together so so to
speak
so the library working group is headed
by alasdair Meredith he's he's uh he's a
developer at Bloomberg and the core
working group is headed by I forget
who's sorry Oh Mike Miller yes so sorry
there is no study group inside the core
working group and these are what you
would the people here are usually
referred to as the language lawyers so
if there's any question about the
language you ask the people in the poor
working group okay so that's that is the
committee three working groups inside
the big working group and yes question
oh right yes so the whole so the the
last meeting that happened in Kona
Hawaii the attendance was 70 people and
not everyone is exclusive to one group
so in the span of five days in the
meeting some people would join the
library working group some people would
join the evolution working group during
the meetings and at any given time the
largest group is almost always the
evolution working group you see like 40
50 people in the same room talking about
the next version of the language then
the library working group is usually
around 52 as much as 20 at any given
time depending on what is being
discussed and five is required for
quorum
core working group is the same 5 to 20
people because 5 is a quorum okay this
answer the question yeah okay thanks so
the process updating a standard so the
standard is basically one document the
document includes the definition of the
constructs that define what the standard
c++ implementation is and the libraries
that should come with this standard
implementation so how do we update this
one document right there are three kinds
of changes right so core language
changes are changes to the existing
standard things like make the sentence
clearer or disambiguate this usage
scenario or say okay I want a new
keyword or we want to change auto to
mean something else it used to mean one
thing and now it use it means something
more relevant or more useful and the
other class of changes is library
changes so let's say you add a new
algorithm and you add a new container
things like that and new features when
you when we talk about new features this
usually encompasses a new keywords or
new behavior to existing keywords so one
example of a new feature would be
I'm liking up c++ 11 new feature auto
right auto so that's a new feature range
based for loops all the cool stuff that
call type if you know what that is yeah
okay so these are the three main classes
of changes right and the process is a
loop a very tight loop spanning multiple
meetings but basically you come up with
a proposal in the form of a paper or
something less formal than that usually
a presentation and then you attend the
committee meeting you attend the
committee meeting the world before you
do that you kind of become a member of
the committee through some way one way
is through the national body so if
you're not in the US or you're not a
Googler you usually ask your national
body representative for iso to say hey I
want to go to the next standard because
here is a proposal for c++ national body
approves that and then you get to the
next meeting as an official
representative of your country the other
way is through kind of the same process
but the company becomes a sensor
representative through the national body
so in our case Google is a member of the
ANSI standards body the American
National Standards Institute and because
Google the corporation is a member and
ansi is a member of ieee so we can then
send representatives for google to the
ansi meeting i sorry and the iso
committee meeting so the google vote is
one felt as a as a company and the ansi
vote is one vote as a country and then
you have a lot of countries that are
part of the eye so that each have one
vote so in the case of a different
country you would have typically
a handful or more companies and
individuals that act as members of that
country and when they vote the country
has to vote the way the membership does
so antsy votes according to how the ANSI
members full and every every country
that's a member of the iso body gets one
vote so anyway that's how you get to the
committee you get to the meeting you you
either you or someone on your behalf
would present your idea so let's say you
don't you have a good idea it doesn't
make it to I mean nobody in your
national body would let you go there or
some other reason but you still want to
send a paper so you can ask someone else
to champion it for you and a good idea
would be to ask an existing member to
co-author a paper and that that member
would then present it to the committee
then the next thing is once you're in
the meeting you defend this idea you go
several iterations of this defending and
revising until you get consensus so the
iso committee works by consensus and
consensus means not majority vote it
means unanimous vote so okay then the
formalization of this process would be
you submit a motion that is entered in
the meetings that is considered a work
item and once that motion is carried by
the body it happens so that's that is
code encode the review process for
getting changes into the document it's
clear so far
okay so a meeting usually happens in a
remote location from any well it depends
right this currently the schedule is
twice a year so if you're going through
several or several meetings to defend
your idea be prepared to make it happen
over at least a couple of years all
right okay so meeting update what
happened in kona so bearing in mind the
process that I just described what
happened was you had a few ideas that
were thrown around and that was step one
or step two actually and so the next
standard is going to be C++ 2017 we are
referring to that as C++ one why of
course after c plus plus 0 X 1 Y is
supposed to mean that hopefully it
happens on the 17 2017 why is kind of a
placeholder just like how X was the
placeholder but we just think c plus
plus 1 Y is cute I don't yes so parallel
development of the next standard after
2017 is also ongoing sorry so we also
are talking about C++ 22 what happened
there was because of the wealth of new
ideas that we want to bring in and the
limited amount of people that can work
on these ideas in the committee what
happens is ok we decide that some of
these are going to make it into 2017 and
those that are big enough that needs a
few more iterations will go into 22
right we also created the network study
group networking study group which will
specialize in the development of an
the specification of the next network
specific libraries that will be included
in the standard so we're thinking about
things like sockets packets messages all
the way up to HTTP FTP all that so
there's a dedicated group of people that
are working on this as part of the
committee and the the networking study
group has a different schedule kind of
so this study group can work faster than
the main committee and the idea is you
can work faster and then when the
meeting comes present the ideas that
have been distilled and discussed then
you know do it concurrently with other
study groups then we decided to continue
work on a file system library file
system library was supposed to be TR to
but then tr2 was killed and now it's
going to be just the file system TR and
demon ghosts the author of boost
filesystem is working on and heading
this study group so sorry this this file
system TR TR s technical report which is
technically not a standard but it's like
a memo to everyone that's implementing
the C++ language and library to say hey
this is what's coming down the pike you
might as well want to implement this
before it becomes part of the standard
so we get feedback from actual usage and
we discussed a few big features C++
modules constraint templates static if
reflection STM and synchronous i/o so
cool parts code uncle cool parts C++
modules this makes so this is not your
grandfather's module this is not Python
modules this is not any other kind of
module
you think might mean a module so c plus
modules are meant to be replacements to
headers and they don't define libraries
or shared objects or dll's know their
replacements for headers down the line
when and most likely when not really if
when C++ modules become part of the
standard only then can we start thinking
about how shared objects and shared
libraries dynamic libraries and things
like that would be defined because
that's easier to define in a world where
we have modules constraint templates if
you heard what happened to concepts yeah
so we're calling it different now sorry
is it just a change of name the answer
to that is no it is a change of mindset
right it used to be a little more
theoretical now it's a lot more
practical so there are a couple of paper
ones there's already one paper that came
out authored by iana soup and the group
from texas A&amp;amp;M and they are talking they
still call it concepts in that paper but
during the meetings we discussed and
it's a and we moved forward and said
instead of calling it concepts let's
talk about constraint templates and the
idea is to enhance the way templates
work to take into consideration the
rules that are defined by concepts
coding code so it's enhancing the way
templates work in a manner that makes it
easier to use let's put it that way
static if on the other hand it came from
Andre Lex and rescue
and the idea is to kill spinner so spin
a is substitution failure is not an
error if you don't know what that is
don't worry we're trying to kill it and
the idea is static if works like if only
statically yes question
so the question is between this and C++
modules is there a movement to move to
go away from reprocess files the answer
is yes we want to so one of the
movements is to limit the dependency on
three processors yes the question is how
would modules work with templates right
yes good question so actually C++
modules are lot smarter than the common
header file and this brings with it
things like templates and how they're
instantiated etcetera etc and modules
are working at the compiler level so it
doesn't change how templates work it
just changes how compilers work right so
none of the rules will change none of
the template rules will change none of
the other things will change but it
would just change whether or not you're
including headers and it may it it may
be as simple as changing hash include
foo to just say import food and the
compiler will make it happen
is sorry it's what it's C++ modules
implementable in GCC is a question I am
not aware of any effort to do that but
this is already in as stated they're
available in a branch in clang and the
edison design group is already so there
are two papers one paper from the editor
on design group and the other
presentation from apple who are working
on this concurrently and this is also
one of the groups there was did we make
this yes there was a study group now
that's four modules part of the
evolution working group so douglas
gregor and devi vanity board i think i
just mangled his name but yeah so
they're working on getting this
clarified and presented in the next
meeting so this is like part 1 part 2 is
reflection we presented a paper on
reflection runtime reflection called
rich pointers and the feedback on that
is to consolidate the proposal to
contain static reflection and to please
not create a new pointer type so yes
we're gonna turn it into a library sorry
a library that has compiler assistance
similar to what initializer lists are
now and yeah a lot more static
information this is a maybe for c++ 2012
Oh 22 sorry
yes I am currently working on making
this happen for the next meeting yes so
Stan software transactional memory so
SDM this is actually according to Intel
going to be available in Hardware soon
and they have already announced plans
for this publicly and it's very
encouraging the idea is very cool so if
you don't know what software
transactional memory is it's really hard
to explain but I try so the idea of not
having explicit locks and defining
transactions in your code that modify
shared state and allowing you to compose
these transactions without having you to
explicitly define your synchronization
assign from saying Oh everything that
happens in this transactional block
happens all or nothing and then there's
a retry mechanism built into it and it's
a it's a is an interesting concept and
there there are a couple of papers out
on this this was presented in the
previous meeting and the consensus has
been it's still a maybe but if we see
solid evidence to suggest that this is
ready for prime time then we really want
this synchronous i/o better futures so
Microsoft has already released
casablanca which is a high-level c++
network library using c++ 11 features
this i am not sure if it is open source
but it is publicly available and it has
enhancements already for the standard
future type they they have a few
enhancements to the standard feature
along with language mechanisms and
guarantees for a synchronous i/o that
implementations can tweak and actually
implement so this is actually very
contentious issue a lot of people have
different ideas on how to do this but
it's agree it's we really want to have
this because every other programming
language already has networking it's
like hey welcome to 2012 you don't have
networking C++ so yes we want this in
2017 but hopefully so this is one of the
things that the networking study group
is working on okay so enough about that
why does google care right so I'll try
to keep this as Google as an agnostic as
possible but yes so Google cares because
we're dependent on C++ it's not a secret
core libraries are implemented in C++
everything almost everything that
matters is built with C++ no other
programming language or environment
comes close to performance profile of c
plus those programs under load I'm not
going to say anymore large percentage of
large percentage of code is written in
C++ so some stats the last number i got
that official is a hundred million lines
i don't know if that includes tests or
other third party code but yeah so
anyway still 100 million so that's a lot
of code okay what do we do and why we
shape the C++ programming language so
that you know we make changes internally
it's not secret we have a team working
on GCC on Klein even though our changes
are public we have a significant
investment in C++ we proposing to do
features we need for our systems yes so
we also contribute standard library
specifications so we have our a ref and
string ref as library proposals oh the
concurrent Q is also being proposed
there is an executor paper out as well
and the number of other things that we
want to take away from our internal
implementation and make them standard so
we don't have to maintain it we also
improve the state of the art with regard
to the networking so outside people that
join Google know how to do network
programming in C++ if we can bring the
networking stuff into the standard then
that means less time to train people
because outside people will be using
network stuff does that make sense yeah
so this is what we do in Google and why
we do it right so what if we don't what
do we don't do this right what if C++
suddenly has a vm oh no what if you can
no longer you know embed assembler in
your C++ what if you know what if C++
changes and it no longer becomes
suitable for google that is a bad bad
situation we don't want to get there so
that's why we participate what if C++
defines bad cymatics for you know what
if edition becomes a lot more costly as
it is now right things like that we make
sure that any changes to the cheapest
cost language introduced by non google
people are actually according to what
Google needs C++ to be as well right and
if we don't participate C++ programmers
learn a kind of C++ that's not
what Google C++ is we already have this
problem and we are addressing it from
two parts one is we're changing the way
we do c++ internally in line with modern
practices and we're also changing C++ so
that the new people that join know that
C++ that we're gonna be doing okay cool
so I've told you what we do is part of
the committee now if you want to get
involved right let's say you have this
brilliant idea what is a brilliant idea
let's say oh I want I want to introduce
and standardize the way you do metal
programming in C++ just for the sake of
argument right you know has anybody
heard of template metaprogramming is
equalized yeah you don't want to do that
too often so what do we do if you want
to get involved right let's say you have
a idea x what do we do well so first we
want to make c++ in google more C++ 11
friendly and yes so if you already have
the feature in C++ 11 like deco type why
else do we not support sorry lambdas
stud future dancing stud thread stud
what else unique pointer so we already
have these things in C++ 11 the
implementations we use already support
these and if you want this in the in the
style guide we need more people to write
the proposals and defend the idea and
actually make it happen internally the
other is we have a call for papers the
c++ committee as
I forget the actual press release but
there is an official press release
that's calling for papers and we want
libraries so more than any new features
we really want to beef up the libraries
that come with C++ so if you've heard
the term batteries included we want to
make that true for C++ as well and we do
not need an open-source implementation
but so let's say you have a library even
if it's an internal Google library and
you want to make it part of the standard
that implementation doesn't have to be
made public but you can make the
interface standard dish if you if you
follow the style of the standard
libraries that's how you make it look
yes right question is isn't the whole
point of boost this that it be the
proving guard proving ground the answer
to that is yes the idea of boost is that
okay you want to make extensions to the
c++ standard library that has worked it
continues to kind of work although there
are now some libraries that going to
boost that kind of have nothing to do
with the standard anymore but yes so
boost still does what its intended to do
but now they're so just to clarify there
is no special blessing for boots from
the C++ committee it just so happens
that the people that started boost were
committee members and their intention
was this but a proposal from the boost
community and a proposal from say
Bloomberg or Google Microsoft insert
name here they are weighted the same
right so it doesn't have to be that if
you want your library to be made part of
the stand
that you have to make it part of booze
that is not a requirement does that
answer a question right yes yes mm-hmm
why are we caught okay so boost has a
lot of stuff already and why are we
calling for more stuff the answer to
that is because not all the stuff in
booth is in the standard nor is anybody
in boost actually pushing for these
libraries to be part of the standard so
we we have seen a few from boost like
the file system library is being made
into the TR and a co a synchronous i/o
is being proposed although we have
raised exception to that some concerns
but we want this because things like I
tu is nice to have in the standard too
we have a lot of other libraries that
are not in boost that would be nice to
see in a standard do like even though we
don't like XML we want an XML parser
anyway in the standard because then
everyone else uses xml what else reg ex
was a good it was a good example it came
from boost but then additions from other
companies changes in the standard made
it better so yeah D is nothing stopping
anyone from using boost right except
there are other libraries that we would
like to see in the standard to that are
not covered by boost that make sense
okay we like boost right except like
things like template metaprogramming
were a little iffy about making part of
the standard so
also boost doesn't have an HTTP library
although it has a co it doesn't have an
HTTP FTP smtp things that matter library
yes right so the question is for
whatever library we want we could just
use it and what is the motivation for
bringing it to the standard right and
the answer to that is if so in the
context of google or in the context of
any company if you do things one way
that is not the standard way and you're
hiring people that know that standard
way then you're going to have to teach
these people the way you do it that is
not standard the two things you can do
you change the way you do it to do it
the standard way or you change the
standard to the way you do it we're
trying both okay that makes sense and
everyone else that's in the committee is
doing the same yes yeah question
they're this kind of method for changing
the language
periodical standard bank push up to
other languages like description
languages like Python Perl reference
implementations that mpls implements in
other ways all right so the question is
why is C++ being changed this way as
opposed to okay so what are what are the
differences between the way C++ is
changed and the way other languages are
changed so for one thing C++ is an iso
standard and because it's an iso
standard we have to do it the way I so
does it that said there's nothing
stopping all any of the implementers
from extending the language having
proprietor extensions nothing stopping
anyone doing that but that is kind of
harmful right it's easy it's harder to
reconcile the differences once a dialect
of the language becomes the de facto
right so we avoid that by saying this
standard C++ if your program is written
according to this standard and you're
using a compiler and implementation that
claims to be standard compliant then it
will work right also there is no one
like implementation that can be called a
reference implementation and this is by
design so nobody can dominate what C++
is this is good for everyone that's
that's in the so you have to remember
their vendors there are consumers and
then there are just casual users right
so and there are also customers people
that are actually paying vendors for
this implementation right so as opposed
to other programming languages where you
had one person implemented and then
suddenly it grew it grew it grew there
yeah it's not much point in having
languages that grew that way to have an
iso standard maybe you'd react my
standards or just an ansi standard
Common Lisp add just a Nancy Lisp and a
different list right there is no one
standard implementation bliss but okay
right that's the same idea so there has
been talk about you know maybe maybe
trying another way but the committee is
like it's been working so far anyway
right so there's no snow there's no big
incentive to change the way things are
being done yet right and because of this
there has been less fragmentation as far
as C++ is concerned that's kind of a
good thing yes oh yes I think adding new
stuff to the standard library is a good
thing but can also be overdone and
abused so for instance the random number
generators and all these profitez
probability distributions that were
added to the new snap I don't think the
majority of C++ programmers care about
those don't probably don't even know
what they are so things like that only
cater to a specific group probably
people in financial domain but they just
increase the volume of the library add
pages to the standard without providing
much benefit to you know the average
program
right so the question is why does the
c++ standard contain a lot of niche
libraries right um yeah and that it
could be abused the process could be
abused by members so this is the reason
why we are calling for a wider pool of
proposals so this observation has been
made in the committee and we are aware
of this observation and when we when we
say average programmer write it it's
really hard to define so if you're in if
you are in the web development community
the average C++ programmer there will be
the program at rh HTTP servers or a
parser for your template language or a
compiler for HP right so in that in that
group the average is different from the
people that create desktop software
where you know the average programmer
for desktop software development firm
would be someone who uses GUI tool kits
and no and then you go to the other
high-performance computing sphere and
you come up with people that do
numerical analysis across clusters of
thousands of computers right so it's
really hard to define what average is
and because of the composition of the
committee you have more people
presenting papers that are relevant to
their niche right you mentioned the
random num number generators in the math
lab reason things like that which may be
only relevant to people that need it but
that doesn't stop the standard from also
providing a network library or in our
case regular expressions right maybe the
numerical guys don't even use regular
expressions but then we still have it in
the standard library so the idea is you
grow the base of the standard library so
that
you don't burden all the C++ programmers
with the choice of using something
that's not standard that might not work
in all the platforms that have C++ so
you problem the base it's there if you
want to use it if you don't use it it's
fine it didn't hurt you that it's there
right so that is the main motivation for
broadening the standard library in in
that sense does that make sense also see
things that are probably more neater
than our more immediate needs bread
bread and you know like having weibull
distribution in the standard library yes
I agree 10 yes probably appreciate about
much more by a lot more C++ programmers
are having
each yes and yes Lawrence
unless somebody shows up with proposals
going to push it through and for that
stuff doing the guy working for the
National Labs whose job is to deal with
these kinds of random number is used
America computations that kind of style
he showed up he had a problem you want
to solve he push the idea through it's
not that there's any particular agenda
set by the committee what comes out of
the standard is the people that show up
at the door with an idea and they're
willing to push it right and this is why
we have a call for papers so in this is
why Google is participating along with
Microsoft and all the other companies
because we realize that hey you know we
have our own needs and if we can if we
can get a random number generator in in
the library well what else can we put
there right so that's the idea people
were presented pushed ideas route and
fingering your presentation you said to
submit a change to a standard you have
to be in this circle right so the people
already in the circle can be selected
for what kind of stuff they want right
so this is a selection problem right so
the and this is true and because because
of these observations we are actually
encouraging more people that are not
part of the circle to reach out to us or
in our case what we're doing right now
is reaching out to these people that are
not part of the circle and saying hey
hey I see you right the ICU library we
really like what you're doing here and
we then the c++ committee would really
appreciate it if we had like a standard
way of dealing with locals and unicode
and all that stuff then we can work with
the ICU guys and say hey okay this is
the way the standard committee works
let's work together right
so this is why in in our case in Google
if you have this idea or because I
primarily work with as as a consumer of
the internal stuff right so but if
you're working on some core piece of
infrastructure code or something that
you think would be nice to have in the
c++ standard this is no holds barred
like anything goes so if you think your
library for converting a number from you
know even to odd some way or whatever I
don't know right say let's say you have
a library that would be nice to have in
the standard then you can reach out yeah
and that is happening in boots as well
that is happening in there is an effort
called a local oh no pic yeah portable
pcl right pickle so portable C++
libraries and the whole idea is to get
everyone including your brother to write
you know proposals for the standard and
the committee members are going to deal
with the bureaucracy and all that
process right yes are we pushing
protocol buffers we have talked about it
and but we're still deciding on whether
using version 1 hour version sorry no so
the motivation for rich pointers is the
reflection in proto buffs if we can get
language features that are required for
proto buffs to work in the standard then
it might just happen that any struck can
be a pro tough right instead of robust
being something special so if example if
you can serialize any struct
into a message then probably us to go
away everything is just a strum right
and if you want cross-language
compatibility it just it's just a matter
of changing your compiler back end so
you parse a strap in C++ and you emit
something that Java can use something
some weird things like that right so
there's there's one way of looking about
so because though the idea of protocols
is good we want we want it available
everywhere but I mean changing the way
you define a struck is none non-starter
so then we can push features that can
make photographs the features of proto
buffs available to all trucks right so
but we want that so that we can get
networking done distributed computing
done and these building blocks will take
time to get in the standard but we
really want to have like the whole stack
part of the standard so that we don't
have to maintain our own right more
questions
yes this stuff is clear enemy of the
aesthetic assertions and see how much
interplay is there right so the question
is what is the interrelation between the
c and c++ standards especially with
regards as an example is that active
yeah right so something funny happened
with C++ 11 because C++ 11 came out with
the memory model and the threading and
concurrency model before she came up
with theirs and there was very close
actually a lot of the team members were
in the c++ meetings and the same right
so the the coordination between the sea
committee and the chief of us committee
is pretty high touch so that's something
happened in that 2011 C++ 2011 and the
sea memory model is consistent with the
C++ my role model and that is just going
to continue to happen moving forward
because it makes sense is all
practically all the vendors for c++ are
also see vendors so it makes sense to
have you know them consistent
okay actually I had a slide for that but
so I think we're early I'm for the whole
thing so if you still want to hang
around I'm I'm gonna be here till
tomorrow or actually friday but yeah we
can talk more about this so thank you
very much for sitting around and see you
in the mailing lists</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>