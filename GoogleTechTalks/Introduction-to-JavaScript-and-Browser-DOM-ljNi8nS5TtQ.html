<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to JavaScript and Browser DOM | Coder Coacher - Coaching Coders</title><meta content="Introduction to JavaScript and Browser DOM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to JavaScript and Browser DOM</b></h2><h5 class="post__date">2010-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ljNi8nS5TtQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome I'm Mishka Avery I don't know if
you guys know me I'm the crazy guy who
does crazy things around here and this
is my boss over here who has managed to
not to fire me hi Brad
okay so we're gonna talk about
JavaScript so I've been doing JavaScript
for actually very little for how long
about a year and a half so I'm pretty
new to JavaScript but I'm been doing it
very intensely I've been working on a
project called angular and I was able to
kind of learn how to push the browser
into new limits etc and so I'm just
going to share some of the know-how I
have by the way this is an introduction
in a sense that I want to show you how
JavaScript works not necessarily what
the syntax of JavaScript is or all the
nuances that I'm sure you know most of
you guys can figure out just time so
we're gonna talk about basic concepts of
JavaScript and mainly the fact that
everything in JavaScript is an object or
an object is really just a hash map
right it just a hash and so all the
primitive types which are objects are a
strings numbers functions no and I won't
know is not only an object and undefined
it's not an object either but all of
these guys act as objects and so what is
true of objects is also true of all
these other classes the second thing is
JavaScript is a functional language and
as such there's a maybe a little bit of
different way of thinking about the
problem then oh oh but nevertheless
because we're coming from an OLE world
we're going to talk we're going to show
you how we can build all systems mainly
classes inheritance and you know the
Standard Oil conventions that we have
and then we're going to talk about a
little bit about the browser so keep in
mind that we're talking about JavaScript
in its purest form not necessarily
JavaScript how it's also tied with the
browser and how it's also tied with the
API that it has I'm only talking about
the language itself I personally am a
big fan of the language itself the api's
are kind of interesting but the browser
is where most people have the kind of
the hatred towards javascript because
all the browser's are different right
but you know keep in mind that the
difference is between the browser's are
now the differences between JavaScript
but rather the differences between
and so we'll talk about that in a bit so
if you are on a on your computer and you
want to follow along you can let's see I
cannot do it here but just about any
webpage you open and you hit inspect
element a little debugger comes along
down here and then you can click on if
you're in Safari or Chrome you can click
on over here and you can type commands
over here so you can say I don't know 1
+ 2 and you know you value it
immediately so as I we go along I
encourage you to go and try these things
on your browser as well okay so let's
start with the basic which is the D we
have an object and so you can really
declare objects in one of two ways
you can say new object and if you're
coming from a Java world how many people
are coming from Java world about
everybody right okay so this should be
very natural to you to do the second one
is kind of a shorthand notation which is
just to Curly's how many people know
json okay so the two Curly's should be
again familiar to you right and so this
is basically how you instantiate an
object now couple of things that you
might not know about javascript first of
all you can there's this type of
operator when you can say and it
actually returns a string so if you say
typeof object one you'll get a string
that says object you can also say object
one instance of object now here's
something interesting notice that in the
first case it's returning a string with
lowercase o in the second case this is
actually a variable which is a global
variable called object that refers to a
constructor and so what you're saying
there is that it was object 1
constructed using the constructor
function object and again the answer is
true and you can try this on your
debugger and you'll see the same thing
happens and all objects have several
special properties that are just always
present and one of these properties is
for example a constructor and that
points to the function which constructed
the object so if you say object dot
constructor you'll get back a function
that was the constructor so in s
the line that says object 1 instance of
object and an object 1 that constructor
are basically the same way of asking the
same question well sort of in this case
it's the same thing in a case where you
would have inheritance and you would
basically have something else like a
vehicle that inherits from object
you know the vehicle that constructor
would point to a vehicle but the if you
say is a vehicle instance of object that
would still say true
so the instance of operator is a little
more intelligent not only does it say
was it constructed it also says well
maybe some of the parent classes could
have been the constructor of it as well
so it kind of works just like you would
expect it in Java does that make sense
by the way stop me as I'm talking about
this thing I love questions if
something's not clear you want more
explanations you know just go ahead yes
go for it everything is the self object
or the type of anything equals off you
know if you say typo for example three
it will come back as a number if you say
type of string strings are kind of weird
they're kind of an object and kind of a
primitive and they'll convert on you
automatically sometimes so they'll come
back as a string but in general for all
the objects that you all the classes
that you declared when you say type off
it will always come back down as an
object that's correct
but if you say instance off you might be
able to get more mileage out of it
that's a very good point and one thing I
didn't mention is there are concepts of
primitive types in JavaScript and the
primitive types are number and boolean
and I think that's it string strange is
kind of a weird one it's kind of a it's
a primitive type but it sometimes
behaves as a object okay so on the
bottom we just have a simple assignment
and I'm just trying to point out that
you can assign in one of two ways you
can either do a literal assignment using
the dot or you can say using the bracket
notation and then the string and the
reason why you want to use the bracket
notation is that what's inside of it
could be a variable right so you could
have a
a variable X equals name and then you
can say object 1 bracket X right and X
evaluates to name and therefore you're
saying object name thank you yes when I
look at this object one instance of it I
just like working my hair is there a
better way to do this even though this
might be legal isn't that you're having
trouble with why you repeat the question
you're most sorry he says he's trying to
rip his hair off when he sees object one
instance of object in other words is
their thing or caste there's some
disease or something like that
no there is no other notation you can
create your own function that does this
right but I mean if you look at other
languages like Java they have the same
exact thing I can Java you would say X
instance of class and it will valu to
either true or false so this is
something that other objects other
languages have as well so it's not
nothing you need to JavaScript ok so
let's talk about the prototype chains
this is kind of where it gets
interesting where all the power of
JavaScript comes from so I can declare a
class sorry I can declare an object
instance called vehicle and I'm going to
give it a a attribute called power
equals true and notice it before I would
just use double curlies to declare it an
object it's also possible that I can
inside of those double curlies enter new
attributes of this object so the vehicle
will automatically have a property
called powered and will be set to true
and I can also create a Volvo and I'll
say that it seats four so now I have two
classes vehicle and Volvo and as you can
see they're completely independent
they're not related in any way right
there's no references from one to the
other and so if I can say if I save all
that seeds I will get four and if I save
all with that power I will get undefined
and that makes sense because you know I
haven't defined the powered on Volvo now
what I can do next is something
interesting I can say Volvo dot
underscore underscore proto underscore
underscore the special property on
another one of those magic properties
and I can send it to vehicle what it is
basically is if you think of a over
object as a hashmap what you're setting
there is the
parent hashmap saying that if i'm going
to look up a property cold power let's
say and if you don't have it set in your
hash map ask your parent maybe he has it
and this can be chained as deep as you
want maybe and so on and so forth right
so now after we set the the property I
can say Volvo that powered and it will
answer back that's true because while
the Volvo doesn't have the powered
property the the vehicle which the Volvo
inherits from does and so now you get a
piggyback true so now I can do something
more interesting and that is I can say
Volvo dot powered equals gasoline and so
I'm overriding the property powered on
Volvo it's not question becomes which
property my overriding is it the
property on Volvo is it the property on
vehicle and the answer to that is it's
on the Volvo itself so what you're doing
is you're covering up the property of
the parent object so all over that
powered returns
gasoline but vehicle that powered still
returns true that was the original
setting that we have over there and we
can also say Volvo that proto that
powered and that comes back as true
because you're saying go to the parent
object which is now vehicle and look at
the powered and that becomes true the
concept of title is kind of a stretch
sorry to repeat the question doesn't
matter they're not of the same type well
there is really no well there are types
but they're very big inside of
JavaScript right and so there are no
constraints and you can really do
anything you want and the interpreter
would be perfectly happy to to do this
so there are no restrictions on types in
JavaScript it's a very weakly typed
language okay does that make sense all
right so let's go make some some more
interesting stuff with functions so just
like you can declare objects you can
declare functions and keep in mind that
what is true of objects is also true of
functions because function is an object
so we can declare a function there's
really two ways to declare a function so
the first case
is what's what's known as the name
function so you say function add it
takes two parameters a comma B and we'll
return simply the sum of a and B and I'm
also going to declare a I can also have
an anonymous function which is the
second line which says function a
returns negative of a and I'm going to
assign it to a variable negate so in the
first case I have a function that has a
name add in the second case I have a
variable negate which is pointing to a
anonymous function turns out that
there's really very few differences if
any between these two the only
difference is that if you say add dot
name it will actually give you the name
of the function whereas if you say
negative it will say I don't know what I
don't have a name it will just have an
empty string but other than that in both
cases the the function pointer which is
which is where the property negative ad
is set is set to the current scope now
in the case over over here it's actually
going to be on a window we'll talk about
that in later on so if you say window
dot add you will get a reference to the
add function if you say then does that
make it you will get a reference to the
negative anyway so functions after you
declare them they can be called so you
can say add 1 comma 2 in parentheses and
that will call the function and will
evaluate it and not only can you call
them in that particular way you can also
call them using apply and call and apply
is basically a kind of a reflective way
of calling the function and we'll talk
about that a little bit in a second so
that it takes the first argument which
is the functions this we'll talk about
in the next slide so I'll just pass in
the null for a second and in the apply
you can pass in an array of arguments
into the function and so again if you
say add that apply and you say array of
1 comma 2 is the same thing as calling
the add function directly and you get 3
the call is the same exact thing except
the arguments are not in an array so you
would say why would I want to do that
you would want to do it because if you
want to call a function reflectively and
you don't know how many arguments it has
ahead of time passing in an array of
arguments allows you to build up any
argue
strings you want okay so going on a type
of ad return is a function you know just
that we would expect add that name
returns ad because that's the name of
the function because you could say x
equals ad right and then you could say X
dot name and will still return ad does
that make sense
okay so you add that length will return
number of arguments that the function
has we already said that negate is
anonymous it doesn't have a name and I'm
just pointing out the type of ad that
apply is also a function so not only are
you declaring function the each function
also gets these two special helper
functions the apply and call for calling
it and I also want to point out that it
also has this special constructor
property which points to a global
constructor function called function and
because it points the global constructor
function that also means you can call
the constructor using the new operator
so if I say new function and I pass in
an argument a and the second argument
I'll pass in a string which is actually
piece of JavaScript code this will
actually instantiate a new function it's
a kind of a convoluted way of doing it
but this is actually perfectly valid as
well so if you wanted to create
functions on a fly you can do that as
well
so does that make sense with functions
any questions on it okay it sounds like
we're doing good okay now one more thing
about functions I get to talk about is
closures and this is kind of something
that is very new to JavaScript I'm sorry
it's a concept that's new if you coming
to JavaScript it's not a concept you're
going to have in let's say Java and
closures is what's really powerful about
JavaScript but it takes a really while
to get used to it and kind of
how to get the most out of them but
anyway so here's an example called
greeter so there's a function called
greeter and it will take a salutation so
let's say the salutation is the word
hello right so it internally we declare
a variable called counter and we declare
a variable called prefix and a prefix is
simply a period plus salutation plus
some extra space on the end and what we
are going to return out of this function
is another function it's kind of getting
confusing a little bit isn't it a
function that returns a function but
bear with me for a second
so the inner function gets returned and
so what we can do on the bottom as you
can see of it over there is we can say
bar greet is equal to greeter hello so
the greet variable now is a function
that we can call and that's actually the
function that's inside of the other
function so now if I say greet world it
will say 1 dot hello world and if I call
the green world again it will say 2 dot
hello world now why is that if you look
at the inner function it increments a
counter that means that the state of
variables is preserved between
invocations right that's why the counter
keeps incrementing if you first of all
if you were trying to do this something
like this in Java the compiler would
force you to declare counter as a final
you guys familiar with what I'm saying
okay some of you are shaking your heads
okay well the force you to declare a
finally that's because the compiler
actually makes a copy of that variable
it's not really a same reference as it
is in JavaScript but in JavaScript is
actually the same reference so the
function that gets returned out from
within the greeter has a reference to a
counter but that's the same reference
that when you instantiate when you
called the greeter function that you had
and so that reference persist for the
duration not just of the function call
but also for subsequent durations
because there's a reference to it and
the reference is the function that you
returned so you can think of it as there
is a state that exists outside of the
function when the function
was declared right and that state is
dark honor not only is this state the
counter but also the prefix variable is
the statement the prefix doesn't change
over time as you invoke it but it also
states and so the bottom function the
greeter function the one that gets
returned allows you to basically say
hello world or hello you know your name
over there or something like that so
what we say is that the inner function
is bound through the closure to counter
into prefix does that kind of make sense
the inner function is actually unnamed
function right the inner online function
is bound to counter and prefix and we
call the variables that we were bound to
closure that I said wrong the first time
signaling says yes okay
we're again new functionary between to
have a separate Chris the question is if
I invoke the greeter again it would have
a separate binding that's true not only
wouldn't have a safer binding but the
function returned from greeter would not
be the same function as the first
invocation so if you did equal equal on
it it will return false
does it have reference to everything in
its scope even if it doesn't directly
reference it that is absolutely the
question sorry the question was does the
inner function have access to everything
even if it doesn't reference it and
that's actually up to the interpreter to
implement I believe the answer is yes
because the closures are really just
hash maps and they're chained and I
believe if you inside of like Firefox
you can Firebug you can actually see
them but I could be wrong on this it
could be very very wrong so don't quote
me on it
but a because you don't actually have a
reference there is the compile the
interpreter could optimize it away and
you would never know because there's no
really no way to get a hold of the
closure object to be able to do
reflection on it
all right somebody else had a question
or was it already answered so sent
question alright good so let's go on ok
so now that we've talked about functions
and objects let's see if we can create a
class and this is something that a lot
of people have trouble with because if
you come from a different language like
for example Java there's only one way to
create a class right there's the class
keyword and you instantiate a class and
there's specific syntax for it and the
class is the first class citizen for the
compiler and that's how it is done in
JavaScript JavaScript is more of a
functional language than an OL language
and so there really is no keywords or
anything that basically allows you to
create a class rather everything is done
through conventions right so the concept
of a class and something that behaves
like a class you can build it in
JavaScript
but it's convention only based which
means if you go to project a versus
project B people might have chosen
different ways of using the conventions
now it sounds like a scary proposition
but it turns out that all the
conventions are internally incompatible
with each other so if you're passing
classes around you can happily pass it
to somebody else it works just like you
would expect and they all have different
advantages and disadvantages which are
is nice to take a take advantage of or
you know use it to play to the strengths
and weaknesses of them and so it's
really up to you how how to use it so
let's say we wanted to create a standard
example which is the circle right so I'm
going to say let's create a circle which
is an object and I'm going to give it a
property called the radius which is
let's say five and then I'm going to
assign a method area to it which is
simply a function that says this star
radius times this does radius right
that's the multiplier of two and times
pi right standard implementation like
nothing surprising there and notice what
you can do is that you can simply just
assign functions into properties and
they just automatically become so so you
can say circle that area and it will
compute the answer which is 78 and some
change and really when we're talking
about all what we care about is the
final syntax of how the user would use
the class right and so the standard
issue is that you have an object and
object has methods and you can invoke
methods on an object like that's really
what is at the heart of it and also
means that they that the data and the
methods travel together so let's have
some fun with this class just to kind of
point out how different the Java Script
is so let's try let's see if we can
decompose the code so I can have a
variable called FN and I can say FN
equals circle that area notice because I
didn't put parentheses on the end I'm
not calling the function I'm simply
getting a reference to the function
right and if I call FN Col I will get
back a n a n not a number now why is
that anybody try to guess go ahead
that's correct that's because this is
undefined what happens is and this is
kind of interesting is that when I say
circle dot area whatever is on the left
hand side of the dot from the function
in this case it's a circle becomes the
functions this does that make sense what
I just said okay so when I called the
area function it so happens that that
was referenced from a circle object and
that circle object becomes the dis of
the function and so when the function
body gets executed this that radius
actually points to the circle and so
circle that radius returns properly five
but when you call the function without
the dot notation you no longer have this
and so if you just say FN and just put
parentheses on it or if you say F and
that call and put parentheses on it
it just blows up now it doesn't just
blow up and this is one of those
horrible things in JavaScript that I
wish they haven't done ah but it's not
that this becomes undefined it's a lot
worse than that if this was undefined it
would at least have some useful
exceptions being thrown but no then this
is one of the grained mistakes of
JavaScript and that is this becomes the
global object and the global object
happens to be the window so if I do
window dot radius equals one and I do
the FN Kol again I will get back to that
one four one five because 1 times 1 is 1
times pi is pi right so this is
absolutely horrible this will bite you
in so many different ways when you
forget to properly this is called
binding if you forget to properly bind
and you automatically default to window
it you will get to these strange
situations where oh if you have a single
instance of an object it happens to work
because you're sharing the global space
but if you have multiple instances all
of a sudden weird things start to happen
and it all comes down to this and this
is one of those horrible things that I
wish they haven't done this is a big
gotcha basically but it turns out there
is this is where the call comes into
play and now notice I can say FN Kol and
I can
passing a circle and what I'm saying now
is execute the function FN which will
circle that area right but call it such
that it's this is the object circle and
now things work as you would expect
yes isn't it sort of just the case that
all functions all - basically kick
variable number of arguments you know to
go yes we can see a functioning case
this method called call and fly and
takes the first parameter is this I'm
using the rest of the primary function
so I mean it looks like what you did was
you just called it with a different
number of arguments that it had an
argument for it okay sort of so you re
familiar with Python I'm going to
rephrase the question
okay okay so the question was it is not
that each function has a hidden first
argument which is basically the
functions this or salt but Python this
is actually explicitly I should have to
say cell for this and the answer that is
not really and let me show you a while
in this particular case which is the
we've basically called AB dot apply and
I explicitly pass the no I said call
this function with no as this no
JavaScript actually calls it with window
so even if you pass and no or undefined
or whatever other thing that doesn't
actually value it into object it will
still call it with window so like in
this case if I call F and Cole and
there's nothing in the arguments all
arguments that are not bound
automatically become undefined so you
would expect that you would have an
undefined for this that's not the case
you will still have window this is one
of those horrible things that done in
JavaScript as a matter of fact you can
make an assumption that if the function
was called without proper binding it
will be a window and it's a very safe
assumption to make these also undefined
yes except for the first argument and
except inside of the special call and
apply which defaults the window okay all
right so now let's build up so this is a
primitive kind of a class and you don't
want to really build classes this way
because every time you make a class
you basically have to assign all of the
the methods to it right but we know that
if you have a class really there's two
pieces to it there's the this state and
there are the methods right and so and
we also know that objects can be chained
together to kind of have certain
properties come from other objects so
wouldn't it be nice if we could simply
create a single object that has all the
methods on it and then we would
instantiate new objects for the
instances and then we would tie those
instances proto to the parent object
which happens to have the methods and
that way we have a nice all going on
right because that makes sense what I
just said okay so as a convention we put
a capital C for a class so here just
another object called circle with a
capital C and I'm going to put a method
on it called area just like I had before
and on the bottom I'm going to say bar
instance and I'm going to create a new
instance radius five and I'm going to
say instance proto and I'm going to
point it to the circle class and now I
can say instance area and the reason
this works is because when the
interpreter tries to look up the area it
looks into the instance first and says I
don't have it so it looks at the
instance proto which is a circle it
finds it now it tries to call it and he
looks at the right hands sort of the
left hand side of the of the dot
notation and says oh I see an instance
over there that becomes the this of the
function and then the function executes
as it normally would
does that make total sense all right so
this is a kind of a standard way of the
way many languages do this is that they
have the concept of a class and they
have a concept of in instance right and
if you're in Java you know the
ass is actually an object as well and so
is the instance it's kind of gets
convoluted a little bit because
everything is an object but really there
is a different thing if it's an instance
a different thing that's a class what
you can do is actually if you declare a
property on a circle with a capital C
it's essentially the same thing as in
Java declaring a static property on a
class right because that's shared across
everybody the only difference is is that
that well no that's the same thing as in
Java if I declare a property you know if
I declare a constant name equals Google
let's say and I say private static
that's the same it would then make code
I can simply just refer to Google and it
will automatically be available and so
it's the same thing here if you say
circle Google it would become
automatically available to you because
you can you just automatically have it
inherited to you that make sense okay so
we can achieve the separation of a class
from the instance using this trick the
only problem is with this so far is the
notation like notation is kind of a pain
that I have to set the proto and there's
really no constructor and all this that
so let's see if we can solve all these
problems one at a time first let's see
if we can do a constructor so let's say
we have a function called circle and
again this function is in no way special
it's it's only convention right and so
it's not like special function like in
Java that the constructors are really
special functions and you can't call
them on not this you can it's just a
function and you know as a notation
we're going to put a capital C from Java
I'm a come from the Java world so I put
capital C meaning that's the class to
say it's a constructor and what we're
going to do inside of that constructor
is we're going to say this that radius
is we're going to set the radius on it
and we're going to say this that area
and I'm going to set the function on it
as well so this constructor will build
the object for me automatically so now I
can do something interesting I can say
bar instance I'm creating an empty
object and I can call the constructor by
saying circle Col I'm going to pass
instance as this to the constructor
right and the second argument is five
which is the radius and so that will
actually construct we will assign the
radius to the instance and also assign
the instance and then I can say instance
that area and we'll compute the answer
but there is a shorter way of doing this
and that is to simply say new circle
five the first two lines are almost with
few little differences identical so any
function in JavaScript can be a
constructor and the new keyword is just
a shorthand to say make a new object and
call the constructor as this parameter
on that object the new keyword has no
other meaning so let's see how they're
different well I can call an instance to
both instance of instance two I can call
the area and will result with the same
answer but if I say instance instance of
circle I'll get a false whereas if I say
instance to instance of circle I'll get
it true the reason why we have this
difference is because remember I said
there is a special property called the
constructor in me the new operator not
only I call instantiate an object and
calls it but it also sets the
constructor property to itself so that
if you say instance two dot constructor
it will point to this circle function
whereas in our case we didn't do that
right and so our instance off doesn't
really work properly and so we can fix
that we can well I don't have it on this
slide but if you would have said
instance that constructor equals circle
then the instance of would properly
behave the way you would expect okay so
this is a pretty good class like we're
getting pretty good in terms of syntax
into what we want from a system you know
it's pretty usable very close to Java
the only feedback I have on this is that
we don't have the separation between a
class and an instance rather the every
time we call the constructor we're
constructing a whole bunch of functions
and those can take up space and means
you can't we pass them around it also
means because the function is inside of
the the other function that function has
closure which means that function has a
reference to radius it could have right
in our case it doesn't but I could have
simply dropped this that radius and just
say radius and it would still work the
same way so while this is definitely one
way of declaring a class it is it has
certain side effects that I'm not really
fond of and so let's see if we can build
an exact class that behaves just like
you would expect it in Java and so for
that what we really want to do is we
want to say function class we want to
instantiate we can instantiate instance
one of that class and then me we want to
compare it with another instance done
the different way so here we instantiate
two by just creating an object we're
assigning the constructor back to the
class on the top and we assign the
instance to proto to the class dot
prototype now what is the prototype
turns out that every function has this
property special property called
prototype and we're going to talk about
it in a second and what the prototype
does is it has basically when you
instantiate the the new class using the
new operator not only do you set its
constructor you also set its underscore
underscore proto to the functions
prototype
which means you are automatically
setting the parent class of that object
parent in terms of in terms of property
inheritance so what I'm trying to show
you is that the instance one new class
is absolutely equivalent to the instance
to a code if you create objects in these
two ways there is no way you can tell
them apart in runtime so the new
operator is equivalent to creating an
object setting the constructor to the
class assigning the proto to the class's
prototype and then calling the
constructor on that class so if I say
instance one or to that weird notation
is instance one or two that constructor
will be two class if I say
is one or two proto it will be class
that prototype and if I say instance of
class will return true so you cannot
tell these two objects apart they're
identical at one time okay so let's talk
about this prototype for a second this
is kind of interesting so what is the
functions prototype do so again let's go
back to function and we declare a class
called circle just like before this time
we all we do is assign the property to
the radius and every function
automatically has a property called
prototype which happens to be an object
and so we can assign other methods or
anything you want into the prototype so
in our case we are assigning our area
function into it when we instantiate the
circle using the new circle five right
the the new operator sets the instance
dot proto underscore underscore proto
underscore underscore to the circle dot
prototype which means it automatically
inherits all of the methods that it had
and so this is the kind of the classical
way of defining in a class in JavaScript
because it provides the separation
between instance data and the functions
the functions are declared in a higher
level of object which gets its
properties automatically inherited does
that make sense or did I confuse myself
no questions all right good
that's usually one of this thing that's
hard to grok but glad that yes so I'm
photo and the prototype it was the
prototype and underscore misko proto
good question
the underscore underscore proto is what
the runtime uses to look at the parent
object in order to resolve a property
the dot prototype is a special property
named on a function and a function only
which is what the new operator uses to
copy onto the underscore
underscore proto underscore underscore
you can think of the prototype as a
template and the proto as the runtime
reference to the parent confuse now
sorry I'm not explaining it right
no it's hidden from you I so it turns
out good question so in practice do
people use the other schematic on proto
sort of it turns out you can read
underscore underscore proto on all
browsers but you can only write to it on
everywhere but ie
so many of the examples I have showed
you will not work on ie but that's okay
because you can always do it through the
new operator so why is it little
confusing is because circle dot
prototype is an object which means
circle dot prototype dot underscore
underscore proto could have other object
hanging as a parent of itself which is
how you would do inheritance in
JavaScript but I'm not going going to go
there because that's even more brain
twisting so every object has underscore
underscore proto but only functions have
prototype which is the template used for
creating a new opera a new operator
hopefully that kind of helps a little
bit all right okay so let's talk about
the function binding problem which is
that we have our this disappear on us
from time to time and this is something
that's really useful to have so because
functions are first class properties
which means you can just you know pass
them around cold etc it makes for a very
different kind of style of programming
you know in Java if you wanted to do a
callback you have to have an interface
and depressor to be implemented and so
you know 50 lines of code later you
finally have yourself a callback in
JavaScript you can just pass a function
somewhere and you're done so let's look
at this example over here so let's see
we have a class called greeter and the
there's a
method called green on that class right
and the Greek takes a mean and suppose
there's another class called server so
I'm in ten shading ingredient also
instantiating class called server
I haven't declared server in this
example because I've kind of ran out of
space but just imagine there is a server
class somewhere and the server class has
a method called get user and here is
something interesting in JavaScript
which we'll talk about in a second later
and that is JavaScript has exactly one
thread and that thread is responsible
not just for running your code but also
for updating the UI for the page which
means that if you're if you wouldn't be
a disciplined JavaScript programmer and
you decided to do something like server
that gate user and a server would take
three seconds to come back with response
your UI would be blocked for three
seconds we don't want that to happen so
it turns out that every single API call
in JavaScript or rather in the browser
right because now we're leaving the
domain of the language and now we're in
the domain of the api's all API is in
the browser are non blocking which means
it is every method call that you call
instantaneously returns but there's some
intrinsic time that it takes to execute
a method right but they all return
immediately
what that means is that it's impossible
to write a piece of code that is that
doesn't return essentially from a user's
point of view immediately now it is
possible to get yourself in an infinite
loop right but short of getting yourself
in an infinite loop you always going to
have to be forced to return immediately
so now if you have the server object
that talks to an external resource like
a server and that takes several seconds
to come back with the result how in the
world do you process the result the way
it's done in JavaScript is that you call
the method and you pass in a function
that will become the callback what it
means is that here is a function that I
want you to call when you are ready with
your data right this is very different
from Java programming where you simply
say call the
in Java you would say you know var name
equals server decayed user and I call it
block for several seconds until the
server will come back with response and
then you continue your execution
so everything in the in the in the Java
world or sort of JavaScript world is
non-blocking so you have to pass in a
function so what we want over here is to
simply say look once the server comes
back with a result why don't you just
greet the user using the greet method
right but do you see a problem with this
the problem is that you pass in the
greet function and that greet function
when it gets cold well no longer have
the property this associated with it so
when the function says this dot
salutation it will get the window dot
salutation alright that's a problem so
what we need to do is we need to do the
second form at the bottom it's a server
that get user and we're passing in a
function that has a name and that
function simply forwards the call onto
the greeter greet name and because the
call is being forwarded
now the greet method has a proper this
because the greeter variable is enclosed
right it's the part of the closure of
the function and so this is it this is
basically what's called binding this to
a function does that make sense why
that's necessary okay so now this is
necessary and this is basically how you
solve this problem but it's a kind of a
pain in the butt to do because you have
to do it everywhere whenever callbacks
are involved so let's see if we can do
something to help help out with this
let's say we declare a function called
bind and that function will take the
functions of this and it will also take
a function and it will return a new
function and when you call that function
it will forward on to the FM function
and it will call it with the function of
this method and oh by the way there is
this hidden
a property called arguments that is your
the arguments of the function that
happened to be cold that you happen to
call and so we're just going to forward
on all the arguments that you called
with the function onto the next one it's
a little mind-bending here but do you
see what it's doing you're saying give
me a function such that if I call this
function with the improper this you will
call it you will forward the call on
with the proper this so then what you
can do is you can simply say server that
get user and you say bind the greeter to
greeter that greet and that will do all
the magic for you so you don't have to
do all the pieces okay I think this is
all pretty much what you have to know
about JavaScript so now we're going to
go and talk a little bit about the
browser yes go back to the last life you
said that when you call a function the
left side of the period is this current
so if you call it greeter greet why it's
not wise at this not the greeter ah
because you're not calling it there you
sorry the question was Thank You Brad
the question was in the left hand side
of the the function that on the left
hand side of the dot becomes the
functions this so why is this necessary
it's necessary because the greeter greet
on this page you are simply getting a
reference to the function you're not
actually calling it there's no
parentheses over there and when that
happens when you don't call it
immediately you are losing the left-hand
side of the of the this so when you call
it later on all you have is a reference
to a function and you no longer have the
context which is the this which belongs
to that function it's a good question
yes this applied was it really necessary
could you have just written FN this dog
argument ah
it's actually necessary so the question
was was apply necessary how would you
call F in this dot and then you have to
call the name of the function you don't
know the name so you would say what
happened this dot FN well but so ok that
requires us to go all at the beginning
so what you're saying on the bottom of
that you see object want that name the
name is the name of the property so now
you're saying if you say F and this dot
F n you're saying take the property FN
of the F and this which is not the same
thing right
right what you want to say is you want
to say F in this bracket if a name but
then when you do that again you lose the
this because you no longer use the
proper notation so unfortunately apply
is necessary oh yes so I wanted to
actually point out one more crazy thing
you can do in JavaScript and that is
because all classes that are built-in
which is the object string array and so
on are built in that they're all so that
they have the proper constructors
everything you can actually extend them
so here's an example let's say I have a
text and the text is hello and I'm going
to say type of text is its string so
therefore text that proto should be
string that prototype and it actually is
it returns true so then I'm going to say
text reverse and that's going to say
well I don't know vs. okay no problem so
I'm going to say strings that prototype
that reverse equals function and I'm
going to declare a reverse function
inside of there and inside of that
function this is the string that I'm
interested in and that means that later
on I can say TxDOT reverse equals you
know turns Britten's back hello and
reversed notation the thing I'm trying
to point out here is that you get you
can extend the internal behavior of
classes you can also override it is this
a good idea probably not because if you
design
to write a reverse function then you use
somebody else's library and they also
decide to use a reverse function you
could have collisions there's a library
over there called prototype I think
there's a JavaScript library called
prototype not to be confused with the
prototype of a function where they
chosen to extend the prototypes of
existing JavaScript classes and that
libraries essentially became the
incompatible library with everything
else and so because of that they they
were the first one so they luckily they
end up having to own this this these
classes everybody else goes out of their
way to make sure they don't touch the
built-in types because just in case you
have a prototype that JavaScript
included you know it will break whatever
you have so not a good idea if you if
you are writing a library horrible idea
if you're writing an end-user
application where you have a full
control of all the this thing all the
classes that are in there this is
probably okay to do so depending is what
your writing might or might not be good
idea I just want to point out basically
that you can extend types as well okay
we're running out of time
iteration you can have an array array is
declared using the square bracket
instead of the curly bracket and if you
think about what an array is it's
essentially essentially an object that
has a special property called length and
has keys which is 0 is car one is book
to his table so the next line makes
total sense if you think about in terms
of objects because you just say oh well
iterate from I equals zero until eyes
less than the special property length
and then when I want to reference the
specific key I simply say log I'm sorry
I should say array of I write I'm
concatenating an array and so the and
other and the result is do you even have
car book and table concatenated together
but you can also do something else
there's another way of doing it eration
and that is you can iterate over the
keys of the object and that is the
second for loop which is you say for I
in array and that basically returns 0 1
2 3 or if it's an object it will return
the keys of the object so in this second
case you're actually returning 0 1 2
and if it's an object we return you know
name greeting bah bah and so on and so
forth so actually I believe we have an
example over here which is that you know
if you have a object called Spanish and
you iterate over with the four key in
Spanish the key becomes the left-hand
side of the the pair right the house and
hello and the Spanish off key becomes
the right-hand side which is the Casa
and hello all
okay I'm going to fly through this goes
right so there is now let's talk about
browsers a bit so a brass yes one thing
worth mentioning is that you have hidden
properties on these objects if you don't
get to the operation
correct there are hidden properties all
over JavaScript and I should have
pointed that out and there's actually
another hidden property called
which is a function called has own
property which you can call to test to
see if the property you happen to get is
real or hidden on more advanced stuff
okay so there's this global object
called window which we talked about
earlier and everything defaults to
window and it turns out that if you
declare a function function agreed just
like this it's always declared inside of
some scope and if it's really declared
as it is over here without a scope it
becomes the window so function green can
be called directly as greed or it can be
called as window degrade but notice that
if inside of the function I create a bar
salutation the window dot salutation
obviously is not it because that's
specific to the function but if I forget
to put the word bar in front of it like
I said message and I was really wanting
to save our equals message you
automatically get the window dot message
set so again it's one of those horrible
things if you forget the keyword var the
verbal becomes global it's the most
horrible thing ever but you got to live
with it so don't forget the var because
the code was kind of work as long as you
have a single instance of something and
if you have two instances and the
obviously the state will clobber each
other so many I'm just kind of pointing
out how the war works and how things are
always declared inside of the scope okay
we talked about the synchronous API a
little bit and I want to you know extra
charter is the typical thing we use
called the XML HTTP request I believe
and so let's say you want to make a
request call the get request to a server
some URL you have to provide back a
function this is the callback function
that gets called a later point in time
we kind of talked about it already but
what I want to point out is the
pseudocode of how the browser actually
works behind the scenes again remember
there is only a single thread executing
everything the nice thing about it is
you don't have to worry about locks you
don't have to worry about somebody else
concurrently modifying something like
you are in control when you're in
control and there's nobody else doing
anything else the way it works inside of
the browser is that there's a queue of
things to do and that queue is usually
ordered by time so everything to do it
has a timestamp when in the future it
has to be done that way you can do
things like animation when you have to
scroll something from left to right and
you have to make sure that every 30
milliseconds something happens you
there's a special method for inserting
stuff into this queue but if a callback
if the browser makes a request to a
server and at some point later the
server comes back with a result the
result gets in queued at the head of the
queue so it gets automatically insert it
and this wait for event is the only
blocking call within the whole browser
what that does is it says why don't we
give something to do if you have
something to do execute it and then
after you execute it update the screen
update maybe the Dom has changed as a
result of the execution and if so go out
redraw the screen and this isn't a tight
loop like this this is when sometimes
you when you get into an infinite loop
inside of the inside of your JavaScript
that's inside of the event portion of it
the browser will say hey your JavaScript
has been running for 20 seconds do you
want to kill it looks like something bad
right because you shouldn't really ever
have to do something for 20 seconds that
means you something broke right because
all the AP eyes are not blocking so I
just want to kind of point out how kind
of the browser works internally and I'm
sorry we're kind of running out of time
I don't mind speaking further let's just
keep going okay if you have to go
somewhere I apologize for going over
time okay so let's talk about the Dom so
now we're kind of leaving the domain of
JavaScript and we're going into the
domain of how the browser's work and so
when people complain about how horrible
javascript is really they're complaining
about how bad the DOM is okay the
JavaScript itself is actually a very
nice language it's very consistent
across browsers it's the Dom that will
kill you so what is a Dom done is the
parsed representation of the HTML in in
the standard document object model which
means you can get a node you can get a
children of its node you can get
attributes and so on and so forth and it
turns out that if you modify that dom
node the browser's will automatically
redraw to update whatever the changes
you've made so let me give you an
example of it so here this piece of code
actually executes so you can say when
does that document that body that gives
you the body element of the DOM and you
can say body that inner HTML and we can
do an assignment bold hello world with
italics and bold and this will actually
set the browser's body tag to that HTML
then you can do something more
interesting and say okay well let's grab
the person so person is really just take
the body and get me the elements by tag
lean I so because there's only one eye I
asked for the first one right so it
gives me an array of all the eyes in the
in the Dom but really I'm interested on
the first one and I can say person dot
text content Mieszko and so now it will
say hello misko right and this is
basically how all of the Ajax
applications work they're modifying the
structure of the Dom on the fly that's
the whole magic now thanks to w3c the
Dom API is
is horrendous to work with it's just bad
it's what they try to do is they try to
design an API that would work for every
single language everything from C to
JavaScript and as a result the API is
really hard to work with so there's lots
of libraries to kind of make this thing
easier and we'll talk about that maybe a
little bit in a second but I might go
over the couple of JavaScript gotchas
and that is the O is by convention only
so people when when they come to
JavaScript and they see o in there and
they say yeah what is this crazy
language you can only do you can declare
a class in three different ways and the
answer is yeah you can declare in two
different ways but that's because it's a
functional language is not a know-all
language and we're just coming at it
from the point of view of oh and we were
so desperate to create classes inside of
our language that that's just kind of
what we get everything defaults to
global window sub watch out if you don't
have a bar you'll have a window
references to functions lose this again
default to window and a browser is
single threaded and all calls have to
return immediately and it's impossible
to wait for something and we kind of all
pointed it out
so browser incompatibilities this is
kind of the stuff that you have to watch
out for so as I said javascript is
remarkably consistent across browsers I
have found very few differences between
the way JavaScript works within all the
browser's string bracket is one of the
things that doesn't work in IE and it's
always IE that's different everybody
else is fine trailing commas for example
in IE that's going to be a array of
three elements with the last one being
know where as everywhere else is just an
element of two elements in I you cannot
set the proto ah and then of course
what's different is all the api's
between the browsers right so the way
you interact with Dom is different
within all the browser's it's not the
fault of language it's the fault of the
api's now DOM and CSS on the other hand
is remarkably inconsistent between
browsers the way you interact with it
what gets rendered when you put the same
set of DOM and CSS elements is going to
be different
ah and so you know there are all kinds
of so for the Dom problem there are lots
of third-party libraries including
Google's closure that deal with in
is between the Dom manipulation and they
do a fairly good job of abstracting it
away the CSS inconsistencies though
there really is no solution or at least
no good solution so if somebody can come
up with some the world would be very
thankful to you and you know the engines
really are the ie engine the WebKit
engine the Firefox and opera engine
turns out the WebKit Firefox and opera
are pretty consistent between them
WebKit is obviously Safari and Chrome
together so they were almost identical
the eye is always the odd one out and
even I five six and seven especially
across CSS selectors is very very
different oh yeah and memory leaks is
one more thing that should be noted
so javascript objects have a separate
memory heap so for those of you who are
from c++ world you should know what
memory heaps are and the memory heap is
matched using a standard issue advanced
these days are pretty immense garbage
collectors that know how to do mark and
sweep and they can take care of circular
references and it's not a problem at all
Dom on the other hand is written in C or
C++ because that's what the browser is
written in it has its separate memory
heap it uses malloc and free to allocate
stuff and it has ref counting internally
that's how the browser knows whether
it's time to go allocate some things if
the reference count goes to zero but the
ref camp is probably does not detect
circular references because the ref card
limit goes to zero and so you have a
memory leak right now this isn't a
problem for you because you're not
developing C code for the browser if
your browser developer then you have
this headache but you don't you write in
JavaScript but you can cause a memory
leak when you create a references
between those two heaps so I can create
a JS object and in the JS object I'm
going to have a property called element
I'm going to point to a document that
body the document that body is actually
an element that is a Dom element and
therefore it came from the C++ heap not
from the JavaScript heap now I can do
the reverse I can say document a body my
attribute I'm going to point it now to J
object and having have yourself a
circular reference between the two heaps
right it's not that the seed developers
made an error is not that the JavaScript
is Anna flawed is that you are now
working with two different kinds of
heaps in here
and there's a lot of different ways to
create a circular reference not just
creating a property also for example
adding a listener or passing a function
because with the function remember it
comes the full closure so not just the
function itself is a reference but also
whatever the function happens to see
that is also reference and so that's how
you create a circular Fresnel this is
normally a problem is normally not a
problem for a normal applications where
you go between pages because as you
leave a page the browser says well I'm
going to blow away everything so every
ref comic must be 0 and so everything is
clean but for Ajax application you never
leave the page and the page is open for
long periods of time and so that's where
the number of leaks can happen okay so
I'm kind of done ah but I'm going to
leave you with couple further reading
John resin is the first link he's pretty
famous is the guy who wrote jQuery
jQuery is a beautiful functional library
for manipulating the Dom superb if you
if you like to look into it he has some
crazy puzzlers in terms of JavaScript
and what they do check it out I
personally like the w3c schools
reference for looking at both the DOM
and JavaScript API people keep telling
me that this JavaScript the good parts
is a really good book I've never read it
but I don't have a reason to believe
that it's not a good book so I recommend
it and there's a couple of readings on
functional programming which is very
very different than oo style programming
which you know separate talk in itself
and then JavaScript libraries so if you
want to manipulate the Dom jQuery and
closure are two wonderful api's the
closure is very eccentric whereas the
closure is very functional centric so
it's a different approach the same
problem there is a if you like
functional API is there's this under
there's this project called
underscore.js which has all kinds of
crazy
punctual like mapreduces etc in
JavaScript very interesting and I like
to think that javis we always try to put
Java in the browser and I think we
actually have a Bronk I think we should
put the JavaScript on a server and so
there's this project called nodejs where
there's JavaScript on a server and you
have the same exact setup that you have
a single thread that services tens of
thousands of connections and because the
service because all the API are
non-blocking
it is impossible for you to block our
normal servers you know have a single
thread for a request and that thread
blocks until you're done with the
request because of the non blocking
nature of the API you can have a single
thread that that can handle tens of
thousands of requests concurrently it's
a very interesting system and it
simplifies a lot of things cuz you don't
have ten blocks you know lots are just
the pain to work with and then of course
there is this CoffeeScript which tries
to basically create a new syntax for
same ideas as JavaScript but it tries to
the better syntax for it and tries to
fix these craziness like you forget to
put a var it becomes global and you have
to bind functions etc it's kind of good
a good places to read to kind of explore
different directions I think that is it
so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>