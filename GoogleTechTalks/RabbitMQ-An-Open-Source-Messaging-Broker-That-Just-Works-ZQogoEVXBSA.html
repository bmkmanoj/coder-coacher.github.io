<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RabbitMQ: An Open Source Messaging Broker That Just Works | Coder Coacher - Coaching Coders</title><meta content="RabbitMQ: An Open Source Messaging Broker That Just Works - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RabbitMQ: An Open Source Messaging Broker That Just Works</b></h2><h5 class="post__date">2008-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZQogoEVXBSA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm a day I'm a technical solutions
engineer at Google and I'm basically
hosting this talk by the wonderful
people at El shift and cohesive ft about
rabbitmq I've known two or three of
these people for a few years now
actually and I thought invite them along
they can talk about that stuff and we
can see how cool it is but after reading
so my name's Alexis Richards and thank
you for coming today I work for a
company called cohesive ft and together
with el shift we've created RabbitMQ and
I can source messaging bro code which I
want to tell you about today the stretch
of the talk will be in three parts first
I will talk about the bat business
background nqp which is a new open
standard for business messaging it's an
Internet standard like HTTP or XMPP then
Matias who's a head of engineering on
the project will talk about the
architecture of RabbitMQ the product and
explain why we chose our line ATP as a
platform to build it on and then at the
end at the end Tony Gomez Jones will
talk about some research of the working
on new stuff to do with web messaging in
general and future directions for a and
QP possibly XMPP and other internet
standards and then we can have some
questions ok so the first point is that
rabbitmq is nothing more than a
messaging broker that's all it does it
takes messages and it sends them on to
other places and it does that in a
pretty smart way nqp is the protocol
that implements there are lots of
plug-ins for other protocols like XMPP
HTTP and stomp and it's completely
language neutral so you can write you
can write to it or read from it from any
language just like if you using TCP or
HTTP and I wanted to introduce messaging
some of you may not have use messaging
very much messaging is a way of dealing
with sending data over the Internet
people use it to scale applications
there are some applications that are
famous for having run into some
scalability issues recently here's one
of them
obviously the markets have been in the
news recently another reason for using
messaging is market data which is a form
of monitoring you might use messaging if
you want to send lots of data to lots of
people at the same time or if you need
something delivered and you don't know
who it's going to be delivered to so
this is a generalization of the notion
in SMTP of sending a message to another
party so it has notions of addressing in
it as well or you might need things done
in a certain order another reason that
people use messaging is it provides
seriality guarantees so you can use it
in transaction systems for guaranteeing
order especially in distributed systems
that can be very important and lately
people have been talking about the cloud
as a way of dealing with distributed
applications that aren't run by you but
are managed elsewhere or distribute it
or federated in some way and messaging
is very important as a fundamental
infrastructure for cloud applications
because you need to monitor them you
need to send data between them you need
to upload applications into the cloud
and get them back from the cloud and
sometimes you need to do that reliably
or transactionally or with the
properties of delivery that that we've
double talked about okay another point
about messaging is it's really
everywhere it doesn't have to be used in
any one way here are some topologies
that you've probably seen before which
are used in messaging scenarios
peer-to-peer is a very common mode where
you've got lots of parties who are of
equal business status talking to each
other in some virtual network
another one is client-server this is
very commonly used for patterns like
what's called store-and-forward where
you have to deliver something to one
other party in a network and some major
party or hub will take responsibility
for that another pattern is for service
architectures what's called a service
bus this is when you purchase the quest
response over an asynchronous backbone
and here are some use cases for
messaging later on people might want to
check this link this is a really nice
turn slide introduction to why you might
need messaging fleshing out some of the
things I've been saying by Bob Pascoe
who founded WebLogic back in the 90s but
here are the main things I've summarized
them already cueing and buffering is
very important monitoring is a very
common use case and load
and scalability so one of the ways that
people already use messaging well the
thing about messaging that's interesting
from our point of view is up until now
it's either been done in ad hoc ways or
it's been done using what's called
messaging middleware which is
third-party software which you buy as a
product either a license or you get as
open-source and then it implements a
proprietary API or an API that offers a
degree of portability but not the level
of interoperability that TCP or HTTP do
and our claim is that this this lock-in
effect has reduced the uptake of
messaging across the world and here's
why typically the more that you have
proprietary api's the more work needs to
be done to actually integrate the
product into the surrounding environment
and the more maintenance work has to be
done in order to keep it going over time
and if there's a cut if there's a single
company involved in this and that can
put great risk on the on the end user
who then develops a dependency on the
company which may not exist in a few
years time and quite often people have
been really hampered by this if at AMQP
got started because a bank JP Morgan
Chase realized that they were losing
money by locking themselves in in this
way to multiple different vendors and
thought well wouldn't it be easier if
messaging was just plug-and-play like
TCP and HTTP and you can see this if you
look at the messaging market the
messaging market for software products
middleware products is IBM sonic TIBCO
and a few others and it's about a
billion dollars which is kind of trivial
compared to companies like you know
Google Yahoo Amazon etc and other
software companies that provide
third-party software it's not a very big
market because the complexity of dealing
with middleware has kept the use cases
fairly narrow and there's lots of other
use cases that just aren't being
addressed and this this we believe is
because of the lack of open standards so
the open standards that we admire and
that JPMorgan looked at when they
decided to run startup a and QP or
things like TCP and SMTP SMTP is clunky
but it does actually work people are
able to send emails and the failure
modes of ones that human beings can deal
with reasonably well one of the problems
of SMTP is spam so that was something
that might be addressed in a future
improved version of messaging HTTP I
don't think I need to talk of the
success of that and TCP well the
interesting thing about TCP is for a
while and with different competing
network protocols in the 80s but once
they things settle down people really
did achieve interoperability and could
actually build new applications that
were relevant to their business on top
of them so that was the hope with AMQP
as well and again because they're not
being provided by a single software
company there is the opportunity for you
to build system that outlast any
particular supplier and have a
marketplace that lasts a long time and
for people to think up new ways of using
the technology that aren't dependent on
out asking the original engineers who
wrote it how to do that so you can sort
of see this if you imagine what would
happen if we never had TCP and instead
how to use a single product from a
single vendor say IBM or Novell or HTTP
if we could only use a single vendors
web services that that would make things
difficult and at the moment you can see
some transition points XMPP is a new
standard it's only been around for about
six seven years and people are still
using AOL people are still using MSN
people are still using Yahoo into the
messaging Google of obviously have gtalk
which is based on XMPP I believe but if
you look at the numbers XMPP is it only
taken ten percent market share across
the world approximately on our fridge I
think an ATP is even nearer so you know
we hope to achieve this benefit with
these standards and if you care about
this kind of thing this is sort of very
simplistic way of looking at application
their protocols sometimes elf or
sometimes l7 depending on which stack
you're talking about essentially we're
talking about something that is as
asynchronous as SMTP
so we took him out messaging but it's
business messaging it's got a degree of
reliability either stability under load
or the failure modes are exposed in the
protocol so that you don't have to deal
with errors by hand as you do with SMTP
or you've got transactionality
properties like rollback for example
which you don't have with them with
other protocols now the point about this
picture is also that there are several
candidates to fill in this question mark
and at the end of this talk
Tony will talk more about research that
we're doing in areas around this that
don't just involve AMQP but other way to
doing reliable messaging with with HTTP
and XMPP but the point is there is a gap
and AMQP is aiming to fill that gap with
these fundamental properties routing
delivery and fidelity the routing is
where do I send messages who do I send
them to delivery is a queueing property
how do they get there how do they get
buffered do they get sent to multiple
consumers at once
or does they get held in place of one
specific committed consumer to take
exclusively and then how do you build
more complex patterns out of that and
fidelity is is the what we think of what
goes in must come out property which
originally delivered by NQ series which
allows you to no transactionally that a
party has received the message that
you've sent and send messages exactly
once
so it's an idempotency property on
delivery and this is the model in a
nutshell again I recommend that you go
to a website and look at the specs for
more details but what point about MPP is
is the three tiers producers and
consumers or clients of the system there
is a logical tier of what are called
exchanges which are routing tables which
deliver the routing property there is a
set of cues which buffer messages on
behalf of consumers and introduce
quality of service properties like
persistence and transactionality and
collectively there's a set of properties
which deliver fidelity across the whole
system but if you assemble an nqp
berroco you just give it simple
instructions as to what exchanges send
messages to which queues should be in it
terminology of NGP pounds to exchanges
and so which word messages they receive
based on routing keys a routing keys
like email addresses or new spirit names
so you can send things like to Mateus
Adele Schiff net or there are pattern
based routing keys as well so I can say
IBM by dot 100 and match on the work by
in the middle of that of that group and
that gives you the publish/subscribe and
messaging properties that you see in the
middle web products but in a
standardized way and you assemble these
into clouds of barcodes which allow
producers and consumers essentially to
communicate in a in a peer-to-peer style
this is business peering rather than p2p
in the technology sense and here's a
quick picture of the underlying
technology the point here is that we
using TCP for the connection at the
moment although in the future
other connections other network
transports will be allowed and channels
represent modes of communication for
messages between producers and consumers
exchanges in queues multiplexed over
this connection and the tears we'll talk
more about that a bit later
whereas nqp come from well there's a
working group which is the standards
body what's interesting about this is
there are actually end users in it who
are guiding the outcome which is unusual
many founders only produced by vendors
which like the web services standards
which possibly has held them back or
made them a little bit too complicated
rabbit website I recommend that you look
at this and some things that people say
about it generally people are happy with
rabbit they find it very easy and quick
to set up a cluster of brokers and
things tend to work really well the
first time lots and lots and lots of
clients in different languages again go
to the website or some of the links that
will give you later to check those out
it's pretty fast we did some testing
with Intel we're able to handle the
whole of the North American options
price feed on a single box that's
disabled opera feed you can read about
that on the Intel low-latency site and
here's a recent comment on Twitter
somebody just trying to test some
performance there
so why would you use rabbit in the end
it's because it actually does some quite
complicated stuff for you that you might
be tempted to write yourself but we
would generally advise you to think
twice before you do do that it does
deliver some pretty significant
clustering and high-availability
properties and it took us quite a long
time to get these right even using
eyeliner OTP which already does that
very well for the for the lower layer it
is a complete conformant Interop
interoperable plantation of the nqp
space it does a lot of different
functions it's free to use open-source
mozilla license
we support it commercially and there are
lots of bundles for different platforms
that you can just get unzipped and up
and running very quickly so it's there
give it a go and let us know who your
problems this is sort of to read later
these are various links the website the
repositories my company cohesive has
built virtual servers that are ready to
run on Amazon flower or on VMware or Xen
I recommend you to try those out this is
a list of links that I collect on
delicious that you might find
interesting there's an IRC channel and
various other references some of the
stuff from later today you should check
out on the elf shift blog as well so
that's it for me it's an open source
project so we'd love people to get
involved what I'm now going to do is
hand over to Matthias we'll talk about
the architecture and the engineering of
it and then Tony to talk about the new
stuff ok thank you by going to the
details of the Robert a new architecture
and the reason for why we choose ADP I
just want to say a few words about along
itself of course I'll what is the rest
of the talk really isn't going to make
all that much sense and how many of you
guys here have actually written a few
lines of a long code okay if you yeah I
hope I wouldn't bore you too much for
the next few minutes but you just be
patient bear with me so on this slide
here I've just put a quick history of
Erlang and there's two main points I
want you to take away from this firstly
that all actually has quite a long
history it's been in development for 20
odd years and significantly
that's all been in a commercial
setting so this is more HD students near
a pet project that they came up with
last month right it was first conceived
by Erickson in the mid 80s when they
were looking for new platforms and
technologies programming languages to
build a telecoms applications and for
the first few years of its life it was
only used in-house by Erickson that had
some advantages in terms of language
development because he basically had the
users of the language sitting right next
to do the developers so there was quite
rapid feedback that allowed them to
refine the language and the platform and
it got open sourced in ninety was it's
yeah 1998 and over the last few years
just the last couple of years actually
there has been a research of interest in
along ITP which can probably ascribe to
to a number of factors to firstly the
rise of new multi-core systems multiple
systems have become really prevalent oh
Allah only just over the last few years
and along being a platform that was
designed to handle concurrency and
parallelism is quite well suited for
that so that's one reason why people can
more interesting on OTP and another
reason is grid computing just a form of
distributed computing another area that
Erlang has been designed to handle
really well and finally internet scale
computing dealing with protocols that
kind of thing alone coming out of the
telecoms world which is a very very
protocol heaviest protocol standards
heavy in fact has been designed to in
your tech health but really well and for
those of you who don't know along yet
thus there's a new book out well but ye
olde now which is near Belleville rate
it's a great introduction to alarm lots
of examples it really gets gets excited
and need to use the language right so
what's it all about at the heart of
along Nia just very very few concepts
really and wrong system is a collection
of communicating processes and process
creation
is extremely fast you create processes
with the scible statement I've got that
they are the sworn statement or to get
back as process identifier which you can
then use to communicate with that
process processes are extremely
lightweight which allows you to have
tens of thousands hundreds of thousands
off them in the typical airline system
no problem with all that's quite typical
process is share absolutely nothing
between each other they have their own
private memory they have their own
garbage collection which gives along
some here soft real-time properties
inside the process what's running is
it's a functional functional code
functional programming code which of you
are familiar programming lots of you
good so I'm going to have to explain
that you get pretty good abstraction
concise code etc significantly though
you also don't have mutable variables
which just takes away one whole area of
concurrent programming that becomes a
headache so how do processes exchange
data then well they communicate with
each other by message passing message
passing in Erlang is asynchronous on the
sending side so we have this process
there on the Left addressing the process
on the right by its president firepit
and sending it a message that's the
sending side asynchronous it sends that
proceeds on the right hand side the
process is sitting in a blocking receive
with an optional time art when a message
arrives it new starts processing
continuous processing what happens when
the thing on the right hand side is
doing something else it's not sitting in
the blocking receive and a message
arrives well in that case the message
gets included so every processor no long
has a little message queue or a large
message queue possibly the messages get
queued up when they arrive on top of
using those basic communication
primitives you can then quite easy build
your more complex communication patterns
such as RPC if multicast etc and indeed
the along library contains libraries API
is for doing exactly that last point
here but the same code you're seeing up
there works just as well in a
distributed along systems to imagine F&amp;amp;G
being on different nodes in a
distributed system same code just works
so far a nice program but along the
language but that's all that's this free
little acronym now OTP that also gets
mentioned as well
OTP stands for the open telecom platform
which is really well it badly named has
absolutely nothing to do with telecom
really well it is it's a collection of
applications libraries and tools all
built on top of our lungs so all using
the do lung core principles and hence
all working really nicely with each
other and it designed to build highly
reliable scalable distributed systems
and you also get a whole collection of
system design principles near patterns
of usage of how you should implement a
system that that is scalable and
reliable
so that's OTP a very important part of
the whole package so why did we choose a
long road EP for rabbitmq well the first
point is that Ben when I looked at the
mqp spec but two years ago I immediately
thought that was a pretty good
architectural fit between what mqp was
trying to achieve and what with all our
OTP actually does so remember this
picture here which Alexis briefly showed
on the slides so we have points on the
left cells on right tcp/ip connections
this notion of channels which is
multiplexing of the logical data and
command streams across a single tcp/ip
connections queues and exchanges etc so
that's the MPP architecture let's just
focus on the server side only for the
rest of this talk and drill down a
little bit so this is just on the
logical MVP architecture side of things
so we've got something to deal with the
whole tcp/ip communication side of
things
we got the multiplex and demultiplexing
to new
get the subdivision of a lot of one
tcp/ip a tcp/ip connection into multiple
channels this layer there is new on the
slide what it deals with is rather than
an MPP rather than sending all commands
kind of atomic it atomically as here
undividable entities across the network
you can actually subdivide them into
something called frames and the reason
you do that is so that when you have
large messages there you have your one
gigabyte message so that you don't clog
up the entire communication channel by
dividing your message into frames these
frames can then be interleaved for
frames for commands on other channels
other channels can continue to do what
while you're sending this really really
large message so that's what that layer
is dealing with and on the right hand
side we got curious exchanges bindings
between them and channels and that's the
RabbitMQ server design so yeah flicking
back and forth you can see are some
differences they are but new broadly
it's a pretty good fit each node on the
slide here corresponds to two things it
corresponds to a module in our code base
and our module in our code base and it
also corresponds to a process for
collection of processes in the running
RabbitMQ system now this is pretty neat
firstly we get very concise code because
of this in nice architectural fit
secondly it makes it really easy to move
between a logical design that you have
for some feature to the implementation
so as despicable as we think of new
ideas as community things of new ideas
new features to implement and rabbitmq
they can immediately move from that
logical design and pinpoint the area in
the code by that featured us live or
should live now how small is to code
really well it is pretty finely the
entire Robin and Q server code base is
just under five thousand lines of
handwritten
well done code and another 1,100 offline
so for the generator code the bulk of
the auto generated code is in their kind
of mqp codec the slot delay of the deals
with you taking five slot that's off the
wire and turning them into mqp data
structures representing fill and gear
such as representing MP commands advisor
versa that's all to generate and in fact
most of the mqp implementation take a
similar approach if they take the
specification next an XML document in
fact and generate a codec from that the
bulk of the handwritten code is not
surprisingly in our human communications
are called advanced Message Queuing
protocol so that's where most of the
code lives and a lot of the logic of
mkp also lives in the channel and Lygia
is alongs distributed database which we
used to store routing information extra
for exchanges bindings and queues so
this this noise fit between logical
architecture and our design is one
reason why our code base is concise
another reason pretty important reason
is that how long has some quite neat
features that help us keep the code as
concise and I just want to show a couple
of them firstly this is an example of
some of you auto-generated code it
doesn't look very well general it could
behind written but yeah this is from the
incoming side of the codec so we take
some offsets of the of the wire and we
want to decode them into analog data
structure representing em capice basic
publish method which is the method we
should publish a message and we are
using something here from Erlang called
binary pattern matching so there this
thing it takes this sequence of octet
and decomposes it so for instance you we
have 2 length prefix strengths in there
8 bits of length information followed by
a string of that length is in
syntaxin arm to support that and you can
probably finger ways if making it even
more concise but it would probably
become unreadable so I think it's neat
just about the balance is just about
right and similarly on the outgoing side
has another feature called finery
comprehensions where you can buy similar
codes to to take into a lot of data
structure and turned into a byte stream
this conventions are high all little
functions
nothing unique to along it all anybody's
done functional programming they'll know
but these is just a little example that
I pulled from our code base where were
using these so this is an unordered
parallel map takes a list of data items
applies a function to each of them in
parallel
Colette's collects the results doesn't
care about the ordinate results arrive
and yeah that's five lines of code so
another reason why before the way to P
would be good choice for implement our
mq is that we get pretty good
performance and more importantly
scalability why is that
well Erlang gives you very fine-grained
concurrency very frank and parallelism
which allows us to exploit parallelism
that's inherent into mqp model in kind
of three different dimensions so firstly
every message going from a producer to
consumer sub travels through the
RabbitMQ broker actually goes through an
eight stage pipeline that eight
processes eight distinct Erlang
processes it involved which you can kind
of see on the on the scripture here kind
of going round this loop yeah which of
course means if you even for just a
single producer and consumer in theory
if you have an eight core machine you
can see an Eightfold speed up if you
keep your pipelines busy and the pipe
ends the stages in the pipelines are
perfectly balanced which of course they
aren't I mean some of these processes do
more work then obviously you won't get
Nate full speed up what you will get
some and another degree of parallelism
we exploit is that between channels so
each channel in mqp
is completely independent from all the
other channels we have
if you processes these free here for e
instantiate it for every single channel
so we get parallelism data and then one
level up the same happens for
connections next thing I want to talk
about is management and tool support
which you get quite a lot with the RTP
platform only way to be worse designed
to keep telecom systems up and running
you probably all 24/7 never go it on and
systems so that's a awful lot of tools
to come with the platform that light if
you poke around in the system figure out
what's going on tweak it tracing
debugging all that kind of stuff so the
main tool for looking at a running
alexis officio like shell you can just
have running system bring up the shell
that connects to the system and enter
ordinary Alang expressions to poke
around and figure out what's going on on
back that's it
so here's an example of using the along
shell to figure out what process is
eating all memory so say we have our
rabbit our rabbit instant and it's
getting fatter and fatter so before be
feeding it too much we want to figure
out what process is responsible for that
so that's an ordinary online expression
here typed in the shell we get well of
all the processes pick up what the
memory consumption is sort the list
traverse the list get the top process
and you can see there's that's the
process identifier there by the way is
just a trouble there and it's very
consumption is right there that doesn't
tell us an awful lot we want to find out
what kind of process is it so we ask the
post for a bit more information I will
probably all the cryptic to you but you
to the trained eye you can discern that
there's an M cubed process here and it
means it's one of our process
representing in nqq and it's actually
for the queue called test queue it
sample step information we can then hit
cook bit more on the system to figure
out why that queue is consuming more
memory another example this time
something there that didn't come out of
the box along with appear for something
to be implemented ourselves a little
management application called rapid
impute CTL here's an example of using
that to set up a road and cure cluster
five commands to take two separate drugs
and Q denotes join them together in a
class those that are born logical
product that's all it takes
left the best fits last one for many
reasons why we choose to use Illinois
defeats because we can actually hide it
you don't need to know anything about a
lung in order to work with RabbitMQ and
why is that well should be pretty
obvious mqp is a protocol the few of
protocol based standards is that when
you are a user of protocol a client you
don't care what your service implemented
there there's a whole bunch of libraries
for most programming languages that you
can use to implement your clients or you
can even you're right
clients yourself a snowball at heart
spec is published you can pull the
generated code from it and so i've got
senior quite a long way in terms of you
just hiding my TP for those you want to
develop with rabbitmq or want to
administer a RabbitMQ system we need a
little bit more to new to make enough to
illinois tph Ness transparent and hide
it a bit so we've packaged rabbit in
cubes it you get debian and RPM packages
you get nice little locked files that
got to get rotated all the kind of stuff
is this happen would expect so just to
sum up my poll talk here we'll head over
to tourney one boils down to is that my
GP has a sweet spot when it comes to
dealing with protocols
alright shouldn't come surprising given
its background and health comes industry
but if you for considering or along for
some of your projects if they have to do
with protocol handling then it's a
pretty good choice right and if that I'm
gonna hand over to Tony to talk about
the future of messaging and our XMPP get
way I'm just going to talk a little bit
about how messaging is in use on the way
it's sort of as I see it and it's a two
back with us I mean you see messaging
queuing in many many applications many
many different environments from email
to the web to RSS and atom feeds instant
messaging of course people even abuse
file systems to to get sort of poor
man's messaging and queuing going on
obviously one of the the other things
that people use as a sequel database I
mean if they don't have a messaging
system in place so everybody's doing it
well nobody's quite got it right or
abstracted out the primitives of
messaging yet so that's what we've been
trying to look at in the AMQP working
group we're trying to take nqp as it
stands which is a client-server protocol
where you have a server and a well-known
location and clients that are anonymous
connecting to it and we're trying to
grow it out so that it's a family of
interacting protocols that can scale up
to the whole internet just like HTTP
does so looking at that and thinking
about the the sort of the essence of
messaging or the essence of these kinds
of distributed system and we've come up
with a few things that we think
characterize messaging now and the first
one is that when you look at internet
scale applications you see that people
are trying consciously or not very hard
to encapsulate state they're trying to
get state into small well known well
named locations and they're trying to
keep the networking fabric from being
stateful we try to keep it as stateless
as possible so messaging being
fundamentally stateless applications
fundamentally state full let's this sort
of fundamental dichotomy or the
fundamental two components in the system
the second thing that we noticed is that
people use messaging to in a lot of
cases arrange for the transfer of
responsibility for a message so if you
look at the delivery of a message you
know I'm sending a message to you I
don't know whether you've got it so what
I need to hear back from you is an
acknowledgement now in a lot of systems
debt acknowledgement is an acceptance of
responsibility so that now if you've
acknowledged that message that means
that I can blame you if you lose it so
there is a kind of a contract and so
we're looking at ways of sub surveying
all of these different systems and use
and and trying to look at the different
sort of contractual arrangements that
they have with each other between the
participants and then it work
the other thing about having a contract
and having some transfer
responsibilities you can then plan for
failure it's going to happen anyway you
might as well get the planning done
upfront so that when the network falls
apart you're not going to go running cry
crying and the responsibility
transferred layer is also where issues
such as quality of service you know
where the messages are stored on disk or
not with this stored in core how many
replicated copies there are that's where
this comes in you know if I get that
acknowledgement from you then that's
your promise to me that you have enough
copies you're just going to coat the
serious people that we see is that
messaging is used to synchronize the
state of these stateful applications
stateless messaging so state is sort of
moved in buckets from one place to the
other by way of messaging if you like
you can think of the messages and flatus
sort of photons you know they're the
carriers of the electric force they're
not themselves electrically charged so
messages carry state but they are
themselves stateful so if you look at a
common sort of application this is a one
sort of generic Lego brick that gets
used hell of a lot and distributed
systems as a shared queue now this is a
place where messages arrive and then
they're stored until some consumer is
ready to accept them so there are two
obvious aspects to a queue there's one
which is to do with the messages when
they're in flight and as the messages
arriving and departing that's the
transfer aspect there's one which is
queue browsing which is looking at the
queue kind of from the side as a whole
and it's sort of an examination of the
messages when they're at rest and
finally you can use queues to do
synchronization you can use
synchronization to do queues it's kind
of a meta level transition thing you can
you can build an infinite Tower of these
things I'll get onto that in a minute
to begin with obviously you know you're
transferring stuff into a queue from the
end so above this line here representing
in an interface a programming interface
you've got messages flying in flight
then they sit down for a while they're
in a known location in a known state and
it's at this point when the
acknowledgement goes back along this
edge that the queue is promising a
certain level of quality of service
level and then finally they get
delivered on to subscribers out the
bottom second aspect of queues of course
is you can look at it as you know this
this picture that we have here you can
retrieve individual cells in the queue
you can update individual cells and some
systems
and finally you can you can remove
entries from the queue and there that
final one is an interesting operation
because by deleting something that you
can see that is taking responsibility
for it I've got my copy now you don't
need to keep yours so transfer of
responsibility happens in that if a
scene there needs to reliably deliver
something to a receiver it can send it
and it can send it so long as it's got a
good name a good identity predicate you
can send it over and over and over again
until it finally does hear back that
acknowledgement so that acknowledgement
constituting of course you know
acceptance of responsibility from the
receiver a second pattern of
responsibility transfer is that that we
want to be able to support as the
delegation of responsibility now
SMTP lets you delegate responsibility in
that you know naively configured smtp
will relay messages now this is a
problem you know spam obviously because
we think it's because it's NTP does the
acceptance of responsibility at the
transport level not the application
level so what we need to do is lift that
up so that the omission of the you know
this smtp 250 replies saying I've
accepted that message it's mine now
needs to be controlled by the
application behind the SMTP interface
it's MTP being you know fairly simple
messaging message transport protocol
doesn't really think too hard before it
decides to accept the message so what we
want to do is instead permit
applications to receive a message
without accepting responsibility then
delegate it on to peps some other
application which then in turn finally
does accept responsibility which will go
all the way back cascading through to
the original sender this is hugely
complicated I suppose in you know
instead of running out of time so just
really quickly sketch the essential
features and if you have a queue and you
want to have a copy of that queue
somewhere else so for instance think
about TCP it's got a queue of bytes it
wants to send and on the receiving side
it's got a queue of bytes that it's
received
but it's arrived or you know messages
arrive from the sender they're put in
the queue and then this from the side
view is used to synchronize the two
views of the data structure this queue
of waiting messages or or bytes in the
case of
CP they delivered on to the ultimate
consumer which because we're lifting
responsibility transfer to the
application level they have to then
individually accept when they do accept
them the from the site browsing
interface is used to delete the messages
or the bytes and the weighted Q on the
other side and then the acknowledgement
can be propagated out to the ultimate
sender so you can use synchronization to
do efficient responsibility transfer
because of course there's no need to
send each of these as a separate message
you can bundle them up collapse them
down into a single as a single message
as TCP does you know it has its sequence
numbers which are effectively
collections of names they represent a
set of messages or set of fights so we
started getting get a feel for where we
want to go is starting to get a feel for
the kinds of patterns that the ideal
messaging protocol should support and
AMQP as it stands gets us partway there
of course it does let you subscribe it
does let you publish messages it has a
simple notion of local transaction for
grouping and for control of quality of
service with this responsibility
transfer idea has sophisticated routing
so you can do pub side wall you can do
direct delivery and of course it has
these cues so that you can buffer
messages when nobody is interested in
receiving them right now so the
challenge is to cleanly integrate the
remaining features this sort of shopping
list of things that we've identified by
looking at the Internet at large we need
this from the side view we need to be
able to look at a queue as a whole
that's not there yet we needed to scale
up which means that we need global
addressing we need the service to be
able to fit irate with each other
cleanly and the manner of XMPP we need a
good public key infrastructure but then
don't we all we need peer-to-peer
protocol support unlike HTTP more like
XMPP where each participant in the
network is speaking the same language
and is able to be a full participant
both you know a server and a client
without having to you know speak
different dialects and we need good
management we need to be able to gather
statistics on the operation of our
network we need to be able to enforce
resource limits so that you know my cell
phone that's speaking this new AMQP
protocol doesn't get overloaded by the
spans that people are sending it
now this table is clearly pretty
complicated now this is really just um
please do have a look at this table in
the slides that we're going to publish
after this because I'm not I don't have
time to go through it right now the
basic idea is that I've been looking at
things that are both protocols there are
some applications in there and there are
even some programming techniques and
they all have aspects of messaging or
queuing that I thought were interesting
so we see right up the top there and in
keeping of course has a lot of these
things already TCP interestingly has
this notion of responsibility transfer I
don't have time really to go through
this XMPP is one of the few that are
federated it's also one of the few that
appear to peer relaying is an
interesting one it's MTP relays they
cause a spam we need our ideal protocol
not relay by default that needs to be a
conscious decision taken by each
application individually and finally
XMPP is the loan system that has a
notion of presence we want to under
grate that into AMQP as well that's
extremely useful I thought it just touch
really quickly on data languages you saw
earlier in Matias as part of the
presentation the binary parsing
capability availing mq peas binary
protocol is reasonably efficient so
reasonably low latency is reasonably
fast it does a good job but it's not
ideal there are a few things that it's
missing so I just thought I'd talk
really quickly about the ideal data
language it should be tight it should an
editor it should have abstract syntax
separate from its concrete syntax so
that you can design concrete syntaxes
for specific situations domain-specific
situations such as you know if you are
needing to debug it then you know Jason
or an XML representation of the abstract
data is a good one if you need him to go
really really fast you can choose a
binary representation that optimizes
just message delivery and escapes out to
a more general representation for other
kinds of commands that need to go across
the same link it should be extensible it
should have a canonical form so that you
can sign it and if it was a widely
supported protocol people are using
already then that's a deal there's
nothing really that fits the bill I seen
that one actually comes pretty close
telephone
protocol buffers is a close second their
protocol
buffers Cheers a lot of similarities as
I'm sure you're aware with I send up one
and there are a few things that's
missing it only has the one concrete
syntax at the moment of having a few
more defined would be great it doesn't
have a meta circular representation
which would be just lovely you know
being able to express the protocol
buffer types there's protocol buffer
messages and it kind of wins hands down
for a sender one in the area of sort of
simplicity and the availability of tools
as end of one compilers can be found
it's a little awkward um and just to
sort of close off um we implemented an
XMPP AMQP gateway and that taught us an
enormous amount about the kinds of
things we might want in the you know
perfect messaging protocol it seems that
they complement each other pretty well
XMPP is internet scale addressing and
Federation of fantastic something that I
am QP is lacking its presence model is
really interesting and for AMQP to have
lifecycle events over the exchanges
queues and bindings that it supports
would be really useful but on the other
side XMPP is liking a sort of a mandated
stored capability at a Lego brick of a
shared queue it doesn't have
programmable routing and filtering it
doesn't have transactions or
responsibility transfer yet all of these
things you could add to XMPP they just
haven't been done yet pub/sub has some
of these s bits but it's missing others
so that's it I mean I guess I've been
talking very quickly about the kinds of
things that we're looking at to try and
take a and QP to the next level and try
and take it out to internet scale all of
the things that you see here are being
worked on in the working group as we
speak or less we hope you to open up the
community anybody who's interested in
this kind of thing please do you know
get in touch with there and keep you
working great we'd love to hear from you
we're actively soliciting extra
involvement and rabbitmq very much the
same we really want people to give us
feedback on what it is that we're doing
obviously we're looking to implement
features to track the amqp 1.0 release
they'll be coming out soon and to make
it run faster you can grab it please do
download it from our website it's
available today people using it in
production try it and let us know how
you
find it oh thanks for lunch hi so I
thought we'd do something interesting
the questions we're all sub alternate
from with the Google moderator webpage
and people actually here so to start
with one question for the web page is
our language better suited to text-based
or binary protocols right I'd say it's
almost certainly better suited to binary
protocols because it has very
sophisticated binary pattern matching
capability it sticks pattern matching is
done along the same lines but with text
of course you know you're suffering from
variable lengths all over the place and
it's regular expression support is
improving it's in the most recent
release it's got Perl compatible regular
expressions but in previous releases it
had a more limited form of regular
expressions sort of basic all critics as
not very strong so binary protocols it's
very strong okay right so maybe maybe
protocol buffers does get to sort of you
know yeah yeah sure okay the the next
one was how many lines of test code and
that's that's an awkward one to answer
because I'm given that it's a
client-server system we have a
knee-length server we also have clients
are in a number of different programming
languages and we use these clients to
exercise the server so we've got some
teams of test Suites in Java with some
yeah I think you'll probably find us
more that's more testing our Java client
than those coding the actual server
partly that's I would like to say this
because we have what's the most of
tesla's machine to do is type up your
tests and Java
sure so one of the selling points you
talked about how this system may do a
Twitter Club
sure um well we've been experimenting a
little bit with this I guess the Lexus
has some things to say as well oh sorry
um to it Twitter right and that was one
of the selling points was was that we
were to talk about Twitter and so the
question was well how how are we going
to talk about Twitter with if you think
about what Twitter is doing it's kind of
like blogging
in a way it's kind of like micro
blogging and so that's what the XMPP
people have been talking about recently
is micro blogging and so with our XMPP
AMQP gateway we've been experimenting in
there in that area as well and keeping a
support for a thing called a topic
exchange and micro blogging is very
similar to publishing messages into a
topic exchange and having them routed
out according to the interest expression
of a queue representing an inducer a
subscriber alexis did you want to say
something so that you we can talk about
this call quite a bit actually and maybe
we talked about it afterwards but um the
first thing that Twitter does is it uses
as far as I understand I could be wrong
about this but my understanding is that
when you you read from Twitter you
perform a select in the background
what's happening with rabbit if you use
rabbit to implement a Twitter like
implementation product or service it's
actually doing the Select at the
filtering stage so every time a message
arrives the routing Keys allow you to
match on different utterances from
different people with different patterns
and then route them to queues where
they're effectively cached pre cached
for the kind of queries that you'd
expect we've experimented by creating
something called rabbit ER which you can
actually use download C on github which
is a fun prototype for seeing how easy
or hard it would be to do Twitter like
behavior using rabbitmq we started from
the belief that it will be possible to
run the whole of Twitter on one RabbitMQ
instance and we think that's probably
true at least as far as message loads go
although it may not be true as far as
HTTP based
read queries goes the the rabbit
implementation takes the XMPP gateway
and puts which gives an XMPP interface
to the NTP server and allows you to
declare statements like follow Jude Jude
being jabber ID so you log in with your
jabber ID because you're coming in
through XMPP normal plain vanilla
instant messaging you're not using PAP
here and you so you can actually make
rabitor your friend on Google Talk for
example just friend it and then when you
talk to the chatroom that represents
your chat with rabitor you can make
statements like follow matias or follow
tony and it will then show you what
they're saying to that chatroom so
what's happening under the hood is that
AMQP and RabbitMQ performing all the
filtering for you and queuing things up
for you to read and if you want them to
be persistent then you can make the
messages persistent etc etc what we'd
like to do next so that that solves the
fundamental if you like client-server
version of a Twitter implementation with
an XMPP front-end but it does not give
you the ability to read things like old
messages using a web page so two things
are happening at the moment number one
this is being added literally as we
speak I spoke to somebody in Seattle
who's done a prototype version of this
in the last two days adding CouchDB as
the inbox for old messages so then the
keys are essentially caching what
CouchDB is storing on disk and secondly
we've written up a design which i would
be very interested in your feedback on
for federating rabitor and actually
decoupling the implementation from the
amq penis of the internal server so that
people can implement a network of
federated market blogging using the
pattern that we've defined but with any
other kind of technology as well
particularly with pet servers in mind so
PAP is the simplification of XX EP 60
and XMPP pub/sub and it's personal event
protocol and it gives you a kind of way
of subscribing to remote utterances
through XMPP so an alternative way of
doing micro blogging is to use Pat
what we've done and I'll give you a URL
if you want afterwards is define a
pattern for federated microblogging that
could either use rabitor in federated
mode or app app server or combination of
the two that hasn't been implemented yet
but I think the design is relatively
robust with respect to future
implementation so we seek feedback on
that our goal then is to show that you
can use networks of messaging systems to
do federated microblogging in other
words things like copying a blog comment
from one blog somewhere location a to a
set of subscribed interested parties in
locations B C and D possibly over multi
heart multiple hops in between and this
allows for the future this would allow
people to declare interest remotely in
what's being said and get efficient
updates and notifications about what
people are saying about specific topics
or in specific places or for all from
specific sources and the door was open
to this kind of solution few years ago
when things like RSS and atom became
standard but it's the belief of I think
many in the community that you need more
technology than those simple protocols
define and that's why there's quite a
lot of interest in things like XMPP also
certain patterns for using HTTP if you
look at what Roy fielding has written
about this it's quite interesting
commenting on the talk by Kalin and I
remember the other guy's name another
one of the XMPP guys at oz calm about
XMPP versus HTTP there's lots of
different approaches to this
microblogging problem that it seems to
be that it's quite interesting to a lot
of people right now so answer the
question thank you
I think in that case that pretty much
concludes this Tech Talk we're all going
to lunch</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>