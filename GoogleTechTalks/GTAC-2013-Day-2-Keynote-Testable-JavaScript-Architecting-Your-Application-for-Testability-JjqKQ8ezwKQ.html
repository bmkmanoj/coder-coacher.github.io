<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2013 Day 2 Keynote: Testable JavaScript - Architecting Your Application for Testability | Coder Coacher - Coaching Coders</title><meta content="GTAC 2013 Day 2 Keynote: Testable JavaScript - Architecting Your Application for Testability - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2013 Day 2 Keynote: Testable JavaScript - Architecting Your Application for Testability</b></h2><h5 class="post__date">2013-04-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JjqKQ8ezwKQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I would like to introduce our first
speaker of the day
Mark Foster is a O'Reilly author
well-respected in the community he's
written a book on testable JavaScript he
was born in SoCo I'm that short term for
Southern California he says he's going
to be lived there till he dies I told
him please don't do that anytime soon
and with that I'm gonna hand it off to
mark and say hey I don't know about
well-respected in the field I don't know
where that came from mother okay so my
name is mark I work at Google I'm an SCT
with Google help I'm actually based in
Irvine yes I have this book testable
JavaScript O'Reilly was supposed to send
out a bunch of copies but they failed so
they said find me afterwards and I'll
collect emails and if you're interested
in the book I can get you a free copy
okay so when we talk about testability
actually before I even jump into this
we've heard a lot about testing and
automating your testing and I think
Simon yesterday said something really
great which was you can't sort of bake
in testing and maintainability and all
this stuff after the fact it needs to be
there from the very beginning otherwise
you're not gonna get the benefits of
automation and easy testing and all this
so it's really important that from the
very beginning your applications don't
just come in at the end and try to test
something really try to be present at
the beginning when these applications
are being developed and architected so
you could have your say about how maybe
they should be built to make your jobs
and our jobs much easier down the line
when you need to test these things okay
so when we talk about testability you
know these are sort of the standard
things that get thrown out we want loose
coupling and tightly focused methods and
all this other good stuff no surprises
and all that and I hear these and I see
these in
a lot of presentations and when I talk
to people and that's great and I don't
think anyone disagrees with any of these
things but rarely do we talk about okay
how specifically do we actually achieve
these things what do we need to do our
applications actually have loose
coupling and tightly focused methods and
all this other good stuff sorry so so
the way we get there is using interfaces
and not implementations and what I mean
by that is and what a lot of this
presentation is about is we talk a lot
there's a lot of talk especially in the
JavaScript community and probably in
Java as well about hiding data you know
I want to make this private I want to
make this protected I'm I'm gonna use
the module pattern or closure to hide
variables or properties and methods from
you and when you start talking about
what you're hiding versus what you're
exposing I think you've sort of already
lost and so what I mean by that is when
you program and you test to implement
two interfaces and not implementations
your life becomes a lot simpler you can
swap implementations very easily you
could work and test and code all in
parallel and we'll see what I mean by
when I say all this stuff and you can
write the test one time hopefully and
then as you implement different
functionality your tests don't have to
change or change very little we have
some bonus slides that have slipped in
here so I'm just going to ignore this so
when I talk about interfaces and
JavaScript the first reaction is well
JavaScript doesn't have interfaces well
it sort of does and we could fake it by
creating an object like this and
defining a bunch of empty functions or
methods and when I do this what I've
done here is essentially is I've created
an interface here's an interface for a
user repository
it provides some all the basic
functionality that I need to get and set
and deal with users everyone's
application most applications have users
you need a way to store them somewhere
somehow and then retrieve them back
later so here we create a simple
interface that you know could get and
set and query and do these other
interesting things to a user repository
and what's great when I have an
interface like this besides the fact
that it's very sort of self documenting
is when I write my tests I write tests
to the interface so here you can see I'm
passing in a repo object I don't care
what this repo object how it's actually
implemented I just care about its
interface the save and the get methods
so I'm gonna write a test here that I'm
gonna save a user and then I'm gonna
call get and get the user back and then
I'm just gonna verify that the user I
saved was actually the user I returned
and this is all via the interface not
via some implementation that is buried
somewhere in the object so now what I
want to actually have an implementation
of that interface in JavaScript it looks
something like this first I have a
constructor function which takes
parameters specific to that
implementation so here I'm using the
readest data store to implement the user
repo interface and it takes some you
know host port options sort of inject
injected as we'll see dependencies into
the constructor and then I you know have
any any I have my Reedus client here and
then later on I set the prototype of
this constructor function to be the
interface itself so here I'm sort of
declaring to the world that I am going
to implement this user repo interface
and then finally on the prototype I then
go ahead and define all the methods that
the interface says I need to define you
know
save query delete you know whatever so
in this way I've sort of created a
JavaScript object that implements my
interface so what we've got here is we
have an object that's acting as an
interface
there's no initialization you could do
on this object this object can only be
used by implementations to actually get
work done the interface itself does
nothing the implementation itself has a
constructor which takes specific
parameters that are injected into it to
actually create the object in the
implementation and then I sort of state
my intention to the world that hey I'm
going to implement this interface by
setting my prototype equal to it and
then finally in the actual
implementation object I then go ahead
and I override all those interface
methods and now I have an actual
implementation of that interface and
what's great here is now when I need to
test this thing I've already got the
tests I just create a new a new object
of this specific implementation of the
user repo interface and now I just call
the test method on it and great I do my
save and I get and hopefully it all
works and now I've just tested my
implementation so time goes on my
application is growing Reedus turns out
oh crap that was a bad idea to use Redis
we actually really need to use Amazon s3
no problem very simple all we need is a
new implementation of our user repo
interface gonna call this one user repo
s3 has a constructor it takes parameters
that are injected into the constructor
for what we need for this specific
implementation I'm going to announce to
the world that I am also going to
implement this user repo interface and
then I'm going to go ahead and you know
actually create the methods that
actually are going to implement that
interface you have to save
whatever hey I've already got the test
for this thing all I need to do is you
know wire up a new Amazon sorry use a
repo s3 object run it through my test
that I've already created and I could
tell easily quickly if this thing
actually works it which brings us to our
first principle of the day which is the
single responsibility principle that
says every interface essentially should
just do one thing and one thing only
which leads us to the second principle
of the day which is no objects should be
forced to depend on methods and
functionality that it doesn't use or
need and we saw that now user repo
interface it just deals what's saving
and getting users there's nothing else
in there there's no you know there's no
extra functionality that I might or
might not need later which finally takes
us to our first pattern which Aldous
called the interface pattern here when
we bring all this stuff together we have
the single responsibility principle we
match sets with debts and what I mean by
that is if you have if your interface
has a way to take something in it should
have a corresponding method to get the
thing back up I see this a lot when
logging there's a method on the logger
to log something and then it goes away
and there's no way to get it back the
only way to get it back later is you
have some other way to maybe query the
database later to actually read the logs
that's sort of dumb you should have
something in the interface if you could
set it you should be able to get it back
you end up with more in more smaller
interfaces versus a couple really big
interfaces that try to do everything you
really want a lot of small focused ones
and then of course we want the interface
interface segregation principle or
interface is just doing one thing one
thing only
not any extra functionality in there and
when you write tests and when you write
your application you just look at the
interface you don't look at the
implementation that interface we saw the
user repo interface it's an object it's
self documenting here all the methods on
it
here's sort of what they the parameters
they take that's the only thing you
should be looking at when you're
programming and when you're testing okay
so we've created a bunch of nice
interfaces maybe got some
implementations of those interfaces now
it's time to actually use this stuff
what we don't want to do is just turn
around and in something that actually
needs our user repo is to call new
because what we've done here is you've
tightly coupled your implementation to
the thing that needs it
so here later on when I switch from
Reedus to s3 I need to go through all my
code and find out all the places where
I've sort of got this user repo Reedus
object that is now very tightly coupled
here and replace it with the s3 object
not only that any parameters that this
thing needed to be created I need to
somehow you know switch to now being the
s3 parameters instead of these so we
don't want to do this this is the sort
of the definition poster child of tight
coupling when you do something like this
so what you do want to do is pass the
dependent in in the constructor just
like we saw for those interfaces earlier
when we were creating implementations
you pass these things into the
constructor and then later on we just
sort of save off a copy of it and then
later on this class will use the
interface methods of this user repo
object and now my user controller
doesn't care doesn't know doesn't want
to know whether it's Reedus its s3 it's
my sequel it's whatever the heck you
decide it should be later because these
things will change and they do this
class does not care it doesn't know it's
just programming to the
which brings us to our next principle
the Liskov substitution principle has a
really big impressive sounding name for
something that's pretty obvious
intuitively which is any object that
implements the same interfaces they can
be swapped out at will so as we saw
earlier I have my user repo s3 I have my
user repo Reedus I could swap them out
to my user controller class my user
controller class has no idea it doesn't
care shouldn't have to know it doesn't
know that's all thanks to the Liskov
substitution principle a great phrase so
when you pass in all your dependents to
a constructor you end up with something
called constructor injection a very
fancy name for just passing in all your
dependents to the constructor and what's
great about constructor injection is it
makes all that objects dependencies very
explicit such that you can't even create
this object until you have all of its
dependencies passed into it you can't
create an object that's sort of half
created and then later on you need to
remember to call like an init method or
set something else up over here you
can't even get this object at all until
you've actually passed in all of its
dependencies in the constructor this
also gives us this nice loose coupling
that everyone agrees is a great idea
that lets us swap out implementations at
runtime or whenever you need to
essentially to get very loose coupling
there are a couple exceptions to this
rule and we're going to talk about those
a little bit runtime dependencies being
the most common when we talk about
constructor injection and we say you
can't create an object until you pass in
all of its dependencies to it the first
thing you would think about is well crap
that doesn't seem to help me now the
object that now I need to know all of
the dependencies of any object I need in
order to create that object and that
sort of puts all the onus on
that doesn't seem to make sense well
you're right you shouldn't create
objects in fact you should very rarely
if ever create any objects during the
normal course of the running of your
application what we want to do here is
we want to create all of our objects
upfront at the very beginning of your
before your application even runs create
all your objects create all your
dependencies and then sort of kick your
application off once you have all of
your dependencies and all the objects
created from this giant object graph so
what we've got here is we really are
break the broke our application into two
distinct phases if you will one is at
the very beginning at a place called
composition route if you want a fancy
phrase for it you create all the objects
your application is going to need for
its entire life you sort of follow this
object graph and you create all these
objects and then you create sort of the
highest level one and then you kick it
off and hit start and then off it goes
so we create all of our objects at the
very beginning and then we in the first
phase and then in Phase two we actually
use the objects and our application runs
and it's all great now in a web
application composition route isn't
necessarily when the entire application
starts up say with the web server or
something like that there's also the
request cycle for instance a user object
you don't know who the user is
specifically until the request cycle
starts and you've sort of retrieved your
session like oh that's the users mark
I'm gonna create the user object mark
that represents him so it's okay for
your composition route to be you know
scoped at a request cycle as well as
from the very first time your
application starts up okay great so we
want to create all these objects at the
very beginning well then what creates
all the objects well there's lots of
different dependency injectors or
inversion of control contained
whatever you like calling them those are
the things that are actually create your
objects for you and you could use sort
of one off-the-shelf certainly there's
many for Java there's a lot for
JavaScript as well it turns out Cujo
Cujo Jas provides wired aijs is a really
popular one do-it-yourself that's a d/dy
I dependency injection you could also do
it yourself and the idea is at the very
beginning of your application at the
composition route whether that's during
the request cycle or when your
application first starts up or when you
first push all your client-side
JavaScript to your browser you sort of
say you know this object depends on
these three these three objects depend
on these eight these eight depending on
these 24 finally at the very bottom you
have a set of objects that don't depend
on anything else so you create those
first you walk your way up your sort of
dependency graph till you get to the
very top and then you've created
everything and that's what these
dependency injection or inversion of
control containers are really good at
walking that object graph to create all
your objects for you angularjs
open source Google project does
dependency injection as well so there's
you have lots of you have lots of
options here of what you want to use
okay
so you've created these sort of
self-contained objects and they just do
one thing and they do one thing only and
that's great and then the question is
well about this other stuff that I might
want to do I might want to do logging I
might want to do auditing caching all
these sort of cross-cutting concerns and
the the question is how do we sort of
weave these cross-cutting concerns into
the fabric of our application here we
don't we know we don't want to pollute
our interfaces with logging or with any
of this other stuff because you might
need it you might not need it not all
classes might want log
so how do we how do we bring all this
stuff together well let's first look at
what we don't want to do and what we
don't want to do is what we saw earlier
which is just sort of you know create
new versions of this stuff within a
specific implementation so within my
user repo Reedus implementation I don't
want to just turn around and call you
know new logger or new profiler again
this tightly couples us to those
implementations and it makes things a
lot more difficult to test when you have
this stuff sort of buried within the
object itself a lot harder to mock out
instead this stuff out so you say okay
well I want to pass some stuff in maybe
to the implementation and this is on the
right track in that we're using
constructor injection but there are a
lot of problems with this is Pro with
this approach as well
for one the single responsibility
principle here is now we have a specific
implementation user repo Redis is now
sort of baked in logging and profiling
and when I want to use the user repo
Reedus object and maybe I don't want
profiling I don't want logging I'm sort
of stuck here so what I mean by that
specifically is you'll end up with code
something like this in your save method
that's implementing the save interface
method you sort of put all this extra
junk in here that not all users of this
class might need here we've got logging
we have profiling and then in the middle
of all that we're actually going to
reach out to reduce to save the user and
then we're going to do some more logging
and more profiling and the problem here
is in our next implementation user repo
s3 I've got to remember if I want login
profiling I've got to pull all this code
out of there and I got to put it over
here and as I said earlier not everybody
you might not want logging and profiling
all the time whenever you're using this
object so the solution to this problem
is like the solution to almost all
problems
is we want to keep the different
functionality separate we want to
maintain the single responsibility
principle we want to keep we don't want
to put any extra functionality into the
our implementation here that some
classes might not need so what we want
to do is create an interface so here is
a logger interface you see it has just
two methods here a log method and then
again a way to get the log back out once
you've put the log in and here's a
simple implementation of that interface
here's a implementation that's going to
log to a file you can imagine one that
would log to a database or log to a
remote remote logging somewhere else I
have my my implementation specific
constructor that's going to take a file
here I'm announcing to the world that I
am going to implement the logger
interface and then I go ahead and blow
through all the interface methods and
implement them for this specific
implementation so quick aside here one
thing that makes JavaScript really nice
is we could sort of do whatever we want
with the objects a lot of sort of
built-in reflection here's just a quick
method called mixin and what this method
is going to do and we'll see how we use
it on the next slide is we're gonna sort
of take all the methods from a base
class and automatically and then it sort
of from the base and we're gonna
automatically add them to a different
object so we're just going to blow
through all the properties in our base
object and then if we find one that's a
method and it doesn't already exist in
the in our current implementation we're
just going to stick it on the current
the current object and we'll see how we
use this in a second well let's just
look at how we use this thing actually
okay so let's get back to our initial
problem here which is we want to sort of
have logging with our
with our user repo so here's how we do
it we create something called the
decorator and here is a specific
implementation of one a user repo logger
and the idea of the decorator here is it
is going to also implement the user repo
interface but it's going to have logging
baked into it so again here I have a
constructor which is being injected with
its dependencies in this case it has a
dependency of another user repo object
we don't care which one because it's
just gonna we're just programming to the
interface and a logger object again we
don't care which one cuz we're just
going to deal with the interface now
we're gonna mix in all of the original
repos original methods into this class
and this is really just sort of a helper
which lets me not have to define all of
the save they get the query user the
delete user methods if I don't declare
any of those off our prototype then they
will just fall back to the sort of the
inner repos version of those methods and
then finally I actually am going to
implement the save method here and what
I'm going to do here is I'm actually
gonna take the logger and I'm gonna do
my logging and then I'm gonna sort of
hand off responsibility for the actual
repo saving to whatever repo was passed
in to me and so here what I've done is
I've sort of intercepted or decorated
the save method with logging and what's
great here is the inner repo whichever
one I happen to pass in use a repo
reduce user repo s3 or whatever has no
idea that logging is happening and the
logging has you know no idea about the
user repo they're not mixed in any way
only through this decorator class so
when I want to create one of these
things at the very beginning of my
application using my dependency injector
my container I create whichever
implementation of user repo I want here
in this case the read this one I create
whichever implement
of the logging I want here in this case
the file1 and now I've got another user
repo that thanks to our good friend the
Liskov substitution principle it says I
can now use this reap user repo anywhere
I was using a user repo before and now I
get logging for free without having to
you know mess up my original user repo
Reedus or s3 implementations okay so we
talked about proof we wanted to do
profiling to remember that so let's
again go through this same kind of deal
here I'm gonna create a profile
interface it does a start and a stop and
then of course it has a way to get it
back out to once we've stuck it in
here's a very simple implementation of
that interface here's my constructor
function which has implementation
specific parameters none in this case
announcing to the world that I am going
to implement the profile interface and
then finally I'm going to go ahead and
actually implement all of those methods
there here's just start/stop one can
imagine of course other profiling what
if you wanted this base profiling what
about you wanted CPU profiling no
problem just you know create another
implementation of the profiler interface
and you've got this so again I'm going
to create another decorator for this one
I'm gonna call it user repo profiler
this one and its constructor function
takes again an inner repo it takes a
profiler interface I'm going to mix in
everything from the user repo into this
current object again this is just sort
of like a convenience so I don't so this
object doesn't have to implement all of
the interface methods if it doesn't want
to and then finally I'm going to sort of
intercept or decorate the save method of
the user repo interface and in this case
I'm going to do sort of start my
profiler then I'm going to delegate to
the inner repo to do any actual saving
and then
going to stop the profiler so now I have
a sort of a profiling user repo and then
finally we're gonna put the whole thing
together here to get a all-seeing
all-knowing all doing logging and
profiling user repo user repo object so
first I'm gonna create a specific
implementation here I'm gonna use the
Reedus one and for grins I'm gonna use
the time implementation for profiler I'm
gonna use the logger implement the file
implementation for logger and now I'm
gonna sort of create my here's my
profiling user repo object and then
here's my logging profiling use a repo
object because I've been programming two
interfaces I could and because of our
good friend the Liskov substitution
principle I can use this user repo prof
object anywhere I can use a user repo
object since it implements that
interface so I'm going to use that to
pass into the user repo logger object
and now at the very end here I have a
user repo object that can be used
anywhere a UA user repo object could be
used but this one has logging and
profiling built into it and at no point
have I sort of violated any of our
principles of keeping things separate
and what's great is I could test the
heck out of my my logger implementation
I could test the heck out of the
profiler implementation and I don't need
to mix them I don't need to have that
kind of testing also when I'm just
testing the user repo interface as well
okay
so just a quick quick note on Tess here
there's a couple ways to test decorators
one is you sort of mock out the the sort
of the part that's doing the decorating
then you just sort of call your save
method on that object and then you
verify your your mock out object the
other way is to sort of create the whole
thing and a lot and sort of mock out
everything and so this is more like if
you don't trust the fact that when you
put all this stuff together it's
actually going to work like you think it
is you could you could do tests like
that the previous way is you've sort of
tested the two and I all the interfaces
in isolation and you could just run them
through your normal user repo tests that
we saw earlier that save that's just you
know saving to the you know that's just
using the interface methods so they're
really easy to test
and these decorators are obviously are
very easy to mock out as well
which brings us to our second pattern
which is the decorator pattern which is
what we just saw and the whole game here
is again everything we just saw you
create a constructor that sort of takes
an inner version of the interface and
any other objects it needs that it's
going to decorate the interface with
then you want to sort of mix in the
inner objects methods into the interior
decorator objects so you don't have to
implement all the interface methods if
you don't want to and then finally you
go ahead and actually implement the
interface methods that you want using
using the decorator using the other
object you passed in the log or the
profiler to actually do the work that
you want the decorator today and I say
in there optionally because it turns out
you don't actually need to call the
inner interface if for some reason your
decorator
besides it doesn't need to and the sort
of the canonical example here is caching
you don't want to build caching directly
into your implementations you could
write a caching decorator that in the
save method or in in the get method it
would look to see hey is this object
already in my cache and I'm keeping
locally in the decorator if so I don't
need to delegate at all to the inner
repo I could just return the object I've
already got okay last bit I'm gonna talk
about here is what about the runtime
dependencies and so sort of the example
here is I've got a dating site awesome
website people come they try to find
their matches for who they want to go
out with and there's a couple different
criteria they could use to determine
what they want to use to find their
matches they can use do we share the
same likes do we like to do the same
activities distance how far away are
they from me or anything else you could
think of and the idea here is that when
the user comes to the site they sort of
have a pull down and it's up to them to
select how they want to find their
matches one of those three things well
the thing is you don't know what they're
gonna pick right so you can't sort of
create a user controller object or
something at the beginning with one of
these fine match algorithms because it's
up to the user to pick it and you don't
know what it's going to be so the first
step here of course is to create an
interface called find matches this is
given a user ID it's going to return a
set of matches for them and then we're
going to go ahead and create some
implementations of this interface again
here's that F is just short for a
function because there wasn't enough
room on the slide so I have a
constructor function here here's one for
distance here I'm going to say I'm going
to implement the find matches interface
and then I have some other objects here
I've got one for activities I've got one
it's gonna find your closest matches for
likes and whatnot so here's here's the
crux of the problem here is in my user
controller I don't know what you're
gonna pick so I don't know which find
match sort of implementation to inject
here so I could inject all three that's
sort of that's clunky doesn't smell
right what about I come up with a fourth
you know a fourth one later then I got a
I got I'd make sure to add it there what
if there are other things that need sort
of a dynamically injected find matches
so the solution here is an abstract
Factory so I don't want to get too
bogged down in the terminology abstract
Factory that that sounds crazy that
sounds like something you need in Java
not something you need in JavaScript
isn't javascript supposed to free us
from all of this well when I say
abstract Factory what I what I all I'm
talking about here is it's an object
that's going to take a runtime value and
return a dependency that's all I mean
here so to create one of these abstract
factories just like everything else I'm
gonna have an interface I'm gonna call
this one find match factory it just has
one method get match implementation and
you can see it takes a type and this
type say is just a string likes or
activities or distance and it's going to
return to me the implementation I need
the find match implementation I need to
actually find the matches that the user
has requested so here's a quick
implementation of this interface again I
have my constructor in this case it's
going to take a user repo object I have
a I'm here on broadcasting to the world
that I am going to implement the find
match factory interface and then here is
my get match implementation actual
implementation of it and you can see
there's something slightly strange here
what should make you sort of recoil is
that there's news in here whenever you
see new and
you should you should get a little bit
scared but it turns out for factories
it's okay
it's okay to call new here and this is
the whole point of this object you don't
have to do it this way you could also
pass these sort of three or more
implementations in via the constructor
and sort of up to you how you want to do
it but the idea here is I'm gonna take a
type-a runtime value and I'm gonna
return an actual implementation so in
this case I'm gonna switch on the type
and depending on which one they selected
I will return you the correct
implementation for that okay so what
happens here is in my user controller
what I'm injecting into its constructor
is the abstract Factory that's the whole
game here so here I'm injecting in the
abstract Factory I save it off for later
and then so here's the constructor
here's I'm saying I am implementing the
controller interface and then in this
method here where that finally boils
down to when the user is actually
selected their type I know what type
they selected I know what the user is
now I reach out to my factory that was
injected to me and I say uh-huh okay I
finally got the type give me the object
that matches this type it does and then
now I could call the interface method
matches if you remember from that from
the fine match interface to actually get
the matches that the user requested okay
I'll get it by distance or likes or
activities or whatever they want what's
great about abstract factories is
they're really easy to test you know all
they're not doing very much all right
they're just translating from a type to
an object so a dead simple test is just
to iterate over all the known types and
make sure you got the object back that
you expected
and they're really easy to mock out so
when we want to test this the user
controller mocking out an abstract
Factory is is really simple so here's a
here's an implementation of our abstract
Factory for test this is it has a
specific constructor that takes a mocked
out match version and what the expected
type was I say I'm going to implement
this interface and then they get
matching implementation just sort of
returns the mock plus it checks to make
sure that the type it got passed was
what was actually expected and then you
can go ahead and in inject this mocked
out or test version of the abstract
factory into your user controller which
brings us to our final pattern of the
day which is the abstract factory
pattern and the game here is as we just
discussed I'm gonna take a runtime value
and I'm gonna return to you an actual
object for that runtime value the
factory implementation itself is created
a composition route along with all the
other objects and you inject the factory
instead of injecting you know the actual
you know fine matches object into the
constructor of any object that needs to
deal with this runtime value and then
finally you use the factory at the
moment when you actually need it to get
the actual dependency that you needed
okay so sort of tie a bow on all this
what we really like to see when we're
talking about testable JavaScript or
really testable probably anything is we
like composition inheritance is a little
more stifling composition allows us to
really easy mix and match pieces that we
need without sort of sullying our
implementation objects or our interfaces
we want a program and test to those
interfaces again we talked about I
talked about the very beginning you know
hiding data and making stuff private
putting like an underscore there to make
sure people know that hey this is
private don't touch this using
interfaces it's just here's the
interface that's what you got that's it
you don't have to worry about hiding as
much again we want to create lots of
small interfaces because we've seen how
easy it is to mix and match them
together and it's significantly easier
to test small interfaces and to mock out
small interfaces and it is big hairy
complex ones we're gonna decorate an
intercept for those cross-cutting
concerns we're gonna construct or inject
all of our dependencies even the runtime
ones using abstract factories thing and
here's our abstract factories for the
runtime dependencies and finally there's
really unfortunately only one way to
actually ensure testability of your code
and that is to write the test first
because then you're guaranteed to have
the tests up front but if you follow you
know all these patterns and these
principles I showed you maybe you could
try to get away without writing the test
first but why would you want to do that
that's all I got
thank you very much
yeah Thank You mark that was fantastic
and thank you for bringing back my
childhood fears with the Cujo Jaso for
those of you that don't know Cujo
it was his giant German Shepherd that's
rabid attacks his family they're stuck
in a car everybody dies it's a terrible
movie so years of Beethoven and Disney
has fixed this but we're gonna have to
watch the back tonight sorry to take you
back down that road okay if you have
questions we have two mics in the aisle
like we did yesterday so I see one live
question when you ask your question
state your name your company and your
question or you can delete other parts
if you don't really want to state your
name so with that go ahead please my
name is Alec Monroe I work at arc 90 I
noticed one piece that wasn't injectable
the the Rita's client or the s3 client
wouldn't that become an issue when you
were trying to do something live and you
didn't want to actually are trying to
test something and you didn't want to
actually have to be talking to s3 so
yeah that's a good point because when I
was looking at the slides I was like you
know you could just inject the Reedus
object itself into the ER user Reedus
repo but sort of the idea of the user
Reedus repo is it's talking to Reedus so
that's sort of a you know like a piece
of that object that can't really be
abstracted away but using you know the
programming to the interface it's really
easy just to create a mock so if you
don't really want to talk to Reedus it's
really easy just to create a mocked out
version of user repo that you know it's
just checking to making sure like did I
get this was that what I expected and
whatnot yeah yeah you just put it in
different repo since you're just
programming to the interface it doesn't
matter what the implementation actually
is with that thank you if you have other
questions I'm sure you'll be around mark
yeah I'll be around this is this is a
good question on the dory - yeah it's a
fantastic question it says it's about
you know performance concerns if you
have 10 seconds 10 seconds yeah 10 SEC's
so the idea is you're gonna so the
question is well if you create all your
objects upfront isn't
performance problem or something like
that it turns out it's really not since
you're going to be creating all these
objects anyway during the course of your
application it's better to create them
upfront and then you have less of a
performance issue throughout the rest of
your application hmm good answer all
right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>