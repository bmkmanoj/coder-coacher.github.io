<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2008: Automated Model-Based Testing of Web Applications | Coder Coacher - Coaching Coders</title><meta content="GTAC 2008: Automated Model-Based Testing of Web Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2008: Automated Model-Based Testing of Web Applications</b></h2><h5 class="post__date">2008-11-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6LdsIVvxISU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're gonna talk about automated model
base
stinger web applications and the title
of the stock is slightly misleading
because I'm going to talk a little bit
in the beginning about testing
event-driven software and try to
motivate the problem and then I'm going
to tell you what we have done in terms
of testing GUI based applications so we
have had lots of success in model-based
testing of GUI based applications and
then we will show you what we have done
with web applications so the work on GUI
based testing is kind of a sneak preview
of what we are going to do in the future
for web applications okay all right so
let's start with basic event-driven
systems or event-driven software and
this is my abstract view of most
event-driven applications you have these
event handlers that are coded and
they're sitting in this cloud here and
when the software starts executing each
of these event handlers starts getting
registered with a dispatcher and each
event handler tells the dispatcher that
I can handle a particular type of event
or a particular class of events in a
certain context and so each of them gets
registered in this way and then the
software goes into this state which I am
going to for the sake of simplicity just
call s naught and now s naught is the
collective state of all these event
handlers and other things in the
software that are important and the
software is now in this state where it's
waiting for events to come into the
system so events start and E one comes
in the system
the dispatcher knows that e capital e
one can handle this type of event and it
triggers this event handler the event
handle handles the event and so things
start moving the software state changes
to s1 all right it's moved from s naught
to s 1 now if a small e one comes again
to the system
it's quite possible that the dispatcher
will decide to send another event
handler that has registered itself to
handle small even but in state s1 so you
see that the execution when the software
is going from state to state depends on
the current status how software and what
the event handler has told the
dispatcher what it can do so we are
happily going along event II to comes in
new system and other another event is
internally generated by e2 and we call
this event III which needs to be handled
so that gets handled by capital III and
during this time the software has moved
from s0 all the way to s3 in some cases
as we all know that the execution
environment in which the software is
executing also has an impact on how the
software runs and how the event handlers
behave so let me just tell you how it is
what a nightmare it is to test this kind
of application so one thing one could do
and one should do is to test all unit
tests each event handler alright so
that's great but then because of this
state based thing which James correctly
said yesterday that that's a very bad
thing you need to test each of these
event handlers in multiple states and
how do you get to these states is by
generating or coming up with sequences
of events preceding events to test this
event handler all right so generating
sequence of events is what we are
actually interested in doing and those
are our test cases we want to use
model-based testing techniques to
generate these sequences and so what are
the problems here the event interaction
space to be tested is very large it's
huge in fact number of test cases grows
exponentially with length I will talk a
little bit more about this but when you
have more events in the test case the
total number of test cases can grow
exponentially and we don't really know
how to sample the space of all
Sullivan interactions and when I say V
it's not the two of us but we as a
community don't know how to sample this
large space of event interactions
alright so let me try to put in slightly
more concrete terms by giving you a
small demo of this tool called computer
management in under Administrative Tools
of Windows XP alright so I launched this
tool and in computer in computer
management local I am going to go and
change and say connect to another
computer all right so I'm performing
these sequence of events through the
user interface and the computer that I'm
going to connect to first of all doesn't
exist and the name is going to be really
long okay so it's going to keep letting
me type until it reaches a point where
it doesn't let me type anymore and then
I say ok so as expected I get this error
message so somebody really did a good
job of catching this kind of name if I
say ok and I go to computer management
and do a right-click and want to view
properties then the application crashes
so this is I guess it's pretty funny but
we would like to be able to generate
such sequences automatically as a tester
how do you come up with a sequence like
this all right we want to be able to
come up with models that allow us to
generate these sequences in the
thousands maybe and run them
automatically on the application and
catch these kinds of problems all right
so I'm not going to send this to
Microsoft
so we've done a lot of work with the GUI
applications and I'm going to tell you
more about that but web applications are
also event-driven right we all know that
you can perform events through the UI on
the web application and some event
handler runs in the background so this
is again my abstract view of a web
application and it being event-driven
okay there's a problem with this web
application where the state and the
event handlers are distributed across
multiple tiers this is a problem that we
have not encountered before when we were
looking at GUI applications right so for
example in the presentation tier which
is let's say it's on the client you have
some JavaScript event handlers that
capture user events that are coming in
and does something with it all right in
the middle tier you have all kinds of
technologies where there are event
handlers that receive events from the
users layer and process things and then
in the data tier you have all kinds of
data management events update the
database will retrieve something from
the database I call all of these things
events and lots of people write lots of
test cases at all these different levels
so this is a nice test case to test the
functionality that I had shown before
and there are test cases that you can
write at the CGI level middle tier level
and at the database level all right very
complex applications for example if you
think about database testing it's
extremely complex it requires a lot of
expertise we are actually not really
concerned about all of these tiers what
we care about is to test through the UI
okay we're not saying that these other
kinds of tests at the different tiers
are unimportant they're very important
but we would like to do automated
testing through the UI all right so it's
a different kinds of testing that we are
focusing on here and by doing this we
would like to avoid some kinds of
errors for example if I go to United
Airlines anybody here from United
alright so I login
this is my mileage plus number if you
want to add miles to my performance
testing is very important for this also
there are lots of people who are on the
wireless network so maybe that's why
it's slow right so let me tell you
what's going to happen
well then the problem is demos is that
you have to really make put them in
slides you don't really want have a live
demo all right so when I log in United
Airlines expects me to do certain
actions all right it expects me that I
expects me to perform some actions do
something in my account all right but if
I log in and log out immediately
then this website doesn't know what to
do all right so I log in and then I'm
logging out and it's just given it gives
ends up in a blank page or it's
something that it cannot access all
right but if I did actions in the web
application I went and modified my
profile did lots of things and then
logged out I would not see the same
error okay so the context in which an
event is occurring seems to have a huge
impact on how these applications behave
and this is not just web applications or
GUI based applications there are lots of
applications that have these
characteristics the context in which an
event on action occurs let's say robot
control systems all right
the current state of the robot and the
application really has an impact on how
the events and the commands behave all
right so let's go back yeah so this is
what I want to do I want to be able to
obtain sequences of user events either
manually or using model-based techniques
these sequences become test cases and
then I want to obtain the expected
outcome which is for a test Oracle this
is something that determines whether the
test case passed or failed execute the
test case automatically and verify
execution behavior right the application
that I showed you the United Airlines
application is reasonably
straightforward think about something
like Google Maps where we are moving
things around zooming in zooming out the
events that a user can perform on
something like Google Maps is extremely
complex how do we do automated testing
of that kind of application through the
UI oh so this is a topic that's going to
be discussed at lunch time where the
environment influences the accessibility
of an applique
so this is Federation of American
scientists website if you're viewing it
in Netscape 4.8 you cannot search
alright if you're viewing it in Mozilla
then you are ok alright so this is a
great this is going to be a topic that
we discussing in at lunch time so that's
another thing that is a problem in web
applications where there are so many
environments many of these at web
applications don't work correctly on my
windows mobile phone all right so what
do people do when they are trying to
test things through the UI so save the
practice manual testing is common so as
was mentioned yesterday you hire a bunch
of high school interns and then they
give them some tasks and they are
happily trying to test the application
through the user interface all right and
add after typing a little bit you see
that their head tilts all right so the
tilt of the head is very important
because they're trying to verify whether
whatever they did was correct or not so
that's the test article it's a manual
historical right now all right
you come up with very few test cases of
all the possible interactions that you
have on the web application or on the
GUI based applications
there are millions and millions of them
right billions actually they are usually
there testing maybe hundreds of them
because this is very expensive so there
are very few test cases that come up
it's valuable to do this because humans
can actually do very creative things
when they're testing machines and models
they tend to be slightly Dumber I would
think this article is mostly visual
that's the tilt of the head and then the
most of the time people are testing
common sequences and I think we heard
that yesterday in terms of game testing
games that they game the people who are
testing games are they want to do things
that they like to do so they don't want
to go into that board because the board
is boring all right so what is common
one persons common is another person
uncommon and when we make applications
we always have some users like this
they'll always be a birdbrain who will
want to do something to your application
that breaks it whenever I have released
an application after a day somebody will
come back and say they look I did this
and I did this and the application
crashed all right so they'll always be
there and one of the biggest problems I
think in my opinion is that these test
cases are not reusable ok there you must
do this again when the application
changes so that's one level of testing
there's another level which is coding
tests all right so webdriver tests go to
google.com type in something in the
query and then hit the submit button
alright webdriver you can do this
automatically you can run things
automatically you can spread them across
multiple machines that's very nice when
you have regression testing when the
application evolves then it's not clear
what happens to many of these test cases
depending on how the tests are coded and
what kinds of changes are made a lot of
tests become unusable so that's still a
problem Oracle what do you check what
should you assert in this test case to
see if your results are what you expect
or not that's still decided a lot by the
tester you still have very few test
cases problem right how many test cases
like this can you call it's it's still a
few all right and then there's a little
known tool called selenium that also
does some of this all right
ok so thanks God for this test case
alright so another thing we can do is to
start using capture replay tools so the
thing is that all of these people and
the bird brain whatever they're doing is
useful all right so we capture all of
this using a tool and store it in a
database or a test file and there are
several tools that allow you to do this
for example the well-known tool selenium
IDE they it allows you to capture
we play the tester manually performs the
actions the tool captures it stores it
and also some partial state that is
specified by the tester is also stored
all right and when you want to replay it
you give it to a soft Mart that can take
the test file and then replay and then
check against what has been stored okay
so these are good tools they do a lot of
good things and that's why we have also
used some capture replay tools in our
own work so this is where we think the
state of the world is all right I
consider these to be reasonably solve
problems there are very smart people
working on these things so we don't need
more less smart people working on the
them right so tests can be replayed
automatically you can spread them across
multiple servers you can run tests in
multiple browsers and platforms you have
good test management some of these tools
actually a very good test management and
you can very data for test cases for
example you can read things from a
database fit them in text fields these
are the problems that persist some of
them that are going to appear on the
right-hand side how do you sample the
space of all possible event interactions
this is something that we don't
understand yet we need more people to do
research in this we need experiments we
need results of experiments that can
tell us that there are certain kinds of
sequences that are important that should
be generated when the web application
evolves what do you do lots of these
sequence based test cases become
unusable
what do you check and then there is this
more philosophical question that how do
you test large event driven applications
this is not just specific to web if you
have solutions for the web then we
should look at how it can be migrated to
other kinds of event-driven applications
so our approach is take the capture
replay tool because they are well
engineered and they have good test
management and they have done lots of
work in terms of intercepting Mouse
events and things like that and split it
apart into the capture part and the
replay part an insert a model in the
middle
all right so a web application model
what does it look like for this is my
favorite picture of a model the model
should have some red nodes and some
lines in there
all right so for example I could think
of this as a state machine model right
each of these red nodes becomes a state
and this is a state transition that
leads from one state to the other right
if I have usage profiles of how users
are using my web application I could
probably fit some probabilities on the
state machine model come up with a
probabilistic state machine model all
right
use that model to maybe generate test
cases that mimic the population of users
who were used to capture those profiles
all right so we have done some of this
for our applications if I had for each
event that you can perform on the
application if I had preconditions and
effects may be derived from the
specifications for example something
that looks like this for a zoom in event
which takes two parameters the window
and a map that's being displayed if the
window that is being displayed as a
current window and the current zoom if I
can obtain that and it's not equal to
the maxim then I can execute this
command called zoom in I can zoom in to
my map all right and the effect is that
the value of the current zoom will
increase if I can encode certain things
like this for each event that a user can
perform then I can use this to build my
test article which can be used to verify
if a test case executed correctly or not
or we have used AI planning for test
case generation all right so a planner
will give you a sequence of events that
you can replay automatically on the user
interface or on a web application I'm
going to talk a little bit about event
flow graphs that we have developed for
this kind of work so I'm not going to
say much about them here we have also
used the dynamic behavior of the
application to generate additional test
cases all right so what the flow
see here is that don't generate
thousands of test cases and dump them on
the machine alright generate a few
execute them learn something from those
results and then improve your testing so
run test cases in batches so that's one
thing that I'm also going to talk about
and so we have done this for desktop
applications and for web applications
we're going to talk a little bit today
about the state machine model that we've
used to generate test cases
all right so most of this stuff is done
for GUI desktop applications but this is
something that we are going to migrate
to web applications that's why I want to
give you a sneak preview of what we have
done for gooeys and the idea is that you
guys have lots of experience with web
applications we I would like to hear
from you what you think about this
migration right so as the talk
progresses by the end of it I think
you'll have enough background so that
maybe you can give some useful insights
so this is our sneak preview on what we
want to do for web applications based on
our past work on GUI based applications
so first thing is the event flow graph
the event flow graph was one of the most
important models that we came up with
for our work so what is an event flow
graph those of you who are here last
year
might remember some of this stuff the
first thing we do is we identify all the
events that a user can execute on the
application alright so usually for a GUI
based application all the widgets menus
drag and drop events those kinds of
events are identified okay and then we
come up with this relationship called
the follow relationship which says that
a user can perform this event after
performing this event right so it gives
you a blueprint of how a user can use
the application it has a flavor of
program flow graphs data flow graphs to
some extent we call these event flow
graphs all right now what is this again
this the nodes here are events that the
user can perform they're not States and
the relationship here that's being shown
is that a user can perform
this event that's at the end of this
arrow and after performing this event
immediately alright so this gives you a
whole blueprint of what a user can do on
this application so that's an event flow
graph then we in our experiments we have
run literally millions of test cases we
have studied their results and we have
found that there are certain patterns of
GUI events that lead to effective fall
detection in applications all right so
if you generate these sequences that
have been shown to be effective in the
past then you get really good test cases
so that those experiments have led to
another structure called the event
interaction graph which abstracts out
certain events resulting in smaller
graphs that are more efficient for us to
process so I'm not going to go into too
much detail of that but just remember
that this is now an event interaction
graph where this edge is a path from
this event to this other event and maybe
there is an intermediate event that is
needed to get from here to here right so
there's a slight difference between
event interaction graph and event flow
graphs I can take questions offline
after the talk if you are more
interested in that so this is our event
interaction graph right now let's say
that we want to do something really
straightforward these are the events
that are available to you when the
software is first launched okay so let's
say you launch Microsoft Word what are
all the events that you can perform
immediately in Microsoft Word these are
the ones that have these incoming arrows
now with these incoming arrows I can
start from this node and I can follow
these arrows and at each event that I
encounter I can spit that out into a
file and that gives me a whole test case
if I do this random walk I get all kinds
of test cases that probably mimic that
bird that I showed you like typing
random things or I can do slightly
better and since I have this structure I
can generate what I call two-way
covering test case
by picking each edge in this event flow
graph and for each edge I generate a
test case alright perfect so for example
I picked this edge and I took these two
adjacent events and then I used the
shortest path algorithm from this node
to this node to get me a full test case
and then because this is an event
interaction graph some of the events are
missing so I have fit those and I get a
full test case that I can give to a
robot that can replay it automatically
so that's kind of how we could generate
test cases from event interaction graphs
so this is a very promising technology
we've had lots of gooeys and I think for
web user interfaces that are becoming
more like gooeys like for example with
Ajax technology we feel that this is
very promising for that kind of work all
right so how do you create event flow
graphs event flow graphs are nice but
they can be pretty large for example if
I show you three windows in microsoft
word pad don't worry if you cannot read
this this is kind of blurred on purpose
but this is the pulldown menu of word
pad in the main window there's a fine
window in the replace window and if I
want to have an event flow graph for
this and for these three windows only
then it looks something like this all
right so it's a mess and nobody's going
to do this even my graduate students
will not do this
so so how do we come up with an event
program what we did was we came up with
a automatic technique to extract the
event flow graph from an application or
an approximation of an event flow graph
alright that would help us save a lot of
time so the technique that we came up
with was called GUI ripping we rip the
event flow graph from the GUI okay and
the key idea is that if you give me the
handle to the first window of your
application I essentially do a
depth-first traversal of the entire
window hierarchy and I extract all the
widgets that are available to me and
from this GUI tree I use an algorithm to
convert everything to an event flow
graph okay that's a paper I can give you
a copy of that I can discuss it if you
need we don't have time to go through
that but the idea is that we want to use
similar techniques for web applications
can we extract the usage structure from
a web application and you see that a
little bit in a demo today
okay so the we can obtain event flow
graph for large gooeys in a few minutes
in fact one of my students is working on
GUI ripping for Microsoft Office and
he's able to do Microsoft Word he's able
to obtain 40 or so windows in Microsoft
Word with thousand or so widgets in
roughly 20 minutes so that technology
he's still working on that and so we are
hoping that we can apply some of these
techniques to Microsoft Word at some
point and then we can automatically
transform the event flow graph to an
event interaction graph using heuristics
okay
so there's a slight problem here since
this is a fully automatic process what
it yields is an approximation of the
event flow graph there are parts of the
GUI that might be missing in what we can
obtain automatically right so we have an
editing tool where the user can actually
go and add stuff to the event flow graph
the user can open a window that we've
missed and tell our tool that add this
window to the event flow graph structure
so it can do that so we can stitch event
flow graphs together there are parts
where the relationship is not
always accurate okay because of state
these things that we cannot capture
using automatic techniques how you can
go from one state to another what states
are valid can you go from not entering
any user name of textbox to the next
page in the in the application or not is
that valid is that not valid and that's
we drive like how the test cases are
generated so I'm going to show a table
representing this webpage so s index all
this all the states here are yellow they
are the start States so this s index is
when you first load the login page you
can click these are the transitions that
you can go to Valley transitions from
this webpage from this are from this
particular States so I can click on the
reset button and these states right here
in I guess red or something right here
they would they will be the end states
so if I click on reset I'm still gonna
be in the current state that I am if I
enter username text I'm in this state if
I enter if I enter a password I'm in
this state I can't go from nothing to
suddenly introducing a password so this
is not a valid state and so on and so
forth and we do this for the entire for
all the different for the different
elements on the on that web page so I'm
going to go back
so so after we've generated at the table
manually then we we come up with using
webdriver we say okay what would
represent a start States so the idea is
that once you load the page what are the
elements that are on the page as soon as
you learn all the links all the text
boxes and buttons and everything like
that we store them and their values as
soon as the page is loaded so that way
we have a way of keeping track of the
states of the our website as we go along
so we'll be able to verify ok our is our
tests giving the right results and we do
the same for events as well so each
state would be a list of I guess the
values of all the text boxes and the
buttons and things like that and the
events would be okay click or enter text
and things like that and then we came up
with some kind of like a translator that
converts this table into a SML code
which is which was created by Microsoft
Research and we basically use spec
Explorer which is a portion of SML code
as I understand it to model the diagram
the state model that I showed earlier on
with all the arrows and things like that
so so that we're able to store and keep
track of things as we go along and then
it also we're also able to get worse
able to convert the to convert our state
machine model into you could also show
that graphically using graph is which is
just a graphical representation tool and
then after you've done all this then the
user verifies the all the test cases
that came forth from this and so you can
know okay did your test pass and did it
fail
so so right so now we have our ASML code
which basically represents our a state
model like all the transitions and all
the states that are possible and we also
have what they represent using in
webdriver code like the events and the
states and then we came up with the
automatic event sequence generator which
basically converts our state model
traverses it and comes up with a list
like a tree of event sequences and the
different states as you go along and I
sure again I showed the the graphical
representation so these two are then
combined using webdriver command
generator which basically converts all
these all these states and the
transitions and converts them into
webdriver commands and then we come up
with different webdriver test cases so
the algorithm that we used to traverse
the state machine model I'm not gonna
read this cuz I don't wanna read and
nobody wants to read this so I'm just
going to go through this I came up with
this little graphical representation so
we here we're starting at the start
state this is our R this is the first
state in the model so well the algorithm
basically says it's basically a death
fresh start algorithm of the entire
state model so we look at all the
outgoing transitions from this state
like what are the things that we can
perform in this state what are the valid
things that we can perform I can enter a
password in the password text box I can
enter a user name I can click the reset
button so let's say so we pick one of
them so Kay is there any that we haven't
picked means anything that we haven't
traversed and we click and we take that
path all right so we start state we
start from here we take this transition
and we're in this state from this state
we we also say okay what are the
the outgoing transitions from here what
are the valid actions that I can take
from here I can click on the submit
button which should give me an error
because I don't have a user name it I
could click on the reset button which
cleanse the form or I can enter user
name so we click we select one and we
keep doing the same thing from here I
can go here I'll click on the submit
button when we reach a state that has
there has no outgoing transitions this
made an HTML basically represents okay
that means you were successfully submit
at the forum and the next page in the
web page has loaded so when we reach a
state there's no outgoing transitions
from here so we backtrack and we say
okay what are the other transitions that
we have not taken from this and we pick
one of them and we keep doing that too
until all state pairs and all
transitions have been taken and as we're
going along with generating test cases
so we have some short test cases which
lead to the to the final because the aim
of the login page is to get you to the
next page in the web application so
that's the idea and we keep doing this
until all our transitions in all states
so basically it's it get help lets you
cover all the possible user actions that
people could do in your web page so I'm
going to demo the tool real quick
okay
so what it's gonna do is it's going to I
hope is going to load the web browser
and performance so right now is
generating the different event sequences
and hints and states that you could go
through there we go okay so it's loading
the web page so now I enter username
click reset first nothing happens that's
fine
introducer name click the reset button
claire's everything introducing them
again and so the password is gonna clear
out the password and click on the inter
possibly and click on the submit button
all this is done automatically it's
basically just all the test cases
sequences that we generated is basically
just testing each and every one of them
so now I'm going to show you not good
alright so here are the webdriver codes
is generated I can show you trying to
show you real quick the some of the
event sequences okay here we go here's
one so enter you have reset button
excuse me
from this stay you can click on the
submit button it's not valid so these
states and and it's and the tool
verifies as it goes along to make so
that you would know where there was an
error where your web application crashed
so so we've automated test case
generation the other part that is manual
is the creating of the tables and so
we've worked on trying to automate that
as well so we have a web prefer which is
the web version of the GUI professor
Mohan talked about and it's basically
the first thing that happens when you
load the web page is that like I said it
will like it will collect all that it
was it will scan the web page and
collect all the user all the user
elements I guess like actions like text
boxes and it will store them in a tree
and and those will comprise of what a
state is and those and as those values
change as you perform different actions
on the webpage
you keep verifying with all those all
those all those elements of the webpage
so that's the definition of the state
and so we can really perform like a
breadth-first search of all the all the
different combinations of events that
you could have so you have so let's say
I have two to two text boxes and two
buttons I could click on it I could
enter a test in the text box and then go
from there and enter text in the other
text box and then click on the submit
button so all these different event
sequences so to speak are gonna be
automatically generated now some of them
do not make sense and the youth and
that's where the tester is going to have
to go back and basically update the
table that's generating not okay so the
table that's generated is going to be in
XML format
okay
so it's gonna load the webpage scan
everything do the traversal I should
close the webpage when it's done okay
and so now we have this table which
basically represents the table that we
had in the beginning and all the user
has to do now is just indicate which
which states we have this start state we
call the initial States is it an initial
state you enter true or false and you
keep doing that and all the end states
can you go from this state to this state
if you can you enter an action you given
give a text this and you keep editing as
you go along and the idea is that it's
easier for you to have this huge list
and decide okay what what do I need and
what don't I need as opposed to trying
to come up with all these different on
test cases so and this is the exact same
table that we had here only in XML
format and that's converted in the tool
zone
so I'm gonna hand back over to uh
Professor my monster finish alright so
let me just summarize what we've been
doing
we showed you a state machine model and
we're trying to create a web Ripper that
will come up with the state machine
model approximation automatically and
then we're coming up with tools that a
user the tester can use to edit the
state machine model and then use
existing tools to generate test cases
and run them automatically the there are
lots and lots of limitations of what we
have done so far and as you can see the
application that we showed you is very
straightforward
I'm sure if you add more complexity to
it the reverse engineering and the web
ripping will not really work fully
that's what we would like to actually
hear from you so we want to enhance and
extend the model we want to come up with
new state machine traversal strategies
what she showed you right now was
basically you want to cover all pairs of
states and then we want to evaluate
using experiments how good our new test
cases are there are limitations in terms
of what we can extract and there is lots
and lots of work that we want to do by
extending our GUI testing there are
there is probably time for some
questions and some discussion but the
question that I have for you is how do
we test this kind of an application
which is so much more complex than what
we showed you for which I don't even
know how a state machine can be created
so the question is that have we
considered adding some more verification
elements to our test case use the
plug-in able yes so right now what
happens is as each si event sequence is
generated after an event we do verify
using webdriver code whether we have
reached the right state but a user can
definitely go in and use certain things
in there it becomes a Java program at
the end so then you can insert things on
your own right
so so one of the things is that of
course the we expect that the state
machines and any for example an event
flow graph for a web will be huge what
helps us in doing is it helps us in
generating many many test cases as you
said it will might take us two light
years to run them but we have lots of
machines right now we have over 1200
machines on which we spread our test
cases we have a cluster Condor cluster
that also does that but it helps us to
study these results so we don't expect
testers to actually use this and say
that they're going to automate their
testing process but what we want to do
is we'll take the next step in
understanding these event sequences so
that at the end of the day we can come
back and tell you that these are the
interesting kinds of test cases that you
should be generating because we've shown
them to detect more false than others so
it's a kind of an experimental platform
for us to
was that it's kind of difficult to do
craft exactly what state because you're
just taking
right so it's more of a suggestion that
how do you make web applications more
testable more test friendly for example
for example now the latest version of
Microsoft Office has all these kinds of
things that help us to test it so
similarly web applications they could
probably do the same thing yes maybe we
have one more question yes
yes so that's a good question so how do
we get the data into our test cases
right and once you start getting into
all kinds of data that can go into these
text fields then the state space will
explode and we have the same problem in
gooeys but what we have been able to do
so far is that we use the good old
category partition method on each text
field come up with constraints between
field elements and then populate a
database which is read at test execution
time and so they get plugged in so we
have a limit on how many we can plug in
but this is a big problem that we still
haven't solved it's a good question all
right I can take other questions offline
because the other speaker is I would say
ready</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>