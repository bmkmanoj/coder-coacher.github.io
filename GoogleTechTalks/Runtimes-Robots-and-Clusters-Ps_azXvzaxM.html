<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Runtimes, Robots, and Clusters | Coder Coacher - Coaching Coders</title><meta content="Runtimes, Robots, and Clusters - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Runtimes, Robots, and Clusters</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ps_azXvzaxM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright well I've gotten the thumbs up
so we're
go ahead and get started my name is Matt
jaded and how about the podium as
Kristin Christian Jacobson and John
Simpson Christian and I both did our PhD
work at the University of Kent in
Canterbury England and John has just
finished is just finishing up his final
year of his undergraduate and we thought
this was a great opportunity to showcase
some of the nice work that he's been
doing that feeds so well into our work
surrounding concurrency so the title of
our talk has changed many times we're
going to talk about concurrent runtimes
and little robots so here's the roadmap
and you'll see this slide several more
times I'm going to introduce the
challenge that we've undertaken talk a
little bit about the project that we're
engaged in give a little bit of history
highlight two particular examples that
we think nicely illuminate the use of
concurrency in robotics and then a beery
peek into the future because there's
some things that we've started work on
as our project has matured which we
think will be particularly relevant and
of interest to the Google audience so
number one this is the challenge how do
we introduce concurrency and parallelism
too excited bright energetic young
students in a way that they'll be well
prepared for the massively parallel
future that's coming actually I guess
given where I'm standing we're already
there and so this is that there's an
educational challenge here and really
what it is is it's fundamentally a
user-centric problem okay we require
better tools for the teaching and
learning of concurrency the tools that
we've developed in the course of our
project we think they have some
intrinsic value outside of the
educational context and what we're going
to do is explore a little bit how those
tools were applied to our educational
problem and I think that's about it so
that's all we'll have time for
motivating concurrency I think there's a
big what do I want to say I think
there's a big stigma attached to
concurrency where people think it's hard
and if you listen to educators talk
about concurrency and parallelism and
teaching computer science this is too
bad because I think it can be hard but
it does not have to be hard so what we
really want to do is create compelling
context in which students can learn
concurrency and then we'd also like good
solutions to our challenge to be guided
by some very sound principles that
provide an umbrella for all of our work
first principles is that and the things
we work would need to be authentic and
really what we mean by that is that
often we we work with problems that up
that are quite abstract and they do have
a basis in the real world but but still
we often work with them in the abstract
and such as the dining philosophers
problem which is often set in
concurrency courses what we are more
interested in is really exciting people
so so here we have some young women who
are actually working with robotics and
and we would like to present the problem
using these robots as an authentic
problem that requires concurrency now
second a second principle that we've
really used to guide our work as an
ocean of constructivism this is a theory
of learning that has been around for a
long time and by constructive what we
mean is that when you are engaged in an
authentic task it engenders a kind of
learning that generally produces very
deep understandings in the material that
are very personal this lecture context
is not constructive but when students
like these who are engaged these
pictures are from the FIRST LEGO League
competition that we've been holding for
several years now at the University of
Kent and it's an international
competition you may have heard of it you
can see this young woman is intensely
focused on her task and when students
are engaged in this way when we capture
their minds holy
the kinds of lessons they learn are
incredibly powerful whether it's a
winning success or they feel somehow as
they've failed both of those you'll
powerful learning experiences okay so we
also believe that solutions should be
fun if we so the University of Kent map
mentioned that there's the first lego
league competition and actually we run
this with 20 schools and tend about 10
students per school so that there's a
lot of people come in and there's a very
busy environment and people work with
robots and they actually the students
really get engaged for the material they
really enjoy what they're doing and they
get really attached to the kind of
things they're working with my forward
and you can see when when they win when
they when they're our victories they're
really really feel a sense of belonging
to the material they're working with you
again personally I'm here we're working
on the project to do to do this
concurrency work because I encountered
it while I was at University and I
thought it was a really interesting and
engaging opportunity to work on real
research problems outside of the scope
of my calls and I've been able to
explore things and I've really think
thought it's been an enjoyable
experience this just to note that the
first lego league is an effort that
requires our entire department when we
say we were referring to all of our
colleagues not just the three of us
standing here today so now I'll give you
a bit of an overview of the trans to
protect the logo for which you see
sitting here down in the corner it's an
open-source virtual machine and our kind
host dave board put together these
excellent posters for us so we've gone
ahead and used this this symbol that you
may have seen in thought was actually a
real warning so the first bit of our
project is actually the trans terp retur
it's a verte bytecode interpreter it's a
very small virtual mode it's a small
virtual machine it runs on about in
about 10k and that lets us interpret a
rather interesting bytecode that has
built into it some notions of
concurrency what we'll be talking about
as we've said is educational robotics
and we've worked a lot with the Lego
Mindstorms because it's such an
affordable commodity platform
and lastly we'll as we talk about some
of our future directions to talk a
little bit about 42 that's our
experimental compiler for exploring
compiling concurrent and parallel
languages it's the answer to life the
universe and everything written in PLT
scheme will also talk a little bit about
some of our explorations of SMP and
cluster computing as well so it's been
odd to narrate your own video this is
from a presentation that we gave
previously where we didn't it's hard to
do these demos lives so this gives you a
chance to see up close what a Lego
Mindstorms looks like how many of you
have seen a lego mindstorms okay
actually almost all of you so if you'd
like I don't need to dwell on this
terribly long 16 megahertz machine 32k
of RAM three sensor inputs three motor
outputs and what we have here is
actually a robot that has two light
sensors so I'm getting ahead of the
video I don't know if I should I'll let
it run we have two light sensors on this
what's interesting is we have two
parallel processes connected to them
that read from the sensors and then we
have two parallel processes that
actually talk to the motors we have a
process in between that actually acts as
a brain or controller so when this runs
we have at least five or six concurrent
things going on on the Mindstorms juggle
in a very safe and reliable way so let's
go ahead and move on well see it follows
the line and it's too late it's gone
they followed alignment and so what one
of the goals in actually designing our
virtual machine was to explicitly target
the Lego Mindstorms and small platforms
like that and and so one we wanted to be
portable because all of those get
embedded platforms use a lot of
different kinds of processors and we
also need it to be small because
actually on the Lego Mindstorms we yeah
we don't have very much RAM we're kind
of with 32 16 and kilobytes of RAM and
we also want it to be extensible so we
can do interesting things with it in the
future and and we're really interested
in this concurrency aspect so we have
explicit support
currency and that leads into the fact
that we're using an explicitly
concurrent language which actually runs
on top of this runtime so we've been
dancing around our virtual machine the
trans TURP retur the language that we
compile and run the bytecode from which
is our canned pie and we've had people
come up to us and say I think it seems
like you're excited about what you're
doing but why did you invent a new
language and we didn't we actually went
back and are building on top of a long
tradition in terms of concurrency
research and languages in 1968 now sir
professor tony hoare along with his
contemporaries developed the
communicating sequential process algebra
what this is it's now to work for
reasoning formally about sequential
processes running in parallel in the
1980s the inmost corporation in the UK
developed the trans pewter which was a
piece of hardware that was designed to
be very fast at juggling tens if not
hundreds or more thousands of concurrent
processes and you could easily Network
these CPUs together to form a
computational mesh mesh could be a
computational mess that was programmed
in the programming language alkem Ockham
is a small language and it is by and
large a direct expression of the CSP
algebra so what you have here is a
concurrent programming language that is
grounded in a formal set of a formal
system that we can actually reason about
when talking about concurrency now in
the last decade and a half Peter Welsh
and others at the University of Kent as
well as colleagues elsewhere have been
extending out come into language that
they call a compile a borrowed from the
PI calculus and introduced notions of
mobility excuse me and so we have
notions of both data data mobility
across disparate or distributed networks
we have notions of channel mobility
process mobility and today
we have the trans turpin which is the
project that we built we wanted to make
it so the language could run everywhere
it's four years old is generated almost
one PhD Christian is submitted and is
yet to defend we have one more on the
way a number of papers a few posters one
final year project and we think noodles
of other needs stuff I think it jumps
down so the transfer is a project of
many parts there's a core bytecode
interpreter but as you know these kind
of things live languages live in an
ecosystem so there's the various ports
that we maintain which involve a wrapper
around the core we run on the Lego the
cell broadband engine or the Cell
processor it's the core of the ps3 as
well as other places the msp430 which is
just a very low-power embedded chip
produced by Texas Instruments a linker a
wrapper around the compiler toolchain a
swig tool chain that allows us to bind
to foreign libraries written in C and a
whole host of applications native
libraries tests and so on the one that I
do want to highlight is we actually have
a vmware virtual machine that includes
all of our tools and what's nice about
it is we can then program simulated
robots directly from the vm so you don't
have to go through a large install
process if you have VMware Player
installed you can download our virtual
machine and get programming right away
against large relatively large robotics
platforms so these are just some videos
of some early testing of what are
obviously not entirely successful robots
but anyway I'm I'm the middleman so what
Christian is going to talk to you now is
not authentic it is not constructive and
it is not fun that is to say he's going
to actually talk just use the producer
consumer problem to illustrate some
features of the Alcan pi programming
language and then john will talk about
an extension of that and how that was
used to do some interesting work in
robotics replicating earlier work on the
sub sumption architecture
and so what we will be talking about
really is showing its dr compile
language which is what we run on top of
the virtual machine and and it has
concurrency as a first-class construct
so we're basically able to say in
parallel run a bunch of things and and
it also helps us to ensure safety so you
know concurrency isn't an add-on library
it's it's there in the language so the
compiler and the semantics can actually
help us ensure and for example that we
don't have raised hazards and when this
is in part because processes are
entirely self-contained and if you just
look at a paranormal a simple
producer-consumer scenario we're just
generating some integers sending them
from one to the other and in sea or in
Java or Python there's quite a lot of
overhead you need to to do you need to
spawn some kind of threads processes and
you're probably going to have some kind
of shared memory solutions so whenever
these things synchronize and exchange
data you need to program some locking in
and so that they can actually do this
successfully and and for a small problem
might produce a consumer that's probably
reasonably easy but as this scales up
and it becomes much harder and you then
become likely to introduce and various
problems related to concurrency such as
the race hazard and really and you have
to focus on low-level concerns as
opposed to the kind of higher-level
concurrent design issues and we're
really more interested in the higher
level issues and and so if we look at a
knock on program what we often do is we
draw things and paper because actually
arkham programming works very well as
diagrams and so often we draw an actual
producer process and and in this case we
need a consumer process as well and now
we don't have any shared state and so we
need to connect these two things
together and we do that with channels
and so these are point-to-point blocking
unbuffered channels and so they actually
both exchange data and synchronize the
processes and you might know these from
from other message passing and systems
such as open mpi
and now what we then do is once we've
designed our system and we can pretty
much just turn the crank and turn this
diagram into some code so what we have
is a name process call it producer and
it actually has a little dark there
which is where we're going to hook up
the channel and so we need a parameter
there that actually says we're going to
have a channel of integers we will call
it out so this allows us to hook it up
to the other side and and what we then
do is we can write some code to actually
produce the numbers and send them to the
other side now you'll notice perhaps
that Arkham uses indentation in order to
denote scope much like a Python does and
but what we have here really is just a
process that loops forever and outputs a
number and that's denoted by the bang
and it basically outputs I and then in
increments and the number we go around
again the consumer is is pretty similar
again we have a name process this time
it has a channel which we call in
because we have things coming in and it
just consumes numbers and it probably
would do some kind of work on them so
what we have to do as well we now have
the two simple processes but they're not
yet running in parallel and so we
actually need to to put these things up
and and run them in parallel and to do
that we just create a container process
called main and then we could just say
in parallel indentify to run these two
processes however and they do need to
communicate so we do need to make a
channel for them to actually communicate
across and so we make a name channel of
type integer and we give that one end to
each of the processes and now what I've
done here is just try to
how the language can help you write safe
safer perhaps concurrent programs so one
thing you might do and is use the wrong
process and input in place of some pros
other process you are going to try to
use so here we have a producer producer
and network and obviously this is
probably not really what you want and
because Arkham that the compiler is
actually able to infer and how you
communicate on these channels it can
detect that actually you're doing output
on both of them and the compiler can say
no you cannot compile this because it
does not obey the semantics of the
Occupy language and and that's a nice
feature especially for our students who
don't have to wrestle with some of the
harder problems and concurrency so
producer-consumer sets us up to see that
we have these independent processes that
the runtime is responsible for juggling
and it handles the the underneath the
runtime handles the actual transfer the
data and making sure that everything
happens safely what jobs going to do is
talk a little bit about how he took
these ideas looked at previous research
done in robotics and brought some of
that forward into the language and I
won't say more so that he can talk about
it instead okay so when I started using
this concurrent the concurrency in
conjunction with the robotics I quickly
realized that when you're using the
concurrency maps well to the inputs and
outputs that we have but it would be
good to find a way to build robust and
systems we can expand these easily so we
look to Rodney Brooks is subsumption
architecture he wrote a tech report
about it in the mid-80s and what this
does it takes the complex behavior of a
larger product system and breaks it down
into smaller layers of simple simpler
behaviors that can be composed this this
field became known as behavioral robotic
control sometimes reactive robotic
so if we go on with the behavioral
control kind of theme we've got simple
layers they're kind of like they might
think of them like reflexes if we touch
something hot well let me do recall
backwards without any maybe without any
current cognizant thought about what
we're doing additionally we can actually
take high-level behaviors and then
subsume underlying behaviors with them
this is kind of related to if we wanted
to go into a burning house to save a
child or something like that we could
actually override our reflex to reach
away from the burning door handle and
open it anyway and this is the same kind
of idea that week when we don't want
that basic reaction we can override it
to get more functionality so this is
actually out there in the real world
Rodney Brooks started a company called
iRobot they make the right quite popular
Roomba vacuum cleaner robotic vacuum
cleaner and the Scoob are sort of floor
cleaning thing as well they've sold over
two million of these and they used the
behavioral control system this is very
much an emerging from his research so I
sort of took this sub sumption
architecture and sort of looked at how
we could apply it to our Empire to make
reusable robots control systems so
Brooks's system described what modules
with wires connecting between them and
this is kind of similar to what
Christian was showing a few minutes ago
we've got these ideas that there are run
it there are things that are constantly
running and they're communicating along
channels and so Rodney Brooks was
working in these terms and so we've got
these wires wiring between different
modules and all of these modules are
running concurrently in the original
design of the system and we can actually
keep that true to life in the RM system
the layer the decomposition into layers
is also present we might take a layer 0
here in this robot that causes it to
wander that caused it to drive into
space and randomly pick a heading but
then we might add a layer one that picks
of defined heading the gets us to a goal
where we'd rather be and that connect
they actually overrides the motor
commands when it has a better idea of
what we'd like to do with the motors so
this is a video of me working in the lab
back at Ken there's a lot is color
there's got a lot of stuff in the lab
and actually this is the pioneer
three it's a fully-featured pentium 3
700 a computer inside running debian
linux and it it's actually a really big
robot we have a laser scanner and so no
scanners around the edges and actually
this is running this assumption code
that I ended up writing and so it's
using the laser scanner on the front of
the robot to explore the space and go
forward and turn away from objects it
encounters it also has a safety
mechanism built in if it drove straight
into an object it'll actually stop so we
can start to compose these systems in
the art with these occupy processes if
we define a behavior that tells us to go
forward until we get too close to
something and then stop we can write
that fairly easily in terms of process
and channels so we get a channel of
laser data in we get a maybe we have a
process that refines that to get a
minimum distance the nearest object and
then that distance is passed on to a
threshold attacks against our the kind
of distance we'd like to be away from
things and then past is either a stop or
go mo go command appropriately and we
can actually look at the arc my code for
that at the top of the process we've got
two channels defined we've got a channel
of distance in and a channel of motor
commands going out when we come in we
enter a while truly we're running
concurrently we can keep doing this over
and over again without worrying about
the rest of the system and actually we
can read the minimum distance in doing
if doing if construct over the minimum
distance and then send an appropriate
message on to the motors and so actually
we can start building up some really
quite interesting systems by composing
these layers if I want in an additional
behavior that said what we want to turn
away from objects in front of us because
just stopping doesn't really do anything
in them in an enclosed space i can write
some more arcane processes have some
more channels what's interesting here is
that we can have the suppressor that
when we've got when we've got output
coming from the lower levels it'll pass
straight through in the main cave and
but actually when when turning where we
want to turn away from an object in
front of the robot we can override those
go forward motors using the suppressor
and actually pass the back up and turn
messages to the motor instead and we
haven't modified the behavior of the
underlying layer we've still got the
semantics that we would expect from that
layer well we've added more
functionality to the robot and this
robot would actually demonstrate more
complex level of behavior and we can
continue to do this arbitrarily and it's
quite interesting to it's quite
interesting it which I said we had
lasers and sonar so if I added another
layer that read from the sonar and
checked it through the space behind to
back up because if we head up to a wall
and then we try to back up maybe there's
a worn extra we'd like to check the if
there's a wall there because then maybe
we can try and go forward about and make
a tire made of make a term with more
points so we can write another process
that reaching the sonar and we
introducing you inhibitor then and we'll
see that behavior in a minute if you can
revise so actually we activate this
layer we're back in we've been backing
up and we don't have space behind to
back up into this layer becomes active
and it activates the inhibitor what
we've done is complete what we've done
is connect the second layer into the
inhibitor so that actually when we don't
have space behind we won't we won't
actually send those back up and turn
messages to the motors but then the
emergent part of this system is that the
base layer will then be active because
there's nothing suppressing that go
forward messages so actually by adding
this extra layer we're bringing a lower
level a lower layer back to do some use
for work and all of the layers stay
intact as they are the interaction swing
this is defined in terms of these
external processes and so actually what
we get is we get the forward motion
without explicitly writing that we
wanted forward motion in this new layer
that we've added and so we'll just show
that video again just to sort of now
we've related some of the code that's
running on the robot and that's that's
the things that's doing it lets us build
these kind of architected systems that
decomposable into individual pieces that
don't change between iterations and
what's nice about this is we actually
managed to implement Rodney Brooks his
work fairly directly today even though
it was written maybe 20 years ago and I
think that's but i think has actually
been really interesting to explore
so it's interesting so anyway english
language has just left the room so
wasn't yet to reiterate what john said
it's really nice is that Rodney Brooks
had this model for how he wanted to do
things and there's something really
compelling I think about being able to
express that model in a way that is
directly supported by your underlying
language and you can have tools that can
help check the correctness of what
you're doing before you turn it into
executable code so we're going to do is
we're just going to give you a peek at
some of the things that we're working on
as we move into the future and hopefully
those might be sources for questions or
either way they're just the interesting
things that we're working on that we
would like to share in fact that's just
that we think they're interesting is
that we think they're very very exciting
so so what one of the things that we
really like to do is is we have this
notion we're actually wanting to get
across to students that actually
concurrency doesn't need to be extremely
hard and now there has been back in the
heydays of Arkham there's been a number
of graphical user interfaces for it and
again because we have this very
graphical notion of the language and we
can actually draw things and almost
mechanically turn them into code and and
so we'd like to actually be able to give
that to our students because we don't
necessarily want them to have to deal
with the syntax straight away because it
really it it distracts from some of the
objectives related to currency that
we've much rather get across and so what
we'd like to do is put this in a program
and where we can actually build these
robotic controllers from components and
that they can drag off a pallet and then
put on a wire and thus build some
robotics controllers but also we don't
really want
to actually hide the power underneath
and so we so we would like to then once
they've got used to the concurrency
ideas to actually that allow them to
express them more fully using the full
language and and this is really what
we're interested in doing and its really
start by hiding the complexity and
making it available and to to our
students to explore and the concurrency
concepts and then unravel and things
until we actually get down to the syntax
into the code to actually program and
they can actually then start to do some
very powerful things so in terms of our
original educational objectives of
authentic constructive and fun what
we're really saying is that the tools
that you use become a gateway and they
really do shape the way that students
and can't think about encounter probe
and tackle problems that if we wanted to
you know our experience from using these
lego robots in the classroom in my case
now since 1998 really there's a lot of
inadequate tools for students who are
trying to engage in what is a
fundamentally concurrent task with a
linear control flow based visual
language or syntactic language there's
many java see there's a lot of languages
available for these robotic systems but
none of them actually support them in
juggling all of the tasks that they need
to engage in and so what we're really
trying to do is at some level provide a
powerful way to introduce students to
these notions about concurrency and
parallelism so they are more functional
as designers of parallel and concurrent
code in other languages when they
actually have to start implementing it
using lower level primitive constructs
looking forward part of what I'm
employed right now to do is I'm a
postdoctoral researcher the University
of Kent on the dias project stands for
the design implementation and adaptation
of wireless sensor networks and what
we're doing is we're it's actually a
very ambitious project it involves five
institutions strathclyde university
Manchester Glasgow st. Andrews
and Kent and we have radio engineers
database experts language experts people
working on runtimes and hardware and
most importantly we have scientists and
what we're trying to do is address the
kinds of research questions they have in
an agile way bringing together all the
different kinds of design that go on in
our various disciplines in the
development of sensor networks that we
can place in the world to study the
environment now I don't know if you've
thought much about what it takes to
actually put sensors in the world and
run them for long enough to do
interesting research but usually
scientists have questions that they
require years worth of data that's
consistent and really the state of the
art in terms of software development in
terms of power battery power and other
things is not prepared to drop a node in
a river for two years and then come back
and have it still be working and have
data ready for you so there's some very
difficult challenges so we've been using
the transfer / at the runtime level to
try and bootstrap us into writing safer
concurrent code on these embedded
systems so we don't go out six months
after deployment and discover that we
had a race hazard and got three days
worth of data one of our deployment site
sites is in the croton watershed area
that's east of Manchester England it's a
very beautiful area all these sharp
rolling hills where you cannot get a
cellphone signal if you try and so if
you deploy your network at the base of
these these valleys you really need a
way to shuttle that around or alert
conditions so you might then have some
kind of mast at the top that can see
part if not all of your network and so
to a certain extent what we're trying to
do is is use these wireless networks to
enable better longer-lasting research
and basically help scientists engage in
fundamentally important tasks in asking
questions and answering them about the
world using the small devices in this
way
another another exploration that we've
engaged in recently and actually on our
um on our web log there's there's just
some some initial informations and some
science numbers and graphs where we've
taken the trans tur paterville machine
which when we're running on the lego is
a single a single threaded fetch and run
loop because the lego only has one
processor but when we're running on some
kind of SMP machine we have a lot more
computational power available so what
we've started working on is is we made
some very small changes to the the
interpreter just a few lines of code to
actually put operating system level
threads underneath it in Occam as you
saw we have the construct par and when
we put something under it we'd really
love to actually run in parallel so what
we've seen is that when we thread the
interpreter we can get speed up even in
relatively trivial cases we've also
found that threading models on different
operating systems are completely
different and actually there's a lot
more work that we'd have to do before we
could claim any kind of general result
there's plenty of research on scheduling
algorithms and things for this kind of
thing that we've we've read about but we
wanted to make tiny changes just to do a
spike exploration and what we think is
that there's some actual value in
pursuing this further and lastly on the
Darwin h4 cluster you guys have a few
machines available to you it's probably
not as impressive as the cluster I run
under my desk does do people make jokes
like that all the time yeah so I got it
got it will chew on foot later but
either way so what we've done is I said
I mentioned how we want to be able to
make use of I'll call it legacy C code
although openmpi is an active and living
library we have this language that has
notions of parallelism and channels and
there's a very nice mapping actually
between occupied channels and open mpi
blocking calls between distributed
machines on a network
and so what we'd really like to do and
what I've written some prototype code to
do is that we can first of all we could
model our distributed system in alcon pi
there was a paper published in oh no i
forgot the I Triple E conference by a
gentleman at skype where they modeled
hundreds of thousands of users on their
network using a compile-time sign if we
could use outcome isn't as some kind of
architectural glue and at key points
break our aquam process network up with
open mpi channels at which point my
concurrency and parallelism is still
guaranteed to be correct as long as the
semantics map correctly from the
language to the library so I think
that's kind that's something we
definitely want to spend more time
looking at and I think that that leaves
us with just one more exploration that
we've been engaged in and that's 42 it's
an experimental compiler written in
scheme I did my Master's work in Indiana
University and I learned some from some
really great people about about
languages and it's an experience that
I've always valued as I've moved forward
so what we do is we've taken a even
smaller part of the language occupy is
already not large and implemented a
small compiler that we could explore a
few key things number one our bike code
interpreter is not hugely fast it's very
portable and in fact one of the things
that we brought with us today is in a
box and it's hidden we brought a robot
that we saw for the first time two days
ago a brand new architecture for us we
ported to it and we actually now have
John subsumption code running on top of
it you're welcome to come up and take a
look at a real robot running around on
the floor after the talk but what we'd
really like when we're dealing with oh
thanks Dave so there it is it's a you
know it's a little robot
they're so we'll run him around on the
floor in a little bit but what we've
started to explore with the compiler is
native code generation we're actually
able to use the existing code base as
runtime support for compiled code so
instead of doing bytecode interpretation
we can sort of unroll things and get
some very initially very impressive
numbers executing at near-native see
speeds while maintaining again our goal
of safe concurrency on a platform our
colleague Damian Dimmick is looking at
code distribution he's been playing with
the cell broadband engine and we're
interested in whether or not we can a
compile-time or dynamically at runtime
do distribution of processes over a
changing you know a changing set of
resources in a distributed context but
that's that's an interesting and
challenging linguistic challenge and
lastly it's also been a place for us to
explore compiler design have been
playing around with some I think some
interesting ideas with units and mix-ins
for composing many many passes and a
compiler but either way so just another
spike which brings us to the end of our
talk and there's there's a lot of people
who have been part of it or helped out
in a number of ways and yes this is
quite a few people we need to talk and
my supervisor Cleo Welsh and also David
wooden Fred Barnes who's been
instrumental in updating our come to
occupy our colleagues Damian Dimmick
who's recently started his PhD at Kent
Karl Ritson has just finished his his
third year at Kenton is now doing a
postdoc project Carl did some some very
nice things exploring helping support
some of the multi-threading as did Adam
who's finishing up his PhD not too long
from now the University of Kent have
been very supportive and in particular
we have to give thanks to Jenny only
jenny is actually the secretary of the
director but I don't know what your
experiences in life has been but she
helps make things happen of course the
epsrc for for funding me as a postdoc
and for supporting some of this work and
we also want to thank Dave board who's
been our host here at Google so that's
about it we don't have a slide with our
URL on it which is unfortunate because
the word trans terp retur actually
rather hard to spell but that's that's
the end of our talk and thank you for
taking some time to listen to us so if
there are questions I I think I'll just
go ahead and I can point at people if
you have any any questions yes sir
it's okay so yes repeat the question so
the question was is our primary focus
embedded systems these small systems or
is it that we're more interested perhaps
in the massively parallel and
distributed our initial initial goal was
to get Occam running everywhere which I
think we've done a nice job of
demonstrating we haven't yet encountered
something we can't run on and it was
originally a language for running on
small platforms and embedded systems
what's interesting is that because of
the approach of using interpreter making
it easy to bind to other languages we've
been engaged in these spike explorations
I'm not a hundred percent the language
as it sits would necessarily be
completely appropriate for for anything
and everything in the distributed
paradigm but certainly there's something
compelling about it as being an
architectural glue language where
perhaps I have my high performance
libraries written in C for doing
numerical crunching or data processing
but at a higher level I use a language
that my compiler can help check me
afterwards to say yes when you go and
you run this job on your 1 100 1000 unit
cluster you're not going to run into
something that you hadn't anticipated
it's although we're four years old I
guess another way to put it is we're
just reaching the point now where we can
do these interesting explorations if
that makes does that make sense
any other questions
we have stunned them with our very very
exciting oh the robot yes go ahead
Christian you've been hacking on most
recently so I think what we would like
it to run around I think we've had a bad
flash experience here classic so
unfortunately I managed to destroy the
program right yeah the real problem is
that we flash it over Sigma it'll signal
signal over them so there's a lot of
interference with all the wireless here
it doesn't really go so well so we need
is a lift or something like that like
Faraday cage where we can get the
program back but it's true we were at
triple-a our robotics at Stanford
earlier just the last few days and
whenever we wanted to flash this thing
because Stanford also has a fair bit of
wireless networking we'd either climb
into the basement of a stairwell or an
elevator and finally the upload worked
but you know somebody decided rs-232 is
no longer viable so our machines don't
have it will try and fix that and show
it to you before for loan any other
questions all right well thank you all
for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>