<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2016: Selenium-based Test Automation for Windows and Windows Phone | Coder Coacher - Coaching Coders</title><meta content="GTAC 2016: Selenium-based Test Automation for Windows and Windows Phone - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2016: Selenium-based Test Automation for Windows and Windows Phone</b></h2><h5 class="post__date">2016-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8XLGonU9Pyw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">&amp;gt;&amp;gt;Matt Lowrie: And right into the next lightning talk, we have Nikolai Abalov.
&amp;gt;&amp;gt;Nikolai Abalov: So, yeah, I'm going to talk
today about Selenium based automation for
Windows and Windows phone, and I hope somebody
saw a Windows phone actual device.
Yeah.
[ Laughter ]
So, yeah, I am a software development engineer
at 2GIS.
It's a Russian-based local search company.
And as I said, I'm going to talk about Selenium-based
automation for Windows and Windows phone,
and I'll start with why even bother?
Why Selenium-based automation?
Why don't we use some custom API?
So basically Selenium exists for more than
ten years and it became a standard de facto
for Web automation.
And there is a lot of documentation and big
community, and a lot of common problems has
been already solved in this Selenium infrastructure,
basically.
And, also, Selenium uses this very nice architecture
where it's basically a client server architecture.
So your tests are just an HTTP client which
sends a comment according to the WebDriver
specification to the server, and then the
server actually translates this comment into
a concrete automation to drive a system under
test.
And your system under test can be basically
in your browser, in your mobile, or even if
you want a coffee machine or something like
that.
So this allows you to write your test once
and then to execute them many times on different
platforms, ideally.
In reality, it doesn't work like that, but,
yeah.
So from the point of the user, from a coverage
test using the Selenium-based tools, it basically
has a lot of comments -- problems already
solved and he does not have to invest more
time to starting new API and stuff like this.
So it saves a lot of time.
And from the point of developer of these tools,
you basically have everything on the left
already written so you don't have to provide
any client API for your users and stuff like
that.
You just need to fill in this magic part on
the right of the picture.
And the WebDriver spec itself is very simple.
It's basically just an HTTP request which
can have a JSON body, and response is also
just a JSON body, so it's very easy to implement.
And together, there are -- besides Selenium,
there are also tools like Appium or Selendroid,
and together this family of Selenium tools
covers almost every major platform, except
for Windows actually until very recently.
So like maybe in the last release of Appium,
it was added support for Windows desktop,
which was made possible because Microsoft
released a Winium driver which is actually
a closed source and is in beta right now,
but you can go to GitHub and download binaries
and try it out.
I'm going to talk about the Winium project.
So Winium project is basically an open source
family of projects for Windows 7, Windows
phone automation.
And I will start with Windows phone automation
because it was the first project we brought
back in 2013.
So we needed some tool to automate Windows
phone, which was quite popular in Russia.
Yeah.
[ Laughter ]
And we had actually there were no tools for
automation for Windows phone, and even there
were no tools provided by Microsoft, which
was kind of strange.
So, yeah, we wrote a project which is called
Winium mobile.
You can find it on GitHub.
It's completely open source.
We have, like, documentation and samples and
stuff like that.
And what it does basically is WebDriver implementation
which can drive automation of native applications
on Windows phone.
It actually lets you run your test on emulators.
It does not work on devices, but you can hack
it around and actually run on devices, but
with some limitations.
We also are working on a support for hybrid
applications testing.
And because it's Selenium based, you can easily
plug it into your existing infrastructure.
You can use it with Selenium (indiscernible)
to run tests in parallel and stuff like that.
And there is only one catch, but I will show
it to you here.
So we have this architecture which is similar
to Selenium.
And we have your tests and we have a driver
and when you send a comment to the driver,
this comment converts into one set of APIs.
So we use Microsoft APIs to manage virtual
machines with are basically emulators to simulate
user input, to install your application, and
stuff like that.
But to interrogate UI and to interact with
UI, we had to invent a test (indiscernible)
application on that test.
So because of areas in boxing on Windows phone,
you actually have to add a special automation
server right inside your application, and
this server will be able to handle comments
like finding elements and getting the text
variant and stuff like that.
So how does it work?
It's very easy.
Basically the steps are similar for -- as
for Selenium or Appium except for the first
one.
So you have to invent a test server, as I
said, and this is accomplished by adding a
single code of line and installing a package.
So it's very easy.
And from then you just write your test like
any regular Selenium test.
So there is no difference basically from Web
test except for capabilities.
So we have some specific capabilities which
let you install application and install files
into this application or debug your application.
And in your test, you can use standard comments
like finding element by D, by class name,
by name, et cetera.
Also, you can use Appium bindings which are
basically just extension of Selenium bindings,
and this lets you close application, launch
application, and upload and download files
from and to the application.
And also, it lets you switch between context.
So if your app has, like a WebView for authentication,
you can switch to this WebView.
Use just regular Selenium to optimize this
WebView, and then switch back to the native
context.
But we can't release it yet, but you can build
it from sources and try it out right now.
And, also, because we have this automation
server right inside the application, we are
able to do some cool stuff.
Like we can call any static method in your
application, basically, or set any value of
(indiscernible) in the UI.
So this can help you with just ability of
applications.
For example, if you have like a map view,
you can set coordinates of this map view directly,
very precisely.
You don't have to use like touch, gesture
to swipe it or you don't have to write a custom
test API.
So you can just do it from Selenium test.
And, yeah, then you just run your driver,
and you run your test like usual, and I have
a demo.
So if we can switch and turn on this video.
Yeah.
So with just one of our test cases.
So we install application.
We upload map and all the data into application
and then just try to build a route.
So basically navigation stuff.
So it does support everything, like swiping
and stuff exit.
Yeah.
Can we switch back to the slides, please?
No.
Like, next slide, please.
Okay.
Yeah.
Technical difficulties.
Okay.
Thanks.
So, yeah, we have one more project.
So when Windows 8.1 was released, Microsoft
actually release its own automation tool,
called Coded UI.
So, we naturally decided to try it out.
And we wanted just to swap out our Winium
Mobile.
So we wrote a Selenium (indiscernible) so
we can just replace one driver with another
and keep our test.
And it's also open source.
You can find it on GitHub.
It has basically the same features as Selenium
mobile except for some of the comments.
But it can run on devices.
And it actually doesn't require to modify
your application on that test, which is very
cool, because you can just build your application,
test it, and deploy directly to the App Store
without any modification.
But you have to pay a price for it.
You have to buy Visual Studio premium license.
So it's not very scalable if you have a lot
of notes to run your tests in parallel and
stuff like that.
So we actually decided to stick with Winium.Mobile.
So here's this architecture.
So in this case, we don't have any tests here
inside your application, because we use this
Coded UI, which runs out of the process side
by side with your application.
And also we have a Windows desktop automation,
of course, because we've had a lot of internal
enterprise Windows clients and we needed automation
for those clients.
And we wrote a Winium desktop.
It's also completely open source.
You can find it on GitHub.
So it's kind of like a WinOp driver from Microsoft,
but it's also existed for maybe two years
or even more.
And it basically can automate almost any Windows
desktop application which is accessible by
Microsoft accessibility.
So if a screen reader can read UI -- elements
in UI in your application, then you should
be able to automate it.
It does not require you to modify your application
(indiscernible), just like Coded UI.
But unlike Coded UI, you don't have to buy
Visual Studio license.
So you don't even need Visual Studio installed
on your desktop.
And it's -- also has full access to desktop,
so you can even automate multiple applications
at once if you have, like, cross apps in there
or something like that.
And the architecture is just the same as for
any Selenium project.
And I also have a demo.
So if we can switch.
Okay.
So we'll automate the calc (indiscernible),
which is basically just a standard calculator
from the Windows, resulting in modification
and stuff like that.
So it's just -- it just calculates two to
the power of eight, and validates the result.
You can use it not only for testing, but also
for automation of (indiscernible), where you
have tools which have no APIs or they have
only UI stuff.
Can we get slides back?
So also we have a more -- oh, thank you.
Here are slides.
So here's an example of our -- a code sample
which we use to record this demo.
It's written in CSharp.
And, actually, I had a previous slide, but
I can't switch to it.
Ah.
Okay.
And here's the same code which is written
in Python.
So it's also one of the benefits of using
a Selenium-based approach, because we have
a lot of different teams in our company and
each team prefers their own language to write
the automation.
So one team can use Python, another team can
use CSharp, for example.
And there is almost no difference.
And, actually, that's all I have.
But we also have more automation tools.
We have VMMaster, which is basically like
a Selenium grid on steroids.
So this is basically browser's cloud.
When you run your Selenium test and you request
a new session, it gives you a new virtual
machine with a clean state.
So you don't get flakiness because of dirty
environment in which you run your test.
And also we have STF tools, which you can
use combined with Appium and open Smart Test
Farm, which is also open source, too, to build
an Android cloud automation with video recording
and stuff like that.
That's all.
Thank you.
[ Applause ]
If you have any --
[ Applause ]
&amp;gt;&amp;gt;Matt Lowrie: Very good.
Thank you, Nikolai.
So I think we have a little bit of time for
questions.
We are, after this, going to break for lunch.
So prepare yourselves.
The first question, though, which languages
do you support in Winium?
&amp;gt;&amp;gt;Nikolai Abalov: So, actually, because it's
Selenium-based, you can use any language to
write your test.
So your test just -- your test is basically
just an HTTP client.
So if you have a language which can send an
HTTP request, you're basically all set up.
You can use Python, you can use CSharp, you
can use Java.
So, basically, any language.
&amp;gt;&amp;gt;Matt Lowrie: Very good.
Any questions in the room?
I'll get -- All right.
So I'll ask this one and get the microphone
to you.
But can Winium handle responsiveness?
&amp;gt;&amp;gt;Nikolai Abalov: I'm not sure how to answer
this question, because it depends on what
you mean on responsiveness.
So by itself, Winium was just like a Selenium-based
automation tool, so it does not -- you can
use it, actually, to check if your interface
behaves correctly on different sizes, screen
sizes by actually getting elements, (indiscernible)
and stuff like that and asserting against
it.
But it's quite, like, an unusual scenario,
I think, to use.
So usually to do stuff like that, you use
something like (indiscernible) tools or another
responsive UI verification tool.
&amp;gt;&amp;gt;&amp;gt; My question is, in the footer of a couple
of your slides, you made reference to a tool
called UISpy.
Can you splay what that is.
&amp;gt;&amp;gt;Nikolai Abalov: Basically, it's one of the
tools which came with Windows (indiscernible).
And this tool was usually used to verify that
your application is accessible.
So you can use this tool to see which elements
there are in your application and which labels
they have.
So when the screen reader, if you read the
screen, it will read it correctly, basically.
So it's like a UI verification tool of some
kind.
&amp;gt;&amp;gt;Matt Lowrie: Okay.
Maybe one more.
Can Winium run the automation on multiple
phones connected to a computer?
&amp;gt;&amp;gt;Nikolai Abalov: Actually, only Coded UI
can run on devices without limitation.
But it turns out that you can only connect
one device at a time under one user.
So it's just a limitation of API provided
by Microsoft.
But I think if you manage to run multiple
users on single desktop, then you can, like,
assign each use B to a single user, and then
it should be possible to run multiple tests
on multiple devices from a single machine.
&amp;gt;&amp;gt;Matt Lowrie: Okay.
So to stay on track, let's give another hand
to Nikolai.
[ Applause ]</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>