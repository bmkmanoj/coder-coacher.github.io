<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Eclipse Day at the Googleplex: Wiring Hacker Synapses | Coder Coacher - Coaching Coders</title><meta content="Eclipse Day at the Googleplex: Wiring Hacker Synapses - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Eclipse Day at the Googleplex: Wiring Hacker Synapses</b></h2><h5 class="post__date">2008-07-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GfeUCT-tRJQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">did anybody follow the development of
real-time shared editing anybody know
what that is okay that is very
unfortunate but very fortunate that
you're here now so what I did just
before flying to monk view that was last
week in Germany I did a screen cast of
the new real-time shared editing
facility that comes with Ganymede and
you some of you might know Neil Bartlett
who is another fairly well-known
ecliptic emitter he twittered me this
morning and said hey you and your orc
are famous and then of course he asked
me about a bug that is in real time
shared editing and supposed to be
removed and you and your crew first to
that screen cast so if you haven't seen
the screencast then I will just do
another live demo and we'll show you
well something similar with another hint
at World of Warcraft or something
because in the very first screencast I
implemented an orc class instead of a
person class you know the standard
boring exam so Scott Louis and I are
here Scott is the project lead on the
club's communication framework for jam
commit Iran and I think we should just
get started with real-time shared
editing the demo and after the demo I
will you know tell you a little bit
about the algorithms behind it why it's
so cool and what future steps we're
actually thinking about so Scott are you
signed in into your XMPP account all
right you're logged in I will log into
this is an xmpp server in standing in
ottawa right okay so all right Scott
you're the only one on the server and
what I'm going to do now is I'm going to
invite Scott to a shared editing session
and both of us are going to flesh out
this same class so it's invite Scott
occasion you got an invitation okay
let's check whether Scott is just saying
so or high or he is here all right he's
in the same class we're editing the same
document and you know what most
certainly our edits are crossing on the
wire conflicts
rising all the time when we added at the
same time but still the document is
staying consistent being consistent so
Scott what should we do I'll just
implement two fields and you can flesh
out that equals method i will do a name
field I'll use the names yeah for
instance let's call this name and I'll
do another string and we'll call that
well I think chlorine have tribes but
you probably wouldn't care if you don't
play World of Warcraft or never heard of
it okay well Scott fleshes out that one
I could do something else that makes
since like for instance implement a
tostring method for this class so mmm
let me think let's return this dot name
and this started did you initialize both
of those oh we don't have a constructor
yet little bit ok that's cool mmm okay
this is basically what how it works like
you can edit the same document at the
same time without getting alphabet soup
or without getting errors are everywhere
and it looks probably it might look
trivial it's not and I will introduce
you to the black magic that is shared
editing so let me just okay thank you
Scott mmm where is my presentation so
that was the really short live demo I
will give you a link to these slides and
the slides contain links to even more
material and to the screencast which
runs like 48 minutes and provides more
detail on how to use real-time shared
editing within eclipse so this talk is
about collaborative coding and if I stay
within my time limits then Scott might
even say something about general team
tooling and you might say something
about the Eclipse communication
framework not just being about you know
tools but also about API is actually
mainly about AP is and well if I if I
just
use up all the time then you won't hear
anything about api's all right so
collaborative coding in Eclipse
communication framework lingo is real
time shared editing with Cola and cola
is the synchronization engine that I
wrote i started out as a google summer
of code 2006 student did an internship
with google and that's how it all came
about so that's the agenda i'll talk a
little bit or very briefly about my
motivation for doing this i'll give you
a conceptual overview about shared
editing sessions just so that we have a
common basis i'll introduce you to the
challenges which is just a better word
for problems that arise with shared
editing and then we'll explore the
solutions i'll introduce you to the
future not yours but I've shared editing
and well I hope that after the talk you
leave and are all happy and all fired up
to try out shared editing yourself so I
wanted to enable pair programming I was
I was introduced to pair programming by
a couple of friends of mine who did that
very strictly and you know at first I
was going to go okay interesting but hey
come on share a single keyboard you sit
at the same desk all the time I don't
know whether I like that so people who
really slavishly follow kent beck spare
programming they probably won't like
this and go like them okay no no you
really have to have that single keyboard
I like having different machines and
actually that enables you to do even
more another thing is you can do live
code review with this of course google
has a very very nice tool internal tool
which has become public made even public
by the creator by guido van rossum the
creator of Python it's called Mondrian
and now they have an open source version
which has been released its called
rietveld and there is a review board
these are all that we call them
synchronous review tools reviewing tools
with this you could of course do live
code reviews using shared editing
real-time shared editing you can help
tutor mentor people or you might have
somebody who knows something better than
you who is a domain expert or you know
with all the multi threading coding
going on in many teams you might have a
single or two person two people on the
team who know
java.util concerned and well why not
invite them and have them check your
code or just code together it's actually
the best way to learn anything there is
a lot of people who say hey examples are
the best way I think if you have
somebody who can teach you it's even
better so obviously real-time shared
editing this way is independent of
Geographic restrictions which is
especially important for open source
teams like us for instance I mean Scott
how often have we met before like once
in person right and we've been working
for two years yeah together so this is a
tool that will help you with things and
team structures like that it's also it
enables you or is resilient resilient to
location limitations that means if
you're in an open plan office or if
you're just sitting in an office with
like four or five people pay programming
can become a bitch you know because
you're allowed you're talking all the
time and people will not like this so
the ultimate goal summarize making
coding more social effective and fun and
you know what might sell you might sound
utopian but this might not be the right
tool in any case you know if you have to
be totally concentrated sitting and
trying to solve an algorithmic problem
actually then you shouldn't have your
IDE fired up you should use pen and
paper I think but still you know with
many stuff with many things like you
know wiring api's together or learning
stuff this is actually a good tool is my
personal experience so what we've showed
you just now is to participants working
on the same document which currently can
be a text file a java source code file
anything that uses the Eclipse editor
infrastructure these two people can work
on or actually are located and working
on different machines and the their
respective updates to the document are
sent over the network what the
synchronizer takes care of Cola takes
care of is that you in the end have a
consistent document state now you might
say okay I'm very very okay I'm trying
to be diplomatic here but ok let's
change this I'm so bright I'm so smart
most of I you can have a consistent
document state if I just you know always
sent the full document over and just
overwrite all
changes the other person is done while
my document was travelling right because
at the end you will again have the same
document just you won't be in tension
preserving because what you want to have
is the changes I did to my local
document while changes were on their way
to me they I want them to be preserved
vice versa for the other editor that is
what Cola does so let's have a look at
this conflict-free ideal of a shared
editing session I'm just introducing you
to the type of diagram i will use
throughout the talk so Anna and Zoe are
two software engineering hecker ladies
and they start out editing on the
initial consistent documents state that
was what you saw in the example as
public class tour so just imagine this
green bar being you know a line of text
in a source file what happens now is
Anna makes an insertion at index
position a in the document the insertion
gets incorporated into our local
document sent over the network reaches
Zoe and add Zoe again gets updated and
integrated into the document no problems
so far Zoe does an insertion at the
beginning of the document in exposition
0 incorporates the change change gets
sent over the network lands at anna and
again the document is updated now you
will say hey most of I don't think I
need this synchronizer yes you do this
is the totally and absolutely well the
most optimistic example you could
probably have so just reviewing what I
showed you we had the same document
state we had some editing and in the end
we ended up with the same document state
consistent documents intention
preserving changes because and I wanted
to make a change somewhere in the middle
of the green section and Zoe wanted to
make a change somewhere or not somewhere
at the beginning of the document both
these changes ended up at their
respective positions so again recapping
real fast no conflicts because an i
generated you know a change on the
common documents state that also Zoe had
sends it to Zoe Zoe updates the
unmodified local doc
with incoming change so he generates a
change herself on this same document
that they both have now the change gets
sent to Anna and a updates her common
document state now and we're all set and
all happy because we have strictly
sequential execution this is ideal but
very very unrealistic especially when
you code at the same time so one of the
challenges that you run into when
implementing realizing something like
this is that you know reviewing Anna
inserts something at an exposition a the
change gets sent over the change is
traveling on the network while the
change is traveling and it is another
update to our local document inserts
something at index pose position 0 gets
incorporated but what if this packet now
travels much faster than the packet that
was sent before so that's one of the
problems you can run into what happens
is Zoe gets this first change the second
change that animate that's the insertion
at the document beginning then we set
the initially first change arrives also
at Zoe but gets inserted at the wrong
position and that is because this change
moved all the index positions that
insertion a expected further to the
right well of course this old you know
this insertion at an exposition a that
was generated on an old document state
does not know any of this and still
inserts of index position eight we're
actually it should have been moved
further so this is let me say fairly
easy to solve if you just briefly think
about it in order message sending and
reception has been solved by other
people by network protocols so you just
use TCP TCP takes care of sending stuff
in order and receiving stuff in order or
you can make life even easier build on
application level protocols that builds
itself you know again relies on TCP so
and if you if you're really really smart
you use the clips communication
framework because that provides for an
abstraction and you're absolutely free
to transparently change the provider the
communication application level provider
that you use for your shared editing
session for instance you could use X and
PPS to have encryption you could use
skype for the same type of communication
so another challenge that is not as
easily resolved is first of all are one
of the requirements we have with this is
we want text editors to be responsive
that's what we've been used to forever
right I mean what we have here is
concurrent edits to a shared resource
which is the document now just picture
just imagine well sink renewing strict
locking on the document would never work
I mean if you have to want to type
something but still have to wait for the
negotiation happening to the remote side
and then freeing up your document again
nobody's going to use that and actually
I doubt that it's usable for interactive
text editing sessions so local changes
need to be applied immediately another
problem network latency so messages will
cross on the wire when you work like
this and when you do when you
immediately apply local changes to your
local document state and communicate
over the network which again introduces
slowdowns then you have an incredibly
high probability for conflicts for
messages just crossing on the wire and
let's have a closer look at such a cross
on the wire conflict and I again insert
something at index position a
communicates the change at the same
position i generate this insertion at
index position a Zoe inserts something
at the beginning of the doctrine she has
incorporates it to our local document
that change gets communicated over the
wire ends up in Anna and let's review
this is this intention preserving mmm
and I wanted to have something so we
wanted something at the beginning of the
document okay it lands there that's nice
and I wanted something in the middle of
the green section that's also nice okay
that very much looks intention
preserving it actually is but what
happens here again same type of problem
as we saw before we have an operation
that arrives at Zoe's site which does
not know anything about this insertion
at 0 which
did a change did an update on the whole
document that affected index positions
that affected index positions that
insertion a actually is dependent on
since they happened at a lower index
position so what to do how to resolve
problems like this there is a mechanism
which I've dubbed which actually others
before mew have dubbed operational
transformations and it's supposed to
take care of issues such as this when
you have operations a locally applied
operation and an incoming remote
operation which originated from the same
documents state that means they the
documents don't die diverged by more
than one operation then you can apply
the operational transformation on the
incoming operation in order to yield
another transform version of the remote
operation that you can apply directly to
your local document that's what this
slide summarizes and also says so first
of all we have to think about how do we
determine that these two different
operations don't diet verte by more than
or actually come from the same document
state that's actually fairly easy you
stamp each locally generated operation
prior to sending it out with a counter
your local document manages two counters
it's locally applied operations and it's
remotely or received remote operations
and actually these two simple counters
are enough to communicate state which is
good because it's simple it saves you
from introducing bugs yourself when you
realize stuff like this so local
operation count remote operation count
these are enough to communicate state
let's read
yes it is it has a very good question i
would actually ask you all to save your
questions to the end but no no worries i
didn't say that and it is enough because
when you extend this case i mean the
first realization or incarnation of cola
just takes care of the two-way case but
you can actually do a virtual two-way
extend it to an end way and it's you
have a hub instance and then all the
other others think that they're engaged
in a two-way communication and the hub
makes sure that no changes coming in get
replicated to everybody else so
everybody thinks it's still two way all
right but that's a topic of its own and
i'm not going to cover this in detail in
this talk since this is all to wait all
right so we compare the counters on
incoming remote operations with the
conflicting already applied local
operation then we use the cola
operational transformation we put we
input the conflicting incoming remote up
they already applied local up we get the
updated remote operation and that is
ready for application at our local
document so and since this is all very
abstract when I just tell you this have
let's have a look at the diagram that
visualizes this again Anna's edit
insertion same time Zoe doesn't know
another insertion cross on the wire
happens again and now we have this I've
dubbed this co-opt which just means Cola
operational transform actually it's not
even called that in the code anymore but
you know abbreviation so again what it
what is supposed to go into this what is
supposed to be transformed well it's the
incoming remote operation and it's the
locally conflicting operation and what
are we supposed to get here what is this
operational transform supposed to yield
here well fairly easy we saw this before
we knew that you know when you insert at
a lower index position than the
conflicting change then you won't have
to update anything that's okay since
this insertion did not in any case move
those in indices all right so that's
exactly what we do no update necessary
everything's fine here so what happens
here we have another operational trance
here are the remote operation is Anna's
operation Zoey so operation is the local
operation and now let's think about this
what should happen insertion it in next
position a is what we wanted operation
is coming in but we have moved the
indices by a length of purple operation
that's so we generated so that's
probably the next index right so we
should have insertion a plus L where L
stands for the length of the purple
operation and when we do things like
this then voila we have the can we have
a consistent document stayed and we have
intention preservation so this is a
little pseudocode because what I showed
you is you know very simple case one if
they sing first of all it's an insertion
versus an insertion it's not an
insertion vs. and deletion it's not a
deletion versus an insertion it's not
too deletions against each other because
all of these cases are more complicated
than this is and once you figure figured
out what operations are you are
comparing against you still have to see
where the indices are and decide how to
update those indices and what we did is
yeah we have these you know either you
have a lower local op is at a lower
index in that case you have to move the
remote up to a higher index if the local
op is at a higher index you don't have
to do anything to apply the remote
operation locally so what this gives
though is we have a combina
combinatorial explosion we have to when
you implement you know some kind of real
time editing mechanism of your own
because Cola right now is text editing
as I said but it will be possible to we
will abstract an api out of this it will
be possible for you to you know use this
model of optimistic concurrency control
optimistic because you first apply stuff
and then you worry later to your own
modeling in real time shared editing
cases and applications like for instance
building graphs or uml diagrams and I
say combinatorial explosion because you
have to determine atomic operations like
for instance deletions and insertions
eclipse the whole editing or document
update
mechanism actually has another notion of
a replacement that would be a third
operation now when we think about this
all of these atomic operations they have
to be somehow you know you have to
define proper transformations for these
so if you have two atomic operations
that means you have four cases right you
have two possibilities basic
combinatorics two possibilities for the
first operation to for the second if you
have three then it's three square and it
is nine and you know gets worse after
that so the fewer atomic operations you
settle on the better for you and model
compound operations such as replacements
as if you can other atomic operations
like for instance insertions and
deletions a replacement in the case of
Cola I've realized as a deletion
followed by an insertion and that just
works wonderful all right so this is
just giving you know some asymptotic
notation so that it looks all more
serious but it's actually not really
hard so the cases we have to think about
is we have a number of atomic operations
square I explained why and that's still
you know o n square no big problem there
then I showed you the pseudocode with
the NDC checks with the index checks
that's always three for text editing so
it's a constant it doesn't change
anything actually about the complexity
and now comes the good part good or bad
depending on your viewpoint for me was
bad because I was implementing stuff
realizing this right really writing the
code and this is not a runtime problem
this is an implementation problem you
will just you know your code will be
terribly bloated if you come up with 50
atomic operations if you just come up
with two you don't have to cover that
many cases and things will work
perfectly and thank God it's not a
runtime problem because just imagine
having n square complexity that you know
every professor will tell you and your
boss to is very very bad for you the
company and the safety of your job I
guess so okay it's linear complexity by
the way so doesn't hurt really at
runtime so the fewer atomic operations
the better now we have another case
and this case is fairly interesting this
case is the one case that I did limit
from my talk and distilled a little just
to convey the basic idea and the basic
solution we've realized that or I've
told you that the operational transform
the transformations are defined on
operations that are the Djinn have been
generated on documents that did not
divert by more than a single operation
now what do you do if you've actually
applied five operations a number of
operations on your local document and
the remote operation on your way to you
did not know does not know anything
about these in you know changes that
happened while it was traveling you have
to have some kind of mechanism some kind
of resolution for that type of problem
so this is recapping what I just said we
have the generation of multiple local
changes while the remote operation is
still traveling so upon arrival of that
remote operation the local doc has not
just changed by single operation but by
a whole slew of operations so the
precondition for other operational
transformations is not met anymore let's
have a look at that what does that look
like we have an insertion that Anna
makes Anna likes and exposition a I
could tell so she inserts stuff again
Zoe does the same and now Anna's change
of course gets communicated gets
operational or you know has that
operational transformation we talked
about and this works actually you know
we've talked about this this is easy to
do divergence by a single operation you
can apply this transform this and apply
this directly and everything is fine
Anna does something else before she even
receives that insertion at put index
position Z she does an insertion at a
lower position V in corporate
incorporates that change communicates
that change when that change at some
point arrives at Zoe's local document
still the only operation that insertion
V does not know off that Zoe generated
is still the single insertion at an
exposition see we can again apply an
operational transformation and can apply
this and it's all intention preserving
we have insertion a at the red position
in
at an exposition be an insertion Z stays
at the same place but what happened to
Zoe's insertion Z on its way to Anna
well it traveled really really long and
it arrives at Anna's local document
after anna has executed two local
operations can we apply upper an
operational transformation unfortunately
no we cannot so what are we supposed to
do questions so far by the way did I
lose somebody on the way no okay alright
so let's have a look at the resolution
because the resolution is actually not
that hard it just tastes you know a
little thinking about it so we again
execute an operational transformation
and we do that as we did before with
insertion Z and insertion a this will
yield a new opera transformed operation
add another at an updated index position
and we call this purple star insertion
at index position X star and where x is
the position Z wear purple was supposed
to go to plus obviously the length of a
and now we will think about can we apply
that purple star operation directly to
our local document state and the answer
is unfortunately no we cannot because
there is insertion V and that again
moved index positions so what to do now
well we're being bright we just use
purple star for the next operational
transformation and transform this before
applying it locally against the other
operation it's conflicting with and that
yields purple to Star and Purple to star
it gets another update index which is
why and why again is the updated index
from before X plus the length of the
gray operation insertion it and
exposition V and now that we have this
we can actually execute the right the
remote operation on our local document
state and get consistent documents once
more and intention preservation so now I
will you know just quickly recap and
tell you about additional details that
I've
for this talk because I thought you know
time would be running out much much
faster time did not run out as fast as I
thought but again introducing these
details would just blow the top blow up
the talk as i said i will give you
pointers to more documentation and if
you you know if you're interested in
this i'd suggest you have a look at that
so what you have to do actually in order
to be able to do these operational
transformations over several locally
applied operations that are conflicting
is you have to manage a local q of
unacknowledged operations obviously you
have to have them somewhere you have to
know which operations to have not been
received by the other editor by zoe and
our examples in order to know what you
transform against so you have to add
local operations as you apply them to
your local document to your queue and so
that the q does not you know at some
point run or your machine does not run
out of memory you have to remove these
local operations if you have to remove
them when you see at this via the state
of operations communicated from Zoe that
they that the operations in the queue
have been implicitly acknowledged like
for instance if Zoe sends you another
operation and that has like a counter of
Zoe insertion has a remote operation
counter that's their operations she
receive oh god this would give a sudden
end to our presentation but we saved it
yeah I got it so um where was I yeah if
the counter says okay i have received
five operations from anna and you get
that operation in c hey my local q the
most recent local operation i've
generated i have in my local q has also
local counter of five then you know hey
five and five equals so that remote
operation knows about my local operation
state and you can empty the Q so that
was that another issue that I ran into
see I feel dealt with these algorithms
in 2006 then I've done a lot of other
stuff for like one and a half years and
just forgetting made I came back to this
and thought okay would be a nice feature
have lets you know finish this let's
update this make it Ganymede ready and I
forgot about this essential part of the
algorithm which meant that 30 hours
before the code freeze before the
Ganymede code freeze you had me hacking
30 hours and scott knows this because he
slept during that time and then woke up
and then we did the test sessions and
everything so i totally forgot about
that you have to actually you have to
update the operations in your local q of
your local operations as you transform
them against remote incoming operations
so me saying this like this does not
have to ring a bell and not have to you
know not be very very clear but again if
i would explain this it would just you
know double the time probably but if you
ever think about implementing stuff like
this read the scientific papers once
more and if you do the you know if you
do your own version of Cola
synchronization then you know keep this
in mind bear this in mind there is this
tricky detail don't forget about it it's
the virtual update of queued up local
operations and I call it virtual because
you update them in the queue but you
actually don't apply those changes to
your local document anymore yeah column
to you read the paper the project lead
on the papers okay you really want to
have the calls all right so then it
helps to introduce a notion of state
space graph which you can do then you
see where you you know how to traverse
the all the possible document states and
everything but again that you need once
you start fiddling around with the queue
and we're not doing this so what should
the future bring and this is actually
where you come in try out the feature
please please please try it out I think
most of you I guess will like this and
there will be things especially
usability issues since you know if you
do a 30 hour hacking session usability
is the very first thing that you save up
on as a developer so find these issues
and just either drop me an email comment
on my blog send us an email to the ECF
dev mailing list and you know either
report bugs or submit feature requests
one thing
that is obvious that we should do at
some point is you know have more than
two session participants another thing
is right now we're sharing single
documents would be cool if you could
share your whole document and the thing
is actually Cola wouldn't not even have
to be changed for this it's all the
surroundings all the session management
and all the sharing and sending over of
the other files that needs to be changed
because what you would have is you would
have a cola synchronizer for each of
these editors so that's something that
would work now so that's something that
I on the one hand predict is not going
to take long on the other hand i'm still
a college student i have finals coming
up so yeah you might have to wait until
August Oh college student in Germany
that's why it will take a while so and
then yeah another thing we will have to
do are thinking about doing and that's a
refer I've referred to this couple of
times during this talk is you know
extract an API make it possible for
others to implement other editors not
just text but also graphics or graphs
yeah that's the bright diagrams anyone
then deeper integration with eclipse
that's something I really really want
that's something we will have to talk
about with the UI and platform people on
the other teams deeper integration means
you know would be great if you could see
where the other editor is you know see
multiple cursors that's great or C high
Lighting's you know if I want to point
out a certain region in the code I would
very much love to be able to highlight
that and that highlight getting
communicated and marked in the at the
remote site so yeah Scott can talk a
little more about this but then again I
did manage to fill up time before we
have questions that's the resources so
what I suggest is okay drop by my block
drop by scotsblog you can have a look at
the ECF pages and then there is this
wonderful screencast well actually it's
very simple it just shows you know an
eight-minute editing session that I did
with my hacking pal tongue in Germany
before leaving for amount view three
days ago and that's the exciting thing
so apparently we've struck a nerve with
this project because
I just uploaded this on vimeo and it has
more than it got more than six thousand
views in six days I mean it doesn't even
feature cats or you know cute hedgehogs
or anything it's really just me I mean
crazy and shared editing alright so so
much for my talk hope you all enjoyed it
and hope you're all fired up to try this
yeah and questions yeah great questions
what makes up an operation you send
something over there okay I'm just recap
repeating this for the mic and for the
recording so what makes up an operation
is it single keystrokes is it something
else actually it is every change to the
document so and that's it is a very good
question better than you might suppose
because for my google summer of code
project I just implemented this to work
on single key strokes which is not that
cool when you copy and paste stuff
because that totally screws up your
whole state model well that works now
you can copy and paste code you can
delete single characters you can delete
whole sections of code all works so a
change any change to the document gets
wrapped up in a up into an Akula update
message and gets stamped with local and
remote operations counters and sent over
the wire
chicka chicka files for this awesome
cool yes you have the same file systems
will check right check it out on both
sides so okay oh I wanted to say is
right now it's not integrated with
anything beyond this the focus for this
effort was you know get the
synchronization right you see I wrote an
internal when I did my internship at
Google which actually also has been open
sourced a peeper force eclipse plugin so
that's a team repository provider and I
would suppose that you need to you know
have have to integrate these somehow so
but it's not integrated right now team
repository providers mpus Scott you
wanted to say something like that
doesn't area where we definitely are
planning work we've already got to
answer the questions is to integrate you
know version control whatever provider
subversion CVS whatever with basically
team a PR and we can do that pretty
easily because i do have sort of other
code that allows people to like sort of
remotely launch remotely tell someone to
what you know oh oh scotton are you have
to say it all again you guys could hear
me good you know yeah Ian's nodding yes
I'll leave it that but yeah so
integration with version control is is
definitely high on our list we were
getting to the point now where we do
these things separately basically and
will now be start putting them together
conceptually how's it working both users
have a checked out
I think that's a really good use case it
probably won't be the only one that we
deal with so I mean that's I'm sure a
frequent one we might have one where it
you know if it you don't have both
parties have a checked out already you
know one party is asked to check it out
rather than actually sending the state
across like we did here and you know
maybe even do something like you know
merge if necessary you know basically
guarantee that they have a consistent
initial state
if it doesn't do any innovation with the
internal version 8 stuff so you can go
back or like so big it can tell who
added what okay so the question is does
it do does it have or feature any kind
of integration with the Eclipse
versioning mechanisms and it doesn't as
I said right now all it does is exactly
what i present it it's you know the
synchronization and making sure your
document and editing session doesn't
blow up but these are all good ideas and
I would really really suggest i mean the
simplest thing is just drop me an email
i will make sure it gets in at least
into the bugzilla if or it's fixed or
just open an enhancement requests on the
powder so I know what people are used to
that that's a that's also a good way I
mean we'll do it for you if necessary
that's way go ahead Kelley
so the thing is if you do a rename which
is right now limited to the 21 file then
obviously these would be document change
events well I would hope because if they
are document change events I feed all
document change events into the cola
synchronizer so anything that is a
document change event or triggers one
goes into the synchronizer and get spit
out correctly which means gets
communicated over the wire gets handled
within the queue now one thing we've
come across is that for instance certain
changes like the syntax completion and
stuff like that apparently does not seem
to either trigger a document change
event or there is really some other type
of button did I didn't have time for
looking into this but that's been
something people have been asked asking
me after the screencast because I don't
use you know syntax completion and the
auto import functionality because that
just does not use this synchronization
mechanism so i will have have to make
sure that i catch those and also feed
them into the synchronizer excuse me
even though syntax this in completion
the dolphin changes right I hope they
are document change events do they fire
document change they do ultimately yeah
I mean generally unless there's a bug
like like Mustafa said but yeah I mean
one one thing to mention though is that
you know for things like metadata like
say markers I mean we can add and this
is another area where we're going into
we can add kind of the the replication
of metadata and in fact other kinds of
kind of characteristics to a model like
say you know you want to replicate the
entire sort of abstract syntax tree or
say a model which includes sort of you
know dependencies between classes rather
than just you know the source code for a
single class so you know we're expanding
kind of the notion of what the document
consists of two more toward a general
model and then we can apply the same
sort of notions of synchronization to
those more complicated models you know
that is defining a set of operations
are appropriate for that model and then
transforming them as as they change to
synchronize the replications for that
model right so you know if a single term
sticks with you after this talk it
should be optimistic concurrency control
which means you share you have a shared
resource you update this one of them
that one of the you know changers does
and then you worry about fixes there was
another question let me first have you
sir excuse me if the counters match on
both hands are the documents always
guaranteed to be yeah but some state
yeah it's Lenny verification of that oh
you have to I mean I don't the algorithm
is algorithmically proven right and you
can do stuff like that but you of course
it's one line of code to you know check
the last incoming ops and what yeah but
you know there is another thing what you
have to consider is let's imagine the
two of us coding and you just make three
changes and after that I do a hundred so
then you always get updates for me how
would I know that you have sent
something that I didn't receive or
something like that so what you want to
make sure is that the algorithm is right
and that the algorithm deals with
everything that you know that you
receive and that it ultimately yields
the correct results and then also the
ECF kind of abstraction layer also
guarantees things like reliable delivery
so or failure detection in the case of
you know sort of remote process failure
so that you can you know recover back to
some unknown good state first there and
after that he returned yeah
you were talking about their great team
fired by the way I wish you the best of
luck we work remotely and also work with
other people a lot of times if you I
don't really want them to see my work
spaces that so much as I would like to
shadow there's no it's theirs is like
the master so to speak that they see
that you know any changes that gets in
there and obviously if you have any team
problem it better be configured
correctly over there is any thought we
put to that um I mean the answer is yes
I mean you see a question first well the
question was has there been a thought
given to kind of replicating someone
else's work space basically it sounds
like basically to see what the state of
their workspace is is that correct so
yeah absolutely and we sort of are doing
work on so replicating pieces of the
workspace we haven't I mean the use
cases for that they're a bunch right so
say you want to do a review and you sort
of want to get all the kind of state of
various source files and whatever else
is happens to be in the workspace for
say one or several projects and have
that feed into the review well like say
a review scenario would dictate kind of
certain things about the availability of
sort of read verses write access to
those resources and you know who has
access to changing those resources so
you know we are that the API is that ECF
consists of are consistent with you know
kind of supporting those different use
cases and we're sort of exploring which
ones are the most valuable given kind of
the team support for distributed
development and so you know we would
love to have your input on kind of which
ones you find most valuable and which
ones you'd like to see us address first
because we have to sort of make
decisions about which ones to focus on
and which ones not okay more questions
you had one as well
unresolvable helmets between two nations
not with Cola not with you know once we
abstract out an API it's up to you to
define the proper operational
transformations so if you forget
something or if you or if something wit
goes wrong with your set of atomic
operations and you've forgotten
something or model the compound
operation formed it up from the wrong
atomic operations then obviously stuff
will go wrong but with text editing
that's solved by Cola itself in this you
know exemplary implementation so behold
add go to the same place or yeah that
works so if we both you know work at the
same place or even worse think of harder
cases like let's say you're deleting a
patch of texture you know like character
one to ten and I insert stuff at
position 7 to 10 so that moves your you
know the characters you actually
intended to delete further in the
document so what's supposed to happen to
the deletion to the incoming deletion to
my document where actually inserted
something in the middle of the section
where the deletion is supposed to occur
well then you have to split up the
deletion and you have to think about
these cases that's why i said it's very
very important that you have very very
few atomic operations otherwise you will
be dealing and implementing for a long
time well and there may be other models
like say a graphical kind of model where
there are situations where something
occurs that if you resolved it it would
be very jarring to the user all right so
you may at that point want to say oh you
know basically i give up to the user you
need to sort of resolve this conflict
somehow now for text that's not
necessary because cola kind of resolves
things in it in a natural way but for
other model forms it may be</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>