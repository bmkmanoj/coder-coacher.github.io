<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Topics in Programming Languages: Java Puzzlers,... | Coder Coacher - Coaching Coders</title><meta content="Advanced Topics in Programming Languages: Java Puzzlers,... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Topics in Programming Languages: Java Puzzlers,...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wDN_EYUvUq0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">or counterintuitive behavior and it's
your job as the audience to guess what
the program does so we'll pull you after
showing the program you will tell us
what it does by show of hands
multiple-choice typically four choices
and then we reveal the mystery but it's
not all fun and games with each of these
puzzle is immoral and the mole tells you
how to avoid whatever trap or pitfall
was displayed in that particular program
in typically in these puzzles
presentations we've discussed only the
language and the core libraries mainly
Java dot Lang and Java dot util but
today since I'm a special guest we're
actually going to be throwing a few new
things into the mix and you'll see them
as we get to them excellent why don't
you why don't you give me the first one
okay so I've got a puzzle for you the
joy of sets so we're going to take a set
and add things to it and remove things
from it and at the end we asked how big
is the set okay and the question is what
does this program print well this
doesn't look too hard at least it's
short
in fact it's a set of shorts and let's
see we we initialize it to a new hash
set of shorts that's kind of the basic
set implementation and this is the sort
of the idiomatically correct way to do
it where the type on the left hand side
is set on the right hand side the
implementation type we iterate for I
starts at zero and goes all the way up
to 100 actually 99 because it's I less
than 100 and then we add that element to
the set so first we add zero and we
remove I minus one so I guess that's
like the previous element in the first
case we're going to try to remove
negative one now the set doesn't contain
negative one so that's a no on second
time through the loop we add one and
remove zero leaving one in the loop next
time we add two and remove one leaving
two so each time who loop we only have
the most recently added element mom
always said to clean up after ourselves
yes that appears to be what we're doing
here so after the 99th iteration the
loop the set contains 99 and no other
elements what we're printing is the size
of the set which is 1 so I would have to
say this program prints 1 well let's see
if that's one of the options yes indeed
it is and the question is does this
program print 1/100 does it throw an
exception or none of the above and that
could mean you know that it varies from
run to run but there's one thing it
could not mean yes that's right
so sometimes in the past we've had Java
puzzlers that don't compile and we have
found that the audience gets very very
angry when this happens so this year we
make you a pledge a space cadets honor
space cadets honor all a puzzle grams
come come hi
so yes so now times for you guys to
decide does this program print one one
hundred throw an exception or do
something else hmm and you're all
required to vote this is not something
where you're allowed to simply sit on
your hands right it's okay to be wrong
many people are okay we think we're
ready what we're ready all right
so how many people think the answer is a
that this program prints one okay how
many people think that this program
prints 100 B okay how many people think
that it throws an exception okay and how
many people think that the answer is D
none of the above
okay I'd say that was about evenly split
between a B and C roughly yeah I would
say so well let's find out what it
really does shall we okay so what does
it actually do it prints one hundred one
hundred yes oh well why does it do that
it removes all those elements ah the
problem is is that it adds shorts to the
set but it removes integers so those
integers let me get another look at this
okay so the problem here is that I minus
one is an INT valued expression wait a
minute i's is short and and one is a
little tiny number why is yes but
whenever you perform any sort of
arithmetic operation on any anything
that could be an INT then the result is
either an INT or possibly along if
you're working with long but any served
combination involving shorts bikes or
anything any sort of integer operation
with that produces something of type int
and so this int computation is going to
get auto boxed into an integer object
and the short that contains the value
one and the integer containing the value
one are actually distinct objects that
do not compare as equal and thus if you
have a set that contains the short one
and remove the integer one it is a no op
well that's all well and good bill but
wasn't set parameterised that is genera
fied in 1-5 yes it was it was genera
fied and 1 5 and you can see we defined
this as a set of short short but
shouldn't the compiler complain when you
try to remove an integer from a set of
shorts you might think so and you would
be wrong right so it turns out that for
the set if you try to add something to a
set of short the compiler enforces the
restriction that you can only add a
short however the remove method for a
set of e allows you to remove anything
from it you can remove a string buffer
you can remove a string you can remove
anything you want but it's not a bug if
you try to remove the wrong kind of
thing from a set well its type safe
right and and to some extent that was
one of the things that designed how
things got Jeannette refined it turns
out that there are some cases in which
you might want to iterate through a
collection of objects and remove
everything in that collection of object
from the collection of shorts and since
there and in order to maximize
backwards-compatibility was decided that
there are a number of methods such as
the remove also very important the get
method on a map where the type of the
parameter is object if you have a map
from strings to strings and pass it a
string buffer with get that will compile
and it will return null because there
are no string buffers in a map from
strings to strings in fact by the way
when we were genera fiying the
collections libraries we first attempted
to enforce that restriction and we found
that it simply didn't work there were
many reasonable programs that just could
not be genera fide if you were only
allowed to remove a tea from a
collection of teas for example suppose
you want to intersect a list of numbers
with a list of Long's that's perfectly
reasonable you know you're kind of
going to take out all the lungs or or
you know get all the lungs from the list
of numbers it should compile and it does
great so what can we how do we fix this
one well one way you can do it is you
can cast this results result back to a
short a primitive short and then this
will get Auto boxed into a short object
and therefore the short object the short
one will find the matching short one and
it'll actually remove the object that
you added to the set in the previous
iteration and so then the program would
print one then it will print one and my
answer would be correct yes it would
great once the program is fixed yes and
and and what can we learn from this one
all right so first off that there are a
number of methods in the collection
classes that even when you supply
generic types they take objects as
parameters and you have to watch for
these so the remove method takes object
map get and so forth you just have to be
careful about that integral arithmetic
any math operation involving any sort of
integer value results in always an inter
along never a byte a short or a
character and what that means by the way
is that byte short and char are sort of
inferior types you can have things of
that type once you operate on them they
always turn into intz so avoid mixing
types you know instant shorts that can
bite you in a number of ways at a pun
yes and avoid short avoid interfer int
among basically the only really
compelling application for shorts and
your programs is if you want to have a
very large array of shorts you really
buy absolutely nothing by having local
variables or fields of type short it
doesn't get you anything other than
confusion and by very large I think bill
means very very large because you know
suppose you've got say a million shorts
is that large well you know I guess each
short is two bytes so a million shorts
is two megabytes but I don't know about
you I by my memory and gigabytes these
days some people run java on small
platforms oh yeah that's true so so
those people should worry about it okay
so that was a great problem bill but now
I have one for you all right
yours was the joy of sets - more joy of
sets okay and yours my mind is sort of
superficially similar to yours yours
considered sets of shorts mind considers
it sets of URLs so what we do is we have
a list of strings they are my favorite
URLs and we we make a hash set we put
the URLs into it and then we print the
size so my question is simple what does
this program print and why are we so
preoccupied with size okay question so
what does this program do we've got a
array that's going to be initialized to
contain six different strings Java
puzzlers Apache to snort Skybar yes
snort it's the best okay yeah josh has
some interesting favorites Google Java
puzzlers now that's a repeat of this one
the findbugs website and the university
maryland website okay so we've got these
I'm getting to Maine and we create a set
of URLs and in this slice with a hash
set then we go through all of these URL
names your strings and so for each
string we create a URL object and we add
that to the set and then at the end we
print out what the size the favorites
are okay so there are six strings but
they're only five unique ones I mean and
so I'm going to guess that this program
create five URLs and when you put things
into a hash set duplicates find
themselves so I'm going to guess that
the answer is five five that's that's a
reasonable guess let's see if it's one
of your choices yes your choices are
four five and six and of course the
ever-popular none of the above
which as I remind you could mean you
know a different number could mean
throws an exception could mean varies
from run to run it could mean all sorts
of things so audience
how many of you think this program
prints choice a for you give me a little
bit more of a moment to think about it
you guys ready that's not a hard problem
all right
nobody four four how many four choice B
five what's not your choice knows my
tools got about five of you how many
people four choice C six ah the great
bulk of you and finally choice D the
ever-popular none of the above now a
smattering but this is a clear win for
choice C six then let it let us see what
this program actually does shall we well
as a practical matter it does print for
if you run this on for sorry if you run
this it will print for if you are
connected to the neck and you Googlers
are always connected to the net so it
will print for if you look in the
specification you'll find that the
answer is it varies from run to run and
as as for the intuition how is that
possible
URLs equals and hashcode methods are
completely screwed up it's as simple as
that let's take a closer look here's the
deal
these two URLs may be different Java
puzzlers calm and Apache snort sky bar
dreamhost calm but they resolve to the
same IP address and so from the
perspective of the marvelous and
magnificent URL class they are equal if
you look at the specification you will
find out that two URL URL objects are
equal if they're reference equivalent
hosts and furthermore two hosts are
considered equivalent if both host names
can be resolved to the same IP address
and the other kind of interesting
factoid here is that since hosts
comparison requires name resolution
checking if two URLs are equal can block
is that not delightful
but I mean so apache2 snort and Java
puzzlers if you actually go there in a
web browser you see entirely different
websites yeah they call that virtual
hosting and it turns out that the equals
method for URL is incompatible with
virtual hosting because you know when
you are l was added to the platform
which was like 1993 there wasn't a lot
of virtual hosting going on those were
kind of in the early days of the web so
how do we fix this one well it's really
easy URL is broken so don't use it use
URI instead which which is a newer class
and and much better designed it turns
out that the equals method for URI is is
kind of structural it's just based on
the text here it does a little bit of
canonicalization so for example it
strips out extra spaces and so forth I
think it might even do capitalization
does it I'm not sure but anyway it is
well specified and it does the right
thing so if you run the same program
using URIs instead of URLs it will print
out five because of the fact that Java
puzzlers is on the list twice so it is
equal to itself but the others are all
distinct even though two happened to
resolve to the same IP address
notice by the way that instead of
calling a constructor we have a static
factory here because it turns out that
static factories are just generally
better things than constructors and
since this is a later class they added a
nice static factory to it so using and
what can we learn from this one well the
main thing that we can learn is because
URLs are broken you should not use them
as set elements or map keys in fact you
pretty much shouldn't use them much at
all it turns out that they're equals and
hashcode methods simply aren't well
defined and they disobey the general
contracts for equals and hashcode one of
the contract stipulations says that the
quality and the hash code of elements
should not change over time unless you
change the elements but in this case
whether or not you're connected to the
network can change the behavior of your
program so if you experience an
intermittent web connection failure but
that never
misty you guys right but if you do the
hashcode of your object can change is
that horrible well I could also measure
in Google you guys might create some
large hashmaps of URLs and that could
create a serious Network load and you're
trying to do some tests or stuff it's
true so just don't use URLs as elements
or map keys use your eyes instead and if
you need to have a URL because some
other API requires it simply call the
method that allows you to view a URI as
a URL and that the general message for
API designers here is that your equals
method should never depend on the
environment when you're checking if two
objects are equal it should involve
quick tests of in-memory objects
simple as that all right well that was a
good puzzle now I have one for you a
racy little number whoo so we're
introducing some new things here which I
think have never been seen in a puzzler
before j-unit and concurrency so we're
basically going to create a test case in
which we create a thread which is going
to check that a number is equal to two
and we're going to set the number start
the thread incremented join ology work
about okay let's take a look at it so
let me see we have a single test method
by the way I don't see any print
statement so what am I supposed to tell
you here
well okay so this is j-unit and Jana
doesn't depend on print statements
rather you write methods
test methods that throw an exception if
something goes wrong so you want to know
if the test passes or fails right well
why don't you ask me that right and so
the question is does this test case pass
or fail okay let's take a look at it
then so we set number to zero we create
a new thread whose run method invokes
the runnable whose run method is just
asserts that the number is equal to two
so the question is will the thread see
number as two or some other value if it
is two that the test passes
and if it's some other value it fails
right so let's say we start out with the
number 1 then we start the thread then
we increment the number and finally we
wait for the thread to complete right
now the thing is that when you start a
thread
it doesn't necessarily start right away
so although this number is actually
after the start method I think the
number could get incremented to 2 before
the thread actually runs so as a
practical matter I think this program
will always the number will be equal to
2 by here so the assertion is going to
succeed and I think that the test will
always pass all right this is true let's
see if that's one of the options so the
question is does this gene test always
fail sometimes pass always pass are
always hangs you know concurrency always
got to worry about hanging all right so
fail sometimes pass sometimes fail
always pass or it always hangs give
yourselves a moment
okay how many people think that this
test case always fails remember how many
people think that it sometimes passes
and sometimes fits okay how many people
think that it always passes okay and how
many people think that it always hangs
all right that looks like a clear win
for B yep so let's see what this program
does in fact do it always passes I got
it wrong nothing yes you got it right
okay
the problem is is that j-unit doesn't
get to see whether or not the assertion
fails it doesn't it hasn't looked let's
take a look at that code okay J unit
reports that a test method fails if the
test method throws an exception right
and these assert equals methods test a
condition and if the condition is fail
the call to assert equals throws an
exception the problem is is that this
assert equals isn't occurring in the
same thread that invoked the test method
and thus what will happen is that this
exception will simply propagate to the
top of the stack and then get printed on
the console but the J unit test harness
will see that the test method returns
normally and will report a little green
dot saying that your test method passed
every single time well that's that's
terrible
so you're saying that
the test method will always succeed
whether or not the tests succeed whether
or not the assertion passes or fails the
test method will always succeed okay now
it turns out that the assertion will
sometimes pass in sometimes fail so
those of you who had that intuition
we're halfway there there was a little
little clue in the positives called a
racy little number because it is in fact
a race condition so how do we fix this
travesty
okay well unfortunately this is not one
of those one-line fixes the problem is
is that getting what you need to do is
if in j-unit you need to start any
threads and you want to report an
exception thrown in those threads as a
failure you need to have some way to get
the exception propagated back to the
right guy
and so we're just going to declare
fields that will declare an exception or
error if they're thrown and then in the
teardown method for the test
we'll check if either of those are non
nil and basically all the threads were
going to start if an exception occurs
they'll shove it into those fields and
then the teardown method will basically
check was an error or exception thrown
by any of the threads that we started so
this is sort of what we set up outside
and then each individual test method we
need to do something else
next slide please and then here we
basically need to in a run method we
need to catch any exceptions that wind
up occurring and store them so that when
the main thread the thread that called
the test method will also be the one
that calls the teardown method these
errors will these exceptions will wind
up being propagated into that thread and
therefore j-unit will see it and will
get reported
okay the question
the reason is is that then you would
have to go back to the teardown
yes the question by the way for for our
viewers is why didn't we use throwable
why do we have two fields one an
exception the other an error and while
you're at it you might as well answer
why they're volatile okay so the reason
is this way we can declare teardown as
throwing an exception in general I
dislike declaring methods that throw
throwable you know and they're weird
things like you can declare things that
are throwable there are neither
exceptions nor errors and so forth these
are volatile partially because I'm a
little bit over conservative this is a
field that could potentially be updated
simultaneously by multiple threats right
and thus whenever you have a field which
could be simultaneously touched by
multiple threads at least one of those
updates is a right make it volatile in
this case two people competing the store
different values it probably wouldn't
actually impact anything but better be
safe wise advice okay so now that we
know how to fix it what can we learn
from it okay so basically j-unit does
not support test cases in which multiple
threads have to coordinate if you want
to do that and want to get errors
reported back from any of the threads
you create you have to roll your own or
find somebody else who's already rolled
one okay and perhaps the scariest part
of it is it gives you a false sense of
security you can write something that
looks like it ought to fail but if it
fails in the wrong thread you'll never
see the failure um please hold your
questions till the end of the talk just
because it's kind of a long talk but do
remember them and we will answer them
okay so that was a fine puzzle and now I
have one for you just a moment here this
one sartorial effect because this one's
about Elvis it's called Elvis lives
again
people who have been to our
presentations before know that we have a
thing for Elvis because Elvis is a
singleton there's only one of him so in
this program funny I think I've seen
more than that in Vegas
RL but do you know they were Elvis
anyway so here's the deal I think we do
live in a mono Ella vista Kuna verse and
here's how we end
or that we have a public static final
Elvis called Elvis and we initialize it
to a new Elvis with a private
constructor so that's the standard
singleton pattern and then what we do is
we keep track of whether Elvis is living
or dead it turns out that the tabloids
care about this I don't know why so what
our program does is it simply prints out
hound dog if the king is alive and
Heartbreak Hotel if he breathes no more
so tell me Bill which is hound dog or
Heartbreak Hotel all right
so this is going to get our Constructors
this the main method we ask see if he
lives and lives returns the value of
alive alive is a variable to this
initialize to living and living is
initialized to true and this one there's
trinary operators always have to look at
those when you do those but this
evaluates to true so hound dog Elvis
lives
hound dog okay well let's let's see if
I'm sure that is one of your options
since there's only two sensible options
here
we got hound dog Heartbreak Hotel it
varies from run to run or the
ever-popular none of the above let's
let's give the audience a moment to
think about this one
you're more muttering on this one than
some of the others yeah yeah now when
the muttering stops we'll ask
see dicks smiling I think he got it
all right I think we're ready ready is
everybody ready
time is up the Pens are down
oh well I I spoiled that one I apologize
shall we buy many people think the
answer is a-ok so since I since I
spoiled it shall we just go on fine
okay the correct answer is D none of the
above it always throws a
nullpointerexception and I apologize
that I didn't give you an opportunity to
vote so as for the intuition class
initialization is a tricky business and
auto unboxing happens when you least
expect it so let's take another look at
this I mean how did know get in there
how did know get in there it's a very
good question so here's the deal
first of all the initialization of this
program is less than perfect when you're
looking at these things which involve
class initialization you have to
remember the class initialization
precedes top to bottom and the only way
to figure out what the program does is
to basically simulate it to run it top
to bottom so what do we do here first
thing we do when we initialize Elvis is
we create a new Elvis now in order to
create a new Elvis we must initialize
the Elvis class but we're already
initializing it that's called recursive
initialization and does anyone know what
the system does when you try to do
recursive initialization shout it out it
ignores it that's exactly right it says
oh gee we're already trying to
initialize it we don't want to go into
an infinite regress
so we'll just barrel through and create
the new Elvis which runs the sole
constructor which that's empty it is
empty which means all it does is it does
the the initialization of all of the
instance fields for Elvis so where are
the instance fields well we've got one
we have alive and it is set to the value
of living and what is the value of
living true new you know it says private
static final Bowie and live equals true
so you might think it's a constant true
and always true it turns out not to be a
compile-time constant and here's why
it's because it's a capital B boolean
that's an
object reference it turns out that
except for strings object references are
never actually compiled time constants
so this variable is a final that means
once it is initialized it cannot change
but it turns out that in order to
initialize it you actually have to
execute this line of code and before it
is executed the value of living is not
true but no you see this little true
it's actually gets Auto boxed into the
capital B boolean true a rapped true but
before this line executes it is not so
in particular when we're executing this
line initialize in the alive field of
the so Elvis instance we copy living
which is at that point no into alive so
now alive is no and it's final it's
never going to get changed it will stay
no forever then the constructor returns
and we finish initializing the class so
the next thing we do is we set living to
true but it's too late we've already
used it we've already copied it into the
instance variable so it is of no help to
us and that's it for the class
initialization then we run the main
method so the first thing we do is we
execute this trinary operator Elvis
lives question mark hound dog Heartbreak
Hotel well what is the value of Elvis
the one and only no and there is only
one know by the way so I guess in a
sense it's but the value of Elvis is
else but Elvis start lives is I'm sorry
yes Elvis top lives is not I made this
mistake last time as well
Elvis that lives returns null and then
we have to turn this null into a boolean
it'll be a little bit boolean in in
order to do that we have to unbox it and
what happens when you unbox no no all
pointer exception that's called a
surprise left jab while auto unboxing
that's the problem here so how do we fix
it well what we do is if we create the
single after we've initialized the field
upon which it depends so all I've done
is sort of swapped these two lines
around then we fix the problem we
haven't done away with the recursive
initialization but it's okay because by
the time we do the recursive
initialization we have already assigned
a value to living and alive takes on
that value which is true and so it
prints out hound dog
just as bill said it would but there's a
better way to fix it why are we using
these nasty capital B boolean's let's
not write if we simply use lowercase B
boolean that is the primitive boolean's
then the behavior of the program is much
more predictable and you know generally
speaking it'll run faster if not this
program a program that uses a lot of
them so you don't want to use those
rapped values unless you have to now
I've actually kept the order the same of
the initialization of the Living Field
and avi Elvis instance but it turns out
is no longer necessary even if you swap
them it would still do the right thing
because of the fact that living is now a
true compile time constant whose value
happens to be true and what can we learn
from this one well wrapped primitives
aren't primitives so autoboxing blurs
but does not erase the distinction
between primitives and object references
capital true is not in a boolean dot
true is not the same thing as true you
should prefer primitives to wrapped
values because auto unboxing can occur
when you least expect it and it can and
often does cause null pointer exceptions
so one thing you should never do is
never use boolean as a return a capital
e bullion I should say as a return value
from a method to allow three possible
values true false or I don't know that's
just a prescription for disaster because
if someone then just does an if
statement that takes the return value
from that method that if statement will
blow up whenever or turn
No and it turns out by the way that
there is at least one method in the JDK
unfortunately that does this you know
the problem is the method predates the
introduction of auto boxing into the
language and before autoboxing you may
not have been a great idea but it wasn't
a terrible idea now it's a terrible idea
so never use capital B bullion as a
three valued return also watch out for
circularity Xin clash initialization you
can't avoid them they do occur in a
whole bunch of common patterns like
singleton and type safety Noom and so
forth but when you have one you should
make sure they even YCJA lies all the
fields that you depend on before you use
them all right well that was a good
puzzle with a good moral now I have one
for you mind the gap so we're going to
write out a file and then we're going to
read it back in skipping over everything
but the first and last byte and see what
the first and last byte work and
question is what does this program print
this is a loan program but it doesn't
imply the hard program there's nothing
object-oriented about it let's just go
over so the first thing we do is we set
gap size to 10 times 1025 is 10k and I
see the private static final int not
integer so this is a true compile time
constant which means it's just going to
get replaced by the value 10k whatever
it's used so let's find out where we use
it we set temp to create a file whose
name is gap txt and I think it throws
some numbers in there it says what this
will create a random sort of name that's
not being used okay a random name that's
not being so we get ourselves a file and
in a good temper sort of area and then
we get a file output stream on that temp
and we write to the file output stream
the byte one I guess that's an ASCII
control eh is that right yeah okay it's
not a ski this is bytes well yeah yes
but it's you're ready to a file system
so it's I don't know anyway it's it's
the byte one yes umm and then we write a
bunch of bytes in fact 10 kilobytes
Zero's because we create an array of
length 10k which is initially empty so
we write all all these zeros then we
write two that would get controlled be
correct yes and we close the file and
then we open okay a buffer input stream
of a file input stream on the same name
and that's good
because I know you don't get buffering
for free so if you want to have buffered
i/o what you do you do this wrapping
thing I guess that's the decorator
pattern right and we read the first byte
to an int and then we skip the size of
the gap which is 10k we read the last
byte presumably this is 2 this is 1 and
finally we print first plus last so
that's 1 plus 2 which was 3 last time I
checked is that your answer that fits my
final answer all right let's see if
that's one of the options ok so question
is what does this program print no
actually one thing we're actually
dealing with the file system here right
and so to avoid any questions I'm
actually going to promise you that there
are no issues with the file system
nobody else touches the file the file
doesn't go away we don't run out of
space on the disk there are no i/o
exceptions really the question is
reading writing the file works just as
you would expect and the question is
what does this program right that's
right generous of you bill yes I'm a
generous person ok so the question is
does it print 0 1 3 or it varies from
run to run ok
woman looks like they're ready I don't
see here a lot muttering so yes now keep
your hands off that button all right so
the questions take and you pay for it
all your life
all right so how many people think that
the answer is a zero smattering how many
people think that the answer is B one or
a number how many people think that the
answer is C three how many people think
that the answer is D it varies I think
there were a few people sitting on their
hands but I think maybe B one yeah yeah
I think by a hair all right let us find
out what the program actually does now
kind of press the button now you press
the button okay okay in practice it will
print one in theory it will vary from
run to run one why will it print one the
problem is is that the Skip method
returns the number of bytes that it
skipped it may decide on a whim to not
skip the full number of bytes you
requested wait wait let me let me take a
look at why would it do that it doesn't
make any sense well that's what the API
says it doesn't necessarily have to make
sense
so the Skip method as I said is declared
that it can decide to just return any
value less than you know between zero
and the number of bytes you request and
he said it like always returns one as a
practical matter why would it do such a
thing so it turns out that a buffered
input stream if there's already some
data buffered it will only skip the
amount that's buffered and won't go down
to the underlying stream to try to skip
additional bytes that's ridiculous and
so as a result yes and as a result this
will always perform a short skip and
thus this read of last won't actually be
the last byte in the file but rather a
byte in the middle of the file which
will be zero and thus first will be zero
sorry first will be one and last she'll
be zero and thus we will print one
ouch so how do you fix it all right well
it turns out there's not a one line fix
and in fact a lot of times when you find
yourself having to do something more
than a one line fix the best thing to do
is don't try to do it in place but
compartmentalize it define your own
method and so here we're going to define
a method called skip fully that will in
fact skip all the bites you request it
to it will never return a short number
of bites and if for some reason it gets
back that it skipped zero bites it will
throw an end to file exception because
that is one place where skip is
documented that if you're at the end of
file it will skip will return zero
that's the only way to find out that
you're at the end of file when you're
using skip it won't throw an exception
and so this method will always skip will
either skip the number of bites you've
requested or it will throw into file
exception can you show me how it works
yeah let's take a look at that and once
you've written this next slide well you
can't show me how it works if I switch
to the next slide I want to know how
this method works I don't believe it oh
sorry how this method sorry all right so
we take in the number of bites that
we've been requested to skip and then
we're simply gonna have a loop you know
you know how many bites left do we need
to scoop skip until I call skip and I've
asked skip this many bites please please
please it's going to returning some
value right if we return zero down
although the spec doesn't say that that
only happens under in define there's no
other logical situation which you do so
we're going to promise me that they're
going to change the spec so that it does
say that so that if this returns zero
then we must be identifiable throw an
end a file exception otherwise what we
requested this many bytes we're going to
decrement it by the number of bytes we
actually skipped and then we're in a
while loop if we actually skipped as
many bytes as we're your requested
remaining will be zero and we'll be out
of the loop and the method returns if we
didn't skipped as many bytes as we
requested we go back for another skip so
I believe that works but it's a royal
pain yes and what can we learn from it
so the Skip method is hard to use in
error prone you roll your own skip Foley
method and if you if you need to use
skip right there's a request for
enhancement
had inputstream some other thing we're
trying to do with son on this in general
if you have an API which is broken and
there are api's that are broken the
problem is once you make an API your
cast in stone it's forever right and if
you're stuck with a forever broken API
come up with a better way to call it
rather than persisting with the old use
and for API designers don't violate the
principle of less least astonishment
right I mean make it easy to do the
simple things I mean I find it hard to
pull so interesting story about skip
there are 63 places in the JDK where
skip is called and in 56 of them they
ignore the return value right so that
behavior is so astonishing that even the
people who wrote it don't believe it
right and I think also pretty clearly
the people who wrote that API never
actually tried writing any code that
uses it because if they had actually
written anything more than a simple test
case that use it they would have found
out gee this is really hard to use
correctly
why don't we redesign the ax the
operative phrase here is use cases the
way to find out if your API violates the
principle of least astonishment is try
and use it if you haven't tried to use
your API it doesn't work all right okay
well that was a fine problem and now I
have one for you this one we call
histogram mystery it almost rhymes so
what we do in this program is we have a
list of words the words are I recommend
poly gene lubricants you do I do and
what we do is we make a histogram out of
these words the histogram is of length 5
and the way we make the histogram is we
iterate over all the word pairs so we
have a doubly nested loop of words and
we pair the words together compute their
hash code choose a bucket based on the
hash code and increment that bucket then
when we're all done we add up the
contents of the histogram and we print
it out so I want to know bill what the
program prints
all right so let's see I recommend Polly
Jean lubricants there are four of them
doubly nested loops so they're total of
16 pairs including like you know I I
recommend Rome and so forth and for each
one we take the hash code of it take the
absolute value so we thought something
agnostic just to interject here bill
we're one plus word two is is string
cabinets the two so just concatenating
the strings right so we concatenate the
strings take the hash code take the
absolute value and then we take that mod
the histogram length so this will give
us a number between 0 and 4 and then we
increment the appropriate bucket okay
now at the end of doing this I have like
no idea how big histogram sub 0 is but I
don't need to know no no because all
we're going to do at the end is we're
going to go through and we're going to
sum up all the values that are in any of
the buckets right so pair count is 0 and
I go through and I sum up anything that
got added so I don't know exactly where
each pair wound up but since there are
16 combinations each combination
incremented one bucket when I add up all
the buckets I should get 16 and do this
so I sit it I say this prints out see 16
see 16 well that's a reasonable guess
let's see if it's one of the options
it doesn't even your options are a 83 B
C 16 C s and D none of the above and and
I should mention for those of you who
are too young to have to have dealt with
ascii directly that capital a is 65
decimal in ascii I'm not saying this is
necessary to solve the problem but if
you find it useful go ahead
we'll give him a moment this one's
tricky this look straight forward to me
all right I think we should move along
okay I don't they're still chattering I
don't we don't have a hard stop okay
we'd win long ass good no little red
buzzer like there wasn't Java one no no
and I can edit these things out of the
video
nobody wants to hear you chattering I'm
sorry it's it's nice chattering okay
then the chattering seems to have died
down so I think everyone knows the
correct answer no your hands up so how
many people think that the answer is a
83 we've got about a recording to vote
for something how many people think
choice B C 16 the only one poor lonely B
I'm unique I'm gonna join bill moral
support thank you
how many be able to go with choice C
okay we got another third of you and how
many people go with choice D none of the
above
smattering so some of you aren't voting
but anyway it seems to be a tie between
choices a and C is that right yeah yeah
okay
let's find out what this program really
does shall we all right none of the
above it always throws array of bounds
exception how'd that happen
well the intuition is that math thought
abs does not necessarily return a
positive non-negative value I should say
absolute value can in fact be negative
under certain circumstances and it turns
out that the mod operator that doesn't
necessarily return non-negative values
either oh and let's see this let's take
another look see these words were chosen
very very careful
now it turns out that the hash code of
the word poly gene lubricants is integer
dot min value and that the Adhan what is
special about integer dot min value well
it turns out that the absolute value of
integer dot min value is integer dot min
value well but that's negative it is
negative so here's what's going on in
the two's complement arithmetic there
are more negative numbers than positive
the idea is that you have an even number
of values right you have two to the 32
in values one of them is reserved for
zero that leaves you an odd number of
values so roughly half are negative and
half are positive but there's one
negative number without a partner
and that's integer dot min value and if
you apply the standard algorithm for
negating it it's the binary
representation is a 1 in the high order
bit and zeros in all the other bits so
to negate it first you complement it so
you got a zero here and all ones and
then you add one to it and you end up
with all zeros and one you're back where
you started negative integer dot min
value is integer dot min value and
absolute value if it finds a negative
number it returns it's negative so in
every case but one it does return a non
negative value but if we pass an integer
out min value you get out introduc min
value and then we take it mod histogram
dot length while the histogram length is
5 so you got a negative power of 2 mod 5
what does it return it's guaranteed to
be a negative number because it isn't
zero right a power of two is not
divisible by five and it turns out that
division in Java always returns
something if it's non non zero whose
sign is the same as the numerator which
in this case is negative it turns out as
a practical matter it returns negative
three and by the way it always returns
negative three because the hash code of
string is precisely specified in the in
the spec so we get bucket minus three
and we try to add one to bucket minus
three and there's your array out of
bounds exception so it never even gets
down here it turns out there is another
little trick down here it
does not print out c16 because it turns
out what we're doing here is we are
adding a character value to an int value
and what happens is they're both
integral types so when you're adding two
things of integral types you do what's
called the primitive widening conversion
you turn the smaller one the character C
into the type of the bigger one integer
so we do turn C into an integer and as I
said a is 65 C is two more than a so
it's 67 so we add 67 and 16 getting 83
so the program you know would print out
83 if if in fact it didn't have this
problem we talked about that in the
first puzzle didn't we we did so how do
we fix it well two things first of all
we do the absolute value after the mod
operator right if the first thing that
we do is we take the hash code mod
length that gives us a value between
negative 4 and positive 4 right we if we
take any value whether negative or
positive mod 5 the result is going to be
between negative 4 and positive 4 and by
the way zero occurs with twice the
likelihood of any of the other values
roughly speaking and then we take the
absolute value of that if you take the
absolute value something between
negative 4 &amp;amp; 4 you get something between
0 &amp;amp; 4 so now we are guaranteed to get an
actual array location and now the
program does end up with 16 as pair
count and notice I've also changed C
from a character to a string so now it
really will print out C 16 just as my
brother said it should there you have
and what can we learn from this one well
mapped out ABS doesn't guarantee a non
negative value
enter drop min value equals negative
itself well but you know that program is
probably okay it only goes wrong once
every 4 billion times you know I'm sure
would never go wrong while we're showing
our software to the VC no no I don't I
wouldn't go wrong then nor I think after
we sold it to an important customer
would never blow up you know for them it
would blow up when we were testing it
right if we do good tests yeah and
and this this thing which everyone calls
the mod operator it isn't it's the
remainder operator and it is defined to
have the sign of the numerator of the
first number the left operand if it is
nonzero and finally when you are faced
with this problem of translating a
signed hash value to a bucket that is an
array index you can do any one of these
four things either you can do the
remainder operator before you take the
absolute value as we did when we fix the
program or you can right shift the
number one effectively throwing away the
leftmost bit or you can mask it
effectively throwing away the rightmost
bit I said that backwards first one
throws away the the high-order bit the
second one I should have just said high
order this one throws away the low order
bit this one gives away the high order
bit yes right correct and finally if you
use a power of two length array you can
simply look at the low order bits of of
the hash code which is good if you are
you know believe that your hash code to
be up high enough quality that the low
order bits contain enough entropy so
that's it all right so I have one for
you a sea of troubles and we're going to
create a random number right well
actually a random boolean then we're
going to ask whether to be or not to be
that is the question yes it is if it's
that way they're going to get the
integer three or a floating one and
print out the result well this looks
utterly straightforward we get a random
number generator
it's seeded with time so who knows what
it's going to do we get the next boolean
and I know although this is capital B
boolean that it actually returns a
primitive so there's no no boxing
nonsense so two B is going to be either
true or false so it's going to be either
true or false or false or true either
way one of them's got to be true so once
you or the two together this is going to
be true which means that we're always
going to end up with the left side which
is the integer 3 so when we print it out
it's got 4 3 right well that sounds like
a reasonable option let's
yes indeed it is so the question is does
this program print 31.0 throw an
exception or none of the above
put on your thinking caps
you know sometimes he's right rarely I
was right once before you are it may set
a record all right I think we're ready
to pull the audience okay so how many
people think that this program prints
three raise your hands how many people
think that this program prints 1.0 no
takers on that one how many people think
that it throws an exception be proudly
proudly I see these tented what is this
okay you're allowed to be wrong it's
okay right okay and how many people
think that the answer is D none of the
above do you want now I think it was a
tie between a and D okay all right let's
see what the answer is in fact it prints
3.0 3.0 yes that wasn't even in the
program yes and the problem is is that
ternary operator has very strange
behavior when operating with mismatched
integral rap it rap types let's take a
look at the program again yeah okay so
the problem is is here we have a integer
object and here we have a float object
but they're both object references
what's the problem well the problem is
it's going to take the in so this will
evaluate to true right no surprises with
what's going on with the boolean object
but it's actually the result of this
operation is that it is going to create
a float object containing the value
three so why does it do that
that's why
it turns out that it's you look it's not
at because it's a rap
primitive type it's not actually doing
what it would do if it was simply an
object reference where it simply chooses
either this pointer value or this
pointer value it's doing what it would
do if it you had a question mark : with
an INT and a float where it says okay
let me take these two numeric types and
convert them to whatever type is more
general than both of them now I have an
observation this thing here it looks
like a car rental contract yes and
nobody ever reads those yes so how do we
fix this okay well one way to do it is
to avoid the ternary operator
right the ternary operator has a number
of nasty corner cases if you think you
might not are not sure what the ternary
operator does in particular case don't
use them so here we simply declare a
value of type result and we use an if
statement either assigned to it and new
integer or a new float and in this case
we will get the integer object 3 which
prints as 3 okay and what can we learn
from it
okay so avoid mixing types the question
mark colon operator has counter
intuitive semantics when use with two
different wrapper types and if you must
select between two different wrap
integral types use else--if rather than
the question mark colon operator now I
should point out by the way that the
question mark colon out operator has
sort of gotten a bad rap it is very
useful when it is being used on to
objects of the same type so feel free to
use it under those circumstances it's
just these odd mixtures of wrapper types
where it really screws up okay so that
was a fine problem I have one last
problem for you the last problem of the
day is that a sigh of relief that I here
this one we call ground round and the
reason we call it that is because it
involves the round operator math dot
round all we do is we generate a random
integer and if the rounded value of that
integer is unequal to the integer itself
we print ground round so what I want to
know is you know what does this program
do most of the time how does it how does
it behave
so we create a random number generator
we get an int value from it and you take
an int value and you round it and round
to an integer value that you asked is
that not equal to an integer I mean
round takes a number and moves it to the
nearest integer and last time I checked
the nearest integer to an integer was
itself and so you should get back the
same injured this should be the identity
function on intz and so it should never
print ground round now let's see if
that's an option well the options are
never sell them almost every time it's
wrong and every time it's run so what do
you think does this program never print
ground round that will be choice a now
are we ready to vote I think we're ready
to vote are we yeah now I hear some
chattering well give him a moment
I think most of them have reached a
conclusion we'll give him a few more
seconds this is the last last puzzle of
the days yes last one we present a good
point they have a whole afternoon
okay I think well let's come ten seconds
all right all right
I don't know we got about a few of you
and how many people Sadie every time
it's run a smattering almost no one
so the winner I guess is sell them that
right yep seldom okay time to reveal the
answer the answer is in fact almost
every time it's run 97% for those of you
who are obsessed with quantification it
turns out the intuition here is that
there is a silent lossy conversion from
int to float and that in combination
with the fact that math dot round of
float is the method that is invoked is
killing us so let's take another look at
it see the problem here is when we call
math round of I and integer there is no
method define in math call round that
takes an argument whose type is integer
there are two versions of this to
overloading is defined round of float
and round of double and the float one is
the one that gets invoked and that is
true because whenever you have two
applicable methods it chooses the most
specific so is every float a double or
is every double a float every float
value is a double value and that makes
float the most specific one so this is
the one that gets invoked now in order
to call round a float on an integer you
have to convert the int to a float that
is called a primitive widening
converting but it isn't really a
widening conversion it loses precision
you have 32 bits for an int and 32 bits
for a float well eight of the bits in
the float are used to represent the
exponent you can represent huge values
with a float and tiny values and that
means you do not have one value left for
every integer so some integers must end
up with the same float value by the time
you've converted the into a float you've
already lost so how many of them do you
lose well as I said there are eight
exponent bits there are 256 possible
values of those eight bits so that means
you know that roughly speaking you're
going to lose sort of
99% of them it turns out it's not quite
99% and to understand why you have to
have to go into the details of a
floating-point representation and we
don't have time for that today but
because of that virtually no intz went
converted to float and then convert it
back to int or equal to themselves
statistically speaking statistically
speaking 0 through 10 are okay zero
through ten are okay the low ones are
okay it's when you start getting high
that you start really you know losing
big-time so how do we fix it
well if we cast I to a double then we
end up invoking the version of math
round where every INT has a unique value
because our only 32 bits in an INT and
64 in a double so by converting an INT
to a double if we convert it back to an
INT we'll end up where we started and
what can we learn from it that silent
so-called widening conversion from int
to float is both lossy and dangerous it
was a mistake in the language design you
know basically you should never get a
conversion where you lose precision and
not get a warning or even an error you
should have to explicitly cast to get
from int to float but unfortunately you
don't
more generally the float type is seldom
called for as my brother said earlier
unless you have a huge array of the
things don't use float use double double
is better in this case you weren't
really choosing teams float but you were
sort of getting it shoved down your
throat and finally method overloading is
dangerous arguably what killed us is
that there were two over loadings of
round if they're you know if they'd
given them different names or or if
there had been no / no version of it for
float or something we wouldn't have
ended up in this nasty situation and
that brings the normal part of our talk
to a glance so now we have the abnormal
part Java is a reasonably simple and
elegant platform I used to say it is
simple and elegant but I think as of
Java 5 I can't call it that anymore it
has gotten a lot more complex it has a
few sharp corners and you should learn
to avoid them and if someone wants to
make it more complex you should think
very hard about whether that is
something
really want to do to the language and
we'll mention that we had to work long
and hard to come up with these puzzlers
it is true you know it used to be easy
to find puzzles that we haven't
presented yet it's gotten much more
difficult because we've sort of mined
them all and unless we make the language
more complex you know I'm afraid we're
not going to get a lot more
fundamentally new puzzles but here's
here's a good rule if you weren't sure
what a program does it probably doesn't
do what you want and keep your program
simple and you will stay out of trouble
another important thing is to use fine
bugs it's a static analysis tool then
I've written it's actually used within
Google available through bug bot and
very shortly through Mondrian and it
actually finds all eight of the puzzlers
that we discussed today if you enter
those codes on bugs will say hey you're
making this kind of mistake fix your
code and for our viewers on the web
where should you go to find to find the
books well you can just google find bugs
and it will take you to the right
location excellent and finally don't
code like my brother don't code like my
brother and now a word from our sponsors
if you enjoyed this talk then you should
get a copy of this fine book called Java
puzzlers by myself and Neal gaffer it
contains 95 puzzles none of which we
presented today so there are 95
different puzzles 52 optical illusions
and tons of fun and in case you wonder
what this is here this is a shameless
plug
and that that brings to a conclusion our
talk so thank you for coming and thank
you for stating I think now we can take
some questions excellent question
so the question was how long did it take
me to find a string whose hash value was
ended up in value and that made sense so
I have a dual processor Opteron 170 at
home and I Unleashed it I have a
dictionary of 200,000 words which means
there are 40 billion word pairs
unleashed the Opteron on that and I took
it 10 minutes to calculate all the hash
values of every word pair it found 11
collisions and this was the most amazing
one where you catch error and accept it
some of the code inside the threat had
died by throwing throw we wouldn't have
caught that yes so to repeat the
question
if in our je-yoon example the the code
had died by throwing a throwable that
was neither an exception nor an error
would he have not caught it and the
answer is yes it would not have caught
it don't how about yeah don't do that I
mean it hurts when you go like that and
dumped her yes the language well but I
mean inseparable I mean the language
would allow you to define things that
are neither an exception nor an error
I think there's absolutely no use case
for that the language should have
forbidden it I agree with my brother in
this instance back
again so the question is which should we
define a math background that takes an
int value so actually so I had one
suggestion for how to fix the problem in
ground round that we could declare a
function in math called round that takes
an INT returns an int it would be the
identity function and we would
deprecated that function from the moment
we added it right so if you ever used it
I mean because there's no sense in
calling that method and so if you did it
you would get rather than getting the
float version which is lossy you would
get the into int version which is marked
as deprecated and that that would be one
reasonable thing to do and and you know
one of the things which is often
interesting is you find yourself with a
mistake in an API and they say well we
can't actually fix it because that would
be incompatible and then you try to
figure out well is there some way that
we can tweak things to make it be not so
troublesome and that might be one way
how you could do something like that
yeah although it is arguably not upward
compatible you're changing the behavior
of existing programs I would say a
better solution is to run fine bugs now
there's something my brother did not say
because he was too modest but I will say
fine bugs catches all eight problems in
this year's talk if you simply run these
things through fine bugs it will draw
your attention to every single one of
them so just just run fine bugs and
that'll take care of this one yeah
don't I
if there is I've never heard of it and I
don't have to have time to check right
now if it exists when you check into up
line but but the problem you know
remains that if you do the obvious thing
you get hurt so this is a case where you
know it definitely does represent a trap
or pitfall
but I mean the problem is is that nobody
is probably going to you know
deliberately invoke the round function
passing it an int sometimes we've seen
cases where people will do a computation
and they think they're getting a float
or a double but they're not they're
actually getting an int and they're
accidentally doing the silent lossy
conversion right I mean this was a
contrived example most many the puzzlers
are but the important lesson is is this
accidental lossy conversion yeah
is that more likely to happen with
generics I don't know if this is more of
the question was is it more likely to
happen with generics and you know is
there is there any solution I don't know
if this one is it is the case that
generics especially in conjunction with
auto boxing auto unboxing and varargs
complicates enormous li the the overload
resolution algorithm so it does make it
more likely that you will invoke the
incorrect overloading and you know I
think the only solution there is added
care especially added care in API
designs api designs that used to be
reasonable are no longer you know it is
even less advisable to use method
overloading than it used to be and
static analysis tools can help you find
potential problems in pre-existing APs
I don't actually think this would be a
problem because the generics is done by
type erasure and you can't do something
where well you define something that's
generic over numbers and if you actually
give it into you invoke this overloaded
version of the mum number this one this
one wouldn't but other ones would we do
have other puzzles that rely on exactly
that right you know for example in list
there's a list gap method that takes an
int well if you have an N list up remove
that removes the il iment if you have a
list of integers you know have this
funny overload resolution problem where
if you remove 14 are you removing the
number 14 or the 14th element it turns
out it's the 14th element and that's
very confusing so any other questions if
not thanks again for coming thank event
for staying and see you next year
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>