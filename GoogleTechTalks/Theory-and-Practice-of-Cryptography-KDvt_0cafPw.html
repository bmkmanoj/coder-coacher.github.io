<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Theory and Practice of Cryptography | Coder Coacher - Coaching Coders</title><meta content="Theory and Practice of Cryptography - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Theory and Practice of Cryptography</b></h2><h5 class="post__date">2007-12-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KDvt_0cafPw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is the second lecture of the theory
and practice of cryptography Google is
teaching Google series and I'm glad to
see somebody people back from last week
and today I'm really talking about some
of the issues of using cryptography in
practice and as usual all the course
materials and QDB links slides and video
from last week are available on the wiki
page go slash crypto course and I'll
continually post some suggested readings
and homework exercises on there I've
posted exercise set 2 which is a little
more hands-on so using some of the
internal tools at Google that we've
built for crypto and a little bit of
exercises with attacking some crypto
systems and just kind of recount from
last week as I said the video is up on
YouTube so you can watch it or if you
missed last week's lecture you can you
can catch up
we had about I think three exercises on
the first exercise set the first one was
just to sign a message with GPG and to
verify my message and on average took
the people who did it about 20 minutes
and come the point of that exercise to
show that actually using the software is
not very simple even for a Google
engineer and I think that the people
actually did this nigga shut this chat
window there I think what people
actually did this were a bit
self-selecting because people are very
interested in and wanted to do this
exercise because when I've done it in
the past at a at MIT in the computer
security class took people about an hour
sometimes an hour and a half to actually
do you know basically what you just did
which was create a PGP key and assign
somebody else's and assigned a message
and then you know actually verify my
message and I posted the second exercise
was finding hash collisions and Tom
giing found the largest truncated hash
collision which is 77 bits so that's
kind of exercise to get experience and
you know trying to crack things and you
know make you see some data structures
and we don't know why the chat windows
popping up here so about that
I know so actually sha-1 there have been
full collisions found as of two years
ago and they did that with about 2 to
the 69th operations so it's expected to
take two to the 80th and they found a
full 160 bit collision and sha-1 with to
the 16th operations
sorry their question again if you're on
VC was did that actually happen here and
is that a record and the answer is no
people asked me offline about you know
what's the significance of finding two
random values that collide and versus if
I had a specific value and you wanted to
find a collision the idea with having to
you know being able to get to things
that collide even though you don't have
control over the preimage values you
might be able to get somebody to sign
things so you have some be signing code
for example you might be able to take
code and have an innocuous program that
doesn't do anything and have some you
know random variables at the end so I
can keep getting Google for example the
signed code and then if I find a
collision with one of these random you
know innocuous codes that they actually
sign I could replace it with my
malicious code then pad some random
noise on the end this is kind of a
chosen cipher text attack in the in the
hash context maybe we can talk more
about that offline if you have questions
as I say the bond on this slide feel
free to ask me offline some of you did
at the end of last week's lecture and
I'm not really gonna get to everyone's
questions but as I said feel free to
email me directly the other exercise was
doing some crypt analysis on these two
time pad encrypted and Jason Klaus
actually decrypted the whole message
which was this crypto rap song called
Alison Bob so there's a link here and I
sent it out and you can definitely
understand all the references in the
song and all the end jokes by the end of
this lecture
so moving on I'm gonna actually restart
this presentation because there seems to
be some problem with the group chat
window ok so today's lecture is mainly
gonna focus on things that you should
not do with crypto it's gonna be a lot
of
kind of practical things that we've
there's the chat window again get this
thing out of here so we got a Reacher
again my trader that's gonna focus on
things that you should not do so it's a
lot of kind of practical knowledge we've
learned over the years and a lot of
things that people would intuitively use
crypto may have problems with it we're
gonna see a few examples of that
throughout the lecture and so by the end
of the talk I'd hope that everyone can
understand all the little subtle things
that can happen when using crypto all
the kind of things that you would think
it would be easy but that when you put
these pieces together
there actually can have some
interactions that are can create
problems and be security threats and
come up or in the end this is that I
want to you know emphasize that there's
a security team here that's here to help
you and can answer your questions so if
you're working on a project that needs
to use crypto there's a lot of resources
in-house that you can refer to and you
know that's our job is basically to help
you use this properly and get you what
you need for your product and finally
we've got some in-house tools that we've
built and you know by then this you'll
see that these tools can actually take
care of a lot of the issues I want to
present today and will be very useful
for you to use in your code so you know
we learned last week crypto is pretty
easy you guys know the primitives you
know what block ciphers are public key
crypto hash functions signing and
there's a ton of libraries out there
that are very easy to use there's you
know job has got a built-in to the jce
it's a very simple interface it's open
SSL all sorts of libraries out there
that you know as engineers are very you
know straightforward to use there's not
a lot of complexity here and you know
you can pretty much easily use these
criminal but Sunni crypto primitives and
the question is should you and the point
I make today is that it's very easy to
get this wrong if you get it wrong the
consequences can be very dire it can be
completely broken you can have issues in
the future and become the idea I want to
drive home is that putting together all
these little pieces can be very
difficult in practice because there are
tax that you may not think of you know
intuitively they may not be things that
you know we're really considering at the
time does
that can come up later so kind of the
first deadly sin I want to talk about
today is writing your own crypto
algorithms and I will say unequivocally
don't do this don't write your own
crypto and it's surprising to see how
many people out there today you know
companies individuals will come up with
their own proprietary crypto scheme so
remember we last week we talked a bit
about kerckhoffs principle which is the
idea that the entire security of the
crypto system should rest in the secret
being just the key and not the actual
algorithm so there's a lot of companies
out there today who will have a
proprietary algorithm and they'll tell
if this as a security feature that
nobody knows what they're doing with
their crypto and I'm gonna you know take
the case that this is a very bad idea
that we should see what the crypto is
doing and it should be public and should
be under scrutiny and you know if
experts should hammer on it for years
and should go through a lot of process
before it's agreed on so we've got very
good standards out there and you know
they're constantly under scrutiny
things like AES went through a public
competition to actually decide on and
there's researchers from all around the
world working on it and it's been
continually you know subject to attack
people's whole career is trying to
attack this thus crypto system and write
papers on it and then improve it and
write the next crypto system so I don't
think it's gonna be an issue for anyone
in this room I don't think anyone's
gonna go out try to write their own
cipher mode or you know their own block
cipher public key scheme but if you're
gonna do it don't use it in practice
until it's gone through a proper vetting
process which is to publish it in you
know a peer-reviewed conference usually
and go through a lot of rounds and kind
of deliberation and actually get like a
solid standard that's had a lot of peer
review so another kind of point I want
to make is to avoid using obsolete or
unscrutinized crypto this kind of ties
back to the first slide and it's
actually just kind of showing some due
diligence so things like des are
effectively completely broken I
mentioned last week that in 1999
somebody was able to crack des for in 24
hours for an initial investment of
$100,000 so that means it could
continually crack des keys for that one
time in
investment you think that you know
processing power is increased you know
by Moore's law and we've gotten better
technology and better parallelization
better all sorts of things that's gonna
be much faster today so Triple DES which
is basically just a composition of three
days operations it's it's still using a
lot of legacy applications it's still
out there especially in the financial
institution a lot of banks have three
days hardwired into a lot of their
protocols but this is not something that
should be used for new applications
we've got a great standard in AES it's
more efficient it's been law has longer
key lengths it's more flexible and
there's no reason to go back and use
Triple DES but hey you know there are
not practical attacks against Triple DES
that are known in academia or in public
as of now md5 and sha-1 you may have
heard about a lot of the collisions in
you know the paper somebody asked about
whether 77 bits is a record and actually
both of these people can find collisions
or people have found collisions md5 is
actually can find a collision in it very
quickly you can download some code out
there I can find it under a minute and
the question is what's the implication
of this and it kind of comes back to
whether you can get people to sign your
chosen you know message that you want
them to sign so something like a
certificate something like code signing
you don't want somebody to sign that
with you know DSA with md5 remember last
week we talked about using message
digests with a signature stream in that
case it's not appropriate for that
because somebody could get you to sign
you know two things one of them is
innocuous one of them is malicious and
they they can give you you know they can
get you to collide on md5 values however
md5 is still you know as far as I know
k4h max and the reason why there is that
you can't get people to necessarily sign
for it and there's talk about this more
offline but generally each Mac's are
okay for md5 and sha-1 finally the last
thing on here is I haven't mentioned it
yet in the course is T EA this is stands
for a tiny encryption algorithm and this
has been using practice I'll talk about
it some more today but there's some
attacks against it and there's been some
revisions to it
and the one concern I have about it
personally is that it hasn't had the
same level of scrutiny as other things
out there and the fact that people keep
finding these you know not crucial
attacks but you know small attacks that
keep whittling down the the strength of
ta so third point I want to make is to
use reasonable reasonable key lengths so
I've pulled these numbers down from the
site key links calm and they've compiled
a bunch of different standards they've
it's NIST it's the NSA European equipped
and they have a bunch of different
things you can look at kind of key
length recommendations and for the
foreseeable future 256 bit AES is you
know thought to be strong this is the US
government's top secret standard it's
what they're using for their most you
know vital secrets in government sha-256
egde another Shaw standard that's you
know thought to be secure for the
foreseeable future 409 six bit RSA DSA
this is based on the you know difficulty
of actually factoring large numbers and
something I haven't talked about all is
elliptic curve cryptography which is
much shorter keys and you know 512 bit
keys are thought to be you know secure
for the future foreseeable future for
kind of the current standards that we're
using usually the measurement they'll
use is that you'll think about
encrypting something today and how long
you want that protected for so you
notice that I have things that are
protected for about you know 25 years
until about 2030 you know 20 30 years
and AES 128 which is the government's
secret for a secret level clearance
that's thought to be you know things you
encrypt a day you can think that in 30
years this is gonna still be protected
and sometime between then you would you
know anticipate that you're gonna
increase your key sizes same goes for
using sha-1 for H Max and 204 8 bit RSA
DSA and 256 bit ECC things that are kind
of at the end of their lifetime right
now our Triple DES sha-1 for signatures
as we said you know people found
collisions with you know a lot of
computation but that's going to come
down as they have more attack
and 1024 bit RSA DSA kind of
recommendation now is to sunset you know
1024 bit RSA keys and move on to
hierarchies within the next couple years
or larger keys in the next couple years
these are details that you know you can
refer back to the slide or look at that
site later on but the idea is that just
use reasonable key lengths and this goes
in both directions you can have people
you know you might think that hey let's
just use huge RSA keys and let's use a
huge AES keys and the problem there is
that there's still a performance issue
these are not necessarily inexpensive
operations and there's a trade-off
between performance and speed and
security so you can kind of go both
directions you can use short keys that
are too short and weak or you can go
overboard and affect your performance
and make your security unusable by using
a huge key just kind of moving on to the
next point I want to make is not to
misuse primitives and the idea here is
that we've got block ciphers and hashes
and you know all these different things
and you might think that you know there
are ways to compose these primitives out
of each other so I might build a Mac out
of a block cipher the idea there is that
you know if you and I share a secret
maybe I just encrypt something and then
you can verify that you encrypt the same
value and people can do this you can
compose max out of block ciphers there's
one you know you can make them out of a
yes yet does and all these things but
it's not trivial to do you actually have
to put some thought into how it's
constructed and there's a tax you can do
against it so a great example of
somebody misusing a primitive and you
know trying to use a for example a
cipher for hash is Microsoft so part of
their copy protection scheme in the
original Xbox they use ta
as a hash function and the idea is that
they would this is for code signing so
they would excuse me they would you know
use this block cipher to compute some
value and treat it like a one-way hash
now the problem is is that well there's
two issues one is that there was known
vulnerabilities in TA and that was not
supposed to be used for cipher or for
hash functions and they were misusing in
the wrong way to actually compute this
hash function
so because that people could figure out
how to get collisions very easily on the
code that was signed by the Xbox inside
the Xbox there was a talk here on this
about a year ago that was very
interesting there's a site out there
with kind of talks about all the things
I should actually send a link to it but
the point here is that because Microsoft
did two things they didn't you know do
their research and find out that he had
these vulnerabilities and they kind of
misused the wrong tool for the wrong job
people are able to you know boot Linux
on their Xbox they could you know
circumvent the bootloader and so it's
just kind of a case study to show like
you know the pitfalls of actually trying
to do this on your own
and kind of the concerning thing here is
that Microsoft employs some very good
cartographers they have very good
security people you know talent people
who know this and so something we can
learn as an organization to make sure
that we talk to each other because
somewhere there was an xbox engineer who
looked up the phrase tiny encryption
algorithm and this is the first thing
that came up and they used it and they
didn't go do their due diligence and
find out that oh wait there's these
subtle attacks and these things so you
know the point here also is that we
should use the resources we have
in-house because you know Microsoft they
have people there who knew knew better
than to use this in Xbox so next point
and I'm kind of jumping around there's a
bit of a mishmash of points is to use a
good source of randomness so we talk
about a lot about generating secret keys
and generating initialization vectors
I'll talk about a minute but it's
important use a good source of
randomness so we have a lot of them and
for all practical purposes you know dev
slash random dev you random are good for
which you know we're gonna do on a daily
basis we also have you know Java
security secure random some in-house
tools under Utila andum and our own java
secure random package and all of these
in my opinion are acceptable for use and
there's some caveats
so dev random is blocking and some might
be an issue in your code another one is
to consider forward security and for
security is this idea that if at some
point in the future my key generation
algorithm is broken like somebody leaks
the key that's using being used to store
the
seed to pseudo-random number generator
you don't want to go back you don't want
to go and compromise all your old keys
that were generated by that same
generator so we actually have if forward
secure random number generator in our
own utilities and again this is
something you can talk to a security
team in the house and see what's right
for your particular application and
project now some weak sources that have
been used in practice a lot
are things like time of day and just the
see random call and java.util random
which is weak and lfsr stands for linear
feedback shift register these are just
easily reversible functions that you
know people have used for generating
randomness and a lot of people again
just will make up something they'll grab
some disk noise they'll grab some you
know keyboard clicks and they'll try to
you know jumble it together and make up
their own source of reminisce again this
is not something you should rule on your
own the time of day is a great example
there's a you know anecdote in Las Vegas
there's a keno game and this guy you
know started winning he won for like
three days in a row won like three
hundred thousand dollars playing keno
and then they finally like shut him down
they're trying to figure out how what he
was doing was he cheating how you know
how'd he paid somebody off and it turns
out that every night they were turning
off their keno machine and then they'd
flip it on about the same time in the
morning
and it would seed itself off the time of
day so then it would generate numbers
throughout the day and then they would
come up again so this guy played a lot
keno and realized that he saw the same
patterns come up in a couple times and
then figured out that you know if he
just recorded all the games that were
being played they would be played again
and they took him to corn he won cuz he
wasn't cheating it was you know their
fault for seeding their game off the
time of day and you would be surprised
how much you know this is still out
there people use the UNIX random call
they use this they make up an lfsr
and again we have plenty of tools out
there there's no reason to use a weak
source of ram randomness so another big
point is not to neglect key rotation and
I've got kind of a Don Rumsfeld quote
here like stuff happens
keys are leaked there's algorithms are
broken processing power
gets better and you can basically from
the ground one plan to change your keys
and if this is for signing keys you need
to be able to go revoke all your old
things you signed if it's for encrypted
database you may need to go through and
Riaan crypt your database with your new
keys and you're gonna be have to be able
to identify which key was used to
encrypt different signatures or cipher
texts and this is something that people
you know again neglect a lot they will
generate one key and it you know think
that it's not gonna change for a long
time think it's gonna be used for a long
time and generally you know a good rule
of thumb is you should plan to rotate
keys maybe annually or quarterly you
know some people say DL a but I think
that's overkill personally but this
should be built in your design from
ground you know day one that you expect
to change keys it's not gonna disrupt
your application it's not gonna be you
know anything that's gonna break
anything just to change a key value
which brings me up to the second point
is don't keep your keys in source code
this makes it very difficult to change
the key if it's encoded in there as a
binary string you need to go recompile
your your code and push out a new binary
just to update the key we actually have
a project right now to go remove these
keys from code and it's on this wiki
link and you know we're basically
compiling a list of any keys that people
have hard-coded in code and their
exceptions to this where if you have
test Keys or if they're you know just
legacy keys that are in there that are
not being used for security purposes for
example you know a lot of people have
used Mac's
H max just for integrity checking they
don't actually don't care about you know
people trying to forge things it's just
you know like they'd use a CRC and
things like that it's acceptable but
generally you want your keys to be in a
separate data file that is independent
of your source code that you know you
can update independently that your
source code will read from and we'll
talk about some tools do this at the end
of the talk so my next kind of point is
to use the right cipher mode and you
know what's the cypher me I've really
talked about this yet and we've got
these primitives block ciphers hash
functions and cipher modes are the way
that you put together these block
ciphers over
a large message so for example here
we've got this block cipher encryption
this case you say AES or DES and you
know if you have a big long plaintext
that's bigger than the input size your
block cipher kind of the intuitive thing
is just to go along and just run this
block cipher a long every piece of that
message I mean seems pretty
straightforward and you're obviously
probably see some problems with it in
that the patterns in the original
plaintext are gonna be apparent in the
ciphertext so a great example of this is
you know I grabbed these from Wikipedia
pages is this image so the image on your
your left is you know plain text image
that hasn't been encrypted by ECB mode
in the center and you can see that the
patterns in the original image are just
you know pre transparently shown through
in the output and the far right the far
right would be the cipher text that's
you know encrypted under a different
cipher block mode and the idea here is
that you know just like this attack some
of you did on the exercise where you
looked at the you know output you try to
do some crypt analysis you know this is
obviously easy to see but you know maybe
you could get away with it with a you
know large text message it has some
decent entropy in it maybe you could say
okay well you're not really gonna see
patterns but the fact is that crypt
analysis is about seeing patterns in
there and using the wrong mode can make
it easier for some types of data so ECB
should only be used for very short
blocks where you don't care if it's
deterministic you don't care if people
recognize this particular encrypted
block so one example might be if you had
user IDs if you had you know user IDs
counting up from zero to your number of
users and maybe we just want to hide how
many users we have so you know that
might be along you can encrypt it with
AES the output people are gonna see the
same encrypted user number but it's not
telling you how many users are so that's
the kind of application where you see B
be appropriate just to give you some
context for other cipher block modes
this is one that's used often
it's called CBC this is a chaining block
cipher and the chaining idea is a little
hard to see on the slide but I use my
mouse you have this initially
initialization vector value and this is
just a random
blob that you can generate for every
encryption and you XOR this with your
plaintext right the first block of
plaintext and encrypt that and then the
chaining part is that the next that
ciphertext is going to be used as the IV
for the next block so you know one way
to look at this is you just pad the
beginning of the message with a random
block which is the IV and then do this
chaining step and the nice part about
this is that you know every time you
encrypt the output is going to be
different because this IV is changing
and you know it hi if you look back in
that previous slide where we have this
picture that's the kind of output you're
gonna get is that you know because you
have the same pattern the blocks that
would be encrypted here they're not
gonna be apparent in the output so CBC
is one mode and you know one drawback is
that this is fixed size you need to
actually pad the end of the plaintext
another mode that is commonly used is
called counter mode and it's a very
simple ideas basically your
initialization vector is gonna be part
of your input it's the first half of
your input block and the second half is
just a counter that's going to count up
from you know zero to the length of your
message and you'll just encrypt these
blocks and then XOR them with your
plaintext so the nice part about this is
you can do in parallel it can be the
length of your plaintext but again you
have to make sure to use these correctly
whoops so one issue with these this is
not to reuse your initialization vectors
so if you think about if you think about
using counter mode what's gonna happen
if we reuse the same initialization
vector well these knots values are gonna
be the same the counter values are gonna
be the same so the cipher text is going
to be the same and we've got basically
that to time pad from the homework
assignment it's exactly the same thing
so if you use the IV it's you can do the
same attacks that you can do on the
first exercise set to actually recover
the plaintext so don't reuse IVs it's
another kind of like walk away point I
don't know why this chat window keeps
opening there's anybody from the docs
team here like please take a note of
that then we can fix it okay so don't
reuse IVs
similar issue is we haven't talked about
it there's things called stream ciphers
and you know as you probably guess these
are ciphers that are not blocks and they
can just encrypt a stream of arbitrary
length data and again it's basically a
function whose output is X sort of the
plaintext and reusing the keys for a
stream cipher has the exact same attack
it's the two-time pad all over again and
you know you think that yeah this seems
pretty obvious but this happens a lot
the WEP the WEP wireless protocol had an
issue with people reusing stream cipher
keys they were using a stream cipher
this is kind of to two cases they're
using a stream cipher to do mapping so
it's again using the primitive for the
right permit for the right job they're
using a stream cipher from makng and
then they were also reusing the keys for
it
so people could do attacks against the
authentication of the WEP wireless
protocol and again like the people who
design this should have known better it
was you know I Triple E guys and this is
just a misuse of crypto that they should
have caught and later wireless standards
use even more secure crypto and properly
use it
another point sign all ciphertext as
with when I was talking about before
this issue with hash collisions where
you can get people to sign things for
you that's kind of a chosen cipher text
attack there and the idea is that I
might be able to give you you know some
data and get you to decrypt it and the
issue here is that by getting you to
decrypt things I might be able to tweak
either the IV or parts of the ciphertext
and do things to reveal the message to
me the idea is here we want to ensure
that all cipher texts have not been
manipulated and so you want to sign both
the IV and the cipher text and any other
sort of input that actually went to
generating the cipher text so that you
should never use encryption unless it's
authenticated that should be the default
because if there's unauthentic it things
out there we open up a lot a whole class
of attacks where you can you know
basically manipulate the cipher text and
do things to it and some things people
try to rely on it's just saying okay
well we'll detect the changes in the
plain texts when they decrypt and things
like that maybe having a you know CRC
check with
in the plaintext and there's a tax
against that so unless it's a you know
actual signature H Mac it's very
difficult to guarantee that you're not
susceptible to you know some of these
cryptanalysis tax now one thing is I say
sign all ciphertext why not sign before
you encrypt and this is kind of a very
theoretical attack but there's
vulnerabilities by signing first so in
practice we like to encrypt first than
sign and this is very my new you know
detail and you can get away with it some
some cases there are also things
there's authenticated site for block
modes that you can use where you signing
happens automatically as you you know
encrypt so there's there's a lot of kind
of exceptions to this rule but generally
sign all cipher texts another issue is
padding and encoding your plain text
properly so the idea here is that you
may be able to do attacks against the
padding scheme or the encoding seem in a
cipher deck so I this comes back to
signing is that I might be able to
manipulate a cipher text or generate my
own that when you decrypt it and you
actually take your action on it because
of vulnerabilities and your padding or
your decoding I can maybe reveal your
secrets or I can record really your your
message contents or authenticate myself
and a good example is I have this paper
a linked on the wiki about the web
authentication so you know back a few
years ago the Wall Street Journal had
these paid accounts and they would
basically take your username and some
sort of secret and hash them together
and that would be your cookie now the
problem is though is that they didn't
properly pad this username they actually
just truncated it down to eight bytes so
if your name was
you know Joe Blow one two three somebody
could log in as Joe Blow one two three
four and we get truncated down Joe Blow
one two three so this is more of a data
impact format but there's other attacks
against padding and so that would allow
somebody to basically you know log in as
somebody else's by somebody else's
account by getting the site to you know
take their username and hash it down to
the cookie value they needed to log into
somebody else and you can read the paper
to get you know all the details about
how they do that in the ways that they
actually would fight that another issue
our RSA certificate forgeries and this
came out at a conference a couple years
ago and again it's this padding issue
and basically remember the details a
spot here there's an issue with the
delimiter in the certificate so we
talked about certificates the first week
this is basically somebody's public key
that's been signed by somebody else like
Verisign and for certain RSA keys what
you could do is create a certificate
that you can take advantage of a
implementation err in the way that they
parse the certificate and when they
actually sign it you could you know have
that valid certificate too like your
friendly site actually be for some
malware site because you can manipulate
the actual values and their certificate
so I also have the link for that you can
read more about it but there's a lot of
cases where the scheme can break down be
keep because people don't encode or pad
the data correctly so Miller again Jumby
talk topics a bit here are to use knots
as properly so one thing to think about
with RSA in particular is that it's not
what's called semantically secure and
we're gonna talk about what somatic
least cures more next week but basically
there's no randomness in the encryption
if I encrypt the same message twice the
output ciphertext looks the same so we
get back to that kind of ECB problem
where if I encrypt every block in the
picture with my key you get that you
know picture of the penguin coming
through so you know kind of an intuitive
idea is hey let's just pad the plaintext
with a random string so I take my
message and random string and encrypt
that instead of just the message and
that seems like a good idea the problem
is though is that you know has intuitive
is it is there are attacks against that
and you know some of them are more
difficult and you know some of them
require some different assumptions but
by just you know do it again by just
appending strings together
especially for RSA and some other
ciphertex schemes you're maybe opening
yourself up to vulnerabilities so one
way that they actually you know one
particular scheme that randomizes it's
called Oh a EP and the construction of
this is pretty non-trivial they actually
have to do a lot of steps to ensure that
you know this isn't Valen attacks or
people gonna tell what what messages and
this these are tax felt chosen plaintext
attacks the idea is that you choose the
plaintext and encrypt it and can see
what the output looks like
and it's non-trivial to actually
construct these so you know kind of the
point here is you know don't just think
hey I'll slap in some random knots there
and then I'll be fine I'll look random
because there can be a tax against that
similar issue comes up with using keys
in the same way so one idea that a lot
of people have and again this comes back
to actually building your primitives is
keyed hash functions or you know H max
hash max and one idea you might have is
say hey we've got sha-1 let's make this
a mac let's just take a key you know
tack on the message at the end and hash
that and then if you've got the same key
you can you know compute the same
function over the message and again
there's a tax against that that can be
you know particular to that hash
function scheme it can be you know in
general to the whole you know the
theoretical notion of a hash function
and getting it right it's non-trivial so
one standard that I've actually linked
to both these on the wiki as well is H
Mac and so they do a construction that
you know there's some thought and detail
that goes into there and some you know
very my new things that they have to get
right to do this properly and going back
to o AP is they actually had to do a
couple stabs at this they published a
paper and then you know going through
this process found some vulnerabilities
into it and then had to go back and
revise and come out another version so
that you know even the experts you do
this for a living and academia they can
make mistakes that's why this whole you
know process exists they've kind of
publish it and then do revisions is that
it's very difficult to do so again like
nonces don't think that you can just
take a hash function or a Mac or cipher
and
thrown a key somewhere and then it'll
down be some sort of key thing usually
whatever you need there is already a
construction out there to do it and you
just need to know what to look for
another point is not to use encrypting
keys for signing keys or vice versa and
again this comes back to this attack
where you can get somebody to encrypt
something or science that's going to be
half or you know if you think of like
the email context I might send you an
email and then you hit reply and then
sign that message well that contents of
the message you know some of that's
determined by me so the idea here is
this is actually part of the exercise is
that you can do attacks against some
encryption schemes signing schemes by
getting people to sign a particular
message so the example in the exercise
is with RSA where you know I might have
my RSA key to encrypt messages to you
and then I'm also signing your
certificate with the same key so if you
give me a certificate a sign you might
be able to do attacks against it and
there's obviously a you know kind of
trivial one but there's a more subtle
one that you can actually not detect as
the person signing it and you'll kind of
figure that on the exercises and yeah so
basically the same key shouldn't be used
for signing and encrypting this applies
to a EES that people try to reuse a es
keys for Mack keys and there are more
you know attacks against that because
it's the same issue of the signature may
actually leak some information about the
key but generally should be totally
separate they should never kind of cross
this boundary and again there are some
exceptions with things called sign
Krypton and authenticated block cipher
modes and so there are cases where it is
acceptable where you have just one key
but in general two separate worlds
another issue a side channel attacks and
this is more you know depend on the
platform but I'll talk about some things
are actually relevant kind of the PC
model as well and what you're looking at
here is a trace of the actual power
consumption of a DES operation so it
does has 16 rounds and you see these
spikes going up and down and this is
actually a smart card consuming power
and the interesting thing here is that
the shape of this curve
can tell you what's going on inside this
car so this bottom picture if you notice
the scale is different this is zoomed in
on I think like one of these rounds here
and you know there's some patterns here
this kind of shape is the same but
there's these two spikes down here
versus one spike over here and what this
is that actually is is they've been able
to zoom in and see operations like
shifting a register and based on this
implementation they knew that these
shift operations would happen for
specific key values and so by just
looking at this trace without you know
attacking des at all they can extract
the key just by looking at how much
power this thing's consuming now the
same thing happens with timing attacks
RSA is you can look at the time things
take to respond to try to determine what
the key values are and RSA is one thing
that's susceptible to this this last
summer we had an intern in the security
group who did attacks on cache timing
the idea is that when so many BD doing
RSA computations this expensive
computation and they would be doing
exponentiation over large large fields
and they'd have a lot of pre-computation
tables and when when they'd hit certain
parts of the table it would cache it in
two different lines and the cache block
and so depending on what your secret key
value was different cache blocks would
get filled with this pre computed data
and so what her project was was to write
a program that would basically try to
flush out the cache and then see the
response time when reading her data back
out of the cache and so you know it's on
a multi-threaded machine so there's the
you know process that she can touch this
running some RSA computation her
processors in her own user space and
what it would do is you know try to
write a bunch of stuff to the cache and
then the RSA would run for a while and
if she'd come back and try to read her
things from the cache and time how long
it took to actually get her data out and
the things that took a long time
they were flushing the cache and so she
spent the summer looking at traces like
this that were three-dimensional or
two-dimensional like cache lines and
response and at the end of it she
figured out that she could determine the
RSA secret key that was in use by
looking at how long the cache response
times were and so you know there's not a
lot you can do is this from an engineer
because it's kind of dependent on the
implementation but one one thing to take
away from it is that you know all of you
right now could go fire up Python or
Java and write RSA in like 20 minutes
it's very easy to do but things like
open SSL and some extent that Jacy
they've thought about things like timing
attacks especially open SSL and you know
the the woman who's an intern last
summer is actually attacking open SSL
and this is after they've already
addressed this problem so she found an
attack against things that they've
already supposedly fixed so kind of the
idea here goes back to don't roll your
own you know use standard libraries use
standard implementations because they've
thought about things like timing attacks
side channel attacks power analysis
things like that very subtle details
that you know aren't clear on the
surface and you know there was your
before people actually thought of doing
this this is just in the 90s so well
last point I want to make is don't
fixate too much on the crypto in a
secure system we're getting these email
threads sometimes that people will go
back for you know 100 messages talking
about what to use as their source of
random bits you know disk reads and
keyboard clicks and just going back and
forth about attacking you know you
random and you know don't use AES and 28
using AES 256 and the thing is is that
usually the crypto is not gonna be the
weakest link usually crypto people don't
attack it they're not gonna go brute
force crypto they're gonna work around
it and that kind of phrase that Bruce
and I are used once and he's a big
crypto guys it's like putting on a bank
vault door on a tent you could have the
most powerful strong key crypto
algorithm there but it's the rest of the
system that people are gonna attack
they're gonna look for the weakest link
and it's very rare that you see attacks
directly against the crypto algorithm or
you know brute-force attacks very rare
that ever happens usually it's in the
integration so things like I talked
about WEP
and the Wall Street Journal cookies and
Xbox all these things they weren't
attacks against well Xbox an exception
they weren't attacks against the
algorithms they were how they were
actually being used and however they
were put together and these are hard
lessons that we've learned these are not
you know it's taken 25 years of crypto
papers to start thinking about these
attacks so it's not that people don't
know how to you know people are stupid
and can't figure out crypto it's that
these are subtle and these are hard to
figure out and you know they take a lot
of time to sometimes to figure out these
attacks and they're not always apparent
so takeaway from this is that crypt is
just one part of a whole system it's not
the end-all be-all of security
you know encrypting things is great like
you know example might be if you're
storing files on disk but brings up all
these other questions of where you're
storing your secret keys and who's got
admin rights and you know is this
patched up and then just the whole
system security needs to be looked at
and you know this is especially kind of
you know on blogs and things like that
people will get focused on key lengths
and which algorithm you're using and
what hash you're using and it's
important but it's just one part of a
whole system so one final thing is snake
oil so if you go on the internet there's
a ton of crypto libraries out there and
I've kind of taken these from Bruce
Schneier he's got I got a couple links
on the wiki but some warning signs of
snake oil crypto one is that there make
a lot of like pseudo science claims
they'll say this is a new field of math
this is a new thing that we're basing
our crypto on and generally if it's not
published in a peer-reviewed paper in a
crypto conference I'm very skeptical you
know whether this is legit and this
comes back to this idea of having the
algorithm public having it open and you
know somebody makes some pseudoscience
sounding claims they may sound
convincing but if I if this paper hasn't
been published I'd really don't believe
that this thing is solid this idea of a
lot of times people will say that's
based on some new mathematical field so
one you know experience I had as a grad
student was
this guy contacts me he's like oh we've
got this new crypto scheme and it's
based on chaos theory and comes in and
makes me sign an NDA and you know I look
at like well this isn't secure it's not
you know here's here's some issues with
it and it's not really an improvement
and you kind of ignore what I said and
then later on you know Bruce Schneier
does this great thing where every month
is a newsletter and might have it done
company that's in the doghouse for
making these snake oil claims and these
guys ended up on there so it felt kind
of vindicated that I was not like you
know just missing the next great
technology but yeah you'll see it
they'll say it's on chaos on who knows
neural-net
whatever generally it's very hard for
somebody to make a transition from some
map you know a mathematical field in
group theory whatever to being used in
crypto there's some exceptions it's just
why I have a star there
some things are lattice work you know in
the 90s there's some crypto schemes
based on lattices that jar you know held
up pretty well for about the last ten
years and kind of the jury's still out
on another thing is pairing based crypto
which is very released in the last five
years or so and these are kind of you
know new applications of math and crypto
so that they do happen but again this is
kind of a warning sign proprietary
technology we talked about you know
people who won't show you the source
code that's secret and make you send the
NDA very skeptical with crypto kind of
clueless claims like they don't make any
sense what they're saying huge key
lengths so some of these things they'll
say we've got our key is six megabytes
and you know things like that or just
kind of things that don't don't match up
if the key is bigger than RSA keys I'm
very skeptical it's kind of upset she
claims they'll say you know this is
claimed by security professionals like
who are they talking about who who you
know review this proof of security now
I've got a star on this because you know
some of these companies will say you
know it's proven ly secure its
unbreakable ball of law and then in the
theory of crypto world there are people
who do do security proofs and we're
gonna talk about what that means next
week and even within the the crypto
community there's kind of a
a war going on right now between Neal Co
blitz who's a guy who designed elliptic
curve cryptography and some other
cryptographers Oded Gould Reich and Buzz
Barak and so these are like they're kind
of going back and forth about what it
actually means to be a proof and so you
know Co blitz is kind of a mathematician
and he's saying all cryptographers their
proofs don't mean anything he's kind of
attacking it and then they're saying oh
well you know I need to do this prove
the security and this is kind of going
on the open last couple months it's kind
of like what does it actually mean to be
secure what does it mean to prove
something secure that's still something
that's being worked out among academics
cracking contests again I've got a star
here and because you've seen RSA
cracking contests you've seen des
cracking contests these are kind of
different because these snake oil
companies will use that as the basis
their security like one of them they're
giving away a Hummer a Hummer Humby and
that was their base secure they're like
oh we've had a Humvee you know give away
for a year no one's claimed it no one
could decrypt this message and like that
was their argument versus the RSA
contest they were doing that to
establish the state of the art how good
people were at factoring numbers and how
you know powerful the algorithms still
remained after the years so cracking
contests I would say generally it's a
warning sign but it depends what the
motivation is and finally one-time paths
you know we talked about this last week
about some of the issues with one-time
pads and you know shayna example in a
sec but one good question to ask and
next week we'll say what this means is
just ask if it's a semantically secure
if the person has no clue what you're
talking about
they probably their schemes not good if
they're able to answer it kind of
meaningfully then maybe they get their
foot in the door and you can look at it
some more and yeah we'll talk about what
that means later and you know that's
kind of interesting way of defining
security for crypto schemes so as an
example responsive script
I grabbed this from one of the doghouse
things and this is they're selling it
for seven dollars and fifty cents you
can you can buy this and you know I'll
just read some of the excerpts most
violent kryptos use messages that rely
on the theory of computational security
that is the difficulty of key
factorization prevents decryption of the
file this bar keeps raising as computer
prowess power increases product X is
designed to be used designed to use
conventional xor encryption on keys that
are the same size as the file to be
encrypted this is known as the one-time
pad and is completely unbreakable even
to computers 1,000 years from now you
know this is the kind of stuff that
people are actually trying to sell his
products and there's you know dozens of
company that companies you know people
out there trying to pass off xor as the
next big crypto thing out there and so
the reason why I have this whole snake
oil slide is that it comes up again and
again and you start looking at it and
you'll grow more and more skeptical as
you see crypto schemes out there so
pretty much wrapped up to the day I just
you know one drive home the point if you
want to use crypt it on your code talk
to security team you know we've got the
tools we've got the experience and you
know if we don't have what you need we
can build it for you
another things this is part of the
exercise is we've got an in-house
library called key master and I work on
that and part of the exercise is
actually doing some stuff with key
master generating he's using it to
encrypt you know verifying a URL and
this is an ongoing project it's kind of
work in progress and you know I I would
appreciate any feedback you have on the
documentation it's kind of you know
still being worked on and if anyone's
interested in working as a potential 20%
project please feel free to contact me
1:02 this will be open sourced hopefully
within the next year so right now that
you know we're gonna take our existing
library and then translate to something
can be shared with everybody because
it's a very useful tool and one thing
keymaster does is basically tackles a
lot of the things we've talked about
today sign cipher texts has key rotation
built in use
right modes uses right random sources
right IVs so all these things we talked
about today one thing that's nice about
key masters that kind of puts in under
the hood and gives the programmer an
easy in an easy interface so you don't
need to touch keys you don't need to
generate IVs it just happens and does it
behind behind the scenes and you don't
need to worry about it and it's got key
rotation built in so a lot of the things
that we talked about you are not gonna
have an issue with in your code anyway
that's all I have today and I'd like to
open up to questions and I'll try to
remember to repeat the question because
I had some complaints about that last
week
so the question is I I said do not sign
a Crip at the same key and is that the
default behavior in GP GP GP I believe
they actually generate two keys and
treat them as one key object so when I
did it they had an alga Malky and a
that's for the encryption that camera
member they may have at DSA key for the
signing so
yes questions can i summarize the patent
stats for RSA RSA is out of patent and
it has been since we've been 2000 but
it's it's in the clear some of the
things I think Oh a ep pretty sure
that's not patent protected and most
these patents have expired
AES is government standard no patent
sha-1 Garmin standard no patent same
with DSA yeah pretty much all the major
crypt of things have no pants on RSA
definitely is is out of pad protection
yes this is a very good question about
exporting cryptic technology and as of I
believe he's also mm maybe 98 before
that crypto was considered a munition so
used to see t-shirts that said this
t-shirt is a munition because it had
crypto code on there and it was illegal
to export crypto source code on a disk
but you could export it in book format
so Phil Zimmermann the guy who wrote PGP
wrote a book that was just source code
and had it in a very scalable format and
then shipped it to Europe and that was
totally legal today in the US you can
export crypto strong crypto any country
that's not on the state sponsors of
terrorism list and there was five left
which actually has come up here that you
know we do hire people from Cuba from
Syria and it is an issue if their
national of those countries that you
know what what can we what is actually
giving them what is exporting other
countries it really varies ee you is
pretty liberalized there are some
countries where it is very restrictive
Saudi Arabia I believe it's I may be
wrong in this but at one point in time I
think was illegal to use encryption or
encrypt Internet traffic and I'm not
positive on that so don't quote me but
yeah it varies around the world and
there is a I think it's epic it's a
group that they publish annually a
survey of crypto laws around the country
some sort of Internet freedom survey
yes so the question is is kind of
vanilla RSA you know the the textbook
used anymore in practice and the answer
is not really I mean it's always used in
conjunction with some sort of padding
scheme whether it's there's one called
PSS and no AEP well we always use it in
conjectures and padding scheme I'm sure
there's people out there who just use it
vanilla and for signing it's it's used
in conjunction with you know a message
digests
you mentioned l-jamaa alcohols a
different crypto scheme so it's kind of
independent of RSA and we're going to
talk a little bit I'll go mall next week
because it's really cool cool cryptos
game okay good question
what's quantum cryptography and quantum
comes up in two different context and so
quantum cryptography is actually
encrypting things in transit and it
makes use of kind of quantum properties
of photons so the idea that I can't
measure this photon you know by the act
of measuring and I might change its
value and it's pretty interesting you
can actually I mean the pretty simple
idea is basically you polarized photons
in two different orientations to be ones
and zeros and the person who knows the
secret key can read them in the proper
orientations because they kind of slide
through without actually changing it if
you don't know the key and you try to
measure it it's kind of this quantum
property where you may change the value
and actually not know you know whether
you change the value or that's the right
value so interesting with quantum
quantum crypto is that you can detect
when people even try to eavesdrop and so
recently there's a thing in Switzerland
where they'd built this on a for their
elections and it's a little bit of a
hype somebody you know said it was like
using an armored truck to deliver like a
postcard you know like at the end of the
you know yeah it really matters what's
happening on the tabulation like using
this in transit does it really make much
sense
but as of today I think there are they
can be quantum crypto over fiber optics
at like 80 miles or something like that
and I don't really see it having a lot
of fractal uses outside of like maybe
government institutions for quite a
while
just because you know it buys you this
in transit security it's not actually
you know on disk or anything the other
thing the quantum comes up with that you
hear about a lot is factoring so RSA is
based on the difficulty of factoring
large numbers you know they're the
modulus is two large primes and we don't
know how to do this fast in classical
computing but there is a fast way to do
it in a quantum computing model and it's
really one of the two algorithms that
you know put quantum on the map Peter
shor came up with this and I think the
early 90s and basically you can you can
factor in quantum computers and so if we
could build a big quantum computer with
a lot of qubits then RSA is could be
effectively broken the problem is though
is that having a lot of qubits on the
quantum computer they interact with each
other and so I think last I I read
somebody built a quantum computer with
four bits and factor the number fifteen
so don't use fifteen as your RSA modulus
but you know it's this could be you know
reality people are making advances in
every day and you know 20 years RSA
might be effectively dead I don't think
this affects things that are based on
discrete logs so algum all the
diffie-hellman key exchange we talked
about last week I am unaware of any
implications that quantum has on that
but yeah so those are kind of two big
quantum crypto issues and there other
questions all right thank you very much
everybody and next week we'll talk about
some theory
and I think the planner for the final
week I've actually invited a guest
speaker to talk about crypto voting
protocols it's really cool to talk about
things like you know visual cryptography
scratching Evo mix nets all sorts of
stuff
it should be a fun talk and it's not
going to be you know technical kind of
like the level last week so if you're
not engineer not into the math side
that's fine they'll be real interesting
talk so that's two weeks
next week is Theory proof security
definitions and things like that thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>