<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tinkercad | Coder Coacher - Coaching Coders</title><meta content="Tinkercad - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tinkercad</b></h2><h5 class="post__date">2011-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5aY4a9QnLhw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'd like to welcome Kai Backman here to
give a talk Kai was at Google for about
five years
he left nine months ago to co-found
Tinkercad which he's going to tell us
about now hi okay hey everyone I'm going
to start by doing the demo because
that's obvious in the cool part then we
can actually talk about what you saw in
a bit
this is Tinkercad it's a website you can
go to it right now it's called Tinkercad
calm it's a solid modeling CAD we're
super feature-rich when we get illusions
of grandeur we keep calling ourselves
the Microsoft Paint of CAD which gives
you kind of a rating how good we
actually are there's we don't feature
just one tool we feature two separate
tools two separate tools the first tool
is you can add stuff that's pretty cool
right see right there you can add all
kinds of different stuff around whatever
and the second tool is you can subtract
stuff so if you just added stuff now you
can take a piece away excellent
you can always do stuff like you can
change the plane where you're taking
stuff away or adding stuff so you get
slightly more complex shapes you can
actually rotate the plane so that you
take stuff away at the different angle
and this gives you more complexity but
this is more or less the full
application you can add material so your
model done with the finger modeling you
can take away material and you can
change the work plane where you put the
material in and change some or change
the shape of the thing so that's all
there is to say again yes see okay so
the question was can be precise but
about the work plane yes there's a
little widget here which you can
basically use to rotate the plane in
different around to get get something
that's slightly more specific than you
want it to you get angles and so for do
you have some basic measurement tools
but let's not go into that that sounds
like we're actually doing stuff that
like we're not that high-end yet we do
it but less
what you're seeing though is this is a
solid model I'm not gonna show the demo
again I just want you to kind of get a
given glimpse of what the application
although it's a simple website the URL
you see up there is a permalink so if
you one of you guys typed in that URL
you would actually see this model you
could copy it and start editing it again
you can tweet it you can mail it and so
forth
so that's the Laurel that's all there is
to it now we're done you can go home
unless you want to know what's behind
the covers so it's a deceptively simple
application but what's going what's
going on behind all of it is actually
pretty interesting so this is a browser
cloud-based application first thing you
notice we using WebGL for rendering we
basically launch the public beat up a
few weeks ago
more or less two weeks after Chrome and
Firefox went stable with the WebGL
implementation so there hasn't really
been a possibility to for doing anything
like this earlier there wasn't the flash
doesn't have a good 3d support there
isn't really a good way to visualize 3d
meshes before this is really cool like
we're totally in depth into the chrome
and Chrome and Firefox students we're
getting getting all the WebGL stuff
working in the first place what's more
interesting is this is a cloud
application we talked a bit more about
how it works but we actually run we run
a small 100 core cluster in our in New
York I think it's actually bigger now so
whenever you in operation there's a lot
more happening behind the covers than
just the client updating to give you an
idea rough idea what we're talking about
it's 40 K 14 K of JavaScript 17 K of go
and then four K of C++ in some tight
inner loops all of what you see has been
written from scratch so we basically
deploy on raw Linux machines we
currently are Linode but we could be a
normal ECG or something else we wanted
to all we need is some installed Linux
machine we run our own kind of systems
on top of that everything else like HTTP
servers etc is written all of those are
written in go we helps a lot by the
standard libraries but still it's
written by really
from scratch also and this this I'm fond
of telling people seem to think that
running a solid kernel from scratch is a
bad idea I agree so we decided to do it
four times this is generation four you
just are saying we basically rewritten
the whole solid core engine from scratch
four times in these nine months we're
working on version 5 or generation 5
that's something we can talk about next
year but as for now again a demo or talk
about the stuff we actually running in
production right now if you go to
Tinkercad comm this tech talk is gonna
be about the stuff you see there see I
skipped a time I did it already the
first thing I want you want you to
understand is we're talking about solid
geometry we mainly targeting printers 3d
printers what's called additive
manufacturing there's a bunch of
different technologies how they work but
the basic idea is that that they deposit
small amounts of materials that then
then fuse together eventually forming
the final object this is a slow process
but it's also quite flexible and very
precise process the problem is when it
really boils down to - like the hardware
lines there's usually some kind of
nozzle or something and the printer
driver needs to figure out when the
Nussle should be squirting out stuff or
when it should not be squirting that
stuff this is a very simple problem it
turns out coming up with the data
structure that can answer this question
should the nozzle be squirting or not
it's not straightforward there's a not
surprisingly there isn't and one can
only call right answer there's there's
tons of trade-offs in terms of or what
way you want to like what you want to
put your and faces on and what kind of
applications you're doing but it turns
out it's a really hard problem to come
up with a good data structure for
representing a solid in a two main
operation we are interested in is is the
basic query if I get a volume of space
or on specific point is this point
inside or outside the solid model the
second question is or
an operation we want to do given these
two solid representations we want to do
a boolean operation of them and and and
or XOR or a number of not very useful
operations but basically you want to
combine these two solid representations
end up with something that's still a
solid and basically how it work mm-hmm
mr. price this is hard there's probably
a handful of solid kernels in the world
world and to give you an idea of how
hard the problem is there's there's one
like high end CAD software that's so
good
that they actually actually include two
solid Colonel kernels in it and the
instruction manual says when you do an
operation and it doesn't look right try
the other kernel so basically there's
there's there's no way to
programmatically detect when things go
go bad so they're they're basically
counting on the user in some sense to
figuring out okay now things when it's
create and we need to try the other one
this is a hard problem just to give you
a hint to if you think we're really
smart we told it by cheating the
standard representation is called the
boundary representation this is if you
don't every dumb computer graphics this
is like the triangle soup very easy
demonstration this is a boundary
representation my hands are about
representation for its right way it's a
very very compact representation it is
super super compact especially if you
have really simple shapes like Euclidian
shapes and so forth you can store this
representation very very small amount of
space
it's very cool in that sense the problem
main problem when it is a bad data can
make the solid undefined for example how
does this work in theory your your
boundary doesn't have any volume so
you're kind of stuck with something
where you have boundaries but like
there's an opening and it's not clear if
the space inside a triangle should be
inside or outside in theory it should be
outside because there's a connection to
to the outside space but in most cases
you should actually want it to be inside
and the reason I want it to be inside is
now not a hole so obviously
and big but in reality the whole can
actually be a tiny tiny tiny like
submillimetre so tiny you can actually
see it usually the hosts come out from
floating point rounding errors and the
result is that that if you look at the
beer app you can't actually like it well
the problem is you take the beer app
give it to a printer driver the printer
driver basically decides to turn this on
all off switch roughly in this fashion
like randomly and then result is you end
up with a blob of plastic this is not
good this is a very very unfortunate
property question sure okay okay so
question is I'm talking about
two-dimensional polygons and we're
trying to build three-dimensional spaces
I'm not sure I understand the question
so if you think about a cube a
3-dimensional kind of space it can be
represented by four squares in space
right MB reps it's all two-dimensional
polygons so they don't they don't
they're not actually in most cases
planes some representations use planes
which is obviously better but in a lot
of cases what you end up is there are
really polygons so if the polygon edges
are slightly ajar you actually have a
hole in the polygon representation for
example one of the standard
representations for the 3d printers
called STL is literally triangle soup so
if you you have triangles and if you
have small rounding errors within the
triangle edges or or in the corners you
get those holes that's the answer a
question or are we talking about
different things
ooh excellent question okay so so the
question was how do you decide what's
the inside the polygon mean with the 3d
surfaces that's actually interesting
problem it's not trivial to figure out
there's a bunch of algorithms for
deciding it one of them is called I
think the famous algorithm it basically
says that you you Shooter a true the
like model and any count the number of
hops you're doing and then basically
like you shoot it from infinity or two
different point you add to infinity and
any count the number of polygons you
intersect and if the the polygon count
is odd you're inside if the polygon
count is even you're outside
that's one algorithm a simple on the
promise if you need to answer this query
very often then this doesn't this isn't
a very fast algorithm it is sensor you
to gas question or okay
another problem is combined with the
previous property that you can get these
kind of undefined behaviors if you think
about for example raycasting example we
just talked about if there's a tiny hole
and your array happens to go out that
hole now you're basically giving the
wrong monster you don't know if if
you're inside or outside any longer it
turns out that these algorithms
especially for doing buland's are super
tricky they're tricky in the sense that
a lot of computational geometry has has
tons of edge cases we have the base
algorithm then you have kind of 50
special types of conditions and special
types of cases and to do bullen's
correctly you need to get all these
cases right because if there's even one
case that's wrong then basically you're
gonna end up creating this undefined
geometry and you get all the problems
from before so the solid kernels almost
all solely kernels today are be reps or
many of the criminals Romans RB reps and
they're good mainly because somebody
some super smart people have spent ten
years fixing every last single bug in
them so they're like they're near legacy
isn't so much that they're in some sense
superior in algorithmic fashion and so
forth it's just that they're really
really solid pieces of code like all the
bugs have been fixed
they hope we're not smart enough to do
beer ups by the way which is why we get
to the chaining part a second bad thing
is that buland's the running time for
buland's is N squared so it roughly
comes from you need to find
intersections between triangles more or
less to to do a boolean and you
calculate intersections you
basically the worst running time for it
is N squared how does how you see this
is we trying in something like Rhino or
blender or some modeling program and do
boolean operations for example subtract
the circle from from a slab or something
like that what's gonna happen is is this
is a nice demonstration of laman by the
way what's gonna happen is the first ten
operation is gonna be some second you're
like wow this is cool this is super good
then the next few operations gonna be
like a second two seconds three seconds
15 seconds two minutes half an hour and
then you're waiting next week oh sorry
and cubed nothing squared yeah number of
polygons number of kind of distinct
surface elements on in the mirror so if
you basically had cubes that will be
good but often when he ends up happening
is you end up tessellating the surfaces
which kind of shoots up your end
combined with the fact that that's it
kind of every time you do a boolean
operation
the end result usually has has more
polygons than the initial and you
started out with this obviously isn't
very good
this means that bullen's our usual
second-rate citizens in most most
modeling software because that's just
they do it it doesn't make sense
exposing something the users that that
basically blows up in their face really
quickly like you saw in Tinkercad again
the only thing we have is two bullets we
have like we have the or and we have the
sub bullet more or less we don't
actually have any other operations from
one point of view we wanted to we knew
initially we started out we want you to
paralyze this algorithm we wanted to
basically make make the software run on
machines that didn't have too much mmm
so we wanted something that could be
paralyzed in a cluster cluster
parallelization of a bond representation
is hard it's not impossible but the
problem is that that you have a lot of
these global State how how the kind of
polygons interact yeah basically you
could tessellate down everything to
really small triangles
but then you run end up running into the
bullion run time issues and that's kind
of the only way to really solve it then
you can take those tessellate triangles
make small subspaces split down those
out on the cluster and so forth but it's
not entirely clear it's very easy to do
also it's industry standard this is how
everybody does it the reason everybody
does it is basic because it's compact
back in the day when did the first frame
I started approaching in the 70s mainly
memory was a big big concern you just
did not have memory so you needed
something where you could squeeze it
into a small space as possible all these
other things are kind of negotiable if
you like if your machine has certain
amount of RAM you can't make it bigger
it doesn't matter how if you didn't if
this is a bad solution because this is
the only solution gonna have so it's a
very good solution if your level memory
okay this is what we did we use a
volumetric representation instead we
don't divide space voxels is something
we forbid ourselves from talking about
but voxels is mainly what you can think
about the format is slightly more
complex than that but boxes are a good
idea of how it works I don't have
anybody play Minecraft then you
definitely know how this works we
basically have we take the whole space
subdivide it into small cubes in our
case we use aq cubic grid and for every
every kind of little cube we say we
start one bit of information as I use it
inside or outside super simple thing
there's a tiny tiny flying ointment this
this the space requirements are cubic in
run time record having a run time cubic
fragment is sad having a space
requirement this cubic is kind of I'm
not good yes that was for our generation
one thank you
yes you can orally compress it you can
do a bunch of compression stuff so in
the end what happens is that the actual
growth we're seeing like the actual
space like space probe or seeing is
squared and in this case n is the
squared error
so basically we're we're seeing that
that we're growing
basically at the speed the the the
surface area of the model grows so if
you had something like a human lung
which has a crazy surface area will be
totally post by it but most mechanical
models which is what we're targeting
actually have a very good surface area
to to kind of volume ratios so for those
cases it works out okay
we definitely optimized for for further
skating in a lot of cases for a very
complex model we're not too much worse
than the B rep because if you have a
complex model the tessellation is very
high there's a lot of triangles so the B
rep and stop storing a ton of stuff and
we obviously end up storing a ton of
stuff as well but we're not that much
worse the bad thing is that this is not
something that can be visualized
directly using a like normal computer
graphics card that's not entirely true
in theory you could write fragment
shaders and things on current hardware
that could actually visualize a voxel
space or a kind of bullock metric data
the problem is that the amount of data
is still huge and we store it all on the
cluster on the servers and we just the
pipe from the service to the client is
the clear bottleneck so what we do
instead is we use derivative derivative
of marching cubes to create a
visualization must mesh and then
basically send that to the client
instead it's also important because the
the the B rep is the STL format is
actually standard for printers so you
need to be able to create a mesh for to
actually be able to print these things
question so the question is how we
representing the space doesn't it if you
use an octree like space doesn't need to
get expensive form diagonals we don't
use a simple representation as I said
here we use something closer to what's
called a level step basically the sample
stores how far we're from the isosurface
which defines the inside the demander
between the inside and outside it turns
out diagonals are not harder than
everything else it turns out everything
is slow there's no there's no special
slowness
for like the fact that we use the grid
kind of a tree as orthogonal a cubic
grid doesn't actually add any sadness to
the problem where it's as slow and bad
even if we use some kind of like even if
you you go against the grid or even if
you go in in direction with the grid in
theory we could do some optimizations if
operations were just perfectly aligned
with the grid but those operations are
so rare that we actually decided not to
do those optimizations that sounds
answer your question right a good
property is that bad data
adds noise so with the B rep bad data
basically blows your thing up in most
cases sometimes it's fixable but in our
case bad days that just adds noise if
you have like one if you had one of
these little little like issues with
some corner or something if what you get
maybe a small indentation or or a small
hole somewhere inside which basically
like that that's nice you get from the
thing you can occasionally say anything
you can model as if you are sampling
resolution is it super high yeah you can
occasionally see like these cases where
you basically are running into alien
jitters from the fact that you you're
trying to try to represent features that
are too fine compared to the sampling
density you have the good thing is
boolean's are super super
straightforward to implement you
basically take the RLE encoded one is
the good example the first one which
i've wrote which has prompted revisiting
my some deals much better but the first
one was basically it's like a merge sort
you weren't walking down the two are
early data structures then you're just
like taking a span throwing away
combining two like it's a super simple
algorithm it's super robust it's easy to
do different types of bullets and so
forth we like this and also cluster
paralyzation is feasible
I say feasible as in it's still a lot of
work like any kind of distributed system
but it's it's possible to splice up the
space you take you basically say here's
a here's an extent of samples I call
this a block in our case and then you
take these blocks and split them out
over the cluster and process each block
separately
there's tons of issues because for
example the mesh
Shing requires you to have slight
overlap between the blocks so we depend
for example on the boolean operations to
be deterministic which is sometimes
difficult with floats yes question the
question was to do orally encoding on a
level sets for storing in Arab and we
used to do level stats we no longer do
our form which is different nowadays I
think we stored I think was three
samples of narrowband when we did it we
experimented we've tried it out and saw
when it started right and I think I
think was somewhere it might be might
have been three or four samples of on
there open if not too much actually very
little very good question you seem to
have worked with my boss that's nice if
you haven't by the way encounter levels
that's ever it's an interesting data
structure recommend you guys look it up
it seemed invented I think in the 80s or
something for totally different purpose
physics simulations but it's an
interesting way of thinking about a
problem that's very different from from
like classical in my view classical
algorithmic thinking so in spirit of
Google are gonna talk about the life of
an ant apply and apply is basically a
single editing operation in our world
that's that's one of those like you
click add subtract or something all of
those get translated into an airplane
it's our most interesting operation we
have heartbeats and there's kinds of
kind of supporting operations and but
the main reason we wrote everything from
scratch is to make the apply fast like
we wanted you guys saw how he was we
were actually on the west coast the data
center and the East Coast it's not as
fast as it could be we want to data
center on the west coast as well but the
reason it's even that fast and not
doesn't take two minutes is the fact
that we've been like crazily crazily
focusing on just this one operation our
storage is basically we dump file
something in any high-tech that is but
the appliance is where we shine so
client side you saw had a user so it's
just like click bang and off you go
first thing we put up the spinner
it's a tiny thing but it's actually very
important to give user feel of where the
operations gonna be to give it a kind of
placeholder to to master latency we send
off an xhr request with with the current
revision of the part we have the current
revision basically contains a list of
block IDs to give it a server in any of
what blocks the client currently has and
then we send as payload we send apply
geometry the the shape you're doing and
we say if this is another sample the
response contains the new revision the
client is saying - it contains a new
list of block IDs this are 64-bit unique
IDs basically saying you're in revision
205 duration 205 contains these 200 work
IDs and then we added additional payload
we'd add all the mesh data for those
meshes that the client doesn't have
already so the service area knows that
you had these you had these blocks from
before you must have the
representational mesh for them so here's
the new list of blocks you need to have
and here's like the 10 new meshes that
you need to have fun before question ok
so question was the client never has the
full world German just a mesh data yes
correct the client doesn't have enough
space and we like the blow-up isn't like
a model like that is probably a few
hundred Meg or so but if you take
JavaScript blow up it would be like a
gig or some thing and also it's it's a
few hundred mixing between very
compressed form and there would be it
doesn't make any sense to have the data
on the client side really so so all we
always send back is is the
representational mesh for for nothing
xml httprequest thank you so a question
was what's the xhr stand for listen
microsoft invented technology to make
the web better i don't think they meant
it that way
but that's what they did so it's
basically an HTTP request with payloads
in both ways hmm we used to send back
the response as a JSON which then was
compressed with gzip nowadays the
browser's support us sending binary data
which is really good because previously
the problem was that
the mesh data had to be taken out of the
JSON and then pushed into WebGL arrays
and it says this is not JavaScript
strong points like manipulating tons of
tiny bits of data so so what ends up
happening now we actually get the binary
data we just dump that into WebGL and
then we have a separate processor that
parses out
we also embed JSON data so now what we
do is instead of having like a Meg of
mesh there that needs to be transferred
from JSON to binary we have like a few K
of JSON data names to take a binary to
do like text format which is much more
feasible so that's a client view if you
take away the apply geometric piece you
basically get our heartbeat so we don't
advertise this and we haven't actually
exposed it to users but you can several
people can edit one part at the same
time wherever they are like you can ten
browser windows open and just edit the
same part the reason we have it exposed
is we don't know how to do the UI it for
it correctly yeah it's not it's very
confusing like we used to have edit Wars
at the company
or basically like we have all all the
people piling on apart and just keep
like editing it's very fun but it's it's
it gets very confusing quick I also get
through it very quickly in depending on
your founders but video it's a very
interesting piece of functionality you
can do stuff like the viewer does
heartbeats too so if you do a class you
could actually like show the part and
then have people should open it up in
the viewer and they're gonna see your
updates as you edit the part which is
pretty okay the technology is there on
server side this is more interesting
some more interesting obviously more
interesting because I'm a server-side
programmer nothing another client
programmer so yes this is obviously
recorders or UI engineering we'll watch
it at some point and totally kill me for
this but what happens on the server is
is the client actually once you've got
the HTTP request for initial page it
actually takes
opens the xhr connection to a secondary
server which is our kind of we call them
the edge servers the edge server gets in
the request it prune
go through the list of blocks that were
kind currently operating against it
basically builds a primary list of
blocks for the new geometry we got so
but if your is if we're kind of adding a
cube it does a simple run where you
figure out ok this cube will touch this
in these blocks those cases where it's
completely inside a cube and the
existing block data says we're
completely inside kind of these boolean
cases that that this block on left hand
the left hand side block is full the
right hand side wok is completely full
it prints those out because obviously
those are very simple to compute so just
like calculates them to figure it out
what's the result is we have a
hard-coded UID is 4 4 totally full and
totally empty blocks all the border
cases are packed up split up into
they're basically put on a cue the the
server kind of fires off all the all the
requested to the solid servers the solid
servers are the bulk of the clusters so
we run I think 80 solid servers at this
point each solid server has a little QoS
based queue it takes in requests from
edge processes there's requesting based
on the QoS and then says the results
back so then all the little edge does is
it's very lightly loaded server all it
does is taking the request as some
initial really easy pruning to take out
the easy bits fire off all the different
waste all the solids and then waiting
for the responses and as the responses
are coming in we actually like put them
together in the fly so the edge edge
gets flayed blocks and we have like an
open gzip response so that we can
actually get the plate blocks in
different orders it doesn't matter like
as soon as it starts getting responses
back it start sending bytes back to the
client and then eventually they're all
diminishes arrive and bang you're done
there's a bunch of retry mechanism this
is this is there so you you guys server
programming this is obviously not as
simple right you need to do retries
machines go down etc etc etc so there's
a bunch of stuff going on to make sure
that everything actually arrives but
that's roughly what edge does mmm so
leads to actual work they get two blocks
of
you know daddy actually sends the block
at this point to the solidus they
perform the boolean operation they mesh
the volumetric data create a new kind of
representational mesh of it this mesh is
really dense it has tons and tons and
tons of triangles it runs a dozen
simplification passes over that mesh
basically to throw out triangles to make
it more more easier to visualize that
visual sighs and then lead and coastal
results compresses the results and sends
the results back to to do edge our
target deadline for all of this is 400
milliseconds we mostly make it we have
issues with with laggards so if if a
solid server is overloaded or slow for
some reason that slows down the whole
request at this point be thinking of
doing optimizations like sending it to
two solids having some kind of deadline
if you don't get a response back in like
50 milliseconds send it to some other
solid and so forth Court suggested who
ever guess worked on search this is very
familiar to the type of problems search
phase the difference is we can't drop we
can degrade quality we can't basically
take a step back and say oh it's okay if
only half of them succeed because
obviously what's gonna happen for the
user is they're gonna get something
weird looking because half of the stuff
is missing so we actually have to get
everything completed to be able to
return the request but there's a lot of
stuff we get to do I think to push that
400 milliseconds down you'll also know
this is a single pass algorithm we
talked earlier about about how you need
to have a real lab specifically the
simplification is the part where overlap
is crucial we could do meshing without
having overlap okay that's not true we
need to have one one sample overlap to
do machine properly I think and we need
to have two samples overlap to do do
simplification correctly because we need
to calculate normals we've seen issues
which are very very uncomfortable where
different machines do the same
operations to get different results
most of those has been tracked down to
some kind of floating issues we don't
like floating-point we very much don't
like floating-point
diploma it doesn't seem to be a
deterministic system to do stuff this is
obviously a problem we're to two
different solids computer result the
mesh doesn't match up and then because
we use actually this mesh to send to the
printers we get the same problems you
get from via rap that there is like
issues cracks in the thing we think we
fixed all of them at least the known
ones but obviously there might be some
some of them lurking the good thing is
that if we screw up with meshing the
solid with a B rep your model is screwed
like it's very very hard to to kind of
go back in and totally fix it in our
case we can just push a code fix and
then as soon as you do a rematching
which we always do like once you learn a
part of the first time we actually
remesh the whole part on the fly so for
us it's like the solid representation is
always stable and if we have a problem
with the B rap we can just like push a
code change and then everybody gets the
fixin's
immediately which is we think a better
it's like one one-way flow of data so
that's the server side questions okay so
WebGL so the rest of stuff again I'm
going to talk about WebGL and go which
are kind of the two big new things we
use we use a bunch L we use a bit of C++
for for the inner loops in the kind of
solid operations we've wrote the three
first generations that go but the fourth
one we basically run into into SSE
optimization issues so SS the
optimization Jesus is just so much
better and the difference wasn't too big
and we basically got we benchmarked the
last version we got go was about 1.7
times slower but in our case that's
actually important and the second one is
is that the coder was a bit of code blow
up the go code wasn't that's very easy
to read which is interesting because all
the distributed code is much much
smaller
anyway Oh WebGL the big good thing is
WebGL looks very very very similar
similar to OpenGL yes
I'm probably gonna be corrected here but
I think it's almost one-to-one with the
es back right yeah so it's almost
one-to-one with the ESP
this is big yes is for another way it
actually stands for but it's basically
like for mobile devices like iPads and
iPhones for it
our main UI code or graphics coder has
done games for 20 years and it's not
like open jail for years and years and
years but in the last few years had been
basically working on iPod and the fact
he's never done any he started doing
JavaScript nine months ago which i think
is impressive
but the fact that that he could
basically drop in on WebGL without any
thoughts about how it works was super
super cool so this for us was like a
huge huge thing compared to almost any
other API like flash is talking about 3d
API stuff all of those would have meant
that we would have to learn a new API
and to get up to speed with WebGL I was
just like drop in and you're done this
was super super important one of the
problems is that the the browser adds
one more layer between us and a graphics
hardware those who done in graphics
coding know the graphics hardware is
famously dodgy it's it's very they have
a different idea of what stable means
compared to to say say normal gee CPU
manufacturers there are sort of drop
bugs and drivers there's tons of bugs
and other things we run into some issues
where basically we don't know if it's
our problem
the driver problem or a browser problem
not too many in most cases so far it's
been our problem so which is pretty
common this is a two-edged sword a sword
one hand this makes some bugs for us
slightly harder to to debug on the other
hand we believe that this is the first
time probably in history when there's
like a focused group that can put
pressure on on graphics card vendors to
actually write these and drivers like
another it's like somebody you can
actually say yes we're running this
thing we need to make it run like for a
while so let's make sure this actually
works
we think this dynamics is good we rather
have have like the chrome people push on
and media on ATI to get better drivers
then have asked for shown for shown the
same
okay so was comment was basically that
the grammys car driver or graphics card
manufacturers say that there is a
different class of device is called were
station cards and then those are more
stable and so forth
I'll tell you a story so egi
manufactures the car caught fire deal
which is a workstation card you're
almost right but not quite
I used to write code for fire jail and
one of the things I was I was running
point and there's a view plane right and
I had point fly basically wall all
around the viewer when a point would go
behind a view plane what the spec says
should happen is nothing the point
should disappear obviously because it's
no longer visible it's behind to be a
planet so forth what happened was that
the point blew up to a full screen fill
so you could get this like I think was
the two grand at the time the car it was
a very expensive or you could get this
two grand card on its knees by rendering
two hundred points
I dialed them up and said like what and
the answer was basically no kind of
endor uses points go away they didn't
they never fixed it what happens
actually is and this happens in games
too like high-end games they they
coordinate the the vendors of high end
CAD software or ohon or like AAA games
they coordinated with the graphics card
drivers so they actually like in terms
of workstation they released drivers
very rarely and then they certify the
application against those drivers so so
they basically fix all the bugs until
like Maya or or 3d studio works and then
I say like ship it and with games they
occasionally do stuff like if they have
an na release on some specific date they
release a new driver like two days
earlier which they've been debugging for
the past month and soon kids with the
game to make sure that all those people
who buy the game in the first week are
gonna get a good experience which means
the half a year later you might actually
actually not get the game to work as
well so that's that's a solution to this
problem it's basically like
backroom lobbying and so forth we're not
powerful enough to do it so we hope the
chrome team is did you answer the
question but I were to call address the
comment okay you need to be careful
about managing data on the JavaScript
side we talked about the fact that we
don't put the solid data on JavaScript
side blow up is crazy javascript is not
a language for doing doing tiny like
having data in a very very small space
it's a language for doing something very
different we seen it with with kind of
auxiliary structures like picking
structures trees to be able to pick
different structures and so forth
we need to be really careful about how
we encode those the encoding you were
doing picking like go or C++ isn't
necessarily encoding it what I have with
the JavaScript side okay general it's
just it's still early days we launched
basically I think a few weeks after
chrome went to stable with WebGL we came
up with the public media so we're like
we're so so much in the leading edges
you can be but currently this is
absolutely the best option for doing 3d
in the browser hands down there's no
question about it we like the fact that
it's standard we hope it's gonna stay
being the best option as well but
currently as if you want to do something
today this is your best part go
thank you I spin it all on go go is the
programming language from Google if you
guys are gonna wear it looks I keep
saying it's better see we wrote five
core servers and go HTTP these are kind
of the one that serves the site and
that's the basic requests edge it's the
server Chopra also serves HTTP by
basically served a publication request
solid service again this one you seen
before is the ones that actually do the
processing the solar service actually go
process that embeds a C++ press or if it
starts to C++ processors under recover
to basically like do dual actual work
all the coordination work is done about
a girl thing the C++ thing is super
simple it takes in a set of bytes
crunches crunches and give us how to set
up byte
it goes had actually does a lot more
logic lock service a chubby style lock
server it's a
we currently don't run a Paxos DB under
it we're thinking of adding there's
something called oyster which is written
in also written go which is as far as we
know the best option for adding paxos in
any language currently we probably going
to put a practice-based or under it it
provides locks it provides atomic small
files provides a cache client-based
cache if you if you know chubbie this
this looks very much like choppy node is
our we run node on every single machine
it's kind of our log collections slash
user space process management thing you
make sure that the process is on their
own when a machine gets restarted that
we actually capture the logs send them
out you collect them and analyze data
and so forth the notice is then
obviously kept alive by in it it's a
very small piece of code we try to keep
it really stable we also have three
auxiliary service returning go Sentinel
lists are our monitoring server it pulls
both data from the node service in real
time and kind of gives an ability to get
graphs analyze logs do runtime like
operational analyzes or what stuff
what's happening progress a load test
wrist lash / kind of testing framework
and we also run in a cluster what the
deploys are continuous deployment demon
so we run perforce surprise coming from
Google
we run perforce and and then o to deploy
listens to the peripheral stream
whenever just a special tag saying boy
it basically pushes those changes out to
class to make sure everything is fine
falls back if things doesn't work out
and so forth so we don't do manual
deploys at all we used to have the
facility for doing manual deploys but it
turns out after six months we haven't
done a single one so we just ripped it
out and use auto deploy
it's it's totally live service it's
super great you have ability to shout we
push changes to the site maybe five or
six times today maybe 10 or 15 times so
depending or hacked if we are depending
on the day what you're coding on so the
site is almost always very close to the
tip of code we like I used to work on
the go team
Google I've done a bunch of go program
before I even like left for the startup
I think at this point in time go is
probably the best language to write
concurrent services there's there's Earl
I know there's a bunch of other
languages I think go has a nice
combination of C style very tight memory
layout management which is something we
need a lot for because we push so much
data around we need to be really careful
with every bit how we kind of push data
how it looks in memory to make make
caches work and so forth and he also did
the only language where we can do this
and at the same time have a very good
concurrent server like like edge runs a
ton of stuff ton of go routines to keep
track of all the different states which
means that the different go routines are
super short and simple it's really easy
to follow them this would be very very
hard to write in any language it's hard
to describe like I've done a lot of C++
development a lot of other language is
we just feel more productive and fast
writing services ago it's hard to say
like all these these are probably good
reasons but I would not like you have to
pry it from my cold dead hands at this
point
C++ is faster and more productive for
computational geometry we found that we
talked about the really the small inner
loops the main problem is go doesn't
currently inline functions so we end up
using a lot of tiny function for tons of
of weird operations and the second thing
is C++ or GCC specifically actually SSA
and SSE encodes these so in the end we
found that the the really this kind of
the loops they're a kind of weird code
we used we use some things in C++ which
aren't pretty but it makes us us makes
us lets us compress those inner loops to
a shorter span which makes them readable
because they're really difficult
algorithmic problems and and if even a
small blow-up makes it really hard to
read so for example
macros we use a ton of macros to get
inlining very fast and then we use the
templates in some cases to do some
functions where you have you have
templates on on floater
float64 and you can basically you can
read the code the same way you even have
used two different types of floods that
type of stuff I think those are those
certain ones that I really like I think
inlining is the biggest one like if we
had in lighting we'd probably be much
closer for us the performances is a
killer eventually as well it wasn't only
about this point to this we're still
debating about that well Matt this point
c++ first but we're probably gonna do
benchmarking in which generation five go
note so this is my last line we run
servers we go max proxy equals 1 which
means though is we find go to be super
good for concurrent stuff but we know we
find actually we get better performance
out of it if we manage the parallel
stuff on a process level as opposed to
inside the process so for example we
treat GDC at this point we treat GC
slowdowns as any other type of slowdown
like Network slowdown so forth like our
architecture doesn't differentiate
between a GC running on a solid or or
the network just being slow to the solid
on it being constrained in terms of CP
or something so we we did a bunch of
benchmark benchmarks that came to the
conclusion that we push the parallel
stuff once one level above we use proto
buffers for storage we need to too much
data in numbers languages use gums for
transfer pretty easy naming convention
we have we have a hard time finding good
names for for functions that are at the
root for go routines and then for
channels this is what we came up with we
call everything where you you say go foo
we go it go through loop and that way
you can kind of identify the entry point
this is something if you're not a go
program it's not gonna make sense go
program is a program nodding or have
some really good suggestion we'd love to
know how other people do it because this
seems like a good some convention here
seems useful we you think source request
response as names for for channels to
kind of signify flow of day in a
direction of data and so forth we again
we found channels we found a channels
kind of require slightly more ornamental
naming that normal variables because
often they're in slightly different
position than normal variables and then
if you come from C++ which was a really
hard hard thing
for our poor poor graphics coder he used
he's like a stickler with memory he
cares like when he writes code he he
like he feels pain for every mile lock
that's in there and he basically until
he realized that he can't do stack
allocation he was he was just killing
himself you know the problem is that a
stack what you think of his C++ a stack
allocation that actually be a heap
allocation which obviously does not make
him happy right so once he figured out
that he knew nice to use arenas and
pre-allocated blocks of memory stuff he
was fine but it was something that was
just like it's very hard for him to to
grasp that's about our experiences
thanks this is a MakerBot one of the 3d
printers by the way these girls love it
questions should we don't know how so
the question was do you need to really
consider using BSP representation we
don't think PSP is BSP is a pretty
specific type of representation we think
it works for for game levels really well
we don't know how to do good bullets for
starters I think you I think a good
bullet would boil down to about the beer
app type of boom and it's interesting
question though no we really didn't
think about it too much but I assume
because we kind of put them into in the
mirror class right exactly well did you
come to us at the bit unrelated to her
house bullying vs Febrary then it's
certainly possible so okay fair enough I
don't know we didn't consider it no
question
okay so to compute software engineer in
the first row said that he likes a
program called openscad which is
basically a CAD program where you write
programs and you end up with a bullet
result yes we thought about doing
specifically where and this is a road
map we haven't like figure out when and
where but it's pretty clear that it
would make a ton of sense to be able to
take an opus CAD program and have them
have the solid up here in Tinkercad we
think that seems like a very like clear
use case we don't know when we're gonna
get to it yet but we think open scan is
actually the coolest thing ever on the
planet
if Tinkercad is something where you just
like do concrete modeling and it's very
like tangible openscad is the one where
if you want like control and I need to
do more there's a lot of shapes that are
very hard to do by hand like like
helixes and stuff and those are
fantastic to do by out that's God so we
think that that openscad we like to have
opus country kind of BR the parametric
part of our software if that answers
your question we love it will work to
integrate that mr. summary I think it
was one more somewhere there okay the
question was what users are we targeting
we expect with a primary at this point
we're targeting makers
so roughly anybody who has some 3d
printer access to shape ways or uses
Shapeways or anybody who wants to do it
we find a lot of people who the current
that we think there is about this
segments about 200,000 people roughly
there's much less printers and much less
people actually use Shapeways but a lot
of the people who come into our you
stinker guy like right now and Abita are
basically like wow this is cool I should
buy a printer so so we we find ourself
leading kind of adoption of the printers
so it seems like people first want to
try it out to see how how it works how
they can do stuff and once they feel
like wow I can actually this looks
pretty cool I want to go in and print
this out so that's kind of the second
we're targeting first that's the segment
that has the most paints at this point
there isn't really a good especially a
good browser-based solution for for
makers who want to do something on
unless their MakerBot
okay so question was how does the data
get to the printer there is some in
projects you can download an STL file
and the STL file is the standard file
format all almost all the printer
printer drivers takes to basically take
that and drop into the printer driver
software and you're not if we had
integrate we will program an integration
with shapeways so what what that would
mean is you wouldn't have to do this
step you would just say print and then
bang we would take care of sending data
Shapeways they would printers and you'd
on the model back question so the
question was we're sending that we're
sending about the data back is binary to
the browser the question that's WebGL
have some way of taking here's a bunch
of binary interpreting Britax alright
yes it does this is fairly new stuff I
think the spec only finalized a month
ago or so okay okay so I'm correctly
it's been around for a while so we just
haven't implemented it but yeah so the
comment was that is it just like packing
versus an index race you know vertically
isn't it OpenGL yes
it's basically the server packed them in
in the binary format which is done
exactly dropped into the vertex arrays
to get the final data and we done some
of the day we just parse some beginning
of the data to actually get our JSON out
to have the rest of the response
question so the question was that we
only have two boolean operations is this
sufficient for complex modeling and is
there something in the printing that
inherently requires not just to used to
so answer the second part first
no there isn't anything inherent in
print in that requires us to use just we
could use any I think there's 16 in
total I mean like if you have to think
there's a bunch of mirror once and so
forth you will down I think you get five
of them
since we do there's obviously stuff like
XOR and things which you could do we did
not actually think the user would find
them useful like like we walk down the
list and adding and subtracting or seem
to be the only ones that are actually
needed to get stuff done we can't think
of corner case it would be really cool
to have some really like one of the more
odd combinations but it's not clear that
that's actually so adding a third
operation is added kind of user
interface cost it makes it again more
complex it's one more thing for users to
learn so far we think basically the
feedback that adding more operation
would be more would do more damage in in
making the application harder to use
compared to the power in without to
users in some special cases almost all
the special cases we figure come come up
with there's some better way of solving
that special case than using a boolean
operation a lot of times people wanna do
like surplus and stuff and their
solution is for us to add a sphere tool
instead of adding of having just
cylinders so in most cases we found that
there's a better solution than adding
one we open obviously to adding it's
very simple on the current side but the
decision to just have to is basically
you are decision okay so the comment was
basically a twister taper or some other
modification yes we want to do all of
those but now that you guys know the
internal representation doing a taper is
essentially shoveling around a ton of
bits because we need to redefine how the
whole whole kind of certain like solid
model not doing a final transference
it's not easy with this representation
it's doable but it's not easy we want
you to add those there's a bunch we want
to add the stretch for example that you
could take grab to answer a piece and
stretch it to have the middle stretch
out and stuff like that what kind of
rotate and so forth
Oh questions sorry yeah can you say
something about how hard it was to bring
it here you you can't hear me you there
can you say something about how hard it
was to bring the other members of
I'm going to unmute yourself yeah okay
doesn't work okay there you go
any more questions so the question is
how we totally ruled out adding more
organic tools like game tools like set
brusher and that type of tools do okay I
would like to read a student no son no
we haven't we decided to try to target
mechanical shapes initially because we
felt that there was a bigger lack of of
a tool to do mechanical shapes actually
to get these sharp corners and kind of
sharp features we have is much more
difficult than doing organic shapes
technically we need to do a lot of magic
on the data to actually extract where a
sharp corner is the default for this
data format would be organic shapes the
reason why most of the kind of it is
this set brush type with tools have soft
shapes but don't not have too much sharp
shapes because sharp shapes are actually
harder we wanted to do sharp shapes
first so that basically one if once we
done them it's easy to go back to
organic ones I just thought yesterday
somebody had modeled bunny in Tinkercad
by basically like painstakingly making
the tool shape smaller and smaller and
basically going in and like cutting off
smaller and smaller pieces of it yeah
he's probably spent like seven hours or
something it was a cool-looking bunny
but I was like I was like we really need
to add some tools to help so it's a yeah
I think there's there's definitely I
need for more what kind of software
tools just two today for my point of
view is just more tools it is pretty
easy to add them technically but we just
haven't like we don't wanna we're trying
to keep a break on all UI changes to
make sure that the product stays really
simple really conservative you're adding
new stuff but this seems to be something
that people want to do it in once you
like take real-world things and
so we probably have to people are gonna
go down that road comin to basically
this is more like woodworking as opposed
to working with clay I actually wanted
it to be more working like clay nowadays
when you see an operation you basically
make a line and that line is then done
and I want it to be like a free from
brush you keep like going like this and
then my dear co-founders Vito the fact
that we would need like 10 or 20 times
more mushiya's for it is and it seems
like we didn't make it firmer sure one
we might still make it eventually but
it's obviously a computationally much
more intense to do something like that
okay question was if you want to make a
cube that was hollow inside do you have
to basically like make the cube take out
the hinners and then add a lid or could
you actually go in and take the inside
out you can actually go in and take the
inside out so so if you if you position
the work point I'll actually show you
show it because it's not too difficult
so I move the work plane up a bit like
this I think I gotta do it like actually
I need to make it smaller so so I'll
show it just on a corner because
otherwise you're not gonna see it so
there's a tiny hole in there so I could
do the same thing in the middle of here
or somewhere where there isn't actually
stuff okay there's a tiny hole in there
the problem is obviously you don't see
at all if you went if you went out and
printed this they would actually the
printer would make a hole in the middle
and that's it like you as you see the
problem isn't the fact you can't do it
problem is that the the user feedback
for the holes in the middle order part
is lacking that's a proper turn
you could have a flow so the common ways
you could have a floating thing inside
there's actually a model which has a
whistle with the ball of the whistle
inside the whistle and and it doesn't
fall down because there's like a tiny
support strut once you print it you
basically goes through driver pop it
loose and now we have a fully working
whistle with a ball that that never was
inserted in the first place that that
kind of money when you print that out to
people it kind of blows people might
especially because it very loud whistle
I love it questions
okay okay so question was what about
extensions we love to do them bunch of
people and ask them asked us about them
obviously already making a good
extension API is hard we're currently
not doing it we're not gonna do it right
away we want to think about it a bit me
wanna mainly collect what type of
extensions people want to make a bunch
of the stuff people want to make it's
basically stuff we want to do anyway
they're like they're missing features
and they're like well I want to do an
extension to this we're like oh that's
really cool but we actually think we're
gonna do it ourselves I think there is a
valid world of doing extensions that are
more there aren't like core features for
example integrating with opens God would
open up kind of an extension wall
because then you could write openscad
programs and stuff this is something
we're obviously interest in I agree with
you this is a good tool that could be
used as a platform as well and we'd
certainly like we ourselves have tons of
those widgets here earlier I was bathing
in yes I was talking about a height map
they have like - update and I want you
to print it out what shape is basically
says they can't print out the height map
they need a solid model so basically
they could write a little Python script
- to take the height map and import in
Tinkercad
or some other arbitrary type of data
which is happened to have have like
lying around or you want to solve the
model from so yes we want to do it but
it's we don't a rush into it because
it's actually we think it's designing
good API is hard okay
question
so when I watch summarizer coming
basically talked about adding more calm
like features but I think without going
into detail you just described something
we're about to implement in a few months
thank you yeah
if I understood correctly I might not
have more questions okay I think we're
done thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>