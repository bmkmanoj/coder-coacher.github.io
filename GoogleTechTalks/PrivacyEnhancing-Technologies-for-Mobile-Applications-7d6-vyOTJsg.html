<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Privacy-Enhancing Technologies for Mobile Applications | Coder Coacher - Coaching Coders</title><meta content="Privacy-Enhancing Technologies for Mobile Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Privacy-Enhancing Technologies for Mobile Applications</b></h2><h5 class="post__date">2009-05-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7d6-vyOTJsg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody so today's talk is
privacy enhancing technologies for
mobile application and the speaker is
dr. Hurst hengartner he's a professor at
the University of Waterloo that we David
charns Clough computing science worse
thank you good afternoon thank you for
for having me I member of the crisp lab
at the University of Waterloo this is
the cryptography security and privacy
lab and I'm going to talk about privacy
enhancing technologies for mobile
applications like this slide I'm it's
not it shouldn't be new to anyone here
on today cell phones most of them now
have some sort of positioning
capabilities which allows them to figure
out the current location using GPS using
nearby cell phone towns whatever and
using these positioning technologies he
just become pick up it has become
possible to introduce several
location-based services and applications
and two examples are listed on this
slide and I'll take a more closer look
at them later in this talk salsa so you
can imagine having a social networking
applications you know to Facebook
MySpace whatever and that takes user's
location or users proximity into account
are you cannot imagine a service that we
turn them returns nearby points of
interest to people for example this is
what you can do and when you use Google
Maps now there's a problem with all
these location-based services and
applications in particular and the plan
is about location privacy so if you know
somebody's location you might live to DM
to derive sensitive information
sensitive personal information about
this person information about her
activities her interests how political
preferences her health right if somebody
is at the gym for example she's probably
doing sports if she's at a soccer
stadium she's interested in soccer if
she's at the headquarter of the little
liberal party she might be a member of
the Liberal Party if she's at the mental
hospital she might have she might be
sick but maybe she's also just visiting
somebody
right and so therefore we have to be
very very careful when it comes to
revealing our location to other entities
while using a location-based service of
location-based application in particular
what we need our privacy enhancing
technologies so technologies that allow
us to use this location based services
are applications without having to give
up our location privacy for example
without having to reveal our precise
location to a service or to a friend and
I look at two specific kinds of privacy
enhancing technologies in this talk so
let's start with the first example this
is the web page of a company called
loopt you might have seen it yourself I
don't think it's available in canada and
but it's available in the US and so it
supported by many of the big US cell
phone companies and some of them are
listed on this slide and so some of the
features are also given in particular so
you can do things like if you go to a
restaurant you can write a review and
then post you two loops and when
somebody else is closed later on and
it's thinking about going to the
restaurant he can he or she can look at
the review and there are other
activities that are very similar to the
activity activities in existing and
social networks you can share your
photos your location and and comments
and the feature that I'm most interested
in is the first one and I highlighted it
on the right side of the slide in
particular what this feature allows you
to do is it allows you to connect with
friends and it alerts you whenever a
friend of you happens to be nearby now
you think about this feature in more
detail in order to be able to implement
this feature loop has to know
continuously all the time your location
and also your friends location and
obviously for our privacy point of view
this is troublesome so the question
arises can we do better can you build a
distributor
version of you a flute of Luke's a
version of loop that does not require
these trusted third party at all these
knows where we are where I am where my
friends are and so I'm going to what I'm
going to do for and the next two minutes
I'm going to outline some possible
solutions and outline how they are
insufficient ill be done till we will
converge on a on a final solution so the
first solution is very straightforward
right today's cell phones while their
smartphones like they can do all kinds
of stuff and so let's just them to the
following so Edison bulb their friends
so alice is smart phone smart phone
every five minute or so it determines
its location and since its location to a
bobb smartphone and Bob and looks at the
received location and checks or the two
local two locations are closed and if so
it is going to raise an alert well now
you no longer have a third party that
can track everybody but in this solution
it's still possible for Alice and Bob to
track each other so that's not what you
burned either right ellison park they
should learn of each other's location
only if they are nearby so let's try
again so what we what Ellis could do is
and this could could encrypt our
location before sending it to Bob now
obviously for this to be useful but Bob
should not be in the possession of the
decryption key because otherwise you can
still learn the location right now the
problem now is in a traditional
encryption scheme this doesn't really
help us much because like a ciphertext
you can there's not much you can do with
the ciphertext all you can do is you can
decrypt it but Bob doesn't have the
decryption key so Bob gets a ciphertext
but there's nothing you can do with it
now there's an interesting observation
observation in that they are a modern
encryption schemes developed in the last
five ten years or so that allows to do
operations directly on a ciphertext and
this is what we are going to exploit in
our application so one of these schemes
and it's called homomorphic encryption
so what is this it's a public key
encryption scheme I assume most of you
have heard of public key encryption so
there's a key paired as a public key
a private key anyone can use the public
key to encrypt some information but you
need a private key in order to decrypt
this information and so in the rest of
the talk i'm going to use notation that
EA of m is the encryption of a message m
with a public key a and so the
interesting feature of homomorphic
encryption is the following if we have
the ciphertext of two messages and this
is all we have right so we have only the
ciphertext of two messages then we can
compute a ciphertext for the sum of
these messages right so in on the slide
we have EA of m1 and EA of em too that's
all behaves we take these two to cipher
text we do some fancy processing on them
and what we end up with is an encryption
of the sum of m1 and m2 right and we
don't know we don't need to know m1 and
m2 it doesn't matter how exactly this
works and behind the scenes I'm if
you're interested I can give you the
details after the talk by the way please
feel free to interrupt me if you have
any questions and what would be really
cool if we could also you a product if
you also if you could also compute the
product of two messages in this way
unfortunately they are not there yet
despite this lack the lack of this
future we can still do quite an amazing
number of things using homomorphic
encryption in particular what you can do
is the following at least uses
homomorphic encryption to encrypt
allocation and sends it to Bob Upton
encrypts his location using again
homomorphic encryption and uses the
received location from Alice which is a
cipher text and the ciphertext way its
own giant location that he just
generated and combines them using this
whole morphic encryption property and
computes the distance without actually
learning the distance this is the cool
thing so Bob doesn't learn any
information but he's still able to
compute the distance between Alice and
Bob and so he simply after having
computed least encrypt the distance he
returns it to Alice which code and which
is going to
decrypt it and then she learns the
distance so here Bob doesn't learn any
information but you still have a problem
Alice she can always learn the distance
to Bob and that's not between what we
want you should learn the distance only
if Bob happens to be nearby so if the
distance is small now as he turns out
there are a few additional tricks it was
the help of which we can i implement
this feature so Alice we be able to
decrypt only if the distance is smaller
and on the next few slides I'm going to
outline and two possible tricks to do
this before I do that let's take a
closer look at the actual protocol how
it works behind the scenes so Allison
but what they do is they jointly compute
the distance so this is the second line
on this slide and so Mike this is just a
standard distance computation well
actually let me compute is the square of
the distance it doesn't really matter
and whether we need the square a
distance and both of them are sufficient
for our purposes in particular I'm
computing the square is cheaper so we
have that the compute the distance first
and then you sub me subtract the square
of a value r and r is the distance that
Ellison Bob consider nearby right so
basically if d is smaller than CC closed
model than 0 and this involved m are
considered nearby and so what our
protocol does is it computes this value
of T without em Ellison Bob be able to
see to learn the actual value and so
what we're doing is right at the third
line on a slide shows that the formula
for the distance commutation just in a
slightly different form so Alice and Bob
they now compute compute each of the
terms in these formulas rights of
example Ellis computes the encryption of
X a square and all the other values that
depend on her location and then she
sends all the ciphertext to Bob Bob and
compute for example the encryption of
his of X B Square and he also am come
putes all he computes on for example 2xa
to get the encryption of 2x axv again
analyst sorry Bob is not able to learn
Alice location and finally Bob ends up
with the encryption of the distance but
now AM Bob can't simply send this value
to Alice right analytics us Ellis and
could simply decrypt the ciphertext and
chew but however but you should be able
to learn the value of the only if the to
happen to be a nearby so I can be doing
instead instead of having Bob compute
the encryption of tea we have him
compute the encryption of D plus a
random value V that is chosen by Bob and
so Alice I sorry Bob returns the
ciphertext of t plus v to Bob to palette
sorry Ellis can decrypt this value but
it's going to be computed completely
useless to her right because it's D plus
V we randomized this value it's no
longer the actual distance so Alice
cannot learn any information from from
the decrypted information and useful
information from the decrypted message
instead what is going to do is she takes
this decrypted value and gives it to a
third party trend this could be a joint
friend of Alice and Bob and similarly
Bob gives v so the random belly that he
chose to trend and so now Trent takes
these two values and can compute D and
then informs Ali's whether the two of
them are nearby right so Bob learns
leather Alison bar nearby and this is
the only information sorry Trent learns
where the Ellison Bob are nearby and
this is the only information that trans
learn Trent learns and he notifies elson
bar that they are nearby any question
about the protocol so far so this works
the problem is we have this what we call
this semi trusted third party trend we
will I have we have to rely on trend to
behave properly right now to cheat not
to be malicious not to tell Alice that
Bob is near is not nearby info Bob is
found to be nearby
also in this protocol while el tren
cannot learn Allison Bob's location he
can still learn better than their nearby
invited some maybe these could reveal
sensitive information like if maybe all
of the Sun if Alice in the bar what
happened to be a nearby a lot maybe they
are more than just friends right so this
is this can be sensitive and also
ellison park they have to trust trend
not to collude with the other party
because if trying to load it with the
other party for example with bob bob and
trying they could always figure out the
distance to Alice so ideally or we
wouldn't need trend and so that's I'm
going but what I'm going to do next is
I'm going to outline a solution where we
don't need trend so Alice and Bob are
the only two parties that are the only
two participants of the protocol again
we use homomorphic encryption but this
time you use a what I call homomorphic
encryption with a twist in particular
there is a homomorphic encryption scheme
where the owner of the decryption key
cannot actually decrypt the ciphertext
alright the first sight this might sound
weird right why do we have a sink
ription scheme where you can't actually
decrypt I'm a ciphertext well if we
couldn't do anything with the ciphertext
then indeed that the encryption scheme
will probably be completely useless
however what we can do in this scheme is
the owner can check whether the
ciphertext is an encryption of a
particular plain text for example if the
owner thinks the encrypted value is the
value zero they only can take that value
zero and check whether the ciphertext is
an encryption of the value zero what
this means is if there are lots and lots
of possible plain texts that can become
encrypted and the the entity that
generated the ciphertext randomly chose
one of these values and encrypted it it
is very very unlikely for the owner of
the decrypt decryption key to figure out
the data that was incorrectly or the
only thing the owner of the decription
can do is take each
hospital plain text and check whether
these plain text was encrypted in a
ciphertext but if there are lots and
lots of possible plain text it takes
take too long to do this so therefore
this scheme works only the owner can
learn the plaintext only if he has a
good idea of what the encrypted value
could be excuse me so this is the first
part of the piece that we need the
second pieces and we need location great
so we changed scenario slightly instead
of importing actual location like
allocation in on a granularity of meters
into our algorithm we compute or we use
a great right so we our look our
position is now the cell in a grid so
you can think of the greatest being now
consisting of cells that have a width of
about 100 meters right so basically the
way the scheme works is we take the the
accurate location like in meters and
divided by r which is about 100 meters
and get a great cell and then we compute
the great cell distance right so Alice
and Bob each other cell and we come that
we compute the distance between Alice's
and Bob cells cells and so if Ali's
happened to be in the same cell as shown
on this slide then the distance is going
to be 0 if they happen to be into a
joint cells and the distance is going to
be run and if they happen to be into
direct diagonally adjoint cells the
distance is going to be two on the other
hand if Bob is farther away this
distance is going to be larger than two
as in the example on the slide and where
the distance is 5 right and so now we
consider Ellison Bob to be nearby if d
is either is i0 one or two and so now
let's take the two pieces and combine
them so Bob what he's going to do is he
takes he computes the grid cell distance
as shown on this slide and then he
mouthed remember Bob cannot learn the
actual distance because we use
homomorphic encryption and so in
addition about papa
he multiplies this value with a random
value V and so he returns this valley to
cipher text to Alice and now if Ellis
again but she cannot directly decrypt
the ciphertext the scheme the encryption
scheme doesn't allow us to do this
however she can try some possible values
in particular she can try the value zero
right because if d is zero the product
of d and v is also going to be zero so
if the cyber attack stick is the
encryption of the value zero Ellis will
be able to figure out right so if Alice
and Bob happened to be in the same cell
Alice will be able to learn this on the
other hand if they are not in the same
cell D is going to be at least one and
in addition we have a random value of V
which can be randomly large meaning this
product is going to be a random value
and it is very very unlikely that Ellis
will be able to figure out which value
was encrypted any questions so far
that's not if the value of T is zero
Ellis will be able to figure it out
we need t write this the actual distance
he in great sir she's doing this chicken
but you can be done right for example if
we don't multiply it if the random belle
and she's here in this cell right she
should not be able to learn if what is
in this out if the distance is fine
because we no longer consider this to be
a nearby and so if we didn't perform
this multiplication Ellis could just try
all possible value starting with 1 2 3 4
5 6 7 and ultimately she might be able
to figure out the distance but with the
help of this multiplication this becomes
very difficult because again these
randomly large and only if T is 0 only
then will the product be 0 you have no
right again but this works only when
I've talked about this works only for
the middle cell that a equals 0 if d is
if t equals 1 we take a random value and
so the product is going to be as i just
said it's going to be a random value to
and it's very unlikely that addy will be
able to sol to be able to figure it out
and so how do we deal with the case
where these either one or two well what
we do is we have Bob compute D minus 1
all right so if d is 1 t minus 1 is
going to be 0 and we end up with the
same setup as justice cost and similar
with me for the case study and could be
too so it just come up just computes the
minus two so if T is to the managed to
become 0 and the product is going to be
0 and so what this means is bob has to
compute three ciphertexts 14 d another
14 d minus one and another one for d
minus two and sends all three ciphertext
to Alice and Alice tries to encrypt
sorry decrypt the three of them and if
she manages to encrypt that one to
decrypt one of them she knows better pop
is nearby on the other and if she fails
all the time she won't tell any
information any questions
now we actually implemented this scheme
and we use them openssl and a publicly
available at number theory library and
we use 2048-bit cryptographic key and
used a pentium 4 to evaluate this scheme
and the numbers are shown on this slide
in particular be sure how we show how
long it takes to Alice and Bob to set up
an SSL or TLS connection and we also
show how long it takes for Alice and Bob
to do this computation and so it's a
it's a little bit doing the encryption
and decryption operations a little bit
more expensive than setting up a TLS
connection but but it's not too bad so
basically what this means is if we have
a device that is able to set up a TLS as
a cell connection like for example many
mobile phones are able to do these days
then these devices they should also be
able to perform this protocol to
demonstrate that this is really the case
and we built to sample implementations
of our protocol one of them for the
blackberry smartphone which is so shown
on this slide and we don't have an
implementation for the Android platform
but the software is publicly available
so if one of you is interested in using
it on the Android please and download
the software and it's in Java so it
should be very straightforward to modify
it if you do so please let me know
because I'm interested in learning about
them and experience with our
implementation on other platforms and we
do have a second implementation this is
for the pigeon instant messaging client
which some of you might have used
yourself and so right so you're
basically your instant messaging with a
friend and behind the scheme scenes and
this scheme also exchanges location
information with your friend and you if
your friend happens to be nearby you get
alerted so what you see this life is
that whenever
theories for your location you get
alerted like you think this is a useful
feature for privacy reasons is somebody
wants to figure out that the young
nearby we better tell you in case
there's a problem and then on the next
slide and we learned that a friend is
actually nearby and that based on this
information for example I'm ice cream
together and so again if you're going to
play with this implementation and go to
that address and down yeah that you can
download it any questions about this
kind of application so what malicious
people could do is they could enter a
wrong location into the protocol and you
might have my you might not have noticed
but so far I've been always talking
about friends so I wouldn't run this
alga sproat a call for random people but
on the other if you have friends and
then they cheat this might have an
effect on their relationship thank you
for example your application tells you
that pop your friend is nearby but then
you fail to spot him and so you can
conclude that you probably cheated so
yeah this could negatively affected
friendship alright so but I don't
recommend running this application with
random people because as again they
could spoof location the location I
think Rosanna
I was it on how's the application on
battery life and we haven't evaluated
battery life and so so the question was
how is the application of a telegraph
you haven't actually ovulated battery
life swim i'm only interested in the in
the cryptographic performance and but
this is definitely a topic of future
work and i'll come back to this am a
towards the end of my talk some
potential issues with this application
yeah good point though the distance
between the two friends have to be
defined symmetric like if alice wants to
know if Bob is within 500 meters but bob
was the final T fallacies within a
kilometer can they define that or the
protocol needs to consider about the
same distance so the defective same
distance is nearby it doesn't have to be
be the same distance so the day the way
we deal with me now protocol is ellie's
chooses the distance the distance she
considers nearby and informs pop of this
distance and if Bob is doesn't feel
comfortable with the distance he just
refuses to participate in a protocol all
right any other questions ok again if
you want to play with this view please
feel free and downloaded so another an
application that I've been looking at in
my research is our location based
services that return and information
that is relevant to your current
location so a a key example here is
google maps so what i did here is I
looked for coffee places that are close
to the University of Waterloo and so the
problem with this kind of application is
but in order for the application to work
we have to tell Google Maps reflect on
Google where we are and so we end up
with the issues that are just outlined
like somebody learning our location and
some people react to this by saying well
you don't have to reveal you locate your
identity to the service you just
use the service pseudonym ously like a
or even unanimously right so that the
search is not going to learn your
identity and there's a problem with this
statement in that some locations they
are bound to particular person's even if
you don't reveal your identity and to
the service from your location the
service might still be able to figure
out who you are right for example your
home all right your home is technically
bound to your to you as you are done and
your identity right so from learning and
the location service could infer your
identity even if you issue a query from
a place that is not bound to your
identity like I don't know a train
station or a public square right many
people access a service in a continuous
way and so the search is going to be to
see many queries over time maybe all of
them and originating from the same IP
address and then once the query ends up
at a place that is linked to the an
identity of the query issuer the Clery
issuer can be relied on to find and so
therefore use just am using a service
anonymously or using a pseudonym might
not be sufficient so what can we do
instead we could cloak our location it's
in particularly instead of revealing our
fine grain location to a service we
reveal a marked all strange version of
this location to the service for example
instead of revealing room 3526 davis
until university of what law which is my
office I just tell Google I'm at you
somewhere at the University of Waterloo
now there's another problem here to me
in particular just simply enlarging the
area might not be sufficient the problem
is if I enlarge the area and I happen to
be the only person in the enlarged area
this is likely the case fairly if you
had a more rural area then and if the
service or if the area of the enlarged
area is on the physical surveillance
service provider the service provider
could still and re identify you so
instead what we what has been proposed
this location block cloaking based on k
anonymity you might have heard about k
unlimited this is a concept that was
developed for databases in particular
you have some sensitive records in a
database and you want to reveal these
records in an anonymized form and so the
idea behind k anonymity is you release a
record only if you can no longer be
distinguished from k minus 1 records
that also get released and so for
location cloaking is slightly modify the
rule at the rule follows now we cloak
the location so we make it bigger until
it covers my location and also like
locations of at least K minus 1 other
people like and so there are K people
and which gives us an enormous is an
unknown amity set of K people they all
have the same location very good
observation so simply K an amazing
location information is not sufficient
we also have to canonize other
information for example all kind of
information you're asking for you have
2k analyzed as you attend all the
signals that are going to the service
and so that's perfectly true and so I
look at this as a first step right so
the first thing we care and mize is the
location that's when other researchers
looked into how to anonymize and queries
good point so this is this K unanimity
approach I'm not the first one to
suggest this for location privacy there
has been lots of research that has
looked into this approach and but there
are some some flaws with this existing
research and much of these reeds
research relies on centralized cloaking
right so each device in forms a but I
call location broker of its location and
then the location broker design
it's but there's a sufficient number of
people within a cloak location and if
this is a case and we reveal the cloak
location to location based service the
problem with these solutions is
everybody has to trust this location
broke that the location broken nose all
the time that everybody is and as we saw
and a few minutes ago for the first
application at a talk blood that's not
what we want summer reasoned approach
has suggested and to get rid of the
distance idea that the trust the
location broker by introducing and
distributed cloaking so now we have
devices that talk to each other and they
try to figure out the days of patient
number of nearby devices the problem
with these approaches are that and they
am they assume that all the other uses
that they are not malicious and again
this might work if all the other uses
are your friends but of course it
doesn't skill like if you want to do
this protocol with random people and so
what I'm presenting on the next slide is
a strong inappro a straumann approach
instead of having one location broke we
have multiple location progress and if
you think about it this is what we have
in real life right so there it's not a
single entity dick knows there's not a
single cell phone provider that knows
where everybody's at all the time
instead we have multiple a limited
number of cell phone providers right
days rogers who knows who some people
are all the time there is Bell who knows
where some other people know em and all
the time and so right so we don't have a
single party only we have this multiple
parties that each of them knowing the
location of a different set of people
and so what you can do is and if I want
to know whether there's a patient number
of people at a club location I just
query each broker they send me the
number of people currently at this
location I sum up the numbers and if
there is sufficient number I contact I
sandella's I send a cloak location
the location broker sorry to the
location-based service this works but
they're from a few so that the big
advantage of this solution is case in
the correctly zooming it integrates
really well with existing infrastructure
again think of as a location broker as
being a cell phone provider but there
are some drawbacks and it might be
possible to track users based on data
mining rights the easiest cases you
learn that there is one user in a
particular cell and there is nobody in
the surrounding cells and so now you
might be able to track a person if this
person leaves the cell so this is a
potential problem also just from a
design point of view and this is not
necessarily a good idea if there is a
solution that allows us to solve a
problem in a more privacy friendly way
then we should choose this approach this
is what we call privacy by design right
so try to build in privacy and in the
actual in the design solution early on
and another problem with the solution is
right this location brokers their cell
phone providers and so now we expect
them to reveal the number of customers
within or close to a particular cell
phone tower for example and and do this
to random people but right this could be
sensitive information that the location
broker is unwilling to share so and what
I'm going to do next is I'm going to
provide a discuss a solution that is
that is based on these approaches of
having a multiple location brokers and
so the user and the location brokers
they collaborate that will also be a
third proud SME trusted third party and
these parties then together determine
whether the cloaked area has at least K
people and that nice feature of our
solution is nobody not even the user not
not the location brokers not the sumitra
CTO party none of these parties can
learn the total number of people that
are in a cloaked area
before an outline our solution i just
want to point out the model which makes
it easier to understand the actual
solution so we have lots of users
denoted by cell phones the other
directory server which allows the user
to query and the available location
broker and each user is in a particular
cell and then she registers the cell as
her location with her location broker ie
cell phone provider and then we also
have some sick what we call secure
comparison service is a required power
protocol in an ideal solution we
wouldn't need these and additional
parties and we do have a solution that
gets rid of these parties but
unfortunately em it turns out to be not
very not very efficient so the next
slide outlines and the protocol I've
changed the set up slightly from the
previous slide so now we have the user
in the middle of the slide and we have
to location brokers on the right side
and we have a secure comparison server
on the left side so the way the protocol
works is the user and asks each location
blog about the number of people in her
cloaked area this location brokers
return his information in encrypted form
to the use the user is not going to
learn these numbers all the user can do
is again using homomorphic encryption
she can sum up these numbers and send
them to the secure comparison server
well actually she's not going to add
santa some in stats is going to send the
sum plus the random value are in
addition she also sends her privacy
preference k and and an edit which has
the random value added random value our
Arab twig she also sends this value to
the secure comparison server the server
decrypts the first valued a cipher text
and then it simply compares the two
values and remember and this is and
informs the the use of Theresa batteries
of this comparison basically says is
there a sufficient number two's me in
the closed area any question about the
basic protocol it's important that
everybody understands this because the
rest of the slide 3 may depend on its
protocol so I'm going to do next is I'm
going to outline a few challenges and
the first challenge is if the secure
comparison server to the server on the
left side and the location broker if
they colluded they could learn a users
privacy preference k I'm not going
through the details but and it's
possible to do this and once they know
this privacy preference k the reverse
process would allow the two of them to
learn the total number of users in the
cloaked area for future queries and so
that's what we want to avoid that nobody
should be able to learn the total number
of users in a query and so to fix this
problem if I go back to the previous
slide what we want to do is it should
not be possible for the server to learn
the value R plus R plus K but it should
not be necessary for the user to reveal
our plus k2 deserve instead the server
should learn only the first value so
that r plus the sum of the individual
numbers and so basically the way we want
to perform the comparison such that and
the user knows one knows one of the
values that are input the comparison and
the secure comparison server knows one
of the values that are input to the
comparison but there is no party that
knows both values that are input to the
comparison so this is one of the
features that we need another problem is
binary search right so in the protocol
if you go back to it the user sends this
valley to the secure comparison server
and asks it is it at least k at the
right to use a malicious user could
just modify the value of K and using
binary search she could ultimately
figure out how many uses there are in
the cloak area and so in order to avoid
this you have to make it impossible to
read and to you have making possible for
user to resend the same some multiple
times to the comparison server the third
third challenge is a user could register
his or her location with multiple
location brokers right and so then each
location broker counts this user as one
person but in fact it's always the same
person right and so it should not be
possible for the same per person to
register with multiple brokers and
another feature is a collusion between a
user and a secure comparison server and
we also have to avoid this kind of
collusion because otherwise and they
could still learn the total number of
users in a Cell so I'm not going to
outline all the solutions to all the
challenges in detail I just give a
high-level overview of how we solve them
and
we use I'm cryptographic solutions for
our challenges and but I also want to
emphasize is that for some challenges
you could potentially also and solve
them using a non cryptographic solutions
for example if you look at the problem
where we have duplicate registration
rights about this means is a personal in
order to register multiple times with
multiple location brokers a person
basically needs multiple cell phones
right ensure she has to man you buy
multiple and cell phone planes and so
the amount that can be economic reasons
that make this kind of attack harder so
let's outline the solutions for the
various challenges so the first
challenge remember this is the challenge
where we want to perform the comparison
and executed by the secure comparison
server and the user such that neither of
the two parties learns both input values
but each party should learn only one of
the input values and so we use an
existing protocol the GTE Scott protocol
or greater greater than strong condition
of lip oblivious transfer protocol and
I'm not going to give you the details of
the protocol I'm just giving you a
high-level survey of how the protocol
works so we have the user's input which
is R plus K remember our is a random
value case our privacy preference so she
takes this value in particular the user
takes each bit of this value and it
encrypts each page separately and sends
it to the secure comparison server the
server takes its input value to the
comparison r plus the sum of the number
of users and encrypts each fits in the
same way as the user and then the server
obliviously compares the two vectors
right so the server does the comparison
without learning which of the two
vectors and corresponds to the larger
value and again I'm going to skip the
details but at a high level and the
procedure is illustrated on this slide
so we have these two vectors
and the server starts comparing each bit
starting with the most significant one
again the server doesn't see the actual
values as soon as the server sees a
value that is different server stops now
again this terror is not able to see
where actually and the server stops and
depending on which value is one in which
value 0 and the server assigns either
the value 1 or minus 1 to this value and
all the other values are set to random
values and then the server shuffles this
resulting vector this prevents the user
from learning the position of the bit
and where there was the first the first
difference was it was detected and
finally this vector is results back to
assign to the user which decrypt says
and then the Jews is able to retrieve i
under- one-on-one and based on this
value to serve so the user can figure
out and which of the two values which of
two vectors is larger meaning the user
will be able to learn whether the k
unanimity property is satisfied any
question about this again it's not
you're not required to understand
opposite the details of the protocol how
do we solve the second challenge I'm not
going to talk about the details
basically what we do is to use tickets
right see this the user needs to be in a
possession of a ticket which is
basically a digital certificate and only
if the if there is this ticket will
broker as I reveal the secure comparison
be able to execute the comparison and in
addition the server X so it says the
server caches receive tickets and if the
server receives multiple tickets and the
server will reuse a ticket that year
that it has already seen duplicate
registrations again I've mentioned that
can be ways such as buying multiple cell
phones which is costly which might
defend again
this attack I cryptographic and defense
again against this attack is based on e
cash which you might have heard about EK
she especially is basically an
electronic one electronic version of
cash so you have a bank the customer is
dropped ross money from a bank spends
the money with a with a merchant and now
an important problem with each cash is
double spending obviously it shouldn't
be possible for a customer to double
spend a coin so when the merchant
deposits the coin with the bank the bank
will be able to disband double spending
and so in our solution we use this e
cash for to avoid multiple replications
so the user initially gets one coin from
the bank and then the user registers
with a location broker and she spends
this kind and the coin decide the broker
deposits the coin with the bank and now
if the user registers multiple times
with maybe different brokers this
amounts double spending which can be
detected by the bank and so when the
user Debbie justice she be the broker
withdraws the account from the bank
spent it with the user the user deposits
it with the bank and then the user can
get a fresh coin and use the fresh coin
to register with the next location
broker and I'm not going to talk about
the solution for the next challenge
because I'm running out of time and
again we have an evaluation of our
protocol this time we the setup is
slightly different we run the server on
a fast machine and we run the user on an
old an old laptop in order to simulate
the capabilities of a modern smartphone
and so there are two and protocols that
we evaluated to the first protocol is
the communication between the server
that's are between a user and the
location broker and so here remember
this is whether you'll use a curious the
broker for the number of key ball a
registered with the broker
so we have connections it up and which
is 33 milliseconds and we have the
encryption operation and as it turns out
the encryption operation is actually
cheaper than doing the connection setup
the second operation is the comparison
operation between the user and our
secure comparison server and remember
this is a bitwise operation so each bit
is that is compared individually and so
that's why we have on the x-axis the bit
length and on the y axis we have the
actual delay and so we give the delay
for the extra for various components of
the protocol like the server and the
user and the curve you're most
interested in is the blue one this is
the curve for the user and as you can
see on this slide the delay varies
between 200 milliseconds for a bit
length of far and delay of about 600
milliseconds for a bit length of 16 and
in practice we think that big lengths of
eight and 12 between eight and 12 bits
are sufficient and so the delay is going
to be on the order of 300 till to 500
milliseconds which of course is
noticeable but we think that this is
also tolerable tolerable in practice
okay and let me conclude my talk I hope
I've made it clear that together with
the upcoming of all these mobile
applications that take users and
location into account another important
issue that is arise in this location
privacy so we have to you have to
clearly control who should be able to
get access to a person's location and so
they are multiple ways to deal with this
problem there's been lots and lots of
research on this topic I'm not claiming
that this is a complete survey and i
just presented to particular audience
that i'm turned out to be useful in
practice the first one was based on
cryptography techniques like well
actually both of them were based on
cryptographic techniques like
homomorphic encryption and another
popular technique is based on k
anonymity and as our implementation and
evaluation has shown it is actually
possible to deploy these algorithms on
real mobile devices right it's not just
a dream that we that we are having some
of you to work the first item is already
been pointed out in a question but it as
I as I showed on the with the with a
slider the blackberry and it is possible
to run the protocol on a blackberry
because the performance is similar to
setting up a TLS connection problems
arise when you have for example lots of
friends right some people if you look at
their Facebook accounts they have
thousands or maybe even hundreds of
friends and so right if your cell phone
has to run this protocol every I know
five ten minutes with each friend this
is going to take up and lots of
resources or resources meaning both the
computational resources but also battery
resources input or communication
resources which can be a problem like in
places like Canada where communication
can be expensive and so for people that
have lots of friends and our protocol
might be too expensive and so instead
what you would like to have is a
protocol where we can offload
computation to a third party server in
particular
third party server should do the
computation and but it shouldn't learn
much information that I'm not saying it
shouldn't learn any information because
this presents an interesting problem
terms mean scientists rights of example
if you think about Google running this
third-party service so Google is doing
computations on behalf of lots of people
but it's not learning any useful
information by doing these computations
obviously Google wouldn't have much of
an incentive to do this right so the
question arises what kind of information
can be revealed to google to this third
party while doing this computation such
that the third party still gains a
profit from this computation I don't
know what the solution is maybe be
revealed a person's clothes drying
location to the third party such to the
third party good for example so
application based ads to the to the user
another item of future work is for the
second poll to protocol that we talked
but I talked about what we would like is
but you really would like to have is a
solution that doesn't require this
additional third parties to secure
comparison sir and we have a solution as
I mentioned but it doesn't turn out to
be efficient so this is still open and
finally which is the next time you told
me the biggest items right are just them
talking about two applications and in
this talk about there of course lots and
lots of other applications that are out
there I don't know location based games
or location based matchmaking right so
you tell your cell phone and about your
current interest and you somebody else
happens to be nearby and the cell phone
with the same interest happens to be
anybody your cell phone alerts you but
of course there are obvious privacy
problem with these kinds of application
so the question arises how can you build
all these applications with my privacy
in mind before I conclude my talk
briefly give me some let me give you
some credits most of the work in his
talk was done by G song he was my master
student and to some of the work my
colleague Ian Goldberg
he also contributed a party and finally
I also would like to acknowledge and
search okay thank you for your attention
are there any questions all right if
there are no questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>