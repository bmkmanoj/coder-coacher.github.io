<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2009 - Opening Talk | Coder Coacher - Coaching Coders</title><meta content="GTAC 2009 - Opening Talk - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2009 - Opening Talk</b></h2><h5 class="post__date">2009-11-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8W5Jd_wzB90" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's a pleasure for me to introduce the
next speaker and I want you going to
take you on a journey back and think
back 40 ish years and think about just a
couple of highlights probably all of you
remember I as we go through languages as
you go through very early machines as we
go through concepts that have made their
imprint in our in our industry you're
talking about a fellow of the ACM a
recipient of the ACM turing award not
sure whether you recognize this person
but maybe you recognize that person so
it's a pleasure for me to welcome dr.
weirds to share with us some insights or
a overview of the history of the last
time how we got here I'm sure it will be
a very interesting opening our please
thank you very much you know spite of
all this very nice introduction you
might be surprised to see me here a
speaker and myself actually surprised
and I wonder why I'm here I got some
time ago asked whether I would like to
come down the Helena means from the
other side of the town to give a talk
and I said well why not and now I'm
surprised to see myself as a speaker not
in a little group but on a on a
conference anyway bear with me of course
I must confess that i'm not an expert at
program testing and so i hope you don't
expect big news and technical
breakthroughs about program testing from
me so what I'd rather do is give you
perhaps some perspective on history of
programming and program testing which
are intimately intertwined and perhaps
see a bit through
the development over the last five
decades in this object yes I first got
in touch with the field of programming
in 1959 as a matter of fact I had
emigrated to Canada and by chance ended
up in just founded graduate Department
we were five students one from France
and one from Brazil one from Pakistan
one from China and one from Switzerland
and I got a master's degree there and
attended a course in numerical analysis
and that was kind of attractive because
they had a computer and one who do the
exercises with the aid of this computer
and I'll whack it turned out however a
big thing big huge thing it turned out
that whenever we had finished an
exercise program than exercise rode the
program the computer was in service in
maintenance it was doubtless people say
now so you ended up this whole course
without a single single or not once even
touching the machine and so there were
no failing grades yeah was kind of a
letdown in spite of it all but nevermind
then I moved on to Berkeley where I
entered a ph.d program that was in 1960
and which one I eloped with her there
were any openings citizenships in the
computer related area and after a while
one turned out and I got in touch with a
Bendix g15 machine it was also like a
like a drum machine that means the main
program whether the data were on the
drum
arranging track so i think on under 28
words at 27 bits or something like that
and and there i really got into
programming programming of course in
hexadecimal machine code and online you
had to reserve an hour or whatever on
that machine for yourself could do that
maybe 1000 three times a week and there
you'll struggle to get simple very
simple programs running so testing was
already more predominant and programming
the main debugging tool was a bell that
means when your program finished or
somehow trapped or whatever you had to
insert use a command ring bell very
important come up so that was debugging
in 1960 well the computation Center had
a bigger machine an IBM 704 six thirty
two thousand words of store and and that
machine was programmed remotely that
means you never touch the machine you
never even saw it you punched your
program on punch cards and inserted them
desk place where a tray and either 8 or
24 hours later you could go and see
whether the output was ready so how was
the talking down there I forgot but
somehow you had to inspect if the result
didn't come out right you have to
produce or two dumps
means images of the core of the memory
which was called core because it
consisted of magnetic cores and and then
you have to we threw these myriads of
opal numbers of course the computer
wasn't that big it was as I said most
thirty-two thousand words store and your
program occupy the only small part of it
we weren't in the age of gigabytes
already so how would up to doms look
nowadays you can imagine well there were
two things of course one is that
programming and debugging took a lot of
time the turnaround time was the key
issue if you made a mistake small
mistake you essentially spend another
day waiting or programming and so in a
way a very important innovation in that
time was programming language at that
time it was Fortran and then it was just
the advent of Algol 60 Fortran is a very
at least at that time was a simple
language and what could even imagine how
statements were translated into machine
instructions
so first milestone of the month I'm
going to discuss of the introduction of
high-level programming language of
course this brought me into the field of
compiler design for various reasons but
I discovered that there was a group in
one corner of the computer science or
computer center building who programmed
on something that's now called a
compiler and the challenging thing is
that the whole pilot program was
formulated in the language that was
translated itself kind of a recursively
to age and I joined that group and
managed to convince my professor that
this was something worthwhile studying
and after a while I got into the doing
some understanding of what was going on
it was it was simply a true mess there
was only one person who had what mung
night calls an understanding of the
whole thing and if anything he wanted to
do you had the gold comes out with her
bother her it was a program maybe 100
pages long which was awfully long at
that time and full of Algol statements
intertwined mixed up with machine code
instructions MC agent and an octal
number so the advantage of using a
high-level language was rather marginal
and then of course comes the question of
how do you debug well again the famous
or infamous octal dump comes the
question again
apart from certainly manipulating your
program inserting an additional print
statement Zealand there and so on which
even nowadays is actually not a bad way
but the key is you have to know how this
compiler worked how it translated into
machine code because it was just the
compiler was a step between you and the
program running but there was no
feedback in order to know what was going
on you had to talk in the understand the
machine code and and the Machine
operations and tediously find how far
the program had progressed and where it
got stuck where an error occurred no
wonder that debugging and testing which
is intimately connected testing is
debugging until it runs it's also very
tedious process and you had to learn to
think in the machine not in terms of the
machine not only in terms of the
programming language I will come back to
this to this topic he well as I said I
got into this field of compiler design I
was sure that one of the primary duties
in computer science the one thing that
might bring us a step ahead would be to
bring some order into the chaotic mess
perhaps try to find a good principle
according to which a compiler could be
written so that you could systematically
build it up from scratch of course this
at all the two with syntax analysis
field very much active in the 1960s
syntax analysis may
possible to specify or syntax was made
it possible to specify rigorously what
the language was what were acceptable
sentences and which ones were not now to
describe the meaning of a admissible
sentence is still another thing that's a
definition of semantics and we didn't
get very far in that subject anyway
subsequent compilers which I wrote for
first for alcohol and Corral go w the
derivative of alcohol 16 were a lot lot
lot more systematically built than the
one for Disney react and they could be
explained people could be reduced rather
quickly but so what I mean debugging
still was a topic at hand and
nevertheless the systematic high-level
language allowed to make one progress
and I consider it quite a milestone
nowadays namely symbolic debugging that
means you did it replaced the necessity
of understanding the translation and the
outcome of it in terms of the machine
architecture by letting you think in
terms of the high-level language only at
least ideal weight should be that way
that means you could get in the case of
failure of your program you could obtain
the state of the computation not in
terms of things pertinent to the machine
to hexadecimal gum and location pc
location where he failed instead you
could get the state of the point of
failure in terms of your program
you cook at the list of the variables
active at this moment and their values
in this as decimal numbers or character
strings or boolean values and this was
as I would say quite a breakthrough
because it relieved the programmer from
knowing anything behind the scene of the
language the high-level language
nevertheless let's go back to the topic
of testing let's assume that you got
through your debugging aids the
impression that your program was correct
how did you make sure that it was indeed
correct instead of having only belief of
how do you convince other people that it
is correct and as is free of mistakes
well that is of course a key question
which was important then and I think is
important now this is certainly
something I ought not to tell you who
are in the feel of testing I mean it's
all a business of convincing other
people that your product is right well
of course there is the idea that you
test all possible cases at least that
was an idea and it's it's a failure it's
a misconception it was Dykstra who
pointed this out that even very very
simple computation cannot be tested
exhaustively and the
the example he gave was that of actually
multiplying doesn't matter adding two
32-bit numbers now in this case you have
you have to to the 64 possible cases not
the ought to test now let's assume that
you want to we are so naive to try to
test all the 22 to 64 cases of a decent
and that every test will occupy will
take one micro second perhaps nowadays i
should say one pinko second or whatever
nevermind let's assume one microsecond
then you have to to the 64 that's about
ten to the twenty one about and you have
tend to do 21 cases divided by the
number of sector of microseconds you
have per year and you decide divide this
by this number and you get something
like 10 to 10 years to do all the test
cases it may be not 10 to the 10 it may
be something 10 to the 8th or something
like that yes which is still more than
we could care to wait for and just point
is that it's obviously mistaken to try
exhaustive testing even for very simple
cases now the programs we use nowadays
are very very complex and obviously we
must find some method of obtaining the
necessary conviction of correctness by
some other means there are two ways to
do that and one would of course be to
reduce the number of tests
basis and the other would be to use
faster computers and I'm afraid the
world at large well certainly takes a
mixture of both but very heavily relies
on the increased power of computers it's
certainly not the academic way and I
think we are at the place where we can
say we are still in misery and even the
fastest computers for testing cannot
really do the job properly if the
programming wasn't done in the first
place right the ideal would of course be
to have not sold so many test cases but
zero test cases i would like to remind
you of what Dykstra said it back in
nineteen seventy about the testing is at
best capable of showing the existence of
errors but never to prove their absence
now in a way this is the best
certificate for testing of their
sentence and I don't think you should be
very happy about this and therefore I
also hesitate to show you this sentence
but it is so true that I cannot withhold
it from you so the goal must be a
dramatic reduction of the test basis all
feasible
now the best way is of course to go to
be radical and to reduce the number 20
and the way that dudes doing that is
called analytic testing analytic program
analysis or program verification if you
want now this is certainly a field that
has undergone very much research
activities mostly at universities and is
still being actively pursued and you
might wonder why it is not more widely
applied and why it hasn't been much more
successful than it has so far been first
of all it's not easy you need quite a
capability of mathematical thinking of
proving essentially what I throw already
have shown that is programming is an
activity very close to prove
mathematical proving and not everybody
is very much trained at this and so we
shouldn't expect that we could get
thousands and tens of thousands of
programmer to be brilliant mathematical
provers so that's one thing of the side
the human factor and the other is of
course that when you want to prove
something you have to have a sound basis
from which you can start your proofs by
applying a whole sequence of deductions
so the deduction rules must be very
precisely defined and the basis on which
you rest your your your universe rests
now debate what is the basis we prove
programs which are texts texts written
in a certain language and in order to do
anything rigorous about such programs
your language must be rigorously defined
as a matter of fact people look at the
programming language as something you
drop down programs and then you feed it
to the computer but actually a good
programming language is for human
consumption it should be the tool in
which you precisely formulate your
programs which are then subjected to
mathematical reasoning that that's the
same that's already said in the 1970s
Dykstra was a very strong proponent of
always but it hits the key of the matter
a programming language must be
rigorously defined and you must be able
to do mathematical reasoning with its
text and if you look at nowadays Madame
programming languages they're further
from black oh and they were big 50 years
ago I would rather have mathematical
reasoning conducted on algal programs
they don't see programs or name it you
name it here one jar of whatever our
languages have become so huge so
complicated that it there is no hope
whoever put them into a rigorous
mathematical framework as a whole and
furthermore programming has changed it's
not just concocting programs in that
language according to given rules you
essentially rely very heavily
on library routines and most of your
time is actually spend inviting the
right library routines and understanding
them so I'm afraid I'm actually drawing
a fairly negative picture of our
so-called science and testing at the
conclusion we can safely draw testing is
going to stay with us forever maybe
that's a satisfaction for you it's not a
very brilliant recommendation for
academia in computer science and I don't
hesitate actually think they failed
pretty badly and I don't even have to go
to prehistory to make this point
prehistory well i think that the era of
computing started around 1975 with the
advent of the personal computers
particularly out on the xerox lab which
brought computing into homes and into
schools out of these very few closed
computed computation centers inhabited
by the so-called specialists so
everything that I'm I was telling you
about 3 1975 is prehistory prehistoric
events we should consider high level
programming languages as formal systems
it's not only the users would come could
conceive them consider them as such but
the designers high level languages not
spiracles defined as I said and the
point is without reference to any
underlying mechanism for their
interpretation because if you do not
satisfy this requirement any programmer
who finds his program in mistake or any
tester must obviously also know about
the underlying computer he cannot just
rely on the definition on the rules of
the language now it's always said that
these languages are high level what does
that mean I think that just means on a
higher level of abstraction abstraction
means that you can forget about certain
things and in this case about the
structure and the instructions said and
so on of the underlying computer and you
should be able to use a language or this
or that computer and should always
behave equally well and if you do not
deliver a definition of the language
without reference of that computer then
you're in bad shape I have struggled I
think all my life creating a language
that would be explainable without
reference to a complete and my first one
oily mental but i'll go w and then
pascal had had this in mind but of
course i failed at to produce a language
in due time that was usable for me and
for our students so i couldn't wait
until i had found the ultimate solution
pascal had failed there are certain
things where you have to
no they understand underlying machine to
understand mistakes then came modular
and then overall and each time I think
in this with towards this goal there was
a definite progress made in modular the
idea of the encapsulation was brought in
very important i think i mentioned that
even in the milestones modules in the
encapsulation that was in nineteen
eighty in ada they were then afterwards
called packages ada was like the big
influence by title say not only got
asked out but by modular encapsulation
and module concept are important insofar
as it was guaranteed that mistakes comes
occurring at one place could be analyzed
by just looking at its immediate
environment and you could exclude
objects or variables defined procedures
defined in other modules in other parts
so instead of having the whole world to
analyze you could restrict your scope to
a certain module already a very big the
progress of which people are even
nowadays making use
after certainly a great help of reducing
the number of cases to analyze of course
as I said it would be ideal to reduce
the test cases to zero that means by
using strict mathematical analysis and
for that you need the axiomatic
definition as a basis for proving
program correctness I'm afraid this idea
had come up about 40 no 30 well no 40
years ago between 30 and 40 years ago
and a lot of activity started
immediately out for approving programs
correctness by analytical methods not
very very much has happened so far I am
afraid at least not in practice industry
practically ignores all these efforts
and I can also understand why because
practitioners industry after the you
with the systems available at large and
they are huge and they are not built
with these methods at the first place
and if you build a house you can prove
its stability as long as you want if you
don't know how stable the ground this
don't get very far if you build on sand
it's not as if you build on block and
what they were you prove about the house
must cannot be better than what the
ground
promises well here of course we come to
a topic that I is very much close to my
heart the problem is in the complexity
of our systems and we should strive
every day when we program to reduce
order to keep the complexity within
manageable bounds but we are in the bad
position that of course what ever we
build is built on on many many other
systems that are hundred or thousand
times more complex than what we build
and so we can only promise anything with
the reservation that the environment
holds to the promises in a way we are
very much victims of our own love and
boundless exercising of creating more
and more complexity a telling tale or of
course the programming languages which
have become more and more complex and
there are programming libraries which
have become huge and they were become
huge and there are given specifications
but they are typically not complete
yes I have talked about the past and let
me add at least five minutes to talk
about the present i have out of this
world of huge programming systems by and
large but i'm still participating in
long project and have to program myself
i program software in the language of
our own making this Oberon and it is
really a pleasure because they're one
understands what's going on of course
having built it myself mostly i should
understand so this is one thing the
other thing is that i'm the same project
designing hardware essentially a set of
identical processors connected by a
network and all this is done on the
programmable device and fpga and there
of course nowadays you do not acid eat
10 or 20 or 30 years ago they're all
circuit diagrams proving the correct
neural circuit how did you ever do that
unknown concept no nowadays you don't
draw circuit diagrams anymore you
describe them in terms of what over
circuit description language which is
also called programming language the one
I'm using is called very lock commercial
product first of all it's also a
language which is hugely complex and it
has one excuse namely that it has to
introduce software concepts into
hardware
and sometimes you don't know whether
describe a sequential program because
the statements look very much like that
but then you realize again that you're
actually describing the circuit where
old gates operate at the same time
parallel so we are even further away
than you are when you see or C++ or C
sharp from any kind of sound theoretical
basis which would allow program proving
but then this language is also
surrounded by a lot of tools and they
are the real misery starts I'm really
struggling in finding my way through
these tools and often the concepts are
not clear and the connections are not
clear and sometimes I just don't know
whether there is a buck in the tools or
in the back in my thinking narrowing
down of course is the mistake is a
primary principle in finding mistakes
and sometimes you just stare at the
place and you see it must be right look
I'm writing and then you call for an
expert and after a few days they find
out that this and this was the reason
something have been missing completely
different ways of the system or of the
toolset or of the configuration
specification or
configuration files with all kinds of
things where something might go wrong
and which are of course not described in
this very lock to understanding very
lock is by far not enough you must
understand a lot more inclusive
inclusive down to the levels of Cades so
if you are unhappy with the tools of
your software world then i order you to
dive into the hardware world for a few
days and you come back happily know it's
a sometimes feel this is such a highly
praised field information technology or
computer science and I sometimes wonder
where is actually the progress that we
have made we are still struggling with
similar problems as we did 50 years ago
I told you we have to sign up times and
we had long long compilation times even
for small programs well my hardware
program is also only few pages long and
when I compile it after wait half an
hour and then I spend an hour finding
what went wrong if i'm lucky i find it
out usually i do not but i get some idea
what might be a possible remedy i make
one or two little changes and then I
wait another half hour reminds me
totally of the times of the sixties
there at least I had the time to go home
not only to drink a cup of coffee
but still it's the same basic problems
that we are fighting with and it it
shouldn't be that way I believe we could
increase the productivity of our
engineers by a factor of a hundred and
more if we had proper tools now our
dilemma is of course that we are stuck
with the tools also the huge companies
who produce these tools are stuck and
sometimes they admit that they are my
sovereign most I don't know a way out I
don't know don't expect that I have a
panacea to get out of this situation we
have moved far too deeply to trace back
to bad i'm nothing to leave you with
such a bad bad note but before we start
a discussion and i have a bulletproof
vest by the way let me leave you with
with a few perhaps a bit more positive
thoughts well as we acknowledge that
testing is in this is indispensable
strong efforts must be made to eliminate
errors in the first place instead of
detecting avoid errors this of course
means that testing and programming must
be intimately intertwined this shouldn't
be separate activities I mean they have
seen now already that in order to reduce
this enormous number of testing cases
you have to know the structure of your
program you have to know how it was
developed and then you can test water
cases oh and rely on things in between
seeing
hopefully seeing that there's a linear
or whatever behavior between the two the
porters if the if the erase is 100 has a
hundred element if you test for zero
element and for 99th element you can
safely assume that in between if you
probably want to do so you cannot
separate testing from development now
whereas analytic methods are needed they
are neither easy nor infallible I'd like
to put stress on that too because
program proofing is a very subtle
business it needs only it leads very
good logical skills and since systems
are huge we have a tendency to automate
them like testing if something is too
big to understand when it's automated
and computers are fast enough nowadays
so we'll manage somehow whether this of
course increases the trustworthiness is
another question but it's not infallible
and proofs can also contain errors so
you may make an error improving an error
erroneous system and this leading to the
belief that the whole thing is correct
more effective because available now
would be simple less baroque languages
less baroque formal systems together we
stood with a disciplined approach to
program design I think programming is no
I don't think I know it is so
programming is that the base is at the
root of the whole matter and
it's not given proper attention this may
be a strong statement but it is true at
universities programming his is
neglected the skill teaching the skill
of programming is necklet neglected
because it's difficult and it's
considered below the rank of academic
activities I mean programming you see
you by osmosis somehow you are a clever
fellow you can strike this together and
this is not so for the simple things yes
but as soon as things become more
complex is not tony hoare once said we
should look at programming like learning
to play the piano you very quickly learn
to play the first simple tunes with two
fingers but in order to become a master
you must learn it play with ten fingers
and very often we quickly are trained to
train we are asked to learn playing by
two fingers and then later on the
difficulties are low or overwhelming
universities are not very good places to
learn programming there are no
professors who teach programming because
they don't program themselves anymore
that's why are not familiar with
difficulties which are also present in
the languages and the systems they
choose and then they leave the trouble
to their assistance
yes can we do I don't know maybe you
have a solution that is really what I
wanted to say and I hope we can have a
few questions now thank you very much
for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>