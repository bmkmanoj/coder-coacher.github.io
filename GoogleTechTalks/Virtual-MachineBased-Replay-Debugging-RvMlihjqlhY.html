<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Virtual Machine-Based Replay Debugging | Coder Coacher - Coaching Coders</title><meta content="Virtual Machine-Based Replay Debugging - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Virtual Machine-Based Replay Debugging</b></h2><h5 class="post__date">2008-11-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RvMlihjqlhY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone I'm Jaron I work in our
Santa Monica office it's my great player
here to introduce you with a Lewis
Porsche entire and Michael Schneider
were ski there he is and finally Eric
Chen they both are from VMware and they
are here to present a virtual
machine-based we play debugging Eric and
I go way back with way back so it's my
biggest prayer to host him here so enjoy
thank you testing can you hear me know
okay let's get started my name is e
lewis you can call me e hi it's pleasure
to be here let me give you a little bit
introduction for the guys here I'm glad
that the four of us are outnumbered by
the Googlers that's good we've got
Michael Schneider he's a GDB maintainer
we've got mike chen he's the manager he
runs this project he makes it happen and
we've got Prashant dandre how did I do
who knows way too much about the windows
kernel so what I'd like to do right now
is talk about some work we've been doing
at VMware and I I hope you're going to
agree that this what we've got here
represents I think a particularly
interesting application of machine
virtualization and i hope to entertain
you but i also hope to inspire you to
weave and we've actually got some
products that use this stuff i hope
you'll give it a try play with it a
little bit and tell me the ways in which
it sucks so that perhaps we can improve
things so my point is we love some
feedback here so let's begin by me
trying to guess who you are I think
they're your you've probably fall into
one of a couple categories you might be
a developer and you may have said to
yourself from time to time it has to be
easier to find bugs you may be a tester
and you probably have said to yourself
from time to time it has to be easier to
report bugs you may be one of those
manager types and you think yourself I
need to streamline my test dev processes
and even if you're not one of these or
even if you've never asked these
questions my guess is you're some kind
of a technophile and you need a break so
here's that break okay before we really
dive into things let me give you some
insulting insultingly simple pictures
describing what virtualization is and
just just to make sure we're all sort of
on the same page here so in the
traditional view of what a machine is
and how programs run this is pre-google
pre vmware this is what you got right
you got some hardware in the bottom you
got an operating system that sits on top
of that then you got out applications
that sit on top of the operating system
so in a virtualized world you've got a
picture that looks more like this and
what the important distinction here is
we've introduced this component and I'll
just call that in very general vague
terms i'll just call that the
virtualization layer and what that's
doing is that's virtualizing the
hardware the CPU the memory the neck the
discs etc and then presenting a virtual
view of that hardware to potentially
multiple operating systems sitting on
top of it so I'd like to point out and I
think that the key here oops the key
here is that that virtualization layer
is the boss of whatever is above it it's
in charge and as a result it can observe
everything that's going on above it and
furthermore it can control what what
what the guy above it does so it's in
it's in complete control and that gives
you a bunch of nice characteristics
right that gives you for example the
ability to migrate virtual machines from
one physical machine to another physical
machine without actually bringing it
down that's a trick we can play because
the virtualization layer isn't charged
similarly what we're going to be talking
about here is a a record replay
mechanism that lets us record what's
going on cited on inside a virtual
machine and then replay it in exactly
the same way and this is the key to
making that happen because that
virtualization layer is in control of
everything we can record what's going on
in the virtual machine we can replay it
uh okay another thing I'd like to point
out just
okay good another thing I'd like to
point out here is that I still have an
operating system sitting on top of the
hardware and their virtualization
environments do things in different ways
this is the picture for a product out of
vmware called vmware workstation and
that's what I'm building on here but of
course there are other virtualization
environments like the ESX server from
VMware where there is no operating
system the virtualization layer sits
directly on top of the hardware okay so
let's get started so the motivation here
is that software software debugging is
important challenging and expensive and
i think there's no controversy here
clearly it's important sometimes
developers produce programs that have
bugs in them it happens and it turns out
they're often really hard to find if
they weren't hard to find they probably
wouldn't have made the mistake in the
first place and because they're hard to
find it's expensive it takes a lot of
time to find these problems what I'd
like to do now is highlight what I think
are some particularly challenging
aspects of software debugging challenges
of debugging the first has to do with
will forget about fixing the bug forget
about even finding the bug the first
challenge is that the developer his or
herself did not find the bug usually
somebody else who finds the bug it's a
quality assurance engineer it's a
customer out in the field so the first
step is just communicating the fact that
there is a bug to the developer so the
developer can fix that bug and that's
surprisingly difficult so you know the
idea is you say here's the reproduction
area to reproduce this problem here are
the inputs you need to provide and so on
but often it just kind of doesn't work
often the you say well I clicked on a
bunch of things in the UI and then it
crashed well that's often not enough to
go on another challenge is that some
bugs just like to hide some bugs are non
deterministic sometimes they're there
sometimes they're not as a result even
if you give a perfect description of how
you produce the bug the developer may
not be able to reproduce that bug
another important challenge of
debugging I think is that debugging is a
very invasive process so sometimes the
bug disappears when I look at it in the
debugger and that's because when you
attach to a process in the debugger
you're potentially changing the timing
characteristics of the application
you're changing how threads are
interleaved you're changing the order in
which locks are acquired any network
connections you have may timeout because
you're sitting at some breakpoint trying
to decide what to do next and all three
of these sort of boil down to the same
thing which is if you can't see the bug
you can't reproduce it you can't make it
happen it's really hard to fix the
problem and then a final challenge of
debugging I think is that debugging is
unidirectional and this this seems a
little weird at first but it is a little
odd or I think those who have debugged
have this common problem that you get to
a certain point you say AHA I know I
have a problem but the manifestation of
that problem occurred earlier you sort
of gone too far one person shook their
head in the audience this is great but
but I think you're all thinking it
you're all thinking shaking your head so
that's so okay so these are the what I
think are important challenges enter
replay debugging I think replay
debugging is going to help us address
these important challenges so first what
is replay debugging well the idea is
dead simple the idea is we want to
record the execution of some program and
then we want to replay that recording
but debug it while it's replaying really
simple and we're going to go into this
in more detail to make it crystal clear
but I think this is provides benefits
that directly address the four points we
looked at on the previous slide so first
there's encapsulation this gives us
encapsulation I've got everything
necessary to reproduce the bug in that
recording right so there is this problem
that delivering or telling a developer
how to reproduce a bug is really hard or
can be hard but if you can just give the
developer a file that contains the
manifestation
that bug well then you don't tell the
developer anything it's all encapsulated
in that file in addition replay
debugging is deterministic so again
there's this problem that bugs are none
that can be non deterministic they can
hide but once you record a bug it
transforms a non-deterministic bug into
a deterministic bug because you can
replay that recording over and over
again and the program will have exactly
the same behavior replay debugging is
discreet this is the opposite of
invasive on the on the previous slide
because we're creating a recording and
because we're not doing any debugging
while that recording is being created
when we replay that recording the
behavior during replay is determined by
the behavior while it was recorded so
whatever we do while we're debugging has
no impact on the behavior of the program
we're not going to change how threads
are interleaved how locks are acquired
or we're not going to our network
connections aren't going to timeout any
of that stuff and then the final point
is replay debugging can give us by
directionality replay debugging can give
us abstractions for moving of course
forward in time but also backward in
time okay I think a natural question to
ask at this point is well how are we
implementing this how are we recording
what's going on inside the virtual
machine well so so first they're the
goals of recording inside a virtual
machine the properties we want we have
our that it's whole machine it's a whole
machine recording so thatÃ­s say we're
recording what the operating system is
doing we're recording what all the
processes are doing and a principal
advantage of that is well there's some
efficiency issues let's not talk about
those right now they're a little subtle
but there are an advantage to this is if
you got a complex system that has
multiple components you can just record
it all and then choose to debug the
components that give you a problem at
any particular point in time you don't
have to commit to what process you're
going to be interests
also our replay our record replay
technology gives us perfect instruction
by instruction fidelity and this is the
thing that gives us determinism the idea
is when you record what's going on
inside a virtual machine we're going to
replay the identical sequence of
instructions exactly the same
interleaving of processes exactly the
same behavior of the operating system
and of all of the applications
instruction by instruction identical in
addition our technology has low runtime
overhead during record and replay and
low disk overhead for the recording
itself and I think it's natural to say
the second two probably seem like
they're at odds with the first two like
you can't sort of get perfect fidelity
and have it be cheap so let's look at
how we do this before we and then come
back to this question about the the
overheads that that this record replay
technology has so how do we do it well
let me explain it to you in 18 inches if
this topic probably deserves a little
more talk than this but but here's the
summary it's actually I think it's just
what you'd expect the idea is we want to
only record non determinism in the
execution inside the virtual machine and
and this this is I think that I think
this makes sense as you're executing on
a processor it's usually really easy to
predict what happens next right it's the
next instruction or if it's a branch
it's where you branch to so normally at
any given time you can easily predict
what comes next and the only place where
you can't predict what comes next is
when there somebody enters some input
there's some sort of an interrupt a
timer goes off these sorts of things so
what we do is only record the
non-deterministic aspects of execution
but otherwise let the processor just do
its own thing the result then is a small
log because we're recording a very small
amount of information and very fast
execution because we only have to sort
of interrupt the process
sir and sort of interrupt the normal
execution of the program when we're
dealing with one of those infrequent
uncommon events so going back then to
overhead in terms of disk overhead
basically the the overhead sort of just
to give you some ballpark figures about
what I really mean by overhead low
overhead here the disco overhead is kind
of in the neighbor for CPU intensive
applications is kind of in the
neighborhood of what you see in an mp3
so say a megabyte a minute that's not so
bad right it's also the case though that
we have to log we have to record in this
record representation of the recording
we have to record a net work input
traffic that comes in from the network
that makes sense right because when we
replay we need to have that network
traffic so what that means then is on
top of that say megabyte for a minute
we're recording the network traffic
coming in so depending on your
application you're going to have you
know from a little too to a lot recorded
in terms of the runtime overhead this
again depends on the application you're
running but CPU intensive workloads are
in the neighborhood of sort of like zero
to five percent applications that have
lots of interrupts are going to be
higher and we've seen as high as say
fifty percent again it just depends on
the workload yes
I think the question is don't you also
have to record disk i/o it's all right
Yeah Yeah right so so I so I made this
comment that I'm recording a input from
the network why don't laughter a record
input from the disk and the response to
that as well you can certainly record
input to the disk or you can in fact use
the disc itself you can so we've got a
mechanism that sort of creates a clone
of the original disk does sort of a copy
on write kind of thing and as a result
you've got all your data sitting in the
disk so you can just get it directly
from the disk rather than having to
record it so that's just sort of a
little optimization that avoids needing
to do that recording which reminds me if
you have any thoughts you'd like to ask
questions as we're going please do yeah
so the question was if we if there's a
if you're dealing with a bug that
results from uninitialized memory will
it still be deterministic and the answer
is yes yeah because we this recording
starts from exactly the same machine
state all of ram is the same and then
we're doing a deterministic sequence of
instructions that are just going to do
exactly the same thing yes
right so the I think the question is hey
what's going on with data that comes off
the network and the the answer there is
what we just record the data that comes
off the network so that when we replay
we just deliver that data that we record
it as if it arrived off the network even
though during replay we're not actually
communicating with anyone ok so I'm
sorry I'm missing this sometime there's
dynamic so you're describing an
application that has non-deterministic
behavior it won't so the important thing
is do I need to press the button here
theme look at that the the important
thing is no so there what we are going
to do is ensure that the sequence of
instructions that are executed during
replay are identical to what they were
the first time around so it will have
the same behavior and we're going to
force that to happen if the application
is using some kind of randomness its
using input if it's looking at timer
interrupts those are going to happen in
the same way during replay so its
behavior will be the same that is the
key point if that doesn't happen we have
to quit and give up ok let's let's push
along hold that hold that thought but
let's not stall here too long what I'd
like you to do at this point ok once we
pass this slide let's accept that this
replay mechanism works now let's talk
about using it for debugging so the I
want to point out that what I'm talking
about here is actually implemented in
VMware Workstation version 6.5 it's
available right now the particular
component within workstation does this
stuff is we're calling it the integrated
virtual debugger and what it is is it's
an extension to visual studio plugs
individuals
it supports C and C++ replay debugging
and the feature is technically
experimental at this point which means
if if you find a bug try not to yell at
us too much but it's it's it's it's
useful and I hope you'll give it a try
we delight and we're and we're actively
working on it to make it even better the
the goals of of what of the integrated
virtual debugger is we want to preserve
the visual studio debugging experience
so basically when you sit down at this
debugger you know what to do and we just
want to leverage all about existing
knowledge about how things work and then
we add a few key key features well we
add this deterministic replay we allow
you to debug something that's actually
replaying so it's having the behavior it
had not as it appears to be running but
as it did when it was recorded we also
add this a single sort of new feature
called reverse continue so when you hit
the continue button that executes until
you encounter some sort of an event you
get a break point there's you encounter
an exception this sort of thing reverse
continues exactly the same thing it
logically execute backwards until you
encounter the previous break point or
exception or some sort of interesting
event okay and then the final point is
it provides some support for managing
VMs so since we're working inside a vm
since our application is running inside
a vm it would be a bit of a pain if you
had to start up the vm and start the
program running and start the recording
and then attached to it and so on so
this integrated virtual the bugger
actually does the heavy lifting of
managing the VMS powering them on
starting the recordings that sort of
thing so i guess i shouldn't call this a
goal but you should know what there are
few key constraints that we've added
here and the most important one is we
can't change registers and memory as
we're debugging and I think that that
hopefully sort of makes sense why that
would be because we're replaying the
execution of the program if you change
the state of the program your replaying
then presumably you're doing that to
change the behavior of that program and
you can't do that because it's a
recording
similarly we can't change the control of
the program the control of the program
is determined based on what happened
during the recording phase so we can't
just say hey go execute this function
because that function execution wasn't
in the recording in the first place okay
so the big picture here in preparation
for a little demo I'd like to do as well
okay we've got visual studio and we like
to sort of attach it to some process in
debugging okay let's get a little more
specific here so we're sitting on some
physical machine running windows and now
let's put the final piece in play what
we're doing is we're in addition to
running visual studio on this Windows
machine we're also running workstation
and vmware workstation is giving us a
virtual machine running windows and in
that virtual machine there's a process
running and what we logically want to do
now is debug that process so that this
is sort of the big picture this is what
we want to do and the reason of course
why this guy this process is in a
virtual machine is that we want to
leverage the ability of the
virtualization layer to record
everything that's going on inside that
virtual machine you with me yes good so
let's look at a demo so I've got an
application it's a stock trading server
and it links a bunch of clients remote
clients to a single back-end server so
it's just taking these these trade
requests processing them in some way
doing some logging and then sending it
to some back-end that actually execute
the transaction the problem with this
application though is sometimes the
application crashes at the end of the
day that seems like bad news crashing is
not a good thing especially in this kind
of a context the challenges with this
bug is well it's non deterministic
sometimes it happens sometimes it
doesn't it's also particularly
challenged to debug because the setup
for this application is complex like for
the developer sit down and play with
this thing well the developer has to set
up a workload which means spawning a
hundred and fifty clients and then the
developer has to get a
back-end server a development only
back-end server because he doesn't want
to connect of course to the real
back-end server and actually execute
trades in addition live debugging
results in timed out clients so you've
got all these clients connected to you
right and whenever you set a breakpoint
and you think 44 seconds about what to
do what your clients end up timing out
so this this applications can be a bit
of a pain so so let's do a little
debugging here let's give it a try so
here i am in visual studio I've got this
trade star to project what I want to
point out is the plug-in that we have in
the in visual studio gives us this
VMware menu and this VMware menu gives
us a number of things to do a number of
additional facilities I'm going to point
out this options option and i just want
to point out how we configure replay
debugging we just have to basically name
the virtual machine we want to run here
and we name the recording we want to
replay and that's pretty much it so now
given that we've got a vm we've got a
recording let me try that again what we
can do is go up here to the VMware menu
and i want to say start replay debugging
okay and what that is going to do is
that's going to bring up VMware
Workstation it's going to restore the
state of the machine that represents the
start of the recording that's what we're
doing right now then it's going to start
replaying the program as it executes and
that's what we're seeing right here and
then and then we're debugging so the the
program this text window here hasn't
done anything very interested let's
that's good right good hasn't done
anything very interesting yet because
we're just at the first line of Maine
but I want to point out that if you look
at what I'm doing here we can do sort of
stand your basic windows or know your
basic debugging stuff like
step over some functions I can say step
into a function you know step some more
I can step out of a function takes me
back to where I am if you look over on
the right hand side I've got all my
local variables if you look down here I
can see what DLLs I have I can see what
threads I have I can look at my call
stack this it feels like i'm debugging
right there's nothing sort of special
here but the thing that's interesting is
that i'm debugging a recording so what
that means then is it just go it's going
to have the same behavior every time it
runs so if i set a breakpoint at this
point then i want to continue and let me
go back to work station I'll see an
entry for the first transaction so that
first transaction was for a client named
Smithers it's always going to be for
Smithers that's just the way it is I
just happen to know so let me let me do
another step here so i just did a
continued it went one more time through
the processing loop the next transaction
was for Lewis and if I can just sort of
keep doing this and I could I could
debug this program over and over again
it's going to be the same every time but
ok let's actually fix the problem though
let me take out this breakpoint and let
me just run and after a while okay we've
got a first chance to exception in the
problem is an access live violation
reading some memory location 60-69
something okay here's the line which
that happens let's look in this t log
structure okay head the head field has
the value of 66 nine something and we're
dereferencing it so so here's the
manifestation here's the manifestation
of the problem which is where
dereferencing some garbage pointer
obviously so we want to know how this
pointer got bad so a natural way to do
this is to set a data break point or a
watch point so let's see if I can figure
out how to do that here so i want to say
new data break point and i want to do
that on t log head
okay and normally this sort of wouldn't
do us any good because we've gone past
the source of the problem but what I
want to do at this point is execute
backwards I want to execute backwards so
I can find out who put that garbage in
the head filled you with me good so
there is yeah I could hit this little
backwards button right here or I could
go to the VMware a menu and say reverse
continue this is just the analogy this
is the I'll put this over here this is
the sorry this is the analog of forward
execution what it's doing is it's taking
taking me to the last event the last
break point the last watch point
whatever it's not taking me to the to
the first watch point of the second
going forward it's taking me to the last
one so this is going to take me to the
bad guy the bad the guy who corrupted
this data in the first place so some
stuff is going on here I can I'll go
through sort of the the details about
what this is doing in a second make that
a minute but the point is we have
arrived someplace we've hit our break
point well let's figure out what's going
on so we're in some library code let's
look at the call stack to get back to
our code to find how we got in that
library okay we're calling stir copy and
we are copying the name nah subpoena
pedal on into this last name buffer and
okay i think there's our problem the
problem is our last name buffer only has
12 bytes allocated to it but now a
subpoena pedal on is considerably longer
so the problem is we're doing a stir
copy we're not checking bounce we're
overflowing the buffer allocated for
that string into an adjacent buffer into
an adjacent structure which contained
this head field and I could show you the
declarations of these of these two
structures and you'll see they're right
next to each other makes sense that one
would overflow into another so the
summary there is in fact Glenna line
go to hear the summary here then is what
this is giving us is mostly a normal
debugging experience I'm just using
visual studio and debugging but bug
reproduction is now trivial the program
has become deterministic it was non
deterministic sometimes it would fail
sometimes it didn't but whither the
recording it's always failing another
important point is the environment is
part of the recording so this wasn't it
this was a program that's actually
really difficult to set up and run at
all because you've got to set up all
these clients to cert to give the
workload to this application and the
backend server but once you've got it in
the recording you don't have to do any
of that stuff because the recording
replays all of that Network interaction
so it happens in exactly the same way
makes to debugging a whole lot easier
and in addition reverse execution makes
it easy to find interesting execution
states because you can go in addition to
going forward you can also go backwards
if you've gone a little bit too far so
at this point I'd like to take some time
and talk about actually you with me
anyone want to throw out any questions
here yes yeah okay so the question is
what does it take to create this
recording in the first place and that's
a great question and I apologize that I
didn't tell you so the there are
basically two ways to create recordings
one is if we go up into the let me do
this let me stop debugging so if we go
up to the VMware menu there's this
option create recording for replay and
what that's going to do is that's going
to power on a vm wrist restore to a
particular state in time start recording
start the execution of your program so
that's just going to create the
recording for you it's also the case
that the VMware Workstation itself has a
recording button so even if you don't
have visual studio even if it's the
quality assurance engineer who doesn't
want to play with a debugger they can
still just press the record button and
then give that recording to the
developer who can end
yeah if this is gonna be long enough
should you use the microphone may be
good cuz cuz i'm in a good a try
could could we have the microphone
better look there we go okay so that
there's two big use cases we really care
about and there there's somewhat related
and basically what we want is a
situation where we could have some sort
of you that are automation tests running
or a manual test running and the way we
do a lot of that right now is we have a
bunch of vmas images laying around we
pull one up we have someone either run
an automation test against it or they'll
play with particular feature whatever
and then oh darn a crash happened what
we'd love to be able to do is start up
that session and say okay start
recording this stuff and if something
happens in that session and say the
course of several hours of something
going on without to be able to say stop
record everything that happened in the
last 10 seconds moreover we'd love to
have that be able to some have something
automatic where okay we've got say a
thousand VMs running somewhere doing a
whole bunch of automation test rain
throw a bunch of sequences and 70 Darin
one of them crashed detect the crash
immediately record the last 10 seconds
send it to a developer to investigate
are those right the circle things you
guys are thinking about oh yes so this
is great so these are great points I
there's there two answers to this
question if you go grab workstation 65
right now we've got nothing for you in
that regard but we're playing with
exactly the stuff you're talking about
and I think this is this is sort of what
I'm imagining you want and I think
there's sort of two pieces to this one I
let's see so we can't at the point of
the crash you can't to decide you can't
decide to record the last ten seconds
because it's happened already but what
you can do is you can we can just say
record but then trim off the old stuff
so that we can do that that and the yeah
it's it's a big black box situation so
that that that we can do or will do soon
rather that's a that's a great case
that's a natural thing to want to do the
second part of this is sort of
automating this because what you kind of
want to do is you know if you've got a
you're running a bunch of tests and
you're sort of failing here and there
you don't want to keep trimming them off
because you'll trim off those failures
so you want to have some
in your scripts that are running you
want to have the ability to say hey stop
this recording save you know the last 10
minutes or whatever put it aside now
start a new recording I think that's
great I like it prashant and I were
talking about that yesterday good
excellent so so let's talk a bit about
the implementation here let's get a
little a little geeky so let's see what
do we have well we have a replay
infrastructure let's just accept that
our replay infrastructure works we can
record what's going on in a vm we can
reply it it's also the case that we have
the ability to do remote debugging and
really when you're debugging a program
running inside a vm it's it you're just
remote debugging right you're your
visual studio kind of just thinks it's
debugging an application running inside
another machine that just happens to be
a virtual machine okay and any debugger
can do remote debugging right so it
seems like replay debugging just as the
combination of those two it should just
be easy right and what I'd like to do at
this point is talk about why it's not
quite that simple and I want to talk
about a couple of the challenges we we
have and I think these are sort of the
key challenges we have to making replay
debugging work so the first is that it
turns out remote debugging is not really
compatible with replay it kind of
doesn't make sense so I'll talk about
that in a second it's also i also want
to talk about how we make reverse
execution work so you know that doesn't
address the fact that we want to have
this abstraction of work reverse
execution and finally we want all the
stuff to work with visual studio and
visual studio is not really play in our
game visual studio doesn't know about
reverse execution so we might have to we
might have to fool it a little bit to
make to make all this work so let's talk
about the sort of incompatibility of
replay debugging and remote debugging so
here's a normal remote debugging setup
right I've got some physical machine
it's got some target process I want to
debug I've got visual studio and what I
have running on that physical machine is
some sort of debug monitor in the
windows world this is ms b c mon and
that's the entity
it's controlling the execution of that
target program reading its registers
setting breakpoints those sorts of
things so that's sort of the normal
remote debugging world so in the virtual
context which is where we're operating
we've got this virtualization layer
sitting underneath and this is great
because it's giving us the ability to
record what's going on inside that vm
but i think this is where you start to
see the problem remote and replay
debugging are incompatible because
remote debugging requires execution in
the remote machine while you're
debugging let me say that again this
time clearly maybe the point is while
we're debugging we're going to say
things like hey what are the values of
the registers and we want msvc mon or
whatever our debug monitor is to execute
to run some code to figure out what the
values of the registers are the problem
though is ms b's ms b c mon didn't do
that while we were recording it right so
what we want ms piemonte vc mon to do is
do a different thing when it was
recording and when it was replaying and
that's at odds with what our record
replay mechanism does you with me on
this problem yes
yeah that's exactly right so the
statement there was the statement was
yeah that's right and if you are if you
press the record button on the vmware
workstation you i m sms nsv seaman
wasn't even running at all ok so what's
the solution to this well the solution
is we want to provide some sort of debug
monitor functionality outside of the
machine and we're going to use the
virtualization layer to inspect the
process state and read register values
and read memory and that sort of thing
so the picture then looks like this here
was the original circumstance we've got
this virtualization layer underneath and
what we want to do really is basically
move the debug monitor functionality
into the virtualization layer okay so
what that means then is we can replay
everything that's going on in here just
like we always were and visual studio is
going to talk to this debug monitor
that's running outside the vm so we can
do whatever it wants and it can of
course still ask for register values and
set breakpoints and do all those sorts
of things the basic functionalities of
this debug monitor needs to start and
stop the program it needs to read memory
set breakpoints detect interesting
events like a breakpoint hasn't been
encountered or an exception has been
encountered a dll has been loaded these
sorts of things and I think a key result
of all of this is this is an important
part of non-interference right because
we're not running anything in this the
guests that knows about debugging all of
the debugging functionality is in fact
outside of the entity that you're trying
to look into so you with me on this what
do you think
good so let's look at a couple other
challenges one is just this this whole
feature of reverse execution so we saw
we saw it in the demo it took us to a
point in the past and the question is
how did that implementation how do we
implement that and my guess is well so
let me tell you the idea is we could we
could try to actually undo instructions
one at a time but you only want to do
that if you got a lot of time right
because now we've got some sort of
interpretation overhead per instruction
and if you do something like this so
you're probably going to see a slowdown
of say say 30,000 now maybe a hundred
thousand it's going to be slow so what
we want to do is instead leverage the
fact that we've got this really
efficient and high fidelity way of
reproducing the machine state at any
point in time via replay we're going to
simulate reverse execution by our replay
so the idea is if this is our timeline
we're running along the program started
we stopped right here maybe we hit a
break point and then we say hey I want
to go backwards so what we're going to
do is we're going to do two phases
versus that is the discovery phase and
we're just going to execute along and
look at the events that we're
encountering these are like break points
and these sorts of things so the idea is
we hit say a break point and then we
then we have to say to ourselves well
are we there is that the last event of
interest well you don't know because
there might be another break point right
here right the only way you know what
the last event is is when you get to
where you started right so we just keep
executing along we encounter these
events here we created a thread here we
hit another instance of the first
breakpoint and finally at some point we
reach where we started in the first
place and only now do we know what the
last event was this was the last event
so now we know where we want to be now
we have to get there and of course we do
that in what I'm calling the final phase
which just takes us straight to that
state in time okay so this is what we
think back to the demo I don't know if
you're
or if you didn't blink he saw that we
actually had these two replay steps and
that's exactly what we're seeing here
but I do want to say you with me okay
now I do want to say also that a key
thing we need to do here is optimized
because we don't always want to do to
these two replay steps and in fact often
we don't have to because if we want to
do another reverse execution well we
know exactly where to go it's it's here
so we can just go straight there without
that discovery phase so optimization is
key to making this practical so we don't
have to have all of those replay steps
it's also the case that well we want to
we don't always want to have to replay
from the beginning of the program so you
can sort of drop checkpoints
periodically and just go back to the
previous checkpoint and replay from
there it's also the case that D war what
does that mean deliver events without
replay the idea is well this create
thread event for example visual studio
is just going to say hey thanks for
telling me a thread has been created
continue so from a user's perspective
replaying to that point in time to
deliver the event is kind of a waste see
what what we want to do is instead just
deliver the event but not actually
replay there to avoid to avoid a costly
replay step okay what do you think thumb
this up excellent yes
the transistors and electricity backers
look at the logic level and kind of like
converted everything going backwards
could you something that would actually
give it so so that's it so I'm gonna
have a hard time repeating that question
but the question was sort of something
like what if I actually wanted to sort
of at the at the actual logic level
turned the crank backwards actually have
the concept of reverse execution and and
it's interesting question the thing
that's particularly challenging about
that is execution destroys data so you
actually over right data so you can't
derive your you can't always derive your
inputs from your output right so you
would need to store some additional
information so I think so we'd have to
go further than actually you know
sending the electrons the other way but
it would be interesting the I think the
my feeling is that that's going to end
up storing a huge amount of data and
what this avoids is it avoids precisely
that because the because all we need to
be able to do is a replay okay but let's
talk I thought you were I thought you're
going toward this problem so here's
another challenge from the challenge
here is that visual Studios is is not
with us on the whole reverse execution
thing visual studio doesn't know about
reverse execution so what we need to do
is we need to sort of deliver undo
events so that reverse execution feels
like forward execution so suppose here
is our timeline suppose our we're
executing along we encounter a load dll
a create thread then we exit that thread
then we stopped at this point say
because we hit a breakpoint now suppose
we want to do reverse execution here so
we of course don't know where the
destination is the breakpoint can be
here it can be here it could be here but
let's just assume we've got an Oracle
that for this demonstration that tells
us the breakpoint is here so ultimately
we want to get here and the question is
what do we need to do to get to this
point the we could deliver we could go
backwards deliver this let's see we
could just go to this point in time
right the problem though is the visual
studio will think that the dll we load
it at this point is still loaded but at
this point in time it wasn't
you with me so if we revert to the state
at at this point in time and then the
user chooses to look at their their
modules they'll see a dll that's not in
fact loaded so we've got to sort of undo
all of these guys so that visual studio
has a consistent view of the world when
we sort of wake up at this breakpoint so
what we're going to do is trick visual
studio into thinking that it's playing
forward and then what we're going to do
is deliver sort of the dual of this exit
thread will deliver a create thread and
the logic is were we're logically about
to enter this region in time and during
this region that thread existed so we'd
better create it okay so here's kind of
what's really happening we're kind
here's what the user want how the user
wants to think about it they're actually
going backwards they're going back to
that point okay then we're going to
visual studio is going to continue to
think it's executing forward and we're
going to deliver an exit thread
corresponding to this create thread
because we're entering a region of time
here where that thread didn't exist so
we better tell Visual Studio exited okay
and then similarly the users model looks
something like this we've actually gone
back time to this point okay then we
continue on we create an unload dll
corresponding to this load dll the user
thinks of it this way and then finally
we deliver this breakpoint and then the
important thing is from visual studios
the debuggers point of view it has an
accurate view about what threads exist
and what dll's are loaded at this point
in time but it got to that state the
state of the machine by what it thought
was forward execution so we're just
tricking Visual Studio delivering these
sort of pseudo undo events so that it
has a consistent view of the machine
when we when we when we take it back in
time yes
because you actually additional
operations in which step like locking
stuff you've received two logs because
you're actually low
is there
right
uh I'm not getting what you're saying
uh-huh so the important thing the thing
we're trying to achieve is when we stop
at this point going backwards the state
of the machine in terms of the this what
the stack looks like what the mall the
threads that are running all of the
dll's that are loaded the values of all
the variables is the same as it was at
this point in time so from the users
perspective the state is identical
between these two guys
lisaraye this please sir can show up
that's the goal
where
so so I I will admit I'm confused they
we are in fact delivering these events
to the debugger they're not happening
yes they're not actually happening there
there is no create thread rather there
is an exit thread and we want to
logically move past it going backwards
so we just make up a create thread and
we make up a create thread solely for
the purpose of compensating for the fact
that we're moving into a portion of the
code where that threat exists but this
would be a great thing to pick up toward
the end just to make sure because
there's another talk in here at three
let me squeeze in a few more then we'll
we'll talk over here in a second so let
me just give you a brief summary of the
status of what we have right now which
you can play with right now this this
only works in visual studio in the
windows context of course we have a
super stealth replay debugging system
that doesn't have reverse execution that
works under linux in gdb if you really
want to give it a try it works for C and
C++ we only work with single processor
VMs your host can have as many VMS as
you want but the vm itself can only have
a single processor the processor you're
running on has to work with the record
replay technology that basically means
it has to be kind of a new processor in
court to say
and when you replay you have to replay
on a processor very similar than the
processor e similar to the processor on
which you record it and then the final
point I want to make is we're not yet
into the NYS we're not yet into the
slick regime our buttons aren't shiny at
this point but I think we've got
something useful there are a host of
things that I think it would be
fantastic to work on here let me just
sort of point out a few of them you can
tell me if any of these would be helpful
for you one right now we've got the
separate recording step and then a
debugging step and there there are
contexts in which that's exactly what
you want but it would be kind of nice
just to have this sort of all the time
you can just say run my program in the
debugger and it just happens to be
recording and then you just happen to
have the ability to execute backwards so
I'd like to have this implicit recording
so you can just debug an implicitly
records and gives you reverse execution
if you want it of course we always want
to improve performance particularly
during reverse execution it would also
be useful to develop tools for isolating
recordings from the vm so right now it
can be a little awkward manipulating a
recording file itself because it kind of
gets married to the vm itself it so if
we had a way of we can build a simple
tool just to extract the recording to
make it easier to move around it would
also be great to have a sort of a
concept of attached right now when you
debug you start from the beginning of
the recording and replay but often you'd
like to just sort of jump to the point
where the the bug happens you just like
to start right there so you can sort of
think of it as this is a glorified core
file then right you go to the source of
the problem and then you look around
maybe that's enough maybe you have to go
backwards and figure out how he got
there and of course some slick vacation
but we nice to integrate this with some
existing VMware products that also be
nice to generalize this for the Linux
contacts gdb Eclipse windbg all kinds of
other contexts so the the pitch I'd like
to make to you at this point is that I
think we've got something pretty useful
but I I'm not convinced that we've got a
complete solution yet I think there are
a bunch of things we need to do and we
need feedback from people giving this a
try so I'd love love
if people could give this a try it's a
30 day trials are free at VMware calm
for work station after all so it's easy
to try but we love feedback to help
identify the most important use cases
how do people really want to use this
thing to help us identify the features
that are most useful and to identify the
context that are most useful the people
you know if you're doing all of your
work in the linux gdb context the visual
studio things hard to get excited about
okay so let me skip right to the
resources and say that you know here's
where we can get workstation you can
read about it at the blog replay
debugging com there's a forum and this
is the most important thing if you're at
all interested in this you want to give
it a try you want to talk about it you
want to tell me what you'd like feel
free to contact e Lois Lois at VMware
com we can talk on the telephone we can
exchange some mail my goal is to make
this great if this could be useful to
anyone let's see if we can make some
changes to make it really useful for you
I'd love to do that and if you're
glutton for punishment you can actually
read the manual but I wouldn't really
recommend that so when our remaining 21
seconds maybe we could take one question
and then you know head over there and do
a little informal talking the winner yes
yeah so this this is a great question so
the the recording itself is
deterministic but the process of
creating the recording will that affect
the performance of the system and the
answers well yes and the reason why yes
is it as I said there's some performance
implication here right we are executing
some code we are doing things different
than they would have been they would
have happened otherwise but i will say
that there's sort of two responses to
that one is that the impact we have on
the behavior of the program i think is
comparable for moving from say one
version of a processor to another like
that is to say we're not introducing an
overhead that's a factor of 10 or a
factor 20 that's just going to
completely change the game but this is
the performance impact we have is like
just running on a slightly different
processor so it's still realistic so
it's still you got what I'm saying okay
we because it's three o'clock and we
have to stop I should stop thank you
very much and I'd be happy to chat more
with you afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>