<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Knowledge Connectivity  vs. Synchrony Requirements for Fault-Tolerant Agreeme... | Coder Coacher - Coaching Coders</title><meta content="Knowledge Connectivity  vs. Synchrony Requirements for Fault-Tolerant Agreeme... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Knowledge Connectivity  vs. Synchrony Requirements for Fault-Tolerant Agreeme...</b></h2><h5 class="post__date">2008-04-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_K-4mVXWfdc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody
pleasure to introduce you fabula gravy
favilla is a professor at the federal
university of bahia in brazil and she
works on fault tolerance and in
particular she is going to give us a
talk on her recent work on the consensus
problem which is a classical problem
info tolerance and they advance she has
made to do the understanding of the
problem fabula welcome to google thank
you very much well for you doing thank
you for the invitation so I'm glad to be
here today to talk with you about fault
tolerant agreement problems and
especially the consensus problem which
is a very important problem on the
design of reliable distributed systems
these are consensus problems in
agreement problems are at the heart of
the development of mainly reliable
midler that we are aware of that we have
as for example group communication
service transaction servers reliable
servers and where else and in the
context of a peer-to-peer networks for
example if consensus be is being used
for maintaining data consistency so
these problems are very they are well
known to the dependability community we
have a lot of solutions to solve for
them but these solutions are able or
interested for a classical network of
wired networks or aesthetic of pathetic
service but when we want to solve these
problems in a in this modern context of
mobile networks or overlay networks a
dynamic networks we have a lot of
problems so the community is still
trying to understand them is still
trying to provide some good definitions
and to to find good models adequate
models to solve these problems
this environment so today I'm going to
present to you some of our results
concerning these these abstractions
which are necessary and sufficient to
solve consensus so this is effect are
joined to work with my colleague from
France Sebastian text oil and my talk i
divided my fault in four parts first of
all I will define consensus and the
abstractions that have been proposed in
order to solve it consensus in a non
classical context of self-organizing
systems again the name of Africa
photo/laurent consensus with unknown
participants and after that I will give
you our main results which are the
statement of sufficient and necessary
conditions for solving ft cup and
finally I will conclude and give you
some research perspectives so first of
all let us define our model we are
placed in a distributed systems
composite of a set x of n processes our
correct processes that is active during
the whole computation otherwise it is
faulty and a thought process will not
recover any more among the end process f
process can be fought and in- f can be
will be correct so process will
communicate by reliable channels which
means that messages cannot be lost if we
have to correct process P I and pj if P
is in the message m to PJ PJ is going to
receive this message so we are placed in
this context of self-organized systems
which are characterized the mobile ad
hot neck networks the sensor networks
instructed peer-to-peer systems overlay
networks what else and this systems are
highly dynamic which means that nodes
can join and leave the system as
wish they desire and also this these
processes are placed Internode's which
can move around so the system can be
mobile and there is no central authority
which we feed processes with with global
context information which will give
information about the whole network
topology and the whole composition of
the system so the system is
self-organizing and it is also a
synchronous which means that there is it
may make no assumptions concerning the
relative speed of processes nor on the
message trances delays so um in a
classical context in ovno networks
everybody knows everybody everybody can
communicate with every bar so we can
kill considering that the set of
processes pi and it's cardinality in is
known by everybody and the communication
graph normally is we are considered that
it is complete and partitions if they
ever happen this they are temporary
which means that the graph is all always
connected in the knowledge graph that
the knowledge that depth appears the
notes has have of the others is complete
everybody knows each other but in a
self-organizing context of a new
networks the composition in localization
of the piece is really a concern which
means that the the best that our process
can have is a partial knowledge about
the system composition so a process can
only send message sapir that day it
knows and it knows only a partial set of
this of the system and if this thing's
weakens we can consider that
communication graph is dynamic is
dynamic because the system wheel is also
dynamic and nodes can move and the
knowledge graph cannot keep be complete
and more
and also the edges are are not by
direction x direction so we have a
direct direction graph which is not
complete and it can be dynamic so this
is the model that we use to work with
our problem so the consensus problem as
we said is a fundamental problem and it
can help in fact the peers to deal with
the high dynamism they self-regarding
organizing nature of the system in order
to take consistent actions so but what
is the consensus in fact consensus is a
long process to agree on own actions in
the system so process will propose a
value and they will decide for a unique
value according to some properties which
are the agreement property not to
correct prosper up process decide
different values termination every
correct process we eventually decide for
us for the same value and validity the
decided value is the proposal today so
how can we solve consensus in fact
unfortunately consensus cannot be solved
in any synchronous systems even in a
classical network of non peers this is
known as the flp impossibility result
this is a fundamental result and any
presence of even one single crash we
cannot solve consensus and the community
has proposed a lot of abstractions in
order to deal with this impossibility
result and one of them in the most
interested or elegant abstractions is
their obsession of unreliable failure
detectors which are in fact the idea is
to feed the system actually reach the
system with some degree of synchrony in
order to to solve the problem the prob
of consensus so the unreliable fellow
detectors are detectives that will give
hints about failures in the system so a
process can consider a fellow detector
and it will give a list of suspected of
of process suspected of being fold and
these hints can be unreliable that
unreliable fredo detector can make
mistakes so it can suspect that a
correct process is crash or that a crash
process score it okay and base it on the
accuracy of this information we can we
will have some classes of failure
detector among these classes we are
interested in these three here so the
perfect failure detectors are the ones
which cannot make mistakes they are
perfect so the only way to implement
failure detectors which are perfect is
if we have a synchronous systems system
the other two they are unreliable so the
diode as fellow detector event released
wrongfully detector it can make another
a betrayer in number of mistakes until a
point in time in which after which some
correct process is never suspected by
all the process in the system another
fella detector is their leader detector
in it dis attacked in fact it will give
hints about a process identity and there
will be a point in time in which the
same correct process is going to be
given by the Delhi the detector at the
same identity of correct trust to all
the process in the system's the the good
thing is that these detectors diamond as
an Omega they are equivalent they have
been proven to be equivalent and they
consult consensus and they in fact
represent the weakest condition
synchronous conditions able to solve
consensus in an asynchronous systems but
as soon as the majority of processes
can is correct in the system so if we
have assists in a synchronous system in
Richard with these detectors we can
solve consensus and the good side effect
of this as strategy is that affect the
protocols that we conceived to solve
consensus are induced indigents toward
the failure detector which means that
the fellow detector can be unreliable
they can can make a lot of mistakes and
whatever it behaves their consensus
keeps they say the safety properties
which means that the consist we will not
decide without agreement and also the
the interesting thing is that we can
also solve uniform consensus as well
which means that process which decide
other day a crash or correct they will
decide for the same thing so in the
context of no unknown networks the
consensus has has been redefine it for a
cup which means consensus with unknown
participants and in fact this is the
same cup-cups keeps the same consensus
definition and it adds the assumption
that there is no global lodge knowledge
about the system composition and then
it's cardinality and these authors cave
in SAS on cheaper they have provided
solutions in order to solve this problem
in a few free environment and after that
they had afterwards that they had
started the problem in our favor on
environment and they called it it ft cab
photo learned consensus in the uniform
place your version of cup is a uniform f
F ticket so how can we solve this Cup in
networks so in fact the synchrony
assumptions that are sufficient to solve
consensus in a classical environments
are no longer sufficient to solve the
problem in a unknown network it is
necessary to enrich the system now with
some more informations some more hints
and in this case hints about the
participants in decisions or about the
connectivity of the system and in this
is the same authors have been provided
their abstraction of participant
detectors so this is the abstract a
participant detectors the same as the
fellow detectors that they are
distributed Oracle's in the systems that
will give hints about this the peers
which are in the system the peers that
participate in the computation and this
information is partial and this is it is
accurate and also it is not decreasing
over time which means that if you know
if the participant tell that somebody is
there this guy is really there and this
information is known is non-decreasing
it doesn't matter for the for the
abstraction of participant detector if
it detects that the guy was there the
guy was there so it is a knowledge
relationship so I know that the guy was
there if you it was there it was not
there it it moves i don't i'm not
concerned with this it's only a
knowledge relationship okay so the
information given given by these
distributed Oracle's are going to enrich
the system with a knowledge connectivity
graph okay and base it on the properties
of this graph we have some classes of
participant detectors
okay so with this abstraction this
author is called que vienen says OMG
pair they they they found necessary and
sufficient conditions in order to solve
cup in a non-network in a no network but
they start the problem in a fail free
scenario afterwards they started the
problem with the presence of folds and
they found that in order to solve the
problem with the same minimal
connectivity conditions that they found
to solve cup it is necessary to enrich
the system with the stronger sync
synchrony assumptions which are
represented by the perfect failure
detector so in fact what they what they
do is this is to the result is that for
solving the problem in a self-organizing
network dynamic network with the minimal
connectivity requirements it is
necessary to enrich the system with the
stronger synchrony requirements the
problem is that this kind of systems
that we are considering are not have not
synchronous CA are not able to be
implemented in a synchronous system why
not their mother are not synchronous
they dis competes with the
self-organizing a dynamic nature of
these networks so it's not so really a
possible to implement a perfect fellow
detector in this kind of systems and
another point is that they cannot solve
after uniform Africa in fact they prove
it that even with this stronger
condition it's not possible to solve the
uniform version of consensus so the
question that we erase it was is that is
that possible to solve the problem even
the consensus problem in synchronous
systems with the dynamic dynamic
characteristics and mobility and and
self-organizing characters in fact it it
is possible in this is our these are our
main contributions what we do is to try
to analyze the problem in order to see
if it was possible to have more
conditions a stronger conditions
concerning the connectivity aspects and
in order to week the synchrony
requirements are for solving the problem
so the idea was to is it possible to use
the same minimum synchrony requirements
to solve consensus in order to solve ft
cap and in fact we found that it is
possible and we solve this problem with
the minimal synchrony requirements which
are represented by the fellow detectors
diamond as in omega and an interest
interesting side effect is that we can
use all you can serve also the uniform
version of consensus and why we can do
this because we use a constructive
approach in which we reduce the problem
the FTL problem to a consensus problem
which has the same conditions the same
characteristics of a classical consensus
and in that case we can reuse any
classical indulgent conduct consensus
that we are aware and for this we have
we must use in Moscow enrich the system
with more stronger connectivity
conditions and these are represented by
a participant detector of the class que
OS are so let me show you
which is which are the characteristics
of this participant detector so this
participant is sufficient and necessary
to solve ft cup in a consensus in a sink
in a synchronous environment with the
minimal synchrony conditions known so
the chaos as our participant detector it
generates a graph which has the
following characteristics the graph is
connected this is the primary concern
for civilian in in forms of n in type of
reliable a problem and they the graph if
we reduce it to its it k strongly
connected components this graph will
have only one sink and if you consider
to see two components if there is a path
from one component to the other then
there will be K paths from one component
to the other let me illustrate this
better if they the aid of this example
okay so here we have a two or sr graph
this graph has three components and each
one of the component is to is strongly
connected which means that there is at
least two knowledge joint paths between
n pairs of processed into each one of
the components moreover if we have a
path for one component to the other we
will have two paths and we have only one
sink which means that processes which
are in the sink can see themselves but
they cannot see the arrow process in the
in the graph and the other process in
the graph into inside the other
components they can see themselves and
some of the other process in the graph
but all of them are able to
all the processes in the sink okay so
with this graph we can solve consensus
how can we do this so these are this is
our one of our results in fact the
participant detector of the Kos our
class is sufficient for solving ethical
in spite of F crashes and as soon as we
enrich the system with our a fellow
detector a reliable failure detector and
as soon as a majority of process is
correct in the sea so how can we prove
this theorem here to prove it we have to
give you the algorithms that you found
in order to solve ft cap so have you an
idea how to solve this problem how to
solve consensus with the a graph with
this characteristics have you guys any
idea on how to how can I um yeah that is
it i reduced the problem ah
it's easy because I know the other
processes in the sink oh I know up some
of the other process which are not in my
component and for sure I know the other
processes in the sink so I would just
send message to all the process which I
i know and i will have the decision
afterward okay now you can let me show
you the algorithms so for solving
consensus I have to know who is in the
sink I have to dirt on mine who is in
the sink but to dirt am I this I I will
run and collect algorithm which is going
to be to do a sort of breadth first
search in the graph to determine a
maximal set of rich mode notes in the in
the in the graph and after that I will
be able to run any sort of consensus
that that I that I know that I have and
here for what for doing this this these
algorithms running it I will carry the
participant detector and for running the
classical consensus I will carry the
failure detector so let us show you how
can we do the collect so first of all
note that this is a graph which has been
created by a que OS our participant
detector so if you are process p1 for
example the first thing that we should
do is to carry your your participant
detector to know which are the guys that
this participant no nose so in this case
a p1 is going to know the participant
detector is going to return these three
processes okay and this graph if you if
you you see picture for example the
participant detector of p2 knows p 1 p 3
and also before and so else okay so this
is the graph that this we have format in
the system in on the start of the
consensus algorithm so after that what
what process p1 is going to do he knows
that this process knows other guys so he
is going to inquire with this process
about their knowledge and this process
are going to give back their knowledge
so be true is going to say I know before
NP 1 p-3 p 8 is going to say i know p
11pm and p3 know i know p 11 and pee pee
10 and and soils so we do affect a sort
of reddit first search in the graph we
can see that the protocol runs into in
rounds in rounds and in each round we
are going to discover the processes that
are distant at level level are so in
round one we have the process that are
distant at level one in run to the
process that a distant at round at at
two and in round three and so until we
have found all the process that are
reachable in the system so all the
processes are going to do this collected
to run dis collect algorithm so the
process which rg1 are going to see or
two to be aware about the existence of
all the process in the in the graph okay
in all day the other components process
which are in g2 for example they are
only able to see themselves and process
which are in the sink and process which
are in the sink are only able to see
themselves
okay so now we can we can ground the
sink algorithms so at the beginning each
process is going to run collect yes yes
this is not the communication that
that's the point this is the knowledge p
to know that before exists for sure he
knows because before has communicated
with with it yeah but in this model we
click we don't use this information we
could use but we don't to use okay the
only formation that is used that we use
is the knowledge you are right okay but
but yeah in fact if you can see how can
we implement a participant detector for
example if we are in a mobile ad-hoc
Network we can make use of the local
broadcasting facility so at the
beginning everybody is going to
broadcast their identity so I will
broadcast my identity so you know me and
he knows me but perhaps that he doesn't
know me but I don't know that you know
me you see I can I communicate with you
but I don't know if who are the guys
which i received my my broadcast you see
so if you consider this graph before has
given has on the broadcast and get to
know has received it okay and this is a
new direction now because it
you are constructing the graph yes sir
phone before forgive us to deconstruct
the moment you are yeah mark because to
me the everybody answers there no in
this case in this case I just broadcast
my identity okay I don't know who are
the guys who is going to receive my my
identity okay I can receive the idea of
p2 as well but in this case I didn't
receive perhaps I'm not in a good life
of the deterrent taryn you see so I just
yeah that's it I can do this ok but you
are right it there is a correlation
between knowledge and communication
which are we are not exploring in this
mode but we could explore this we could
do this yeah so now to run the sink
algorithm oh you just run call collect
you got a partial view of the system
each one of the p.i process are going to
do this and after that they are going to
inquire again the process that they they
know which are in there if it partial
view so if all of the process have share
the same p i said that you except for
those who are faithful you can ensure
that you have the same view of the
system and in this case you are in the
sink ok you can for sure you can deduce
that that you are in the sink otherwise
you cannot deduce that you are in the
sea notice that if you are not in the
sink let me come back here for example
this process they they are not in the
same
okay and they will have knowledge there
you have the process that they eating
choir in car inquire in each component
will share the same view of it but this
process we are not going to share the
same view of it so which we this process
going to receive at least one response
because they're there is some correct
process here so at least one response
from this process he will receive and in
this case this condition is not going to
be satisfied so the only way for this
condition to be satisfied if it the
place is for the process in the sink
okay so now we are done we can run if we
are in the sink we can run any classical
consensus that we know and for this we
are going to carry the fellow detector
and after that we are just broadcast the
decision to everybody that we know and
finally we are going to decide these are
for the process which are in the sink
the active process those we are which
are passive they are just going to wait
and ask for the decision to Evernote in
its part of you so they are going to
broadcast this enquire and they in their
going to wait for the response so we we
are done in okay so now let us show you
that this in fact this Kos our
participant detector is the is also
necessary to solve the problem so in
fact it it has the minimal conditions
knowledge connectivity conditions in
order to serve
teacup in a synchronous system with the
assumptions that we gave so the
participant detector kos r is necessary
to stop ft curve in spite of efforts so
how can we prove this in fact it's not
so difficult we can make a proof by
contradiction we can assume that we have
an algorithm that solves ft cup without
a graph kos r if the graph is not chaos
are we have two conditions either there
is less than K no gin joint paths
between two components and in this case
if F process crash k minus R can be F so
we can disconnect the graph and we are
not able to together the decision and
another possibility is that there is
more than one sink in the in the days
graph in the system what happens if we
have more than one sink in the system
can we decide with agreement in this
case what will happen can you try to
prove make this proof for me no look
here in this graph I have two sinks okay
and each one of the process in this week
has up a value a violet ball as a value
and on the other seek we have a grim
ball as a value okay notice that for
consensus to be solved we must satisfy
the termination property that will lead
it profit in the agreement profit and
suppose that this processes they did
they are going to solve consensus so
they must satisfy this property so for
the termination problem they are going
to decide one day they are going to
decide suppose that they decided time t1
suppose that this process decided time
to t2 okay for the valid its proper they
are going to decide our value that it is
proposed by themselves okay and here
it's the same but the knowledge graph
right yes they communicate and they know
what they did that they only know
themselves they know they are not aware
about the others here is the same they
only know themselves they are not aware
about the others but the others are
aware about them for example suppose
that these guys communicate with them
okay but they can pass their values but
we are in a proof okay so we are going
to postpone these communication until a
time T greater than t1 and t2 look the
one interest one important thing to note
to know is that we are in a synchronous
system so we don't know when a message
is going to arrive okay the Masters
channels are reliable we have correct
process here the day they are going to
pass their daya value but we don't know
when so suppose that this happens before
the time they decide okay so in this
case they are going to decide because
they have to terminate they are going to
decide for their own Val the green value
because they they have to satisfy the
validity here is the same but effect at
the time they decide the other processes
could not communicate with them so they
are going to pass by their decision or
they are going to decide decide at
different values and the agreement is
going to be violated that's it so with
this we this concludes my talk so what
we do what we have presented this the
necessary is sufficient
conditions in order to solve ft cap in
our work we have investigated other
classes of participant detectors like as
for example decay connectivity which is
necessary and the K strong connectivity
which is sufficient this this
participant detectors gives rise to only
our address with only one components in
this case we have a key strongly
connected component in here we have a k
a connected component so we proved that
it is it possible to solve ft cap and
with the minimal synchrony requirements
which are necessary to solve the problem
in a classical context we also show you
how to solve the problem with protocols
which are indigents so we found a needle
giant protocol to solve the problem
because we reuse classical consensus and
some perspectives of research in fact we
are currently studying the problem of
consensus ft cup in a byzantine model in
which we consider that the peers can be
malicious this is very interested for
for example using this problem in a
peer-to-peer network for solving
problems like as the reputation problem
for example and one of the weakness of
our solutions are of our our algorithms
is that this consensus that we have
proposed are not indulgent toward the
participant detector which means that if
they graph that the system the system
form is not does not belong to the KO as
our class we cannot ensure the agreement
or determination of the consensus of
consensus so consensus is good only if
the graph that is really generated by
the system has the good properties and
this is a real challenge to propose a
consensus in this context which are
indigents toward a participant detector
class another point is concerned the
participant detector how can we
implement these guys in in a practical
situation setting how which are they how
can we compare also this the different
classes to see if they are complementary
etc etc so we have these perspectives
that we are investigating now and this
concludes my talk thank you very much
for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>