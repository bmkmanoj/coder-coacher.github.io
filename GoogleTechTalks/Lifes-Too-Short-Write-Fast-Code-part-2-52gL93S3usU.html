<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Life's Too Short - Write Fast Code (part 2) | Coder Coacher - Coaching Coders</title><meta content="Life's Too Short - Write Fast Code (part 2) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Life's Too Short - Write Fast Code (part 2)</b></h2><h5 class="post__date">2009-03-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/52gL93S3usU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right now I'm Steve Souders and I
work at Google on latency and normally
so I'm starting this series of text
speakers and normally I introduce the
speaker but today the original speaker
is God so I can't introduce him and the
replacement speaker is me so I'll
introduce myself I'm Steve Souders
here's Steve Souders he works at Google
and latency so in this I just wanted to
plug these sessions a few weeks ago the
first speaker that I brought in was John
Resig and last week we had a great talk
from Crockford who's here today it's
nice to see him if anyone has any
follow-up questions grab them left
afterwards and you can see those I
blogged that those videos were up on
YouTube and I blogged about him on the
Google Code blog so you can find those
talks there I've booked two more talks
coming up the talk today was supposed to
be Rob Campbell who helps lead the
Firebug effort he works at Mozilla but
he was coming in from the East Coast and
got snowed in earlier this week so his
trip got canceled so he's rescheduled
for May 1st and and on April 23rd I
think Denny toyour from Yahoo will be
here talking about her decoding for
green project that she's involved with
and as I get new speakers and I'll let
people know so
okay so let's get started so I've been
here about a year before that I worked
at Yahoo and I started the exceptional
performance group there and while I was
there we would help teams analyze their
website and find ways to make them
faster and out of that came these
fourteen rules and we would evangelize
those across the different teams and we
saw significant improvements in in
making in how websites got gots sped up
and so I was able to take those rules
and share them publicly and I did that
in a variety of ways and I still do that
so one was I started this tool called
yslow which is a extension to the
Firebug Firebug extension and you can
download it and run it on your site and
it tells you exactly like it gives you
an overall score and then gives you
details about exactly what's wrong and
this has been much more popular than I
expected I thought we'd get maybe 10,000
downloads and at last count it was about
700,000 downloads a hundred thousand
daily actives so that's pretty cool and
then I helped work with Tim O'Reilly to
start this velocity conference and I
serve as co-chair for that so it's the
conference targeting web performance and
operations and last year was amazingly
successful we had twice as many people
come as expected and were gearing up for
the second one this year is Herbie in
San Jose June 22 to 24 I hope to see you
there last quarter I taught high
performance web sites at Stanford so
it's another way that I'm trying to get
the word out there and the videos from
that class should be available pretty
soon I'll blog about that when they're
up there and at the end of this month
month March 30th right before web - oh
Expo Doug and I and a couple other
author O'Reilly authors will be giving
one-day workshops at
this training set of training sessions
O'Reilly is calling master classes so if
people want to sign up I think it's
pretty small I think it's only like 20
or 30 people can sign up so that will be
March 30th so again trying to get the
word out there about these best
practices and one of the other things I
did was write this book high-performance
websites and it did pretty well not as
well as Doug's book but it did pretty
well and it's still doing pretty well
it's been out for about a year and a
half and in that year and a half I
haven't been sitting idle I've been
continuing to do performance research
and I want to talk about that today and
so of course that research I think the
book has been pretty successful in
getting the word out there so in the
background I've been working on a kind
of follow up book and I just got the
cover shot for that
earlier this week so I think this is a
blackbuck antelope or something like
that I'm not sure I know the greyhound
is the second fastest land animal
cheetah is first but it was already
taken and so I have to look it up but
the I'm guessing this might be third or
top-five fastest land animals so it's
kind of apropos for the book content and
so it's even faster websites we're going
back and forth whether that's one word
or not and here are some of the chapters
that I've written for the book and the
first book was kind of thin
most people like that and these eight
chapters would make a good book but it
would be very thin and one thing that I
think is really important for the next
year to looking at web performance is
JavaScript and I think I'm a really good
hack at JavaScript but we needed better
expertise than that and so I contacted
people I knew who were leaders in
JavaScript and and asked if they would
be willing to contribute to the book so
there's six other chapters that these
authors are contributing and this I
think this is the first time that this
has been announced publicly so Doug is
gonna head right in the chapter on ahx
performance Nicholas Zakas also from
Yahoo an author and
and speaks a lot about performance
javascript is Girt talk about writing
efficient JavaScript Ben and D on the
Ajax scene guys have won creating
responsive web apps
Dylan teaming of site pen and dojo is
going to talk about comment he also runs
one of the most popular content blogs if
not the most popular Tony gentle core
from Google is there talk about beyond
gzipping some accept-encoding trends
that we see out there and the industry
experts on images Nicole Sullivan and
strolling on Stefan off from Yahoo have
contributed a chapter on image
optimization so we're hoping to have to
book out in June of this year and it's
going to be tight we're working hard on
that so today I'm going to talk about
four of these rules I previously talked
about in my first version of this talk
talked about splitting the initial
payload loading scripts without blocking
and how don't scatter inline scripts how
the inline scripts can affect
performance in your page can harm
performance in your page and so I'm
going to do a quick recap of loading
scripts without blocking because that's
a segue into how you couple inline code
with that those asynchronously loaded
scripts and then if there's time I'll
talk about flushing and using iframes
and we're on a tight schedule today
because there's another Tech Talk at
noon exactly so we'll have to finish up
by then so let's get started so why
focus on JavaScript so here are some of
the alexa top 10 u.s. sites and i've
circled the javascript HTTP requests in
there waterfall charts and what we see
is there's sometimes a lot of javascript
or even when there's a small amount of
JavaScript it takes a disproportionate
load time for the of the overall page so
even though they might not be a lot of
requests they take up a majority of the
loading time of the page and that's
because scripts block they block down
parallel downloading and rendering in
the page so here's an example from this
kazillion website that's available if
people want to try it out it lets you
the tagline is because there's a zillion
pages to test so it lets you very easily
with like a page avatar construct
different test scenarios and see how
they work in different browsers so
here's one that has a two scripts at the
beginning each of them take a second to
download and a second to execute and
then an image a stylesheet and an iframe
and we see at the end that the image
style sheet and iframe all load in
parallel and that makes the page load
much more quickly obviously but we see
that the scripts block everything else
in the page while they download and
while they execute this was done in IE 7
but it's true in almost all browsers
some of the newer browsers have this
mitigated but still not totally relieved
and so it's because of this that I think
it's really important to focus on how we
load JavaScript in our pages and that's
where I'm going to dig into so earlier
when I was looking at these problematic
websites in the Alexa top 10 I didn't
show MSN and that's because if we look
at their javascript files they all
download in parallel and so the joke I
always tell at this point and if this is
the exact same slide I used in the first
version of this talk so I apologize if
you heard this joke already so it goes
something like this well you know this
obviously is some collusion between the
IE team and the msn.com team that the
SEC should find out about because
there's probably some secret sauce in IE
that msn.com is taking advantage of but
if we look at their source code we find
that that's not true it's actually
really straightforward they're doing a
technique that I call the script Dom
element approach where they call
document create element with a script so
they get a script tag that's created
dynamically and then they set the source
and turns out in all browsers if you do
this the script will be loaded and
executed but during the download part it
won't block anything else in the page so
you know this kind of piqued my interest
and you know I would listen to
read blog post and talk to developers I
came up with this list of six techniques
that achieve this result of loading
scripts without blocking the page at
least while the script is downloading
while the script is executing the since
browsers are single threaded the UI and
other downloads are pretty much locked
but while it's downloading at least it
would be good if a script didn't block
the page so there are these six
techniques and in the earlier version of
the talk that you can find on the wall
on the Google code blog I went into
detail on each one of these I don't have
time to do that today I'll just show the
result what we find is that these
different techniques have different
traits different characteristics and
there's really no single solution it
really depends on what you're doing or
your scripts on the same domain as your
main page do you want to trigger busy
indicators or not if you have multiple
scripts does it matter if they get
loaded and executed in a particular
order or does that not matter and
depending on those attributes you have
to pick the right technique to use and
so I offered up this flowchart where
knowing whether or not they're on the
same domain whether or not you have to
preserve order and whether or not you
want to trigger busy indicators you can
find your way to the preferred technique
to use for loading scripts so I got done
with that chapter and it was really good
okay now we're about to start the new
part of the talk so I got done with that
chapter and it's pretty good and then I
took a step back and I realized it's
pretty rare that someone has a page and
it has an external script in it and all
they need to do is load that script it's
certainly possible but typically what
happens is you have an external script
in your page and you load it and then
there's some code in your page some
inline code that calls the symbols
references the symbols or functions in
that external script so you have this
dependency order or what I call coupling
between this external script and your
inline code you're in LA embedded script
and so it turns out that if we load this
script asynchronously and we don't pay
attention to the fact that there's a
code dependency we get undefined
Blair's so let's look at an example so I
built this page with all these examples
of these different techniques and and
the impact they have and whether there's
code dependencies between one file or
two files and so here's the default page
so we we have a page that includes so
the this list of examples is very
convoluted so I wrote this as as an
example for this exercise I wrote a
JavaScript file called menu J s and what
it does is you call a function and you
pass in this array of menu labels and
menu URLs and then it constructs the
HTML menu for you right so this is going
to be the example that I talked to as I
explained these different techniques
so how would so this is what a typical
page would look like using this menu
example I would do a script source for
menu J s and then I would construct my
array of menu items and I would call a
knit which is just a wrapper around this
function to call create menu EF WS is
even faster websites so I built like a
little library around this code example
so if we load that page we get get an
HTP waterfall chart like the one shown
down here this page also has one image
in it and because we're loading the
script in the normal way the script has
to load then while it's loading it
blocks the image so then the image loads
so that's making our page slower because
it's loading all these elements
sequentially so we could adopt one of
these asynchronous loading techniques
this is the one that MSN uses the script
Dom element approach so instead of doing
script source equals menu Jes I can call
create element scripts at the source 2
menu Jes and add it to the head
appendchild to head and then I have my
examples and I call my code and and we
get what we want we get the parallel
loading works just fine right so this is
really really awesome there's only one
problem when I load this script Dom
element
in Firefox everything works the menu
works but when I load it in IE i get
undefined symbol errors and that's
because the script dom element approach
preserves the order of external scripts
and inline scripts in firefox and some
other browsers but not Nighy so this is
the exact kind of context for the
purpose of this talk of this chapter is
it's great to load your scripts
asynchronously but if you have code
dependencies either with other scripts
or embedded scripts you've got to figure
out a way to couple those together so
that you don't encounter this problem
and so we have these different
techniques for loading scripts
asynchronously but the way that they
behave in the way that you couple them
can vary and have different performance
characteristics so I want to talk about
about those so let's see here's the all
the different asynchronous loading
techniques and what we see is there's no
technique that preserves execution order
and also doesn't block downloading
there's no technique that works in all
browsers in fact there's no technique
just out of the box that will work in
any browser except for script Dom
element in Firefox so if you just use
these asynchronous loading techniques
and you have this kind of coupling
dependency if you don't pay attention to
what I'm about to talk about you're
gonna get undefined symbol errors so
let's dive into these coupling
techniques there's five of them and
we're talking about each one of them
really quick so hard-coded callback
these kind of go from worst to best
so hard-coded callback so I have this an
it function that kicks off the menu
creation so what I could do is I could
just create my array have the admit
function and I could dynamically create
the script using the script Dom element
approach and in that script menu jes at
the very end I could call a knit and so
that's going to call back into this
function that I built and create the
menu and it all works really well but
it's not very flexible like if I change
the anit function
to be due menu then I have to go change
that external script and also sometimes
you don't even have the ability to
change the external script suppose
you're using jQuery and the anit
function is calling some jQuery symbol
to create a jQuery dynamic menu or
something else well unless you want to
host your own version of jQuery you
can't add append a function to the end
of the jQuery j/s so this technique
works but it's very kind of hardwired so
you could tie something to the window
onload event so what would happen is you
could load your script asynchronously
and after it had loaded and everything
else loaded in the page the onload event
wouldn't fire and that's where we could
tie in this case the anit function so
here's what the code looks like
basically I'm going to here I need the
script Dom element approach doesn't
block the onload event in all browsers
so I'm switching to a different async
approach I'm using the iframe approach
so basically this menu instead of menu
Jas I have menu dot PHP which has all
the JavaScript inside it and so using
this technique across all browsers will
block the onload event until the
JavaScript is loaded and executed so now
I can load the JavaScript this way the
onload event fires and down here I
attach there we go down here I attach
the anit function to the onload event
and have it work across browsers so this
works and it's not too bad it's not that
heavy wait that's not that complicated
but if you have a lot of stuff in your
page like suppose you have this
asynchronously loaded javascript and
then you have 40 images that get loaded
after that it's going to take a long
time until the onload event fires and so
if this javascript is doing you know
constructing some d HTML controls in the
page those aren't going to be available
as quickly as they could be and so
that's kind of the main downside of this
one is you're not getting that
javascript an it function or bootstrap
code
getting called as quick as you could so
you could do a timer so what I'm doing
here just for space reasons is I'm kind
of minimizing the repeated code like
creating the menu object and stuff like
that and I'm just trying to highlight in
bold the code that's changing for each
of these different techniques so in this
one I start a timer and what this
external script is gonna do one side
effect is it's going to create this even
faster websites object right
so in this timer loop I can just check
for the existence of that symbol and
until it exists I'm just gonna keep
looping through this timer calling back
to the code and then eventually when it
does exist I'll call the init function
so this works okay but there's a little
bit of overhead with this timer and if
you make the interval value really small
that overhead will be worse if you make
the interval timer too big we kind of
have the same problem as we did with
window.onload the codes not going to be
called as soon as it could ideally we'd
like the anit function the inline code
to be called as soon as it possibly can
as soon as the symbols on which it
depends are available and with this
timer on average half the interval value
will go by before will be a missed
opportunity or a delay between when this
bootstrap code could be called and
there's a little more maintenance like
if I change the the name of the object
that contains this new code then I have
to change this harnessing this coupling
code so there's it's not huge but
there's a little bit of maintenance
involved probably the best one is script
onload and this is probably what most of
you we're thinking from the beginning
like oh well the way to do this is
script on load so there's a little bit
of variability between browsers you
might have to do the actual scripts
onload handler or you might have to do
the onreadystatechange if you do both it
will work in all browsers but in Opera
10 or 9 and 10 both of them will be
called so I have to add this onload
on flags so I make sure that my
init:function doesn't get called twice
that's just for Opera that I do that so
this works this works across all
browsers it's kind of optimized as soon
as the menu J s is loaded the anit
function is called so there's no kind of
missed opportunity or delay it's a
little more complicated it's going to be
a little bit more code number of bikes
that you have to add to your page but
it's not huge so this is really kind of
the most likely technique that should be
used but I wanted to mention one more
which I when I first read it it just
really intrigued me and I think it's
really elegant it comes from John Rezac
he calls it the degrading script tags
approach and his motivation was
sometimes you have an external script
and he has some inline code and if the
external script fails sometimes that
inline code will still execute depending
on your browser and browser settings and
you'll get undefined symbol errors
because guess what that inline code
depends on the symbols from the external
script that failed to load so his idea
was to do something like this I've got
my I've got my script source called
calling a JavaScript file in this case
you see I changed the name a little bit
you'll see why in a minute and between
that open script tag in the close script
tag I actually put the code that depends
on this script so this is really really
awesome now the way that I have to get
this to work is it turns out you know
this is really really awesome but it
actually doesn't work in any browser
there's no browser that's built to work
this way to like pay attention to the
code that's within the script blocks if
there's a source attribute being used
but it turns out it's really easy across
all browsers to add that and the way we
added is by oh so this is nice because
it's cleaner there's only one script tag
instead of two script blocks it's clear
it's very clear that this code has a
dependency on menu J s and it's safer if
the external script fails then the
inline code won't be called but it
requests since it doesn't work in any
browser you have to do a little work and
it's not that much work and it's not
that complicated
so at the end of menu J s so that's why
I renamed it to menu degrading J s so at
the end of menu degrading J s I
basically just do this loop I get all
the script elements I loop through them
until I find the script whose name is
menu J degrading J s and then I look at
its inner HTML property and that's
basically going to be inner HTML is
going to be this code right here and I
just eval it so if so let's look at so
let's look at this as an official
technique here's how we would use it in
our example so it's his example he
doesn't talk about using this with an
asynchronous loading technique but
that's what I'm trying to get across
here so how do we combine these two
let's load this menu degrading J s
asynchronously but have this pattern
where the JavaScript to execute is
inside the script block so here's what
it looks like I have a script one script
block I'm gonna load the script
dynamically doing script on element but
what I'm gonna attach to that script Dom
element that I create here is called dom
script I'm gonna set its inner HTML or
text the bending opera's an exception
here so I have to set one or the other
and I'm gonna set it to call a knit and
now if I add that code that you saw on
the previous slide to the end of menu
degrading Jas it will find this call to
a knit in a valid and now we've done
this coupling in what I think is kind of
an elegant very flexible and also very
cool way but obviously this pattern is
not that well known and if you have a
third party script like I mentioned
before like jQuery Jes this wouldn't
work but this is a kind of pattern you
could add that that block of code at the
end everyone can start adding this to
the end of all their scripts and if we
did that then someone would have the
option of adopting a pattern like this
and if there is no code attached to the
inner HTML of the script element then
nothing happens there's no harm
but by adding that it opens up a lot of
flexibility for how people can integrate
or a couple code with external scripts
so I think it's kind of cool but I
recognize that it's not that popular and
yeah question
the loading doesn't start happening
until you do app in child that's why a
pen child is last okay
so that's pretty straightforward right
you have these different techniques
depending on your situation or
preferences you could choose one of
these coupling techniques or the other
but this was also a maybe simpler
scenario I had one JavaScript file and
and some inline codes that depended on
it what if I had two JavaScript files
that that the second one dependent on
the first one and my inline code
depended on both of those or at least
the second one how do I handle that and
it turns out that's more complicated and
it's almost unsolvable if the external
scripts it's unsolvable to achieve our
goals
if those scripts are on a different
domain than the main page so let me walk
through that now so the two techniques
that you can use to solve this is manage
the xhr if you're on the same domain or
a combination of the script Dom element
and dock right approach if you're on
different domains I didn't see Doug
wince when I said document dot right so
let me change my my compelling example
so instead of having just menu Jes I
have this new file menu tear Jes and
what it does is it creates it's kind of
hard to see but this is now like a
grouped menu I didn't go to all the work
to make it like slide out cascading menu
but this is like a concept of a tiered
menu and so menu TAS depends on menu Jes
so in my code I have to load menu Jes
menu TAS and then I have to construct my
menu object array and I have this an it
function I forgot to call an it here I
would have to call an it at the end and
if we look not surprisingly we see that
each of these scripts block everything
else in the page so menu Jes Lowe's menu
tier Jes load
and then the image loads so we get a
longer loading page and what we want to
do is we want to get a page like this we
want to get a page where everything's
loading in parallel but we don't get any
race condition or or undefined symbol
errors right so I have this I extended
the even faster websites functionality
to have this load script xhr injection
function so this is the managed xhr code
that i was talking about it's using the
xhr injection acing technique and let's
look at that function so so xhr
injection works it makes everything load
in parallel but it doesn't preserve
order so the managed xhr the managed
part of that is the part that maintains
load order so how do we do that here's
the code and when the book comes out
I'll make all this available on my
website so you call this function you
give it the URL to the script if you
want to have a callback and onload when
this script loads you pass in that
function pointer and you pass in true or
false if you're going to load multiple
scripts this way does the order need to
be preserved so the function is called
there's this queued scripts object
queued scripts array and if the user
said order matters then we add a another
element to that queued scripts of array
and we we create a unready state change
function for this xhr and when the xhr
reached ready state for basically the
xhr is done the javascript response has
been returned we go through and if order
matters we add this response text to the
element in our queued scripts and we
call this inject scripts function which
i'll talk about in a minute and if order
doesn't matter then when we get the
response back we basically just eval the
response and call the onload
associated with it so but we're kind of
in this scenario I'm kind of focusing on
a dependency order between menu and menu
tier J yes so we do care about order
let's look at what inject scripts does
again pretty simple I use a total of 100
lines of code or or less it just
iterates through that queued scripts of
array if it finally encounters a script
that hasn't been a cute script that
hasn't been processed it's it sees if
the response has been received yet if
the response hasn't been received we
have to kick out of this loop because we
have to evaluate the responses in order
but if the response has been received
then we can evaluate that response if
that cute script had an onload callback
will call that callback and we'll
proceed to go through because maybe we
got some other responses for scripts
after this queued script they came back
earlier because they're faster or closer
or smaller or whatever and they've been
blocked by this one that we just eval so
we'll evaluate any others that are still
in the queue so this is pretty cool it
preserves the order that the external
scripts are executed it avoids any
blocking behavior in the page it's a way
of coupling inline code with scripts
external scripts that they depend on it
works in all browsers and it doesn't
work for scripts that are on a different
domain so this is kind of problematic a
lot of us are probably loading scripts
from the Google CDN Ajax libraries or
Yahoo api's com or we have a CDN service
that is a different hostname than our
main page so we have to deal with this
other scenario where scripts are on a
different domain than the main page and
unfortunately here the news isn't good
there aren't any techniques that do all
three of these things that we want we
want to preserve the action execution
order of external scripts we can't just
load them asynchronously and have them
evaluated in any order in a
non-deterministic order the scenario
we're talking about is where there's a
dependency order
and we also want the scripts to not
block each other and we also want the
scripts to not block other resources in
the page and as we can see as we get you
know the most important one is
preserving order you have to preserve
order or you're going to get errors in
the page and as we work from left to
right in this table we find that there's
fewer and fewer options available to us
oh I didn't go across it there at the
bottom Firefox and opera can use the
script on element approach and that
works pretty well especially in Firefox
we achieve all of our goals in IE I
found a bug with script of fur that I'm
still waiting to that I submit and I'm
still waiting to hear back on so script
of fur fry he looks like it might be the
best but until I get a response about
this bug I don't recommend it and it
doesn't help for Safari in chrome so for
IE fallback to document dot write and
safari in chrome you really for Safari 4
and chrome 2 they load scripts and
asynchronously regardless in most cases
so you really don't have to do anything
or if you use document dot write it's
gonna be fine it's going to be the same
as if you did nothing so here's what
load scripts looks like so you you call
this with an array of script URLs you
want to load it does a first pass to see
whether or not they're on the same
they're all in the same domain or not
and based on that it will choose the
right function by default that's going
to do xhr injection but that presumes
that they're all in the same domain so
that if they're not on the same domain
if they're on different domains then
depending on your browser is gonna do
either script on element approach or
dock rate and then it will loop through
all those URLs and load those scripts so
depending on whether they're on the same
domain and what browser you're in you're
going to get either all of these goals
met or some mixed bag but all of them
will preserve order ok so wrapping this
one up about coupling external scripts
if you have a single script there's a
lot of room for improvement you can use
script dom element it works across all
browsers you can use one of the coupling
techniques i recommend
download and you can we really don't
care about preserving the order of
external script because in this row
there's only one script and scripts
aren't there aren't multiple scripts in
the page so we don't have to worry about
that and across all browsers script Dom
element will let other stuff in the page
load in parallel so if you have a single
script whether it's same domain or not
it doesn't matter script Dom element
works for both that's a pretty easy
scenario to solve what if I have
multiple scripts in my page but they
don't have interdependencies again easy
problems solve use script Dom element
and we achieve all the goals that we
want if I have multiple scripts that do
have interdependencies and they're on
the same domain as my page it's a little
more code to write and to download but
we can solve that with managed actually
char and achieve all the goals that we
want the most problematic is if you have
multiple scripts that have inter
dependencies and they're not all on the
same domain as the page it's kind of a
mixed bag there's code that can achieve
all the goals or some of the goals
depending on the browser okay
so let's wrap it up with a case study
I'd like to always get back to real
world I think Google Analytics is a
perfect case study for this so Google
Analytics is a JavaScript file that's
really popular there's a lot of websites
that use it and it's the perfect example
of something that can get loaded
asynchronously there's really nothing in
the page that is depending on Google
Analytics a yes to get loaded right I'm
not saying that we that users don't want
to get this Google Analytics information
but there's nothing in the page like
drawing the navbar or something like
that that requires it so this is the
perfect opportunity to perfect an
example of a file that should be loaded
asynchronously if we look at the pattern
that's recommended on the Google Help
Center for loading this we see it uses
the document write script tag approach
and this isn't the optimal approach that
could be used because document dot write
blocks all the other resources in the
page so they also advise that you put
this at the very bottom of your page and
if you do that then the impact will be
mitigated but in looking at the top
examples of people using google
analytics I find that most of them are
putting it at the top of their page
that's just where people are used to
putting code like this up in the head
and when they do that and they use
document.write
is blocking all the other images and
stuff that are below it in the page the
main content of the page so it turns out
when I poked around and now Alex Russell
from dojo Fame is working here at Google
I think he mentioned it to me that
there's this dojo urgent module that
helps people address this these issues
and load Google Analytics more optimally
and if we look at that code oh so I
didn't put in a highlights here but
basically you can call this function to
load Google Analytics and it's gonna
basically do the script Dom element
approach it's going to create a script
element and set the source and then what
it does is the coupling technique it
uses is the timer technique so it's
really cool to me to see this research
that I've done and I've named these
different techniques to actually see
people who have adopted these techniques
not because I named them but they're
actually using them because this stuff
makes sense to do for performance so
they're using a timer technique and that
timer technique basically checks to see
if the underscore g80 symbol exists if
it doesn't it just calls the timer again
if it does then it calls got GA and
gotcha a instantiates the google
analytics tracker object so this is a
nice optimization if you use this even
if you put this at the top of your page
it's not gonna a lot block any of the
other elements in your page so it's a
nice optimization I emailed them and and
mentioned that the script onload
approach would be a little bit better
and they might have actually changed the
code by now so that's kind of a
real-world example of this stuff I've
been talking about ok so that was huge
and long I find presenting that one
chapter to be very difficult and I hope
I was able to do it in a way that you
could follow and see some takeaway
there and I think one of the hardest
things about presenting that is there's
no single solution right if if we try to
find one solution that's going to cover
all of those cases then we have to take
the lowest common denominator one and
there are a lot of scenarios in fact I
would say a majority of situations where
that lowest common denominator solution
is inferior so it's really a situation
where you need to know the context that
you're in and pick the optimal technique
for that context so you might have to
change things depending on you know this
page or that page but if you want
optimal performance that's what you're
gonna have to do so now that one was
really really long like that was 20 or
30 slides so I've got like six more
slides to do the next two rules and then
we'll be done so hang hang with me here
so I wanted to talk about iframes
iframes get used you know a fair amount
across the Alexa top ten I think there's
four or six sites that have iframes in
it and you know the first thing I
mentioned is that iframes just a priori
are really expensive there one or two
orders of magnitude more expensive than
any other Dom element you can think of
and so you just need to be a little
cautious like don't go willy-nilly about
using iframes everywhere if you're only
using one or two this extra expense of
like 10 milliseconds just to create the
Dom element isn't going to be that big
but if you're doing like in these I just
did a hundred of these elements I tested
it across all these browsers and like it
was measurable I mean that's pretty
amazing that just a hundred was
measurable to this degree so I mean they
have impact you didn't want to be a
little cautious about you know just
using iframes everywhere that's why I
say use them sparingly but iframes also
have other impact on the page they block
the onload event of the page and we want
the onload event of fire as quick as
possible for multiple reasons when the
onload event fires it says done in the
status bar and other busy indicators
turn off in the browser so it gives the
user a perception of a faster page as
opposed to those busy indicators
lingering on while you're loading an ad
or Google Analytics or something else in
an iframe so
we don't want to block the onload for
that reason for the feedback it gives to
the user also still a lot of time people
associate some user behavior UI behavior
to the onload event so the you know
predominant one you'll see is focus will
be set to the user name field of the
login form when unload fires and I'll
know about you but I'm always like
already clicked in the user name field
type my username tab to password I've
started tapped typing the password the
onload fires it sets the focus back to
the username field and I'm typing my
password and clear text while people are
looking over my shoulder or even worse
like I'm up in front of doing a demo and
now people know my password so we still
see that behavior so since people are
doing that we want that onload event to
fire as quick as possible so that
whatever that UI thing is that's
happening it happens really quick so now
on some sites where I know this has been
a problem I sit and I wait till the page
is fully loaded before I start logging
in and that's annoying so it turns out
iframes block the onload event and and
everything in the iframe so if you have
JavaScript or images in the iframe the
parent onload event won't fire until all
that stuff is downloaded there's a
simple workaround unfortunately that
only works in Safari and Chrome and
that's to set the iframe source
dynamically as shown in this example so
I haven't done enough research to know
whether just empty string or about blank
is the best value but anyway you create
an iframe that doesn't have a document
URL a source and then you assign it
dynamically and if you do this in Safari
and Chrome it won't block the onload
event from firing the other thing is not
so much how I frames impact the page but
just to make people aware the page can
affect the iframe so we know that
scripts have this blocking effect right
so here I've got waterfall charts for ie
Firefox and then Safari or Chrome and
opera all behave pretty much the same
and no surprise if I have a page that
has a script that loads an iframe and
that iframe has some stuff in it the
iframe and that stuff are all blocked by
the script right no surprise
but this is pretty surprising if I have
a stylesheet below the before the iframe
in ie and Firefox that iframe is blocked
by the stylesheet now normally style
sheets load in parallel with everything
else in fact I think in the iframe as an
example I put an image a stylesheet and
a script and you see that they all load
in parallel but there's just something
weird about ie and Firefox that they
will not start downloading an iframe or
the iframes components if there's a
stylesheet before the iframe so if you
have important stuff in your iframe you
might want to keep this in mind and then
it gets even worse so you would think
like a reaction to this might be to move
the stylesheet below the iframe and if
you do that still in Firefox even though
the stylesheet is below the iframe in
the page it will block the iframe so
it's just something to keep in mind and
another question I get asked is you know
in in mainstream browsers you know
mostly ie6 97 we only get 2 connections
per server and so if I open an iframe
can I get more parallel connections and
the answer is no so here's an example
that has a page that loads 5 images and
an iframe that has 5 images all in the
same domain and we see in IE 7 that
they're still blocked 2 - 2 - so you
don't get any more free connections in
iframe and its parent share the same
connection pool ok so that was high
frames that was pretty fast I will do
flushing really quick so here's a page
that contains an image and image and a
script right and this is the way it
would normally load but if you flush
your document early you can get it to
load like this so obviously it's a much
fat it's a much faster experience so
what does flush the document early mean
so in PHP and in most other languages
like Python Ruby pearl there's a flush
function or something with flush and
Perl I think it's Auto flush or
something like that and it basically
means so typically when some back-end
engine is rendering the page it's
sending stuff to standard out and when
you call flush if it and but it gets
depending on the server and
os the stuffin standardout doesn't get
sent as soon as it arrives you wouldn't
want to be sending packets that had 8
bytes or something in it so it gets
queued up depending on the system that
you're on and then eventually when it is
done or it reaches a certain size it
gets flushed and sent to the client but
you can manually cause that to happen
that flushing of standard out by calling
this flush function and so that's what
happens in this example this is one of
my examples just after I created the
HTML document and put in the tags for
the image and the script I call it flush
and then I went off and did something
that took one or two seconds to execute
but since I flushed it that got sent to
the browser and the browser even though
it doesn't have the full document will
start acting on it but there are a lot
of gotchas I find when people try to
implement this they say it's not working
it's not working so just a list of some
of these here if you're using PHP you
want to check if you have output
buffering turned on and if you do in
addition to calling flush you have to
call OB flush and some other OB
functions it's fairly it's there's a lot
of documentation on it I won't say it's
well documented you have to make sure
you have Trent transfer encoding chunk
turned on and most web servers will do
this for you automatically but one thing
is this only works kind of pretty much
in HTTP 1.1 so if for some reason your
server is 100 you're not gonna get the
advantages of this so these are all
things I've bumped into people they go
it doesn't work I go well do you have
output buffering on they go oh yeah I do
I go then you've got to call the old B
function so we're you using some server
that downgrades to one out yeah I am
okay well you can't do that you need
transfer encoding chunked so the next
one is in Apache if you have gzip turned
on there's this 8k deflate buffer sighs
thank you Steve lamb for finding that
one and you have to exceed that or
change the setting to be less than a K
otherwise it will store up that amount
of output to G to do the gzip
compression but you can achieve and and
that happens for you with Apache two to
eight and onwards but earlier than two
to eight you're gonna have to muck with
that setting another one is right behind
a proxy again people say flushes
working I say are you behind it you know
are you have output buffering on No
are you gzip II know or or I'm on two to
eight do you have transfer encoding yeah
I do
are you behind a proxy yes I am okay so
that's what's happening not all proxies
do it but squid does it and it's one of
the most popular proxies out there and
antivirus software do it they might
queue up the response and not send it
until get they get the whole thing and
then also in Safari even if you flush if
you don't flush at least 1k of content
and in chrome its 2k even though it's
flushed it won't draw anything it won't
handle it so you have to exceed that
amount and for real-world pages that
might not be that difficult to get one
or two K if you have like the whole head
and maybe a navbar and then one other
gotcha is keep in mind that for mains
for mainstream browsers mostly ie6 and 7
you only get two connections per server
and most of the time we only think about
that in terms of the resources in the
page but in this case the document
itself is making a request so here's a
case where all of the resources in the
page no not all of them the first three
well that HTML document and then the two
images are all on the same domain and
because they're on the same domain the
third the the third requests an image
gets blocked by the HTML document itself
so if you're doing flushing and you have
more than one resource that's on the
same domain as the main page you're
gonna see that it gets blocked and you
might want to move it to a different
domain okay so I gotta wrap up really
quick focus on the front end run why
slow here are some rules about
JavaScript I just went over some more
speed matters it's really important we
have some stats have been put out about
how it impacts business metrics and so
that's really important it also impacts
your operating expenses like hardware
and bandwidth here's a chart from Bill
Scott at Netflix this point is where
they turned on compression and you can
see the outbound traffic from their data
centers dropped in half so you can save
money that way so if you want to have a
better user experience
more revenue reduced operating costs is
pretty clear what we need to do we need
to have even faster websites so that's
it and I have three minutes for
questions are there any questions yes
now I actually think doing this would
make it less so the question was if you
do the Google Analytics recommendation
of loading it asynchronously do you run
the risk that like if the user is
clicking through the page really quick
they leave the page quickly you won't
get the beacon and it's actually just
the opposite the recommendation for
Google Analytics is to put it at the
bottom of the page so by the time it got
to the bottom of the page and actually
did that document dot write the user
could have clicked off by doing that
this asynchronous way you can you can
feel okay about moving at Google
Analytics to the top of the page so it's
actually more likely that the Google
Analytics will be loaded sooner and the
beacon will fire sooner so you'll have
less drop-off
the question was what's the likelihood
that future browsers will do the script
tag better so that we don't have such a
performance impact and we're already
seeing that in ie8 Chrome to Safari 4
and in the latest Firefox 3 1 beta 2 and
but they still have some limitations
like in IE 8 it will load all the
scripts it will download the scripts in
parallel but nothing else so if you have
script image those are still loaded
sequentially so that just has to do with
how far ahead they're looking in the
stream to decide what things that can
load in parallel and with more work they
could look further in ahead for the
stream and I forget what it is Chrome or
Firefox
they don't recognize iframes so they
recognize images as something that can
download in parallel but not iframes
they could add that logic so we're
already seeing that with the next
generation of browsers and it will
continue to improve so it's true a lot
of these techniques are mostly relevant
as long as IE 6 &amp;amp; 7 exists which is
going to be years so i have at least a
few more years of relevance last
question was that libraries could add
extra code at the end that introspects
on the page into which they have been
embedded so in general that kind of
experience ends up coming back to bite
you because you're never able to
anticipate well how your library is
going to get end up getting used and I
was not able to follow the example
entirely but one thing that did occur to
me is if you as a result of libraries
adopting that your suggestion was that
well this has no this is no
it does have an effect because
previously a div that had an ID that
this library looks for just by looking
at the HTML you you knew you were safe
now suddenly as a result of just
choosing it a weird name for a div you
know some piece of code could change the
behavior of the page in light of that
would you want to change your suggestion
about where the library should adopt
this behavior so the question was adding
that little snippet to the end of every
script in the world might lead to
unexpected behavior and I don't think
that's true and it was a kind of
complicated example I went through it
quickly so you and I should maybe talk
some more but if you in the code it
actually isn't looking at IDs it's
looking actually at the actual name of
script files and so it you know the the
ID of a div in the page isn't even used
in that code and and since right now
there's no browser that supports
executing JavaScript within a script
block that has a source my guess is no
one's doing it so you could only have
this happen if someone put code in a
place where they're not putting any code
now and I think the only reason they
would do that is they expected or hoped
that the library would support that
technique but we could talk more about
that also all right thank you very much
and we'll see you at the next one of
these thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>