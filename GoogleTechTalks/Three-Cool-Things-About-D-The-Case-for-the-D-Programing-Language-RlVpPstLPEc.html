<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Three Cool Things About D - The Case for the D Programing Language | Coder Coacher - Coaching Coders</title><meta content="Three Cool Things About D - The Case for the D Programing Language - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Three Cool Things About D - The Case for the D Programing Language</b></h2><h5 class="post__date">2010-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RlVpPstLPEc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the Tech Talk today like to
introduce our speaker this is Andre
Alexandre skew I got it right cool
he's here to give a talk on the
deprogramming language
thanks Benjamin it's a great honor to to
be here thanks very much Benjamin for
inviting me and thank you all for
attending I have to admit I was quite a
bit insecure about you know my threshold
was six people and I'll today exactly
why I thought if six people I'm not
going to show show show up here it's
gonna be an embarrassment I'll tell you
exactly why right now I have this food
locker here alright so I have this book
and this book has no author on the cover
right has no author so that what happens
is in world there are eighteen hundred
and twenty four copies of this book
without an author on it the rest do have
the author name on it and one hundred
eighteen hundred twenty four plus the
six I have in this bag and I'm going to
go away six books for the six most
embarrassing questions that you're going
to ask alright so get ready embarrassing
to me all right
and I'm going to keep this microphone on
hand so if you have questions so I'll
give it to you alright I've here in the
past talks about sort of the dog and
pony show about Dee and I changed my
mind this time around I decided to go
with three cool things about it I'm sure
many of you I've heard of Dee to some
extent most of you are going to find it
familiar if you use your C++ for Java
and therefore I'm not going to go
through the sort of garden variety of
features that the offers instead I'm
going to focus on three things first off
how many of you are using for example
C++ in there
they do they work all right Python could
be a you know yeah could be an
intersection there okay
other languages all right what languages
talk to me
Java ok Java so let's let's take a vote
on Java all right perfect perfect Erlang
anyone Erlang all right so what's the
deal with D so this is starting to play
here all right so the programming
language is landscape as of 2010 is has
a lot of languages plastered all over it
there are systems languages their
productivity languages their imperative
functional declarative languages they're
you know that there's this generation
system that you know a fourth-generation
language or whatever didn't really catch
on I heard of it in the eighties but
it's since - nobody cares about it and
there's compiled versus interpreted
versus children languages and so on
now part of the crater has been charted
and there's very nice this very nice
chart made by made by two Russians in
which there's a C+ C++ lands with all
this good stuff here and I turn out to
have a castle over there
she's a very convenient I also have a
ship Loki and there's also you know the
the boost territories and there's a you
know trying called Mita and all the
skill all this fun stuff I find the
chart very very nicely done and very
funny but in the middle of this chart
there is a Sahara sized desert around
the crossroads of a few days it errata
that nobody nobody is occupying right
now so we have this program P a
landscape that has a huge unequal
unoccupied area and a huge an occupied
area is at the intersection of the
following good things to have the good
things to have art we want high
efficiency consistence level access we
want huge modeling power because you
have difficult problems to solve we want
simplicity one productivity and
one called correctness and last but not
least one correctness of multi-threaded
and concurrent and parallel code so the
question is which language occupies this
area
it's no-man's land really so traditional
what languages have done they focus on a
few of these and try to kind of keep the
others in control like for example I
don't know Python is a beautiful
language so I think it ranks high on
simplicity ranks high in productivity it
doesn't run ranked very high on for
example efficiency or assistance level
access and I'm afraid it doesn't rank
higher on parallelism I think does
Python still have done one global lock
that everybody locks ok I think that's
terrible right all right
C++ is the undefeated ruler of 1 &amp;amp; 2
high efficiency systems level access
it's stronger on on 3 than C has high
modeling power but it fails miserably
after that not simple not productive and
code correctness is at least 10 years so
D takes a holistic approach towards the
centroid of this territory so what we
want to do in these you know what so
there are these wishes that everybody
could have about the program language
and essentially we want we don't want to
focus on a couple and forget the rest
what we want to do is try to
holistically approach everything and try
to find the best compromise that are
contradictory to some extent and I think
of this model empowering simplicity
don't go well together right
you know don't sit well right
all right a few basic things about D
that I think are interesting yes
question why doesn't model in power and
simplicity go well together
why does it not well together in my
opinion I think a language was good
model in power will have to have quite a
features what people call features there
they have to have good privacy control
for example you know good visibility
control like private or whatnot they'll
have to have precise interfaces a very
elaborate signatures and all that stuff
and every every single bit of that that
makes it less simple so it's going to
erode into its simplicity I do agree
that there is a sweet spot in which
model important simplicity kind of go
together but if you want to model really
precisely things you're going to have to
complicate the language thanks all right
so he does not replace these memory
model which is a bit surprising because
these memory model is pretty low-level
in what is this memory model how would
you characterize it you know where the
crap is right you know where stuff is
right so you know where objects or
things sit in memory I do you have bit
level access if you want to those you
can cast a void start to an integer and
back and nobody is going to beat you to
the bra right so these approach is to
build on top of C's memory model ad
structure on top of a loosely structured
universe and by that I mean essentially
you have the similar model which is a
rock bed of everything and on top of
that we build the programs which have
safety and forced by the compiler that
you can occasionally break and go down
to see as a proof essentially in C you
can use malloc and free if you so want
he can use malloc and free essentially
all of C standard library you can even
use allocate a non-standard
function for allocating stuff on the
stack which is very useful sometimes D
has a garbage collector which is faster
but not required for D programs to run
so essentially candle daddy program that
does not make any use of garbage
collection but for most applications of
course you would go with the program and
you would use the law garbage collection
because it's very convenient very safe
these approach to safety is layered and
what I mean by that is that you can if
you can define a design time how safe
your program want to be and there's
three levels one is safe
gonna be safe under inch plate safe I'm
going to use the garbage collected
memory I'm going to use only I'm never
going to cast a pointer to an integer
and God forbid back right I'm never
going to do such stuff and a compiler
enforces that stuff the second is our
trusted trusted means I'm up I'm a
writer and I want to break the type
system inside the library
however the interface to my library is
safe what's an example of a trusted
function trusted it has to break the
type system however it it offers a safe
interface a logue garbage collectors a
low allocation primitive right so the
garbage collector is going to inside
break the rules quite a bit it has to
make anti-memory look like it's type
tied to memory to look like it's not
piped but outside is going to be
allocated for me the subject and the
garbage collector does have a safe
interface incidentally malloc itself
could arguably be called safe but free
is not so there is an asymmetry there
which is rather interesting
alright now he has and you know there is
this all-out war on on incorrect
programs and D has a principle however
practical approach to correctness what
when I say principle yet yet practical
I'm saying he does not get you know too
serious about itself when it comes about
about checking what happens that it
could be you could be easy erring on the
on the principle side and will become
also principled and these are half of
the interesting program to route to
compile and last but not least the
fastest threading without races actually
memory sharing
and threading and message passing
without racists guaranteed and I'll give
more detail about that in a few minutes
the compilation model is these a
compiler generates native code has
context independent declarations unlike
in C++ where essentially every line of
code depends on everything that's above
it right so in India essentially every
declaration is context independent and
that has two good consequences surprise
number one it's the top-level
declarations are entered in parallel by
the compiler and could be actually
literally paralyzed so there could be a
parallel compiler could be written that
compiles every single declaration on a
separate core for example that hasn't
been done yet
we're getting close to that there's
other parallelism in the D compiler
that's that's being used the reader is a
human reader doesn't need a lot of
context to understand you know a
function for example there's minimal
context dependence there and each
character is be looked at once and each
symbol is wrote at once when you compile
a program
Zehra know how many times the character
needs to be looked at by the C++
compiler so each character in a source
file how many times does the compiler
have to look at it yes depends on how
many includes you have not quite so I'm
saying a given character in a in a C
program in a C++ program how many times
does the compiler need to inspect that
character depends on a compiler give me
a upper bound in a lower bound
all right so the upper bound space right
if you implement a comparable standard
which has a number of passes seven times
so if go by the other you know there are
processing steps and whatnot and if you
go through it it's going to be seven
times you got a look at each character
ease
this is an excellent point yes all right
I'm I completely agree so if you have
many includes essentially each character
needs to look be looked at even more
especially if your compiler doesn't have
the include guards optimization all that
good stuff but even without taking
included into account
seven times would be the upper bound and
the lower bound the best compass basic
process compiler know of looks at each
character three times they couldn't
bring bring it down there's a digital
mask umpire they couldn't bring it under
three no heart no matter how hard they
tried so D was engineer of course by
Walter Brite himself he got tired of
that so he said you know what I'm going
to build a language in which each
character must be only looked at once
and each symbol needs to be loaded once
this is the fastest language to compile
by a large margin of all language they
know by a very large margin this is a
complete GameChanger
so what's happening is that essentially
it comprised four two orders of
magnitude faster than C++ and it
produces native code circuit of the
program it's a very large program and
you know you say I'm going to change
something and before you blink it's
being compiled right and that's great
because it completely changes the way
approach approach pouring you don't have
those there's a joke with MapReduce and
people kind of swatting away all that
good stuff
the original joke in xkcd what about
compiling or compiling the managers like
ok yep you're compiling an old respect
for that that's not going to be a good
game with D turns out all right let me
talk about correctness a bit so you hear
me on this all right
so I was saying that D is very big about
correctness and I think many languages
do a very sloppy job at it many
languages barely allow you to write
correct code and you know essentially
they don't fast rate at all and the
least resistant path of writing some
code is the incorrect one so greatness
starts with hello world so this is how
the D hellward looks like this is what
it looks like and there's nothing in
anything about it you said that it's
correct it is a correct program that
does the right thing in all
circumstances to wit me ask you this
what is incorrect about this hello world
this is a see hello world what's wrong
is
I'm missing the return value I copied
this from the 1978 book on see it's very
baiting copy so it you know it's
supposed to compile and run so what's
wrong about this program yes
there's no return type of Maine in
please
by default the return type is int in C
that's not a problem the problem is the
following what happens if the actual
printf fails what if you're trying to
redirect the output of printf of hello
world to a stale socket or two you know
sshfs mounted drive that's not there
anymore or to any file that fails and
you know any output that fails what's
going to return for that matter let me
ask you this first
what's this prong going to return
unsuccess if everything goes well what
the result could return to the operating
system talk to me yes best yes all right
what was the best guess all right talk
to me well now give me a number the
number of characters in the string which
is all right 13 quite you know quite
faithful I would say so this program
returns to the operating system 13 in
case of success and what does he return
of failure 127 because it print every
times -1 it makes it into whatever
registered the machine uses for the
return value minus 1 is going to get
truncated at the end of the day you have
a provider returns 13 or 127 which is
almost like 13 times 10 minus 3 right so
there must be something there but it's
an incorrect program all right let's
move on to C++ 20 years of progress
I've been merciful I've used backslash n
instead of the end L disaster all right
what does this guy return talk to me yes
zero well it returns zero whether things
go well or not returns your own success
and returns your own failure why does it
returns your own failure it's a bit more
complicated by default
you know the i/os to do support
exceptions but the exceptions are turned
off by default
so it'd have to you have to know a fair
amount about this about the way our
strings work to make hello world correct
let me repeat to make hello world
correct not interesting make it just
kind of do the right thing okay well uh
that's all problem you know not to
mention that you know I've never been
fond of our streams
notice the positive at it as an
exclamation mark so you know I copy this
code verbatim from from the you know
first edition of the simplest was book
you got to learn more quick like you
know ACDC out what was that shift
operator doing there and more trouble
with multi-threaded i/o what I mean by
that why is he out worse for
multi-threaded IO than printf oh hi yes
so every essentially everything you
wanna print is going to be a separate
call whereas printf flux the the output
file wants it outputs everything and
there's lots of the thing which is
instead of what he does do alright so
you see pause once everything went
better than expected you're going to
claim success whether or not it fail it
succeeded actually alright so my litmus
test for evaluating languages for how
serious are they about real good
production strong reliable code is the
following I read the tutorials and the
tutorials are by the Finnish engineer to
make the language look good so the
tutorials like oh look how nice you
write quicksort two lines one line right
on one line quicksort evaluating it and
seeing how good it is it's a complete
different matter and then consider
various production sinners io may fail
input may be very large API calls may
fail input may contain non ASCII
characters so what does it take to take
the nice examples and make them ready
for production
right oh that was a demo no no to write
the correct hello world here's what you
have to do my friend right and to write
the correct echo cat whatever program
you gotta take it through
steps to make it correct so India is
that all out war on doing the path of
least resistance do the right thing and
echo is the simplest program that
actually does something interesting like
will use echoing the make file don't
make fast for example and the way echo
works is it takes this - M you know
don't output a new line this is an
option it - n so essentially what this
guy does is you know probably the
shortest program that does something
useful and you get the option - n you
pass some configuration options and
whatnot and you write the join of the
arguments to the program followed by an
optional new line my point is that this
program is correct it's correct for the
following reasons if anything weird
happens here this is going to throw an
exception if anything will happens in
the join is going to throw an exception
if everything weird happens in right
it's going to throw an exception the
exception goes out of main the exception
is going to have main print as Marinette
error message to the standard error and
it's going to return nonzero code
otherwise the zero code is going to be
returned and that's the end of it now in
the past people have tried to your arm
approach correctness in different ways
so for example for these an
implementation for validation there's
been contract
you know contract based programming all
that good stuff with invariants
preconditions post conditions right who
knows about DB c DB seen design my
contract all that good stuff all right I
mean the the poster child would be
assert right error handling we are set
up as sorry for the typo we're
celebrating a four year this year four
year anniversary of the movement against
checking error and error codes which is
a very strong movement nobody checks
their error codes apparently I know you
do I mean you know present company
excluded of course right I've ever
checked right and even for people like
you propagating errors manually is
is a continuous friction and sanding the
eye on an uphill battle in you know in
the sand up to the knees and uphill both
ways and everything right it's a
continuous friction that you need to put
up with so then there's been the try
catch using our wine protect doesn't
know that this unwind protect alright is
the least first way of doing a try-catch
and you know let good stuff so I think
they're never gonna scare I think it's
time to say you know what we're
abandoning is battle here and nobody's
gonna use them properly nobody
so let's why don't they scale because
they all affect the normal code path
they have you change the shape of your
normal code path and I think that's
that's a fellow mistake so now how does
d go about it for design implementation
validation there are full bore contracts
within out and all that good stuff and
are built in unit tests which make it
very easy to write good programs you
just put a unit as there inside your
class or outside and it's going to be
run if you pass - unit tests to a
compiler when it comes to error handling
D has what I call modern exception
handling which is divorced from the
notion that you know good error handling
is means a lot of try-catch or a lot of
try finally and you know all that jazz
that's going to do transaction code by
hand India can throw from anywhere at
any time you can throw from destructors
it does have destructor so you can you
can implement like C++ idioms
you can throw from destructors you can
throw from final you can throw from
anywhere and the exception is not going
to be lost
yes does that include signal handlers no
I'm sorry
embarrassing question number one
all right so the interesting point here
is that you don't lose the information
so what happens if you throw in the
destructor throws in the did you know
whatever is on the stack that is going
to throw again and you have one thousand
exceptions being thrown what's going to
happen well what's going to happen is
the following except you can't throw any
object you can't throw an INT which I
think would be an useless feature anyway
you can only throw throwable objects and
throwable objects have a field called
next which is of type throwable so throw
ball implements a singly linked list
it's it's a closed type it you know it
has the closure properly you can you can
create as many throw balls as you want
and you can chain them together so when
you when you catch an exception you
might be catching a whole chain of them
hanging onto the original exception
that's being thrown so what I'm saying
so you casually except that was
originally thrown and then can you can
ask yourself well has in has there been
any collateral damage while this
exception was in flight right and you
can actually inspect the whole chain and
and make decisions yes run out of memory
trying to allocate a new throw what
happens if you run out of memory if you
try to allocate the new throw but where
is Sean all right Sean can give you the
answer essentially this is going to be a
forceful of abort right
C++ there's a standard out of memory or
instance that's thrown all the time the
spartax training system yeah Shawn is
going to fix his whole code that was the
message the high-level message that
everybody needs to take all right
embarrassing question number two here
sir all right these books are not signed
you know you may want to come after a
talk or not I mean depends on what you
want to do with it
yeah these books are collector's edition
they don't have the author's name and
you know I guarantee within a few short
years they're going to be worth millions
but of course I predict that's because
of the hyperinflation that's going to
happen right and bread is gonna be like
a billion right all right so let's
actually look at some examples here
transactional file copy in nine lines of
course I'm going to avail myself of some
some system functions that are already
implemented well my point is there is no
there is no control flow in this
function what I do is the following
I'm saying you know I'm enjoying force
that the I got three arguments otherwise
that the invocation of the program is
incorrect say you know if you didn't
pass me program file1 file2 I'm going to
abandon execution I'm going to say you
know what I'm going to allocate a
temporary name with the messed up suffix
which is going to be the temporary file
that's going to be created as part of
the transaction then I'm going to say if
the scope fails if execution within the
scope fails do this scope is a statement
in D do this and it actually can have
here a statement so you can put a nope
embrace you can put as much code as you
want
if the statement fails then if the file
exists and remove it to clean up after
ourselves does this would be abandoning
the transaction yes
what happens if you run two instances
what happens if you run two instance of
this program parallel well I told boils
down to what copy does right and copies
is implemented STD file there and
essentially what copy does it's going to
open the source file with using the
POSIX primitive function calls API close
and my belief is that that Cole is not
locking the file so there's no you know
there's no adviser locked place there so
I presume that it's you know the outcome
is not going to be very good which means
you're aiming for the book I suppose all
right thanks for being here let's talk
after this all right
yes question for the book
but Spears as I said that call comes in
from standard file and perhaps and staff
comes in from Stan
aha okay so the question was you have
these nice names copy exists remove
probably another library we want to
define the same names right so what's
going to happen then this is a short
program is a script so name lookup I
want to do the minimal amount of typing
to get my job done
however in D what happens is D has an
anti hijacking built-in lookup mechanism
which means the following the culture
function the semantics of a function
call never depends on the imported
modules so now let's say we import a CD
algorithm which does define a copy
function with different signature and
now we have this ambiguity here do you
want to copy one string into another or
do you want to copy a file into another
in that case if and only if the
signatures would actually clash so if
the coal would be ambiguous if and only
if in that case the compiler is going to
issue a compile time error what the way
you fix it is your prefect prefix here
SD that file that copy right and this is
a very nice mechanism I think it's not
Android at all so essentially it signals
and and it prevents ambiguities only
when they risk at the rising not you
know what I'm preventing this call
because I might be thinking that at some
later point in your life you're going to
include another header another library
and you're going to have an ambiguity
yes
by reading this code how do I figure
from which library each call comes
that's a question for the book I'll give
you one so essentially what happens is
at the end of the day you gotta read the
fine manual RTFM right so essentially
what you're asking is like you know why
is overloading a kind of functioning
right well why do we have overloading in
place and whatnot yes yes
changing the signatures of the functions
in one library may break its clients we
can handle this said it not changing the
signature adding a new function with a
new signature no Allah Allah Allah give
me a minute here so this is really
really well engineered I hope I have a
good answer to this it's not it the
you're not gonna get the book folks
here's what happens
this resolution of hijacking is at
module level which means if somebody
modifies a module if somebody modifies
one module they are well aware of what
else is in that module right so if I
come later and say well I want to define
an overload of copy that catches some
particular cases of this copy that's
entirely legal but it's not possible to
break the modularity which would mean I
come with a different module from a
different universe and I'm going to
define my own copy which is going to
hijack the copy that was initially right
there you know rightfully owned by by
that guy yes
clear that coffee well it's not clear at
all apparently coffee comes from
standards on fire yes okay so you said
that there's an exception for instance
that doesn't you know match this one in
terms of full signature there's no power
it will just take the one from Schneider
from fire now it could be that there's a
third livelihood it doesn't have a
coffee at all now somebody comes and
adds a confident Philip like way down
the road you know years later which
happens to match exactly this one and
then you have conflict you're offended
by reality
yes but I hope you agree that I'm sorry
I'm let me repeat the point the point
does the following
well we have this cup which is in a CDF
file what if somebody in a CD exception
years later adds a copy which is going
to interview with this guy and it's
going to break this call up on
recompilation right I you know I think
reasonable people might disagree I think
there's a good behavior at the end of
the day this is pretty much what I want
now I think we need to take the software
I mean I'm not even halfway through the
slides so let's take this offline I'm
gonna give you a book my friend believe
me all right so Justin hope to quench
this this thing but I do agree that
reasonable people may disagree about how
paranoid or how strict you want to be
about about enforcing visibility all
right so truth in advertising I've
studied this self functional bit and the
control flow in 47 lines of code which
is the body of the entire function there
is only two there are only two flow
control statements of 1/8 and 1/4 in the
if handles out of memory it either
succeeds and this is a mantra that I
love the function must either succeed or
fail successfully right so it doesn't do
anything in between
it makes six calls to enforce has four
scoped statements and no extra ad to use
like the very low level C primitives it
replaces a function that was written
sort of old-style which was more than
twice as long he has he had nine goes to
five labels because it used the idiom
whenever anything fails you're going to
jump to the end of the function right
nine go to two five labels and 11 other
control flow statements so I think it's
a net win all right question yes
what happens if there's a failure and an
after your copied partial file all right
how do we feel successful let's analyze
this function a bit I just gonna haunt
me forever
all right fail successfully means the
following so you create this temporary
file and you copy it if the copy itself
fails there's two things that might have
happened somebody pulled the plug on the
actual hardware so while the file was
midway through somebody actually pulled
the plug in that case you're going to
have a file with the dot messed up
extension on your disk right which I
characterize as a successful failure
it's not that they seen at the target
files name all right but if somebody
doesn't pull the plug but it's this fool
what's going to happen copy is going to
throw an exception the exception is
going to navigate here when the
exception navigates here this code is
going to be executed and if the function
exists is going to be removed so if you
don't pull the plug you don't even get
the messed up file which is good because
you know you were in a disk full
situation already right
if renamed fails well rename fails it
could again it could fail for a number
of reasons but again it's going to
either fail or not fail actually in UNIX
the rename is atomic so this is a good
way to to the transactional copy so you
either reach this point with success or
you're rich and with a failure in the
case of failure this file is guaranteed
to be removed right yes you were talking
the next slide about the superiority of
these copy routine is that an inherent
part of the superiority of the D
language or just because it's a more
modern implementation could you do an
equally good implementation in C++ do
you think or is it actually that D is
better
all right good question um well this
kind of has a Slovak ating in
treacherous waters here so here's what I
think I personally think that the the
scope statement and the style that
attempt
stirrers is a complete GameChanger I
think it's impossible to write good code
with trying catch I think it's
impossible next to impossible are
practically impossible to write correct
transactional code rising try catch as
soon as you have two three it's it grows
exponentially we have two three four
atomic actions that each may fail and
each must be undone doing that with
trying catch is a disaster doing with
the instructors has the friction of
having to define all these new types of
which only reason is to decrement the
thing or deallocate something or close
something right so the way you write
transactional code in d is you do action
scroll failure undo actions gopher undo
so the correctness of the code can be
assessed by watching the grass grow you
just look at the you know that linear
it's its basic blocks the linear flow of
control then you can write very
intricate transactional semantics
functions without control flow so yes I
do believe that it's a personal belief
which you know may or may not turn out
to be true but at least for my code I
think it's a you know I've proven to
myself that that's the case yes yes in
fact it's rewritten into I cast a much
you don't want to look at those though
yeah you know that's the point so if you
have like three scope in one one
function the it's the equivalent
try/catch is going to be so convoluted
that it's it's going to be you know
unbearable so yes it's a good point it's
there really sugar over trying catch
which is I mean trying catch is like
imagine like before 4chan people like oh
you know you can call functions you
gotta pass the parameters on the stack
by hand and everyone's like okay I gotta
do it you know what what am I gonna do
and the Fortran came and said oh no
let's make it automatic this is what
scope does it automates this stuff all
right
what is generic programming talk to me
what is I mean you know we hear about it
we know about it something cool a
compile-time parameterization
compile-time parameterization anyone
else templates
well templates are but one solution what
is generate programming yes it's a way
to work with a pipe that you don't
necessarily know all right I think you
know all these answers are kind of kind
of you know hitting the hitting the the
thing but not not quite that the the
middle of the circle there so any other
all right here's what I think I think
it's very simple it's a three step
process step number one is you find the
representation of an algorithm that uses
the narrowest requirements possible from
the data it operates on so you sit down
and think hard what does it take for me
to be able to revert this thing or to
find something in it or whatnot or to
sort it bigger and capsulation should be
a crime I think it has negatively
affected this this notion that
complexity can be encapsulated away as
an implementation detail I think it's
been a huge hindrance to the whole
generation of programmers I'm not gonna
say what language faster that low-level
efficiency is also important because it
reduces the impetus of people to
actually sit down and write their own
implementation by hand for speed reasons
so that's step number one step number
two is you define types that implant
said requirements step number three you
leverage the algorithm for ultimate
reuse because you get to reuse it since
it was defined on a very narrow
interface you get reused it with a lot
of stuff and of course ah at the end of
the day you're gonna allegedly profit I
think it's you know for my money this is
one of the the best thing you can spend
time on why because programming has so
many other it's a social thing it's an
engineering thing it's many things but
at the end of the day it's a math thing
it's a science
so you gotta do what you know what the
scientific method has you do which is
look at algorithms and devise how they
should be working on the you know at
their best and reuse them at their best
here's an example um let me actually
jump to the example
simplest example is the min function
this is very difficult to define
correctly because it just has two types
here there's a collision there here's
how I define a correct min in D that is
as good as I mean you wrote by hand and
it features the following by the way do
you know why I put you know many people
say in when they define mean people
usually say left hand side less than the
right hand side why do I reverse the
stability
okay the explain if the two are equal
then you want the left hand one because
you're going to use this as a primitive
in other algorithms and you're not going
to want to shuffle the order unless you
have to
awesome thinks math okay so Matt's
answer was well you what you want to do
is kind of decide that one thing is
loaded kind of swap the things choose
the right hand thing only if it's
actually greater if it's actually
smaller otherwise you want to leave the
first thing in place in case of a
quality you want to kind of keep LHS so
now this is a sort of a little detail
that the superacid community took up
many years to two to grasp yes yes
aha good question so the question is all
in L n RR type parameters and the
question was where do you say that there
is a constraint on L&amp;amp;R that there's two
constraints actually constraint number
one is that you need to say
LHS this comparison works and returns a
boolean and the second requirement is
yeah so essentially these guys must have
a common type it must mean there must be
an intersection that's a non-void
between these two types I can return it
now the trick is this is a concept kind
of question and it's a bit embarrassing
because I don't have this on my slide I
thought I would save slide real real
estate I see what we can do here
okay in the interest of in the interest
of time I'm going to declare myself
embarrassed because what I could have
done copy of the book for you copy of
the book in the back for the gentleman
with the beard please see me all right
so copy of the book for you actually let
me pass it back all right so what
happens here is the following
you could add here an if clause that
says you know if LNR LH s less than LH s
returns the typo so D has that
capability and then you can say there is
a common type of orig our HSN LH s or
you could say if this whole expression
compiles and the whole banana comes in
between the closed parentheses here and
the open brace here now I'm ashamed that
I didn't put that code on the slide I
wanted to save some slightly real estate
but you know you can see that in the
numerous examples that that I gave in
articles and elsewhere so essentially
it's very easy to add constraints to
generate functions all right so pass
this back I'm gonna give you one more
question
uh-huh good question so what's the
return type of valuer reference again
I'm guilty of of simplifying a bit
things if you put all the ref here and
you put all the ref here and you put all
ref here you get the reference thing
that's all you need to change there's no
other nothing up my sleeve but that
being said I think going with values is
uh is fine we have been thinking for a
long time one day I want to say mean of
a and B plus plus right because that L
value that's what you want right so
probably not very often so all right by
the way I have one only one copy left so
you gotta really embarrass me here to
give it to you all right well compared
with the C++ implementation which
already
is incorrect for a number of reasons but
anyway it's not incorrect it's
incomplete
anyway it's so mad have you heard of
this guy alright so somebody sat down
Howard Hinnant actually sat down and
wrote the correct min in C++ the right
min it takes 175 lines 10 tights and
justice specializations and does the
right thing
all right and that was rejected
unfortunately people thought it's just
too much aggravation all right iterators
versus ranges D defines ranges as a
primitive not iterators why because
iterators while they're very useful and
flexible they are fundamentally
unshakable if you all you have is one
iterator
there's nothing can assert about it what
you have to do is have to eater it is in
a certain relationship between them so
what I did in D essentially is I
encapsulate both and I made a primitive
called range which does not expose the
iterators it exposes its own primitives
then I define a superset of a steel on
top of ranges I suggest you if you're
interested just Google for own iteration
which is an article or a CD that
algorithm which is this standard
algorithm implementation and turns out
ranges have have proven to be a treasure
trove they pervade IO it's the deeper
way deeds are you lazy village even
random numbers you get as a stream of as
a range yes
you could have done a range of C C++ L
as well there's a library thing yes I
agree people have not done it though but
actually this is a good point because I
define ranges to generalize this erase
built in a race which are actually you
know a DARAB specialization of rain
ranges see process does not have an
array primitive and therefore the train
of thought didn't go that way it's a
good it's a good point not embarrassing
enough all right
containers these approaches there's no
container hierarchy I think that's the
right approach
there is no dark containers there's no
hierarchy why not hierarchy who know if
we can notice about bloom filters bloom
filters all right all right tell me
what's the super type of a bloom filter
okay what are the primitives on long
filter talk to me of the people who
wrote their hand come on yes what will
be the primitives that you would define
for a blue filter 12 5 insert insert
change may contain almost sure contains
right I'm pretty sure it contains and
and well there is one more like create a
total universe because bloom filter can
if you assign all bits to one
essentially create the total universe
during the whole set of types everything
is gonna be in there which is very
particular so anyway so blue filter has
insert at almost sure contains how do
you eat irate a bloom filter study don't
even think about it right
fry this up you know something more who
knows about 3t RIE try you know some say
try alright
what apprentice or try can you integrate
a try within STL or within Java
collection library within C sharps
humongous collection library we can't
you can't even if you wanted you can't
so this as you know what let them be
free there is a freedom they could apply
to certain named interfaces which is you
know if you define insert then it's
assumed to have certain semantics for a
container right including complexity but
other than that there's no relationship
between them some containers and we have
stable insert what do you think stable
insert does stable insert stable remove
what do you think the stable thing does
compared to STL insert/remove erase you
know Eurasia
doesn't reorder equal on almost there
what's a liability STL is insert for
containers different across different
container types invalidate iterator
invalidation stable insert does not
invalidate iterators if you can insert
without invalidating you define it
otherwise you don't define it and code
could use introspection to decide what
to do whether or not your container has
this capability see my point so a
container may define insert which does
not make any particular guarantee it may
also define stable insert which could be
an alias to insert by the way it's a
one-liner just an alias there's no
overhead Yale is too nice together to
mean the same thing and then what you do
your users are going to be like oh
that's this guy's supports table insert
and I can implement this cool algorithm
otherwise I'm going to go and
conservative alright alright I have an
upcoming article which is called sealed
containers and shows how you can
implement containers that use malloc and
free for deterministic the allocation
while at the same time staying safe it's
a trickier thing that I might have
thought so I recommend you you stay
tuned
who knows about edit distance Levenstein
right any visas between two strings
tells me how much do I need to modify
one string to be able to get the other
right so it tells me like spell checking
all that good stuff now there is a saw
algorithm Levenstein created it I think
probably back in the 30s or so and it's
not simple as a dynamic programming
algorithm so what I define here is a
generic function that takes 11 time that
takes an equals function which may be
expressed as a string with the
convention that a is the first argument
and B is the first argument this is the
easiest way to define a short lambda in
D you can actually define an actual
function there r1 and r2 are the inputs
and I I impose the constraint that both
are forward ranges now here's the trick
usually if you google for well this is a
sort of a if you google for Levenstein
you're going to see that the usual
assumptions are the the strict equality
imposed there and that the inputs must
offer random access everybody in this
world and their brother implements
Levenstein on a race not on lists I'll
tell you why this is very important why
do you think this is important a race
not least why do you want Levenstein to
work on lists on forward iterators
alright next slide is gonna tell you all
right UTF encoded strings they're not a
race
utf-8 strings are not a race there are
sensible race they're defined as a race
Indy I see you know what I'm taking an
array of immutable characteristic call
that a string and I call it a day so
each each character inside the string is
not modifiable but the string can be
rebound so that's why that's why that
syntax over there right so this is what
it's defining the summer in the guts of
the standard library okay now formally
string and W string only offer be
directional interface why is it B
direction because in UTF it turns out
that you can go from both directions no
problem you can't have random access
because it's variable length encoding
right UTF unicode right unicode encoding
okay so in strings you can't go like you
know they don't have an indexing
operator these guys offer it because
there are Mamata is actually an array
however formally they don't they don't
claim they have random access so an
algorithm that says is forward range is
not going to you know it's going to work
with strings but if it says it's random
range it's not going to accept a string
now here's the trick the net consequence
of all this is that the leverage type
distance function that I word that I
defined for D is the only function in
the world that fault that fulfills the
following works for all strings
works with custom comparison and there
is no copying going on there is a
function in Python that does work
correctly on UTS strings it makes a copy
in D charge like for character right to
have random access now very
interestingly Haskell Haskell lists
right Haskell lists I went to google
code that was very surprised so has got
a 44 implementation of Levenstein for
three of them use the race in the
language that that you know put the
alien list well at least put the
l'Damian list but Hester is using list
on the throw and through right so in the
language that uses lists you know
everywhere there are for implantation of
Levenstein 300 of which require a race
requiring indexing the fourth does not
use dynamic programming is a big slow
there's no good function there's no good
Levenstein in Haskell why is there not
no good leverage time because nobody's
told generic nobody thought you know
what does it take for leverage time to
impose the minimum on its input
everybody goes to Wikipedia Reiser
Wikipedia entry looks at there's a
random access to better use random
access and they call it a day no
leverage time works on forward ranges
interesting enough it doesn't work on
files who here knows about boy or more
fast string searching Blair Moore is an
algorithm that allows you to quickly
search a large string inside the large
string for a smaller string very fast it
sublinear fast sublinear we're talking
quadratic versus sub linear so whoa I
better get on that bandwagon right we're
more I discovered it just so happened I
thought of it for a long time I
discovered that boy more works in a
limited form if one of the strings is
that be directional array
be directional range it works it's it's
a bit restrict that it works pretty well
right do do you think this is important
raise your hand if you think the simple
alright nobody can say whatever alright
I think this is the important I think
it's important that I sit down and say
you know what where more words for
Unicode strings without making a copy
wow that's pretty cool I mean you know I
do want to be there right he find me
interesting in fast in string searching
and I want to be UTF correct
I want this I'm interested the saying
goes about many other algorithms and I
don't have the time to discuss here all
right we have one minute for the rest of
my talk but I can't stand not telling
about this factorial function all right
nice compile time template factorial
function right which wasn't you know it
was a huge event in the CSS community it
was one of the first instances of
compile time program that computed
something interesting right there's
actually one before that can be I think
prime numbers but it wrote them on the
standard error in form of the compile of
compiler error messages so that was not
very useful factor it was borderline
more useful all right forget what you
just saw because India can do the
following you can write a factorial
function like a normal function and
later on you can say I define an enum
which is a statically computed value to
be an expression that normally would be
runtime evaluated by by asking for a
minim here that's enough for the
compiler to go ahead interpret factorial
interpret factorial during compilation
and replace the call with the result yes
you know defer that for functions that
as for IO that's not embarrassing enough
so I'm not gonna give you the book I
have one more copy of the book at you
know I remind you so the answer to that
is the following certain functions and
certain primitives are not compiled time
they can't be evaluated during
compilation a call such as right or
right line or printf or whatnot is the
compile is going to choke on it is going
to say I'm not going to compile this so
the answer is no you can't do i or that
way you can there is a pragmatic does
output and stuff yes dynamically
statically ok good question excellent
question
there's been a very recent discussion on
actually enforcing the statically it
turns out it's conservative doing it
none conservatively is the halting
problem I said I mean essentially to
figure out if I'm going to be able to
evaluate this tantamount to actually
evaluating it trying it and see that I'm
not going to seek you for you know two
days and compiling or what's going to
happen yes yes you can you can make the
slowest to compile program however I
remind you that the D compiler is the
fastest compiler of any compiled
language on earth and probably a solar
system and a few other planets yes
right so why does decompile 100 times
faster than than 4.5 times faster than
gold I tell you why it lost files
asynchronously it does I end it you know
also it can you know it does not exploit
it but it could enter all declarations
in parallel but let's save that for
another day because we're running out of
time I hope this is cool I mean you can
actually ask the compiler you're gonna
say I have this function I want to
divert the during compilation and save
my time during runtime
now here's the trick there are
limitations you can call malloc during
compilation right you couldn't if you
want it yes uses a compile-time constant
I mean are you you are liable to get
into loops but not with that scenario
that's a simple scenario that the
compiler can take care of but you know
of course if you have a recursion
running amok and everything that combo
is going to simply choke on it so
essentially it's going to blow through
and try to evaluate everything it's
going to choke at system calls malloc
you know new casts any unsafe thing not
doing compilation you can give me a
deeper end that's going to ruin my
system during compilation right and such
stuff all right so this is the last
thing I wanted to share with you and who
has a Java clock all right who can sit
here for 10 more minutes all right
perfect thank you so I again I can't
stand myself I want to talk to you about
this and due to these questions here
embarrassing questions about copy being
overload and all that stuff I wasted
some time so I hope you give me some
credit here all right today concurrent
programming several competing approaches
so there is sharing intensive approach
which means you start off ready to seize
all the memory we have message passing
like the CSP wrecker models which are
pretty old but are getting resurrected
today PG as soon as our big-ass
partition global address space for
scientific computing matrix
multiplication
good jazz right for HPC there's no
definitive solution at this time but a
key trend is that on your machines
passing messages becomes faster more
scalable than using shared memory shared
memory is an illusion that's
increasingly expensive to maintain as
the cache hierarchies are getting so
deep that essentially your illusion that
you write a variance somebody else read
it must go through all the way up the
hierarchy and then go back all the way
back to their hierarchy so it's a
disaster traditional languages were
developed in the days one share was
cheap and easy zero States memory
remember and and all people all like
Mihrimah zero weight states you could
buy that right so they placed a bet on
shared memory the places are better
message passing and hedges that bet with
explicit sharing and here's how it works
basic tenet there's no shame by default
you can share on demand shared sharing
is controlled by the compiler here's how
it works if you define a thread local
it's going to be threaded this is global
space right if I say shared in global
then it's going to be shared right
somebody else can modify what is done
the practical consequence of defining
this in shared like in terms of code
generation code generation for shared
stuff you gotta give the memory model
stuff right what does that entail locks
probably does too heavy for an int
has talked to me come on memory barrier
stomach folks Frances memory barriers
you got to protect this this access from
any thread with the appropriate memory
barriers you know whenever they read it
and whenever they write it and it
depends on the architecture exactly how
you do it right so there's a complicated
stuff but since the compiler knows about
shared it essentially takes care of that
key point share this transitive what
does transitive mean transitive
qualifier if I make up every yeah if you
have a pointer that shared everything
can reach through the study from that
guy is going to be shared as well why
because the thread could do it it's it's
a consequence not a decision people were
like oh why why is shared why did you
find the language this way we didn't
define this way we discover it was that
way shared is transitive immutable is
transitive
you can start from immutable and then go
back to mutable if you start immutable
you stay immutable yes yes if you have
an email list all members of the list
are by necessity immutable you can't
have you can have an immutable Island
and the god of that Island into mutable
territory why is this all geographical
reference yes so you you said earlier it
started to talk that you had various
different levels of sort of safety you
could have indeed in terms of you know
type checking and that kind of thing and
you know how the malloc could could
break that can you can you break the
either shared an immutable stuff and
different modules or all right I'm
standing here I'm saying you can break
all of these qualifiers with a cast all
right that's gripper ball but the point
is it's not only grab a ball but the
point is if you qualifier code with the
safe label you know at safe then
essentially the compilers going to not
allow that cast from Hatter to happen at
all so it's going to choke during
compilation so you can break all of this
stuff and actually let me let me up
the following here's how the offer is
layered flagship flagship approach we
have isolated threads asynchronous
messages safe module maintainable easy
to understand programs even
automatically checkable in the future
I'm sure shared variables like free code
all-school critical sections you can do
that if you so want non-save code makers
cast exactly your question s/m
statements assembler statements can go
down to the assembler level if you if
you don't like it if you don't like all
of the above and well you can use a
soldering iron if you saw one but it's
not included with the download why is
this good because we know that message
passing works so essentially in UNIX all
the time wheel spikes - for fun and
profit
how many times did you have a pipe that
had a sharing problem right it could I
mean if you write to a file and the
other guys reading the file and it could
happen but it's very rare so we have the
the process level concurrency which
works but it's pretty heavyweight inside
the language what the offers is thread
level concurrency with shared memory
which which would be fast but fraught
with peril
so why do you offer is sorry the D
doesn't offer that what the offers is
type system level isolation which is at
the same time safe robust and
lightweight so India thread is pretty
much like a process from a systems
person perspective except that it's
lightweight make sense all right
alright you conclude well you know I
have this dog and pony show thing so
what would be the answer to these three
questions I don't know what the answer
is but I think the answer is a weighted
average of everything that you want and
this is what the aims to be the weighted
average of good things that doesn't fall
into any extreme and I think it has
succeeded at that questions yes
not a question regarding your previous
slide regarding the separation of memory
for different threads so this is
completely statically enforced or
checked it is completely statically
checked that one thread cannot access
yes it is completely statically checked
now here's the thing the static checks
are not going to catch all patterns so
if you're trying to do all style
old-school coding with the shared
qualifier many patterns are not going to
compile it's conservative alright so
what I'm saying here it's harsh but it's
for your own benefit right if if you do
need to use such a pattern you can cast
shared the way and use the raw raw
access but the nice thing is that those
are hopefully very few places in which
you don't need to do that so it's easy
to verify that code by hand so how do I
know as a programmer which patterns are
usable and which ones aren't and are
they going to change over time by a copy
of this book this is like really whoring
here all right so questions for the book
pass could you pass the microphone in
the compile time evaluation slide you
said that you could evaluate factorial
of 10 any optimising compiler will
evaluate factorial of 10 I didn't get
the point what was so special about D in
this respect an optimizing compiler
could optimize certain expressions but
at the type system level is going to
disallow him initializing a statically
computed value with a dynamically
computer expression so if I say the
first statement order f1 equals factor
of 10 the compare might may as well if
it's smart decide you know what I'm
going to vary this right now and I'm
going to make it a virtual constant
right
but at the type system level the
compiler is gonna say if I if it sees
any 'm EV to the language definition
must be like well you know what here i
need to make a decision
what's a constant and it dean turns out
that it turns out
thing can be an expression so it's not
an optimization thing it's a language
definition thing they are different mad
like thousands left you out making
comparisons of disciples
all right so so any comparison of the
design goals of D versus go I have to
confess I've been preparing for this
really like like a horny teenager for
for the prom night so I've been learning
a lot about go and I concluded the
following I'm so biased I'm not going to
say anything it's useless I mean really
I'm very biased because if if I would
prefer go I would have done for D what
ideal you know what what's what go is
done because it hasn't done anything
like really new right so the thing is
I'm not going to say anything you can
ask me about specifics where I can
actually talk about you know the
technical technical things I'm I'm not a
question about the safety mechanism um
what happens if you link safe and unsafe
modules into the same exactly ball to be
unsafe modules have the option of
corrupting data or pointers that they
get from the safe ones or is there
protection against that it's a great
question so what if you link safe and
unsafe code within the same executable
there's the mechanisms conservative the
way it works is if your safe function
tries to call a man save function
disallowed so there's no you know
there's no way to untain whatever are
ANSI functions because you can predict
what's going to happen so I think that's
reasonable I think more could be done
about it and I think it's all going to
depend on how people are going to want
to use the language question for the
book yes
given the inertia behind existing
languages like Java and C++ do you feel
honestly optimistic that this has a
chance of really replacing just based on
technical merits it's a great question
again I'm biased so you know essentially
the markets will decide there have been
languages that has succeed on merit
alone like Python Python essentially had
you know not a lot of formal support in
the beginning I do think these married
puts it ahead of essentially all
languages I know that to be again I'm
biased but to be brutally honest that's
what I think happens now the the D book
has been out only for a couple of months
and is the dog days of the summer it's
had good sales already I think there's a
lot of pent up excitement going on right
now in the Dean s and you know growing
community so I'm optimistic but I'm
cautiously so because you never know how
people are going to react to the
introduction of a new programming
language it's a good question you know
what it's a question for the book last
question I gave the book over already so
it's like oh whatever
yes so from a software engineering
perspective I really like the idea of
separating the shared state and the
non-shared state but for from a
performance point of view like to point
out that the the Kaz operation which is
sort of the fundamental primitive for
writing a concurrent code in with shared
memory is is getting surprisingly
cheaper so so suddenly I used to take a
you know 100 cycles you know best cases
now they the the hardware people are
doing it so it's like you know ten
cycles best case and and so the the
performance story may not might not be
quite as clear as as you made it out to
be I think I I exaggerate a bit in one
direction and let me actually amend that
D has cast as a compiler primitive D
defies cast what kind of pointers do you
think has works on
shared casts works obviously with shared
data Aiken castings and actually D is
one of the language that makes make it
easiest to write a lot free programming
with casts easiest because you have
shared you have the cast primitive and
you're safe
so actually you know I was very happy
that I'm a huge program a huge cast guy
and absolutely huge I wrote a couple of
articles about it I'm not sure if
anybody knows this everybody cares so um
I'm a huge cast guy and I think casts
and transactional memory all of the you
know the more complex and the better
models that are people are talking about
I think it has a lot of potential there
so let me amend what I said about
message passing beans being the only you
know the foremost flagship approach to
concurrency in the D welcomes Cass and
it has built-in support for it after
last question all right
going once yes great question so what do
you do so Cass code and garbage
collection are the best marriage in the
world agree Inc Cass is love it is a
five slice presentation about calcifies
last presentation if you have garbage
collection if you don't it's a thirty
five slides pages right presentation I
gave both so I know you know I've said
that at some point I stopped and I said
if you do casts in Java you can leave
now essentially that this is it and then
it counts all the memory management all
that good stuff so answer it's going to
be extremely exceedingly is easy to use
casts with the garbage collector in D
it's going to be probably almost as
complicated as it is in C to do manual
memory management the algorithms and the
underlying patterns are going to have to
be the same gonna have to cast things
away and all that stuff
yes which collection schemes and maybe
also about the allocation of stacks for
multi for the threat excellent questions
all right so what's the deal with the
garbage collector in D and was the deal
with stack allocation for multiple
threads so as far as garbage collection
goes essentially D has a run-of-the-mill
garbage collector right now which is
adequate garbage collector it's not the
best of the breed and I'll tell exactly
why it's not the best of the breed it's
because D produces less garbage and
other typical programs right so there's
less garbage in we have fewer men on the
task there to collect the garbage so
obviously you know that's that's the
dynamics that has that that's happening
now
garbage collection could and should be
improved but he makes a very takes a
very strong stance on separating what
garbage collector collected from what's
scoped allocated like struts like in
India class is always garbage collecting
obstruct is always not garbage collected
right so that's the way it works
essentially there's a clear separation
I'm going to use the garbage collected
heap now but I can actually use the
stack for struts which have destructors
hence the C plus has patterns which is
which are great and then we have we can
use malloc if you so want and actually
you know I started using malloc inside
my collection library because it turns
out garbage collection it does require
more memory to run properly
there have been studies there's been
everything and essentially the the
takeaway of the garbage collection
studies is the the typical price is
going to occupy three times as much
memory to run properly
right it could be better actually that
to have garbage collected stuff it just
is going to occupy three times more
memory the working set is going to be
bigger that's a consistent result it's
between three and five but the average
is three now getting to your second
question which was
the stacks for multi-threaded for
multi-threaded programs he does not have
a strong you know doesn't have the
segments the stack that go has my
personal opinion 64-bit are going to
make this a non-issue 64-bit you know a
64-bit addressing means it means you
always have at a space you know there's
been the people have done kind of
similar calculations essentially takes
you hundreds of years to fill the memory
if you have like 64-bit types you're
hundreds of years what I'm saying 64-bit
address space means you always have
addresses you always have chunks of
memory yes
you're gonna counter that destroy me
mapping us right to the map your
strengths and if so what if yours
doesn't provide you enough threats well
you know I I don't have a good answer to
that essentially right now I can say the
following their weaknesses in the way
32-bit trading is addressed and from
here on it's an implementation thing I
don't think it's a principle thing and
that's what that's what really matters
at this point the excellent excellent
questions yes this D have runtime type
information reflection my java if not
has garbage collection work
yes Dee has runtime type information but
most interesting it has static type
information actually people can do
things like I was just talking right now
with Kirk
so essentially people can say give me an
interface and I'm going to define a
class for you that implements all of the
members of the interface to throw markup
for the win right so we have this class
with this interface with the humongous
number of functions and then I say
instantiate the temp this template is
going to implement everything statically
to throw and then I'm going to say yeah
from this I'm deriving my own class
which implements five because that's
what I care about so I can test and play
with it so people are doing increasingly
this kind of statically enabled
reflection then is there is not as
powerful as Java source t-shirts but you
know I think static is the important
thing and the dynamic is library
implementation thing
all right type I'm seeing people kind of
you know getting antsy here so absolute
last question absolutely so don't leave
me like hanging like this this is prom
night come on all right yes absolute
location absolute answer all right what
is the biggest application currently
written indeed what is the biggest
application written currently in D I
haven't taken atole Walter told me that
a lot of people working at actual
companies that endorse the contact him
and essentially do use the companies
don't advertise it as much yet so this
is sort of an you know it's
unfalsifiable information so it's not
very variable a large the application
might be the Qt binding for D so cute is
a huge library and people have written a
binding for it there are a few sites
that have these beyond games people game
gamers love these so that there are a
few pretty big games written in d
exclusively so I'm hopeful there again
the book has just come out and my hope
is that now is the inflection point all
right well with this I'm going to have
to end and thank you very much for
sitting</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>