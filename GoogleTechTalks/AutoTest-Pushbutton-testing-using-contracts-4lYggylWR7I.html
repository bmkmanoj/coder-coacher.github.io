<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AutoTest: Push-button testing using contracts | Coder Coacher - Coaching Coders</title><meta content="AutoTest: Push-button testing using contracts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AutoTest: Push-button testing using contracts</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4lYggylWR7I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you haven't for the introduction
so in my talk I'm going to tell you
about a tool that we developed at ETH
Zurich which is concerned with
estimation and it's concerned with test
automation to degree will develop only
choices about team and the testing
happens we link the Armada in the
background my comp is structured as the
following already as the parts that we
have heard so far make clear many people
stand different things when it comes to
testing so the first part are going to
talk about what I mean when I talk about
test automation and i'm going to
describe the core work that you all of
this framework does and then i'm going
to show you the components the main
component that you all of the favor is
built up with there's going to be the
core components here with the Oracle
that tells you what a test case past and
when a test is failed there is the
actual testing strategies that come up
with the input data on the test cases
that exercise your system or intestinal
but then and this is where also on
parenthesis once you experiment with
with few strategies it becomes important
that have good support components that
that glue your frame work together and
we've learned quite a few lessons there
and I want to share this experience with
you in the end you'll see and they're
more like them off the tool and I'll
show you some experimental results that
we've gathered so let's start with test
automation one of the or any most
important things to do and when you test
is to only the actual test execution
because it
cumbersome working nobody likes to do it
especially with the event of the axially
kind of tools this this has been
something that people started to to do
it was less overhead with a simple tool
everybody really likes it i think that
it's only one part of the test
automation you're still concerned with
test case creation rate data creation
and then once you run the test case you
need to decide whether what just
happened reveal the bug or it didn't
reveal a mug and many many people many
bright people have done a very good
research in these areas recently they've
been innovative ideas being used people
in using specification or contracts to
both automate automatically filter
invalid input so if they come up with
random inputs who say what is not valid
what is valid and they've used
specification to rule out or to reveal
whether an executed test case contains
bucks i will talk more about this later
of course this requires the presence of
contracts in your source code but then
again other people come up with ideas to
that any plane / specification in the
case where a specification is not
present people have been using variety
of technologies like symbolic execution
or abstract interpretation model
checking and d improving or even a
combination there to create really
really interesting strategies that all
have very very good strengths and in
fact many of these strategies are so
good so good that they're worth
combining and this is exactly what we
tried to do in auto test we're trying to
provide a framework where good ideas can
be combined and then basically we get
the best of breed a framework once you
start doing that so you put together a
frame we can execute tests and you
experiment with various ways to two
strategies and i'll tell you about view
that we
mented and we put in an article other
other things also become interesting as
soon as you start to use your librarian
on real world code things like
scheduling how do I find out or to
evenly test my source code test case
minimization if you use really really
tricky and Astrid technologies to text
your source code you still want to
present the user a very simple but
reproducing examples so that he has an
easy start starting debugging from where
you stop when you test for a very long
time you want to have the execution
robust I think this has already been
mentioned today it nothing is worse that
you you test and you can't actually see
your test results because at some point
something happened that the wrong gear
system down so you want to have robot
execution or at least between results as
long as you can and there are many other
aspects here that order to about so the
time it says push for the testing let me
clarify what that means in our context
we're really trying to have a system
where the user pushes a button and then
the code that he just wrote we can
automate it the great the input data
around the actual test cases and then
judge whether they were merged or not
with one the requirement though and that
is the the software needs to be equipped
with contracts with in the form of
executable specification so we're
targeting Eiffel I don't know how many
of you are familiar with with with 11
times it's quite quite a few so I don't
need to talk too much about it basically
you have preconditions postconditions
invariant and precondition well yeah
we'll see later on anyway a system such
as this can be envisioned to be used in
self scenario for example the testing
overlaps scenario were used all morning
you you write new code and then you go
for lunch but right before you push the
button hex
sighs and as you come back you have a
bunch of bug reports and then you're
busy all afternoon children you can't
test overnight having on a server
continuous testing has been mentioned
several times it can either do it in the
background of your IDE or you have a
separate testing server that is
integrated with your convenience build
infrastructure things like that a
essential part of why we can fully
automate our testing is the executable
specification naturally it's called
design by contract let me give you a
quick refresher on how this works here
in the form of a square root function so
it's a function to compute the real
square root of a real variable and what
we have here is a required keyword and
then the predicate implementation which
I omitted here for brevity and you have
the ensure keyword which basically gives
you the postcondition now the contract
that established here between somebody
using applied of this of this method and
the method itself is the following the
client has to establish the precondition
and only then is the amendment itself
obliged to satisfy the postcondition and
it's by definition that if the grid
condition is not satisfied the
implementation can do whatever you think
it can return parentless things it
cannot return vol you can go for coffee
or whatever what everything's um is nice
now this is applicable whenever you have
language that supports contracts
natively namely guys language or more
recently Microsoft has developed the
language called spec sharp which is
essentially c-sharp up with with those
contracts but you can also apply in two
languages where you introduce those
contents as extensions for example there
is a set of extensions for growl and jml
ocl is bull i think jay contract by
contract and many more of these and of
course you can also should provide to
manually using things like the
circulation pattern okay um so to
conclude the section of test automation
let me give you an example of how we
think about test automation since i'm
currently employed in Zurich Switzerland
I'm required to do those examples only
the main of of the financial world so
i'll have the bank account right yeah
yeah tester so we have an example here
of a bank account constanta content of
the great keyword which basically says
well there will be a method with the
probe make that can act as a constructor
then you have the constructor itself but
let's be poor before if we're looking at
the contractor let's look at these two
attributes here they're the main
ingredients of the pass you have an
owner which is the name of the person
holding the account and you have a
balance which is an integer in our
example oops too far so the integration
procedure you pass a name it's a string
and then required this name is not going
because you don't want to have a bank
account without an owner in the
implementation you set owner to receive
name and you said Vallance 30 value of
zero and then you have a post condition
which ensures that the owner equals the
name there's also an invariant section
down here which is also i am part of the
contract basically limits the set of
objects that were considered valid any
object that is valid needs to have an
owner that is not equal to point and
balance greater or equal to 0 and in
fact with the creation procedure here we
can see that due to the great condition
the post condition
they vary this always keep right after
the object is created and and then we
have another method that's quite
interesting it's called deposit you give
it an integer and with this one you can
add money to your account in the
implementation is quite a bit forward it
basically adds to the balance and then
the postcondition just restate that the
new balance equals the old balance plus
the value that you've transferred all
right now we do have this class we have
the contracts in there they are not
particularly sophisticated how can we
use that for testing let's look at how
we would invoke the auditors testing
tool are on such a system well first of
all you need to invoke this comment I'm
tall so you type on test the next thing
is given a style this is basically in
Eifel what you see is a make file or in
Java is the pasta it basically contains
the list of directories that contain the
classes that make up your application or
library you would need that compile the
implication anyway and you pass it to
the auditors testing to completely
unmodified we don't need any people any
workplace and then what's left is you
can specify the past use code you
probably don't want to test your own
vacation every time so you give your
list of passes and then others will
concentrate on those two passes on now
given these given this invocation what
could all this do well it will start by
creating test cases let her go into
detail what actual strategies are used
to
um it could start with testing string in
order to do that it would create an
object of type string so you can say
create here and then the type name in
curly braces and then a variable name
that receives the newly created object
and then would call some extras on it
will call hot white hot well the wipeout
would be a method on um strength that
removes all the characters now we know
that when we create a new string is
empty so it's very not the most smart
idea to call I path here but actually
it's a border casing might reveal a bug
and actually it might just indicate that
the strategy that we use in for generate
the test cases is based on randoms as
the next step it called could use the
same object to call a pen character it
would be method that would upend one
character to the end of the string then
call the pen bubble which is the same
thing for double values and it could for
example create a new string and put it
into a variable called me too then it
could call me one append Spain etool so
it would upend whatever is in p2 to the
end of the one again probably not very
clever because there's nothing in deeper
and then you could fulfill which
basically takes the character you supply
and fills up the string with a lot of
jeans here in this case and then you
could go on to test rain eventually if
its board it continues with testing
class ANCA calm is the second part here
in the testicle so what happens first
again same structure it will create an
object of type bank account store in
America three you can see here that the
constructor needs an argument is the
owner
practic and our strategy decides to use
a tool here if we go back here be cool
was created a substrate that's okay and
then it starts using methods from an
account there not many available deposit
is here so it will deposit 1512 swiss
francs for example switzerland again
then it will deposit 100 francs and then
decided to use negative integer and it
will deposit minus 8901 friends alright
so how can in such a scenario how can we
detect bugs does anybody have an idea it
cannot you detective we detected in
strip if exactly so to repeat what
you've just said is that what will end
up here is a negative negative balance
and we look back at the invariant of the
cost it states clearly the balance must
always be greater equal to 0 and now
those contracts are always check the
drum time the Americas always check that
the routine entrance in the routine FFX
it in iphone so if the script is
executed will get an error here and even
more so we can even put blame we can say
well is clearly it's clearly the fall of
deposit because it left Europe before it
did something the state was good and
after it did something the state was bad
okay um so the script to reproduce this
part can be very long so it's a few
lines here but you see the ellipses
marked here it could be a few thousand
lines long
should have gone on to do other things
in the meanwhile it's probably not the
best to give the user this very very
long script and asking well please work
from here so what you want to do in this
scenario is you want to extract a small
intestine ace and when you look at it
actually these three lines that are
marked red now it's not really rather
than the project it's right here on my
notebook go represent the smallest test
case that will still reproduce the exact
same problem so this is another thing
you probably need to take care of when
you're trying to do test automation in
this way another thing you you might
want to take care is again this robust
execution thing were when you're doing
interesting or dangerous things here in
the middle you might want to recover
gracefully from it and not not just
strong so the idea here actually another
idea that's in this example is that to
test bank account we're not creating a
new argument we're using one from
previously of course we could have used
to spend in a new one as well some of
our strategies implemented though
sometimes decide I intentionally to use
an older object because it might have
been used before and brought into
interesting States because it's been
used with other methods before so we
hope to get a more diverse set of test
cases this way
um so we have this framework idea we
want to have an automated testing
framework like like I just sketch where
we have the actual testing strategies
that are pluggable you can replace them
one has a flexible execution mechanisms
it's a mechanism because we don't know
exactly how the stretch are looking
looking like or they're just very very
different by nature so the execution
mechanism needs to support them all or
as many as possible of them you want to
be robust that you said that one of the
benefits of hat will of having such a
framework is that have you have a
unified interface for for the user and
you always ensure that you stayed push
button because the user interface of the
tool enforcers if you always just give
it the system and the scope this kind of
test case full pestis automation I don't
think it's going to replace manual unit
tests anytime soon I think it should
cooperate with manual unit tests these
kinds of automated unit tests are very
good at some part in some tests humans
are good at others and I think they
really there's a complementary nature so
I think it's important to have such a
premium integral tightly with the
existing material test cases and also as
I briefly mentioned you want to have
concisely input no matter how
complicated slim workings of your system
are so the testing for Christian to call
our auto test framework lies in the in
so many many people think of different
things with a partner testing this is a
very it's of course trying to classify
where we try to put put the farmers I
think all of this can can be very well
situated in the
in the city of unit tests and
integration tests it's really not as
good system test at system tests because
they require very very complicated input
that automated strategies might not
always be able to satisfy and if not
visit acceptance testing at all because
yeah we don't have the first one of your
comments to process automatically on the
other hand if you do have created unit
tests or integration tests that reveal
the bug YouTube integration with manual
testing we basically can feed back
extracted form an interactive witness of
the automatically generated pests truly
regression tests seem to be executed
next time around so if you have for
example automatic strategy you're you
will be sure that this interesting case
because in trivial problem will be
executed next time around it not only
has a chance to being executed next
camera all right this brings me to the
channel section with the core components
namely the Oracle that we've implemented
and the strategies that we've
implemented for our working on so the
Oracle that we use is based on those
contracts that I've introduced before if
you had once you have the notion of
preconditions and postconditions and
somebody if you met them that you've
never heard before you can basically
call the method with arbitrary arguments
person are arbitrary parameters and then
you hope for two things the first thing
is you hope the precondition will not be
violent it just very definition if it's
violated anything the method does is is
okay only if it's not violated the
method is obliged to satisfy the post
condition so you hope if you're looking
for bugs you hope that the post
condition will be valid because exactly
in this scenario
if we will depart and you know who's to
blame in practice things are a little
more if they are difficult because as
you've seen in example before they're
also in burien revealed bugs sometimes a
precondition you can signify power
imagine a situation where you have a
method retest you call it you're
satisfied recognition but this method in
turn calls another method or itself
recursively violating the precondition
of the second method then clearly
there's a bug in the first map so
precondition can mean for real the back
and the ork ork needs to take care of
that you have a search statement tonight
they're actually called check check
instructions those reveal bugs to any of
other kinds of exceptions think of a
null pointer dereference and things like
that so this is basically you're so that
we have in place now I'll introduce very
briefly five strategies that are either
already on ready for use or which we're
still working on the first of these
strategies is the random testing
strategy is the first one that we've
implemented because it's rather simple
as it turns out it was also very
effective if you're going to see some
experimental results that we have later
on so to explain it for each method on
your test we create a target object and
then we put it in a pool this pool is
basically the speed on and detune that
you've seen before and we keep this pool
around not only for one test case we
keep it as long as possible in order to
get hands demers of you as possible
there's something to that contain the
and the next step for each parameter of
the method you want to call you're also
going to create an object and you put it
in the pool and then in order to have
objects in different states you pick one
object from the pool and you call an
arbitrary vector not necessarily one
from the from the methods and your test
pilot just in the hope to get a little
more diversity there and only after this
step you take it in the method intestine
you pick now for every blank there is
target object and parameters you pick a
conforming object from the pool not
necessarily the one that you've created
with intention to create tests but an
arbitrary one to test so sometimes you
get just a newly created one which is an
initial state and sometimes you get
older one maybe it's the line
um invoke the method or tests and you
you hope to reveal bucks I think that
fixed it
and then there's a follow-up strategy to
this one that we're currently working on
which is based on the idea of adopted
random testing an app lebreton testing
can be best explained using objects that
are in the two-dimensional domain for
example if you've already several
objects to choose from testing like
depicted here those entry circles then
the first time around you're going to
pick an arbitrary now the one that with
pick arbitrarily is marked in blue and
then the second time around the idea is
to not use a value very similar to the
one you've already picked so in order to
pick one that is rather different you're
going to measure the distance to all the
other input candidate objects and then
you're going to choose the one with the
largest display and then you also market
and the next turn in the third round of
testing you going to calculate distance
from each point in the candidate input
sent to all object that is already used
in the one with the biggest average
distance you can adduce next and then
you continue like this and the strategy
that we're developing insert for this
has does this not only for objects in
the two-dimensional domain but we can
actually know this or we'll be able to
do it for arbitrary objects compound or
not another extraction another
experimental strategy that we have is
based on the note on a platter as they
use them in the domain of artificial
intelligence those patterns are
typically used to guide robots through
mazes so they have a description of
their maids the world some actions that
they can take into space and then they
have an initial state which base
it is the coordinate where the robot
starts out and then they have goal
States which is set of patients with
robots should hang up in and then the
osh the planning system and the panic
system gives you a path which is
basically a sequence of actions and then
this implication that when executed on
Rover will get the rover from its
initial position through a goal position
now we've transferred this model to
software testing and we've said well we
describe the software system of the
world the initial state is where no
object is created wall the goal state is
any state where there is at least one
object with corresponding parameters
that satisfy the method under test and
then you give this to the planning
system and you end up with the sequence
of instructions which basically is
already your test case and this can be
used to satisfy 3 conditions that are
tough to satisfy randomly this strategy
presented us with a few challenges
because the contracts that we find in
practice and we tested on real-world
software is they're not perfect they
don't look like you've jml facebook's
examples so what we needed to augment
this width was a learning process we had
the planning strategy team come up with
not the ideal plan because it turned out
that was not feasible but with some plan
and then as we were executing the plan
we learn about misconceptions we had
about the world that is the softer
system and then during the execution we
replan to make up for this mistakes and
this in turn was one of the motivators
what we said we're really flexible
execution mechanism where execution and
test case creation can be
we seamlessly and then there's another
strategy that were still working on
which is based on forward Testament now
the planner based strategy the thinking
of the planner internally acts backwards
so you start the planet internally if
Matt pull mode puts it puts himself in
the goal state and then goes backwards
in each step and as soon as it reaches
initial state it shows you the pan in
covert testing will do the reverse thing
only without the pattern we start with
integrated objects and then we move
forward only not only in a planning mode
but in real life and as soon as we think
that our attraction of the state we've
already seen it then we'll restart with
the news and the last strategy that we
also have already fully implemented for
viola test framework is that it's an
interesting one because it's an
automated strategy to support manual
unit test cases so with manual unit test
cases I mean the irregular actually kind
of styled test cases in order to stay
true to the original idea of push button
testing there were a few things though
that we needed to do it the way they can
use it now is that you put your manual
unit test cases into your system that
you're compiling to build your
application and then you ought to be the
tester will protect the all manual unit
test cases simply by the fact that they
all inherit from this test case possible
and then in the next step we still want
the user not to tell the system what
test cases to execute we're still
looking just to give the tests hope we
want to want the user to say well I have
changed this class please test it we
don't want to tell them let the user
tell all our test what test cases needs
to use so all of this the manual testing
gee thanks but only the inheritance
relation but also the association
relation to find relevant test cases it
basically goes ballistic test cases and
looks what types do they exercise and
hit the type that the exercise is in the
past stroke it marks it as relevant and
then before it does any automated truly
automated test case generation you
execute the set of relevant as cases now
this this strategy is important because
it closes the loop once an automated it
not only supports the existing manual
test but he also closes the loop that if
an automated strategy reveals about in
the form of the script you can downsize
the script to a reasonable size and then
converted to a man unit has put it in
the system and the next time around
it'll be around as part of the manual
unit test integration with no extra
magic and for our implementation were
actually we're able to reuse the Oracle
that we've implemented unmodified for a
manual go to piston alright so much for
the core components that were your cloud
when test whether it test is packed with
very popular Pesky's pass or fail and
the strategies that actually come up
with the input data and the test case
itself and now we'll move on to the
supporting components that we found
necessary so I start with a picture that
will coarsely show you the architecture
of the auto test framework I'm not going
into too much detail here we're going to
see this picture again a bit later on
the important thing for now is this
dividing line here you see that we have
a master and an interpreter the
yeah the purpose of the separation is is
to have robust testing the master
process is the brains it knows what to
test it knows or at least thinks it rose
in order to test things what arguments
with knows everything everything it
doesn't know is actually how to exercise
how to execute the system or intestine
only the interpreter the the save or the
muscles notice so basically communicate
and in the artifice memory which is
communicated by standard inputs and
output channels requests the execution
and then interpret does that in response
back what we get here is the brains that
knows what it wants to do and what it
did already even in the case of the
disaster in the interpreter is able to
recover gracefully we're going to see
that in the next slide a little bit in
more detail another advantage is that
with a random based strategies we can
keep objects around for longer because
we don't have this notion of run a
single test case fall and run another
one it's all one seamless best case in
the end and it also allows this battery
execution of instruction per instruction
is seamless integration or into leaving
between test case creation and execution
like the planning strategy needs so if
you will see a scenario of how the test
driver the monster communicates with
interpreter in the beginning that the
test driver starts off with the
interpreter and initializing and then it
sends a request to invoke connected
which interpreter will do and then it
responds back with the status message
which is basically either guess the
message completed successfully here is
the output or no it triggered exception
here details about the exception
everything is fine the test fabric
records this information and goes on
with the next invocation request it does
that amount in this scenario at this
point of facial hair either the
interpreter is shut down completely or
it goes into a state from which it
cannot recover anymore not the test
driver in such a case will wait for a
certain time off and then assume that
the interpreter is of no use anymore it
will stop the interpreter and start a
new one and then the first few times it
will probably try to test the method
that just the horrible things again and
if these things have repeatedly
eventually it will move on to the next
method important thing is that all the
information from the test testing groups
out so far I'm still there when we first
experiment with the random strategy we
had a model where we first create a set
of objects in in the pool and then we
did a lot of diversification the in the
sense of method calls and we found that
before we came to the actual testing
already with each time kill the pests
can cross and will net with never any
get any results using a setup like this
we can we can get results in any case so
now let's come back to the architecture
picture here you have two inputs it's
the same thing as before the system
under test it's basically the ASD which
all of his part is here then you get the
test scope in the set in the sense of
the set of conscious that you want to
emphasize testing on and the system
error test is passed to the strategy the
tests focus pass to the strategy
and the system our test is also passed
to the interpreter because this one is
actually the one executing it so it
needs to know about input now inside of
the master process there are a few other
interesting components this is strategy
or several strategies that are
replaceable that look at the system a
test and then decide how to test they
forward the request is the proxy because
you don't want to serialize it part is
the answers from the interview all the
time is that this is outsourced to a
separate component and then the proxy
returns the result if asked for data
strategy and also took the article which
that judges what just happened is either
a bug or not and then generates the
results accordingly alright so again
here would be the location of the
auditors full you start out with the
common line tool it David the assembling
description the computation file and
then you tell it what to test from the
system that is described in the sending
power um if you if you do this in a
practice and if you give it a list of
many classes you'll start to wonder in
what order to test them and so what
we've got for audit test is also not
just please execute then ten thousand
tests but instead please test for 30
minutes or 24 hours because for example
if you want to test over lunch you're
not exactly sure about before how long
ten thousand tests were going to take
but you know that could be back I don't
know half past one so you give it a time
up and then we've implemented the
scheduler here that basically fairly
distributes the testing exercising on
all the methods in your test using a
very simple scheme so you assign every
method a static priority I have the
priority the more often it will be
tested so here for example we would have
bank account deposit with the static
priority to
it would have strained filled with the
static relative one and spring wipeout
with aesthetic privateer one but if I
default all methods from all constants
get the same priority that you've
mentioned in tesco and then a the first
that use you assign there is another
concept of dynamic gravity the first
step is just set the dynamic priority to
the corresponding static guard and then
you have a priority queue which always
gives you the method with the highest
dynamic priority and use exactly that
one to create the next test case for and
once you've done that you decrease it's
been a parity in the case of the example
here things would go this way and once
you've reached the state where
everything is zero well you just reset
and unless your static priorities are
very high so that executing them one
time will take longer than the whole
testing session this will guarantee some
kind of here all right so what happens
when we do find bus in order to
facilitate long time testing we're
trying to do as little things during
testing as possible and to do everything
that can we we can outsource afterwards
to actually outsource afterwards the
idea would be to be able to test to do
not increase memory as we go so we can
extend the time of testing because of
this what we do during testing is we
just log all the communication between
the master and the slave and we put it
in a file and we keep on testing and the
actual judging the job of the Oracle is
done afterward in currently basis from
this log file because I by reading it
you can get all the information that you
would have
during tributions and I'll suppose you
found the bug the strip might be very
long the first is at a Margaret
producing example something you want to
give to the user and say here look this
is wrong your software please go and fix
it it might be very large in nightly a
few thousand lines of code igniting even
longer if you tested for long long
enough so it's important here in any
practice quite when you manually look at
the cases the minimal test tester
typically in the range of three three
two pipelines that are literally so
they're significantly more so what you
do want to do here is you want to
minimize your witnesses and then from
the really nice witness you create an
annual unit test case and you put it
back in system so how do we do the
minimizing well with a pipe technique is
called static program slicing it's it's
actually very simple when we look at the
example from before where the deposit
would throw down the balance to below 0
we said this would be the minimum test
case the slicing would implement that
doesn't detect this has tasted in the
next one that is not much bigger what it
does is it starts at the light of the
problematic line and then it works its
way back backwards well it's easy we
need weed for free to reproduce this
test case so it marks the previous time
because it also deals with be free in it
this had better not have been necessary
to move me three interstate so that the
bug actually is revealed and then it
goes forward while again III were
interested that of course we're
interested in this line because it
creates me three but there's another
important thing we learn here and that
is in order to create we three we do
need me to so it puts me to up on his
agenda and it moves backwards and says
will also be to hear was interesting
because it had changed and then oops
of course we need the creation will be
too but everything else not is not
needed for the test case and this is our
way to to minimize the test cases and it
works quite effectively in practice now
it needs to be said that this
minimization is not sound so in some
cases it can be that the original test
is virtually produced a bug and the
minimized version does not advantage of
the slicing the wood that we use is it's
very fast it's very effective because
it's very possible now in order to
filter out those attempts of
minimization that are not do not
reproduce the original art which is a
give that minimized example interpreter
to run again and see whether the same
exception is thrown of course it could
be thought of here that if you do
recognize a case where minimization was
on some we employed longer running more
for a process to minimize the test case
but that's not not increment at the
moment and actually we have
concentration so to sum up the
architecture of auto test we have a
scheduler in the form of a priority
queue we have several strategies
implemented the random strategy the
adaptive random strategy planning based
strategy you making use of a planet of a
toll from the AI domain as strategy we
go forward testing and to integrate many
human test cases into our set then we
have an Oracle which is based on
contracts it reveals bugs automatically
if the source code is equipped with
executable specification and then in the
end we minimize our test cases because
the
end up being very very large and we have
an interpreter that we tweaked so that
it provides a very flexible vehicle for
the strategies to work with right this
brings me to the demo I haven't
mentioned yet auto test is a release
tool you can get it from this website is
released in both binary and open-source
month it's released as open source you
can get the binary or the source code
and play with it it's released in the
license that it's not listening without
advertising but is it cool and so you
can basically do whatever you want with
it all right so here's the demo I'm
gonna invoke it from the common line
similarly to what I've shown you in the
side so this is the name of the tool I
give it the variables option this is
just so that you see what the tool is
doing while it's doing it then a little
cheating here and saying just test
basically this keeps the step of the
interpreter compilation and generation
which I've done before to save time here
on the little briefer and then I specify
a time out I say please stop after five
minutes and then I gave it the system
that a spell which contains the list of
directories that container houses I want
to test and then I say please test pass
bank account and clustering and we'll
put in our paths linked list to the set
as well and executing a departing the
system now and then well
that's so let me just said i think i
forgot to set some environment variables
and it's using them the wrong version of
the tool let try this
No
that's interesting
um
well
it's just
I just did this right
okay unfortunately something is not
working here I can't fix another expert
in this one here no no that that one
should
I just
you know
no I'm really sorry it despite me but it
worked this morning when I tried it last
a few um well it didn't work I have the
results pre-generated for this case so
what it does it generates a set of HDL
path
of this way
okay so you see the bug statistics here
these were the concert that we selected
for testing and in these five minutes
that with children sister on the testing
coil we've discovered pests in all three
of these classes in class bank account
you can see the positive method and what
you see here then is just it already
extract test case to go in here this is
a knife Olympics but it is really looks
just like a manual unit test case so you
can see that it's already minimized to
those three lines that create well
actually the bank account in the example
is a little different it doesn't take a
strain it takes a person as a barometer
if it creates a person then creates a
brown bank account with the person and
then it deposits a negative amount of
money and you can see from the variable
number here e 66 and he sits 67 if this
happened actually somewhere down the
road and has only later been minimized
in the other constants we also found
some facts I can show you results here
to look exactly identical so for example
here we create a new string and then we
call it that and this is actually work I
know of we've reported this it you can
look at the exception trace that's also
provided here and you'll see this is a
case of a nested precondition valuation
because the nap in time in turn calls
chair and then with a precondition
violation in a similar vein you have sex
with men a unit test so manual grading
tests were selected that the system
irrelevant and we have a few bucks or we
go through this as well at any other
section called other possible since we
have to step that we call
diversification
methods are called that were not
originally going to be tested and in
some cases we do find bugs during those
method calls because they have great
condition post conditions as well and
then if we do find those parts we're
marking just as well okay um let me go
back to the slides from this very
successful presentation and showing you
experimental results that we've
collected back in in Zurich so we run
this pool on quite a few libraries here
are a few of those results that we have
we've run it on Haifa base which is
basically the Eiffel standard library
we've read it specifically and with a
lot of running time on basis structure
which is this data structure library
from the standard library I'm confronted
in library called google map which deals
with mathematical things and then we've
run it on an application called dr. C
which parses see declarations and then
is priced and strike than to you in
plain English and then with with reveal
whatever we found here we did this using
the random strategy only and I'm not
going to read the numbers to you but you
can see that even though it's just a
random strategy we already revealed
quite a few problems here in the source
code
um all right so to sum it up I've
presented to you the auditors framework
it's a push-button testing tool using
contracts and the actual testing
strategies to come up to come up with
with the test cases are pluggable in
this in this framework we have several
strategies already or in the works we do
find real words whenever somebody gets
us off to run we have robust and
flexible execution pool we try to keep
objects around for as long as possibly
intensive good idea we tightly integrate
with manual test cases and we minimize
the test cases again because we keep
objects around for very long time thank
you very much for your attention are
there any questions actually I have the
mic so I'll go over the first question
um if I am sure summarizing and the
first of all thanks a lot for the talk I
think it was very good but to summarize
what the software actually does does it
is it safe to say that it's it's an
automatic test case creator by sort of
inspecting code and given something
constructive the code it constructs test
cases from it is that does that
summarize it well yes ok so then a
follow-up question to that would be have
you heard of the software or this
company called agitar that has something
very similar I think is there any
difference in the style or is like what
are the differences between autodesk and
something a gadget on so the actual
strategies i think are different and so
I'm not aware how far as user has this
framework aspect to actually place the
the strategies they use so actually I
got that part I know I know that they
don't have blood of those strategies
which is something that I saw that your
framework has that's actually good
because one of the drawbacks of
agitators and then maybe for the folks
who don't know it's it's basically
software that can take in a piece of
source code or system and agitate the
source code to kind of figure out
possible cases that can great each line
of the code or in this case methods but
what they don't have is something that
auto test has which is plugged the
strategies which is kind of a good thing
right but I just want to know in terms
of the sort of the general approach is
there any different so I think it's very
small anything there's not only a
generic many people currently are have
found or are working I'm very
interesting ways to come up with those
test cases and we want to do that too
but we also want to try to remind a good
ones and see whether this brings is even
forward because very often individual
strategies have strengths very good
friends but also weakness for example
somewhere good with structural and
artists and we're good with reference
structures things like that thanks
I think the big difference would be
behavioral analysis versus static code
analysis really is a key difference
whereas there looking at behavior and
how it performs whereas a tratar is you
look at the code and saying okay how
could I break this so they're equivalent
to a code inspection whereas this is
black box testing so in fact whether you
to refine what you say in whether you
can black folks testing white box
testing the strategy stranger who either
andreas authors you remember a fine not
comment upon just a follow-up comment by
avatars into that strategy I'm a
five-way full schools on the technical
advisory board so mr. strategy does not
require the presence of precondition for
sedition and invariance instead confers
things that are like that by observing
the prosecution montessori uses
collection my question Mia's I was
intrigued by your minimization should a
graph where you said you're basically
computing some pitiable distances of
trying to increase diversity of tests
doing that then your minimization
strategy for slicing those two things
out want some clarification on that
removes basically different approaches
or they two scientists think they think
I think they they are orthogonal with
each other so the the adapted random
part is concerned with the selection of
input during the time where we create
this continuous long test case is
long-running test case and afterwards
after execution finish we take this this
very long test case and reveal bugs by
looking when
happen and then the first step we take
we create a witness from that it can be
very long AZ play it is from the line
where we discovered the bug to the point
will be last we started in the
interpreter and then we take this very
large piece of witness and minimize it
using static sizes there's an answer
your question caller ID a hybrid
graphics and a large know if there's any
hope of extending this framework for
lower languages like C I think I think
as long as you support contracts or come
up with interesting ways to to find
cruel and things automatically there is
there's nothing wrong with the binds to
the language with lexi would you be
ready to take to a challenge so I think
I think we're busy enough words with the
past we have so far
you won't mention the spec sharp early
on in the presentation has this
framework already been extended to
encompass that or is it plan to know
we're currently just concentrating hi
alright I understand how you counted the
number of methods that failed the number
of failures so I went your deposit
method fails 2-1 it will also become a
flight attendant on chastity a little
false witnesses errors can be an antique
on notice is this exactly shown another
graph were we being isolated the bucks
and we showed the number of cars those
were less yep that are you talking of
Curtis boat bro foundation again right
how do you picture so i assume
integration with other languages it is
far more than simply being able to parse
how they implement contracts you
actually have to have code written in
that language in order to be able to
build a sort of testing framework so
excited you're good Bert what folks are
talking about other languages and
contracts and different languages are
implemented with a variety of different
strategies so i assume applying
something like this will require far
more than simply parsing how they
implement contracts you would access
what you have to implement like how you
create the objects for example in order
to be able to you actually have to write
out the code in their target language
yeah well in the language of the
interpreter so if you make it so that
the interpreter has its own little mini
language this is happens to look very
very similar trifle but you can of
course make it so that this interpreter
actually drives a languages that are
reasonably similar
andreas thanks very much it's really
interesting talking about you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>