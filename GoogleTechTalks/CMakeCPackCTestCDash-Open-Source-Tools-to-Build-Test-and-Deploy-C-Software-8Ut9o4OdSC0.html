<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CMake/CPack/CTest/CDash Open Source Tools to Build Test and Deploy C++ Software | Coder Coacher - Coaching Coders</title><meta content="CMake/CPack/CTest/CDash Open Source Tools to Build Test and Deploy C++ Software - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CMake/CPack/CTest/CDash Open Source Tools to Build Test and Deploy C++ Software</b></h2><h5 class="post__date">2010-01-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8Ut9o4OdSC0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome thank you for joining us today
we have Belle Hoffman from KITT we're
talking about the cool work they've been
doing on open source build systems for
C++ so without further ado Phil thank
you okay
my name is Bill Hoffman I'm from a
company called KITT where and I'm going
to be talking about C make C pack
C test and C - and these are open source
tools anybody can use them to build test
and deployed software C++ was the main
target but we can do other software as
well so here's a quick overview of the
talk the first thing I'm going to talk
about is kitware itself just a really
short introduction to give you an idea
of what the company is and what we do
and then I'll get into C make and the
the build tools so the company was
founded in 1998 the founders are five
previous employees of G corporate
research and development and it's a
privately held company we've never had
any debt so we sort of bootstrap the
whole company one-one contract at a time
this year I think we'll hit about
fourteen million in revenue we do print
principally consulting and grants with
some product revenue what we're
basically sort of a research that people
can outsource the research and we're
really heavy into open source we have
about 65 70 employees right now we've
been growing about 30% every year
there's about 25 PhDs in the companies a
lot of masters level very developer
heavy factor I think for the first five
years we had a part-time administrative
person and that was pretty much it
I used to run QuickBooks for the company
that was fun I was an accountant for a
while okay so what do we do what do we
do though well lots of hats at a small
company so what we've evolved into is
what's on the screen here this is our
splashy marketing PowerPoint slide so we
do a supercomputing visualization so we
do a lot with national
ABB's Sandia Los Alamos and our roots
are really in visualization the
visualization toolkit vtk was really the
core of the company it's a C++ toolkit
for developing visualization
applications we've done a lot of work
there to create parallel visualizations
so we can do things with render clusters
so they might have a hundred node GPU
available farm plus a thousand node
computation cluster and we can drive
that from a desktop and do rendering and
compositing back on the desktop or even
over the web and then we've also got a
real strong medical imaging group that
does some interesting stuff doing
segmentation and registration work with
medical data and we've also gotten a
little bit into the data publication
area where we can take these large data
sets either super commuting
visualization datasets medical datasets
and store them online get to them with
databases and then write applications to
visualize them and in the past couple of
years we started a computer vision group
as well and they mainly work in wide
area persistent surveillance so video
recognition tracking people and videos
and really all this is tied together
with our software process tools that
we've created that are open-source that
I'll be talking about so here's here's a
quick slide of the workflow that we've
created and the idea here is that we've
got developers they write their code
they check it into their version control
system of a month get SVN CVS the idea
is you know whatever version control
system you use and they check it in that
goes into a repository and then it goes
off to a testing farm that pulls the
code out of the version control system
and then sends that data to a web
application we call C - which is a PHP
MySQL lamp stack application that can
display the build result and this this
really came out of GE Six Sigma push you
can believe that Six Sigma was this
effort to I think Motorola started it
where they
try to get the defects in really large
manufacturing issues down to the Six
Sigma the standard deviations from the
norm so you want really few defects and
if you've got a big company like GE and
you want to push an initiative like this
and you're Jack well should you just say
well everybody has to do it from the
administrative staff on up everybody had
to take training in this and we were
researchers that a researcher who wrote
a lot of research code that you throw
away and it was like how how's this fit
us and but some of us really like
software and we like software quality
and came up with this idea of creating
well what can we measure in software
what sort of defects can you measure in
software well you can measure things
like number of build errors number build
warnings number of test failures test
timings does it change over time as the
software getting slower or faster and
then create a dashboard and a way to
look at these things and that's what
this system does and I'll be talking
about these tools so a quick overview
about that part of the talk first I'll
talk about building with CMake and what
the actual C make build tool does and
how it works and then I'll follow that
up with testing with C test and C - and
finally we've got a packaging cool tool
called C pack which can create
installers from your see make list files
that describe your build and install
tree so C make this is the C make
section it's a cross-platform build
system and I'll be talking about why
you'd want to use C make I'll cover some
of the cool features it's got and just
basics of how you would use it and how
you'd write an input file for it you can
get help we've got a book we published
from kitware called mastering C make
there's a web page seem a org there's
also a nikkie and a very active mailing
list if there's any questions I try to
make sure they're answered most of
sometimes I don't even have to answer
them anymore
there's a growing community yeah we do
I think so yeah yeah I think we're
seeing a lot and they can really help
out with we've got modules that find
third-party libraries so there's a whole
module directory for you know finding
things from Lib XML to other things and
I really don't have yeah well to find
software so see makes so it's got like a
find find the installed version of live
XML on this machine and I'll talk about
that a little bit more but that's
they've been contributing a lot to that
because I don't have access software I
don't use every software and there's
hundreds of packages and without the
help of the community that that stuff
would really not be as good as it is so
what is a see make or why see make okay
it's easy and it works well that's why I
like say a build system that just works
and it's easy to use cross-platform so
this this slide here shows a typical
project it's actually the curl project
it's an open source C thing for grabbing
a network activity on FTP you see URL
it's pretty neat package and it's pretty
common and if you look in the the things
I have highlighted in red that's their
build system so you can see there's a
make file and make all that am and a
make file out in I'm an AC local a build
comp there's an install that show and a
recon strip there's even a Visual Studio
6 DSW file something called make tgz
make installed errors and then down here
they've got a make file for Whatcom
Borland a.m. net where you get the idea
a lot of stuff and I guarantee you at
any one point in time all of those
aren't going to be working what happened
with the project someone came along and
said hey I'm using Crowe with net wear
and I've got this make file can I
contribute it to you and the guys sure
yeah cool we'll throw it in and this
stuff if it's not tested and not tried
every day it's probably going to break
someone's going to get a new version of
that compiler and in the in the light
blue there that's that's what it
requires to build it with C make so
there's a C make let's pop the top or at
the bottom there's a directory that has
a like one or two module
but it's it's really small and what this
allows it that group to do is outsource
this maintenance of all these different
things to the see make team so they can
not worry about how to generate a net
where make file of so you make supports
it
then the see make team is going to worry
about it and the see make teams can
worry about by looking at the dashboard
to make sure that it's still supported
Nimitz once it's supported it's always
going to be supported as long as we run
it on the dashboard so another reason
you see make its fast we try to make as
fast as possible this is a blog I found
off the web was a quantum GIS codebase
switched from auto tools to see make and
their overall build went from about 22
minutes to 12 minutes I think the large
part of the improvement here could be
the not using Lib tool which is
essentially a cell script which on
startup basically has to figure out
everything there's about your platform
and it's got information for all the
hundreds of platforms sports and has to
trace through all that stuff every
single time it goes to create a library
where as something like C make generates
a static make file once for the system
and then every single library that's
built in the system just happens as fast
as possible why you seeming everyone's
using it so in 2006 KDE switched over to
using C make as their main build system
and the KDE desktop for Linux and this
is a Google search trends that I like to
show and you can see we didn't really
even show up on the map although the
project's been around since about 2000
in Google search trends around 2005 2006
when the KDE guys started using it
people started saying well what is this
CMake thing and we've grown quite a bit
there's about 1200 downloads a day from
our website but it's also distributed
with major Linux distributions cygwin
provides CMake packages some big
projects use it Katie Second Life is
using it for their build system boost is
using experimentally we're working on
moving out on to their main system and
lots of other projects so what is it
drink here they actually become a family
of software development tools the first
one is CMake which was does the building
and the second one is C test C - which
does the testing and finally there's
this C packaging tool and it's under an
open-source license it's a bsd-style
license the history actually comes from
the insight segmentation and
registration toolkit this was an NIH
funded effort was a my familiar the
visible human project yeah yeah okay so
that Dan is here so the visible human
project was a pretty neat project that
NIH put on where they took a human body
after they died and right after death
they CT the memorandum PET scan their
bait every modality they could they had
at the time and then they froze the body
solid and sliced it up as thin as they
could and took actual pictures and this
gave a really good data set because if
you're you've ever done anything with a
segmentation and a registration it's
it's really hard to get ground truth for
this data if you just look at a CT scan
and you can't really cut someone open
and say did I get it right with this
data set they can't and they had
collected this data set and that was
great for science but the next step was
to help with the algorithms for that so
they've got this public data set then
they wanted to create a public
repository for algorithms and it's
written in C++ it's got quite a wide
user base now and it really advances the
state of the art in studying with with
that type of research in registration
and segmentation and we were tasked we
were part of the lead engineering team
for that project and I remember giving a
talk early on in the project I was
presenting my ideas and one of the guys
from Pitt raised his hand he says bill
why are you creating this this build
thing it's going to be that the itk
build thing no one's going to know it no
one you know what before we finish and
let me answer you it
you're not talking about changing the
way that people build itk you're
chanting about changing the way people
build C++ like yeah that's it that's
what we want to do
so that was a while ago and we're
getting closer to that so now I'd like
to talk about what I mean by that so how
do we change the way we build C++ with
seam ik so I saw a really good talk by
David Abraham's he's one of the lead
boost developers and he showed that
boost just explain what boost tries to
do in it and he had a real neat slide he
put up there any instance you know
here's java and here's all the classes
that come with it it was a network class
and there's just just tons of classes
you know hundreds of real rich feature
classes there's Python and here's all
the really cool stuff that comes with
that and here's C++ and we got an i/o
stream library kind of boring and then a
lot of extra stuff so and even STL was
added in sort of at the last minute I
mean it became part of the standard it
really wasn't vetted by any community
and boost aim to fix that problem for
C++ to give the community a place to try
the next things that are going into the
standard so when the next C++ standard
comes out the new innovations from it
well most of them will come from boost
so boost aims to give C++ a set of
useful library C make aims to give C++
compile time portability we can't do the
compile wants run everywhere but we can
certainly do compile it with one input
file and run it build it everywhere as
easy as possible and it really makes it
easy to build small build a small tool
that links to a large tool which is one
of our goals with itk so we created this
huge C++ library and you want the
researcher some small some grad student
to be able to pick it up and link it in
to his application really easy and you
can see so I've got the pitchers down in
here of all the different platforms so
we go everything from supercomputers all
the way down I saw a blog of someone
describing how to use C make with a
Nintendo DS so an interesting thing the
supercomputer probably has a lot more in
common with programming on the Nintendo
DS than the desktops in that they tended
a lot of them like the the craze or
something like that have very minimal
operating systems they don't have shared
libraries and you have to cross compile
to them so C makes got a pretty good
support for
cross-compiling as well so you can write
write your stuff and have it build on
any platform so who's involved there's a
whole bunch of users there's Katie's one
of the bigger well more well-known ones
Second Life is using an IT K of course
VT k our visualization toolkit pair of
you numerical package from Sandia Labs
called free Leno's Scribus boost my
school's using it as its build system
I'm currently using it just for Windows
although I saw something on their list
were there why are we using this on UNIX
and I think they're moving that way LLVM
which is the next very familiar with
that you're yeah that's so the next big
thing coming in C++ open source
compilers apples work on that and
they're using C make as it's built as
their build tool and this this list on
the right of the supporters kit where of
course is very interested in keeping C
mate going army research labs national
library medicine Sandia National Labs
Los Alamos dynamic so the idea to show
this slide is just to show that there's
their support behind it and there's
funding going into it so it's not it's
not a stagnant project and it's not a
hobby project and there's probably three
or four full-time developers actually
getting paid to work on C make and in
the C test and C - and the whole tool
suite so it's it's here to stay and it's
got some legs so the documentation we've
got the book you can buy we're working
on the next version of the book it's
it's going to be out in the end of the
year it's the web page in the wiki in
the mailing list there's full reference
documentation online it's generated from
the code itself it ships with HTML man
pages command line help there's a nice
tutorial that's included in the testing
tree tests tutorial we try to test
everything we do even the tutorials you
can create configured files with C make
you can do optional build components
it's got good support for install rules
and and doing test properties you can do
system introspection check for the exist
so you're not programming to a
particular system but more to a
canonical system you can instead of
writing you live Apple in your code you
can say if this feature exists and then
it's also got this packaging tool called
C pack and C test and C dash
this is other features there's a one
simple language for all the platforms
works on Windows Mac Linux all the UNIX
variants HPC high-performance computing
or embedded platforms via cross
compilation we add this slide here we
did pair of you which is our
visualization tool for high-performance
computing and we needed to run it on a
Cray xt5 I believe and we wrote the
cross compiling part of C make for that
project and we it uses Python and
pythons build tools we looked at the
build tool tried to get it to work with
a cross compiler at the end of the day
it was easier for the developer working
on that to just write C make files for
Python and I think he had it done within
an afternoon he had it cross compiling
it generates native build system so it's
not an actual build tool it's a meta
build tool right now we generate make
files for new make and make Borland we
do K develop eclipse visual studio 6 and
up including the beta the 2010 Xcode
projects this next slide is really
important I think we handle out of
source build trees very easily so you
can just you know make directory build C
make dot dot slash pointed back to the
source tree so on my laptop I might have
you know three or four compilers
installed and I'm running off the same
source tree and doing a build with each
of the tools I want to test on there's
interactive configuration via a
graphical user interface written in cute
it's forged multiple configurations
debug release etc there are built in
rules for the common targets so creating
an executable is just a real quick
command creating shared libraries or
dll's cross-platform creating static
libraries or archives and we also have
good support for the Mac or the Apple we
can create OSX frameworks or application
bundles just with that you know one
extra little bit of markup in the
library definition but if that's not
enough we can also do custom rules now
part of what we did
going back to vtk days
always had our C++ automatically wrapped
into other languages so BTK since before
2000 has had 94 has had a C++ parser
built into it that parses just the
header files and then outputs into Java
wrappers or tickle or Python wrappers so
we've always needed a complicated build
system that can handle the concept of
building some code which would be the
generator then later taking that
executable that was built and then
running it on part of the source code
for the project generating more source
code and then compiling that source code
getting that to work would say something
like a Visual Studio project by hand is
somewhat tedious and error-prone with C
make you create a couple custom commands
and it's going to work across all these
platforms I talked about it's going to
work in Xcode it's going to work in all
the visual studios it's going to work in
make files so it gives you you know it's
got a lot of power there and it's also
got configuration rules for doing system
introspection it's got its concept of
persistent variables these options can
get cached so I really don't try to
avoid the concept of environment
variables see a lot of projects where
you know to build this project you set
these five and six environment variables
and then type make and if you forget to
type forget to set them or or maybe you
set them the first time you type make
and then you go to a new shell and
they're slightly different any time make
and things start blowing up and you're
scratching your head on what happened
when C make find something those fine
package I was talking about earlier it
stores the location in a persistent
cache file in that build tree so you can
have the multiple build trees they can
have different configurations different
things they found and it's all stored
there it's not stored in environment
variables and it's not going away it's
tied to the build tree no it's not yeah
it's it caches it once it found it and
then you can go in with the cache editor
and remove it and have it find again if
you wanted to but again it sits there
for performance as well it also has a
really good implicit dependency
generator for C C++ and Fortran a lot of
the supercomputing folks are still
writing a lot of Fortran they're even
writing new for transporte and 95 and
stuff and
for training actually has this module
system just sort of like Java I think
that's what they stole it from but it's
it makes it a real bear for a build
system because essentially what happens
is instead of just saying you include
food at H you say use module B all right
well you never write B dot H when you
compile B it spits out V dot mod so the
compiled order is important if you
compile a before you compile B and a
uses B it won't compile so originally
one of the guys at kitware converted a
that chemists or physicist code old
Fortran code and he said it's blaming
how to use it and he said you need to
run CMake and then you type make a guy
ran C to C make and you type make and
you went it's built I only had to type
make once usually I take it four or five
times because that's that's what these
Fortran guys do anyways we do dependency
analysis and this also is real important
for developing because especially with
c++ if you have a header file that's out
of date with the source file and your
build system lets you down you've got
one object file that thinks a class is
100 bytes and another one thinks it's
104 you can get really weird bugs and
you walk into the debugger and you're
really scratching your head now kind of
stuff can waste hours at developers
times
yeah it handles that yeah
you
you
fair question we use we use see make
actually in the make files at least at
build time so make will call back on see
make to have it do some dependency
analysis and also when you create those
custom rules you have to just you have
to describe your inputs and outputs so
we know we know something's going to be
an output and then when we're scanning
for dependencies if we see one of those
outputs show up as as an input in a
regular dot c file it knows then that
that's coming and it does sort of a
multiple recursive make kind of thing to
make sure that everything happens in the
right order we do call back into it from
other environments as well when we need
to so it can get around problems and so
so for instance in Visual Studio if if
you change it seem a closed file it will
notice that when you say you tried to
build in Visual Studio it'll say hey
look the seem a closed file change it'll
rerun C make and then C make an actually
it'll go back and detect or running
Visual Studio and see if it matches that
project if it does it actually loads
some macros that keep it from saying you
know reload reload reload reload it can
have it to one reload and resume the
build so we've got some Visual Basic
plugins yeah we haven't had to do it
with Xcode in that yeah ok we also
handle a link to pendency so inside your
project you can say you know add library
B and then you can say library be links
to C and D and then if you create an
executable you can just say you know
link to B and it'll pull in the other
dependencies and it makes it easier to
handle a large complicated projects we
also support a ordering of link search
paths and building our paths into
executables so you can run out of the
build tree without having to set load
library paths but then when you do
install it can actually rewrite the art
paths and I it actually edits the elf so
it's fast during the install it also has
you know really fast make files it does
nice color output you can see
on the slide here it's got different
colors for different types of builds so
let's C++ building an object shows up in
a green linking something shows up in
red it's get help targets you can type
make help it'll print out all the
targets you can do things like make food
I it'll pre-process it and it will
handle that cross platform and you can
do assembly targets as well the input to
C makes what does it look like it's a
simple scripting language with built-in
commands for common rules so here's an
ad library my lib my live dot c XX or
add executable and this bottom example
here shows sort of the power of this so
I'm in what one two three six lines I'm
saying that I'm telling it which C make
I want to use I'm giving it a name of
the project and then I'm saying fine
package boost required with threads and
signals and then I'm telling it to use
include directories dollar boost include
d'oeuvres and then I'm adding executable
my executable with some C++ and then I'm
telling it to link to the Bluths
libraries and that's going to work on
the Mac and work on Windows it finds the
installed boost if it doesn't find it
you can tell it where it is by editing
the the cache through our editors if
it's installed in the usual location it
should be able to find it it's
installing C makes so one of the things
that the biggest roadblock to adaptation
of C make is well gee now I have to
depend on C make so we try to make it
really wicked easy to get C make and
install it so on
seema Korg's download page we've got
binaries for every unix
5 or 6 units like HP and IREX even we
get three or four downloads a month or
something for these weird platforms but
we do it yeah and also the major linux
distributions these days especially with
cadiz adoption you can usually just say
app gets emic but we provide the
binaries for all the platforms and we'll
keep doing that installing it you can
grab a windows binary installer there's
Linux binaries and the source can be
bootstrapped on any UNIX platform so
this is really what the process does so
when you when it configures it will read
the cache file that I talked about
if it exists then it will read the see
make less files and they can include
other see Nikolas files and have sub
directories and then we'll write the
cash back out and this can be an
integrative process because you might
need to go you can imagine a thing where
someone clicked an option that said use
MPI well now it's got to find MPI or
enable parallel and then it turns
something on and it exposes some other
option once you're happy with that it'll
write out that make files for projects
and these are what the editors look like
there's a graphical one written in cute
that has nice little buttons and stuff
to click turn things on and off and
there's also a curses based one if you
don't have a windowing system and of
course you can run it from the command
line we you know people get scared they
say you know do I have to run a
graphical thing to build my toilet no no
you can run from the command line if you
you know if you know the exact options
you want and you're not and you want to
automate a build or a lot of people use
it like this it also has some you can
write scripts in the CMake language and
see make has some simple commands like
see make - e things like copy remove a
file compare get the time and this is so
you could you can imagine building up a
whole nice cross-platform build system
and then calling CP in the middle of it
that's not going to work too well in
Windows right right so so the only thing
we want to require is C make and the
only thing C make requires is a C++
compiler so if you get a C++ compiler
you're building super elf less code you
figure you have to have a C++ compiler
so that's that's our minimum requirement
is a decent C++ compiler and you can
grab the binary but but we build this in
and that's that's why I'm saying that C
make is actually called by Visual Studio
by a lot of projects to do to do these
sort of cross-platform things that
aren't easy to do cross-platform there's
also a scripting language you can do it
C make - P and write C make language and
it wouldn't generate a cache ignores
command specific to building like add
library or something like that if you
want to do something a little more
complex
but again we want to try to avoid having
dependencies on other bigger systems
okay that sort of wraps up the seat SC -
part of the talk I mean the C make part
of the talk what we're on to the seat SC
- so this slide here is a it's actually
a pretty old slide it's from a book from
1999 and it's showing the benefits of
automated testing so it's showing over
time that if you did a little bit of a
long test case let's say you had a test
case that took 45 days to complete
complete each manual retest over over a
decade your manual running those tests
every time you did a release is going to
cost you about 97 percent more than if
you had some push a button and have it
go kind of goes without saying but it's
nice to show people this and a lot of
software that's out there especially
open source stuff doesn't necessarily
have as much rigorous testing and our
system is built around that I mean the
developers we don't we don't wanna
create a system that was overly
intrusive and it's it's an easy system
to use it's easy to apply on projects
and the developers actually like I mean
we've had interns come on and you know
do code coverage which sounds like a
really boring job but just really neat
when they can watch every day they can
see their progress and hey look I got it
to go from you know 75% to 78% today by
adding these these tests so it gives
them something to look at something to
work forward work toward and it's a neat
stuff so this uh this video here make
sure this this is a running a nightly
regression test of a pair of you and
we've recently added into CTS the
ability to do parallel so you can say
see test minus JN and R and this is
running on like a I think an eight-core
Windows box and it's doing a minus J a
and running our application here and
this is doing screen captures in the
background and making sure the images
look like what we expect and this stuff
goes
every night you kill one bunch of
different platforms and it we can take
advantage where trying to make it
scalable so they'll take advantage of
all the cores that are out there
yes you can add test dependencies so I
was one of the first things we added
this and then you run itk and you say go
and like gee why these 50 tests fail
yeah that actually happened with pair of
you yeah they did test case opened up a
socket testing client-server so you can
add dependencies on the tests and it'll
make sure that they it blocks until they
they run
you just say I can only you can only put
dependencies on tests like you know test
test name depends on some other test
name
yeah there's a flag you consider
property you can set on the test that
says I need to be run by myself but you
can also say I need to be run after this
test because a lot of times people write
a test suite where the output of one
test is used as the input to the next
test and they just assume that they're
going to run in linear order and you can
set up that that dependency as well but
you know if you've got ideas too I'm
open to ideas of you know adding new
stuff into it as well the executable so
to create a simple test you write add
test you give it give it a name and then
some executable to run in some argument
it's expected to pass if it returns zero
you can also set it up so it will pass
based on some regular expression
matching of the output
you
you
flakiness you can set expected to fail
yeah although that's a really good idea
because we've got some tests like that
as well
ya know that's a really good idea and
we've actually got a few of those tests
and see Mike I think right now the the
packaging on Apple for occasionally just
doesn't work in right all right so to
run the test you you run there's an
executable called C test which is
delivered with the C make binary and it
can run either for this continuous
integration testing which we'll get into
how that works as a client for C dash or
you can just run it from the command
line unite now C test before you check
code in it can be used on C make based
projects or even not C make British
projects if you wanted to so here's the
dashboard that I've been talking about
if you look let me see if I can get this
so down down this side here are the
build names so the neat thing about this
testing system I think is that it's very
easy for outsiders to contribute to it
so oftentimes some of might come to me
and say hey can you porch C make two to
this and I go well yeah if you'll run a
dashboard because otherwise I'm wasting
my time we had a guy there's a guy down
in Australia that uses qnx he's using
vtk and QNX operating system he does
these room size robots that do mining in
Australia in the outback and he's big
see Mike fan and he came years ago he
came to me and said you know hey can you
get C make working on Q and X I said
sure if you run a dashboard he's been
running a continuous and a nightly
dashboard for years now and I've
actually developed stuff for Q and X by
checking in code with a couple print
statements you know if def Q and X wait
five minutes look it is result like
that's what it's doing on that platform
and and you know he's different time
zone and everything and I've been able
to work with it without even bothering
him and the nice thing is I know it's
going to keep working as soon as it's
off the dashboard that you know we're
going to break it if you're not testing
it good so anyway it's down down this
side it's the site name over here and
you can pretty much pick that
summer kit where some are not this is a
build name so this one is a it's a Linux
64 there's a Darwin which is a Mac and
other Linux 64 another couple Mac's
we've got a style checking test that
checks the C++ coding style and then
over here it's got the update column
which is what files were updated from
the Virgen control system there's a
master one up here you can look at the
nightly changes this is just what
happened when it and the nightly builds
actually pull from you set a timestamp
so you say 9:00 o'clock Eastern Standard
Time is when I want my dashboards to run
and then a C test client looks at that
configuration file and it pulls from the
version control system the a copy of the
code that matches that time so each one
of these is testing the exact same
snapshot of the code you can set it up
to do revisions yeah if you want but the
nightly ID even if you're on say a
branch you want to still pick a
specified time you can also do
experimental builds which are just any
random thing that pumps up and you can
also do the continuous builds which are
set up to run you know as soon as
something's checked into the repository
yes
yeah you can tell it to remove the whole
binary tree if you want usually you do
an out of source bill and then you can
set a flag oh to clean clean build tree
and we'll support the updated stuff this
is a project we did with Sandia National
Labs and they have a project called
truly knows and the idea here is they
have about 42 sub projects and they've
got teams of people working on each one
of those sub projects and the guy who's
working on cath hose or I Petra he
doesn't want to hear about the problems
in Zoltan he doesn't want to get emails
from the dashboard system when Zoltan
guys breaks on he doesn't care and it
doesn't affect him but again someone
might care about all of truely now some
want to be able to see it as a whole and
we created this concept of sub projects
in the dashboards so that the you know
the tough
sky can set up you know I want to get
emails when anything bad happens on my
project and not what anyone else has
something so this so it can be used to
scale the really large projects
it also supports these query filters so
you can set up you know show filters or
hide filters and then you can do things
like you know show all the show this
build name matching this over this date
range you know I want to see this
particular platform for the past five
days and it'll show all the builds for
that or even I have a custom one that
shows me basically all the errors I can
I can click on it I save it as a link up
top I think it yeah there it is
I've got it saved as a link up here on
my taskbar see make only errors so I
click on that and it's a saved query you
can click on a create a hyperlink from
the query it's a I'll PHP stuff pretty
straightforward web stuff but it's nice
stuff to have another thing we recently
added in Prior versions of C make we
always did essentially log scraping and
for some of the build tools like Visual
Studio we still do log scraping which is
let the tool run and then have a bunch
of regular expressions that pull out
things that look like an error you know
look for error colon or whatever and
which is okay but you might you know
something like this particular one I'm
here with C++ if you have one error
you're likely to have 50 in the file and
then what what this does basically is
you can stick in a mode because we don't
want to pay the performance every time
but if you're building it as a nightly
test you can set it up in a mode where
it will essentially wrap each command in
the make file with a C make - - run the
command launch the command and it
launches it to that and then if it
returns a nonzero value it knows it
failed and then it can store the
standard error and standard output and
show the dashboard as one single failure
instead of lots of little failures again
this isn't supported across all the
build tools we have but at least on the
make files it works we also have a
coverage built in so there's two tools
right now that we support for doing
coverage analysis the one is standard G
curve
and the other is a commercial tool
called bullseye which does branch based
coverage which is actually a kind of
neat neat concept to it instead of just
showing number of times a particular
line of code was executed it'll show if
it's got a branch like down here it's
got an if statement I don't know if you
can read it but it's got a capital F
there meaning that it was only ever
fault when it was run and again these
tools are things that developers every
knows it's good to do the code coverage
and I think I ran G Cove once so C makes
essentially an expert system that's it's
stored this information it knows how to
run G cup for you set it up and then all
the developers on the team can see their
coverage without having to run the tool
it's run for them every night you can
watch the coverage go up and down you
can see it when new tests come you can
even have it send you email when code
particular file is low on code coverage
for the testing and we also do the same
sort of thing with valgrind and purify
so you can see and the again these are
tools when do people unveil Grimm when
it's something weirds happening right
but it's not necessarily part of every
developers you know before they check in
their code do they always run it maybe
maybe not
you don't know with this we know we can
say you know when that when that showed
up you know when it crashed we go right
back to the dashboard
why didn't valgrind catch that oh we
didn't have good code card then you go
back and you find out it wasn't covered
and that's why it wasn't wasn't caught
but again these are tools that people
know how to use but they might not use
it every day because they're busy they
want to get stuff done and the sooner
you catch bugs like this the better I
mean as soon as soon as someone's
checked in that bad you know
array bounds right or memory leak if you
can go back in this system even if they
didn't catch it you can go back and see
which files were checked in that day
it's a lot easier to fix them if you're
sort of scratching your head trying to
figure out gee no one's run this for a
couple months and you know as you get
the idea it can send you emails this is
a typical see - email notification
saying something like you know
a submission - si - for this project see
Mike has failed test you've been
identified as one of the developers to
check something in and then it'll give
you a link in a short little description
and if you want to try it we've got a
hosted at a kit where we've got a seed
org si - public you can just click on
there and say start my project and it'll
create a si - thing for you and then it
creates a configure file that you can
drop into your scenic list and you can
get going with it pretty much right away
and it's all open source as well so you
don't need to use us but if you don't
happen to have a lamp stack webserver
lying around you can uh you can try this
had the email know which test failed so
when it when the client did a build it
traded an XML file that showed which
tests failed sent it up - C - C - said
are these tests weren't failing the last
time I got to build from this machine
those tests weren't failing for the
whole process so when I run C test if
I'm doing a nightly or a continuous
it'll collect up all the test results
and put them in an XML file and each
test has a name so you can see here like
system information new that's a test
name in C make
yeah
hmm
you
well there's two ways you can do one is
an executable return zero one or two you
can do some sort of regular expression
matching in the output of the program so
you can say you know set test pass
regular expression or set test failed
regular expression those are the two
ways you can make it
yeah there's a one-to-one
and then it looks at the version control
information the update line to see who's
checked in code now sometimes you'll get
some false positives here I mean you
can't narrow it down you know if 12
people checking code all at the same
time and one test starts failing though
I'll get the email but they quickly
point the finger at the other guy figure
out wasn't me
you
so you have like one test that runs
right do you run it as one big
executable
right
you
you
yeah be good things to look at I believe
there have been some people that done
the Google test integration with the C
test I don't have slides on that right
now but it's been done but yeah that's
that's great a great idea for future
work yeah a lot of times well we have
like an AI TK we create one test
executable for lots of it contains the
ability to run lots of tests but then we
just run it multiple times for each
individual test but I suppose you do
I guess the danger of running them all
at once if there's a crash you pretty
much lose right listed one talked about
that so the overview of the C - testing
we've got a purify valgrind support
coverage support through G cover
bullseye this next bullets sort of a
thing to think about you want
configuration coverage it's not
necessary part of C maker T test does
its automatically for you but if you
look at our dashboard you can see we're
testing almost all of our builds have
spaces in the past because that that
always seems to trip people up and if
you're doing a build system you
definitely want to be testing that and
then you also want to be testing
different versions of LSE's I've got a
stack of Mac minis every time there's a
new version of Mac comes out I buy
another minion stack it on top of the
stack and run the nightly test with that
and then there's you know making sure
you're covering all the libraries and
options within your code and then the
other this final one C - I mean it
doesn't have support for actually doing
the image differencing but it can
support you'd put some XML markup in
your output or your program to tell it
that you know here's a base test here's
here's the image I got and here's the
difference and then C - can display that
online this was just been going on with
vtk since you know a long decade or so
and we found out early on that you know
all OpenGL implementations are not
created equal there have and sometimes
validly different so it supports you
know you might have a you know something
triangulates one way and
something goes the other way and it
shows up as image difference but it's
really not a failed test so we can
support multiple valid images okay the
final part of the talk is CPAC sure
you
right now it's a serialization on one
and using the course although we test
things like paraview which use MPI that
runs MPI launched to run run those tests
but we have been we've done some
experimental work with hooking together
with some of these batching systems for
the supercomputers so they want to test
something on a supercomputer at Sandia
they need to basically you have to
schedule it you can't you can't just run
it so we've got some basic support in
there for that right now
it's it's in the development branch it's
not in any release but the idea there is
you could specify some tests and have it
batch them off and then it sits around
and waits until they actually get
results and then collect them up so
we're working on that but there's
nothing actually in a release
okay okay so I'll go into CPAC now all
right so CPAC is a bundled with CMake
and it creates professional-looking
installers platform-specific again it
takes the same model to see make it's a
meta installer tool we use null soft on
Windows and we can create tar.gz files
you can also create OSX package maker
rpms Debian's and again this is this
thing that a lot of developers I
remember early on a kit where we're
under a release it seemed like there was
like one guy he's the he's the guy that
knows how to run our installer system if
he's not around you can't make a release
you know it was one machine that knew
how to do it again this this sort of
takes that and gives it to developers
and a much easier way to they know how
to write the install rules for C make in
their project and they can write a nice
installer and it also supports component
based stuff so you can do the typical
stuff of a install weather without
headers with or without libraries that
that kind of work and there's a wiki
page talking about how to do the
component installers I'm using it on
Windows you'd install the train line zip
program or null soft installer and then
inside your project you set some C but C
pack options variables that you need you
include the C PAC module and then it
will reuse your existing install rules
and then running it you can type make
package or make package source you can
run C pack and give it a configuration
file and tell it to do null soft or zip
it's fairly easy to use there's some
more information about C pack economy in
the book and in this wiki page and
here's finally I want to sort of end
with a real simple example this is a
cute example and it's fairly short so it
basically says up the top I want version
2.8 of C make or greater and I'm saying
project hello cutie and then I'm saying
find required dependencies I say find
package QT required and then I add an
executable and right here I'm saying
it's a win32 executable so it doesn't
pop up a console and it's also a Mac
sex bundle because that's what the cute
thing is going to be and here's my
source file and then I'm saying target
link libraries to the target name the
executable hello cutie and I want link
in the Qt main library plus the Qt
libraries and then I'm going to install
it so I'm going to install target's
hello cutie which is the name of the
executable to a destination directory
bin will include this in storage system
required libraries which will on
Microsoft pull in the the required
runtime library plus the manifest
side-by-side manifest stuff that you
need and then I'm setting a version from
my project 1.0 and then finally I'm
saying that I want to package this
executable hello cutie and I'm going to
call it hello space cutie and then I
include C pack and now I think to me
this is pretty cool and that this next
one is same thing it said now I want to
use boost inside my cutie because I'm
going to I'm going to try the boost
signals instead of signals and slots
from cute and to do that I need to add
four extra lines into the project
basically I'm I'm telling you to use the
static boost this is because the the
binary from the binary from Windows is a
four boost comes as a static library and
I'm saying I want boost required and I
want to make sure it has the signals
library built with it and then I'm going
to include the boost include directories
and finally I'm going to link the boost
libraries to the target and then the
rest of the stuffs the same so now I've
added I've got something used cute and
boost and it will work on Mac and
Windows
so that's and if you try to do that you
know with make files or Xcode projects
it would probably take you a lot longer
I would imagine potentially finally this
is a slide one of the hot areas of
research at kitware is informatics
visualization so we're actively working
with the Sandia that most of our history
of a visualization is looking at things
that sort of make sense on the screen
like a CT scan you look at that you look
at the visualization let me go yeah
that's a you know that's that's the
inside of somebody you know you look at
this thing over on the left you
you know what if I want look at a class
hierarchy how do you visualize that and
this is probably something that happens
to Google all the time
but we're working on it and we're and
also in a scalable way so it'll work on
supercomputers and things like that but
the idea here is to maybe we can
leverage some of this into the
dashboards or testing we're not sure
really where it's going but but that's
the general idea so in summary I talked
about a C make the build tool and
testing with C test and C - and finally
deploying your software with C pack and
there's some links to kit where calm
seemed a org and sea org there's my
email I'm always happy to answer email
I love reading email and thanks for time
but I got one more thing I want to do I
was going to do a quick quick demo here
so I'm going to drop out of PowerPoint
but this is sort of this is the last
slide in PowerPoint and see if this
works do a live demo so I'm going to run
I've got that example QT that I talked
about with boost of course it's too big
because I had to change the resolution
screen configure and we'll pick we'll
try a Visual Studio 2008 and it's
testing the compiler down here it's
checking the compiler ABI it's found qt
it's found boost with signals and you
can see it found my open source build of
cute I can I can look at a advanced view
I can look at a group view so we can see
let's see what did it find the boost it
found Program Files boost 3.8 found the
library directory for boost get the idea
will configure again will generate
and then I'm an example qtb which is
this directory here pop up the solution
build it and then I'm going to package
it and it's running null soft for me and
this is it the same source code is he
make that I just showed in the slide it
0 RS if you look here on the hold we
have an installer it's pretty minimal
it's got some default install it into
hello coochie and we're done and then if
we look over here there we are and it's
highlighted coop that's new we run it we
get hello whoa yay and throw this slide
out one more time and now I'm done so
any questions or
you
you
there's I mean there's a big example
ather if you want to look at one is KDE
I mean that's probably one of the
largest open source efforts out there
it's probably a couple million lines of
code yeah you do set something you'll
set library sources and you'd give it a
big list and you could you know put some
conditionals in you know if Apple
include these that type of thing usually
in really really large projects they'll
probably you can create macros or
functions in the CMake language and they
they have like you know an ADD KDE
library and it might do some extra stuff
for you but it it does scale into really
really big big projects no no no
yeah no no via something more like you
know I could uh
this isn't a huge project see make
itself but so there's sort of the source
list so I'm saying set sources when I'm
listing them out and then right here so
I've got you know this elf sources which
is a optional thing so if I'm on Windows
I don't have the elf editor but it's
gotta each line so it wouldn't get
conflicts every time and then here I'm
adding a you know if I'm in UNIX I'm
going to do K develop and there's some
Apple sources for doing the Xcode
generator and there's the visual studio
stuff so sure
good question probably should modify the
slides to show more complicated things
as well you want to show it's easy to
use but but it also scales yeah
you
no we don't I mean it's it see makes got
to be around and we're using it for the
copy commands we're using it for the
Installer I mean it's it's like the
install rules the cross-platform
installing it's a C mate command that's
that's actually running to do all that
work so there's a lot of infrastructure
that you really need cross-platform so
you either then you end up saying all
right well you don't have to have a
build tool around we can do Visual
Studio project but you have to have
Python because we got to do all the
extra stuff anyways so the idea is to
have a minimal requirement which is the
C++ compiler that was our take you know
ten years ago when we started this and
I'm still standing by
really well I mean I think when Katie
went over the the build times went
significantly down from from their auto
tools build Kitty they use a build farm
and stuff so it's it was I mean it's a
couple million lines of C++ type thing
they're using this CC I think you just
set the compiler to be dis CC and then
run CMake
right
depending on what you do I mean it
spends on the sides of project and how
many try compiles you're doing so if you
go crazy with you know checking for
every every possible header or whatever
it can get slower but it only does it
once so yes yes
now they've all been cast here
yeah
yeah it should be under a minute I would
think on a reasonable machine like the
truly knows project takes about a minute
or so it's like 42 packages and each one
has several libraries and executables so
it's probably something along that scale
depends on the computer and all that but
it's if we do try to make it as fast as
possible yeah but yeah we spent a lot of
time optimizing it whenever we had a
chance I think we're not done then yeah
yeah thanks for inviting me I had a
great time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>