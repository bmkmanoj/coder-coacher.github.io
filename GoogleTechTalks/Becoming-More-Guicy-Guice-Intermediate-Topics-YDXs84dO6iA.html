<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Becoming More Guicy: Guice Intermediate Topics | Coder Coacher - Coaching Coders</title><meta content="Becoming More Guicy: Guice Intermediate Topics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Becoming More Guicy: Guice Intermediate Topics</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YDXs84dO6iA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to my talk on becoming more
juicy this is the second talk of the
series of indefinite length if you were
not at the talk that I gave about a
month ago and you haven't watched it on
Google Video you might be missing a few
of the fundamentals that I'll just be
glossing over here hopefully it won't be
too bad but you can always go look it up
on Google Video and give it a viewing or
maybe you're seeing me on Google Video
right now stop go to the other video
watch that one first in this talk I
realized there is a lot of demand for a
talk that would be sort of a recipe
based approach of you know take this
situation you want to do this how do you
do it change the code I am working on
putting together a talk or a series of
screencasts on that subject that's not
actually the approach that I'm taking
today so the approach that I am setting
out to accomplish here is to try to give
everyone to the best of my ability a
good mental model in your head for how
JEWS thinks and how JEWS behaves and
what it's doing behind the scenes I'm
I'm lucky enough to have been to be one
of the only two or three people who have
been using juice for a full nine months
maybe not sure so I've had a lot of time
to build up this nice mental model in my
head so that that makes it so that
people can ask me questions about what
will juice do in this case or how should
I tell juice I want this and I'm able to
to pretty much figure out what they'll
do and answer the questions so I'm going
to attempt to the impossible I mean it's
time to sort of tell you try to convey
to you sort of how it works and it's
sort of like in high school
when you had chemistry class you always
had to have four days of boring lecture
and then one day of lab so maybe maybe
the next lecture will be lab any
questions on that and we'll try to cover
the injector in some depth scopes in
some depth a few words about testing and
I'm going to drop some teasers about
what Bob and I are working
for juice 2.0 and whenever you do have
any questions you can put your hand out
and the gentleman over here have a
roving microphone that you can use okay
so here's the standard setup this is
taken right from the previous
presentation you have an interface you
have something implementing that
interface you have somebody who needs
something of that interface
this is garden-variety vanilla Java code
with an added ject inserted and on the
next page is the glue that we use to
take juice and juice it all up together
so that it runs we looked at this in the
last talk we have a module that
instructs the juice for this type
displayer we want to use this
implementation standard out displayer
and then we have our application which
is these three lines of code if you put
all this into your IDE and run it it
should actually run unless I made a typo
it's a complete juice application this
is just sort of review so if anything
here is confusing already we should
address that sooner rather than later I
want to talk for a bit about the juice
injector one thing that you noticed very
quickly about juice is that it has
nothing called container if you've used
nano container or Pico container or the
spring ioc container we deliberately did
not use the term container with juice to
me the idea of a container is that it's
something that's larger than your
objects it's something that your objects
have to live inside and your objects may
not be able to function properly if they
are not inside that container
what juice does it's really very
different it performs a task for you
it's task is to fulfill injection
requests you ask it to inject things it
injects them for you and then it's done
and it gets out of the way in fact if
you were to well actually what I was
about to say I'll say a few slides later
so I don't confuse
so its sole purpose is to fulfill
injection requests and it does that yes
I'm sorry
so juice comes with bundled scopes and
those bundled scopes do things like hold
on to references but they're sort of
separate from the core juice engine so
yes there's probably a million asterisks
that we can say well juice also does
this but I just want to drill in the
point that this is basically its purpose
in life so what is resolution did it
okay so resolution is simply how we get
from an injection request to some
instance of something and an injection
request usually looks like you have ADD
inject and it's applied to a field or a
method or a constructor and juice takes
that and it says okay I know that you're
looking for something like this I've got
to eventually get to an instance of that
what the resolution process does is it
gets from that request and it finds the
instructions that you have configured
for how you want that to be fulfilled
and there's really three fundamental
ways that juice can do this you might
have given juice a single instance from
your module at the beginning saying
always use this instance you might have
given juice a class that juice will
instantiate or you might have supplied a
provider the first thing that it does to
fulfill an injection request is it
figures out what your key is so if you
have ADD inject foo-foo your key is
simply the type foo you may also have an
optional annotation on that injection so
the key is really the combination of the
type and the optional annotation then as
we've seen already you can have bindings
in your modules that sort of give juice
instructions for how to get closer to
the goal if you wanted to you could bill
that you could set up an elaborate chain
of bindings if you have a class called
foo that has a sub
sub fou and sub sub fou and sub sub sub
fou you could bind all of these things
to each other one in a row juice we'll
just follow them all down
sometimes this actually turns out to be
handy sometimes it doesn't but juice
will transitively follow all of the
bindings that you have until it winds up
at a binding that is sort of an end
point of this process and if we came to
an instance or provider reference we are
done because we have basically come up
with the the complete finished sort of
instruction for how you want to
instantiate this class or how you want
to obtain this instance if when juice
tries to resolve your request it ends up
at a Java type that it doesn't know
anything about it's going to look at
that Java type and I should actually I
don't have code examples for this so I'm
just going to gloss over it you can
optionally put special annotations on a
Java interface or class telling juice
either what that class is implemented by
or what that class is provided by but
you don't really have to do this because
most people prefer to use the modules
but it is there when juice sort of
finishes following all these hints it
ends up at some type it's going to
assume that it can instantiate that type
clear as mud
so at this point it knows how you want
to create that instance actually okay
this is indented wrong but if it found
that for type foo you had passed in at
the beginning a new foo paren paren it
already has the instance so it's done
there it is
just gives you the instance if it's at
an intangible class it instantiates it
and it recursively has to fulfill the
injections for that class and if it has
wound up with a reference to provider it
basically has to repeat the resolution
process all over again
it resolves the provider and when it's
all done with that then it calls get on
that provider and that's how it gets the
instance some of these are subject to
scoping that I'm going to be touching on
soon so now we've figured out how we
should obtain the instance and we have
obtained the instance and now in most
cases all that is left is to inject the
value by setting the field or collecting
up all the parameter values and calling
your method calling your constructor
this also might have been a request that
you pulled from juice because you can
call injector get instance and you can
call provider get and in that case it
just returns the instance to you it
doesn't have to actually inject it
anywhere yes please
so suppose I have a base class and
another class that extends it and they
both have injections so I'm trying to
provision the extended class is juice
gonna travel up the inheritance chain
and also look at the super classes and
inject them properly yes it does does it
also grab private members from super
classes probably not but private members
from super classes are not inherited so
but it still does okay okay but that
answers your question then I guess okay
so that's one of the things that's
actually handy about method and field
injection is that you can put them on a
base class and then your subclasses
don't even have to know about them okay
so some of those details were probably
clearer than others some of them were
maybe a little bit muddy but at least I
hope that you have a little bit better
of an understanding of what juice really
does it sees injection requests it
resolves them it provides the instance
and then it takes that instance and
injects it and that's pretty much its
only job so that sort of tells you how
things work on this nice microscopic
level which is nice and easy to
understand but obviously several of the
steps in what I just described are
highly recursive in nature in order to
construct a class it might need
injections of its own in order to get
those they may need injections of their
own and one of them may need to be
provided by a provider which needs
injections of its own and so on and so
forth so every time that you ask the
injector for an instance it may be
actually creating a very large graph of
objects and very quickly and returning
that whole graph to you in fact it could
in certain situations actually create
the entire object graph of your entire
application all at once there are a
couple of things that actually prevent
that from happening which I'm going to
explain next which are provider
injection and injector injection but if
you never used those features what would
happen the second that you in your main
method that you
for one instance from juice it would
create the entire graph of everything
you need and if you took that instance
and you discarded your reference to the
injector the injector would actually get
garbage collected at some point it's it
has served its purpose and it's finished
in reality that usually doesn't happen
because you're gonna use typically some
of these features like provider
injection and injector injection which
I'm explaining next so this is a slide
whose font is too big okay so this
example is again pulled right from the
previous talk anytime that you can
inject a reference to a foo you can
always choose to inject provider of foo
as well you don't have to do anything
special to enable that and it always is
recognized by juice that what you want
it to do is to inject into you some
handle some object that you can call get
on to obtain what you really want
basically what this does is it tells
juice to not be as eager as it usually
is so don't go ahead and create this
gigantic graph of ten million objects
just because I wanted to get the help
message of my application only once that
method called get gets called that may
touch off you know a further
instantiation of another branch of that
this big graph so if you imagine you
know as I'm trying to reason about
what's happening in real life at runtime
in my application I'm seeing these huge
graphs getting to sort of with every
request created and thrown away created
and thrown away and there's a core graph
that you know it has my Singleton's and
it's pretty much there for all time does
that make sense
so you know providers are just a simple
what provider injection is just a simple
way to delay continuing to instantiate
all the stuff down below that spot and
by the way if you use provider injection
and you get an instance from that and
then you retain that instance in a field
of your class then what you're doing is
you're
outsmarting juice and its ability to to
help you and it's not a good idea I
would not recommend it usually you just
get the value when you need it and if
you need it again you get it again so
then we have this thing called injector
injection which is it's not even a
really advanced concept it's just simply
that the injector will happily inject
into you a reference to itself if you
want it most of the time you don't want
it but if you're writing some kind of
abstract framework that has plugins like
we have web work integration and struts
to integration this is how they work
they get a reference to the injector
injected into them and then they can do
two things they can just arbitrarily get
instances from it whenever they want to
and if they have an instance of
something that they got somewhere else
that they didn't create through juice
they can pass it to the injector to say
you know do some post injection of the
fields and the methods in this object so
it's obviously once the instance already
exists it's way too late for any
constructor injection to happen it's
already been constructed but the field
injection and the method injection can
still happen and theoretically you could
take a single instance call inject
members on it do some stuff and then
inject different members into it I don't
think you necessarily want to do that
but you could maybe you come up with
some reason why that's valid so injector
injection is a very big hammer it's
something you know that will let you do
anything you want and the downside is
it'll let you do anything you want so if
you try to reason about what your
dependency graph looks like well as soon
as you have something that has the
injector injected into it it might
depend on anything and you can't tell
any more one of the big advantages of
using the DI
dependency injection pattern is that you
can just look at the code and you can
see the dependency graph you can see
this depends on that depends on that
very clearly just look for the add
inject tags
so I'm going to be moving on to talking
about scopes and I think I pretty much
explained everything I wanted to explain
on this subject does anybody want to ask
any questions that are relevant to this
yes in the front row please oh do you
want the microphone
thank you so for the providing injection
through how to create a class of that
provider for that no okay
no it's basically so the provider
interface is used in multiple different
ways in juice one way you can use it is
you can create a class that implements
provider so that you can control exactly
how you provide instances to juice but
also even if you don't do that at all
you can simply ask to have a provider
injected into your class juice will just
generate a provider that when you call
it has the right hooks to know where to
get the instance from you have to do
nothing special Jessie I've heard that
the provider is also useful if I need
multiple instances of my food so other
reasons to use provider injection Thank
You Jessie one reason is laziness other
reason is you may want to get multiple
instances of the same type and this
gives you a way to just get as many as
you want there is one wrinkle with that
though which we'll see when we get to
scopes because somebody might have
applied a scope to this binding they may
have declared it a singleton and if
they've done that you can call get as
many times as you want it's not going to
help you're gonna keep getting the same
thing in the back oh that should be on
to okay why is it bad to hold on to a
reference that you get from a provider
so if you inject a provider into the
constructor and then you just set a
field to it right away and the
constructor and held on to it can you
provide it you get an example of so if
you're actually able to get the instance
right away in the constructor then you
probably could have just done away with
provider injection in the first place
and just had the instance provided and
that would be more clear if there's a
later point in time when you can get it
I would say holding on to it if you're
gonna hold on to it you should know what
you're doing because when we talk about
how scopes work you'll see that it's
possible for an object to be valid in a
scope at the time it's injected to you
but if you hold on to it in your object
later on that scope might be dead but
you may still have that reference so
you're you're essentially just limiting
juices ability
to catch errors before they happen but
if you're pretty sure that you know that
it's safe I'm not gonna you know I'm not
gonna find you and come knock on your
door okay so time to talk about scopes
the easiest way to approach scopes is to
start by describing what things would be
like if there were no scopes I wanted to
get you know get that guy who does all
the movie trailers to like narrate this
for me with that that voice that they do
with every movie trailer in a world you
know and there's like one man must rise
above and all that stuff in a world with
no scopes nothing gets reused every time
anybody needs something it's created
it's injected and it's thrown away so if
you were to look at your object graph
your object graph would be a tree
because there would just be no way for
two different nodes on that tree to both
depend on the same instance because
we're just throwing it away every time
all that a scope is is a policy for how
instances should be reused we also
sometimes use the term scope when we're
really referring to a particular
incarnation of a scope so in other words
like if you have objects living at a
request scope in your web server then
every time a new request comes to that
server there is some object somewhere
that's being born and is remembering
things for a while and then the request
ends and it dies these things are
constantly being born and dying born and
dying and we sometimes use the term like
oh the scope you know has ended so I'm
accessing out of scope or you know put
that in the scope and we're really
talking about what I'm calling an
incarnation of the scope for lack of a
better term the three you know canonical
examples are singleton request scope and
session scope these three are the three
that are provided with juice
out-of-the-box the singleton scope is
handled by the core juice framework the
request and session scope are added by
the servlet module add-on to juice so
you can actually well think I'm gonna
cover this in the next I'm gonna cover
what I was about to say all right so
does anybody know what t25 is there's
there's like this mouthwash called scope
and it says with t25 and the idea is
like wow I mean that's gonna get rid of
my bad malodorous breath but it doesn't
actually mean anything so sure my scopes
have t25 - I'm just declaring that they
do I hope I don't get set upon by any
trademark lawyers for this there are
some bad odors that they can address so
one bad odor is the context object you
ever seen this thing that you call like
this is my you know email context or my
you know XML context or my who knows
what and it's full of all these setters
and getters for things that are sort of
seemingly unrelated but you just need
this catch-all place to kind of put them
all and get them later this is a kind of
a smell another anti-pattern is the fire
brigade pattern in the olden days you
know before they had like running water
from hoses what did they used to do they
just line up and they'd have a bucket of
water and they'd pass it to the next guy
and then get the next bucket and they
keep passing all these buckets down so
I'm sure you've all seen code that calls
other code passes in a parameter and all
that this code does with that parameter
is pass it to the next guy who passes it
to the next guy and nobody's actually
using anything on this parameter they're
just passing it all the way down the
line because somebody might need to use
it down there at some leaf level
somewhere this is another sort of a
signal that you could take that object
and bind it in a scope instead and save
yourself a lot of mess in all these
intervening layers and of course kind of
going along with you know the latter to
kind of go along with the first one
another way to handle the fire brigade
problem is just having static thread
locals scattered all over the place
whenever you need them
maybe you're remembering to clean them
out properly when you're done and maybe
you're not and who knows if you use
juice and use juices scopes it deals
with that stuff for you so that you
don't have to there are two ways that
you can apply a scope every scope has a
annotation that identifies that scope so
in the juice platform there's these
three annotations anytime that you bind
something you can simply say in and you
specify one of these annotations or you
can put the annotation right on your
class if you want to so that that what
specified in the module always takes
precedence over what's specified on the
class if it were the other way around
and once you put it on a class you'd be
locking that in for everyone and nobody
would ever be able to change it
so that's override well we have a
question are L no okay
you try to go something like Time Square
t square with your question
No
so if time score displayer is marked
that it's requests coat and when you
bind it you bind it as singleton scope
it is juice assumes that you're doing
this for a reason and that you know what
you're doing it doesn't issue any
warnings there are pitfalls where you
can get into trouble which we're going
to get to in a few slides okay
what makes these scopes work is not
really magical on the same binder
interface that you use in order to bind
your interfaces to implementations you
can also bind scopes and to use the
servlet scopes all you have to do is add
this servlet module that comes with
juice into your injector and if you use
it the first two things that it does if
you look at the code is it binds to
scopes and at the left the first
parameter is the annotation the second
parameter is just an instance of an
object that implements this scope
interface if you wanted to use the
request scoped and session scoped
annotations in your code but you're not
a web front-end and you want to have a
different implementation behind them you
can go ahead and do that you can just
bind our same annotations to your own
implementation of scope and it's a
little unfortunate that we did put the
request scoped in session scoped
annotations in the Guice servlet jar and
made it part of that servlet package but
those annotations themselves are really
not highly served with specific so that
was arguably a mistake and this is just
a glance I'm not going to go through
this line by line but with a few sort of
details omitted this is really the gist
of how request scope is implemented if
you look at the real code there's like
some two string methods in there and
there's like a synchronized block but I
just left out the little things like
that that's basically all it does a
scope is something that can take a
provider which always creates and return
you a provider that sometimes creates
and that's basically it that's the magic
I won't go into a high amount of detail
on this but I just wanted to show you
that it's not super rocket science
Singleton's are special among scopes
they're the only scope that we currently
support eagerness versus laziness for
everything else is lazy just because
your request has begun it's not gonna go
find everything that's request scoped
and just go create those all right from
the beginning but with Singleton's we
have a mode that you can use when you
buy and using dot as eager singleton
where it will automatically instantiate
and prepare and inject you know all of
those instances right away when you
create the injector two ways of doing it
or with the as eager singleton method
and you can also just new it up yourself
in the module and pass it in using to
instance in fact in the second example
what you're doing is like super eager
super eager singleton because even you
know just by virtue of configuring this
binder you're already instantiated your
class you may not actually ever create
an injector but you're already
instantiating this class and one thing
to keep in mind with your module class
is that it could just as well be some
bit of utility code or some tool or some
IDE plugin that's executing your module
it may not ever be actually intending to
start up an injector and actually serve
requests from it so we tend to sort of
not prefer this approach where the
module does the instantiation itself and
we prefer to just specify a class and
let juice do what juice does best
which is great things and inject them
oops but I should point out that even in
the latter example which is sort of you
know not preferred we do still support
field injection and Method injection for
that object that you give us so
obviously again it's too late for us to
do anything about constructor injection
because you just called the constructor
but will happily inject the fields in
and we do that as one of the final steps
you know when you create the injector
just before we return we go and inject
all those things okay
so here we get to the tricky stuff I
called this slide night of the living
Undead
and we'll see why hopefully in a second
there is a problem with what I have
called backward scope access in this
example we have a class that lives at
some wide scope and has an injected
object that lives at a narrower scope so
if you take any two random scopes that
exists it may be that neither is wider
or narrower than the other yet there are
plenty of relationships that do have
this this quality a singleton scope is
always going to be wider than any other
scope request scope is always going to
be narrower than session scope so on and
so forth when this happens and you make
a backward injection some bad things can
happen and quite honestly it's a bug
that juice even permits this in the
first place and at the time we released
juice 1.0 we were sort of seeing it as a
feature request to be more careful about
it but since then we've sort of realized
just you know how problematic this is so
if you do this kind of thing when you
upgrade to juice 1.1 your code will
start blowing up right at injector
creation time saying you shouldn't do
this now here's why the first thing is
if you're really lucky it'll just blow
up right away because you may be
creating this class during a time when
the narrower scope is not in existence
the narrower scope may not have been
incarnated yet you might be in singleton
scope doing your server startup and this
thing might be at request scope and no
actual web requests have come in yet
so that's the the good case because you
get the exception right away but it
could be that nothing actually caused
the singleton to load during server
startup and it's actually during the
first request that triggers this to get
instantiated in that case it will
fulfill the request but
nothing knows how to realize when that
scope that request scope has died so
this reference will continue to live
beyond when it should have been dead and
that's why I call this Night of the
Living Undead it's kind of an undead
reference so the next version version of
juice will be will will tell you what's
going on here in the meantime you have
to be careful
one fix for this you know sometimes when
you have things injected sometimes it
turns out that you could have just made
it a method parameter on some of your
methods and the people who call you can
more easily have it injected because
they live at a different scope so that's
one way to handle it another way is just
use provider injection if you use
provider injection and then you just
only get from that provider at the
moment you need something and then you
throw away the instance then you should
never have any problems with scopes
Sascha
so the question is why not just use
provider injection all the time so that
you don't have to worry about this
problem and the answer is there's really
no reason not to do that
it makes your code more cluttered but
other frameworks actually take different
approaches to this problem
I believe in seam they have this thing
where they will insert you know byte
code in between all of your code in such
a way that your fields and methods get
injected right before every method call
to your object and when that method
finishes those things get out ejected
again Bob can tell me if I'm totally
wrong about that so that's one approach
another approach is to have your
reference to my narrow class actually
being this proxy object and the
difficulty with the problem with
following either of these is that I
think that it makes the structure of
your code and what's happening a lot
more mysterious there's a lot more funny
magic that's going on whereas really
with juice once juice finishes injecting
everything then it kind of gets out of
the way
and you suppose
okay so the the plan at this point is
that custom scopes can optionally
declare one or more scopes that they are
definitively wider than and they can
also declare one or more scopes that
they're definitively narrower then if we
have two libraries and neither of them
has the dependency on the other then we
have to assume that there's probably no
relationship between their scopes either
that can be can be really known but for
example if I sit down and write a
conversation scope I can easily say I
know that I'm narrower than singleton
scope and I know that I'm wider than
requests go
the library
so the question is does this sort of
bleed too much internal knowledge of a
library out onto consumers I do think
that the way that scopes work in juice
does require you to have knowledge of
whether you're making a downward scope
access or an upwards go gap scope access
and you have to unless you do what
Sasha's suggested and just use provider
injection all the time and so that fact
is somewhat unfortunate and maybe
there'll be something that we can do to
improve that situation I'm not sure yes
having random stuff by random things is
necessarily cleaner than actually
threesome
so the question is sort of a design
question of sort of is is the question
sort of like is it worth using scopes as
juice has implemented them when you
could do something else instead
or would you is it why weren't scopes
implemented differently than they are
I'm not sure I totally
so it can't comment on whether it's
bizarre or not but we found it to be
very useful so we found it to be clean
and maintainable cut you know modulo
some of these issues with the night of a
living undead okay Sasha first and then
can you maybe take the microphone if
you're
so bouncer that makes me happy is that
you only use when you're injecting a
provider you still see exactly what your
dependency is well is when you're using
a static thread-local you just I mean
it's just the mysterious access
somewhere it's not as clean of course as
just injecting the thing but okay so
this is an example of the kind of
question that is great to send to our
mailing list especially with sort of
example code like look how you know this
could work instead and you know we read
all those and think about them mm-hmm
there is yes okay so the comment is
basically that you can use juice and
dependency injection to inject different
types of things you can inject stateless
services stateful services and you can
inject actual pieces of data and to some
people the idea of injecting things that
represent data is a little bit uncouth
or seems problematic all I can say is
that to me it works for me and I like it
and we can discuss it more offline okay
and who are you
yes so I just wanted to say the problem
with me for using with using thread
locals as it's like the same promise
with service locators or any factories
it's that it's kind of like a hidden
dependency and then I think it makes it
hard to test is I don't find out until I
try and test that object and it blows up
because I get like a
nullpointerexception
whereas with this I have to pass it in
you know I mean it's it's completely
obvious so yeah because there's only 15
minutes left I'm gonna try to cap off
this thread and I will we can discuss it
you know afterwards unless you had a
final thing to say Bob okay so we think
that our way has not the same testing
problems and we'll move on for now
um how to choose a scope this is not
always trivial sometimes you have to
think about it for a bit if your object
is stateless and is inexpensive it
doesn't really do much when it's
instantiating then it kind of doesn't
really matter what scope you put it at
put it at whatever scope you want don't
scope it make it a singleton whatever if
your object is stateful typically it's
going to be somewhat obvious what scope
it needs to live at because your
application probably wouldn't work
correctly if it was at a different scope
you know for example if your object is
trying to maintain a count of every time
a certain event happens for a particular
session then it obviously needs to be at
a session scope things that are
expensive to construct or tie up
resources like a connect like a database
connection these are a good use for
singleton or maybe a singleton that
manages a pool and there is some merit
to the idea of implementing a pool scope
but there isn't really baked into juice
the concept of releasing an object when
you're done with it so that's you know
we'd have to think about that a little
bit more before I think you could
implement a pool of objects as a scope
per se
another rule like we just covered if
your object depends on something that
lives at scope X then your
object had better be also scope X or
narrower than that or unscoped unscoped
is always fine or use provider injection
yes true so if you think that you want
session scoped sometimes you really do
but also they tend to be HTTP sessions
tend to be kind of overrated and
overused sometimes people just use them
as a random cache if you just want a
random cache why don't you just use a
random cache is our point and other uses
are really better implemented by the
conversation scope that we don't
actually have in juice yet but I thought
I'd mention it anyway as a way of
nagging Bob to hurry up and write that
write that Bob conversation scopes are
very nice I won't digress into talking
about them right now but if you're
interested you can ask me or Bob be very
careful with Singleton's and things that
are session scoped if you're going to
use them better make them thread safe
you don't have to worry about that with
things that are unscoped or things that
are requests code but if you're gonna
make something a singleton it should be
thread safe one good idea is use that
jar file of annotations that was
produced along with the Java concurrency
and practice book have they have these
annotations like at thread safe and at
immutable and not thread safe and then
you know if you you would if you were
going to type at singleton at not thread
safe right next to each other you wait a
minute that looks wrong although I mean
I suppose you can have a singleton that
you can find to a thread somehow I don't
know there's always exceptions but it's
just a general warning sometimes you
think through all this stuff then you
realize that you want it to be scoped
but the scope that you want it to be at
doesn't exist and then you have to write
it yourself but it's not really too bad
and you can always mail email the
mailing list and we'll help you with
that so that's all I had on scopes I
think I only talked about scopes for
half an hour any scope specific
questions before we spend just a few
minutes
this slide yes see so I mentioned a
couple of times so you have the
singletons to cope which is the thing
that the provider of the provider you
know gets and only provides it once and
ever again which is the widest possible
scope exists in existence
I think Jews should also bundle the
narrowest possible scope in existence
where the provider always provides a new
instance of that so if you had a scope
that was defined to be the narrowest
scope possible would you allow people to
have an instance injected and then hold
on to that instance as a field because
if they were to do that they would have
to also be at the same scope or what you
would do is force them to always use
provider injection okay so I think Bob
and I talked about this in a different
context it may be as simple as a scope
or it may need a little bit more funny
stuff but yeah we'll we'll take that
into consideration for sure okay so I
have 10 minutes left in three slides
left that's not bad I wanted to just
talk about tests for a while because at
the last presentation we showed how JEWS
helps your unit tests and here I just it
in the the code that we showed last time
this is an example of a strict unit test
which is also sometimes called a an
object test to emphasize that it's
really supposed to only test one object
and this is like a very strict very sort
of die hard way to do all of your
testing I think that there's a very
strong emphasis on object testing
because for most people in most
situations your choice is kind of either
to just test one object or to end up
testing this whole huge you know system
of things which would make your tests
slow and we all know all the problems of
slow tests so I wanted to point out that
while juice not only encourages you to
write your classes so that they can be
very easily tested in absolute
isolation it's also really good at
letting you define whatever set of
interactions you want to test that you
want and just tell juice to string those
together and test those and in fact you
can do this in a couple of ways one way
is you still take this same approach
with the code but instead of creating a
mock displayer here you might create a
real displayer and you might pass into
that a real foo and in a mock bar so you
just simply choose which things you want
to draw your circle of interest around
and you create real things and mocks for
everything else pass them all into each
other string them all together and
you're good to go and if that gets a
little unwieldy there's nothing wrong
with your test case just creating a
custom one-off injector to do just what
your test case wants if you want to test
these six things and not the rest you
can create an injector that specifies
those six things and you can use easy
mock or write your mocks by hand for the
rest of them and it works out really
well we do a lot of that kind of testing
in the team that I'm from in fact
sometimes really I wanted to bring
attention to those tests because
oftentimes when your unit testing you're
testing at such a low level it's such a
granular level that ultimately what
you're doing is just encoding the same
information that's in your production
class in a different way and I'm not
saying that there's no value in that but
when you can string together a little
bit more meat on the bone to test then
you have a little bit more meat behind
your test if that makes any sense
juice also has is also helpful when
talking about your functional tests if
your project is anything like mine your
server and production probably depends
on a lot of other servers it might
contact 20 different servers for 20
different purposes LDAP you know you
name it whatever services you know what
I'm talking about
and so what usually ends up happening is
you have like test servers set up and
every time you run your functional test
it's actually shell you know creating
sockets all over the place talking to
all these different test services and if
those test services go down then your
tests are inoperable and if there's some
bug in their code it shows up as a
problem in your tests
so what juice does is it sort of gives
you a nice way to make sure that every
time that you do anything that opens the
socket to some other service you have
that behind an interface and you have a
mock or a fake for that interface and as
just as you have an application defined
that puts together this list of 78
modules or whatever that's your
production application you can put
together some of those same modules with
some alternate modules that specify
these mocks instead and you can use that
for some of your testing so you can say
you know I want to run the test that
just encompass my server my runtime
environment that mock out or fake out
all these external services that I
depend on and my tests will run a lot
faster and be a lot more isolated and it
doesn't stop you from being able to also
just go and run using the other file
that specifies the full integration of
everything and this is because of the
nice many-to-many relationship between
your modules and your applications that
juice gives you that make any sense any
questions about that just like a mini
rant that I wanted to work in so in the
final minutes
here are some tantalizing glimpses of
features that were working on
don't don't read ahead now so one thing
is provider methods so right now if you
want to specify a custom provider you
have to implement the provider interface
and write a method called get but that
means that a single object can only
serve as a provider for one other thing
because you can only have one get method
so what we're doing instead you can have
as many methods as you want you put an
annotation on those methods that says
app provides and that actually gives you
a much cleaner way to do a lot of
bindings because if you want that
binding to be at session scope you just
say app provides
in scope and if you want it to only be
bound when you use the at blue
annotation you just say at provides at
blue at sessions code on your provider
method so it's very clean will cut down
a lot of the bulk from your module
classes
yes question one thing I've run into is
that I find myself still writing
factories because some of the arguments
are actually data and I want and the
problem with the provider interface is
that you call it yet and it takes no
arguments are you thinking of like
adding arguments to provider are we
thinking of adding arguments to the get
interface or some ability to have
arguments we're not planning on doing
that because we have so far had not much
trouble with the pattern that you
basically you know if you need two
parameters you have an interface that
takes those two parameters the
implementation of that can have the
injectable things that it needs injected
and then the code that that needs the
ultimate instance and has those two
parameters has this thing injected
passes in the two parameters gets what
it wants is that if that is becoming
cumbersome again like email the mailing
list show examples of code like convince
us of this like this repeating pattern
that's bulking up code all over the
place and we'll keep thinking about it
well if it is just anything that we can
get people to say is working well as it
is we'll probably try to keep the same
next question okay so we also have are
working on construction listeners and I
can barely even touch on all the power
that will be exposed by this but
essentially you can attach listeners
that get notified whenever juice
constructs an object and then you can
perform your own post actions on that so
if you want to you know fulfill like the
EJB style annotations like a tree source
and things like that you can just write
some code that handles that and attach
it and now suddenly juice will behave as
if it's a you know completely different
style of container did I just say
container
I said container
another thing is multi bindings so what
we want to allow you to do is bind a
collection which only has to be an empty
collection but then other modules as
many different modules as want to can
contribute bindings which will become
elements of that collection so if you
imagine servlets for instance maybe you
have 8 different modules that want to
add some servlets they can all bind as
many of these servlets as they want and
when you ask to have the list injected
juice would walk down the list and get
the instance for each one put them
together into your collection and inject
them into you and this is actually going
to come in useful for a lot of things
that we're doing and auto binders to
hard to explain I'm going to pass over
it but it's cool and it may not happen
with the next release maybe the one
after that and the introspection API
right now if you get an injector you can
get a few rudimentary things from it you
know iterate through the keys on the
bindings we're gonna expose every detail
about the dependency graph through this
API so that we can support tools that
can draw charts and graphs and who knows
what kind of stuff do validations for
you try to calculate a more optimal
start up you know order that we can tell
juice to use who knows what we're just
going to expose the information about
that graph directly on the API and the
other things may miss the release but
they're in the works question in the
back like a thread local singleton scope
would be useful a thread local singleton
scope is kind of like you could also
just call it thread scope I guess and I
think that if you first of all if you
want to implement that scope it would be
very easy to do typically I mean what
that means is that for the entire life
of that thread that same scope is is
alive and you if you have anything where
you're thinking well periodically you
know it has to be zeroed out so that
from then on it can be a new thing well
then that's really a more a different
scope that you know like that's more
like a request code I was thinking of if
you have like open a socket or something
to some other service and you don't want
to go through and make it thread safe at
you
rather have each worker thread have its
own copy of that structure okay so it's
sort of one way of doing like a pool
just say hey one per thread I can see
that I can also see like if you're if
god help you you're stuck using simple
date format it'd be nice to just stick
simple date format in a thread scope so
you don't have to deal with the the fact
that it's horrible so yeah we'll think
about whether a thread scope belongs in
juice but it's also pretty easy for you
to add any other questions thanks for
coming everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>