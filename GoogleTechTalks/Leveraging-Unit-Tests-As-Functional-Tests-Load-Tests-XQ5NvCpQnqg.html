<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Leveraging Unit Tests As Functional Tests, Load Tests,... | Coder Coacher - Coaching Coders</title><meta content="Leveraging Unit Tests As Functional Tests, Load Tests,... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Leveraging Unit Tests As Functional Tests, Load Tests,...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XQ5NvCpQnqg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone my name is john i work in
google checkout and we have a speaker
today his name is Frank Cohen someone
from my team had told me about some of
the work that Frank was doing and said
we should definitely have a talk on his
topic and I said why I mean we have so
many talks from testing you know I have
another one and the specific
introduction that David the person who
introduced Frank to me gave was one of
the reasons I'm actually here today and
I said we should have this talk and that
is Frank's going to talk a little bit
about some of the software that he's
he's written it's a company that's based
on the same product it's called push to
test and it's you you could say it's I
would like to use the word magic but
then that'd be giving away too much of
the stuff that Frank's going to talk
about anyways and what it really is is
using unit tests to create functional
system and performance tests and that's
something that's really nice because you
can leverage work that people have
already done or going to do to create
larger and broader tests so I'll let
Frank lick the floor go ahead alright
thank you John from that nice
introduction I hope you can all hear me
at this level
can you hear me now yeah there we go so
I'm thank you very much for having me
here John push to test has been around
for about five or six years now we get
started when I was at Sun Microsystems
building the Sun community server which
is a kind of multimedia system that
allows distributed groups of users to be
able to share information back and forth
in a very secure way that information
could be like a spreadsheet it could be
email messages could be voicemail
messages it was multi-protocol and the
problem at the time was to try and test
and validate that the community server
was ready to ship like a new version was
ready to ship required us to be able to
validate that all those different
protocols would work and you know at the
time mercury interactive was still kind
of getting its act together around
loadrunner kind of understanding what
the web was let alone trying to figure
out all these different protocols that
were showing up what we saw at the time
was that not only were they expensive
but they didn't support what we as
developers needed so and I couldn't get
anybody to sign the p.o at the time so I
wrote a piece of software which became
test maker a friend of mine convince
needed to open source it it's currently
licensed under the GPL version 2 we're
making plans to go to version 3 the
software is used by about a hundred and
forty or 150,000 software developers QA
technicians and IT managers and it's
gone through four major architectural
revisions and what I've brought with me
today is test maker five which will
hopefully ship tonight in that we've
already gone through a couple of release
candidates and it looks like everything
is good to go the company pushed a test
is basically five people working
full-time we're not vc-backed we
basically make our money by providing
commercial licenses to the test maker
software the push to test test maker
software
and then also by providing consulting
services to companies large and small
General Motors is our largest customer
and then the smallest is a one-person
shop two cubicles away from mine so
we're very much kind of an open source
player with no expectations of what the
needs are going to be of our users the
test maker framework which I brought up
here is delivered as a java swing based
application and it provides users with a
way to be able to build unit tests in a
variety of different languages and then
automatically run those unit tests
either as functional tests as load tests
or a scalability test and also less
service monitors so there's kind of like
three like different types of customers
that are different types of users of
this software this kind of software
developer who really knows objects
really no scripting very well then
there's a QA technician who has to write
a load test or a scalability test or in
some way validate or release it really
probably doesn't have any programming
experience and then there's the IT
manager who really is just you know
their you know their boss typically the
CEO is using that they're the IT
managers neck as a throttle to identify
scalability and performance problems at
the end users have so the IT manager
just wants to make sure our my user
satisfied and oftentimes they don't have
any technical background so what we've
done is to create a test environment I
love when that happens it drives the
guys behind this curtain nuts I'm sure
so what we have is a utility that works
for all three of those groups the
software developer the QA technician in
the IT manager and I'll just show you a
few examples of this the the basic
environment is delivered as a swing
based java application it's a hundred
percent job that runs anywhere Java runs
the environment itself has basically a
simple set of tools to allow you to
create tests for example let's say I
wanted to
to build a test of a a web application
we include the test gem for web plug-in
to Firefox that allows you to basically
visually use a web application so I've
got I've got one here examples not push
to test calm and being that networks
sometimes they're not now they're just
so with this up notice here I've got a
new toolbar it's basically an add-in to
Firefox as the chest jam for web one was
originally developed by that our friends
at spike source it's it's maintained
somewhat so so by them it's maintained
very well by us in it I can tell it to
start recording if I use this simple web
application which has some links in it
some web forms that i can type in type
in my phone number type in an account
number say transfer 100 bucks this this
application is just a simple example app
that we host on the examples push to
test com site just so that people have
something to to learn the test maker
environment from while i was doing that
the test jennifer web plug-in was
watching my activity and if i wanted to
play it back i can click here and it
will take me back to that original page
that i viewed and then take all of the
actions that I that I did before namely
to click in a certain location within
the the application to type in the
information that I did into that web
form it works just fine with Ajax
applications so we've tested it on like
maps google com i think this is telling
me an alert because of the network
connectivity so what i'm going to do is
instead of using the network i'll just
use the local version that we've gone
and i'll do that i'll do the same thing
let me just reset this okay let's say
record I'll go back to the default page
click here file too here's my
information I'll tell it transfer record
and now when I say stop and playback
this is it going back to the original
page then we'll navigate over to the
other page will type in the information
at once so simple record and playback
function the functions that it's
recording are in this format it
basically has a very simple like XML way
of representing that unit test of that
web application that I just recorded
here it is a go to action here the
various clicks notice that it's using
XPath expressions to be able to validate
the various information that it's
getting within the Dom of this web
application when I tell it to save it'll
it'll save this in an XML file format
that we can now use within the test
maker environment and just close these
things
so I will navigate over to test Jennifer
web examples and I will take a look at
this file which is the XML of that test
that we recorded the XML hear you I'm
not sure if you can see it hopefully
again here's that go to command that
tells it to go to the first page here
the XPath instructions for doing a click
within the Dom all of this means that as
kind of QA technician or somebody does
not a program i could build a unit test
like this of a web application and and
I'd be able to run it within the test
maker environment one of the other
things that we do is allow you to import
this this unit test instead of as as an
XML file you just navigate over here's
the test gen for web examples here's
that unit tests and I'll tell it out put
this as instead of an XML file for
simple playback execute output it as a I
thought script so in this case we've
created a push to test test maker has
created a joy on implementation of that
same unit test so now that it's in dry
thon I'm using the HTML unit framework
so here's a typical unit test right like
a.j unit test case it implements a set
up a teardown and a test method within
the test method I'm instantiating the
htmlunit framework and then I'm able to
step through HTML step through the same
unit test just now I'm using the HTML
unit framework as implemented in a jet
on script so what we find is that a lot
of QA technicians might not code but
there they want to code because they see
that as part of their career path you
know it might be an enablement for them
to get into development someday
the Python language tends to be a very
friendly straightforward language
because while it does give you an object
framework it's very procedural at first
and because of the spacing of Python it
becomes very easy to kind of teach a QA
technician how to write these kind of
scripts so that the push to test test
maker environment access is kind of like
friendly framework for you to be able to
move from just record and playback using
a web application into your writing real
unit tests and real object oriented
tests so what you can do with this test
is a number of things we provide we
provide an environment that we call test
scenarios which is an XML document that
allows you to reuse those unit tests as
functional tests and scalability tests
or as service monitors so I can click on
new load test for example and it will
create an XML document of the test
scenario but I have one already end here
it's kind of like a cooking show in that
respect so here's here's the same sorry
there it is here's example agents
testgen for example so here is a
functional test I've opened that test
and a controller panel appears here if I
want to see the controller panel
close-up I can expand it into its own
window a controller panel here
represents that XML document in a
graphical way the XML document the test
scenario gives the test maker
environment everything it needs to know
where to run the test how often what
unit tests are going to be called in
what order basically it's all
represented in that XML document but
what we find is that a lot of kind of QA
technicians and IT managers again
they're not technical so they need more
of a graphic environment so this is the
graphic face of that test scenario this
controller panel lets you run a test
pause or stop edit the test and then
close it there is a horizontal slider
here which I'll show you how how useful
this is in a scalability test in just a
second and then the results appear down
here so if I wanted to run this
functional test and I just click on it
the status says it's it's now running
this test on a set of test nodes because
the push to test framework is a
distributed test environment you by
default it's going to run on the test
notes on the that's on my local laptop
but if I wanted to run this functional
test from say I'm Sydney New York and
London I can install test notes at those
three different locations and run this
functional test remotely with test maker
this this framework acting as the
console to it so what it's what it's
done here is tell me yeah it's it's run
as successfully meaning no exceptions
were thrown when it ran that that unit
test and if I scroll down here this is
like a little console output window what
it did was it said yeah the test is
valid it said the test is running it
loaded in the resources that we told the
the tent the framework would be needed
to operate the test namely those unit
tests it validated that the test nodes
were ready to run
then it ran the test and because this is
a essentially a unit testing environment
on steroids I unit tests just operate in
there operate very quietly unless
something goes wrong in which case an
assertion of an exception is is made and
then the test maker environment would
show you where the where the exception
is so remember before I said that this
panel is representing an XML document
let me show you what you can do within
that XML environment so I clicked on
this this button here which opened an
editor and can everybody see the text in
here or maybe I should say who can't
that's why I'm wearing these things you
know okay so the way that the test
scenario document works is up on the top
it says hey I'm a test scenario right
and then immediately it gives you some
basic information about that that test
scenario like namely the name of the
test and then where the default
directory is going to be found the next
element here is test nodes the test note
is the distributed operating environment
and in this case we're just running on
the localhost this my local laptop which
is fine but like let's say I wanted to
run it on a bunch of different machines
you could tell it hey you know run this
on the 40 machines that you've got in a
rack of servers for example I run it
concurrently and then tell me how each
one of them performed next is a set of
resource of resources that this test
needs to operate so you remember before
when I was using Firefox I I identified
the name of the file that we're going to
save that recorded test to well here it
is so this is telling the test framework
that when the test is sent to the test
notes these are the resources that are
going to be needed so the resource in
this case is a test gem for web file but
you could also send a jar file that
might
your existing objects that you've
written you might send an ex another xml
file which would do configuration for
the test while its operating you might
send a comma separated value file if you
wanted to input data dynamically at
runtime and what test maker is going to
do is make sure that all of those
resources are sent to the test note at
test operation time so there's there's
no more like Odin I can figure all these
tests notes correctly that I ftp the
resources you know that are needed test
maker takes care of that for you the
next area within the test scenario
document then defines that this is a
functional test functional tests in our
nomenclature mean that a test is just
going to go from top to bottom and
operate once it might operate several
unit tests along the way but there's
only one path through it so in this case
we identify a test case there there are
use cases that we identify and over here
let me just drag it over a little bit as
you can see over here is a run method
within the test scenario that says find
might find the test class that I
identified in the resource in the
resources section and call the test gen4
webmethod and the language type in this
case is going to be test Jennifer web
right so if I wanted to run multiple
unit tests I just insert multiple run
elements within this test scenario
document likewise it's fully aware of
unit testing so if you have a separate
set up or tear down method you can put
that within the test scenario to say
before the test runs operate this set up
and then after the test runs operate
this teardown method so one thing I
should point out is the language type
here the test gem for web Runner is one
of many runners that push to test
includes so if you wanted to write a
test in Java the language type would be
Java if you wanted to write it in Ruby
or groovy or
or PHP or java script there's about 15
different languages that push to test
supports that's because we've been at
proponents and longtime supporters of
scripting on Java and now java 6
features the jsr 223 script engine API
so there's about maybe 15 or 20
different languages that are supported
any language that you want to choose
then can be operated on within the push
to test framework so if you want to
write your unit tests in groovy no sweat
there's even an example code in here
that shows you groovy same thing for
Ruby and all of the others that we
support okay so the last thing to show
is in this test scenario documenta said
there are various options for
controlling the timing of the test but
that's about it so when I operated this
test it ran that that test that unit
tests that we recorded in testgen for
web once and that's about it so it might
say well that's great Frank but you know
can it do anything else so let's say we
wanted to run that same test but instead
of just in one thread one time through
we wanted to run that same you recorded
unit test as a scalability or a load
test so i'll open up this XML document
or this test scenario document and here
it is and what I'll do is I'll get it
started operating just because there's a
little bit of setup time involved and
then I'll describe what's going on the
the controller panel looks a little bit
different for this in that it's now
showing the status of the test node so
load test typically will operate on
multiple nodes right now I'm just using
the local node notice it changed to
green meaning that it's ready now it's
received the resources it needs it's
ready to operate the load test and now
it will start making requests out to
that
to that target host the the horizontal
slider here is showing that we're going
to be testing first at 10 concurrent
requests with a message payload size of
one then as the test proceeds you'll see
this horizontal slider go from left to
right as it steps through the various
levels of concurrency that's being
tested so concurrent requests in the
push to test framework are analogous to
threads essentially the push to test
environment will instantiate a certain
number of threads operate that test for
a certain given fixed period of time
then take down those threads and operate
at the next level of threads so in this
test case it's instantiated ten threads
and it's now operating that unit test
over and over again within each of those
ten threats so as you bump up so you go
from 10 to 20 to 30 threads one might
expect in a linear you a system that has
linear scalability that you'd go from
say one transaction per second 2223
that's the whole point of doing this
kind of scalability testing we're able
to rapidly show within this graphical
environment what the scalability index
of the target host looks like and
therefore provide information to the
user about how many servers they need to
buy what kind of network Kanban what
they need to buy how many CPUs to buy so
this is showing you a live view of the
test currently it's a it's not a speed
demon on the Wi-Fi here so we're getting
point 0 17 transactions per second and
this test will operate for I think it's
two or three minutes if we wanted to
change the test so let's say you're
testing at 20 different levels of
concurrent requests sizes and you get
through about half of them and then you
realize oh you know I really want to
skip ahead or I want to go back and try
and rerun it that's where this scroll
bar comes in so notice when I'm over
here it's testing at 10 concurrent
requests and if I scroll over here it
goes up to 20
so this means that I could drag over and
now stop the 10 concurrent requests
level and move on to 20s with other even
commercially available tools you really
have to let the test tool run its course
and there's no way to once a test starts
to be able to make a change like this
once each of the tests is completed
pushed a test will it provide you with a
distribution chart so this is showing
you how many milliseconds it took for
each of the transactions that were
completed for the duration of that test
and so this would be ten thousand
milliseconds or ten seconds 20 30 40 50
and so you can see that most of them
started here at 30 and then we saw a
decrease in performance most likely of
the network that went up to 50,000
milliseconds or 50 seconds it's now
operating on the second level of
concurrent requests levels and you'll
see that appear here as it progresses
through through the test at any time we
can pause of course or stop the test but
let me give you a little bit of insight
into what's going on at the test
scenario level I click here and it
opened up the test scenario document so
here is the XML document for a load test
right so it's it starts with a test
scenario again we have the basics
information then we have where it's
going to run the test on which test
nodes then we identify which resources
are needed and now instead of saying a
functional test it's saying this is a
load test load tests have different
dimensions in a functional test for
example here is how we set the
concurrent requests level sizes so if I
wanted to change this to give me a
number of other concurrent requests
level sizes i just added here and then
the test maker framework worries about
staging and orchestrating that test
below we've got the same tests that we
recorded with test Jennifer web here is
the run method here's the the run method
of this test which is calling that test
John for web record
unit test right so I didn't have to do
any programming at this point to go from
essentially a functional test to a
scalability and load test I just had to
change the parameters of this test
scenario document the third example of
being able to reuse unit tests is to
instead of running this test as a
scalability test to run it as a service
monitor so I'm going to tell it to stop
running this test and actually I'll just
close this guy what I'll do is I'll tell
it to open and here's a service monitor
the service monitor has its own
definition of a control panel a
controller panel and here it is so if I
tell it to start operating what this is
going to do is now reuse those unit
tests but instead of running them like a
scalability test we've got a whole bunch
of different threads going instead it'll
run those unit tests periodically and I
have this one set up i think it's every
10 seconds it's going to operate the
service monitor then keeps on operating
until it finds an exception in which
case it can notify you the notifications
can be by email by SMS you name it it
can also fire off a JMS request it can
even connect up to a relational database
and do inserts into that database when
it finds that the unit test is is
asserting an exception so the list that
you see here here I'll just drag this a
little bit wider the table that you're
saying here indicates which use cases
operated what the result was where it
was operated because service monitors
could operate on multiple tests notes on
it on a network and then this icon here
indicates that the most recent test
completed successfully if it didn't then
you'd see basically an alert an alert
icon show up and so what we find is that
many IT managers will
use the push to test environment within
their data center and they'll keep this
service monitor basically up as a
dashboard to indicate a success or
failure of their system to meet their
users needs so let me show you how the
test scenario document is used to reuse
that unit test as a service monitor so I
clicked on the Edit icon and here is the
XML of the test scenario document for
this service monitor here's the basics
information you know looks pretty
similar right that's kind of the idea
it's repurposing these things from unit
tests into service monitors shouldn't
take any more effort than it did for me
to create a scalability test here are
the resources that are needed and now
here's a monitor definition so in this
case it's going to say monitor run this
basically every ten thousand
milliseconds every every 10 seconds and
keep on running this until you encounter
an exception and then here is the test
use case in the dimensions and there's
the run method which is calling that
unit test that i recorded using the test
jennifer web plug-in so with this
environment with the test maker
environment I didn't need to do any
programming to be able to reuse a unit
test into those three different types of
tests functional test scalability tests
and load and service monitors so you
might wonder okay well you know then
that's great but what else can I do with
this well one of the things that we
found is that while the while recording
web applications is certainly an
important thing to do there's a lot of
work being done now Within smaller
organizations to adopt either rest based
services or soap based services and so
what we've done in the soap front is to
include the soap you I utility which
comes from everywhere how many of you
are familiar with soap you I no not yet
soap you is really cool in that
yes oh say no soso Qi is an open source
another GPL product for working with
wsdl definitions of soap based web
services so how many of you are working
with soap yeah just a few okay so i
won't take too much time on this the
problem with soap tends to be that very
few people really understand wsdl you
know it's pretty hard to look at a wsdl
document and turn that into a test suite
for example and so what we've done is to
integrate the soap you I utility because
it allows us to do things like define a
wsdl document what you can actually I've
got it already created here and so this
is a message service that pushed a test
provides as an example and if I wanted
to take a look at its binding I can see
that it provides me with one service
titled echo elements and I can enter in
a request the request appears
instantiate it here as an XML document
this is a soap message envelope that
will be sent to that service and what
the soap you I utility makes very easy
is the ability to work with the xml
content that's required as a as a
request to the service and then to see
what the results are without having to
do any heavy could at any heavy duty
coating so here I'll say title Frank /
title and I can click on this icon up
here this actually sends this soap
request out to the service and then
you'll see over here is the response
back from that service and this being an
echo elements service all it's going to
do is echoed the elements that i typed
in back to you so in this way I'm able
to work with soap based web services
visually without needing to learn soap
particularly well and when I'm ready I
can
create a test case or a test suite that
will automatically call that echo
elements function so in this way I'm
able to author test Suites visually and
not have to worry about you know all of
the details of encoding styles and
parameters and xml schema definition
documents soap you I takes care of that
for you so if i switch back over here
and tell it to open i have a separate
set of example test scenarios under soap
you I examples and so here is a load
test and if I open its XML document for
the test scenario here's the test
scenario document we've got basics
information I've got test notes so this
looks familiar to you by now right and
now if I scroll down I can see this is a
load test and the run method that we've
got the run method says hey you're going
to it's going to be called set up test
right the test class itself is test
suite that's the name that we created in
soap you I the method that we want is
called test case and the language type
is soap you I so by doing this I can now
create a test of a soap based web
service and operate it from within the
test maker environment either as a
functional test a load test or as a
service monitor and I didn't have to do
any coding to get here
there's a few other things that I wanted
to show off for example might say well
let's say I've got some performance
results and I wanted to do a comparison
to see you know hey on a performance
basis is the current release faster or
slower than the previous release
question that that I often ask or I'm
often asked so here here's the results
directory here's the the tests that i
created before oops she
bummer just now we get back here example
agents oops example gents results
not click open so we include a
performance comparison utility and I'm
just realizing that I only ran that one
test I don't have anything to compare it
against but you use this graphic utility
to be able to add any of the results
directories that push to test test maker
is created you identify which which of
the test cases that you want to operate
on and then you can tell it give me a
comparison of either the transaction
time the memory the CPU or the network
that's being used and it will show you
comparison charts of each of these right
now I just have one run so it's just
showing it to me but if I had say two or
three or four runs it would layer them
one on top of another inside of this
chart so you can also take a look at the
individual use cases that are available
from each test node so like let's say
you were operating the push to test
environment across several different
geographic areas and you wanted to see
well what's a comparison of performance
between let's say people in China versus
people in Europe that are trying to
access the same server with this
environment you're able to do that
there's one other thing I wanted to show
you I'm looking at the time and I'd like
to give you some possibility of asking
questions and that requires a chart and
I'm sorry for doing the chart but doing
I'm happy to come back and do a separate
demo of our governance features this is
the push to test run time in
architecture what you see down on the
bottom is typical kind of web 2.0
enterprise 2 point 0 application
development environment where you've got
an application server that's speaking to
a browser using say Ajax or RSS or HTTP
or soap you might have an email server
that's speaking pop or imap and so the
push to test runtime acts as a test run
time and it's not like an application
server it's more like a test environment
but you have a test run time that can
operate tests according to this test
scenario definitions that we gave it and
those tests themselves are able to speak
these multiple protocols built into the
test maker framework is a library called
tool which is our extensible protocol
handler library so out of the box you
get protocol handlers for HTTP HTTPS so
xml-rpc sip you know so if you wanted to
test a telephony application you could
do that too and then it's extensible so
if you had a custom protocol that you
wanted to add to it that gets put into
the push to test framework and then
operate it from within those tests nodes
I showed you before how we use the
browser recorder and soap you I utility
there's another way of calling the push
to test environment and that is calling
push to test as a service itself so
pushed a test provides a soap based web
service interface so that a utility like
webmethods as x registry repository
product can call the push to test
framework have pushed a test operate a
test and then respond back with a result
set which indicates the performance of
the test which errors the test
encountered and then whether the test
was able to achieve certain performance
metrics like a certain number of TPS all
of that information is returned in what
we call AG SRS document governance
statistics results that document and
that is then added back to the services
that are managed within webmethods so as
metadata so if you've ever used a
repository you'll typically see like a
list of services wouldn't it be great if
you could click on one of those services
and see that it fails every Saturday or
it doesn't work well at night these are
things that you might be able to write
code within your service consumer to
avoid we also provide an interface to
DBA info powers products which are a
database and application server
monitoring and remediation solution so
that if you're using say Oracle in your
application you're operating a test
within test maker and Oracle seems to be
the bottleneck to performance this
interface to the DBA info power product
will identify the hotspots of
performance as a matter of fact we think
that push to test is pretty much the
only open source test utility that can
really do a good job at kind of putting
together the test results against what
the actual back-end system is able to do
and we can do that through our GS rsn
pushed a test as a service interface so
with that I see it's about 10 10 minutes
of 4 and it had about an hour right so
let me open up if anybody has questions
I'd be happy to answer them or to try
and answer them yes
and
you have any numbers on sort of was the
overhead for running pushed a test and
in particular for doing scalability is
the budgetary markers does the
performance scale with the number of
tests you run or it does so what we
typically recommend as a methodology for
testing is to first build the test or
design the test and build it but then to
run a a oh boy i'm blanking out to run
essentially a check of the system itself
the the test nodes themselves obviously
operate on individual machines and take
up resources to use to operate the test
and so what we find is that will
typically operate a test on the system
itself to make sure that we're not
maxing out say the CPU of the test node
machines themselves on a typical
dual-core intel based server that has
say two gigabytes of memory and has
gigabit ethernet what we find is that in
a soap based web service test we can
typically get about between two and
three hundred concurrent requests on
that one box to I'm sorry not request
but two or three hundred concurrent
virtual users when you go to http based
protocols because there's so much less
processing required to handle the XML we
find that we can go from four to six
hundred concurrent virtual users and
with the price of equipment nowadays we
find that at least for the customer
experiences that we have that that kind
of scalability of the basic system is
there did that answer your question
so the way that the product is is is
licensed by the way is that you can
download the source code and build build
it yourself using the GPL license terms
or if you download the pre built and
tested and installable software it comes
with its own installer then we sell
commercial licenses above 200 concurrent
virtually running users so basically
that's enough for kind of a developer to
write a test and to operate a functional
test or a load test on their desktop and
then when it's time to roll that test
into QA they typically have a budget is
to provide support for the push to test
framework so it's not entirely free but
it is open source
any other questions I had one so I
noticed that the results that pushes s
bits out it's either proprietary or it's
specific to I didn't see any HTML sort
of report is that something I missed or
basically what how number one what did
the results look like and secondly is it
easily integrate able into an existing
test framework for instance it is so
push the test is used often in
continuous integration environments the
output can either be to the graphical
console as we saw before and those test
scenario documents this one's just empty
and that's why it's just logging to the
screen you can also log to a relational
database all of the test results are
stored in that results directory which
is here in XML form there is so here was
the results directory that we created
and so this is this is a log of each of
the completed transaction so you're able
to them grab this with any of the data
analysis tools like Hyperion and you
know even excel and and to continue
analyzing results we also did actually
we relate we locked to a relational
database and then also we log to either
JMS queues or two to other message
queues so that you can have this as a
live logging system into something that
you wanted to build externally and then
we published the XML schema definition
for the doc for the document
any other questions yeah well so I'm
Frank at push to test calm if you need
if you do think of a question after this
or if you have a particular application
at Google we would love to to see how
push to task could benefit Google thank
you thank thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>