<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Merb, Rubinius and the Engine Yard Stack | Coder Coacher - Coaching Coders</title><meta content="Merb, Rubinius and the Engine Yard Stack - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Merb, Rubinius and the Engine Yard Stack</b></h2><h5 class="post__date">2008-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TcMklv40YMY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody first of all I'd like
to ask that we hold our questions till
the end so that we can get those into
the mic and also have them for the VC in
the video our speaker days Edra zigmunn
Tuvok he's the lead developer on merb
and he's also a co-founder of engine
yard he is also of a book called
deploying rails applications which I'm
sure you're aware of and also he's
created to open source projects like
merb and Rubinius so please welcome as
resident pitch hi everybody my name is
Ezra zygmont of itch like he said I'm
have a little company called Engine Yard
we are a we kind of become a two-headed
company at this point we started off to
be like the Rackspace for rails build a
fully managed clustered hosting company
specifically targeted for Ruby and rails
applications and that's been a big
success and we kind of have another
branch of the company doing like
Rackspace for red hat for Ruby so
building a complete stack including our
Linux distribution a collection of
open-source software and we have a
number of open source projects Rubinius
merb vertebra a bunch of other stuff
going on to kind of build this full
stack system so so yeah that's a little
bit about what Engine Yard does today
I'm going to talk about merb and
Rubinius a little bit and we'll start
off with Merv Merv is a ruby web
framework takes a lot of inspiration
from rails as well as the number of
Python frameworks and Java frameworks
and tries to conglomerate them into what
we think is a very nice Ruby framework
merb kind of started way back in
September 2006 as a simple hack to do
file uploads outside of a rails
application and this is actually the
whole first version of merb fits in in
one pasty and it kind of grew from there
just was a fun project to work on in the
evenings and weekends and as it as it
kind of grew up and people started using
it I kind of just was like oh well we
can we can really build a full framework
that can replace rails with this and
learn
from rails good and bad sides so that's
kind of kind of where murdered was born
out of that was Murr then verb now has
been split up into a number of different
packages we're relying on rubygems which
is Ruby's built-in package manager to
make very modular so there's a verb core
which is the core framework which is all
the HTTP handling a tooling code basic
templating and rendering the rack stuff
which is like whiskey for Python and a
number of other core features for doing
you can use just murder itself to do web
serve wits and small web services and
smaller applications and then we have a
number of other pieces that both on top
of it to form a full stack and if you if
you just do a gym installed merb you'll
get what's called Merv stack which is
all of these pieces plus a data mapper
ORM and a jquery javascript library kind
of all packaged up into something like
you would be familiar with with rails
where it gives you everything out of the
box but we really focused on making sure
every piece is built in its own module
so that you can pick and choose exactly
what you want with rails you're kind of
forced into take it or leave it and you
get this whole kitchen sink and it's
really hard to take pieces out that you
don't need or to alter the the
assumptions of the framework so we've
tried to make sure that we we don't go
down the same road everything's modular
you can pick and choose exactly what you
want and not use what you don't need so
you get a much slimmer framework that
does exactly what you need rather than
the whole kitchen sink a couple of the
core tenets of what makes more burb it
should be fast there's no code is faster
than no code so you want to keep
especially in Ruby the current ruby
implementation is a AST walker it's not
a compiler compiler or anything like
that so the code gets parsed it out into
an abstract syntax tree and then the
interpreter spends all this time walking
around this tree executing code so the
more code you write in Ruby the bigger
your tree is and the worse the
interpreter will perform because it has
to walk a bigger tree so keeping Ruby
code as small as possible without
obfuscating it is one of the core goals
of herb to keep everything running fast
and we like to keep the code simple
and not do a lot of meta programming in
the core framework because I don't feel
like that's where it belongs the core
framework should be simple as possible
for you to open up and read and it
should it should be fast so we've spent
a lot of time optimizing the framework
to take advantage of all the quirks of
Ruby which there are a lot of quirks
right and so you really takes it can
take years to become proficient enough
Ruby to know which which kind of
operations are expensive and which
aren't and we've developed a pretty
extensive benchmarking sweet that's in
the Merc or repository where we
benchmark every little idiom we come
across to come up with the best fastest
way of doing something and apply that to
the framework and so it's a ton of micro
optimizations and some people might say
pre optimizations but taken as a whole
it really gives us a much faster run
time for building web applications we
spend a lot of time focusing on memory
efficiency one of the one of the big
downsides of rails is until recently
it's been a single threaded application
server so the application server can
actually only service one request at a
time other requests will kind of back up
and wait in line to be served so you
need to run a bunch of these processes
the big problem is that the processes
are going to average about 100 megs of
ram each and sometimes a little bit less
but a lot of times more even up to a
couple hundred Meg's each and that's a
lot of overhead for trying to run a web
application when each app server uses
hundreds of Meg's and can only serve one
request at once so you end up with these
huge infrastructures to support these
large websites and we've seen the pain
of that at Engine Yard hosting all these
rails applications and you know we
wanted to provide a better way so with
merb you can fit about three to five
merb application processes in 100 Meg's
compared to one rails process and each
process can serve two to three times the
traffic so massively reduce your
infrastructure costs for running a web
application by running on top of herb it
should be modular we talked about this a
little bit the whole framework is broken
up into pieces that are that all work
well together with each other or you can
self-assemble exactly what you need so
so I like to say with rails it's it's
like the best framework out there for
the 8020 rule
it'll get you eighty percent of the way
there faster than any other framework
but you'll fight tooth and nail for the
additional twenty percent because
anything it's not meant to do is really
hard to do so as long as you kind of
stay on this golden path and don't kind
of go outside the norm it's you know
nothing's going to need it for that
first eighty percent but you know the
first eighty percent is is just that
it's the first eighty percent once
people are online the running Arab some
production and especially with the way
the web is going with all these
different kind of mashups and you've got
different database backends that people
are experimenting with that are non SQL
it becomes harder to get that last
twenty percent done merb is built to
take you that last twenty percent of the
way we might not quite be as polished
yet for that first eighty percent you
know rails has a lot of helpers and a
lot of stuff built in but all those
assumptions really add up and you pay a
cost for them later so you know it might
be it might take you a little bit longer
to get up and running but it's going to
really stay out of your way much better
and allow you to go a lot further with a
project maintenance wise and integrating
other kind of things that we as the
framework authors haven't envisioned you
doing yet what we want to be able to
support all those kind of things this is
kind of one of the big points you know I
think rails was a lot of people's first
exposure to Ruby and it was the first
big ruby project so there's tons of code
in there that is uses a lot of meta
programming just for meta programming
sake it seems like we try not to do that
at all we try to keep the code in the
core as simple as possible and we want
and we encourage people as a writer in
applications to explore down into the
framework as well a lot of people end up
treating rails is a black box because it
is eighty thousand or so lines of code
and it's a little bit hard to step into
and figure out what's going on because
there's so much advanced Ruby
metaprogramming going on inside of there
and I kind of feel like the place for
meta programming and that kind of stuff
is in your own application code I'd
rather have the foundation that you're
building on top of be as simple and it's
easy to understand as possible so that
you know when you do hit the wall and
you need to look inside the framework
you don't you don't get grossed out and
you can
get in there and actually do stuff with
it we spend a lot of time focusing on
the application server part because I'm
a big server geek so I'm real interested
in making these things run efficiently
so we spend a lot of time recently
building a master worker kind of process
manager into Merv so you spin it up you
get a master process and say you're
going to run a cluster of three
processes it will spawn those processes
for you share as much memory as it can
Ruby's garbage collector is a little bit
weird the way it marks all the objects
you don't get very much savings from
from fork and copy-on-write as you would
with a better garbage collector but so
one of the big things I've seen that's a
real hard work around in rails is when
you want to deploy new code you say
you've got your five or ten application
server processes on two or three servers
you deploy your new code and now you
need to restart all these processes and
that can take a significant you know
couple minutes amount of time a lot of
most people just kind of punt and they
put up a maintenance page while they
deploy and you've got a few minutes
there where you have to go down in order
to to support this new code what we've
done is make it so save got a cluster of
three processes running your production
application and now you want to do a
code redeploy what we'll do is you run a
you do your code redeploy and you run a
fast deploy on the merb server what it
will do is it'll spin up three new
instances load all your application code
and at the very end when they try to
bind to the port they're supposed to be
listening on they'll bind that they'll
try to bind and they'll fail because the
old processes are still there but
instead of just crashing they'll go into
a loop saying hey can I can I get this
port yet kind of get this port yet and
then once they're up and running then
you kill the the original old processes
and these new ones just take right over
so you've effectively get rid of any
downtime for doing deploys so we spend a
lot of time working on that we also
integrated rack fairly heavily into the
framework rack is like wizzy for python
wsgi it's a it's an interface it's a
common interface too many different
servers so it allows us to not have to
change merb code to run on long roll or
thin or
or fusion passenger or any of these are
JRuby with glassfish any of these things
that support rack can run a Merv
application so you're really portable
across where you can run and one of the
big goals here is to stay out of your
way and be very flexible we're not
necessarily trying to cater to very
really beginner Ruby programmers with
mer we're kind of catering towards a
little bit more advanced people who
probably have some rails experiences and
have run up against the edges of the
framework so we want to be we want to be
low-maintenance we want to get out of
your way and let you do what you want to
do without a lot of ceremony and if you
want if you need to do something that we
have envisioned will let you do that
we've built into into the framework the
the idea of a public API and a private
api and a plug-in API and every method
in verb is documented whether it's
public or private or plugin and as
framework developers we're free to
refactor and change private api's and if
you use those it's your own fault if we
break them but we're trying really hard
to give public API at entry points and
hooks for anything people would want to
do as far as hooking into the framework
with plugins or monitoring tools or
anything like that so rather than the
typical so rails has encouraged a
methodology of using included modules
and alias method chain to hook things
into the framework and that's it's kind
of a bad way to go in my opinion at ops
you skates what's going on it makes this
the call stack much deeper and it makes
it much harder to trace through code and
see what's actually going on so we don't
allow that in merb itself if people are
trying to do some kind of plug in and
they can't do it without doing some
alias method chained dance then we'll
try to add a public API for them with a
hook so that they can do that because
we'd like to see everything going
through our public documented API and
support people that way one of the most
important things here is that verb is
not constrained by backwards
compatibility yet I mean we're just
about to release a one point 0 version
but a lot of this work I've done here I
originally was trying to do two rails
itself and there was just there was way
too much pushback
because and it's understandable because
there's thousands of people running
their applications and production on
Rails now and so changes you know big
sweeping changes are really hard to get
in because it'll break so many
applications and it's also there's a lot
of assumptions built up in this huge
codebase so I see Merv as an
experimentation ground for rails we kind
of have a clean slate we can rebuild
things take what we liked from rails
leave what we didn't like take what we
like from other frameworks kind of
experiment to see what would we like a
ruby web framework to be like and we can
do that without having all this baggage
so I think that we've built a pretty
compelling one point oh that that's in
release candidate right now that will be
coming out full one point o within a few
weeks and that's kind of a stake in the
ground no we're not going to break the
api's from here unless we bunco a major
version number but a lot of a lot of
what we do in merb can easily be applied
back to rails we're just a little more
free to try new things with merb we we
try our best to take to look at other
frameworks and take the best ideas from
Django or pylons lots of Java frameworks
course a lot were heavily inspired by
rails we're built on rack which is the
same as pythons whiskey you basically
have a class or a proc a procedure
anything that responds to call and takes
an environment which is basically the
hash of CGI headers and stuff you get
from any kind of web server and then we
return a couple of the status the
response status a hash of headers and
then the response body what you want to
render and we can use middleware like we
can say use rack show exceptions and use
the common lager and then run this app
that we defined up here and what that'll
do is anytime a request comes in from
the web server the web server will cook
the environment which is you know all
the CGI headers and call this proc and
pass that in and we're allowed to do
whatever we want with that so verb is
entirely built on rack and we have a
number of middlewares we use one for
like cross-site request forgery
protection another one to ensure content
type another one for a debugger for
profiler and for a number of things so
you can build up these middlewares and
stack them to get
to build an application chain it's
really powerful your google here I know
you guys use Django a lot and Django has
a concept called apps which is little
slices of an application like a little
blog or little forum or a little wiki
and you can stack multiple of these
together to create a big application and
we've kind of copied that in something
called merb slices and these are
basically full-blown merb apps but self
contained in a ruby gym and then you
have a main verb application and you can
say ok I want the the authentication
slice and I want the form slides and I
want the wiki slice and then you build
your main application up in your app and
you can override any controller or view
or model from the slices up in your
application so this is this gives you a
way to code reuse and to share
functionality between applications very
easily by using the the Ruby standard
package manager to ship these slices and
then assembling them together into a
cohesive whole so I get this question
asked a lot why don't you just work on
rails and do all this kind of stuff why
did you fork the community all this kind
of stuff and I think that monoculture is
bad and the more choice there is for
people the better the better off we are
so I think a lot of people have kind of
been down on me about merb and not just
doing it with rails but I'm a big
supporter of both frameworks and i think
that there's a look there stuff that
rails is better at and their stuff the
verb is better at we see a lot of people
actually using them both together in
conjunction people are doing their heavy
JavaScript UI stuff with rails and then
doing their back end web services and
heavy lifting with merb and combining
the two I think that's really powerful
and everyone wins when there's some
competition right if mervyn rails are in
a performance competition the users are
the ones who win and there's just you
know if there's only one framework that
everybody uses in Ruby then there's
those guys don't have any any reason to
not rest on their laurels right there
are it and with with merv kind of in the
rearview mirror a little bit think it's
been improving both frameworks a lot so
and lots of words lessons can be applied
back to rails I've actually contributed
a bunch of the rack machinery back to
rail so now rails can
fully run on rack and a number of other
things we've we wrote a better in
flector that changes you know singular
to plural plural back to singular for
four different inflections we wrote one
of those ten times faster when you
contribute that back to rails so there's
a number of stuff that's being like you
know spiked and experiment within verb
and then gets applied back to rail so
everybody can benefit so that's a that's
the reason former just going to kind of
keep moving quickly here talk a little
bit about Rubinius second so Rubinius is
a new environment for running ruby codes
max's ruby interpreter or MRI is what
they call the standard Ruby runtime and
there is the standard Ruby runtime had
no specification so there's no
specification for the Ruby language
that's just here's what the interpreter
does and if you want to write an
alternate implementation you need to
reverse engineer it pretty much so
Rubinius is basically as reverse
engineer Ruby 186 we've written a new
virtual machine in C++ for running the
actual bytecode and then we've written a
kernel a ruby core kernel so we have
things like string and hash and array
are all written in pure Ruby so it
follows the it's loosely based on the
small talk ad blue book which is a
classic virtual machine book for for
building small talk the ends and evan
has taken a lot from that we use a lot
of the same classes and a lot of the
same optimizations and apply it to Ruby
and the the kind of end game is to have
as much as possible of Ruby be in Ruby
so kind of turtles all the way down and
this gives us much better introspection
into the runtime of the language we can
in almost any object that's in the vm is
also exposed as a ruby object so we can
inspect the bytecode of a method or a
number of other things there's going to
be all kinds of cool new tools people
are going to be able to build along the
lines of refactoring browsers and
different code completion tools and
stuff because you'll have much better
introspection into the Ruby language
itself right
now current Ruby is mostly written in C
and it's in a fairly opaque kind of
style and it's it's fairly complex
project and so there's all these kind of
edge cases the language where you feel
like you're in Ruby but it's actually
dropping in to see behind the scenes so
there's some things that are unavoidable
there's a little impedance mismatch
there so trying to get as much of the
system up into Ruby as possible has been
off for some really nice advantages we
also have a library called subtend that
is a interface for running see
extensions that are built for Matz's
Ruby there's a lot of Ruby's not the
fastest language around so there's lots
of C extensions people use in production
things like imagemagick or full-text
indexing things or sometimes people drop
down to write C extensions for
performance critical sections of their
of computations of their application so
we felt it was fairly important to be
able to support those so we've written a
layer that allows you to just recompile
a see extension built formats as Ruby
and run it on top of Rubinius so that'll
help ease the transition for the innards
we've got an accurate generational
two-stage garbage collector whereas
current ruby has a very conservative
mark and sweep garbage collector and one
of the big issues with Ruby's garbage
collector is that it actually sets the
mark bit for each object in the object
itself so if you say want to spawn a
process and load all of your Ruby code
and then fork children and count on
Linux's copy-on-write to save memory
you're going to be disappointed because
you fork these children and as soon as
the garbage collector runs in the child
it'll walk the entire object space and
mark every single object so the colonel
will see that and say oh you could no
longer copy-on-write you need to copy
all this memory over so you'll end up
with two full-size processes rather than
one big one and one little one and
that's that's a major disappointment for
trying to run a high-volume Ruby web app
because you you basically pay the full
price for loading everything in the
memory for every process and it's also
very the garbage collector is very
conservative anything that's on the heap
that might look so er like an object we
will not be collected so ruby has some
major memory problems you know once you
once you use memory it never gets
released back to the OS and it allocates
it an eight megabytes so that's why the
processes get so big they keep you know
basically the biggest amount of memory
you've ever allocated for the life of
the process is the size the process is
going to stay and that's that's that's
no fun when you want to do like an image
manipulation that loads the whole bitmap
into memory but then you ditch it later
your process is not going to get smaller
again so people end up using something
like monett or some kind of watchdog
process to like watch the process and
say hey if you go over this much memory
restart it and that's pretty gross for
production systems so having an accurate
generational collector is a huge
advantage similar very similar collector
to what Java uses by codebase virtual
machine so romania's compiles to a
Rubinius bytecode set and we've got some
cool stuff like Ruben eous archive files
which are basically similar to java jars
or Wars or you can compile your whole
application all the bytecode into one
file and then ship one file for
deployment so that's a nice side effect
to having a bike co virtual machine and
it's capable of bootstrapping itself
actually the compiler and the parser are
written in Ruby and Rubinius is actually
bootstrapped off of Matz's we will be
using it to compile itself and then
going from there to move on to to
everything so taking a lot of stuff from
from small talk and Rubinius it's
basically the small talk 80 Blue Book
like I mentioned underneath but we've
got Ruby syntax rude behavior and all
the guys in the team have been
researching all kinds of crazy papers so
that they can find for four different
optimizations they've actually got llvm
wired into the back end of the vm now
for taking their binya spy code doing a
translation to get llv a bit code out of
that and then using llvm optimization
passes and compiling to native machine
code so there's a lot of headroom for
making this thing really fast current
current state they decided to rewrite
the VM and C++ back in May because the
whole project is test driven all the
Ruby components
but the vm was written in C wasn't very
heavily tested and I was starting to
kind of outgrow itself and become too
complex to maintain so you know we ran a
Rubinius was capable of running rails
which was like the big test for any new
Ruby virtual machine at railsconf in May
and it's kind of gone off the map a
little bit because they were like hey
we're on Rails now let's rewrite the
virtual machine and C++ and so that was
you know a few months of no apparent
progress but they're making really good
progress on that they're running about
eighty percent of the spec sweet again
and they're going to merge that back in
the head here shortly and we're really
looking at hopefully looking at within
six months having production ready we're
meeting at one point oh that's faster
than Matz is Ruby and I think that'll be
a happy time for lots of people so
there's a division of Ruby code I'm
going to get a little more technical
here in Phineas itself so in Colonel we
have our own kernel which is basically
how Ruby is defined and all this stuff
is written in C in the standard Ruby but
if you download the Rubinius project you
can actually read through all the
different stuff in kernel and the vm
actually loads all the stuff in kernel
directly without any requires we've got
one file that kind of tells the colonel
what order things have to be loaded in
and then we've got bootstrap a platform
and a kernel and bootstrap is real
Rubinius specific it's basically light
Ruby classes that wraparound calls into
the vm with Rubinius primitives and
that's specific entirely to Rubinius but
then we've got platform which basically
uses our FF I to tell which platform
it's on bsd or mac or linux or whatever
and set all the right environment
variables and set all the right calls in
the native code and then we got the
kernel which is no Rubinius specific
primitives are in there it's all just
straight Ruby code and maglev is another
Ruby VM by the gemstone Smalltalk guys
and there we've reorganized or Colonel
so that they can use our kernel know so
we're going to be sharing that with them
and eventually hopefully JRuby is going
to use our kernel as well once they can
optimize the JRuby vm to run Ruby code
fast enough to run every
Ruby so we're hoping a big goal the
Rubinius project is to have an
executable specification of Ruby
language since there isn't one so we've
got a spec suite with like 40,000
executable assertions of what the Ruby
language is we develop that by writing
specs formats as Ruby behavior running
it on matts as Ruby until it passes and
then checking those into the Rubinius
tree and working on Rubinius till it
passes these specs so we're basically
replicating bug for bug what Matz's Ruby
does because it is the only it is Ruby
right and we don't want to be we don't
want the Ruby language to fracture and
one of the really cool things is JRuby
and iron Ruby which are sons and
Microsoft's effort to build a Ruby VM
and maglev are all sharing our
specification sweet so they're all
running our tests so the Ruby language
doesn't fracture everybody shares the
same set of tests that says this is Ruby
and we split the Ruby specs project off
into its own site and even Matz is going
to be using the Ruby specs now since
they don't really have specs for Ruby
itself they've had a few disastrous
releases where they made a public here's
the production release and it doesn't
even run rails because they didn't have
any tests to run so hoping that having
this nice executable spec for Ruby is
going to help all the implementations be
stronger so usual and all the code is
loaded by the kernel it's it's not a
it's not like an OS kernel there's no
real strict division between what can
run in the kernel of What's in user land
and the different parts are labeled
basically just to help developers talk
about the code really big on first class
objects like everything basically every
part of the vm is also has a ruby
counterpart so you can access all the
different states of the vm compiled
method the method context provides a
huge amount of data in your Ruby code
and this is a really cool slide here's
eval and Rubinius and it's like 32 lines
of Ruby including comments and
everything if you've ever written your
own little scheme interpreter or or any
other kind of language you'll know that
eval is a really hard thing to write so
I think that's a pretty cool testament
to how everything is in Ruby code as
data since the parser
and the compiler are all written in Ruby
they're very flexible and built-in is is
the ability to take a string and turn it
into an S expression which is what the
compiler takes and compiles into Ruby
code so you can see you know one plus
one is ends up being this s expression
and we're going to eventually have full
macros like runtime macros you'll be
able to say okay give me the the S
expression for this method now rewrite
it and recompile it and reinstall it
back is that method again so it won't be
quite as nice as list macros because
it's a sin taxes so uniform but it would
get you most of the same power so in
robinia like in Max's Ruby you define a
method and that like the actual def
statement just returns nil it doesn't
return anything so we've actually made
the the def statement returns the method
context object for an actual method so
you can say meth equals death tests and
then we can put meth decode and we can
get the actual byte codes that this was
this was compiled to that gets sent to
the virtual machine for instructions the
parser is recent is recently been
completely rewritten in Ruby and I don't
know if anybody's ever looked at Ruby's
eval see or at Ruby's parser that's
written in yak but it's one of the most
insane parsers anywhere because Ruby it
was real big on making the language look
as beautiful as possible and that's at
the sacrifice of the parson being as
ugly as possible so we rewritten the
parser and Ruby now and so that much
more flexible and extensible you can
have parser plugins so ruby ruby has a
lot of stuff like you know % r and then
some brackets for reg ex or % s these
different little differentiators for
doing different things and you can
actually since the parcels pluggable you
can write your own and say % u or
whatever and do your own kind of things
like that so that's it's pretty cool to
have the whole parser and compiler
toolchain bein ruby it allows for a lot
more flexibility with experimentation
like it i want to add this feature to
the Ruby language if you're going with
the normal Ruby now you're deep in crazy
seal and whereas with this you're still
in Ruby the compiler
all in Ruby as well so the parser takes
the raw source code converts that into a
sex p and then feeds the sex p to the
compiler rival transforms that into the
st that gets walked and turned into the
byte code and then fed and fed into the
virtual machine or stored on disk or
whatever and since the compiler is all
in Ruby you can write plugins for it
very easily like so say we want to add a
plug-in for something called method
which will return the current method
context for whatever method you're in we
write this simple plug-in g is the
bytecode emitter we just do a couple
things here if the call method equals
method we're going to push our contacts
and send this method thing right so what
this is up doing is rewriting method
when you see it in the method contacts
current method which would be like this
def blah method name will give us a
symbol of that method so it gives you
very deep introspection in the language
and really easy ways the hooking of the
compiler to add custom stuff you may
have not considered in Ruby itself yet a
block environment is basically an object
we create that contains the environment
and the code for a block and block
environment call creates a block context
and activates a block so if we say def
blah we assign block given will get the
block object and call blah puts hello we
can say decode that method and give us
the the literals and the bytecode for it
tell us where the home was where the
receiver all this kind of fun stuff so
as you can see like there's there's no
way to get this kind of information from
standard Ruby so this is going to open
up I think a lot of different tooling
and ide support that just not possible
yet send sites these are like call sites
this is kind of where we base our
polymorphic inline caches on every place
every place where a call is performed
where there's a sender and a receiver
and a method is called we create a sense
I'd object and every time a method is
called in that same certain way we
increment a counter on it so we can
track how many times a call is and we
can use that information later to
recompile an inline methods for
dynamic optimizations it also allows us
to put in different caching and
different method lookups like the
standard slow look up in ruby has to
okay i'm in this object does this object
have these methods no ok go up the
included method module chain and see if
it has the methods and go up to the
super class and they go all the way up
to objects so it's like chaining through
all these object doing a hash table
lookup in each one which is fairly
expensive with sin sites we can actually
if we see a meth if we see that a
certain method is getting called most
times with a certain kind of receiver
like it's a fixed nom or the arguments
of fixed nom we can compile a native
method which is basically just raw
machine code that does the same thing
and install it in that sense aight so
that instead of having to do the slow
method look up Ruby can just say ok I'm
coming at this site with this Center in
this receiver ok i can just execute this
native code rather than doing a look up
so it gives us a lot of power for
optimization so if you look here we're
defining a method and then you can see
the method literals 0 is that is a sin
site and when you hit it you'll see that
there's one hit you hit it again you'll
see there's two hits so it's available
even in Ruby code so a lot of these
optimizations we do as far as
recompiling and adding native methods
the code is actually in Ruby to do that
not in C so we can see who the receiver
was who the sender the compiled method
was on the selector which is tells it
whether to go look in native code or
whether that do a slow lookup extensions
building an API compatible layer which
is sub 10 and this is just for running
standard Ruby see extensions with just a
recompile so it's pretty cool because
you know none of the other new VMs run
NEC extensions and a lot of production
Ruby code has at least one or two see
extensions so Rubinius is going to be
the only alternative vmware you be able
to run your code on modified so that's
pretty powerful through the issue though
is that in order to completely emulate
the standard ruby see interface we have
to do quite a bit of copying of data and
isolating the pointers and all this kind
of stuff and hooking in with our own
garbage collector so
doing it this way is kind of a
second-class citizen because it's quite
a bit slower but it will still work
which is which is nice Rubinius also has
a true ffi foreign function interface
layer that's pretty sweet this is part
of our POSIX platform which runs hooks
into the POSIX system whatever it is
based on your environment bsd or linux
or OS 10 and you can see here we're just
riding straight ruby code to say we want
to get our Malik and realloc and free
and Rand and all the stuff just from the
POSIX platform itself and this code we
tell it what the types are return types
and all that kind of stuff and so this
is like the native method right FF I set
errno is what the call is in the C
standard library this is what we want it
to look like in ruby and i know equals
and it takes an int and it returns avoid
so describing this in ruby the the FFI
later will go and it uses good new
lightning which is a native machine code
generator and it will automatically
generate the wrapper and allow you to
tie into native c code without having to
write any c code do the wrapping so
going forward you can just recompile
your native ruby extensions and have the
runner Rubinius but if you want high
performance you can just write ruby code
without changing your c code at all to
call in to c code so it's a pretty sweet
way of doing ffi and we've got like a
you know my sequel adapter and our
number of other things written in this f
of 5 style multi vm and concurrency
support is one of the big issues ruby
itself uses green threads which means
the whole interpreter runs on one
operating system native thread and then
it has its own scheduler and switches
between the green threads within a
process so there's no multi-core for a
single process in native Ruby Rubinius
supports multi VMs in the same process
since the whole vm is written in a
thread safe manner and it's reentrant we
can actually spin up multiple VMs in a
single process each VM runs on its own
native thread so you can use multiple
cpus and then each VM runs any number of
green threads inside of it so you get
this kind of
m times in concurrency going on and
there's a simple way to communicate
between VMs like from your Ruby code I
could say here's my args to a spawn a
new vm with these arguments and do a
standard out gets on it and it's just
like I was spawning a new Ruby VM from
the command line or whatever and then in
the in the other file i loaded you can
say meeting SVM each message and I get
the messages and you can pass just
primitive messages between bm's like
ants and symbols and strings and simple
arrays I think that's about it maybe
hashes but it's a real nice way to take
advantage of multiple CPU cores and it's
going to play a big factor in the
Rubinius application server we're
building to run rails and merv apps and
stuff so you can see let's say here in
this file we're going to watch reach
message and we're going to exit if we
get the exit symbol otherwise we're just
going to puts out the message and here
we're going to say robinia spawn that
other file and pass in these arguments
and get the standard out we'll see we
get those and if we pass an exit you'll
see that it goodbye and the other vm is
joined and left the picture so it's a
it's a pretty nice way of working with
working with multiple CPUs in the same
process without having to change a lot
of your Ruby code you can just run
standard Ruby code in each p.m. and have
them ask messages between each other
we've also got so threading a little bit
we'll talk about in standard Ruby we're
basically the same as standard Ruby we
got green threads so they'd stass switch
between each other simple timer based in
for preemption the API is exactly the
same the the vm itself is built on live
event which is an event-driven IO
multiplexing system so our i/o subsystem
is far superior to standard Ruby which
has some some problems all iOS
non-blocking and everything is based on
this live event loop so it within that
loop we use something called a channel
to provide scheduler notifications to
schedule these green threads and we
something called a task which is from
the PI calculus for for building our
thread abstraction on top of we also
have built-in actors similar to early
an actor is a way of doing currency
where you have a lightweight process or
whatever called an actor that has a
mailbox and you send messages to it and
it can selectively pull messages out of
the mailbox execute code and send
messages back to another actor so
Rubinius actors work basically really
similar to early actors they're not
quite as inexpensive to create I think
in Erlang it's only like 360 bytes for
an actor when Rubinius I think it's more
like 1.2 kilobytes or something but it's
still more efficient than threads and
it's basically a lot similar to Erlang
like if we say okay let's just make a
jet called data which is a struct with a
value and we'll say we're going to spend
10 actors and the master actor is actor
current then we can loop over those
spawn an actor passing in the master and
then do receive just like you would do
in Erlang with a filter and we'll say
filter win data so when an object that
gets put to this actors mailbox is an
instance of data then we'll accept that
message and we'll send the value back to
the master so you can kind of see it's
just a simple example loop over each
actor and send the data with a number in
it and then grab the actors from receive
and then say that the values are the
same so so rewritten it's a nicer way
than threads in my mind organize
concurrently communicating processes and
you can actually use the Rubinius actors
across multiple VMs it's transparent the
actors can spread out across all the VMS
you have running so you get a native
thread per vm and then you get a number
of green thread switch actors on each VM
channels are what provide our basic
building block for concurrency and
Rubinius it's basically a thread-safe
channel that you can send a primitive
over like an int or a symbol and it's a
way to block waiting for some kind of
message between threads they're simple
they provide a nice interface the
outside world so we can say ok let's
make a new channel ran is false will
spawn a thread and we'll call see
receive and that will basically block
this thread waiting on something to be
received on this channel and then we'll
say ran equals true after this returns
and then we'll run the thread we can see
that has not ran yet and then if we push
a symbol into that channel you'll see
that it will wake up the thread here at
thread receive and continue on with this
game so that's the basic building block
of concurrency and Rubinius it's used
for timing as well with scheduler in the
vm so we can say here's a new channel we
want to do something at five seconds and
here's what we're going to send on the
channel and we'll say scheduler send in
seconds this channel in five seconds and
the symbol did it and then we can say
the time now is is this right and we'll
say see receive and that will block
until it gets did it on on the on the
channel and the scheduler sends that and
then we can see here it is five seconds
later we receive that that block so it
gives us basic building blocks for
building timing and concurrency it's
also used for all the i/o events and can
be fired based on unix signals so it's
used for the full IO subsystem and all
the forking and managing your processes
and stuff as well as well as event based
interface to wait so there's no blocking
i/o and Rubinius at all it's all non
blocking and we use channels on top of
that to simulate blocking so Ruby specs
I already mentioned this a little bit
there's a website if you want to help
out or go check it out all of the all of
the major implementations are using the
spec sweet now which i think is one of
the sweetest things to come out of the
Rubinius project is the fact that it's
going to help Ruby not fracture as all
these other implementations build Ruby
because now they have something they can
run to verify that they are in fact Ruby
whereas without that I think we'd see
major schisms between all these
different platforms so I'm really happy
that everybody has kind of picked up on
this the spec suite including you know
the Ruby core guys Matz has given its
blessing and everything so I think
that's huge because Ruby does not have
any kind of specs there's like maybe 20
tests that come with the project when
you run make tests and they don't really
test much so there's been a lot of kind
of bad releases of Ruby because of that
because there's no way for them to
verify that what they've just done
change wise still lives up to the spec
because the only spec is like
run run it and see if it runs right so
now with the specification sweet we can
test you know releases before they come
out and verify that they're still
passing all these specs and I think
that's a huge huge advantage yeah I'll
open it up for questions now see see if
people have any questions it's the quick
one respects the curiosity what are they
implemented using our spec it's step 4
it's actually called em spec because
yeah you know Rubinius couldn't run our
spec for the longest time because it's
our specs fairly complex so m spec is
basically our spec compatible it can run
same r-spec syntax tests but it has a
bunch of stuff built in for built into
it for saying okay this only runs on MRI
this one can run on JRuby but not maglev
or whatever so it gives the implementers
a nice way to say we're not feature
comply on this one yet but so so yeah
but it is our spec syntax yeah so you
you mentioned you didn't want to
fracture Ruby code but I mean there are
new features you know method context and
so on that yep there are going to be new
code that that depends on that as well
as you know to a minor extent namespace
complex how do you envision the code
bases living so I think that there's
going to be you know each implement each
new implementation is going to have
certain features that other
implementations don't and so I think
people are going to need to get used to
organizing their code in a way that says
this is my Ruby code right and then i
have this file for when I run on
Rubinius or this file for when I run a
JRuby and it's just you know you don't
want to fracture the language but there
are some things that can be done that
are very interesting that can't be done
another vm so it's a good question i'm
not sure exactly how it's going to play
out right but i think that we'll have
some by the time we're getting one point
0 out the door we'll have some some
thoughts on that on how to organize your
code to to not get tied to a certain
platform and you know we've also done a
number of things like merb uses a number
of extensions to get like the era t and
the
arguments and defaults of a method and
that we wrote a see extension so we
could do that on MRI but then we thought
well we need this to run on all the
platforms so we were able to just write
Ruby code to get it to work on Rubinius
we're able to go to Jay Ruby and have
them implement it in Java and we're able
to keep the same API across things and
JRuby is using ravinians API for the
multiple vm stuff they're working on so
it'll be the same API to spawn multiple
VMs and as much as possible when there's
a feature that may not exist in Max's
Ruby but may exist in these other
implementations we're trying to keep the
same across them so there is you know
there is going to be some there is going
to be some schism as as people use these
new platforms but we're trying to keep
it as minimal as possible okay thanks a
lot okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>