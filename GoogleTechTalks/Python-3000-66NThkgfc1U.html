<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python 3000 | Coder Coacher - Coaching Coders</title><meta content="Python 3000 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python 3000</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/66NThkgfc1U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm Guido van Rossum creator of the
Python language work at Google since
December having a great time here and I
thank everyone for showing up so I can
do one more dry run of my keynote at
O'Reilly open-source conference next
month next week so that's why the slides
do not say Google but a scone anyway
this talk is about Python 3000 this is
slightly more comfortable for me and let
me just dive in with a slide over
overview of the talk I'm going to
explain a little bit of the philosophy
behind Python 3000 so you'll understand
where we are in the spectrum between
like c++ o 9 and perl 6 insert of the
possibilities of language renovation and
then i'm going to touch on what may some
people may find the most boring part
which is the actual process that we're
setting up to reach the right mix of
innovation and conservatism and then i'm
going to do a fairly random selection of
things that I expect will be in the new
language which all has to be taken with
a grain of salt since there's a timeline
that takes a couple of years probably
and then we'll open it and Mike for
questions you can interrupt me anytime
after the talk once if there's time for
questions afterwards I would hope that
people would use the mic in the middle
of the room so what is what is the
philosophy I do not want to design a
whole new language designing a language
is a lot of work and a lot of pain and
blood sweat and tears and all that and I
don't want to go through that again
and actually I think that Python is
pretty good as it is so my main goal for
Python 3000 is actually to to sort of
fix the miss this relatively small
design mistakes I made early on in the
language
I mean Python started out as a a
definite skunkworks project done mostly
in my spare time in week
and evenings because I had no life
that's the only way you can you can get
anything significant started in software
believe me and because because I knew
that I knew had limited time and limited
resources fraction of myself I did allow
myself to cut some corners and I try to
cut the corners that that were sort of
the biggest bang for the buck and that
that were actually defensible from a
more theoretical perspective in addition
to being helpful in saving me time
implementing it but I did make some
mistakes and some of those were easily
corrected and some of those mistakes
were actually really hard to correct
because they get at sort of the core of
of the language in terms of
compatibility and you would break
everybody's code by fixing a particular
design problem so python 3000 is the one
opportunity i'm giving myself for fixing
those design bugs that require the
language to change in an incompatible
way and that will break everybody's code
I could choose not to ever do that I
think in the long term that would be
less effective we'd have a worse
language and we'd all be struggling with
with that forever at the same time I'm
trying not to sort of do something like
Perl 6 where everything is up for
discussion one of the things we're doing
is in the Python 2 series we're
currently at python 2.5 is about to be
released by neil norway it's in it in a
couple of weeks i would i would
guesstimate python 2 5 is a very
evolutionary step from python 2 4 as
Python 2 for was an evolutionary step
from Python 2 3 and so on we are trying
to get the users to to sort of replace
certain old idioms with better new
idioms
but for backwards compatibility sake we
leave the old functionality in sometimes
we issue deprecation warnings to sort of
strongly urge people to move on but
first for certain things that that would
cut just cause a flurry of deprecation
warnings in every single Python program
so we it would be useless and those
especially are the things where we make
the new features available if we can
using alternate syntax in Python to
point X but in Python 3000 the new
syntax will be the only thing you have
so we have I have set up what what I
think is a fairly minimal amount of
process for for arriving at Python 3000
we need we need process I mean it was
clear that if you would just let the
community sort of participate
unrestricted we would end up with
something that was not not like Python
but a completely different language
something to differed more from Python
then then Lisp differs from alcohol I
mean there are just so many great ideas
for language development and let let
other language designers sort of explore
different different ways there's also
the sort of again I want to be pragmatic
I want to have something actually in
people's hands by a certain date and I'm
setting what what now begins to look
like an aggressive schedule and that
means that we have to limit ourselves in
in which things are up for for
discussion and which things were going
to just say that's for Python 4000 so
some of the some of the questions that
we asked ourselves and I asked the
community at when I started sort of
getting a little more formal about the
the 3,000 process was well what is our
timeline going to be and related to that
is are we going to draw Python 2.4 or
2.5
like a hot potato or are we going to
continue to support that for how long
are we going to wear support by thon -
and Python 3 in parallel what are we
gonna do about incompatibilities how how
bad can the incompatibilities be what
what types of incompatibilities are sort
of are ok what what kind of things do we
want to change and what is sort of
considered the spirit of the language
that we should not touch then of course
a question is what do you do with my
grading code from two to three that's a
really really tough issue and I'm not
claiming to have a complete answer what
we're not going to do pretty much by
definition is put in backwards
compatibility feature so you can run
your Python 2 code unchanged under
Python 3 what may happen is that you
will be able to write a dialect of
Python that is sort of a a large subset
that works both in Python 2 and in
Python 3 and we'll see what kind of
challenges you get there towards the end
of the talk there are a number of things
that are completely off the table things
that I just do not want to consider
because they're just a big red hole a
big kind of worms and there's never
going to be time to even reach agreement
or consensus on the design let alone
implement it another thing is I expect
that Python 2 and python 3 will live
alongside for such a long time that
actually certain Python 3 features will
be merged back into Python 2 in order to
ease the transition of code like in
order to make that that mutual subset
larger so the release schedule what I'm
aiming at is the first alpha release
sometime in 2007 the first actual 3.0
final release will be at least a year
after that then once once 3.0 is in in
sort of in people's hands and we're
feeling pretty confident about it
that's actually in some sense you can
consider that another alpha release to
the to much larger group of alpha test
and I expect that we'll get lots of
feedback that will force us to make some
additional changes that that are small
compared to the differences between
Python two and three but that are still
big enough to to increment the minor
version number what happened there I
didn't touch anything okay there we are
again the mysteries of PowerPoint on
window on Apple okay so two and three
will be developed in parallel so I don't
want that we want to be holding their
breath for Python for Python three I
mean you'd get pretty blue in the face
I'd also I want to make clear that the
Python community is devoted to
supporting Python 2 for a very long time
well Python 3000 is maturing so in terms
of version numbers and and these
versions typically come about 12 to 18
months apart usually closer on the
18-month side lately 2.6 which would be
then be out in a year and a half which
is before 3.0 it will certainly come out
I mean we're already sort of discussing
features that were too late for Python 2
5 but are really a definitely good idea
2.7 probably that's that's that's
they're gonna be the timeframe where I
will start back porting Python 3000
features into Python 2 for sort of for
easing the transition after that it's
anybody's guess my crystal ball gets
kind of blurry if we look more than two
years ahead I just know that I do not
want to go beyond two point nine at that
point the decimal system and and version
numbers sort of diverged in an
unpleasant way so how incompatible will
we let it be
well we're allowing new keywords new
keywords will always break a small
fraction of all code we're trying to use
keywords that aren't too popular as
variable names but we're I mean it's
really it's
that easy to detect that kind of
breakage because you just get a syntax
error when you try to compile it and
it's also dead easy to do some kind of
mechanical translation from programs
that use those keywords to some some
other identifiers that at least makes it
work so I have no qualms about adding
new keywords not that I plan to add a
dozen or so but definitely there will be
a couple the most well what I'm guessing
is one of the most shocking things that
will happen is that keys and range and
zip and especially keys that that's
gonna be pretty shocking is not going to
return a list anymore
my originally my original thought when I
mean I realized as soon as we had
iterators and generators in the language
at python 2.2 I realized that keys
really should have returned something
like an iterator so my original plan was
to do that in Python 3000 then at my
previous employer I had the opportunity
to work with the Java container package
for a while and I actually liked their
solution which is that Keys returns an
object that is a that that behaves like
a set but is actually in terms of
implementation a very shallow view on
the underlying dictionary so that's
probably how we're going to tap approach
this range if you're familiar with it
currently returns a list of many
integers we're going to replace that
with the functionality that you
currently get through X range which is
something that just remembers what the
parameters of your range are and then
generates the sequence as you as you
asked for it
zip is one of those functions zip takes
two or more sequences and then returns a
single sequence of tuples containing of
sort of parallel items taken from each
sequence in in order that should have
been an iterator of course unfortunately
zip was introduced in Python 200 and we
didn't have the iterators then so it
returns a list so that's in my view I
mean I think that probably 95 you
percent of all usages of zip are
actually in for loop where you say 4 X
comma Y in zip of less list1 and list2
so that that code will continue to work
another big big change probably the
biggest one in terms of implementation
because it touches almost every piece of
code and it touches every extension is
the Unicode transition we've had about 6
years of experience with Unicode in
Python now and while I was and still am
reasonably happy with with the design we
chose originally I think it's that sort
of we're ready for switching to all
strings all unit being Unicode all the
time and a separate bytes data type that
is very specifically not characters and
that's of course another idea I stole
from Java
I mean python has never been afraid of
stealing good ideas from elsewhere and I
think this is a good one that of course
means that we'll also have to redesign
the i/o library and I'll take that too
as an opportunity to fix a bunch of
other problems with the ILO io I will
because currently it's based on the C
standard i/o library which has some
significant problems for example you
can't switch between reading and writing
without some inter intermediate C core
flush call if you forget that the C
standard i/o library can actually just
seg fault or Core down on you that's ok
according to the C library standard
that's not a really great idea in Python
so we have to work around that which is
painful another problem with the C
standard i/o library that again there's
no standard way to find out how many
bytes it has already buffered which is
not really a question you ask yourself a
lot when you're opening a file but could
be very important when you're doing
non-blocking i/o on a socket that
happens to be connected to a file so
we're taking the opportunity to redesign
all that based on a better lower level
model
and then a stack of things that
introduce things like buffering and
encoding and decoding in case you want
to read and write text files very simple
silly case there should only be one
spelling for the unequal operator on the
other hand a couple of things that that
have been proposed at some point for
that that were considered improvements
by at least one person like making deck
top keys a plain attribute instead of a
method or changing the else clause on
the for loop to be code that is executed
if the sequence was empty instead of
what it currently does its executed if
the sequence did not does the loop did
not end with with a break that would be
sort of too weird or we're not going to
change operator priorities and a whole
bunch of other syntactic things so we
did think about migrating of Python 2
code to Python 3 and by from being a
very dynamic language where there is
sort of relatively little syntax not as
little as Lisp but there's certainly lot
less in text and in C++ or Perl there is
a lot about a program that you can't
easily decide based on what the code
looks like alone now we have tools like
PI checker that that can sort of make
certain assumptions about typical human
behavior that can deduce a lot better
but the net effect is that they don't
have perfect answers they can sometimes
get wrong so that's that sort of you
don't want to have that in in your
compiler let me take an example of
something that's too dynamic for for a
compiler that just looks at the syntax
of your module to get right if you call
some function f with an expression that
takes some object X and calls the keys
method on that object
now as
human reader I'm gonna be pretty sure
that that X is probably a dictionary or
at least some mapping object however
there's no real guarantee that that's
the case the other thing is without
actually knowing which function f is
which could be defined in a different
module or even in an extensional or
dynamically loaded we don't know what f
is going to do with those keys is it
going to iterate over them once in which
case Python 3000 will do just the right
thing or if it is it going to assume
that it gets a list and start deleting
items from that list or sorting it or
whatever or it may be all just iterate
over it five times or try to iterate
over it backwards that means that it's
difficult for a mechanical translator to
decide whether this statement needs to
be changed into something else or not
and actually even if F was a function
that try to sort its argument the
correct I mean as a programmer as a
human knowing what the program is trying
to do it might make more sense to say
okay this function should actually first
lista file its arguments before trying
to sort it so what we can probably do is
is write a tool based on PI checker or
at least very much like PI checker but
with a specific goal of finding things
that can change they will change in
Python 3000 so you can run that over
your program and it's probably easily
going to find at least 80% of the issues
with your code and it's gonna have a
bunch of false positives where it thinks
there may be an issue where actually you
happen to know more about the data that
the program is operating on and you know
it's not going to be an issue it's also
going to miss certain things in order to
find more of the things that that even
even a very smart version of pi checker
would miss there is a complimentary
approach where you take a Python to
interpreter but you instrument it in
such a way that the detect situations
were
objects are used in a way that would be
incompatible with Python 3000
one example actually was implemented
many years ago when we first first
introduced the feature of integer
division should really return a float if
you write x / y in Python the compiler
doesn't know whether x and y are
integers or floats it just generates a
division operator if you know that
they're integers and you want the
truncated
integer result you're supposed to be
writing x / / y which produces a
different operation code that is a
specific an integer specific truncating
division in Python 3000 x / y when x and
y are integers will actually return
float in Python 2 there is a special
thing you can do you can say from under
under future under an import division
and then in that module all your /
operators will also produce floating
point results when presume confronted
with two integers and for other types
they will do exactly the same thing as
before now what what we added to that
was a command line option where you
could say any of any occurrences of the
slash operator the division operator
outside the scope of from future import
division we're going to issue a warning
if the operands are actually integers at
this particular in execution so that the
warning will give you the line number
and the module where it occurred the
word pythons warning system is set up so
that by default you get each warning
only once for each line in each module
so what you can do very easily is you
turn on that command line option then
you capture all the the warnings about
that particular issue in a file and then
you run over that file and I actually
wrote little script ones that took such
a file and found the original modules
and produced a div script that turned
all those single slashes into double
slashes
now you still have to review that
because that could that that could be
cases where it's not so easy and you
actually want a certain different
behavior but that that is certainly a
very nice complementary solution to just
staring at the source for a very long
time until you think you understand what
it means actually running it and sort of
finding out what it's actually doing is
a great help but we can do that for
things like that function f called with
keys argument because we can dynamically
when whenever we have a list that was
returned from a keys operation we can
have a little flag on that list object
that says if you're ever being modified
in a way that's incompatible with the
Python 3000 API for these objects issue
a warning and then we'll know exactly
where that's being being done so sort of
approaching the problem from both ends I
think will have a pretty good solution
for migrating code but it's not going to
be personal 100% automatic so five is
write out one of my favorite multi
python and the holy grail quotes we
actually have a pet with a funny number
3000 99 that lists all the things that
were once brought up and that are
rejected outright like this is something
we're definitely not going to do for
example there will not be syntax macros
or other programmable syntax features I
mean there are quite a few people who
would love that feature and who would
kill to have it it seems there are way
more people who would hate it and would
absolutely be disgusted if it was ever
added to the language but sort of
difficult to choose but in this case I'm
just going to choose for what we already
have and we're my own preferences and
where the majority is a couple of other
examples parallel iteration I think the
zip iterator will do just fine
I mentioned keys and as an attribute
some people believe that I made a big
mistake by doing it letting iteration
over a dictionary return just the keys
I actually really like that feature so
that's not going to change well
sometimes I just take the BD FL
prerogative and and I make an irrational
decision and I'll just say well that's
because I like it that way and usually
eventually I'll be able to rationalize
it when pressed enough but I like to
trust my gut feelings I mean I've sort
of given in to pressure when it went
against my gut to often to find out
later that actually my gut feeling was
right it just hadn't figured out why so
I'm trusting my gut quite a bit that's
getting bigger so I don't want to change
the look and feel of the language too
much and I think that so far the
examples I've given sort of fit in that
general pattern I don't want to make
just random changes I don't want to make
changes that will confuse users and I
also don't want to add radical new
features now that is probably the one
that is - that will be most difficult to
keep the community from from sort of
from trying to do because whenever you
say ok we're going to create a new
version of the language is going to be
backwards incompatible everybody feels I
mean every Python user is in their heart
also an amateur language designer so
everybody has an idea for how they could
greatly improve their own productivity
if only the language had this particular
operator and sort of if you add all
those together again you'd end up with
worse than Perl 6 and not to harp on
Perl 6 it's a great project it's just
sort of an example of something that
keeps going on and on and on and the
Perl 5 people are just ignoring it for
the for the most part so I'm sure that I
will give in for some new features that
sort of somehow I managed to convince
myself are a good thing to have and
Python 3000 is a good opportunity to
introduce them but in general it's
not apart from the new features that we
have to introduce because of changes
like a Unicode everywhere I'm sure
that's going to give give us a bunch of
new features and the i/o library
redesign is also going to to be a big
new feature but in general I want to
restrict new features because we can I
mean especially new features that that
sort of have incompatible and sort of
have compatible new syntax like they
give new meaning to an to an operator
that currently doesn't have any meaning
you can add that anytime you don't have
to have a particular milestone release
to do that so now we get to what
everybody's been waiting for what are
actually the new features of the
language and I think I've already given
away bunch but and again I have to to
warn that this is is definitely a very
limited list out of all the
possibilities you know the things that I
have thought about and the things that I
will think about so the older Python
3000 peps start obviously in with the
number 3000 pepp 3000 being sort of the
Python 3000 meta papp that sort of
describes the project and explains a bit
about the process then three thousand
one and two and so on are going to be
Python 3000 specific meta peps process
paps
and 3100 is the first feature PAP and
3100 is again special because it is a
laundry list of features that are
currently seriously being considered and
as I mean for most of those will
eventually have a pap somewhere in the
3100 that will describe and specified a
feature in much more detail but at the
moment 3030 100 is the main laundry list
you can you are most welcome to join the
mailing list Python 3000
but do understand that if you come up
with you
favorite radical pet idea I might frown
upon it you can also follow my block
which is a much lower bandwidth way for
me to disseminate some thinking's and
and ideas and developments so there's a
whole bunch of basic cleanup and most of
this is listed in pepp 3030 100 and
these are all things that that sort of
have been in the works for a long time
as these things will change in python
3000 for example classic classes classic
classes were sort of these half-baked
user-defined classes that weren't quite
exactly as powerful as built-in types in
Python 2 - I introduced something called
new style classes which is exactly the
same as built-in types in terms of
capabilities however the new style
classes have a small but significant
number of incompatibilities with classic
classes so I mean I didn't want to force
everybody to fix their program if it was
affected by any of those incompatibility
so you have to you have to inherit from
object or from some other new style
class if you want your class to be new
style class at Google actually I think
most classes in our own code base our
classic classes what I've seen classic
classes will no longer exist in Python
3000 and all classes will automatically
be new style classes and if you're lucky
your code will still work and if it
doesn't one of the compatibility one of
the conversion tools will probably point
that out to you
exceptions very early on python has
string had strings as exception tokens
that was a bad idea but the exceptions
were actually introduced to the language
in the first couple of weeks of its
existence and the classes were
introduced only after 9 or 10 months and
I never really got to fixing that until
much more recently so with for a long
time we've actually had classes as
a possibility for exceptions then we
converted all the built-in exceptions to
two classes in Python 2 5 were finally
converting the built-in exceptions to
new style classes but you can still use
classic classes and you can still use
strings as exceptions that will no
longer be the case in - 3000 and in
addition your exceptions will now be
required to inherit from the base
exception class and traditionally the
base exception class has been called
exception it turns out that there is a
good reason for introducing a base
that's even more basic than the base
it's called base exception so
technically you have to inherit from
base exception but unless you understand
the difference and you have a really
good reason you should be inheriting
from exception so into integer division
will finally always return a float if
you wanted a truncating hint you can
write two slashes and you can write out
those two slashes today so that you have
the opportunity to do the right thing
already the difference between intz and
Long's that's another one of those
things we're very early on like in 1990
pythons first year when it couldn't
quite walk it it seemed a good idea to
have each type to be closed under all
operations and to have integers limited
to 32 bits or whatever the machine word
length was and also to have larger
integers but you had to specifically
request those so if you take two large
large 32-bit integers and you multiply
them you would actually get an overflow
error now in recent versions of Python
you don't get an overflow error for that
anymore you get a long integer but
because originally short and long
integers were separate types they there
are a number of operations especially
the things having to do with shifts and
octal and hectic
hexadecimal numbers they behave
differently so the same value as a short
int so
time's has a different outcome for an
operation as the same value in a long
int in Python 3000 there will probably
still be a difference in type but they
will behave exactly the same and we'll
do everything we can to sort of hide the
existence of the long type from the sort
of the average user see extensions will
definitely have to be aware of the
difference but in Python you will be
able to to get along without ever
writing the word long or knowing about
long integers everything will just work
as if everything was a long integer
absolute import by default there is
currently a painful ambiguity when
you're inside a package if you have a
sub module in the package that happens
to have the same name as a standard
library module you have completely
hidden that standard library module from
every cut every line of code in that
package because if say suppose you had
you had a sub module named sis whenever
a piece of code in that package says
import sis or from says import something
is always going to to look in the
package first and going to find the
system module that you have there
foolishly in Python 2 5 4 actually
optionally fixing that but you have to
use a future statement because there's a
lot of code that that depends on this
we're going to say you have to specify
your own package name or you have to use
special new syntax called relative
imports where you can say from dot
import sis
but if you say import sis you will get
the new module and that's going to be
the only behavior in Python 3000 getting
access to an exception you just caught
again long ago Python didn't have
threads so it made total sense to have a
couple of global variables that save
that information for you then we got
threads and we realized that those
variables were really hard to keep that
safe so we introduced a function that
should have pulled the information out
of thread local storage but we didn't
throw away
the old API so there's still a lot of
code that knows it's not running in
using multiple threads - especially
scripts that's using the old API that
will go away a couple of things that
have more modern spellings like Dixie
love has key you can just write if key
indict instead of if deck table has key
key file dot X read lines at one point
was the by far the fastest way to
iterate over all the lines of a file now
you can just say four line in file
object and a bunch of built-in functions
that either don't deserve built to be
built-ins or have better ways of
spelling them or have other problems
we're also going to kill a whole bunch
of ancient library modules because in
the first especially in the first four
or five years of Python it was pretty
much my own personal plaything and while
I shared it with the world starting in
91 for a long time I was sort of my I
was probably the biggest Python user in
the world and my team were the other
people in my team were number two three
four and five so we wrote a bunch of a
whole bunch of stuff that was useful for
our particular project we'd had to do
with with sound and video which really
didn't belong in the in the standard
library but we just put it there because
it was useful for us many of those
things are still there even though they
haven't been maintained in the last ten
years we're going to do a major cleanup
of that hello okay so we get to the
minor syntactic changes I think the
exact statement was a mistake so it's
going to be a function again backticks
don't look good on many in many fonts
they're particularly bad when you're
trying to produce PowerPoint slides so
there there's a functional notation for
that and we're just going to stick with
a function wrapper
we're going to fix an ambiguity in the
accept
handling syntax it's very sort of it's
it's it's like an attractive nuisance
that you can write except X comma Y and
you think that you're catching either
exception X or exception Y but what
you're really doing is except catching
exception X only and when you catch one
of those it's going to assign the
exception object to the variable Y
there's lots of code out there that has
this bug because of course those
exceptions never get triggered list
comprehensions will become syntactic
sugar for calling the list function on a
generator expression which is a new
feature in Python 2 4 there are very
subtle syntactic differences between
what's allowed in a list comprehension
and what's allowed in a generator
expression that mostly have to have sort
of has historical reasons and no
particular good reason so we're going to
change that to to be the same syntax
moreover currently the list
comprehension but not the generator
expression actually bleeds the loop
control variable in the surrounding
scope so if you say X for X in s and you
throw away the list comprehension you
still have a variable X that is equal to
the last very last value in that
sequence assuming of course that the
sequence wasn't empty because then it's
undefined
so we're not gonna do that anymore
because I really like the same feature
for for loops I mean I write code all
the time that goes over over some
sequence searching for a particular item
and when it finds it it breaks out of
the for loop and then after the for loop
I do something with the loop control
variable however I don't have the same
use for a for list comprehensions
bleeding their variables into disco so
that will be done and then there are two
different ways of raising an exception
you can say raise e comma argument or
raise E and then the arguments in
parameters in in parentheses and the
latter one is the is is the right syntax
of the former syntax only existed again
because
14 years ago we had string exceptions
only so range will become x range it
will actually become something like x
range plus plus because range currently
you can you can actually give it three
long integers as long as the sort of the
difference between the top and the
bottom one or the total number of
elements in the list is is limited you
can you can do that with range like you
can on a 32-bit machine you can easily
write the range from ten billion to ten
billion plus five x range currently is
limited to short integers we are going
to fix that and then x range is going to
be renamed to range and everybody should
be happier
zip becomes what is already known as I
see in the inter Tools library that's
just going to be an it's already mention
that actually and it's it's the same
with enumerate which which takes a
single sequence and returns pairs of
indices and corresponding values lambda
lambda lives about a year ago well maybe
a year and a half ago I was utterly
convinced that lambda had to die mostly
because there were so many people who
complained that lambda was not powerful
enough and you couldn't have liked
several for loops inside your lambda or
or an if-then-else even let alone a try
except and I was almost convinced that
yeah this this I mean lambda is is just
syntactic sugar for an anonymous
function definition it doesn't have any
any new semantics compared to what you
can do with the DEF inside another
function however when when I announced
that that lambda was going to die it
turned out that lambda has this this
hardcore following of people who really
liked it and they didn't so much try to
convince me to put lambda back
they spent a year trying to come up with
a better syntax for a more powerful
lambda and they didn't come up with a
solution so I thought to just save them
more effort and safe everybody pain that
lambda is actually perfectly fine and if
you have the requirement to put several
four loops in there or a try accept or a
complicated if-then-else construction
well you can just write a nested
function because as long as soon as it's
going to spend multiple lines lamb that
doesn't actually have all that much
advantage over a death it's the really
short ones where you have a lamb that
just adds its two arguments together or
other simple things we're not having
lambda is a serious problem at least for
certain styles of programming so I don't
want to have hear any more about this
lambda is going to stay exactly as it is
string types I already mentioned that
we're going to switch to all Unicode all
the time that means that when you
specify that something is a text file
you also have to specify an encoding for
that text file or probably we can use a
system default encoding which in in most
modern systems these days you can figure
out what the system default encoding is
and we shouldn't have to restrict
yourselves to ask you only there so
we're going to have two types one name
bytes and one in store which roughly
take the place of the current store and
the current Unicode accept the current
stir is very ambiguous it's both used
for slurping in large amounts of binary
data for example if you read a gift file
or you're reading the index of a zip
file or a tar file any number of
manipulations of binary data you store
that data in a Python 8-bit string and
you know what it means and you shouldn't
become sort of considering it as
characters for that use you should be
using bytes in Python 3000 on the other
hand
if you read text from a text file like
you open a file in text mode and then
you read data from it and you know that
it's like lines of text then the same
8-bit string care string type is
currently used to represent characters
the problem is that because we don't
actually know what encoding is used to
to hold those characters everybody has
their own idea like some like people in
in Europe or in the u.s. probably assume
that it's going to be ascii or sorry
going to are going to assume that it's
Latin won at least in most most European
countries on the other hand if you're in
Greece or Russia or any other country
where they use the Cyrillic alphabet
there is another 8-bit encoding that has
each byte being one character and of
course locally they think that that is
the normal interpretation of strings and
then of course in other countries you
have multibyte encodings and utf-8 and
it all becomes much more painful if you
only ever were manipulating 8 bits 8-bit
strings that contain your your sort of
your local default encoding you can
concatenate them and slice them and do a
whole bunch of operations and print them
and at the end everything will still
look right if you didn't accidentally
sort of cut them in the middle of a
utf-8 melty character sequence of multi
byte sequence of course but you can if
you just sort of read lines and
concatenate them that you're probably
gonna do okay however as soon as you
make these things with Unicode Python
would have to make a choice okay I know
what Unicode is I know every character
has a well-defined meaning but that
8-bit string I don't know what what the
bytes mean I don't know if that 8-bit
string contains utf-8 or if it contains
Latin one or any of the other perhaps
less popular choices so Python currently
actually decides to do not make a choice
there and throw an exception which of
course it's also very upsetting because
you can spend a lot of time testing your
code with ASCII data and everything
works fine
and unbeknownst to you at some point one
of your 8-bit strings
encounters a Unicode string and as long
as the the 8-bit string contains only
ASCII bytes that will work however now
you deploy your code in the field and
some user types their name and it
happens to have a Cydia or an umlaut
boom and that's a very common problem
especially in the web world so the
approach of having only all all strings
be Unicode and it's too bad that it
takes up more space but at least we we
are completely rid of the problem of
what if bytes and and Unicode meet each
other of course there will be a new
problem because now you'll have bytes
data that you read and at some point
you'll want to turn that into Unicode
but then you have to make an explicit
choice saying okay these bytes are going
to be interpreted as utf-8 or latin-1 or
my operating systems or this users
default encoding or whatever so it's
much more explicit about M codings
there's no implicit encoding like we
currently have and you will not you will
not sort of you will always know whether
you meant to have bytes or characters
because there are actually different
types there won't be a single type that
is used both for bytes and for
characters this of course means that the
i/o library will also change and the i/o
library will actually have different
slightly different api's for binary and
for text data like for text data you can
use red line but for binary data will
will not support read line and that gets
us into the new standard i/o stack I
already I think already sort of
mentioned all the problems with the CIE
standard i/o library there's also the
windows text mode and universal new
lines which means that if you open a
file in universal new lines mode it
understands that it understands all
three common common
four line endings return return line
feed or line feed but it only does that
only input on the output you still have
to use use text mode and use your your
systems convention since we're forced to
redo the new i/o library anyway this
this is going to be fixed and I hope to
learn all the good things from the Java
il library without making the same
mistakes this is this work is all still
in a very early stage I mean in theory I
know very well what the changes are for
getting rid of the 8-bit strings and
switching everything to Unicode in
practice that work has to be started yet
the i/o library is even even farther
away because I haven't spent enough time
thinking about what shoot what should
the API for the i/o library be and there
are fortunately there are some people in
the Python 3000 community who are
interested in helping me out with that
and this one this is a very interesting
slide last time I did I gave this at
this talk at Euro Python when this slide
came up everybody booed me and when I
explained what was actually the matter
everybody applauded so and pretty much
the same thing happened when I first
brought this up on Python dev so the
main problem with with print being a
statement apart from it being the only
sort of semantic action in the in the
application domain that has its own
keyword is that sooner or later every
program ends up having to to sort of
turn its IO more into a framework like
you start out with a simple script and
when something goes wrong you print a
message and you quit at some point
you're going to use the login module now
you have to find all the print
statements and turn them into calls into
the logging modules
API it turns out that take
the print statement and turning it into
a function call is something that
requires a lot of manual labor and is
not easily done with some kind of global
substitute because you have the syntax
is so different that like even finding
the end of the print statement and then
there are things like trailing commas or
not it's just all kind of painful so we
will have print parentheses and then a
number of variables and a closed
parentheses and that will pretty much
behave exactly like the current print
statement you can specify ah there's a
question oh yeah I think thanks for
pointing out the typo there I'll fix
that before I go too awesome that's why
I do it here first
you can specify to which file it goes
which by the way when we first discussed
this some people said well when we make
print a method on the standard i/o
library then you can just say file dot
print instead of print with a keyword
argument to point out the file the
problem is that lots of people have
their own file like objects
implementations that don't have a print
method they have a write method they
would all have to grow a print evident
because Python uses duct typing you're
not all using a common base class that
would solve this problem once and for
all
so having print as a built-in function
to me is sort of the right level of
support for for print at this point now
if you want to use some of the fancier
features of the current print statement
like trailing comma you'll have to use
another API and we haven't decided yet
if we're going to introduce something
like printf but takes a format string a
lossy or maybe something called print
raw that just concatenates the arguments
as strings and prints that rather than
inserting spaces and have handing new
lines
dictionary views I think I discussed all
of this already it will return a set
view this is an interesting one when I
when I started Python 16 years ago
I knew it was going to be completely
dynamic you could have a list containing
an integer a string a floating-point
number and a function and for some
reason I thought it was because list
support being sorted I thought it was
necessary to be able to sort that kind
of list with completely random types of
elements it turns out that there isn't
actually a really good use case there's
hardly any use case for for sorting a
list of random random elements there is
a very good use case for comparing
objects of different types with equality
is X equal to Y we can ask that even if
we know what X is but we have no idea
what Y is if Y is a completely different
type than X we'll just say that they're
not equal but if Y is a completely
different type than X it's fairly random
to decide whether X is less than Y or
greater than Y and currently we make an
arbitrary decision based on where the
two guys are in memory which of course
creates problems for jython because
enjoy phone objects can move around in
memory so I think it actually has to
choose a different thing or it chooses
where they were in memory or originally
it turns out that it's actually much
better to just drop the whole idea of
every object can be ordered with respect
to every other object if two objects
don't specifically implement an ordering
relationship between them it's just
going to be an exception runtime
exception to try to compare those and
finally and I see that according to the
clock were actually close to the end
this is my last slide my last real slide
this is this is just an idea and this is
actually one of those new features that
may or not may not make it into the
Nuala into the language it has a certain
it has a certain elegance to it it's
it's actually a really powerful idea to
what extent that is pythonic I haven't
made up my mind yet unfortunately I
don't I didn't actually include a code
example in the slide the idea is that
our current classes of course dispatch
on the type of the object generic
functions or I like to call them
overloaded functions choose which
implementation to use based on the type
of all the arguments you could have a
function foo and you actually have to to
sort of do the equivalent the moral
equivalent of declaring it as a generic
function of a number of arguments and
then you say okay here's how foo is
implemented when both arguments are
integers here is how it is implemented
when the first argument is a string and
the second one is a float here is how
you implement it for some other
combination of types you can put
user-defined types in there as well
those implementations don't all have to
be in the same file you can have a
generic function defined in some common
library module and then two different
third-party libraries can each define
implementations for types that only that
library knows about and then user
application can can override those or
add another implementation for a
particular combination that that crosses
two or three third-party libraries the
most interesting part of this is that if
we actually do this we solve we solve
the problem of adaptation there's a
pepin I always forget if it's about 245
or 246 that proposes adding adaptation
to the language and several large
frameworks like zouk entwisted have not
waited for the tab to be accepted and
have implemented their own adaptation
is basically you take an object and a
type and then you say adapt the object
to the type and what it returns is
something that either is of that the
type or at least behaves like that type
and of course if the object already is
of that type it's a very cheap no of you
just return the object itself on the
other hand you could have a registry of
well if the object is of this particular
type we use this function as an adapter
or this class if it's of that type we
use that other function or class as an
adapter and again the idea is that there
is a single global registry and that
every module or every library can add to
that registry as it feels fit it turns
out that the adapt could just be one
special case of a generic function the
downside of this is that it it it feels
like a fairly big deviation from what
people are used to do in Python so I'm
still on the fence about whether to add
this or not and I blogged about this
extensively so you can read up there
also yeah you mentioned jython briefly
and I was just curious if there was ever
any interest within the Python community
of formally committing to supporting a
giant implementation so to keep up yes
the PSF is actually financially
supporting jython
we have recently acquired a new project
lead for the iPhone project who is
hopeful but doesn't want to make
commitments based on past experience but
he's hopeful that he'll have joy from -
- which will be compatible with python
2.2 in terms of feature set and that's
that's a very major step forward before
the end of this year probably in the
third quarter even it's my guess I um I
think on your blog you hinted at static
typing maybe um could you comment on
that and your thoughts the static typing
is is great food for thought
I don't expect much of that to make it
into Python 3000
some of the syntax may may sort of be
supported optionally I doubt that we'll
be doing much with it and it's it's sort
of it's a really big thing it's it's
it's possible to to accidentally sort of
initiate a complete paradigm shift and
I'd rather in control of my paradigm
shift I'm a bit of a control freak there
any changes to scoping not very much I
think what we what what's likely to
happen is that there will be syntax so
that you can assign to a variable in an
outer scope like you have a function
outer which inside that there's a
function inner currently the if you have
a variable inside outer then inner can
reference that variable and it can call
methods that might mutate it but it
cannot actually reassign to that
variable you will be able to do that we
are currently discussing what whether
the syntax should be the word lock the
key word global or some other key word
like maybe non-local which is kind of
iffy because it's a negative expression
or outer or various other things have
been considered but that's that's pretty
much the only change to scoping that I
foresee possibly also actually will will
will do something like do an analysis of
whole module and look at which global
variables we can detect are being
defined there and anything that is being
defined that that's not explicitly
defined or imported and not known to be
built in we can flag that as an error
and we can then also do a certain
optimization where you say well if if
you're using land and we know that Len
is a built-in and you're not assigning
to land anywhere and inside this
function inside this module we can
actually generate more efficient code it
just uses a new opcode that implement
that asks for the length of an object
without actually doing a lookup of a
function named Len and for for certain
built-ins that would really make a lot
of sense
will the will the threading model change
will they still be a global interpreter
lock dare will very likely still be a
global interpreter lock if you don't
like that you can use Jai thong I will
follow up on your answer to the question
before about scoping I'm surprised that
that you think you can you can make
those optimizations because I could
potentially I could in some other module
I could mutate this module and insert
something called Len but you don't know
when you're compiling this module that I
did that right that is because that is
technically legal but it is morally
frowned upon and we're going to actually
change that change the language rules a
little bit so that if if you just insert
random names in into other modules
that's not necessarily going to be
accepted of course you can if a module
has a global variable everybody will
still be able to give the global
variable a different variable different
value whether that's a good idea or not
it must be code out there that
legitimately does this there is code out
there that legitimately does this with
names that do not conflict with
built-ins I'm not sure that there's any
code that anybody would actually be
willing to show in public that does this
for built-ins hi I have a question that
came from a remote site Santa Monica
it's asking you to comment on a specific
feature
how about postfix if statements they're
allowed in list comprehensions I don't
see a wise reason not to allow them
language wide it sure would make
one-liners cleaner well what actually
what what we add in Python to 5 is not
exactly a postfix if statement but a
conditional expression that has the form
expression 1 if condition else
expression 2 so that the unique property
of their syntax is that the condition is
in the middle between two two branches
you can think of that as opposed to fix
F but it has a
it requires the else so that's that's I
don't think I want to add a postfix if
to everything like assignments or calls
that that somehow that doesn't feel
pythonic to me and maybe if you're new
to the language and you come from a
language that has that you sorely miss
it but I like to in general I like to
see my ifs when they apply to a whole
statement to be up front so I have kind
of two questions one is that there's
this always been this wacky syntax in
Python where you can say low is less
than X is less than high and that get
smudged into low is less than X and X is
less than high but I never hear anybody
talk about that is that that's or is it
just works okay the other thing is is is
there are all sorts of interesting new
wacky things like transactional memory
and and replaying debug you know like
recording debuggers and stuff has any
thought been given to that you know in
terms of Python 3 not specifically in
terms of Python 3 it's not something I'm
very familiar with myself I actually
have an intern who is interested in
transactional memory
I think the pipe eye project is a good
place to look for for that kind of thing
because they're building an entire new
Python universe which includes or will
soon include a JIT compiler and all
sorts of language transformations where
I think a reverse reverse debugger might
well be amongst their possibilities if
they haven't already done it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>