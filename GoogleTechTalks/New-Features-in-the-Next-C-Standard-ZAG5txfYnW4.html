<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>New Features in the Next C++ Standard | Coder Coacher - Coaching Coders</title><meta content="New Features in the Next C++ Standard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>New Features in the Next C++ Standard</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZAG5txfYnW4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're going to have a talk today by
Lawrence Krauss who's very involved in
standardizing C++ in in the push for the
C++ Oh X standard he's going to be
talking about some of the new features
that are coming up in the C++ standard
he's gonna be building on the talk that
Matt Austin gave a couple of weeks ago
and here he is thank you in my life yep
okay the the first thing I want to
clarify is what the standard is trying
to do extend the language in a new
domain so that application areas that
were formerly not standard and difficult
wouldn't would be you could write
portable programs for enable programmers
to write better programs and to try and
preserve some source level compatibility
the one thing you will not see on this
list is fix the language because as it
turns out that if you have your pet
peeve and you try and fix it and you
follow that through you often end up
breaking significant source
compatibility or breaking the way people
want to write programs so fixing is very
difficult now the standard is trying to
do that but in some cases if it promotes
these other two goals but other than
that we're pretty much not trying to
change what's there this talk I'm gonna
try and hit the six major primary
features that are in this next C++
standard go over those and outline so
this is not a detail this is an outline
and then I'm going to sort of skim over
the rest of the features and give you an
idea of where they are are not in in the
standard in terms of likelihood most
talks don't have a whole slide related
to disclaimers but I'm going to give it
to you one is most of this talk is a lie
and what isn't a lie will be a lie later
when they change the standard so what I
want you to take away from this talk is
the kinds of things that are happening
and a checklist of things you might want
to investigate further and because
there's a lot to go through
I'm gonna ask that you hold questions to
the end unless it's a clarification for
what's on the slide so questions about
did you think of doing it this other way
or that's pretty stupid or things like
that I'm happy to take those questions
but let's move them towards the end of
the talk so that I can keep moving
through now we move into the first part
of the talk and use the primary features
everybody really wants these features in
the language the question is how to make
it happen and we believe that these
features have a high impact on the way
people write programs so for those two
respects it's pretty important to pay
attention to these features the first
main feature and the one that I've been
spending most of my time on is
concurrency and increasingly over the
last few years we've lost the video the
need has become apparent for some sort
of standard mechanism for concurrency
people have been getting by with P
threads and Windows threads and various
other platform specific mechanisms in
large part because not many applications
get hit by it they tend to get hit in in
rather small areas and so you can
survive however with the advent of more
and more client-server programming and
the introduction of multi-core
processors parallelism is going to be
everywhere we need the language to have
a standard way to talk about all of that
so that people can write portable
concurrent programs the main thing we're
doing is standardizing the current
environment there are a lot of good
ideas for parallel programming they're
all over the map and everybody has ideas
of why theirs is better and it's
probably true but we can't afford to
chase what isn't well supported by the
operating systems and in fact we're
going to queue fairly closely to what's
actually there in the operating system
the approach of the committee can be
broken into two part
there's the core language part and
there's the library part the core
language part is really focused on what
does it mean to share memory and how are
your variables different this is the
kind of detail people just sort of
assumed would be there but that's
because you're assuming a sort of a
model of shared memory that's no longer
practical in the real world and then at
the library layer there's lots of
questions about how things happen and
we're where things get hooked up and so
they're still ongoing debate in a lot of
this area the first thing about the
memory that we're going to be dealing
with is that we have a loosely coupled
shared memory in the wild that's the way
the machines work the traditional notion
of you know you do a write to a variable
and every other thread sees it instantly
is no longer viable the hardware doesn't
work that way so we need to export the
complexity of that model a bit to the to
the real - through the language and we
do that by basically if you have normal
reads and writes those are local to your
thread until they're explicitly
communicated to other threads and we
don't use volatile to make that happen
the problem is volatile has existing
semantics and we might start breaking
things if we messed with those semantics
now the other effect of this loosely
coupled thing is that what happens when
two threads try and do ordinary writes
to the same variable concurrently well
this is called a race condition it means
your program is undefined and it could
as well order pizza as do what you asked
so but we define what races are and I
won't go into that in the talk a
consequence of all of this definition
though is that some optimizations in the
compiler are no longer legal so the back
ends of the compilers will have to
change we don't believe that these
optimizations are important or
significant so we're okay with
restricting those optimizations on the
other hand there are a number of
optimizations that key off of an
assumption that loops will terminate and
those are important so we're basically
going to define a priori that the
compiler may assume that a loop will
terminate and this affects code motion
significantly so there's sort of a
compromise between the optimization and
the strict program the next topic is
variables what happens to variables in a
concurrent world now you might have
thought that this was already handled by
the previous slide of what what does it
mean for memory but in fact it's not
quite the first thing we'll be doing is
adding thread-local storage this is in a
lot of compilers already and we're
pretty much going to standardize the
common existing syntax but unlike the
current implementations we will probably
also allow for non pods that is
constructors and destructors on
thread-local variables so this gives a
whole new storage dimension to the
language the next thing we need to do
deal with is what happens when you have
multiple threads that try to initialize
a variable at the same time so for
function local statics we will
synchronize that in all likelihood for
global variables we'll probably
rearrange things so that what is
currently barely reliable becomes the
illegal and that then allows concurrent
construction of global variables and you
have the whole issue of destruction of
global variables exactly how does that
occur and should you do it at all should
we take a major incompatibility hit and
say global variables are never
destructed there's some good reasons for
that but source level compatibility is a
severe constraint maybe we don't want to
break programs quite so much that is
still an open debate and happy to hear
opinions on that
moving into the library side our first
approach our first steps into this are
going to be somewhat conservative will
have a basic thread class that has a
fork and join model of execution and not
much more
and then with some hooks to get to OS
types so if you really need to use POSIX
details on your thread you will be able
to get the POSIX handle for the C++
thread and tweak it and our hope is that
that will be confined to those
applications that are serious about it
and in areas of the application that are
already somewhat machine dependent but
that the bulk of the language the bulk
of the program will be able to work
without this the synchronization model
is mutexes and condition variables which
is common in the POSIX world and it's in
its cropping up in the windows world and
the primary reason to go this route is
everybody who's programmed in both
models agrees that the condition
variables are easier to use than the
windows events and it allows the monitor
paradigm which has them some theoretical
work behind it
termination when a friend ends is where
some of the sticky start stuff starts to
come in the easiest case is when a
thread just exits its top level function
so the thread is done and continue on
what happens if that's not the case if
you want a thread to die earlier than it
otherwise would have in that case the
standard is going towards some form of
cooperative termination where the the
thread you want to die has to cooperate
and the reason is that any non
cooperative way and involve some sort of
asynchronous
hit to the thread
and that asynchronous hit causes immense
problems in the language and the
compiler and their strong opposition
against that then the question is well
what happens if the thread throws an
exception and it's never caught and it
goes off the top and the answer is well
there are several answers and the
committee is hotly debating this issue
so I don't want to try and predict
what's going to happen out of that right
now now the plan however is to do
significantly more later if not in the
standard then in what's being called tr2
technical report - this is a library
technical report and the intent is to
simplify a lot of the kinds of
programming that people are going to
want to use routinely thread pools
values with joins futures parallel
iterators all kinds of stuff
the reasons for deferring this work sort
of add up and I don't want to you know
there's this you know one reason you can
point up but there's a lot of little
reasons the next major feature is called
concepts think of this as type checking
for templates so right now when you
write a template you really have no way
to communicate in the language what it
requires out of the parameter types and
anybody who's done the wrong thing with
a template has noticed two page error
message and you have to try and figure
out what went wrong and so this proposal
is intended to address this issue it
also has a consequence in the way people
write generic templates so what we're
going to do is add in a construct called
a concept and when you write a template
you can say this template requires this
concept on its arguments in this
particular case we can say the
combination of parameters I and V must
meet the concept or the constraints of
an input iterator and then you continue
on with the definition of the template
yes excuse me
yeah that's an exclamation point
let's defer that till later okay so you
we have templates we have concepts and
how do you write a concept well a
concept looks very much like a template
the only difference is that the contents
of the concept are basically a signature
of the operations that you need to apply
and these operations don't necessarily
have to be member functions they could
be free functions but those signatures
sort of have to exist so that the
template that uses them can be assured
that it's available at the time when the
person writes the template so right now
when you write a template there's no
real type checking until it's off in the
users hands with concepts you'll be able
to check ahead of time at the point
where you write the template before you
ever give it any client type any
parameter type as you might suspect you
can compose these requirements these
concepts into you know build upon
previous concepts now there's this
little keyword up there called
Auto and that is because of a third
notion in concepts and that's the
concept map so if you have concepts and
you have types how do you connect the
two now for auto that handles the case
where the two have an obvious mapping
all of this function signatures are
exactly the same the names are the same
everything just Maps straight over and
the compiler will do that automatically
if you have an auto if things don't map
up automatically then you can write a
concept map manually and that allows you
to do things like map a concept into a
pointer so an iterator in the current
standard pointers can serve as iterators
but
you need a way to get make sure that the
pointer matches the signatures of a
concept and so that's where that map
comes in so you want to think of these
of this work as three pieces the
template the concepts it requires and
the mapping between concepts and types
the next major feature technically is
called our value references but more
generically you want to think of this as
as move semantics and what it's trying
to do is address a problem with the way
people write C++ now in that the natural
way to write a number of things results
in a lot of copying and as objects get
bigger and you pass more and more
parameters this can result in
substantially more copying so and you
often really don't need the copying and
sometimes it's wrong like when you have
a lock or certain other things like that
and so we'd like to be able to write
code in which we don't copy things but
instead we have a conceptual move of the
information from one variable to another
not a copy of the information but a move
of the information the information is
drained from the old object it in some
ways you can think of this as doing for
copying what mutable did for Const gives
you a way to sort of back through
excessive constraints and as I mentioned
the r-value references are the mechanism
we use to achieve the move semantics
basically it's a new kind of reference
that will also bind to values as well as
variables and we use this double
ampersand as a as a declaratory insist
they aren't first-class types there's
sort of an abbreviation
then the type system to allow you to
write things and in the example down
below you can see where you would sort
of have a difference between the
existing copy semantics where we do a
copy construction and the move semantics
where we sort of copy the pointer over
and and eliminate the pointer from the
other side and that's the difference
between the move semantics and the copy
semantics it's sort of the classic
example of where there's move semantics
can helps out is in swap if you write
and swap in the ordinary way now
everything get had ends up with two
copies at one point or another so you've
got three full copy operations in extra
storage with move semantics you can
eliminate all those copies and just do
the moves and that syntax there std : :
move is a function in the library that
does the appropriate implicit casts to
make that happen so that's not a
language primitive it's just an auxilary
function in the library but you can
expect to see that show up in a lot of
code and you can also use it for
forwarding in particular if you want to
create a factory the typical
implementation of factory ends up
copying the arguments yet again this
allows you to just sort of chunk those
arguments straight through
the next thing we have is constant
expressions in the language so right now
we have constant expressions but they're
really confined to basic type basic
operators and anything else isn't
constant the problem we have is that
particularly within the context of
template programming you really want to
sort of a generic facility for constants
so macros don't work well in templates
and if the the standard defines in
numeric limits that everybody knows it's
constant but because the definition of
language it's not constant and that's a
bit of a problem the fact that certain
types aren't constant and certain
expressions aren't constant means that
the standard library is sort of written
with vague words where everybody knows
how they want to implement it but they
don't really want to standardize this
sort of quirky way it's implemented so
there's sort of notional types that are
manifest as either an enum or a int or
something like that but probably the
most important reason is user-defined
literals people would like to write
their own type for say a probability and
be able to write a user-defined
compile-time literal that could
potentially get baked into ROM there's
no way to do that in the current
language and this mechanisms lets you do
that so here's the simple syntax we've
introduced a new keyword context burg
and you can provide that as a function
specifier and that says the intent here
is that if the argument to this function
were a constant then the function itself
would be a constant and the way this the
there's a cement a syntactic restriction
that the body of the function must be a
single return statement with a constant
expression so the compiler can validate
that you are correct by assuming that
arg is a constant
and then seeing if the return expression
matches all of the rules for constant
expressions in the language and if it
doesn't it will provide a compiler error
but you're not restricted to using this
function on constant arguments you can
use it on variable arguments but the
resulting function call won't itself be
a constant expression so we can push
that through but you might get silent
place in your expression where the
constants of it has been dropped and you
can prevent that by declaring a variable
to be constants pression and that says I
expect this to be constant warn me if it
isn't and it all follows through and the
bottom case is where that has failed to
happen where we get an error because
beta is a variable it's not a constant
and so that stops us as we as we move on
through and here's where the
user-defined literals show up in this
case for complex numbers we're basically
going to run through and make all of the
member functions be constant expressions
so that we can write a fairly hairy
expression and have that come through as
a constant available and evaluated at
compile time and in this case we're
doing what the what the library would do
for us which is declaring a constant for
the imaginary the unit imaginary and all
of that can work with general-purpose
language mechanisms we have had no need
in this case to introduce complex as a
predefined language type to get compile
time efficiency out of the type so we're
leveraging we're leveraging a
general-purpose feature and you as
regular programmers can also leverage
this feature
the next big feature we have is you had
a clarification it will change what the
compiler generates the next major
feature we have is automatic typing for
variables so the compiler right now does
an awful lot of type inference in the
process of doing an expression but the
minute you write a variable declaration
you have to be very explicit about the
type and so this is a way to avoid
having to dredge up type information in
places where you don't really want it
and in particular in refactoring if you
have the top expression you're looking
at doing in some investigation to see
what the type is and how to declare any
variable if you want to avoid doing the
duplicate call and now with reusing a
very old c keyword we can make that
happen automatically for you that helps
when you're declaring variables but we
can also get information from
expressions which helps template writers
avoid having to ask to more information
out of the user than necessary in
particular if I'm trying to write a
product function right now if T and u
are of different types and perhaps the
product yields a third type I have to
ask for all three types out of the user
in order for them to be able to call my
function you really want to avoid that
extra type information because you can
infer it and we're basically using
something very similar to the GCC type
of primitive the names have been changed
to protect the innocent and so now you
can write the declaration of product in
terms of the type of an expression
rather than asking for information to
come in
however what I just told you was wrong
that code was wrong and the problem is
that T and you in that deco type are not
yet in scope and we certainly don't want
compilers to have to try and you know
sort of vaguely skip over the return
type and get back to it later so there's
a new syntax that moves the return type
for a function two after the you've
parsed the parameters and now that
deckle type can work the next major
feature of the C++ language is garbage
collection the reason is that memory
management can be hard and one of the
main criticisms people levy at C++ in
comparison to say Java c-sharp Python is
that I have to put in these delete
operators at the right place at the
right time and so for some applications
that's a problem for other applications
having to do that results in better
efficiency and so the C++ Committee
would like to make both possible you can
sort of do that right now with
conservative garbage collectors but not
always and to do better than
conservative garbage collectors requires
language support which is the cotton
which is the the current standards
effort conservative garbage collectors
are based on the principle that if the
bits look like they could be pointing to
a real object we will assume they will
so if you have an int whose bit pattern
happens to match that of a pointer
somewhere else then it's a pointer by
God now this almost works today there
are just a few situations which people
almost never do for which it doesn't
work and we could theoretically just
outlaw those cases and say use a
conservative garbage collector but we
didn't quite more
not quite ready to go there so for those
people that really need these kinds of
hacks there's a way to do it by saying
that garbage collection is forbidden and
likewise when you start writing programs
that don't do delete operators now you
suddenly have an application that really
needs garbage collection and so now you
say it's required if you ever have a
program that has both forbidden and
required in it that should result in an
error at link time and so in the medium
term you should write your code assuming
neither of those things so you still
want to put in the delete operator but
don't try and go off into the weeds with
this other stuff
the default is neither so the intent is
that whoever does the final link line
gets to choose so for this mostly
effects library writers who have to be
very careful to make sure that they
don't wander but if you are writing the
final application then you can pretty
much do whatever you want and it'll
it'll show up but if you're writing a
library be very be very very careful to
make assumptions but to do better than
conservative garbage collection you need
a little bit more information some
applications have a lot of random bit
patterns and the garbage collector
wandering over that will pretty much
thank everything's in use and never
collect any garbage so we have a way to
specify for any given type that you can
believe the types in this right we won't
be casting this type to void star and
and you know casting it to int or
anything like that so you can pretty
much believe the type system and the
garbage collector can then take
advantage of that information and mixing
these two things is supported
so this gives you a way once you've
decided to get into garbage collection
it gives you a way to sort of cooperate
between typesafe and conservative
garbage collection when you go to the
type safe garbage collection you
suddenly do start getting into some
limitations one of which is that your
own allocators interfere because there's
more information that needs to be
communicated from the program to the
memory allocator than the current
functions can support and so without a
mechanism to communicate that
information it's not going to work and
right now there's no sort of
finalization facility and maybe there
will be and maybe there won't so that's
it for the major features and I know
I've been sort of breezing through this
at lightning speed but there's a lot of
other features we're going into and
these features have varying status so
some your favorite feature might not
make it and it'll show up on this list
possibly and for those of you that are
color challenged you want to pay careful
attention to the bullet the shape is
different depending upon the status I
particularly want to highlight the
bottom one which is deferred to
technical report work what this means is
that it won't be in the C plus next C++
standard but it may be in a technical
report which is sort of an optional part
of the standard or people may do a bunch
of work on it and decide it's not even
going to make it that way so this is
sort of deferred work maybe maybe not
but certainly not now as opposed to the
second item there which is maybe maybe
not but we're working on it to try and
make it for the next standard
one that's important for many of the
current applications is Unicode support
the basic characters type is probably
going to make it in and the reason we
have to sort of do anything in the
standard is that the current language
leaves the basics of characters pretty
much to be platform dependent so if
you're writing a library for general use
you look at those characters and you say
I can't use these because they're
variable they're too platform dependent
so this is a way to provide some solid
ground for library writers and then
there's some follow-up work to enhance
and make that come through there are
more template features the the big one
that often bites people is putting two
right angles and having the compiler
report that this shift operator doesn't
make sense here and in fact this feature
has already been implemented in GCC and
might make it out to you within a
release or to very attic templates
explicit instantiation z' template
aliases they're sort of like type def
for templates some of the tights in the
language are excessively weak for what
people would like to do enums will fall
apart into an int on the first hint of
danger and sometimes you don't want that
at all
and then sometimes you'd like to have a
tight that has all the operations of an
int but isn't really an int because you
want to overload on it and so there's
work on that as well there's a fair
amount of work trying to generalize
classes so right now classes work
generally fairly well but there are some
weaknesses particularly with
constructors so you have to repeat a lot
of constructors where you would like to
factor out some common code
initialization in a couple areas is kind
of obscure and unclear for those of you
who are here a couple of weeks ago BR
nistro strip talked about initializer
lists and unifying the way you
initialize variables so you can have
that be more general
there's proposals right now there's sort
of you know full classes and plain old
data and there's this sort of big gap
between them and you either are or you
aren't and sometimes that requires
restrictions that aren't really there
so let's relax those controls of
defaults forwarding constructors to base
classes or to other constructors work on
all of those likewise
identify our lookup and access to
members is a bit difficult right now
been extended in a couple areas and
going there's existing work on others of
those explicit virtual overrides means
if you have a base class with a bunch of
virtual functions and you want to add in
one more virtual function into the
override mix well in a derived class
well you can't do that because adding in
one function creates a new scope and you
only have that one function unless you
go through and you write all those
functions and then call the parent one
so you end up having to create a lot of
functions where you would rather not
argument dependent lookup if you don't
know what that means well there's some
problems with it and we're trying to fix
it the next thing is c99 compatibility
the C++ standard was finalized it was
formally adopted in nineteen nineteen
ninety-eight finalized in 1997 which was
before the C standard was finalized and
this is sort of playing catch-up
several of the features of c 99 have
come
primarily long long integer types and
the c99 library and then most
importantly from those people that write
header files is preprocessor
synchronization so the C++ preprocessor
and the C preprocessor are exactly the
same and you can rely on that
there's other things that happened in
c99 that are not coming forward into the
C++ standard compound literals are not
coming forward
they have L value semantics which sort
of wrecks havoc in many places in the
C++ eaten for use in C++ variable-length
arrays have semantics that don't work
well with C++ designated initializers
they don't seem to work very well with
C++ hexadecimal floating point
no one's been pushing it so there's
there's no no big push for that we have
some new control constructs we're
working on probably closest to adoption
is some flavor for each loop which
allows you to not have to set up an
iteration variable you can just say
here's the data structure I want to walk
through it the next two bullets fall
under the general category of lambda or
closures the problem is that people mean
different things when they say those
words and the primary two use cases of
this anonymous nested functions sort of
like Pascal but allowing you to write
certain kinds of parallel code directly
and efficiently scope capturing closures
for people that want to sort of defer
computations till later these are really
two different used cases and they need
different language support the problem
is how to make those happen in a way
that doesn't interfere with the rest of
the language there is something called
technical report one after the first
standard
several years after the first standard
the library subgroup of the committee
issued technical report one which was
things we think you're a good idea go
ahead and think about putting these in
those have been formally adopted into
the next C++ standard and you can look
for them and I'm gonna highlight some of
those one is function objects so that
you can manipulate function things that
look like functions as data there's also
been several proposals for things that
affect how you talk with the rest of the
system in particular alignment of
variables and types so that you can talk
with system define things probably the
biggest example right now is some of the
sim D instructions on the Pentium SSE
they require 16 byte alignment which
isn't natural for some of the operations
there's libraries to deal with file
systems networking and shared memory
there's proposals for C++ modules that
try to do some more of the typing and
scoping more aggressively ahead of time
that work has been deferred to a
technical report there's a significantly
less ambitious proposal to support
dynamic libraries that proposal is iffy
everybody's been using a certain H
macros for quite a while the question is
can we do better than that
static assert does those kinds of things
at compile time so that you'll get a
compile time warning if you fail to meet
those a significantly more aggressive
proposal for contract programming or
more function preconditions is not going
to make the standard may make a
technical report
there are some additions to the standard
library to help you manage data in
particular a major somewhat
embarrassment from the first standard is
that the next standard will have hash
tables it will have fixed size arrays
and think of this as the C++ counterpart
to variable-length arrays
there are tuples better smart pointers
and reference wrappers there's been
significant work for like numeric
facilities there's a random number
generator library that's in the first
technical report there's also work on
interval arithmetic special math
functions some other topics for
technical reports decimal floating point
and this is where not that the literals
are written with decimal digits but that
the actual runtime representation is
decimal and this is important for
various accounting practices where the
law says that you will round with
decimal semantics and so people writing
such accounting applications really do
need to do decimal and this helps them
out the infinite precision integer
library and then there's a bunch of
miscellaneous features which I couldn't
actually categorize typed rates allows
you in a template when you're doing
template metaprogramming to say is this
type and XOR is this type of why there's
a regular expression library think of it
as very similar to some of the regular
expression libraries that are available
on UNIX there's a new way to write null
pointers instead of the C hack of using
0 and hope it gets interpreted as a
pointer in the right contexts there's a
proposal for multivalued logic and
there's something called raw string
literals which is available in some
other languages so the the problem is if
you are embedding one language in
another and they use back slashes to
quote and C++ uses back slashes to quote
you start getting into this exponential
decay of back slashes and quotes and so
forth and having written such code it
can take weeks to get the number of back
slashes right so this bypasses all that
you basically have a prefix where you
can say ignore everything until you find
this matching prefix at the end and the
best place to go for more information is
the c++ website and here's the the links
you click on and this n - 1 4 - that is
the paper number for a paper describing
the current status of evolution of the
various concepts so you go to that paper
you start looking around for what you're
interested in that will refer to you to
other papers and you can start doing
more investigation the other thing you
can do is ask questions of those of us
that are working on the c++ standard and
we will try to help you and in fact now
would be a good time to ask those
questions yes
first you mentioned a new facility for
when you're trying to infer the return
type of the function where you declared
it by function name arms and then arrow
something is that facility also
available for just returning normal
lunge for types so I can decide to
declare all my functions that way if I
write only for these types so the
question is is putting the return value
at the end supported for regular types
instead of just inferred types and the
answer to that is yes here we go that's
the example yes you can use any type
there we don't want to we don't want to
unnecessarily restrict these things so
the C++ committee is working hard to try
and make sure that the mechanisms apply
as broadly as possible so we will throw
out mechanisms in the standard process
that do not work well inside of a
template and once it works in a template
there's no reason to not have it work
outside of the template as well template
metaprogramming and you know data
structures and stuff people were writing
and relying on a lot of that and special
cases just do not work well in that
environment
you mentioned layer in the garbage
collection
that there was a way to tell them how to
be very strict about assuming that when
you say you have an n-type you really
mean you have an int and you're not
going to do things like cast void stars
around when you declare that sort of
thing we'll can the compiler also check
for you then you're not actually doing
those sorts of cats and then complaining
if you are okay the question was can the
compiler check here when you have said
that a certain classes type safe and the
end so the way this the way this works
is that the runtime garbage collector
will if you have say a struct and one of
the fields of a struct is an int it will
believe you when you say that that is an
int and it will not look at those bits
for a pointer so will only look at the
fields that have been declared to be
pointers so in that sense the compiler
really can't check at that point what's
going on the what you're asking is that
in combination with the compiler
checking to see if you're being strict
with the use of the types as the C++
language defines them and this proposal
is not trying to do that but there is
work among the various compilers to try
and detect those issues and there are
people working here at Google on that
issue so that we warn people about
misusing the type system that way and
the reason that's going on now
independent of garbage collection is
that it affects optimization so we can
do a better job optimizing programs if
people play strict with the types and so
we want people to know when they're not
doing that so independent of the garbage
collection issue you will find more and
more compilers trying to help you avoid
those kinds of type machination
the inferred function return types lino
can't we just use Otto
the question was with the automatically
inferred function return types why can't
we just use Auto the problem is that for
it as a typed specifier the Auto doesn't
work very well because the function is
the type the the return type is part of
the function so what's it going to infer
it from and the second thing is usually
you want this in an environment where
you're simply declaring the function not
defining the function so sort of autos
the wrong place to make that work out
well
no more questions alright then we'll
call it a wrap thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>