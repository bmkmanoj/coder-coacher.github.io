<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang | Coder Coacher - Coaching Coders</title><meta content="Erlang - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OpYPKBQhSZ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello uh welcome everybody to this
Tech Talk I've been a fan of Erlang for
a little over a year now since the
silicon valley my name is john brewer by
the way I'm hosting the speech for
Google and I've been a fan of Erlang for
a little over a year now since the
silicon valley patterns reading group
did a segment on it when we were going
through a lot of different programming
languages last year obviously we wanted
as a Googler one the most interesting
things to me is that Erlang seems like
it offers some opportunities for
efficient use of the new multi-core CPUs
as we're getting up to between
multi-core and hyper threading you could
easily in a few years have machines with
a hundred concurrent cpu threads and it
would be nice to be able to use more
than one of those and so our speaker
today is mr. Leonard Ullman and he's
been working with Erlang since 1992 and
one of the things he's worked on is the
OTP which is the open telephony platform
which is right basically a concurrency
library for Erlang that provides some
some higher-level constructs and he's
currently managing director of the
consultancy company Roland and Ty
Caelius sicilius Telecom maybe in Sweden
and happened to be in this neck of the
woods scuba-diving and was kind enough
to come out today and do a Tech Talk on
Erlang so let's give him a big hand
I'm happy to see so many of you here
today I thought actually was going to be
China the little audience of 10 people
or something like that and they were
just going to videotape this and just
for the record if someone wanted to see
it so I'm really happy to see so many
people yes thank you very much for the
introduction as you said I've been
working with Erlang since 1992 and yes
that's a very long time I didn't think I
should I would be still making a living
out of this by now so sometimes when I
give classes I say that if there's
something you don't like in Erlang
especially in OTP there's a saying you
should not kill the messenger but in
this case it could be it could be
correct I'm both messenger and
responsible for some of some of this
mess okay when I was going to put
together a little short a few have
paragraph about what this talk was going
to be about I thought how long has
Erlang existed and then it struck me
that we're actually celebrating 20th our
20th year this year and it seemed to be
a gun just secretly away
I guess that because some of the most of
the people who founded our line started
it is no longer with Ericsson and they
are working for a lot of other companies
but I I really have to take this back to
to Sweden and and the remind remind the
Erlang community that we are actually
having a celebration this year it all
started in the middle of the 80s
something called the computer science
laboratory in Stockholm Sweden I'm going
to come back to the to some more
interesting dates later in
presentation about Erlang first I'm
going to go through the main design goes
why did Ericsson decide to make yet
another language like we didn't have
enough of them first when I when I came
in contact with Erlang in 92 doing my
master thesis I kind of thought
something like that well cool another
language seems cool for master thesis
and doing something around that but does
the world really need another language
but working more and more and getting
into the telecom sector I realized that
Erlang was actually pretty neat and
pretty well designed for many of the
problems and that there were no real
good solution somewhere else just to
pick up after I've gone through the
design girls I'm gonna go into a few
programming examples that's why I was
playing around with Emacs here and try
to demonstrate the major advantages with
aural onion so you can see how how it
works and then finally I'm gonna talk a
little bit about the history so you can
get a grip on the development and what's
happening over these two decades and
finally something about the future where
I think Erlang is is heading I don't
know how this Tech Talks work I like to
have questions when I'm talking I don't
know if that's possible to to to manage
but that's at least fine with me the
worst thing which can happen is that I'm
simply going to ignore you
that's because I'm feeling that oh if I
stop now I'm gonna lose the thread and
then just try to ask the question again
later
so goals for Erlang what was it the
Computer Science Laboratory discovered
in in the middle of the 80s they
actually set out to program PBX an
office switch in I think over 20
different programming languages and/or
development environment to see the
strengths and the weaknesses for their
problems and after doing that for a year
or two or something like that that's
when they came to the of course very
interesting and very exciting decision
that we're going to make ourself a
programming language not that we need to
invent something new perhaps of course a
little bit new but we've seen a lot of
good things to have in various
environments and programming languages
but we want them in one single
programming language targets or or goals
they set up or problems I could say they
saw when they programmed this office
which was full tolerance in the telecom
sector down times of fractions of
seconds per year is nearly acceptable
you have no time when you can take the
system offline and play and plan
maintenance this goes hand-in-hand with
with a non-stop property of course a
system goes down if you if it breaks if
you have an error and what shall we do
right error free software well sometimes
you're actually during my career
I hope I hope this person will not see
this talk I've said listen to
presentations where quality managers
have have said now it's very important
that we write completely error-free
software and the kind of we from the
Erlang Department raised our hands and
said mr. manager that's impossible and
like what did you say impossible but
you're very skilled Ericsson engineers
you shall be able to write error-free
software
well we all know that if you write a
large enough system you will have errors
for one or the other reason either
because you make mistakes yourself or
because you didn't understand the
problem domain or it perhaps it wasn't
properly described so the only way is
try to make something which is a little
bit more understanding and where a small
error will not bring the entire system
down but non-stop is not only about
errors it's also about maintenance
software needs from time to time to be
upgraded at least not because we
actually discover errors we discovered
them before they cause any any major
destruction and well we all know what
what happens when we have when we've
clicked that the windows take this
upgrade option and then after a couple
of minutes the Box now you have to
restart your computer comes up not
really acceptable other areas of the
problem they investigated was actually
concurrency a telecoms which is heavily
concurrent I think that at that time in
the middle of the 80s concurrency was
more of a unknown or no
that important property than it is today
today anyone many people writing
software today writes software's for
internet shopping systems online banking
and stuff like that and then you can
very easily picture yes I will have
thousands perhaps hundred thousands of
users simultaneously doing tasks which
are more or less unrelated and you see a
concurrent world in front of you but at
that time I think that computer systems
was more about processing to be a little
bit mean pom you know the punch cards
and things you have you have an in date
you have a single in data stream you'd
process it and you do something with the
output or you have a user doing
something with the computer system so
concurrency was was was pretty new or at
least not really necessary therefore it
came up as yes we really need
concurrency in our programming language
if we are going to be able to describe
typical telecom problems and then of
course not internet users but instead
people making phone calls and of course
one phone call to another is unrelated
to the other neighbor making a phone
call to to his grandma or something like
that
distribution scalability and
heterogeneous networks once again we go
back to a time when it was not uncommon
that if you bought a computer system
from a vendor you were kind of stuck you
have to continue buying their hardware
to eat to have a chance to get the
equipment to talk to each other the
computer science laboratory said that
well now we don't think that's the
future we think the future will be
networks of old computers new computers
computers with this operating system and
compute
with new operating systems and things
like that so we need to target a heater
genius Network environment and at the
same time we will of course get a
distributed environment which will be
scalable so we can start off with one
single CPU and end up with multiple CPUs
once again we think back to what the
telecom world looked like and still
looks like you have small customers and
you have big customers and there is
usually a significant difference between
a small customer and a big customer when
it comes to an amount of equipment they
need and of course you don't want to
have to sell them completely new
equipment when they grow and become a
big customer soft real-time properties
yes the telecom world is soft real-time
it's real time in the sense that you
want your calls to go through you want
your online bookings your online clicks
or whatever it is to go through when you
are when you are doing them but it's not
a complete disaster
if you from time to time actually get
some delays or actually fails it's not
hard real time like if you're
controlling an aircraft or a spacecraft
or or something like that when when
people will die and a lot of money will
be lost if the computer isn't doing some
action precisely at the precise moment
lost but not least prototype ability I
think I've invented my own English word
here at least a spell checker started to
complain about it
the Computer Science Laboratory so a
great advantage in having either a
programming language or a tool or a
development environment name it whatever
you like where it's possible to start
off very quickly with your idea I want
to do this let's try it and see what
works and what doesn't work instead of
us having to to make in a complete
architect architecture and decide a lot
of stuff before we can write one single
line of code and more importantly before
we can test our code and see if our
ideas really works so this was more or
less the major point they ended up with
after trying a lot of programming
languages this is what we want and we
can't find this in one single language
or development environment yes please
in these properties yes the question is
aren't these goals for a system rather
than for programming language itself I
think I'm gonna I'm gonna dodge the
question by saying that you need you
need mechanisms and primitives provided
to the general programmer or to the
developers in order for a system to have
these properties
otherwise they tends to get lost in the
way I don't know if that's an answer to
your question please feel free to ask
again if you if you see another slide
where you think I could elaborate more
on more on that so if we begin to to
these goals how was this met in Ireland
well for tolerance mainly fault
tolerance is about isolating the
problems that the areas where we
experience an error to make sure that it
doesn't spread and have infect other
areas and mainly I would say this is
done in Erlang that the language has
lightweight lightweight process concept
built into itself when I give online
classes I kind of say things like this I
don't want to see any Swiss Army knives
you know big blade little blade the
little scissors the corkscrew and stuff
like that instead you should make many
processes one for the corkscrew one for
the nail clipper and so on so if you
have a nail clipper malfunction if
you've done it properly only the the
people using the nail clipper at this
time
experience some kind of disrupted
service and then it's very important
that these processes are isolated from
each other and that's mainly how it's
done in Erlang it's also very cheap to
spawn a new process so there is really
no reason to to save on the process if
you want to have a hundred thousand
processes in Erlanger have a hundred
thousand processes if a process then
terminates of course someone needs to do
something about this so there are
mechanisms in Erlang for processed
supervision and now we're actually
touching a little bit on the topic of
LTP Erlang has a lot of nice mechanisms
but the OTP is a framework on how to use
them in a consistent way so that you do
it in the same way in an entire
application and even better do it in the
same way in different applications so
that you may be able to to borrow things
back and forth
non-stop mechanism then well fault
tolerance obviously is an important part
in non-stop we don't want to have
service disruptions but also hot code
replacement is very important to do
these upgrades so Erlang has built into
itself
the possibility to have two versions of
the same code at once so you can make
kind of a transition at a time when it's
good or it's it's good to you or to the
application
distribution and scalability then well
when it comes to the distribution
mechanism it is transparent when it
comes to how processes works the main
mechanism since I kind of gave the clue
that it's very important that processes
are independent of each other that they
are very isolated for an error not to
spread to another process then of course
how do we write programs well we have a
process passing inter process message
passing mechanism and by making this
inter process passing mechanism
completely transparent to the
distribution we have a scalable system
so if you can find some way to break
your your world of processes apart and
have instead of having a hundred
thousand here we have a fifty thousand
over there and 50 thousand here on the
number CPU you do not have to change
your code in order to achieve
distribution which is independent of
what kind of platform you're using
Erlang uses a virtual machine then so
you compile your source code to a binary
code which is in the Erlang world called
beam files and then finally on this
slide which is actually new SMP support
so if you have a multi-core processor
you can make your Erlang virtual machine
run several threads and these threads
will pick Erlang processes runnable
Erlang processes from around cue and
start a random there are of course some
situations where locking becomes too
difficult internal locking
innocence becomes too difficult so that
the virtual machine goes down to one
thread but that's very very rare
occasions code loading is for instance
such an occasion but that's something
you only do at startup or when you need
to do a hot code replacement more about
the scheduling or the processes the
concurrency the process module the
computer science laboratory found was
the best one was actually a very simple
one instead of having priorities and and
functions and mechanisms like that they
found out that simple round-robin
pre-emptive scheduling is what creates
the least amount of problems in the
applications so more or less it's in a
way that our instructions in the Erlang
program are they have a price tag and a
process pace for executing Erlang
instructions and when it's out of pocket
money when it's out of its allowances
the scheduler takes the process out and
of course takes the next one in the
runnable queue another interesting thing
is actually that all processes are
equals a lot of what's seen to the user
as part of our line is actually Erlang
processes themselves and they are equals
to other processes that you create
yourself to run your application
soft real-time well since we have a
virtual machine which which takes care
of memory management for us hard
real-time properties will be very very
difficult to achieve but a lot of work
was put in already from the beginning
and is constantly put into fine-tuning
memory management and garbage collection
mechanisms in in the Erlang virtual
machine so for the kind of soft
real-time applications which airline was
originally targeted foreign and others
alike communications applications the
soft real-time properties are by far
good enough
the prototype ability then well the
wizard has an idea and wants to wants to
try it out
actually from when one of the things
I've been working with is selling Erlang
that was before it was open-source
before the big open source trend some
people call it spreading the gospel and
one of the things we talked about we
lean very heavily on was actually what I
now call prototype ability we at that
time called it time to market which
seemed like the buzzword of of that era
we talked a lot about Erlang being a
decorative programming language from the
functional parting rather than
imperative programming and we stressed
very much that this is something which
makes you more productive and of course
better time to market maybe as years has
passed by we we in the Erlang community
actually inspired by a talk at MIT that
Joe Armstrong one of the original
inventors of the programming language
gave he if he talked about concurrent
oriented programming and got a lot of
positive response a lot of people said
ah okay now I understand why you're
using Erlang and I and a lot of other of
the people's we were working with with
selling or talking about Erlang we also
actually got so uh so that yes we should
have talked about concurrency oriented
programming concurrent oriented
programming rather than leaving leaning
so heavily on the functional paradigm of
the
language itself even though still argue
heavily that the decorative nature of
the programming language is an important
part of that you can actually very
quickly sit down and get something done
and test it but from a strict computer
scientifical point of view I would
actually say that it's run time linking
it's that you have the possibility to
change one part of your system very
quickly just recompile it and enter it
into your runtime system and try it
again
without having to go through sometimes
very tedious real inking process of of
your entire set of modules code blocks
or whatever it's called in your
development environment and of course
the runtime linking comes back then to
the hot code replacement features
so that was about the motivation and the
goals for designing early let's make a
short crash course here so that you will
understand some programs I'm going to to
show our line programs are built up by
functions and not very surprisingly very
common in many programming languages a
function can be one or several clauses
and this is a function calculating the
factorial value of something and it
basically works in a way that if I'm
going to calculate factorial of two the
runtime system first tries the first
Clause which requires the argument two
factorial to be exactly the integer zero
so it doesn't match so we do not go into
this Clause fortunately we have another
Clause and here the argument is an
unbound variable variables in Erlang are
denoted by you recognize them by the
capital letter they begin with a capital
letter so - if I'm calculating factorial
of 2 and gets bound to gets bound to end
and gets bound the two is probably the
proper way to put it and the result of
factorial of 2 is 2 times factorial of 1
then and then of course you recursively
call the factorial function and
eventually you will in this cold chain
end up in the first Clause instead
because you are calling factorial with
the argument 0 which will return 1
these functions are collected into of
course Erlang source files such a source
file is called a module and a module is
compiled before you can use it and then
you get a beam file and these beam files
are executed by processes in your
virtual machine so there is really no
connection between Erlang modules and
processes they are when I when I give
classes I usually explain it like Erlang
modules are instructions work
instructions and processes are people of
course many people can work out of the
same instruction at the same time I
mentioned that processes communicate by
sending messages the messaging mechanism
is an asynchronous messages mechanic
messaging mechanism so you as a process
you are allowed to send a message to any
other process at any time you feel like
the process you are sending to can
actually not protect itself it will get
the message it's up to the receiving
Ness the receiving process what it wants
to do with the message if it looks at it
at all
and now I am going to demonstrate some
distribution but since the resolution on
this monitor or this projector doesn't
seem to be very good I think I prefer to
just pull the code up in in Emacs so
here we see a proper airline program
they start with the attribute - module
where I say that this is the module test
one I have to export some functions
that's basically api's functions that
should be possible to be called from
outside of this module I have a start
function taking an argument and the
start function calls a built-in function
called spawn this will cause a new
process to be created it will be created
at node node that is what I give us an
argument to start and it will that new
process will start running the loop
function found in the test one module
and the loop function takes zero
arguments that's why I why I have two to
hard brackets here with nothing in so
what will this new process do well it
will make a risk it will sit in a
receive and if a message comes in that
message will be picked up this is an ant
what's called an unbound variable so any
message will match this variable it will
be bound to this variable and I will go
in here and I will make a print out on
the shell oral and colon display I will
print out actually my own process
identifier
and just put it there so we can see
who's talking and what message this
process got and when it's done that it
will simply make a tail recursive call
back to the loop function this is a very
standard pattern of making a server
serving requests now of course the
messages this server will be expecting
are probably a little bit more
complicated than anything and and and
the services the server will provide are
probably more complicated than just
printing it on the screen and there are
probably several different messages
which are recognized but a principle is
the same you pick up a message you serve
the request you may contain recursive
call back to the function where you sit
waiting to pick up messages all right
yes anode is I'm going to demonstrate it
here but I'll be happy to say it right
now
anode is a virtual machine so you can
have you can have one or several virtual
machines running on the same physical
CPU or you can spread them out over
different CPUs I guess the later is the
most common solution of course so now I
am just going to call test I'm gonna
pick the process identifier out test 1 :
start and this is actually an on
distributed node this this airline this
is an airline shell connected to a
virtual machine just to demonstrate that
this the scalability property choosen to
have an on the distributed node yes yes
it's a built-in function I can I can run
it here for you since this is not
distributed
it's actually really silly if you would
ask me if I would have done this design
decision I I would have chosen a value
which would have been outside of the
domain the value domain of valid node
names so you can obviously not have a
computer named the no host and start an
airline machine name and name it no node
because it would be very difficult to
communicate with it okay
so I just simply start this here and
what's printed out there is the process
identifier and the reason why it's
printed out is actually because it's the
return value from the start function
the last thing done in a function is the
return value and since I call the start
function in this shell the shell prints
out the return value so now I have a
process identifier I can send something
to hello and then we see this is a tuple
and the cut as I mentioned earlier in
the code I was going to get the process
identifier of who was talking and the
message is got and this hello here is
actually printed by the shell because
the return value of this message sending
is the message itself so therefore I
cannot make that go away and of course
if I send something more it will be
printed out very good now let's start
some distributed Erlang let's start a
node here this was actually surprised I
got the same font as I've already set
the others up with but can I just get a
little corner there and stuff
and this was bar and then let's see if
we have food
first of all I must there's a little
security mechanism I must set the same
cookie at both nodes for them to be
allowed to talk to each other
Kaka that's cookie in Swedish and net
the McCullum ping I can see if I have if
I can reach through j21
or Palmilla very good ok I must also
actually move collate down
you remember you can always do it like
this yes you are right document pro Jack
Lang presentations and Google 2007 and
see if we can
if it wants to play
all right really doesn't matter which
one we we choose so now we want to do a
test one start and I want to start this
on the other node food at j21 R and I
should have picked up the process
identifier but we can start another one
and then I send something over hello and
we get it printed out and I'm running
the same code so what I'm trying to
convince you is that there is no big
work involved in when you are scaling
your software up you want me to kill the
process I don't I don't need as I said
the earlier process are cheap so we can
have them laying around there's there is
really no problem they don't take up
much space
all right let's get back to this
slideshow I think since I'm not gonna
I'm gonna demonstrate hot code change as
well and I'm gonna do that in in the
Emacs so don't bother with that you
don't see what's written there we take
up the Emacs and we check out the file
test2 and here I modified this program a
little bit
I entered one more Clause in this
received statement and this is perhaps
it's difficult to see but this is not
this is a lowercase s so this is
receiving actually precisely what's
called an atom switch and what I make
here is that I make a tail recursive
call to the loop function but you see
that I have specified the module as well
what this actually means is that if I
make a call to a module and specific if
I make it call the function in a module
and specify them the module name I tell
our line that I want to use the latest
version of this module and now you
probably start thinking okay so that's
how code change can be done
I can here continue to use this version
even if it's the latest or if it's an
old version whereas I here force the
process to use the latest version
so if we bring our we bring this up
again and we
this time we p1 we start
and I said thoughts I send hello again
okay hello comes out now we want to make
a modification to this code so let's say
that we we want to put in that if we
actually get the message hello
we get high back instead
and then of course we make a call to to
loop
now we're going to do something
interesting now I'm gonna compile it in
yet a third emulator so now I have the
code compiled but not loaded so we still
get we still get hello here if I now
load test
- now unloaded the new version let's see
what happens if I now send hello
still got hello how come well I haven't
made the process change the code yet so
I need to send this switch message
and then send the hello then I got the
hi
fantastic question in the back if I
forgot yes
the question is what if I what if I
didn't have this clause the switch
Clause from the beginning could I have
pulled this stunt off then no because if
I would only have had what's called
local calls to loop I would have had to
start a completely new process with the
new code maybe that's doable also maybe
you can find some way to migrate data
which this process is holding currently
holding but now we're yet again touching
a little bit about OTP that if you're
using OTP digital in the framework
someone has thought of this already for
you so that you won't miss it
yes
no not necessarily
oh sorry the question was does all the
virtual machine have to have to share a
common filesystem no you can actually
push the code out over the distributed
network so if one of those no didn't
have the test to module I could have
first loaded it from a node which has it
and then of course start running it
there all right I'm running a little bit
behind
as usual I guess so I want to just
quickly finish off with the with where
we're going right now
and we're happy to take questions
offline as well if we're out of time
from current slide yes the OTP framework
I'm not going to talk about this here
but it has generic modules where
typically this received statement
resides making sure that you will not
miss programming the switch message and
things like that and this generic module
simply makes calls to a callback module
where you have implemented the specifics
of the of this process a little brief
about the history as I already said
Erlang the first experiments with Erlang
started in 1987 the first project with
Orleans started in the beginning of the
90s a direction
and other milestones late 89 Orlando TP
was released as open source in 2003 the
Erlang workshop became an official part
of ACM sigplan for functional
programming languages it alternates
between the North America and in Europe
this year it will be in Germany last
year it was in Portland Oregon we
actually had our tenth airline user
conference in and that one is annually
held in Stockholm 2004 and another
important milestone I think is actually
the SMP support which was rolled out
last year a bit of caution it is
actually not released for Windows yet it
will come soon I don't know they the
exact release plan by heart some major
usage Ericsson Ericsson and Ericsson yes
Ericsson developed an ATM switch in in
Erlang Erickson's sgsn GPRS note the is
developed in the control logic is
developed in Erlang Ericsson is right
now developing some new products one one
session border gateway based on Erlang
the Tahlia which is the former Swedish
PTT which were actually jointly owning
this company LM tell together with
erection where Erlang was born are using
Erlang in a call center solution and
there are some other net companies
using airline there are a lot more than
them these slides these are the the
usual suspects we are allowed to talk
about there is a gentleman sitting in
the audience which is programming our
line for for another company as well so
this the usage it's it's definitely
picking up as we can see it we see it
also when we get to the statistics for
the Orlando Orange page that we are now
growing up to like you are probably
laughing but I don't how many hits do
you does Google have each second these
are these are hits than per month 151
one and a half million hits or request
more precisely not hits requests but I
at least like the trend
currently the development is still
taking place at Ericsson in in Stockholm
it's headed by its manager Kenneth
Lundeen and the story is that if someone
wants to contribute something you
contribute it to the OTP team a
direction which which decides on the
usefulness and and the quality of the
contribution and whether to to include
it so there is really there is no
difference between the open-source
Erlang and the Erlang that's used inside
Ericsson for instance
for more information I recommend Orlando
org war a brand new or lang book which
is written by yet again Joe Armstrong
one of the initial inventors of the
Erlang programming language it is the
rumors are that it's actually available
in hard copy right sometime this week
previously it's only been available as a
as a PDF well I only missed the deadline
by two minutes thank you very much for
listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>