<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Topics in Programming Languages Series: Python... | Coder Coacher - Coaching Coders</title><meta content="Advanced Topics in Programming Languages Series: Python... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Topics in Programming Languages Series: Python...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1Sbzmz1Nxvo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'd like to introduce author and Googler
Alex Martelli and he will be top telling
us all about Python design patterns
thank you very much thank you everybody
actually I'll be telling you about half
of 2 or 1/3 of it depending because this
is just the first part of a talk that
will need to be split into two or three
parts depending on some issues so let's
say that every for every argument we can
roughly classify on much we already
understand about it how much study and
practice we have to let all hardly heard
about it haven't even heard about it or
just barely of level zero of journeymen
sorry apprentice apprentice is like I've
started don't really know much yet but
I'm stating started drawing man or
master so how many of you would say
about Python I hardly heard about it
okay how many consider yourselves
apprentices how many journeyman mm-hmm
how many masters of Python okay now same
question about design patterns I've
hardly heard about them apprentice just
getting started okay
Johnny man must feel pretty well master
could teach about those things okay so
we have just about the right level of
audience I think we can split it in two
by compressing about three hours of
materials into two hours worth of
presentation this is roughly how this is
structured they show Hari traditional
levels more or less correspond to
apprentice journeyman master although
there are other implications there I aim
for pretty low to medium level for
design patterns not really giving any
absolutely revolutionary insight there
and somewhat higher than that about
Python
I don't really teach any of the basics
my may give some insight but roughly
this is the number of slides I have on
each subjects were full item really
counts about 90 so we'll try to cover
about half of it that is basically all
the way to structural patterns this time
and in the second part focus on
behavioral patterns QA besides the end
of the talk are welcome anytime but of
course I may be just about to answer
whatever question you're thinking of in
the next slide or so so please try to
wait a second before asking just to see
if I I'm already going to answer itself
patterns what's patterns you know it
unless you're hardly ever about it that
the very concept was born about 30 years
ago in the works of architect and
philosopher Christopher Alexander
basically thinking about buildings in
towns places where people live and work
they're made of entities he decided to
call patterns and by looking at things
in terms of languages of patterns
interacting with each other the
different details can be subsumed in a
grander view he also has this much more
for from third book a pattern language
very verbose but very important quote
every pattern describes a problem which
occurs often and the core of the
solution to the problem in such a style
that if we really understand in applied
we can apply the same solution without
ever doing things the same way twice
that is the essence of patterns in the
most general sense possible crucial
issue which Alexander stresses only a
thousand times in his books and his
followers may be silent
another sign hundred in the software box
is that design is not independent of
technology patterns are not a design
concept in the sense of being implement
independent from the technology to be
chosen in implementation if you're going
to build in bricks or wood or
concrete some things remain the same but
many important things changes you don't
exactly use the same patterns similarly
to quote Gamma tau from the foundational
book of design patterns as a software
discipline point of view effects on
interpretation of what counts as a
pattern in charge of programming
language is important because it changes
the point of view that's why I titled
this talk design pattern for Python
because I'm specifically addressing this
point of view in my talk more generally
design patterns are thrived particularly
in within object-oriented development
for no particular reason I mean they
could apply just as well to assembly
level programming or or functional
programming that I guess object-oriented
is the mainstream nowadays mostly thanks
to that wonderful book which I was
holding a second ago into that
incredible sequence of conferences and
proceedings and online debate and
constructive criticism that is a pattern
language of programming series slash
community they were so hyped and there's
such a nice name that three or four
years ago I was starting to get really
worried that they'd be swept away as a
fad or fashion as so many other good and
not so good ideas in software have been
because people are always looking for a
silver bullet well not as we know there
isn't one but a lot of other people and
fortunately the concept doesn't matured
and I think we're past the danger of
being swept away by hype and I keep
repeating they're not independent from
programming languages so what are they
traditional design patterns applied to
software they're not something like data
structures or algorithms on the simple
and so I the linkedlist or a quicksort
is not a design pattern
they're not even domain-specific
architecture for entire subsystems
something that's too big and abstract so
for example
HTTP sessions built on top of cookies
that's not a design pattern that's too
specific off the field of building
session building sessions on top of a
non session oriented protocol so
somewhere in the middle between the
low-level things and in the
domain-specific more complicated things
that's where we have the patterns to
quote the Gang of Four again
descriptions of communicating objects in
classes that's because we are in they or
domain we would say communicating
functions and I are hoarders functions
if we were talking about functional
programming customized to solve that
general design problem in a particular
context sometimes we're talking mostly
about classes but far more often we're
talking about how the objects relate and
the purpose of the pattern is a very
generic description or category
what is this pattern all about and
you're supposed to do a very formal
right half of a design pattern I'm
focusing on two really important aspect
the name of the pattern is absolutely
crucial because if you don't name things
they don't stay well in your memory and
the known users which I will be coding
at every step and also referred to as K
use our absolutely crucial if you cannot
quote at least three examples from
disparate pieces of software it's not a
design pattern that's absolutely crucial
in both Alexandra's conception of the
gangs of four you don't invent a design
pattern you discover it in nature so to
speak you discover it in the state of
the art of practitioners in the field
and then there's all sort of formalized
terminology such as forces which forces
meaning constraints and desires the
Spartan souls and so on but they
complete schema is hardly ever
appropriate it depends on what audience
if you want to go present at PLO P then
by all means do a complete
right up but if you're talking about the
typical in front of the whiteboard
design discussion with colleagues then
something more simple a little bit more
of course than just the name and no
users but say the results are rationale
or context in problem are reasonably
important but you do need to use the
whole complex approach so there's a
plenty of books which I would recommend
depending on exactly what you're going
to most importantly I would not repeat
not recommend the original book to
anybody except people at re level if you
already know all there is to know about
design patterns that is the time to read
this book is definitely not introductory
I would not recommend a pattern hatching
to anybody except those who have already
read throughout design patterns
critiqued it and have particularly and
are able to argue convincingly as to why
this is right but that was wrong because
this is basically what Reseda does here
I would not recommend this one to
anybody who's already married because it
could put your marriage in danger in
danger but it although otherwise it's
quite a cool book very funniest as you
can expect seriously the best
introductory introductory books are
essentially those two of shallow am trot
for very formal classroom like and head
first for if you like thinking visually
and and with a bit of disorder very
creatively this is extremely this is Bob
Martine extremely recommended because he
the only really good book that merges
design patterns is in what comes out of
your design with methodologies what goes
into your design how how do you proceed
with that and a few others of this is of
course strictly if you are in a C++ shop
where you are actually allowed to use
all of C++ otherwise you'll feel very
frustrated
okay so as Albert Brown and wolf in one
of the books I recommend have already
pointed out extremely clearly I'm just
summarizing their arguments many classic
design patterns are work around for the
existence of static typing so they wrote
this voltage motor companion about half
of the Gang of Four were very strong
Smalltalk programmers but they basically
took their small talk
hats off when they wrote the book and
accepted static typing as a way of life
it's need not be so it's not in small
token of in Python is not in many other
languages so basically forget all the
static typing constraints if you're
going to program small talk or Python
and vice versa there are specific
strengths of the languages you're using
with such as dynamic abilities
introspection and so on which you may
really want to capitalize on and I keep
focusing on names as important which is
why I keep using the classic names even
when things appear very different in
Python some patterns simply disappear
because they get incorporated into
standard libraries and in languages
typical example is iterator modern
languages have iterator built-in or in
the standard library so the I traitor
pattern which covers quite an important
role in the original book absolutely has
no reason to exist as a pattern any more
than you would consider it a pattern
subroutine call if you are programming
button airy machine code knowing there
is a pattern called the subroutine call
whereby you push the return address
somewhere before you jump to somewhere
else would be crucial but your language
offers calling to subroutine as a
built-in feature of the language it's
not a pattern anymore same goes for
iterator so the categories of purpose of
dps in the traditional
framing which I'm strictly following
would be creational structural
behavioral the creational ones are the
ones concerned with instantiation of
objects the structural one deal with
mutual composition of classes and
objects you can imagine something that
exists in a certain way and the
behavioral one deal with the interaction
of course those
you creational patterns a bit more
structural one in an enormous sea of
behavioral ones because the number of
different important interactions is much
higher than the number of possible
structural relationship which in turn
swamps the number of creational things
so I hope to cover today some of the
patterns in these first two and leave a
behavioural stuff for the second part
something that holds no matter where no
matter what language no matter what else
as long as you're doing object-oriented
design patterns at least two absolutely
crucial ideas which pervade the book
pervade the design pattern thinking
program to an interface not an
implementation this is also a great idea
to do if you're doing machine code not
just in all 300 programming how careful
you have to do you have to be to do that
depends on your language as well in
Python it's generally automatic unless
you take real trouble to do things wrong
you are doing things right you're
implicitly using duck typing which is
the extreme form of programming to an
interface in other languages you have to
be more bit more careful about it not
all that much and favor object
composition of a class inheritance so an
object-oriented programming was first
introduced in heritance was basically
seen as essentially synonym with
object-oriented programming you had to
do everything by inheritance it took
decades I would say to basically find
out all the ways in which this is not a
good idea and wean ourselves
collectively speaking from our use of
inheritance in favor of more flexible
mechanisms for composition I still
remember the first time I I read a book
on C++ style which taught me it's wrong
to inherit car from engine why it's so
handy yes well a car is not an engine a
car has an engine and so on and so forth
that was over 20 years ago but it's
taken the industry collective
almost as much but most of us still
probably tend to inherit too much unless
we sit and think about it the culinary
test is so handy and the cost are not
obvious until you have progressed a bit
with your design so inherit only when
it's convenient I know that's kind of
more of a pragmatic I know they party
line is supposed to be inherit only when
you can assert a risk of invariants and
is a well I think you can ever assert is
a I think as Korzybski put it they is of
identity is the most widespread error in
thinking and perceiving the world so you
can never assert is if you want to be
really fanatic about it at least not if
you're into concepts key Wittgenstein
and others of my favorite thinkers on
the other hand checking that it's really
convenient yes you want to expose all
methods that are in the base you want to
do a lot of reuse a little override and
maybe extend a little bit and you are
perfectly fine with being so tightly
coupled with the class you're inheriting
from that you will never intend all the
coupling then if all of this holds then
it's right otherwise go for hold or wrap
hold and wrap in the case of Python our
subtle distinction I insist on doing it
like this kids are holding the Python as
you can see which is much safer than
having the Python wrapped around you but
that depends on how big is the Python
this one is particularly large so by
whole I mean an object as a certain sub
object is an attribute and everybody
including the object itself an external
client know that and call owed of a stop
some method it's simple its direct is
immediate the problem is the coupling is
very strong it's all wrong you're
exposing the detail
that always implemented by by having an
S and what methods s needs to have to
all and sundry the wrapping is a hold by
private name or most often by private
name and the delegation so everybody
else calls Oh doc method as opposed to
all the test of method you can do that
explicitly like in every language by
defining method to call surface method
or you can do it automatically will get
after we'll see a few examples later
because it's such a common Python idiom
the point is you get the coupling right
read up on the load the meter is not
particularly Python specific but it's a
very simple super simplified guideline
to good object-oriented design never
have more than one dot if you're saying
Oh s dot method you have two dots and
you know something is wrong now that's
it is over simplified but it's a handy
rule of thumb so this is an example of
wrapping with being much more
appropriate and inheritance because
inheritance cannot restrict the if you
inherit you first of all among other
things commit to exposing every single
method in public attribute of your base
class so what if you want to do all but
a few well you can do that by wrapping
to restrict so this is an initialization
which takes something to wrap and a set
of things of names to block and records
it and then whenever you try to get any
attribute on the subject to with a
certain name if the name is among the
blocked ones then an attribute error is
raised you claim it's not there
otherwise you delegate to the wrapped
object incidentally if the wrapped
object itself doesn't have this
attribute either they will raise they
will raise the attribute error we just
propagate it that's perfectly fine so
this isn't exactly a pattern but it's a
typical example of the dramatic use of
the data in Python creational patterns
they don't really play all that much of
our own in Python although yes
I have decorator later and I wouldn't
really claim it is because it's removing
something as opposed to adding something
decorator normally have something this
removes something so yeah I guess it's
very very close to decorator but I deal
with it here because of the removal
aspects so it's important to have
thought a little bit about creational
patterns even though they don't really
play that much of a role in Python
I've always wondered why don't they why
are they so crucial in other languages
well I would guess it is mostly because
as we'll see the factory concept is
essentially built in Python you don't
have to do something different
to call a generic factory function
versus instantiating a specific class so
it comes very handy but being aware of
it is not a bad idea anyway so I'm
dealing with two sub categories of
creational patterns one is we want just
one instance to exist the note I this in
this case I start by stating the problem
rather than any solution because or
problem or context or forces were
solving we only want one instance of
something to exist normally in
object-oriented programming you make a
class and then instantiate it as many
times as needed sometimes you think
right wrong that you only want if you
instantiate it once rarely exactly three
times or something like that so let's
stick with once the solution for about
99% of the cases in Python is don't use
a class use a module the main thing
about class is being able to instantiate
in them repeatedly just use a module in
that module will have intrinsically just
one instance if you if that module gets
imported from several places as you know
Python internally make sure only one
instance of the module is used
there are some problems with that
modules don't support sub classing so
you can't really do any tweak modules
don't support special methods so you
can't use for example arithmetic
operators you can do pluses x / which
are sometimes nice to have second
approach is just make one is you only
want one instance well make one instance
and use it that's it what you need to
enforce the existence of just one
instance it this works for another 99%
of the case is not covered by the first
99% the only real issue with it is that
you have to commit to the time when that
instance is made because all the rest of
your software needs to be able to know
there is an instance around and know
what name to access it from or which
means to assess it from and then there's
a classic singleton pattern which I call
Highlander for reasons I hope are
obvious
the problem with singleton is that
despite the claims in in the Gang of
Four book it really doesn't work with
sub classing very well at all we'll will
discuss that essentially well what we'll
see it when when you come to the Python
code bitter poison in language and then
there's mono state mono state is the
name originally given to it in bei I
think it was in the C++ user journal but
I call it Borg and the one problem with
it is that we do have set for reasons is
never really explained to me
okay I'm sorry I didn't connect so that
there can be only one is of course the
Highlander referencing in this thing
which is much better than single stone
the twenty bridge player means the suit
in which I only have one card it is very
handy for doing rafts but it's not
nothing to do with object-oriented
programming so Python has this special
method new which is essentially they
play so where theoretically new
instances of the class get constructed
and this thing guarantees it only
constructs a new instance once and then
keeps returning it why do I claim that
sub classing is a problem well suppose
there's class foo that inherits from
singleton and Bartha Daenerys from foo
now I instantiate foo and then
instantiate bar what now do I still have
one instance of singleton which classes
it or do I suddenly have to depends on
in this case I made it per class but
this means there's more than one
instance of singleton there is more than
one completely disjoint object on which
a test of is instance will say yes it is
an instance alternatively you can forbid
that you have you can have this fail but
then you are not supporting sub classing
there is really no way to support sub
classing well in singleton that's they
one of the big reason singleton is
totally bankrupt and although it's most
popular design pattern you can do some
quick Google Trends to find out the
names of our design pattern in ever
works in any language because there is a
concept means you can always supply
something it doesn't know well at least
it was no way to say this class is not
so classical further but then instances
of the subclass are instances of the
model class and that kind of breaks
everything
once again they the quote so Borg is
basically forget about instances who
care about instances as long as they all
share the same state they may as well be
one and you're very happy there is
absolutely no case in which this gives
any problem so in the in mono state to
you do that is in C++ the original
version you do that by forcing every
method to be static every data member to
be static that unfortunately doesn't
really support inheritance either so
that Robert Martin has a very nice
critique of mono state in singleton in
an essay on his site object mentor but
in in Python you have reasonable control
over the object state so basically you
can set the dictionary were the object
alts all of its states to the shared
state of a class and so you can make as
many objects as you want they will all
be the same
except in terms of identity in terms of
everything they will share the same
state any modification and XS will
always go to the same state and when you
want to subclass you just have in Y at
one level of the subclasses to assert
that this and of course all the sentence
until otherwise claimed have the
same shared state so but if you're doing
data overriding which is a typical
Python features not common to all
object-oriented language whereby a class
can override so you see as long as you
access it this way the shared state is
not a static issue of this class board
but an issue of whatever class is being
generated this is the equivalent of what
those multiples calls a class method I
can also ask master method so the other
and much more interesting issue of
creational patterns is that we don't
want to commit throughout our code to
instantiating specific classes this is
absolutely crucial because they this is
where the program to an interface and
not to an implementation must offer
breaks down in the real world
people do strive hard to program to the
interface and now they need a new widget
and they do call new widget or I think
it's new widget in both Java and C++ and
they're in that very spot they have
destroyed their independence from the
active implementation because their
instantiate in a specific class so this
is why this whole group of creational
patterns is so important because we
absolutely need to approve that from
your code there are essentially two
approaches one which I will not deal in
depth that is very well covered in on
and get you is dependency injection
which basically means your object never
create other objects they always get
whatever they need injected from the
outside this is extremely wonderful for
testing purposes and it does help a lot
avoiding the specific class problem the
problem with dependency injection per se
it doesn't cover you okay you don't know
how many widgets you'll need part of
your objects work is to determine that
and generate five or seven or 22 widgets
and you don't really know how many how
do you inject those dependencies into
the object in the first place you don't
you inject a factory that is a factory
is something that can some callable from
function more for example that can
create new objects of whatever class is
appropriate the factory knows or can
reuse old ones if needed they can be
methods of variable by subclasses they
can be functions or other color balls
and you can have an abstract factory
class that basically is a collection of
methods for creation of factory methods
consistent with each other so in Python
each and every time in class is
essentially a factory because you call
it it's a callable like any other you
call it like you would call anything
else and this is the most crucial thing
that makes it interchangeable with any
other
Koller ball which could be a function or
whatever else internally it may
implement that new math special method
we mentioned which means it can actually
do anything it can do anything in terms
of instantiation it doesn't actually
have to give out new instances and it
may be injected directly since classes
are objects there's no need to have a
boilerplate function to call the class
just pass the class as an argument and
and there you are it can be injected
modules also can be kind of abstract
Factory in a non hallway for example you
never import POSIX or import empty I've
never seen it in Python code anywhere
you import OS and OS is the module which
knows or finds out okay am I on a POSIX
operating system or an NT operating
system and basically subsumes and
generates a single instance of one or
the other as needed if not you cannot
inherit and further refine the idea
which is why classes are more flexible
but sometimes you don't do you don't
really want at least in design terms we
don't really want to have different
implementations of the operating system
interface module depending on which
variant of Windows NT we are on or which
variants of UNIX systems were on
although it might be a better idea this
isn't the way it was designed in the
first place so this is the only no news
I'm going to give before any creation
pattern in Python and it's not really in
the library which kind of underscores
the fact that he is not all that used
whenever you call a type intrinsically
it basically starts with a new method
and if the new method actually returns
an instance of the class it's been asked
for then that instance gets initialized
so Python intrinsically does a two-phase
construction
which is a pattern not in the book but
very popular in other realm's
particularly in in gooeys you often have
you don't really want to initialize the
window object as soon as it's created
because you first need to establish
connect it in various in different ways
and then all the initialization must
take place so two-phase construction is
the constructor proper dose hardly
anything and then all the hard work is
done in a separate initialization method
it's very popular in many Liang's
and Python basically embodies it
internally this way this is an example
of a very highly generically factory
function one which is able to load any
object from any package in reach you
give it the name of the package and the
name of the object and it does
everything else of course it would be
easy to design it with a single argument
which is the DAF separated name and does
they split on the last dot but they just
since the role of the package name and
the object name are different I decided
this uses a built-in import function
which basically given a package a couple
of dictionaries to hold context and
possibly a list of object names that
will be needed returns the module from
the package and then get attribute can
take in particular the name object from
so for example you can dynamically load
of course this doesn't make any sense
because it's absolutely equivalent to
from P 1 P 2 P 3 import C 4 as CLS so
there's a language construct for that
but by using this function you can get
these strings from all sort of places
and do dark magic which is probably not
the best idea to do in production code
but can be very handy for testing as
usual alright so this just about covers
my extremely short coverage of
creational patterns this could be a
great idea for questions because I'm not
going to talk about creational patterns
ever again oh okay and move on to
structural factors I'm actually only
dealing with one subcategory in this
series of talks for now which I call
masquerading and adoption I mostly do
that because finding a nice side picture
for structure is almost impossible why
for masks you can find pretty cool ones
this is my main motivation not really
these five buttons set up to a facade
bridge decorator and proxy have
something in common they're all about
objects that basically take the place of
another or make believe they are another
right okay that's a bit vague but let's
go on case by case
so adapter tweaks an interface that
either class or object level you need to
consider both variants facade simplify
the subsystems
interface bridge allows you to use many
implementations of an abstract of an
abstraction so build many foundation of
an abstraction using many different
implementations of a certain
functionality without having to repeat
it in the coding decorator reuse and
tweaks without inheritance and proxy the
couples access to another functionality
from where the object is whether you're
allowed to reach for it and so on so
adapter we have some kind called gamma
that requires a protocol C protocol is
my favorite generic equivalent of
interface IC interface or something
that's purely syntactical all protocol
implies pragmatic constraints as well
supplier code Sigma provides some
different protocol s which basically has
all the C needs but in different
arranged in different ways so I write
some adapter code that sneaks in the
middle between the client and the
supplier it looks like a supplier to the
client it looks like a client to the
supplier and implements protocol C by
making calls to two protocol s so let's
have a toy example very very toy what we
require is a method foo bar the tag
takes a fool and
the bar unfortunately what we are given
is a method bar foo that takes a bar in
a fool so how do we reduce the impedance
mismatch with an adapter for example
let's stick to object-oriented we have a
class with whose method bar food date a
bar in foo and our client code is is
called - to use a different library
where the classes have a method foo bar
which wanted of were in a bar this is
how we do it with wrapping delegation so
we write the wrapper which takes the
roughy and saves it and whenever you
call foo bar with foo and bar it
delegates that to barfoo on the ravi
with bar is hope it's not rocket science
but then it's the tiniest and yet useful
example of adapter that i could put
together and this is how you instantiate
it you pass the existing bar for as part
of the Association if you want to work
at a class level you can do it with
inheritance so basically you delegate to
yourself so a foo bar in this case
inherits from a bar for and adds method
foo bar which calls powerful this isn't
necessarily appropriate because it also
you also end up with a original barfle
so this it may be faster but it's the
other approach the project approach is
that cleaner
there are many known uses of adapter in
the Python standard library oh I forgot
to mention that all my known users are
from the Python standard library it's a
large library you can find examples it's
pretty representative of a good Python
code for example a socket can be seen as
a file object it has a underlying file
object adapter which basically wraps the
raw functionality of socket into the
rich interface of file objects
that's the case of an adapter that
actually has to do a lot of work because
sockets are unbuffered and files are
buffered so all the buffering
functionality is hidden there I don't
think that's very appropriate I would
not like to have a buffering class
outside reuse there but that's how we
coded it don't know if you're familiar
with the doc tests which are very handy
fast quick to write with not quite as
proper and nice as the unit tests but if
you have a lot of doc tests you can
adapt them into unit tests with this
test suite adapter DB hash is another
example of adapter buttons and the
library includes a an interface to the
Berkeley standard distribution database
which is an extremely rich and
complicated system sometimes we want to
access it just if it was a good old DB M
for the kind of file from the early days
of unis DB hash gives us that or
stringer yo you have if you have a
string and want to access it at it as if
it was a fire they don't have to write
it on this which would be silly erupted
in a string that you shelve basically
takes something that has a very limited
subset of dictionaries essentially
forcing string keys and values and
offering just a very basic method and
make it look just like a rich dictionary
because it uses Pico so it can translate
any object to a string and back and user
user did mix in to add all the other
dictionary functionality
so from these known users and some other
looking at real world code we see this
in real life some adapters require a lot
of code not a bit more than the foo bar
bar food sample I get which is why
identified as a toy example mixing
classes are absolutely a great way to
adapt to rich protocols you can
implement advanced method nice easy
things I would exempt mixing classes
from
general dislike of inheritance I think
mixing classes are the greatest thing
since sliced bread adopters of course
overall level of complexity I can
actually imagine although I don't
remember a specific case but I would
code an adapter as simple as they borrow
food to food bar and death that's like
you can't really get any simpler than
that and on the other hand at the other
end of the spectrum you really do use it
after for such things as DB hashing and
BSD DB and it's not just about classes
and their instances in particular we'll
see that after facade that color balls
are are a very good target for that so a
facade occurs when some supplier code or
each subsystem ideally provides a lot of
complexity a lot of complex and rich
functionality and we need a simple
subset not necessary because we've
already written to the simple subject
because we don't want like a bazillion
other users of our code to have to code
to this complicated thing when they only
need the one tenth of the functionality
so basically the facade code is defined
implements and supply the simple sub
subset C by making internal its goals to
us as needed so what's the difference
between a facade and adapter it's kind
of subtle adapter is about supplying a
given protocol required by client code
so you imagine yourself already having a
client so the protocol you need is fixed
or you are designing the client protocol
to be amo genius so you can use
polymorphism facade on the other hand is
about having this very rich interface
that does a bazillion things when you
know only a few is needed and you want
to present him in a very simple to use
way and most often although this will
not come very clearly across from their
own users because they haven't found any
but in real life facade typically France
for many objects for a complex subsystem
full of stuff while adapter is typically
a one on one relationship so the best
way
to present facade a found is in this
site which is extremely controversial if
you like controversy about design
patterns and PHP and my sequel you will
find them a plenty here this is the
concept this is how it would be without
facade so I have my subsystem with a lot
of classes and everybody from the
outside is needing to make calls to many
classes with a facade I take a little
extra step so basically everybody calls
the facade and the facade deals with the
complexity of the of the subsystem so I
don't use many figures here apart from
silly ornamentation but I really like
this one because it shows you the
advantage basically here not you're
making the life of every kind class very
complicated because they need to learn
about all sort of important internal
details of your subsystem and you're
making your future life hell because you
will be constrained forever to keep this
complex interface around because
everybody's making calls on your inside
if you do go to the trouble of opening a
facade the lives of the clients are
simpler because all the things they need
are concentrated in one simplify place
and your life is simpler because the
moment you decide to redo this
completely you only need to make sure
you can keep emulating the facade in
your maintenance is much easier this is
far more than the simpler adapter
provides unfortunately the known users
don't really support that I have not
found any real complicated subsystem
with a facade email as a bit of that the
email package is pretty rich inside but
the reasons for the signal of the facade
is actually to emulate an older legacy
implementation of email sending so it's
not really the best of examples the
facades around are basically simplifying
adaptors of single objects which is not
exactly the best idea for example in
motorist engine there's a type 5/4 which
facades for lists it just gives you push
and pop functionality on top of list
rich on canary
you could see DB hash a Society for BDS
DBB this is probably the closest we
actually get to a facade I also gave it
as an example of an adapter so I'm
cheating but all sets now sets are built
in but they used to be a facade on top
of dicks huge do a lot of stuff but one
way of framing name is a facade for a
double-ended queue with a lock because
they're thread-safe all sparkles on
facade do so in real life asan may have
substantial amounts of code the
important thing is to simplify the
interface even if that means you do have
to add a bit more code in sometimes
minor functional additions like handed
method it a personal level of complexity
but it really matters when you're really
dealing with complicated subsystem
otherwise it's kind of gratuitous any
inheritance is never useful since you're
simplifying you're restricting and since
you're restricting inheritance is
useless inheritance always widens
interfaces never restrict them and this
is an example both adopting and
sustaining also works for calico levels
not just in object orientated in Python
columns play a very large role in Python
programming because you can easily pass
them as arguments returns and as results
so you often need to adapt or facade
them so the Sun still partial which
performs current operation so the most
elementary kind of simplification you
can do on a callable is stick some of
the arguments and frontal partials that
you do that and you have decorators
saying that they add something to make
it as easy as can be to apply a
higher-order function to wrap an
existing callable closures next
lexically nested functions provide for
with extreme directness for the simple
needs you may have in terms of shading
and of course you can always write a
class with a special method call this is
by the way is from economic fundamentals
text it explains how to compute the
worth of color
compared to standard long collar balls
means load loans that can be repaid in
advance with no penalty so bridge you
have a lot of realizations raw of a
certain obstruction a each of them could
be using any of several implementation
yodel functionality F and you don't want
to code n1 times n2 boiler plate glasses
so what you do is make sure the abstract
superclass of all the abstractions holds
a reference to the abstract super of
interface of all the possible
implementation and each row has to go
through our to reach F that's the
easiest way I have to bridge this is a
toy example in god it only I wouldn't do
it this way but it's one way to do a
bridge so say we have an abstract parser
and obviously parses does is accept a
scanner object and hold it and then what
else sorry I skipped that you need two
hundred fours here and it type out my
part every time it stands for any
attribute entry it asks the scanner for
that attribute so that is essentially
the same idiom I was using earlier for
except it doesn't do any addition nor
any subtraction either so it's even
simpler but the point is that they any
any parser a service and track parser
and whenever say needs the next token or
needs to push back a token on a pushback
stack he doesn't have to worry about
what scanner approach as long as the
interfaces are closed it basically calls
them in this case of self it abused
that's because I've used this idiom it
could be self if I hadn't dis get out
her I would say self dot scanner dot
next token self-taught scanner dog push
back so basically they all get full of
there
so there's several known users such as
socket servers one of the most complex
we end with a decorator decorator crab
which basically is how to assert some
semantics to it basically it's kind of
like an adapter except that the incoming
and outgoing interfaces are identical
and this is kind of a complex subject
for ten minutes left I will point out
the zip file which basically looks like
a file and wraps a file but inserts
dynamically and transport the
compression and decompression in the
middle recursive locks which looks just
like lock but no who is holding them and
and allow the same threat of already
holds them to acquire them again codecs
which basically transform a byte stream
to a byte stream but with some typically
internationalization into Boston and
this is the hudsucker proxy by the way
is for access restriction object or bit
remotely or in persisted forms we have
like we Chris Roxy has to do with
lifetime issue which is a typical use
for proxy we want to be able to access
some object as long as it exists but not
keep it alive just for our purposes for
example for caching that why we regress
exist shelf which I already gave is
another example also those proxying I'd
Lib remote debugger is a typical example
it lets you insert the bugging into a
remote process by essentially by
proxying for it and this is part one and
we do have seven minutes left for
questions and answers so I hope there
are some otherwise I rushed through the
last part and warrant ly I was kind of
hoping I could cut this in two parts of
them three which is why I inserted the
holes here
any question yes I gave the URL and the
very start but let me do that again
HTTP dub dub dub totally ax dot IT slash
crew underscore PI DP dot PDF and that
is just one big PDF it covers both the
part we've done today and the part will
do sometime in the future we haven't set
a date yet have any good examples you
know right from Google codes actually
yes now that I thought different so
maybe we started but ofc I we should
leave this for I do have excellent
example from third-party libraries and
applications for example one internal
important class of design patterns which
I haven't covered at all our design
patterns for a synchronous communication
they're covered very well for C++ in a
couple of book by dr. Schmidt and
they're incorporated inside the Python
library in a very simplified way known
as a sink or a cinch at the third party
package called twisted which is
basically the best implementation I've
ever seen of those patterns burn on and
that includes AC which is a great
library but twisted is better so there's
plenty of third-party libraries you
could look at important applications
I've never really studied there but I'm
pretty sure you can find a lot of like
take sugar the interface of the One
Laptop Per child is owned by thon I'm
pretty sure they're using a lot of the
but as an interesting way it would be a
great thing to do a report on that or
big applications written in Python such
as mailman
Chandler jungle there's so many of them
that are open source so you don't have
to have strained excess other questions
so you've talked a lot about Python
specific design patterns I was curious
as to whether you thought that there are
any I mean you talked more about general
excuse me you talk more about general
design patterns now there's curious as
to whether you think there anything that
you've discussed today that are more
relevant in Python than another language
it's I mean you talk a little bit
something I let's try to focus my
discussion only on those aspects which
are relevant to fight them yes right but
but all of the design patterns that
you've talked about as far as I could
tell could be applied to today all come
from the right exactly in the second
part I will get into one design pattern
in extreme depth this part has been more
of a survey the second part will be
mostly about not just the Averill
patterns in general but three of them
template method state and strategy and I
really get into the issue of how
introspection and dynamic approaches
serves their most of them so I'm not
talking about patterns that only apply
to Python not very interest in that it
besides that there are languages which
are basically equivalent in power such
as Ruby's pretty would be pretty weird
to have something that only applies to
fight for me not to Ruby or vice versa
because it would have to be some real
syntactic peculiarities of iterators are
different but the I traitor pattern
doesn't apply to either languages
because they both have iterators built
in in different ways small talk like in
the case of Ruby and much more similar
to the Jenga for design pattern in case
of Python but in other case they're
built into the land
so that's not so much a design talking
anymore
in those cases I had a question that I
noticed in your talk when you were
working on one of the patterns where you
were wrapping an object oh it occurred
to me that you were wrapping the object
in such a way that someone that was
looking into the object wouldn't see
those methods as part of the interface
you mean for introspection purposes
right and I was wondering is that's a
danger that language like python has
that you never run into in C++ and one
if you could comment I'm going to do to
consider well you you would you could
run into in C++ C word if you were doing
debugging you would re you debugging
with some advanced debugger including a
class browser so you get this object
which is actually proxying you may not
actually be able to tell what it does
have or if you're using dynamic casts or
other advanced aspects of C++ your
debugger depending how smart your
debugger is it may get rather confused
if you specifically want to support
interactive debugging you basically have
to add the Oh the introspection to your
wrapper to make sure it looks to the
outside including a debugger exactly as
it would look in the inside it's a lot
of overhead if unless you're
specifically very interested in
interacting debugging as you know I go
by the by the motto debugging sucks
testing rocks so I'm much more
interested in supporting extended
testing than in supporting ascendent
debugging when I am dragging something
I'm going to be aware of the above the
actual issues anyway so for example
suppose I'm debugging something and a
half problems on a proxy that actually
supposed to send the calls out Australia
I'd better know that because the reason
things are misbehaving they have nothing
to do with my code and everything to do
with the underground cable through the
Pacific Ocean having just been cut by an
earthquake so trying to have proxies and
other such consoles be totally
transparent it's possibly a misguided
expense of Labor given these issues
particularly in case of ok doesn't work
now what well is there actually a
transatlantic cable in the middle you
can't really abstract from that because
it could get cut from an earthquake all
right I think we're out of time actually
ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>