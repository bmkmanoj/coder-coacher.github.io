<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Human Aspects of Software Engineering: Social and Cognitive Perspectives | Coder Coacher - Coaching Coders</title><meta content="Human Aspects of Software Engineering: Social and Cognitive Perspectives - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Human Aspects of Software Engineering: Social and Cognitive Perspectives</b></h2><h5 class="post__date">2008-03-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mAX2G-RogAk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">for
so professor with Hassan is a professor
at the technion-israel institute of
technology she is at the Department of
Education in technology and science she
pal she already published a book by the
name human aspects of software
engineering and there is another book
coming about agile software engineering
she has more than 100 publications and
she is also a friend and a colleague of
mine at the Technion and I am pleased to
welcome read to give her job entitled
human aspects of software engineering
social and cognitive perspectives please
good morning thank you for attending
this talk and thank you for inviting me
I'm going to talk about human aspects of
agile software engineering and as we
will see one of the main idea that i
will advocate his collaboration and i
just want to mention at the beginning
that may talk is based on may joint well
with many people yell Dubinsky gym to
make her own Citadel dallas tiger and
amira levy dashed just to not to make to
become familiar with you who is familiar
with agile software development ok ok
and who is familiar with as a following
problems of software projects who is
familiar good ok so we are on a very
safe fairground and the idea that i will
try to present the Dames a working
assumption will be as that software is
an intangible product and there's such a
product it raises it faces us with many
problems that part of them we can see
here and what I will try to show you
that edge aisles of the development
to overcome these difficulties by doing
two things the first one is to increase
the software process transparency
because if software is an intangible
product we can feel it we can see it we
it's harder to communicate it so address
of the development tries to increase the
process transparency and the second idea
is that once again because software is
an intangible product it rights to
reduce the cognitive complexity because
it's harder to understand something
which is intangible so I just love the
development in very systematic way
reduces the cognitive complexity and we
will see it there later in our in the
next 50 minutes i will talk about sweet
topics collaboration obstruction and
testing i'm not sure that i will have
time for all of them but then i will try
to go over as much as we have time I
didn't know if you're familiar with
edges of the development so you are
familiar with the idea manifesto okay
you get the idea and with a good results
of agile projects that it does many good
things to software projects it increases
the business IT alignment it accelerates
time-to-market enhances software quality
impose team morale increases
productivity and helps to manage
requirement priorities so you can see
that many people many people it is based
on a service that was done with about
several thousand cell petitioners they
most of them declared that they got
better results with a choice of the
development with these respects so this
is a big round and let's start with the
first part which is about collaboration
and i would like to present to you the
following scenario okay you are team
okay for this purpose we will be a team
and you are told by your manager by your
team leader I don't
the system here but you are told by
someone here in the yorkie that if you
will then complete the project on time
within budget on high-quality
high-quality you will get a bonus ok the
entire team will get a bonus and you are
requested among the team to make a
decision how to allocate the bonus and
you are given five options the first one
there it means that the total bonus 100
percentages of the bonus will be
allocated equally among the team members
ok the second option means that 20
percentages of the bonus will be
allocated according to the personal
contribution to the project success in
80 percentages of the port of the bonus
will be allocated equally among the team
members ok and we can proceed with all
these options and this means that
opposite that 80 percentages will be
allocated according to the personal
contribution and 20 percentages will be
allocated equally etc and now take tell
me seconds no more no one needs more ten
seconds to decide which option would you
prefer yes see ok why
okay thank you says see other opinions
yes
mm-hmm okay now you're right it depends
on many factors it depends on how big
the bonus is because if ten dollars we
really don't care you know it depends on
the skills of the team members it
depends on many issues but try to think
about the general situation okay and if
you couldn't think about the general
situation what would you prefer okay so
all the time all the bonus would be
allocated equally among the team members
okay did you face any conflict when you
think about it can someone tells us
about the conflict okay we'll proceed
first of all in all audience in all
cases that I present this problem and
people prefer that a bigger portion of
the bonus will be allocated to the team
rather than only been personal basis
it's crossover Israel the US anywhere
and another phenomenon that happens all
the time II that people have conflict
between the interest of the team and
their personal interest and we will
connect it in a minute to the fact that
the software is that intangible product
and what we will do in the next 15
minutes or so will try to explain this
conflict by game theory very briefly
games theory is a field is mathematical
field so tries to explain how people
behave in situations that are
characterized as games are so for
example are there are several players
each player is influenced by the
behavior of the other players and each
one wants to maximize his or her profit
okay so we will try to understand this
conflict between the personal interests
the team interest with game theory with
in games 3 we will use one framework
which is called the prisoner's dilemma I
will familiar with it okay and so once
again in one sentence the prisoner's
dilemma is a analysis framework which
tries to explain how people behave in
situations in which they cannot verify
that their cooperation is reciprocated
okay and it happens in it with for
example when you cannot coordinate it
with other people you are isolated so
many many situations that you cannot
verify whether if you cooperate your
cooperation will be reciprocated so I'll
just give you the hint at this stage
that because software is an intangible
product it's sometimes hard to verify
that your cooperation is reciprocated
and you can go in your mind and find
scenarios that you couldn't verify this
so let's present it very briefly the
prisoner's dilemma it's originally came
from a situation that this is our as it
happens in a prison there are two
prisoners are isolated and they should
decide how to behave in the following
situation the police tries to find
evidence against them and the police
puts them in two different cells they're
isolated they cannot communicate and in
the very simplest form they play one
turn and in this term they should decide
between two options whether to cooperate
with each other with each other it's
important so population is between them
or to compete that means that do not
collaborate with each other okay and
this table describes from aids
perspective what happens in each case so
let's try let's start with this cell ok
a cooperates as I'm sorry a completes
okay a competes be cooperate it's
it means that aim a provides to the
police evidence against be okay so now
that police has some evidence against
bee bee will go to the jail and a will
be released because the police doesn't
have any evidence against him or her
because a we cooperated with a okay it's
clear so this is very good situation for
a that a competes be cooperates a gets
the best results this sale is that
exactly the opposite exactly the
opposite because a cooperate it
cooperates it means that it doesn't
provide the police any evidence against
be be complete it means that he does he
or she does provide evidence against a
to the police and a will go to the
prison we will be released and it's very
bad for hey a we are looking here at the
table from ace perspective so far it's
ok ok let's look at these sale they are
both complete they both complete and
that means that they give both of them
give to the police evidence against each
other ok and it because the police I
would like to thank them for the
evidence that they provide the
punishment is decreased it would use but
still there evidence so they get 00 is a
relative Sam it's not absolute okay and
what happens in in situation in which
they both cooperate they do not provide
to the police evidence do not provide a
the police evidence so the police cannot
accuse them and they are both released
but why is it better than this because
there is no evidence to the police so
it's a better situation from them then
this one
okay so this is a payoff fair table and
now if you were a according to this
table and think about consider the fact
that you cannot you cannot verify what B
is going to do because you are isolated
okay this is one of the very important
work in consumption of the prisoner's
dilemma that you cannot coordinate how
you behave according to the other player
so I what who do do yes
so if you were a what would you do like
okay you see it it's very clear because
if you are a if b cooperates if we
cooperate it's better for you to compete
and if be complete once again it's
better for you to complete now remember
that we will do the same a calculation
okay and he or she also will compete
because it will not have a way to verify
and notice that if they both cooperate
it will be better for them than to
compete okay because five it's bigger
than 0 so if they could coordinate their
behavioral they should cooperate but
because it cannot coordinate their
activity havior they will compete and
they will get very bad results right
okay so this is a prisoner's dilemma and
now let's return to the bonus the case
okay which enters the bonus situation
and once again you are we'll think about
a smaller team only two people a and B
and in software development there many
ways that you can present this
cooperation and as competition for
example if I'm on the team and testing
is a go testing to integrate only well
tested code it means to cooperate if I
integrate the code which is not well
tested it means that I compete okay and
you can think about many many a forms of
cooperation and competition in software
development so let's see what happens i
D fail on the team I will be a if it
will be it will be B and assume that
both of us cooperate we test our code
very well
integrate only very well tested code at
the end our personal contribution will
be considered as equal more or less
right so we'll get remember the first
problem we'll get about 50 percentages
of the bonus both of us now assume that
I completed a field test it's a code
very well integrates only very well
tested the code and I let myself to
complete not to test all the tells area
code and that because I will complete I
can produce a lot of code because I do
not test it i can proceed in the long
term it will harm us but on the short
term it i will be perceived as doing
more work because from the outside i
will do more and more and will not test
it just a moment and so at the end its
end to the one outside and we clean many
working assumptions once again ok let's
think about it theoretically at the end
it will yield contribution will be
considered smaller than mine because i
did a lot of code he is equally tested
all the code so he proceeded slowly so i
will get 80 percentages of the code and
he will get 20 percentages ok this is a
reverse situation when you're here we'll
get 80 percentages i will get 20 and
let's see to the eighth let's look at
this cell it is time if we both of us
will not test our code if was of us will
not test our code it makes sense that we
will not be able to completely complete
to complete the project and you remember
the conditions to get the bonus you
should complete the project on time on
high quality so in this case if both of
us will complete we will not get the
bonus at all so it's very bad situation
and we will get 0 now if you look at
this table what is the difference
between this table and the previous one
of the prisoners dilemma
with respect to the relative values I
will remind you okay this was original
one and this is the software web
excuse me you're right but think about
the relative values okay they are only
illustrative i could put here to raise
all of them by 20 so none of them will
10 ok you see
right right in this case in this case it
no matter what B does for a it would be
better to compete okay now in software
project and this is what I suggest that
are in this case in this case because
it's smaller than this one so what it
means here that in software projects in
software projects partial cooperation is
bigger than no cooperation at all okay
because in these situations that only
one cooperates they will get at least
something okay from if we can return to
the first working assumption that each
one is evaluated according to his or her
contribution so in solar projects
partial cooperation is better than no
cooperation at all and it is different
than the prisoner's dilemma so but let's
put it now in the Y del conte I would
like to emphasize first of all that the
prisoner's dilemma is not something
theoretically it how people behave in
situations in which they cannot verify
that cooperation is reciprocated it's
human nature you cannot change it you're
our tendency how human tendency is to
compete in such situation if in if when
we know that if we cooperate we'll get
better results so this is a absolute we
cannot change it now let's see what goes
on in software projects in software
projects people are asked developers
engineers are asked to cooperate because
it it will produce good results however
because soto is intangible and with now
we connected to the prisoner's dilemma
because software is an intangible
product it's very hard to verify that
our cooperation is reciprocated once
again because software is an intangible
product
it's sometimes hard harder to verify
that our cooperation is reciprocated so
it brings us back to the situation of
the prisoner's dilemma but as we just so
in software projects in software
projects competition of all partners
lead leads to the worst results so we
have a conflict here because of the one
hand we know that we it's not so easy to
verify that our cooperation is
reciprocated on the other hand we know
we know that this is a day software
world that if we do not cooperate we'll
get very bad results and now I would
like to move to the next stage and to
explain how edges of the development
tries to overcome these obstacles of
software projects so they just recall
that the prisoner's dilemma the source
of the prisoner's dilemma is that the
prisoners could not could not coordinate
their activities so importance of the
projects it is reflected by the fact
that software is an intangible products
or sometimes we cannot verify that with
our colleagues behave in the same way so
what I suggest a judge software
development does it vanishes say on the
inability to verify that cooperation is
reciprocated by increasing the forces
transparency and in such a way it
vanishes the working assumption of the
prisoner's dilemma and the conflict the
conflict represent the dilemma was a
prisoner's dilemma doesn't exist anymore
and because you are familiar with edges
of the development I will just mention
several practices to illustrate how
address of the development increases the
software transparency
first of all the whole team the whole
team if you know I just sort of
development the team sits in one office
in one space and the whole walls are
dedicated to post all the information
that is needed for the project measures
the assignment the user stories the
progress the daily progress everything
is presented on the whole walls so
everyone knows what goes on and what is
the project status the second one is a
daily stand-up meetings if every day as
a team member should report on what I
did yesterday and what I'm going to do
today I increase the sort the process
transparency and if all of us do it all
the team does it every day it increases
as of the process transparency very
clearly okay you cannot hide anymore you
cannot hide anymore you could not
compete anymore another practice that
helps us to increase of the transparency
is the planning sessions because in the
planning sessions unlike in traditional
software development processes all team
members participate so it's not just
gotta get something from someone else
they participate they hear their out as
a customer they can ask him or her
questions and it's very transparent all
these requirement a phase measures I
mentioned it before measured our
measures are posted around and everyone
can see including management including
the customer can see how their project
proceeds and finally once again the
customer the customer involves all the
time in the process so nothing should be
hided okay so this is how address auto
development increases a process
transparency in order to vanish the
working assumption of the prisoner's
dilemma that in to enable to lead people
to cooperate because if they could not
verify that the cooperation is returned
they would tend to compete because the
prisoner's dilemma is our
human nature okay so this is the first
part it's about how edges of the
development increases soft when
transparency and if you want to think
about it more you can think about the
following questions may be other social
development methods can be analyzed in a
similar way and maybe other theories
from game steer away from behavioral
sciences from other fields can help us
in understanding how to improve software
process software processes okay we are
moving to the next part it's about
obstruction and I would like to ask you
what is common to the forward following
statements i will read them the first
one is i needa get i need to gain a
global view its application in order to
know how this method fits into it the
second one is i truly believe that if i
had may need to think about these two
objects more abstractly have come up
with the conclusion that they can be
extracted into one class but i must move
on to the next development task okay
this is the second one the third one is
I need some time to think about the code
without being swamped with all the
details I'm almost sure that if I could
leave now and go to swim I could have
come up with a solution but a match
stayed late as all the others on my team
and the last one is i wish i could join
the program ill when she or he writes
the code you ask why i'm not sure if
this design can be implemented into c
plus plus okay what is common to all of
them
their excuses white why why why people
have felt the need to explain their
behaviors yes okay mm-hmm very local on
low level okay okay so let's just
highlight these for the full part in
that highlight Lisa and if you that
result in excuses the first one said I
need to gain a global view and need to
gain a global view the second one said I
I I would prefer to have two minutes to
think about it more abstractly the third
one said I'm being swamped with all
these details and the last one talked
about implementation code implementation
and these are all these terms together
and once again there is tension between
very low level of obstruction and high
level of abstraction and let's see how
address of the development is expressed
with this respect how we can improve our
understanding of about edges of the
development with the suspect let's think
first on a traditional development
process okay it starts with requirement
and requirement analysis and it goes to
design and then it proceeds to detail
design and then to coding and then to
testing and as you can see that we
reduce the level of obstruction from
each phase this is one characteristic of
traditional development processes the
second one second characteristic that
usually each activity is performed by
different people so people are exposed
only to one level of abstraction of the
entire product
and remember we started with the red
consumptions that software is an
intangible product it's how to
understand it we should assist the
developers the entire team in the
development process and one means that I
suggest them not going on into all the
psychology now that in order to help
them to improve the understanding of the
software product they should have they
should gain a view of the product on
different levels of abstraction ok not
to get the specifications from another
team and just to code and to be remained
only on a very low level of abstraction
but rather to move between levels of
obstruction in order to improve their
understanding it reduces a cognitive
complexity because software is an
intangible product so let's look at this
several practices it guide very nicely
agile teams to move between levels of
abstraction so first of all they're
planning sessions that are either take
that take place it's at the beginning of
each release and at the beginning of
each iteration in the iterations are
really small they're of one or two weeks
so first when the relations longer is
about two months so first of all the
release planning session takes place on
high level of abstraction relative high
level of abstraction then when we go to
the iteration planning session we reduce
the level of abstraction so if this is a
timeline the project timeline we start
here with the release planning it's a
high level of abstraction we move down
to the iteration planning session it's
one day at that beginning of situation
then we go down Young's iteration to the
code level nine days and development
days then for the next iteration we go
once again on increased level of
obstruction then go down and cetera et
cetera till they release ends and we
start again we go increase the level of
obstruction and we move between the
oldest levels
another aspect of the blurring session
that helps us to move between
abstraction level is the fact that the
entire team participate in their
planning session so all the team members
have both the high level of abstraction
and the glory local live the lower level
level of abstraction when they code so
they are aware they know from where each
requirement each environment arrives the
fact that we talk about short releases
and it means that we are not staying too
long on the same level of abstraction
each time we should change the level of
abstraction on how we look at the
software / programming is another
practice that helps us to move between
levels of abstraction because if I am
the driver even if I am the driver I am
on the low level of instructions a
navigator who sits next to their driver
things on higher level of abstraction
and the last practice is refactoring
there are more by the last for now
because if you do refactoring in order
to know how to redesign your code in
order to improve your code you should
look at the code from a higher level of
abstraction and then to go back to the
code and to reduce the level of
abstraction and what is nice II that
because we factoring edges of the
development legitimizes in fact away
it's okay to do it people do it in other
development processes sometimes people
who want to improve the cordial just
told don't do that proceed to the next
development task so this was a second
illustration of our edges of the
development tribes to help to cope with
the intangibility of software and while
the first one about the collaboration
showed how we how address of the
development increases a process
transparency this illustration shows our
wages of the development reduces the
cognitive complexity
I leading people to think on different
levels of abstraction the third one is
about testing and here its a mix we will
see once again see all the a gel style
of testing helps on the one hand to
increase a process transparency and on
the other hand to reduce the cognitive
complexity so and you just want to start
by presenting several arguments white
people do not like testing in the
traditional way it is carried out in
many traditional software projects okay
the first one is that in traditional
development processes testing is carried
out at the end of the process and in
miniature in any case it is done under
pressure so people do not like to be
under pressure so they sometimes in many
cases adjust skip it and we can look at
the quote to describe the situation it
is taken for me hands land late it's one
of the famous software engineering
textbooks and it says the testing
activity often does not get the
attention it deserves by the time the
software has been written we are often
pressed for time which does not
encourage thorough testing post balding
test activities for too long is one of
the most severe mistakes often made in
software development project this
postponement makes testing a rather
costly affair and yet in this book after
the coup knowledge Minh is which is very
important this book does present testing
as one of the last activities in the
development process observation two and
we try to understand now or now why
additional testing is not encouraging so
much a testing give may give negative
feedback think about what testing is you
write code and now you should find bugs
in your code you should find what is
wrong in your code
not a good feeling and it ends with
fellow let's read the red box okay which
reflects the ideas that I just mentioned
maybe the reason testing is not always
sort of fun it is that is that there is
a flip side the program may not work in
the earlier parts of development things
can go wrong but fellows are not as
absolute as graphic and graphic as they
are in testing a developer can even
unconsciously own purpose sweet problems
under the rug during requirements
specification design encoding but when
those problems show up as failed tests
it's no longer possible to kid yourself
so it's really not a nice feeling the
third observation wife people do not
like traditional testing is that they
really don't care because in many cases
it is a transpose encode is given to
another Department the QA Department and
if it's not my responsibility the code
quality is not my responsibility I will
turn to skip this and they will not
dedicate the needed time the false
observation is that testing as it is
done in traditional development
processes is that an activity that takes
place at the end of the development
process it takes place at the end of the
development process and if we think
about traditional other assembly lines
or other factories of other kind of
producing products when it comes to the
end of the production line that status
of the workers is reduced because the
first one of the one who designed the
product and then the people do more
technical jobs which are not considered
to be only high status and if it once
again if we leave testing at the end of
the process the people who do testing or
not do not get high status and let's see
the results of one name
study it is taken from the communication
of the same and you can go and read the
entire study so most organization
recognized the need for high-quality
testers and the specific specialized
skill set testers still struggle to win
the respect they deserve one manager
told us if you had a diagram with code
at the top the engineers developers
would put them through with themselves
above that many testers feel they
struggle to maintains of place relative
to that of developers and finally the
lack of status and support make the
tasters job more difficult and
time-consuming as a struggle for
cognition becomes part of the job itself
so if this is a status that testers get
no one would want to do testing and
there are other problems with testing
from the managerial perspective
sometimes it is argued their testing
slows down the development it's
sometimes it's it is a claim that it's
how to manage testing cognitive
difficulties remember we talked about it
before it's hard to know what to test
how to test how many two tests etc etc
so so far we talked about the problems
with traditional testing and I would
like to suggest that edges of the
development helps us to a overcome these
problems by doing two things increase
the process transparency and reduce the
cognitive complexity and just want to
make sure that we talk on the we have in
mind the same concept for test-driven
development of their development when I
say test-driven development EDD I mean
automatic tests which are written power
to the talk the power to the code ok
automatic tests which are written before
the code is written and you know do you
need I'm sure you know and with their
red and green bear bout you know
so let's go one by one on all the
problems that i just mentioned and we
will try to see our TDD helps us to cope
with these problems time pressure is
eliminated in ages of the development
because you do testing all the time so
it is not left to the ends of the bullet
or process and you do not skip it
because there's nothing to skip testing
gives negative feedback as it is done
traditionally but if you look at how
testing is done in TDD is done you will
see that you just reverse the directions
you start with a failure because you
write a test that fence because you
haven't written the code yet so it fails
but then you write the code in the test
once so it ends with a success and i
would like to present testimony of a
practitioner it is taken from the wiki
of our edges of the development it is a
accessible to everyone so it starts like
this why don't people like testing where
the traditional way of testing is tough
to take you right what seems to be
perfectly sensible code then you write a
test and the test tells you that you
failed no one wants to hear that let's
return it around why the test first run
it of course it first you haven't
written the code under test yet start
writing code keep testing soon the test
will tell you that you have succeeded ok
very good feeling to end with a success
the second the next argument was about
the responsibility is transferred to
some other department but here it is not
transferred because each developer each
engineer test his or her code so no
responsibility can be transferred low
status of pesters it vanishes also
because all tests all developers do
testing they test their own code from
the managerial perspective we know we
have evidence now that and we saw the
big
the results of federal project that
edges of the development it which
includes testing ted-ed in most cases
improves accelerates their time to
market and it is partial it can be
partially explained by the fact that
tests are automatic so if you think all
the regression tests it's very easy to
do them because they are automatic it's
how to manage testing once again it's
very easy it's very clear when you write
the tests you write them before you
start implementation implementation of a
specific requirement let's see how it is
reflected from the same name wiki it's a
wonderful experience I don't write code
any other anymore anymore my code has
less problems I have more confidence and
this is from the managerial perspective
and management has more confidence
cognitive difficulties once again will
return to cognitive remember we at the
cognitive perspective you we want to
reduce the cognitive complexity so let's
see how TDD does it because in TDD each
time we test we write a test for a very
specific very small unit we should not
think about a huge chunk of code so it
enables us to face a small problem each
time and it's very easy to know what to
test because it's what i'm going to
write next and next line the next
function the next method it's very easy
to know what i should test and how much
testing should be performed it's also
very easy because i write the test for
what i am going to develop very easy to
know let's see how it is reflected in a
practitioner john on Jeffrey's a key
aspect of this process of TDD don't try
to implement two things at a time don't
try to fix two things at the time that
means reduce the cognitive complexity
just do one when you get this right
development turns into a very pleasant
cycle of testing seeing a simple thing
to fix fixing it testing getting
positive
x feedback all the way guaranteed flow
and you go so fast try it you will like
it ok so let's conclude with the third
part of testing which was about how the
problems that traditional testing
challenges as with and how did he helps
us to cope with these problems by in
many ways but particularly by reducing
the cognitive complexity and in some
cells also to increase the process
transparency so if you have to take one
message from all these illustrations and
cognitive perspective managerial and
possess transparency I would suggest to
take the felt that when we think about
our processes development positives we
should think about the fact that sort or
is an intangible product and it's such a
product it raises many problems that we
should encounter in a very systematic
way and to solve the typical problems I
suggest two mechanisms one is to
increase the process transparency and
the second one is to reduce the
cognitive complexity notice the tasks
but doable so I'm done now and they will
be happy to the questions
so what do you think of the best
examples of studies or the best ways to
illustrate the value of agile processes
do you think there's some work to be
done there and finding better ways to
demonstrate this using actual data
studies grabs whatever as the sales part
of this you look for data you want data
I would think that would be a good way
to provide hard data okay you know that
edge of the development is the relative
new approach it's not it's a new like
Google I guess more or less so there is
data but not well established as
traditionally processors have but you
can look at the conference proceedings
of the conference's and find some data I
have a paper in i triple e sotto about
testing and how it influenced as a
product it was a huge project in the
Israeli Air Force and it made many
changes it improved the process that it
it affected confidence which is very
important in to influence the customer
relationship with a team and there is
data not as much as traditional
processes have at this stage but you can
come to the conferences and see how
practitioners talk about development
edgell development processes and not
only the practitioners but also
customers come to these conferences
because they understand that mainly in
other shops they will get a better
service than the one they get currently
so they come to the conference's some
people say that a good companies that
will not move change in some way they
development processes will you know what
is the destructive technology you know
what it is it's a technology that at the
beginning sometimes people tend to
ignore and when sometimes it
when they keep ignoring it and at the
end they left behind because they didn't
join the wave but maybe were too early
to know exactly okay there are two main
conference is that there is one in the
North America that takes place in the
summer this year it will be in August in
Toronto and there is one in Europe each
year the next one will be in England if
i'm not wrong Oh Madrid even it will be
in June so this was a main two
conferences the wiring the you in North
America each year it doubles the
audience last year the world it was in
Washington DC and what about 1200 next
year it now in Toronto it is expected to
have a 2000 it's big move the North
Americans one is called the agile
conference edgell 2008 now okay that's
Google a Toronto and google it I forgot
babe thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>