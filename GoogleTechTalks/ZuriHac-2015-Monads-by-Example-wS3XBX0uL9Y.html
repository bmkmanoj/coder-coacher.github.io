<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ZuriHac 2015 - Monads by Example | Coder Coacher - Coaching Coders</title><meta content="ZuriHac 2015 - Monads by Example - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ZuriHac 2015 - Monads by Example</b></h2><h5 class="post__date">2015-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wS3XBX0uL9Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'll be talking to you about more nuts
for the next hour but before I start I
really have no idea like with what kind
of knowledge you're going into this talk
I'd like to ask some questions first of
all of the people in this room who is
actually here to listen to the talk all
right
so hope you is comfortable with using
the motivations for maybe and kind of
understands what it does how about all
right then to notation most of you have
probably used it at some point of the
other right all right you would say that
the completely understand what the
rotation does and could translate it
into ordinary and then the Monad laws
who is familiar with good mother
basically what I'm going to do is I'm
going to walk through these topics
essentially in the order I just asked
about them so I'm going to talk about
the Monat instances for maybe lists
stage and a little bit about IO and then
I'm going to talk about good notation
what it does
and how these sugars into ordinary
Haskell and I'm going to talk very
briefly about the Monad laws there's
really not very much to say about them
but I'll say what I have to say so
starting with maybe I would keep the
short because most of you seem to be
familiar with it so as a reminder the
doctype may be it is defined as either
just a for nothing and it's Haskell's
replacement for null values essentially
so if a may be value is nothing that
means it is absolute for whatever reason
and if it's just and I show you that it
means that the value is present and we
can use it and maybe is commonly used to
signal error conditions of any kind and
as an example we here got my example
will be sort of like a web application
because everything is a web application
these days so we've got a user data type
and the user has a user name defined
right here but since we're very privacy
aware here at Google we actually allow
our users not to specify a name at all
so the user name is maybe string it
might be absent if the user chooses not
to specify a name for themselves and
then down here we've got a super high
performance web scale database for users
which is initiates a compile time
function but maps IDs to users in a real
application of course you'd have is some
sort of database that you're querying
but for the purposes of this example
we've got a function that returns for
the user for the int 1 myself for the IT
to Simon Peyton Jones for the IP 3 Comic
Sans for the ID for a user but that user
has chosen not to give themselves
named for the ID five a user who has
chosen the empty name and for any other
idea that we use so that's going to be
the set up and the idea is trying to
motivate why we actually use the monad
answers for maybe so let's start with
with something relatively reasonable we
want the username for an IT so we've got
a function of type int - maybe username
all right so conceptual of course what
we'll do is to encourage a query the
database if the user is present will try
to get the username if the user is not
present we will return nothing right
away because we can't return user name
for the user that doesn't exist so let's
just implement this naively we'll have
to do case analysis on the result of our
lookup
and if that's nothing return nothing if
that's just something we return the
username and of course that username may
also be non-existent we don't all right
now let's modify this function to do
something slightly different namely give
us the first character of the username
so we'll define a auxiliary function
first character from string to maybe
character because of course for the
empty string that is no first character
so first character of the empty string
acha the empty list is nothing the first
character of a list that is not empty is
well the first character wrapped in a
just constructor
so far so standard and if we now turn to
this function and turn it into first
character for ID which Navi tansy then
will have to again as a match on
whatever the username query returns as a
reminder username is of course a regular
function just defined using records
syntax from user to maybe string so if
the username that we get is nothing then
we count to return the first character
if we get just a username then we can
return the first character of that
username if it isn't it alright let me
quickly check if actually all works
alright and now if we get the first
count for ID 1 that's me that's Jade you
get the first time for ID 5 that's
nothing
because you through 5 is a user who has
and so on
now what I'm getting at is that this is
a really really terrible way to write
these sorts of functions because
essentially it doesn't scale at all if
you imagine now you don't have three
functions that you want to apply one or
the other but like five functions or so
and they all take some input and returns
or maybe output then chaining them in
this manner is really ugly Oscar can't
do better on this so we'll define an
operator actually that's wrong operator
will this one which is called the fish
operator also occasionally called wisely
composition but fish is much better
and what we actually essentially want to
do is we want to change functions of the
forum age to maybe B so we'll take the
first function from a to maybe be a
second function from B to maybe seed and
what we get out of our operator is a
function from a to make it C and you'll
probably notice that this is very
similar to composition that's why it's
called flies decomposition for
composition you'd have a to V V to C A
to C and here you've got a may for all
the outputs so let's define not operator
in general let's say we have a function
f and a function G and we'd like to
compose them so our result is obviously
a function that receives a value of type
a which I'll denote by a how what we can
then do is well we can first apply the F
to the a and receive a maybe B and then
we can do case analysis on
and if it's nothing we did turn nothing
because we can't change the function G
on to nothing if it's just a value of
type B represented by B then we can
apply the G function and we'll get a
maybe C so that's our composition
operator and now let's the formulate
that first card for ID function in terms
of that what we first want to get the
user then we want to get the user name
from the username we want to get the
first character and those six lines so
that is quite handy and primarily an
example in how Oscar that I killed
spoiler plate for most of the time but
this has to do with monads is that this
fish operator is a variant on the
defining operator of monads namely the
bind operator and so let's take a look
at the Mona
so this operator is called fine and what
it does is it takes a value of type ma a
function of type a 2mp returns an empty
and you'll probably notice the
similarity here if you substitute maybe
for M in this type signature it's almost
like this function here only we drop the
first component and I'll show later that
the fish operator can actually be
implemented in terms of the find
operator but let's deal with that first
so the first interesting thing when the
first difficulty about the monad type
class is that it is a so-called higher
kind of time class and what this means
is that down here you see that M is
applied to another type in this case the
type a which may be some arbitrary time
so this means that in contrast two types
like string or int which cannot be
applied to another type substitute to
the string here that wouldn't make too
much sense because 3a is not a thing
that we can talk about we need for our
mu not type a so called type constructor
ie something that can be applied to one
other type and exactly one other type in
order to get a so-called complete time
and complete types are exactly those
types which have values so in does a
complete type string is a concrete type
maybe it int is also a complete time
because the maybe is fully applied list
of in would also be a complete type but
list and maybe themselves are not
concrete types
they need some other type in order to be
able to hop out so that is the first
difficulty and that is why later we are
going to write instance more not maybe
not instance monad may be a because if
you were to substitute maybe a for these
M's here you'd get a type that ISM well
you apply maybe to two times which it
can't
all right back to the type operator now
that we've cleared that so the pipe
operator is used to take a so-called
action this MA is an action
I'm going to call functions of type a
2mb computation actually I probably
shouldn't use the tilde symbol yes
because it has a specific meaning in the
husker context which is not what I
intended so let the triple equal sign
mean I call it action action is
definitely standard nomenclature in the
hostile worlds computation I'm not
actually quite sure if that's my
invention or if that is also standard
empowerment's but I'll assume that it is
so pine takes an action feeds it to a
computation in some to be specified
manner and returns another action and
then there is a second function that
we'll be dealing with frequently and let
us return it takes a value of I a
produces an action which has also
and in order to make that less abstract
let's have a definition and the mono
instance for maybe works exactly as we
basically practiced all the way to this
point
it takes an action a maybe something and
feeds it to a computation if and only if
the action is not nothing if it is
nothing then we get nothing back if it
is not nothing then the next computation
is executed and we get the result of
that computation and so let us define a
bind operator that does exactly that if
we've got an action then we can pattern
match on that action face analysis on
the action it's a nothing nothing it's
just something
we all returned the result of applying
well this is basically the pattern of
I've been talking about all a day up to
this point and so that should come as no
surprise and now the fish operator can
relatively straightforwardly be
expressed as exactly that because if we
apply F to a then we get a maybe B and
we can just feed that into G using our
new bind operator and that simplifies
the whole story consider incidentally
the bind operator can also be defined
using the fish operator so these two are
basically have the same power now the
next thing that we need in order to
close that chapter if they turn and now
before exam we actually have two choices
that would match up with the types we
could actually return nothing because
that is a legal value of type maybe a
for anytime a and the reason why we
don't do that will become clear when I
talk about laws but right now let me
give you a very broad intuition the idea
of the maybe monad
is error handling so if if you get an
error along a chain of computations you
immediately drop the chain of
computations and say oh I got an error
on the way I can't give you a result and
the idea behind return is always that it
puts a normal value into a monadic
context that is kind of most natural for
the domain that we're working in and
we'll make this more formal later there
are laws as to what return
but right now if we talk about errors it
would be relatively unnatural to take
any value as map it to the computation
that is always an error rather it would
be much more natural to map it to the
computation that produces exactly that
value and is successful in producing so
we'll actually for the time being go
with just representing the computation
produces just X and of course we can
make that so let me check Wow everything
compiled so it must be correct to
specify Y return well so my eyesight's
always would be just right you put in
the context always just yeah one but the
meaning is also not exactly yes as I
said the types would match up with the
just or nothing and so according to the
type system it wouldn't be a problem to
return nothing here it would be a
violation of the Monad laws and I'm
going to talk about that later but right
now I can only really give you a very
fuzzy idea of what return is supposed to
do and and that idea is that it's
supposed to put a value into a sort of
mutual contacts but in case of binder in
case of either you put it into the right
context I'm not going to talk about
either specifically in this talk but
just as an aside either is basically the
same as maybe as far as the Monat
instance is concerned because it is used
for basically the set at the same thing
it is also used for chaining a
computations which may produce errors
and the only difference is that with
either you can specify which error
has been produced and so you can
precisely locate the error if you so
desire
sir sir but from this folder to return
implementation is coupled to the
implementation of the point it is that's
what you mean exactly so if I change my
return or the other way around you may
have to change yeah at the end of the
total gives the moon applause and I'll
probably also explain why or how they
work out in the case of maybe so I'll
have to ask you to accept that all right
so I believe this should have been
nothing new so
some issue with the projector is you all
right so let us move on to lists lists
are also known as in a very different
way from how maybe but we can define a
law abiding or emphasis on lists and I'm
just going to skip the formalities and
proceed with the implementation talk
about why p2 does a bit late so for
lists our M in the signature of bind is
the list type constructor represented by
the most angle brackets and so if we
substitute that into the type signature
for bind we get list of a then a
function from a to a list of B and we
return a list of beats and let me
quickly give you the implementation
because it's really short let me call it
axis sense
the implementation is this done and what
this does is in case you're not familiar
with Concord map it basically just Maps
the function f from a to a list of feed
over the list of a's resulting in a list
of lists of bees and then it
concatenates those things in order to
get it concatenates all of those lists
together to get a single list of bees so
common cat map it's precisely
otherwise so that's the implementation
the intuition behind the list moment is
that it represents non-determinism
more precisely the full exploration of
non-determinism so to think of a list of
ace as a non-deterministic value that
you may assume any value included in the
list and then think of a function a list
of B as a non-deterministic function
that takes an argument of type a and
produces any of the values included in
the list that it produces and so the
idea behind the list Mona is now
chaining those computations together and
the way we change them together is
really quite natural for this kind of
problem domain we take the
non-deterministic function apply it to
every potential value of the
non-deterministic value and we get a
bunch of like more non-deterministic
value of type B for a list of
non-deterministic value for each input
from the list of s and then we
concatenate all those potential outputs
together and we get the list of outputs
that may be produced by applying the
non-deterministic function to the
non-deterministic value
now yes you follow this model to do this
I mean if you follow this model thought
you'd also me make sense that it should
also remove duplicates from utility
loosely it would very much so I believe
that would be a violation of the Mon
applause although I'm not 100% certain
on that it could be that you could do a
similar thing with sense but I'm not
certain on that we'd have to check
actually that would be quite the nice
exercise maybe I'm going to do that so
yeah indeed we may get duplicates so
it's sort of applicable in some
circumstances it's not a full-blown
implementation of like for example games
at research and so on and so forth you
can do basic tree searching like for
example if you've got a game tree that
is very conveniently modeled using the
Miss Mona but it does have a half its
limitations in the sense that as soon as
you want to do anything but use those
list functions it becomes a bit awkward
but for now let's proceed with the
implementation or this implementation is
to adjust the implementation of the
general idea that I've just given the
idea that we take each input apply the
function f collect all the results and
concatenate them as a list of potential
mouth words and now return is again a
bit tricky to explain in such an
informal way but in this domain probably
make sense to think of a value of type X
as a special case of a non-deterministic
value namely the non deterministic value
that can produce exactly one result and
therefore isn't very non-deterministic
at all and in our model this is
represented by the singleton list that
contains only X so let us
talk about one like little toy
application unfortunately I don't have
the time to go into any great details
about this but let's look at just one
small example so we want a list of int
and now what we can do is we can use a
non deterministic value that takes on
the values 1 2 5 and we can chain that
and wavefunction probably the simplest
function that we could chain it into
would be if we just returned the X but
kind of written very redundantly is the
way I'll take it later and what this is
going to do is recall that return X's
peopleand to just the single rule this X
I was going to walk all the inputs
replace every input by the signal list
that contains exactly that input and
concatenate the result together so this
is exactly equivalent to what we passed
all right that's actually going to
become important later because that is a
general property of return but I'll talk
about that in this section of our forums
another thing that we could do is we
could now use a properly non
deterministic function namely the
function that either produces the inputs
x 2 or the input x 3 and if we use that
we get a list of potential outputs and
you'll see that the first two outputs
belong to the one so they are 1 x 2 and
tutor and one kind of a respectively and
so on a slightly more interesting
example if we now take function
and we use a second non-deterministic
list the list
and we'd shave return a pair consisting
of well what's going to happen here is
the function first walks the first input
and science X every potential value and
for every potential value of x it
executes the rest and the rest is
walking every potential value of y ie 6
to 10 and then putting the X that we got
before and divided into a pair what this
does is it basically gives us all
combinations of potential X's and
potential Y's
we got 16.7 180 190 110 - six - seven -
eight - nine - ten and so on and if you
scale that example up it becomes
apparent why sometimes the list Mona can
actually reduce boilerplate by quite a
lot because if you've got now say five
lists that you want the combination of
or every potential combination of all of
the values out of those lists and you
can simply use the list Mona and write
the whole thing with relative ease
compared to what you would write in any
other language if you were to write the
community like the combination of five
lists manually and of course there's
also scales in the sense that you can
add or remove lists as well and the Mona
instance will take care of updating your
combinations accordingly so that is
essentially why the list is various
questions asked - that instance yes for
example
yeah that's an example it would be a
morning example if I'd say x2 10 but
yeah right I'm not going to talk about
applicatives in this book they are
basically a weaker version of monad that
has more instances and is better
optimizable in some cases so it's
relatively interesting actually
applicatives but I don't have the time
to talk about them here you should
definitely read about
all right on to something different them
state monitor our state's most of you
are weren't particularly familiar with
they are a bit tricky to get that but
the essential part is that we're going
to talk about state transformations and
I'm going to call anything that has this
form a function that takes a state and
produces an output and a new state I'm
going to call that a state
transformation this doesn't have very
much to do with the state monad
transformer that's a different concept
that I'm not going to talk about in this
talk and of course it's related because
we're talking about the state monad and
the state una transform it is related to
that but a state transformation is
hereby defined as a function with that
particular signature or the signature
applied to so we're going to make state
a monad and we're going to do that
because it would be quite useful to be
able to chain these kinds of state
transformations together and the way we
chain together is explicated I think
quite nicely in the signature of bind if
you instantiate it with the tied state s
and remove the boilerplate that's really
that results from this new time wrapper
so conceptually a state transformation
is just a function we wrap it into a new
type in order to be able to make it an
instance of monad without interfering
with anything else but conceptually it
helps to think of state transformations
as just functions
so in that case we get the following
type we get as a first input a state
transformation from an input state and
that produces an output and a new state
we get as a second input a function that
takes an input of type a and we're going
to get that from the first state
transformation of course it takes a
state and we're going to use the new
state that the first state
transformation has produced for us and
we produce a B and a new state and the
result will then be for the output of
type feed and the state after applying
these Tuesday transformations and it's
important to understand that we're
always talking about functions here so
we're talking really just about the
composition of functions or functions of
a particular kind in a particular way
that enables us to think of these state
transformations as the state
transformations that chain like we would
expect from state to computations if I
chain a stateful computation to the next
signal computation the ideas that of
course the second stateful computation
tastes the state from the first and
continues to work with it in whatever
way it sees fit
so let us implement that now I'm first
going to do a mock implementation that
assumes that this new type of business
up here doesn't exist and then I'll move
to the actual implementation because
it's a lot of unnecessary but annoying
wrapping it
of new type that just obscures the idea
so we have a state transformation and we
compose it with a function that includes
another statements and the result of our
composition is supposed to be a function
that takes an initial state of the
college State just
now what we then do is well we first
apply the first state transformation and
what we get from that is we can
deconstruct it into a air consisting of
an output of light 8 and the new state
and now we can apply the function f
because we have a value of a which is
quite handy in this case we can apply
the function to the value of type a and
the new state and what we get is a value
of B and yet another new state and
that's exactly what we wanted so that is
the implementation of this composition
business and now let me just silently do
all the wrapping and unwrapping business
you'll see that the whole thing gets a
lot more ugly but such is the way of
things
after this interstate and when we
actually have to pattern much here
new difference formation I can apply
that to the state okay I've changed
nothing of actual value all right now
return in this case is also relatively
straightforward actually if we want to
make an arbitrary state computation that
changes as little as possible about the
context well then we make a state
transformation that does nothing with
the state just ignores it
and passes it on to the next computation
so return in this sense is turning a
stateless stateless value into a
stateless computation that is well a
stateless computation in our framework
for stateful computations if you want to
put it that way that's probably not the
clearest sentence
so return is a stateful computation that
takes the state and returns the X that
we've asked into it and leaves the state
alone now let us define a bunch of
useful combinators on States because
they'll make working with this thing a
whole lot more convenient for instance
let us define get a stateful computation
in some state s that simply returns the
state that we currently have this is
relatively straightforward the state I'm
using s because s stands for the type of
the state and get is the action that
returns the current state so that's why
I'm choosing s of course you could
substitute for a or b or any other
variable name just like you to c2 is
so yeah the implementation will actually
make this super clear because we get the
pair consisting of state of the output
and state as the new state meaning that
this computation leads the state along
sort of dual to that not actually Huebel
at any mathematical sense but I love use
that word here
what is a computation that changes the
state to whatever well we add value we
provide and returns no output if we
might return the state as an output but
well there's really no point to it
honestly and put is defined like that in
the standard libraries so we'll use that
form so put call with the new state is a
stateful computation that takes a snake
but ignores it completely because we're
going to modify the state anyway then
returns no value of any use and updates
the state with the new State the last
common Combinator modified takes a state
modifying function and gives us again a
stateful computation that modifies the
state with the function we provided and
otherwise does nothing so it's a patient
affects the state returns nothing
meaningful and applies effortlessly and
these are really all the Combinator's
you need in order to work with stateful
computations and let me give you a quick
example one area where a Haskell is
really inconvenient in comparison to
impure languages is rendered numbers
because in an impure language you've
basically got your global state you've
got your random number generator object
and you can query them at any time if
it's fan sake also from is that and you
get a new random number and you can
retire that number will be a unique up
to whatever your pseudo-random number
generator actually does inside it so in
Pascal you can't really do that because
you can't mutable state and so you have
to do is you have to pass the random
number generator around all the time you
pass it to a function the function
retrieves the next random number updates
the generator in the process and you get
back the new generator which you then
have to use for all your father
computations because if you use the old
generator it's a pure value it's going
to produce the exact same in a stream of
random numbers that it would have
produced before which is not being very
random so this is one area we're working
with huh Scoob without the state monad
is actually a pain but now with the
state monad we can do stuff like that if
for example we want a function that gets
us a random element out of a list
and we define that function as taking a
random number generator and producing an
output of type A or rather an output of
time ABA if the index produced by the
dreaded number generator happens to be
in balance for that particular list and
I'm not going to implement that right
now it's not particularly hard but it's
not particularly useful either rather
I'm going to demonstrate that you can
then compose these functions really
relatively effortlessly for example you
can write
tests say we get a random element from a
list of hints
work with placements better not work
with infinite lists we get a random
number from from a from an input list
and then we can for example use that to
get a mental number from the input lists
of 1 up to the number we just drew
or for example using some more monad
Combinator's that are not going to
discuss in detail but I recommend that
you check out control dot monad the
module authority lots of useful
combinations in there if you haven't
seen already using those we could for
example make a list of lists we get the
list 1 2 5
emptiness and though we can just map
random element over that list and it
will give us back the list of random
elements that were drawn from this input
from each of these lists and that is an
example for the magic of moments because
note how we didn't have to pass around
the state namely the random number
generator by hand this Combinator
basically does everything for us because
it executes for each of these lists the
relative random element action and by
virtue of monadic composition it takes
the state that was updated by that
computation the next random number
generator passes it on to the next
computation produces the next result and
so on and so forth until the list is
processed and that is how you can
compose stateful actions and thereby
save yourself a lot of very tedious one
so one piece is still missing from the
puzzle of simple computations and that
is how do you actually get something out
of a stateful computation because recall
that we are always talking about
functions from a state to another state
and well in the end we want to have the
actual results rather than just a nice
function and the idea behind that is
very simple really we just provide an
initial state then run our stateful
computation and return the result
digital state then we can unwrap the new
type constructor apply the est to the
initial State and take the first
component because in this case we're not
interested in the final state if you're
interested in the final state there are
other combinators that can be used to
get that so this is how you deal with
stateful computations and the last mode
an instant that I'm going to talk about
very very briefly is i/o because I
always actually the simplest on lorna's
and that may become a sort of surprised
because monad is deeply magical as well
it's basically built into Haskell it's
abstract meaning you can't see the
definition unless you look into the THC
source code and so on and so forth but
the semantics of mode of i/o are
incredibly simple the semantics are
firstly if you change two computations
together for example say you put string
Ln hello and you chain that into string
by the way this is a variant of the bind
operator that just ignores the results
produced by the first action if you
change those two computations together
you are guaranteed that firstly both
actions are actually executed that is
not the case for any moment for example
if I chain put five in to put six and
sufficiently smart from ila could easily
could determine that the first
computation is completely useless
because it doesn't change the state it
doesn't produce a result that is used
anywhere else so it could be eliminated
without any problems in i/o
you don't have that every actually gets
executed and the second thing is that
every action gets executed precisely in
the order that you specify them so here
the string hello is put before the
string Zoe Hart which is very useful for
i/o because we're dealing with side
effects and those should usually be
ordered of course exceptions exist for
example the port IO thingies that
specify the computations are to be
performed in parallel and so on so forth
but the general idea of the IO monad is
that actions are a stick executed
sequentially and those are really the
two properties that define the mouna
implementation ohayo
nothing more nothing less it will be
honest I don't have much else to say
about it at this point you should be
able to use the usual monad combinators
and the combinators form control the
unit to do basically whatever you want
with IO computations
so those are all the Moana instances
that I wanted to discuss and now let's
talk about those these are the monarch
laws they are very very simple if you've
seen a mana wait before which you
probably owe it's very similar that what
a boner it does and in fact when people
talk about how units are mana weights in
the category of endo factors I believe
the technical term is than they mean
well exactly this we've got an identity
element it's return and we've got
associativity because the fish operator
wisely composition associates
those are the Monad laws and well
there's really not too much else to say
about them unfortunately they are
incredibly simple and they allow you to
do some very basic refactoring that
you're probably taking for granted
anyway
for example the associativity
essentially specifies that the
composition of these things doesn't
depend on in which order these things
are composed which is really what you
expect from any composition like
operator if that were the case it will
be highly impractical what's a bit more
interesting is the identity property and
this is what I was going on about all
the time with it and with return here
you've got your definition of what
return can and cannot do namely it must
act as an identity for monadic
composition and in the case of maybe if
return were to return just simply
nothing all the time then this
composition property would not all
because well if we throw nothing into
any computation by the definition of the
bind operator that is also used to
define the fish operator it'll just
return nothing regardless of what the
computation would like to do and if that
were the case for them we always get
nothing here on the right hand side
which would be in violation of the Monad
laws and similar arguments applied to Y
we define return the way we define it in
state and list and IO and what happened
so those are the Monad laws and I'd like
to make one more broader point the
simplicity of these Monad laws combined
with the rather diverse nature of the
monists that we've seen in this talk
non-determinism ever held the stateful
computations effectual computations that
change something about the computer
these are all vastly different things
and what I'd like to encourage you to do
is stop trying if you have been trying
to get a unified semantic interpretation
of what monads are and what monads can
do monads can do incredibly diverse
things and there is really no point in
time where you can say ok now I
understand what a monad is so if you say
my type is an instance of Moana I'll be
able to write down the instance for you
no problem that simply doesn't happen
because every instance of the Moana type
class does relatively unique things that
have very little to do with each other
and the only really the only element
that come that unifies these different
instances are those we lost but those
three laws they don't tell you
very much at all only because something
is a an instance of the Mona type you
can't say very much about what that
instance is going to do and so that is
really no substitute to learning every
monad instance in isolation like we have
been doing over the course of this talk
there are a lot of different other Mona
instances that are very interesting the
standard library has monads for
aesthetic environment for example in
that it has monads for control flow the
continuation Mona
it has monads for parsing in other
libraries it has monads for stageful IO
in a way for streaming I know that's
what i meant natsu streaming io all of
these things is listen are more nuts for
behave radically differently and there
is really no substitute to learn in each
of these instances so one quick thing
it's fine we have 50 more minutes to the
next book so you can continue okay so
let me do that extremely quickly as most
of you are probably aware do notation is
a syntactic sugar and these are
essentially the transformation rules
that apply and you can picture do
notation as a like recursive application
of each of these transformation rules
based on what the first statement of a
two blockers and if the first statement
is the assignment of a variable to the
result of an action then it means
execute the action find its result to
the values of X using the vine operator
and continue with whatever the other
statements if your first action
is an action whose result is not bound
to any value
now you just execute the action ignore
its result that's what the double white
arrow operator does and continue with
the other statements of the to block if
the do block consists of a single action
that's the termination case of the
recursion then just return whatever that
actually does and then you can use some
more like convenience in fact that sugar
into notation you can use legs the only
caveat is that you don't write in here
because reasons and that is simply a
pure binding of well apply to the
variable X and you continue with the
rest of your statements you can do case
analysis and this basically just chooses
one action that you're going to execute
next then it executes that action and
continues with the recipes and pretty
much the same thing applies for if you
choose the next action then we continue
with whatever else so that is the
rotation the sugaring is really simple
and the intuition is also comparatively
simple like executing an action finding
its results with a variable probably not
the most complex thing ever invented by
man although it can be is sometimes a
bit intimidating for beginners because
you have to watch out which of these are
more netic values the actions are always
phonetic and the do block is always a
something in a moaner
so in action of type ma where m stats
but the X the result that you get out of
an action is pure it's not a phonetic
thing so that can be a bit hard to work
with for starters the concepts behind it
are really not that hard so that is the
extent of my talk that's what I wanted
to see if you've got any more questions
of this ask if you've got a question
that we'll build the next 50 minutes
feel free to talk to me in private of
them otherwise I wish you happy hacking
do you have some questions
question yes but some people dirty that
yeah I haven't read that wiki page in a
while I think the argument is basically
that do notation well is it's designed
to look a bit imperative in nature and
that sometimes tricks beginners to think
that it does things that it really
doesn't and it kind of encourages you to
think in an infinitive mindset and
forget that do notation is really just
syntactic sugar for purely functional
computations and in fact most of the
monarchs that we've looked about it
actually all of them except IO our pure
referentially transparent everything
that you love about Haskell
even the state monad and I think that is
the basic criticism of do rotations I
find well I find do rotation very
convenient as a matter of fact and as
soon as you grasp the concept it becomes
very much second nature and much easier
to read in my opinion than just um using
the operators directly it can be done
it's not terrible
using the operators directly but I find
it harder to read and I find the
trade-off to be worth it the trade of
being you have to teach beginners this
new notation that may confuse you
yeah
well justice by the way one more thing
return really has nothing at all to do
with impunity return statements like not
a thing it's the biggest misnomer in all
of their often prepared to use a few
captive because they it's usually set
for the wanna transform our teens when a
transform stuff transformers are a
different story and specifically the MTL
variant of describing yeah
but can they do that in general with
negatives yes you can take any two of
liquid types combine them automatically
okay I knew knowledge was gained I don't
know maybe it's related to this younger
sense and I mean one of the way I see it
is that I extract the results from a
limitation the next one what I would
like to do is extracting values from
different competition from let's see
from different moment is it this is this
possible in the view notation because I
was doing something similar in Scala and
I got Provence
let's say I don't know I extract money
from at least then from maybe and I want
to combine them the produce that
debilitation extracts for from moneth
and then push it back to amana right
okay the problem that I see is that in
the case it is possible in which one of
the ending results will be pushed and if
it is not possible wise we ensure that I
know what you mean
you want to write something of the form
X from function 1/2 and those are
different formats yeah no that doesn't
work they do notation and the reason it
doesn't work is the year actually it's
the sugar ring or two notation if you
apply that to this block then you get
function one define the result
let's do the dish you're getting again
why and find the result and then we
actually don't do anything you spoke
with its owners but the thing is this
the sugar ring basically already tells
you that what you want to do is
impossible memory because function one
should be composed by the definition of
the bind operator with a computation
that returns a result in the same
movement in the case of function Wunder
boner would be maybe
however function 2 is a computation in a
different mo not let me either string
and so these two things cannot propose
what you can do of course is you can't
do let's say I have a list of it and I
ever made me of it right I want to
multiply the content of maybe to each
element of the list so they are
different more but from you know it
should be something doable if the maybe
these are just I should be able to do
this and then get out the results
Alistair we don't know the solution to
that is you have to transform the 192
the other way you do that is get your ex
let's say you apply a function maybe to
list
and say we have a
maybe much better okay now maybe to list
turns your value into a list and then of
course you can but there is no general
approach because this is very specific I
think for this specific case you don't
actually need monitor at all you can use
applicative position to do that
there's no general but not for moments
monitors are too powerful powerful one
of them do too diverse thing there is no
way to kind of define the rules the
consistent manner how they different
monitors can compose and since of liquid
lips are much more restricted you cannot
so much you can do like average to drop
the graphs of computations like an
applicative is that most Derek directed
by exit across that's kind of the
semantic difference between them and the
applicatives seems they are more
restricted you actually can reduce more
about what they do
hence you can cut a standard way to hold
that monitor just too powerful and there
is no no way that finds them
yes
so there's a distance functor which
allows you to sort of do what you do
where there's instance approvals made
she got us there I think functor is not
powerful enough that
applicative is powerful of modern
factories not poor enough and mana is
tomorrow so the melodic main way to
solve that problem
this you just basically convert the one
thing or acquired both things into the
same or not and then used in rotation as
you would usually indeed this is also a
case where
you have to define one fine doctor later
it says yes if you find like if you make
a type and make a lawful opponent
instance of that type that kind of
composes your pages of lists I don't
know if that's possible in general but
if it is possible that yes of course it
restricts it to either the instructor I
see we should be finished right now okay
if any more questions arise please do
come see me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>