<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Flutter's Rendering Pipeline | Coder Coacher - Coaching Coders</title><meta content="Flutter's Rendering Pipeline - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Flutter's Rendering Pipeline</b></h2><h5 class="post__date">2016-05-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UUfXWzp0-DU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Adam Barth I'm the TL for
flutter partner working on flutter I
worked on calm for about seven years
mostly on a Chrome's minor II engine
started out as WebKit actually became
blink and then working on flutter for
about two years and this talk is going
to be about the rendering pipeline in
Flour so just to sort of orient
ourselves that's this is sort of a
sketch of the overall architecture of
flutter so at the bottom there's an
engine and engine is exposes a very
low-level API and if you saw Ian's talk
he talks a bit more about all these
different layers and how they relate but
so the engine is very smart about text
and also knows how to take vector
graphics and draw them onto the screen
above that there's the framework which
is what this talk is going to talk more
about which is itself composed of
several layers this talk is one of the
about one of the lower levels in the
framework called the rendering layer
which is responsible for organizing the
screen so allocating space on the screen
for various different widgets and then
actually making those widgets up here on
screen and then above the framework is
where you write your application so the
full pipeline but in flutter has a lot
of steps in it and so first you get some
user input like the user touches the
screen then maybe you have some
animations running so they start to
start ticking and then you get a chance
to build widgets so you get to build
whatever you want to have on your
screens you have a one of a button or a
drawer that sort of thing and so Ian
went into detail about how that build
phase works how it is it you end up
building things in constructing wintery
objects and then after that you go to
the rendering phase of the pipeline
which consists itself of three steps so
first is the layout step which is about
positioning and sizing elements on the
screen then there's the painting step
which is about figuring out what those
elements actually look like and the
compositing step basically stacks them
together and draw order so that they can
be composed on the screen is one one
thing and then finally the last if there
is rasterization we actually go from
from that abstract representation of
what you're going to draw up to the
actual physical pixels that are going to
appear on screen so this talk
is going to focus on layout painting and
compositing so the sort of thesis or the
like design principle behind the
rendering part of the pipeline is that
simple as fast so basically if we use
simple straightforward algorithms with
very well understood properties then we
can make them go fast by taking
advantage of those properties and
optimizing them so for example both
layout and painting use of one pass
linear time algorithm so we walk the
tree from top to bottom and then we
return up the recursive structure and
that's it so that's in contrast to other
systems for example where they'll do
multi pass layout where they'll go to a
point in the tree they'll walk down to
gather some information and then walk
down again to adjust the sizes of things
if you imagine nothing that you can see
very quickly how that becomes N squared
work because you keep recursively
walking down the tree and back up and so
in this system we want to have a one
pass play out that just walk the tree
once touch every node once in the way
down once in the way up and then can
figure out how big and where everything
should be with that the other sort of
along the same lines and we use a very
simple constraint model to do layout so
for example in UI kit they have this
complicated linear constraint model and
a whole general purpose constraint
software to figure out where to position
things and that's you know that has some
benefits but we thought what if we could
do something much simpler so our
constraint model is basically a box with
a min width and a min height and a max
width in a max height and that
constraint domain is very easy to solve
right if I give you two of those
constraints and ask you to unify them
pretty obvious how to unify them and so
you can write a very simple constraint
solver and the question is you know our
thesis is that's enough to generate very
expressive layouts and finally we do all
of our repainting structurally so
instead of tracking which like
rectangles on the screen or invalid it
need to be repainted we do it
structurally in the same structure that
the overall tree has so we can say this
subtree it needs to be repainted as
opposed to keeping track of which
rectangles on the screen and that turns
out to be a very big performance win it
takes advantage of some of the hardware
capabilities in in modern like mobile
devices they very good at compositing
things
okay so the first phase I want talk
about is layout
how does layout work so the base class
that everything that participates in
layout and painting uses is called
render object so render object itself is
pretty abstract concept basically as an
owner which is the object that's going
to drive the pipeline and each owner of
it knows what it's parent is but in
general render of it doesn't know
anything about its children all it knows
how to do is visit its children which
means different render objects are free
to have different child models so for
example you can render object that has a
single unique child or render object has
a list of children or render objects
that has a several named children and
from the perspective of all the rest of
the algorithms we don't care what the
child model is it's totally up to the
render object but it does know how to
layout and paint the sort of abstract
rays and importantly there's this
concept called parent data which is a
slot on a render object that the parent
render object can store data so if
you're familiar with other systems like
the web you aren't allowed to put like
an inline inside of a block for example
because block needs to store information
on its children that inline doesn't have
slots to store and so you get these
anonymous render objects in your render
tree on the web to basically convert the
data structures and so we avoid that
just by having this parent data slot
that's managed by the parent it's set it
by the channel and that'll become
important when we talk about positioning
so importantly about render object
there's no concept of any coordinate
systems or anything like that it just
knows that it exists in a tree and has a
parent and it defines this data flow
that I talked about so this is the one
pass data flow so we walk the tree in a
depth-first traversal and we pass down
the recursive walk constraints so from
render objects point of view with their
arbitrary constraints in practice most
people use I think called a render box
so those boxes will be this box
constraint that I talked about and then
up from the bottom of the tree comes the
size so I say here are the constraints
on how big you are supposed to be and
you say thank you for those constraints
I'm going to go talk to my children for
a little while and when I'm done I'm
going to go respond and say oh I figured
out I want it to be exactly this size
next and so far yes I'm seeing lots of
people knotting so that's sort of
abstract but more concretely it turns
out that a very useful coordinate system
to work in is Cartesian coordinates so
you know x and y and width and height so
there's a specialization of render
object called render box that is much
more opinionated about how things are
sized in position in particular it has a
size which is a width and a height as
opposed to a render object to be an
arbitrary thing like a you know sector
on a on a circle or something it also
adds some intrinsic sizing information
which is comes up in some esoteric cases
so box has the
that we're going to use a particular
kind of constraints these box
constraints that I've mentioned so box
constraint is basically what's depicted
on the slide so there's in the width
dimension there's a min and a max and
the height dimension there's a men in
the max and the rule is if the parent
gives you these constraints you have to
be somewhere in this light grey region
you aren't allowed to be too small and
you aren't allowed to be too big and
what's interesting about this is you can
actually express a lot of different
layout algorithms using this simple box
constraints so for example the simplest
kind of layout algorithm is basically
where the parent determines the child
the size of the child so if you imagine
you only have downward information so
each parent was like okay you're going
to be exactly 100 pixels by 200 pixels
and the child was like okay first child
you're going to be 50 by 50 and you're
going to be 50 by 100 so this is
commonly used for example in window
managers in operating systems the window
in a in a desktop operating system has
no opinion about how big it's going to
be the window manager says you're going
to be exactly this big and you can
actually model that with box constraints
what you do is you make the constraints
tight so you set the min and the max
width to the same value and the min of
the max height for the same value so the
child is basically dictated you have to
be exactly this big because that's the
only value that satisfies the
constraints so what this implies is that
any object in the system has to be
prepared for its parent to dictate
exactly how big it is so for example the
check box widget normally you think a
check bucket it has a fixed size it can
only be exactly this size but turns out
in this system since the parent can
force it to be an arbitrary size it has
to think about that and understand what
it would it mean for me to be twice as
big as I expected and so the check box
does something simple like heat is like
centers there's little checkbox in that
available space but is able to occupy
our material space so another layout
paradigm is called width in height out
so this is for example what the web uses
this is a very useful paradigm for text
so basically you say I want you to be
exactly 200 pixels wide how tall would
you like to be right so if you could
imagine you have a bunch of text and you
set the width you start flowing the text
make different line breaks and then you
see how many lines you got and that's
how much height you have and so that
actually arises carnassial
in this model where you to set the width
to constraint to be tight and you set
the height constraint to be loose and
then the parent is essentially
specifying the width and the child gets
to report the height that he wants to be
what's interesting is actually because
this model treats width and height and
visit X&amp;amp;Y symmetrically you get the
opposite you get height in without also
arises naturally and you could ask
yourself like why what I care about this
what is this why does this make sense
and I you know the longer I work in this
project the more I realize that whenever
you have a like horizontal use case
there's always a vertical use case that
arises for the same thing and so later
in the talk we'll actually seen this
actually arise naturally from something
so I promise you I was going to tell you
about parent data so what's interesting
if you notice about a render box here
he knows his size but he doesn't know
his position so this is in contrast to
other systems like cocoa or each UI view
in cocoa knows it's wrecked right a
wreck combines both size and position so
here you know your own size but you
don't know your position your position
is here controlled by your parent in
your opaque parent data field that you
hold so what that means is when the
parent gets the sizes for all those
children is then free to reposition them
without talking to them again so without
touching them you can move them around
and that turns out to be quite powerful
for things like scrolling where you want
to scroll a widget and move it around
without touching it right you just want
to the minimal amount of work to
translate things around so
walk through an example of how layout
works I was going to do flex layout so
flex layout it's a very very common
layout paradigm so the idea behind flex
layout is you're either going to lay
things out in like a row or a column and
here we're going to do Rio for
simplicity and some of your children
have a strong opinion about how big
they're going to be so they have some
sort of preferred or intrinsic size that
they want to be and the other children
are flexible basically they're going to
expand to fill however much space is
left and and actually there's a little
detail about this which they have
different flex factors if you think it
was like Springs they have Springs with
different strengths so in this case this
yellow guy he's got a flex factor true
too which means he's he explains to
expand twice as much as the pink guy
who's only got a flex factor of 1 so
these you can if you like you can think
of the green and red guys as little like
wood blocks and the yellow and pink guys
as Springs with different spring
constants ok so this is a very common
layout program and I'll show you how
this works in this this sort of one pass
box constraints approach to layout so
the inputs of the the algorithm are the
overall min and max with the min and Max
height that constraints we got from our
parent and the outputs are we got to
figure out our overall size to tell our
parent and we have to figure out the
size and position of each of our
children so in this scenario for
simplicity I've set the min width and
height to basically zero so we have
flexibility and this gray box represents
the min and Max height that were allowed
to be and then I'm showing you the
answer but we're going to build up the
answer in steps so
we have to lay out our inflexible
children so the wood blocks in this
block and spring model we have to ask
them how big would you like to be since
they're allowed to have an opinion about
how big they like to be so what
constraint should we give them so well
for there we're doing a row so for their
height it's pretty easy they could
either be 0 height or they can be as
high as I'm allowed to be if they're
taller than I'm allowed to be that I'm
in trouble because I can't fit them
inside of myself so that's sort of
natural and then the width well they're
allowed to be as small as they want to
be that's up to them and then actually
we let them be as wide as they want to
be all the way up to infinity and why
infinity the forest has a puzzled look
on his face and that's a you know very
good question and so actually in the
first version of the system we didn't
have an infinity here we gave it the max
width the incoming max width so our own
max width but oh that's natural but it
turns out that that causes a lot of sort
of subtle problems so if you imagine a
child who doesn't really know how big he
wants to be he's looking for some
guidance from you if you give him a max
width maybe like sounds great I love
that max width I'll be exactly that wide
and what if you have two of those guys
now you're out of space right so you
can't really fit them and turns out that
any value you pick here is either going
to be too small meaning if they all pick
that sighs you wouldn't fill up or be
too big so if they all pick that size
they'd be too you know overflow so it's
actually no good value to give here so
we don't give zero because then they
would all have to be zero width so we
give them infinity which says I have no
opinion you have to tell me how big you
are so okay so we do
they come back and the green guy says I
want to be this big and the red guy says
I want to be that big great so we write
down that information we add up they're
there with and we say well how big
should we be so rows have the opinion
they're just going to fill up all the
space because that's usually what you
want so they fill up all the space and
they want to say how much space is left
after we've allocated space for all
these inflexible children I just take my
overall width then I subtract out the
sum of my child's with right and so I
have a bunch of free space left but I'm
going to allocate to these flexible
children so I just take the free space
and I divide it by the sum of those Flex
factors and that tells me how much space
is I'm going to allocate for each unit
of Flex factor so a child that has two
units of Flex factor will get twice that
amount of space and child is one years
of Flex factor get one right so when I
lay out the flexible children I give
them these sorts of constraints so
they're with I tell them exactly how
wide to be I say you're going to be
exactly enough size that you fill up all
my free space they'll have left my
layout and the height well it's up to
you you can be as you know short as you
want or you can fill up all my max
height all over my max height whatever
whatever you like so they come back and
they say oh okay I I agree you tell me
exactly how wide to be I'm exactly that
wide and here's how much height I need
for that with so they follow the sort of
width in hideout model if you will so
that's great so now I've got sizes for
all of my children and to figure out how
to position them well the positioning
algorithms pretty simple I just go
through an order and I position the
first one first base and increment by
its width and the next one looks like
next one and because the constraints of
all I've given them constraints such
that when this adds up it adds up to
exactly the width that I was expecting
and that's how big I am and so for the
height there are many choices for how to
position people so there's a so for
flexor row there's a choice I want to
align them all to the top or the bottom
of the center or whatever you like
so here of center line them right so I
have all their Heights so my height is
the max of all their Heights and then
for each one I know exactly how much to
offset it because I know its height but
notice here I couldn't figure out their
position until I knew all the sizes of
all the children and then once I knew
all the size of all the children I could
position them without touching this
right so they in no way could they could
their size depend on their position
right because they don't even know what
their position is is in contrast other
systems like the web where on the web
the size of an object depends on its
position on the screen yep and then I
I'm done I've laid out my flex just the
way I said I would do it yes you could
align to the top or the bottom so then
instead of centering them vertically I
would just give them all zeroes is there
as their x-coordinate yes this is a
fascinating question so it turns out
that just because you're given oh sorry
the question is what happens if the
inflexible children is too big I tell
them they could be infinitely big and
they all decided to be huge I know no
space for them what should I do yeah so
it's fascinating so the what the box
constraints really say is here's how
much space you're allowed to occupy
during layout so that doesn't say how
big your children need to be so for
example if your children are bigger that
just means that they send off the side
right so I could either paint them out
there I don't have to paint within my
bounds or what actually what we do is we
clip them we say okay you're too big I'm
going to only draw the parties that are
actually visible so they act occupy that
much space but they there's you can't
see them because they're they're clipped
away yeah so he says if the green guy's
too big you just won't see the pink guy
or the right guy that's that's accurate
so in this layout we do we have fancier
layouts that are smart and do things
like that that avoid unnecessary layout
and building but flex is sort of at
least that's presented here is pretty
simple so yes actually there's a debug
mode you can turn on that will draw a
little red box whenever you overflow
your flexes so see you because you know
you might not want that so you might
want to be told about that
oh so I told you that so notice that we
have this width in hideout property for
the flexible children right
we told them exactly how wide they were
going to be and then we asked them how
tall they were going to be so if you
imagine just rotating this thing to be a
column right totally reasonable have a
flexible layout that's vertical right so
now the flexible children a vertical
layout you tell them their height and
they tell you their width so turns out
we needed height in without even though
when we first saw that it seemed like a
weird thing but it actually rises quite
naturally just in in vertical flex
layouts and turns out this constraint
based you know simple algorithm is
sufficient to generate you know a lot of
different layouts in fact we have a you
know complete implementation of material
design and all of its you know visual
layout properties just done with this
this acronym it's kind of remarkable
sorry when we first are to the cottage
has a little skeptical that is like
simple constraints would be enough and
that's why we one of the reasons why we
have render object is this very general
purpose thing we thought oh we might
need to specialize it to do some other
kind of complicated thing but it turns
out no you can actually do everything
you want just with the simple Agra so
what's neat about the algorithm being
simple is now we can reason about it and
exploit its properties to make things go
fast so as an example you notice at some
point I might give a child a tight
constraint right which means the child
has to be exactly a certain size and
what that nicely does is if it provides
a cut in the data flow of the layout
algorithm right anything that so if you
imagine that this edge here that's
labeled as a tight constraint says the
child has to be exactly a certain size
then whatever happens down in that
subtree with respect to layout can't
possibly affect the rest of the tree
right because there's only communication
with the rest of the tree is his size
that he reported back up the algorithm
but since the size has to be exactly the
one that matches the constraint there's
no choice for his size so whatever crazy
layout thing is happening there that
information can't propagate to the rest
of the treaty this creates what we call
a relay out boundary and we compute
these implicitly just from watching the
algorithm the constraint solver executes
and so basically
if somebody in this sub-tree wants to
change his size or position that change
is contained in the subtree so when we
produce that next frame we only need to
consult this subtree we don't need to
touch the rest of the entire tree and so
that makes things much much more
efficient so I said it was a linear
algorithm actually because of these
properties is actually sublinear because
you don't even touch the parts of the
tree that are I said that are isolated
from the parts that undergo layout and
actually several different cases so
tight constraints are one one case
another case that we recognize is when a
child when a parent asks a child to lay
out he supplies a flag that says whether
he's going to use the child size in the
rest of his competition and if he says
no that also creates a relay out
boundary because then if the child
changed his size it doesn't affect
anything else because the parent didn't
listen to the size it was irrelevant for
the parents point of view and that
actually comes up in another in other
cases where a child can report that his
size depends only on his incoming
constraints so it's not it's that he
says for example a child that always
expands to fill its constraints his size
by his parent whenever his parent told
him is his constraints he immediately
knows what his sizes what his children
do don't matter and it also creates a
relay out boundary and just from these
three simple observations about the
constraints offered actually the
incremental layouts and system turn out
to be really quite small just as you
should have naturally write widgets and
naturally build up applications so I
wanted to touch on one more point before
moving on to painting so you notice what
order did we visit the children in our
layout
well first we visited the inflexible
children and then we visited the
flexible children so our first first
visited the the green guy then the red
guy and then I came back and I did the
yellow guy and the pink guy right so
that's in contrast to the order in which
I'm going to paint my children so I
paint my children in order from left to
right in the order they exist in the
tree but in layout I visited them in a
different order so this is motivation
for why you want painting to be a
separate tree walk from layout because
you're going to visit the children a
different order
that's in contrast to other systems that
unify the layout and painting algorithms
into one walk of the tree and I've been
having to do these careful shenanigans
to deal with the fact that the paint
order is not always the same as the
information flow order for the layout so
here we do them in separate walks and
that just each one is one linear walk up
the whole tree from top to bottom
conception and that matters if they're
going to be overlapping or yeah so for
example in this layout that they're all
next to each other but another layout
besides the Flex is a stack so the stack
is just puts them all on top of each
other and so it really matters what
order you paint them in and they're also
so a stack has positioned in non
position children similarly has to visit
them in a sort of funny walker going
layout and non on visual order okay
painting phase so we figured out where
everything is and how big it is we
haven't figured out what it looks like
which is sort of you know only half the
battle
this tij would say so how do we paint
well you'd say well paints really easy
you just walk the whole tree in depth
first order and you pass around your
offset so where you are on the screen
and then you tell each thing to just
paint itself there because we already
know where it is and how big it is
there's not that much choice it just has
to draw right it's a bowl one slide not
quite so the complication with painting
is that you have to deal with layers so
if you were painting everything to one
buffer then that would be the end of the
story but it turns out that painting
things the one buffer is very
constraining so for example suppose you
had a suppose this yellow thing in here
was a video so something that's going to
be drawn by some other part of the
system that you don't interact with
there's some like hardware video codec
that's just going to like write video
textures and then you're going to draw
them and you want to draw some things
behind the video and some things on top
of the video that means you have to
divide up your drawing into two
different pieces the part that's below
the video and the part that's above so
later when you composite in the video it
everything looks correct so for example
so you can draw like a play button on
top of the Pythia
so the tricky thing in painting is
basically figuring out in which layer
the painting command should go okay so
conceptually you can think of these
layers as like buffers of pixels we
don't actually make pixels out of them
we just keep them as vectors but don't
worry about that too much so during the
paint phase we go walk the tree in depth
order and then we paint into these
layers so here the green bubbles are
painting into the green layer right
number four here he's a video or like a
child view or some something that needs
to be composited in order to paint
correctly so he gets painted in his own
buyer and then everything that comes
after number four in paint order gets
drawn into the red layer so the
interesting thing to observe is that the
on the second row on the Left he's got
some green and some red aspects to him
so what that meant is you should imagine
that I painted one I painted the
background for two and then two and
three and four and on the way up he
decided he wanted to paint some more
things so then the fifth painting
happened so this when he paints after
his children his painting commands go
into a different place a different layer
that when he painted before his children
so they end up in the red layer and then
we go up to to the top the top has no
more painting to do he goes down to his
child and his child also ends up after
the yellow in paint order so there's
this funny thing where a given render
object isn't allocated to a unique layer
his painting can actually be split
across multiple layers this is in
contrast to basically I'm not aware of
any other system that does is so for
example in Cocoa there's a one-to-one
correspondence between UI views and CA
layers you can't split a UI view into
multiple CA layers similarly on the web
you you can't split a single render
object into multiple layers it's
painting does it work they're all these
funny bugs because of that but in the
system we basically do that so the way
we do it is we it's not just offsets
that we're sending down the tree there's
actually stuff that comes back up in our
one pass walk in particular
the target layer so which layer you
often draw into something your children
tell you that's part of painting so you
tell the child you know go paint
yourself over here and he tells you hey
are you should continue painting in this
other layer so if you were like
programming language person you to think
of this is like continuation passing so
if he passes the continuation of where
you should continue painting and in that
way the the combination of the
compositing strategy so which things are
painted in too much layer and the actual
recording of the picking commands is
unified into one walk that's done in a
sort of simple one pass down up
algorithm so that's nice but now you see
there are always funny non-local effects
right the fact that this yellow guy had
to be composited hadn't had an impact on
this red guy and some totally other part
of the tree some like so that would make
painting very complicated right because
any effect in one part of the tree could
have an effect on some other radically
different part of the tree and so if
this guy said oh I want to change my
painting in principle you have to
repaint everything in the whole universe
to make that change happen and so well
we had this clever idea from layout that
we should introduce these we layout
boundaries what if we did something
similar for painting and artificially
introduced repaint batteries so what a
repaint boundary does is basically say
I'm going to artificially pretend that
this child needs its own composited
layer and what that means is it produces
sort of that the effects in that sub
trigger then contained they don't affect
other parts of the tree so now this blue
guy has to be painted into the blue
layer regardless of whether this yellow
guy exists or needs his own layer or
anything crazy like that
the real AI boundary basically is
stabilized the the algorithm so that
it's the non-local effects are contained
in that sub tree I'm going a little
skeptic
look so maybe I I have another quality
yeah yeah so that's a good question so
he asked with a really lay up boundaries
you computed automatically for you by
looking at the data flow but these
repaint boundaries I didn't tell you how
we could do to them automatically and
you might be suspicious that that means
that we don't know how to compute them
automatically and the end that's
actually true so we can place these
repaint boundaries anywhere in the tree
there's a very flexible concept but we
don't know where is the optimal place to
paint them so if you imagine if you put
every different render object in their
own repaint boundary they all use
composite layers unit for the really big
stack of composited layers and that
might be inefficient because now you
have to manage all these layers or if
you texturize them so you turn them in
actual pixels on the GPU then you have a
lot of pixels many more pixels than you
had on the screen on the other hand you
don't want to have 0 so basically you
don't have everyone coupled into one
painting pass so the optimal repaint
boundaries for your app is somewhere
between everything and nothing and we're
in a draw that boundary is actually as a
large effect on performance of the app
and it's something that's difficult to
compute automatically so it's you should
think about the structure of your app
and say when this part of my app
repaints what parts of the app always
repaint with it or are there parts of
the app that are repainting it for
different reasons so a good example that
is like a scrolling component of your
app when this thing Scrolls suppose you
have a scroller on the left and like a
smiley face on the right when the
scroller Scrolls the smiley face doesn't
need to repaint right so somewhere
between the scroller and the smiley face
you should have a repaint boundary to
contain the effects of its painting so
this diagram is is intended to show how
the repaint boundary changes the
structure of the compositing layer tree
so the left was our original layer tree
we had the green layer this the yellow
layer and the red layer so they're
painting here in a pre-order traversal
and on the right we have what the tree
looks like after you've introduced the
rename factory so you get this sort of
dark
ooh or black layer that is an artificial
layer that we introduced to contain the
effects and now the we have this extra
blue layer to paint after the black
layer doesn't the election like I don't
have to think about Miami scrollable
that I yeah so the question is do you
really have to add all these repaint
boundaries manually that sounds like a
big pain and the answer is no that a lot
of the basic widgets that we provide you
know where you should put repaint
batteries so like the scrolling which it
has a repaint boundary in there because
that's a common case and it's when
you're sort of building more complicated
things that or you're building your own
scholar or your own scroll like
interaction or something that you might
have to think about where to put in the
radiant boundaries okay so that was
painting so to generate all these layers
what do we do with them why do we even
have them so one benefit you have for
breaking your scene up into these
composited layers is you can update your
visual appearance very fast so if all
you're doing is moving around these
layers or changing their offsets or
transforms then you don't have to do any
of the rest of the work that we've
talked to at this point because you have
everything split apart into pieces you
just need to draw those big pieces again
so if you want to move the yellow layer
to the right you don't have to touch
anything else you just move to the to
the right and then recompose it your
layers so a good motivating example for
why you want to do this is scrolling so
here imagine that you have a list that's
going to scroll so the great things are
the different items in the list and the
dark gray boundary is the like viewport
so we're like that's the part of the
list that we can see so as we scroll up
here if you didn't do anything clever
you would have to at least repaint the
entire viewport every frame of the
scroll right because you know this pixel
change from from white to gray and so
that pixel asset repaint so we go
explore the tree until we find a repaint
boundary and then repaint that whole
thing well
that to be sort of less efficient than
it could be and scrolling is a very
taxing operation in the system you want
to basically have scrolling be as
efficient as possible so what you do is
you use a separate layer for each of the
items in the scrollable list so here
when I move from the first part of the
scroll the second part of the scroll all
I did was shift those boxes up I don't
have to repaint them I didn't have to
read we layout that might have to do
anything
I just took they're either they're
already recorded drawn commands or if
they have been turned into pixels just
their pixels and view them back onto the
screen and as I scroll up I revealed
this new item so the only amount of
painting acid is when I reveal a new
item I have to go create a layer for him
paint him right but now I have him and
as I scroll I don't have to do any more
work at it has a slide him around and
when this green guy slides at the top I
can reclaim him and that way I get this
nice sort of recycling ListView sort of
almost for free out of the whole system
so as these buffers or layers become
available on the top they sort of can
appear on the bottom and you only ever
have a finite number of them as you
scroll through this system this also
connects up to earlier what we talked
about where each of these items in the
list don't know what their offset is
right so they their behavior or
appearance can't possibly depend on
their offset because they don't know
what their offset is so then I know that
I can just move them without talking to
them right so that means I don't have to
do like I the amount of work I have to
do to do a composited scroll is
essentially like very very little and so
on sort of like you know three-year-old
devices we can do composited scrolling
about like one millisecond that's pretty
fast
it's basically everyone uses the same
underlying commands on the GPU to do
scrolling like this so it's only a
question of how much work was it to
author and how so in the system we built
up the abstractions so then when you use
one of these things it just feels
totally natural so for example on
Android you have this recycling ListView
guy with like a
with like six methods you have to
implement it's very complicated right
but in the system all you did was you
just had a widget with a build function
and then we wrapped it in a wee pink
battery for you and then we because of
the invariance about the offsets and
stuff like that everything just worked
out perfectly so that positive scrolling
is like it's the optimal path just run
it by default
first so we don't leave without like we
mean by positive here right like I mean
you actually like you render all dead in
foreign bombers or they like like
vectors and then yeah yeah okay that's
good I sort of glossed over this and I
actually have four minutes I can I
should cover it just get so far SAS what
do you mean by compositing I'm a
graphics guy this doesn't look like
compositing to me so I'm just I'm
punching it up yeah so traditionally
compositing means I had pixels recorded
in a texture and what I'm going to do is
I'm going to blip that texture onto the
screen in order and so we actually do
that sometimes
but I don't always do that so each of
these layers can either be represented
as a vector so like a display list so a
list of drawing commands execute or we
can bake that list that display list
into a texture and then we once we have
the texture we can blitt the pixels
directly to the screen and so the
question is when do we decide to
texturize these layers and so we have so
in other systems they make very strong
commitments about this so cocoa says you
know every CA layer it's a it's a
texture we're gonna have lots of GPU
memories can be okay
android framework says the opposite it
says I never ever want to make textures
I don't have a lot of memory I'm going
to redraw my display lists' from scratch
every frame and I'm going to make that
really efficient so in this system
actually takes a sort of a middle
approach to these things so what happens
is if you draw the texture three times
we draw a layer three times as a vector
will be like you keep drawing the same
layer I bet it's worth making a texture
out of it and the third time will first
draw to a texture and then flit it from
the texture and from then on as long as
you keep drawing it will just draw it
rested for the texture and it turns out
that three is kind of a magic number so
if you picked one
then that means you would always draw
indirectly through textures right and
that would be not efficient in some
cases like imagine like circular
progress indicator right in material
design so it's just like arc that keeps
changing in size and keeps like rotating
around that never draws the same frame
twice like ever right so there's no
point in drawing it indirectly through a
texture you will you might as well just
draw it directly from its command but
imagine like a drawer that's like
sliding out that thing is identical all
the changing is its offset so if you
capture the drawer into a its own
repaint boundary and you can translate
it in the compositor then after you've
done this like a couple times you're
like hey I bet this is going to stay
like this so you can actually just
texturize the drawer as a whole thing
and then move it out and so why three I
don't know you could try for you could
try one try to freeze actually seems to
be pretty good it's actually a
observation across many many systems in
computer science and electrical
engineering you have two bits saturating
counters turns out to be pretty good so
that's where the three comes from it's a
two bit saturating counter yes okay so
when I said three I said what if we have
lots of tiny stuff and that seems like a
waste then they go oh yeah so the three
is not the only answer there's if
there's some more here six that decide
when we should texturize emotion not
texturize and I suspect as the system
matures we'll need to tune those
heuristics so there's a heuristic that
says hey this layer doesn't it's not
really that complicated it's really just
a big friggin rectangle there's no point
in like storing pixels for it we might
as well just draw it what does a
heuristic that says hey it's got a lot
of empty space in it that's going to be
really inefficient I know a lot of
transparent pixels it's time useless so
they're various heuristics I think is
that we use to decide whether to
texturize something but the nice thing
is as authors you don't have to worry
about any of that that's all done but by
the compositor maybe we'll we partially
expose some sort of control levers for
that to let you tune it yourself I guess
but we don't do that yet yeah you see
you want to texturize things that we
ain't real is that let's do a lot of
that
there yeah so anything if we auto
texturize after three things I can't we
just Auto layer eyes after three things
yeah so we should probably musta gate
that so if you run into bug mode we
actually keep track of all the repaint
boundaries that you put in to your app
if we keep statistics about them but how
effective they are well say like this we
paint boundary was like awesome 99% of
the time the child and the parent
painted at different times or will say
this wasn't was terrible
basically it was always the case that
the parent and child like had to repaint
together there was never never a time
when this repaint boundary actually
separated two different painting
operations and so we maybe could use
that information to automatically
generate repaint boundaries we haven't
really investigated them too much free
being public free that's right so
basically so using what is the actual
trade-off involved in a repaint
boundaries so the actual trade-off is a
trade-off between the amount of time you
spend in the paint phase recording
commands versus the amount of memory you
take and the amount of management
overhead you have for these layers so if
you had infinite memory and we had
really good memory management we're the
good tools for managing these things you
make everything a repaint boundary and
like you can imagine you can make every
pixel on your screen or repaint
boundaries and then you'd be like we get
really good at managing the pixels we
build some sort of specialized hardware
for it we'd call it a GPU right so it's
sort of about moving work from different
parts of the pipeline to other parts of
the pipeline right so if you're really
beefy GPU that can just take every
command you fire at it and draw it then
you would never want any immediate
boundaries it wouldn't make any sense
right but if you but in reality the the
pipeline that your app goes to to render
you know has different constraints on it
there excuse on a CPU and a GPU which
have different relative strengths give
different amounts of CPU memory at
differing amounts of GPU memory and so a
lot of sort of implicit in these things
and in these different knobs you can
turn or how do you rebalance your
workload
across the sort of diverse set of
competing resources and so what we've
done is we've basically picked an
approach that is optimized for mobile
devices so in contrast to other systems
that were designed for for example
desktop devices where the like GPUs
didn't even exist when they were
designed right so then we design the
holes it's going to be up roughly
optimized for mobile devices and then
there are few little knobs you can tune
to basically say my particular workload
right particular app how do I make
efficient use of all the resources that
are available at each stage of time now
we're you know every eight hour here in
our office absolutely yeah so important
so this question was this like Auto
texturization and it doesn't add a lot
of noise to your your pipeline which
might cause you to miss your frame
deadlines yeah so I was worried about
that too but it turns out not to
actually be that bad so the reason that
my hypothesis is they're not all
synchronized so they don't all hit it's
not like we said okay this frame we're
going to texturize everything all right
that would cause a big hiccup but as you
see as you scroll by basically what
happens is this dark blue guy appears on
screen for one frame two frames they
need texture ours is and he goes right
so as long as the like you know it's not
like you're drawing them all at the same
time right so like it turns out not to
actually add that much noise to the for
the pipeline so there's also like
Diagnostics so if you go into
Observatory and you look at the timeline
and you record a timeline you can see a
time oriented view of what's going on
you can see each phase of the pipeline
will be labeled and you can see the
order that they execute how much time
they take relative to each other and you
can see things like texturization show
up it's like you can see things like you
know how big how much layout you're
doing or either if you even visit the
layout phase of the pipeline at all or
whether your frame can purely be
produced by painting or purely be
produced by composite
yeah have you always been delays in the
fixes before you were saying that after
three right you score the mixers right
or is it okay so this question is yeah
so this question is do we always throw
them into pixels or sometimes we draw
them as vectors no so when we're drawing
them as vectors we just draw them in
immediate mode as vectors we just issue
a bunch of tronic like if you have a
path we'll issue all the triangles for
the path how do you turn with a friends
one two and three are the same
that's good question so the the display
lists are immutable
so once you've recorded this play list
there's no way of altering it all you
can do is tear it down and record a new
one so they just have unique IDs and so
we just keep track well this place have
to see unique IDs and so if the we just
remember the ID that we had drew last
time so seven we drew display list 27
last time so this one is to display this
27 it's immutable so it must be the same
thing we also record the matrix so we
will always draw exactly perfectly on to
the pixel grid of the device so if you
change the matrix then we'll change the
matrix in a way that it changes the
projection from the layer to the screen
then we'll say okay that's doesn't count
as trying the same thing because we want
to hit the exact pixels so for example
in other systems like cocoa if you take
a UI layer UI view and you transform it
you won't always hit exactly the pixel
grid which means you've got a little bit
of aliasing so it's a trade-off for
performance right so if you that means
they're able to draw from textures more
often but you don't get like pixel
perfect up output and I expect
eventually we'll want to have that
capability in system and we definitely
can but right now the system is tuned
for pixel perfect output and then if
that's too slow then we'll like reduce
the quality to get performance if
necessary yeah so just to orient this
was the we talked about these three
phases of the pipeline
yeah I want to thank everybody for
coming
we take more questions to get it I guess
you guys asked a lot of questions
already says so one of the one of the
widgets is capable of into your children
so does it end up having n-squared
behavior or do that yeah yeah so he says
some witness can take their size from
their child does that introduce
n-squared behavior and so the answer is
slightly subtle so the simple answer
that question is no it doesn't it just
in general doesn't introduce n-squared
behavior because remember my parent gave
me my constraints I was allowed to talk
to my children and then I reported my
silence so if I want my size to exactly
match my child then all I have to do is
ask him hey child what's your size he'll
tell me and then I can just tell my
parent that was my size so in general if
you want to shrink wrap your children
that's that's basically free but there
are cases where you want to do something
slightly different than that so they
don't actually come up that much but
when they come up they're sort of no
other way of solving these problems so a
good example of that is the pop-up-menu
in material design so how why should
have pop-up-menu
material design D so the answer is he
should be as wide as his the widest line
of text contained in the menu rounded up
to an integral number of 8 pixels okay
that's what they wrote in the specs
ounds great so if you just asked each
child to please lay out at your size and
then I'm going to size myself to the max
of you plus 8 pixels that wouldn't
actually be correct and the reason it
wouldn't be correct is because of Arabic
so in Arabic you instead of writing from
left to right you write from right to
left right which means the menu item in
Arabic should be all of the text of the
menu and it should be aligned vertically
on the right edge on the right edge
and which means you have to when you
when you lay out the children you've to
tell them how big the menu is actually
going to be in order to get the correct
text line and so how do you know is like
chicken and egg problem right so this is
the case where you actually need those
intrinsic sizing functions that I sort
of put up on the slides but didn't
really tell you much about so intrinsic
sizing lets you ask your child a how big
would you be if you well the league if
four different questions to ask and
there's sort of subtle what they are but
the one you want in this case is you ask
the child how big is your longest line
of text effectively so what is what is
your width beyond with if I made you
wider you wouldn't get any shorter
there's an abstract way of saying I
don't want you to take any line breaks
and take as few line breaks as possible
and tell me how wide you are what the
menu needs to know and in those cases
you can get ensberg behavior because if
you if you keep asking that question
recursively as you go down the tree then
you could be always asking that same
click like text at the bottom Hey Dude
how wide are you if you only had one
line right you asking that question N
squared times it is possible to get that
so those are very rare so like for
example in with a stocks app which is
like the M what's like the kitchen sink
app of all widgets that we've ever
thought of it combined in the craziest
ways possible has like two so it does
occur and you need to do it in order to
get correct behavior but oops didn't
want do that but for the line share
cases this one pass simple constraint a
system is sufficient to get the correct
player yeah you see something as a
result yeah so the jaegers question is
being gave this talk that explained that
build phase in detail and I give this
talk that explain the layout and paint
phase and I told you as a pipeline what
if I what if my build wants to depend on
my layout and so when I said it was a
pipeline I sort of actually lied so the
build phase and the layout phase are
allowed to intermix with the
so the middle of layout you can do some
more building you can't do building it
can delay on the middle building so I
guess you're allowed to have build
phases inside of your layout phases and
this actually follows from a very
important property system that I
discussed which is that a render object
doesn't know anything about its children
so what you do is give us another kind
of render object another kind of render
box whose child model is in lazy in some
sense so basically says when I need to
go lay out my children because no one
else has ever been able to talk to them
because no one else knows what my child
model is I can create them just in time
in order to do their layout so for
example we have this lazy scrolling guy
who only build widgets that are actually
in the viewport and the way this works
is during layout he says oh I don't have
enough children to fill my viewport and
to go build one more let him out Oh
someone have enough I gotta go build
another one ok let him out and these
phases are basically because you've
never visited those children before and
you can never have to visit them again
right you never have to get more
information from some other part of
layout that tells you oh I need more
children to deal with this problem then
you get this very clean infinite
scrolling mechanism I want to give a
whole talk about that thing because I
think it's friggin to really understand
it we have to go into a little bit more
debt fit great thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>