<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Silver Bullet -- Time Travelling Debugger | Coder Coacher - Coaching Coders</title><meta content="Silver Bullet -- Time Travelling Debugger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Silver Bullet -- Time Travelling Debugger</b></h2><h5 class="post__date">2009-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LpfmKIxusZY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">before I begin talking about Scylla
bullet you know I thought I'll take some
time to talk about software development
in general because that is essentially
what this talk is really about right so
I mean if you look at you know water
developer does every day in his life you
know you kind of see this cycle going
you know you know I mean definitely can
describe some processes but if you ask
that will develop are you what he does
the whole day you know you can say you
know i'll write some code and run it and
because i'm a human you know I make
mistakes and I spent the entire day
debugging bed now okay i'll take another
detour for for a second you know and
talk about you know how people have
tried to evolve software development
over the years you know and usually when
people say you know i'm gonna help
developers they talk about libraries you
know and this is kind of the division to
show you you know is you usually have
something like this you know you they
say okay this is your your piece of code
right now and right now using these many
third-party libraries and frameworks ah
in some time I'll rights on more
libraries and frameworks and this this
would look something like this you know
because over time the libraries increase
you know and you just have right this
amount of code you know and you know you
know this is the it's the ultimate
software dream that you just have these
complex which you just have to fix
together like a jigsaw puzzle and your
software will be complete in a second
you know and if this was true you none
of us would be sitting here right now
because I mean if the software could be
completed in the second you know why
would you hire expensive engineers at
Google to write it right so what
actually happens is something like this
so the third party libraries grow but so
does your core so if you really think
about it you know take together take an
example of say video games you know back
in the day you know you must have played
something like do and
you know the guys may do me took them
years and right now they're probably
libraries out the game game libraries
they'll allow you to make something like
that in copy of Greek up sir right for
the problem is nobody wants to many more
right they won't do for and that's been
in development for the past five years
and then we're doing for comes out you
know they'll be libraries to make that
in a week but nobody gon do for them the
people won't do five you know so at the
same thing the third party libraries and
frameworks grow but so does your core
you know so that's there's the library
spartina so I'm coming back to that
original cycle that edit Ron debug hi
Helia and here again you know it seems
that people are mostly focusing on the
Edit back you know I mean when you don't
do all a person yeah these sort of
religious talks about programming
languages right and if you really think
about it like does it really matter if
you died in a is equal to five or easy
to five or unite like let's start bad or
you know use any of those to tie the TN
you know let's take a more complex
example you know like the the for each
loop in Java five like sure you can say
you know Java five is much more neater
and cleaner but like TV radio sauce
software development dying by fifty
percent just because you use your form
each loop I mean when was the last time
you can complete a software project
because you can type it in fast not in
mommy today hi assembly last someday
last week's say you know this cuz
there's no damn thing but you get by
probably draw me fast he don't really
happen right what happened since I mean
y'all humans right so you write some
code and you you grown it and you will
make errors on you give me we made all
these frameworks and languages where
baby assume you know that you if you
make an error that's an exceptional
condition that's an error condition and
that's okay for a computer right for
computer maybe that making an error is
an exceptional condition but if you're
human errors are the default for you
right I mean most of the times you will
make errors and in an exceptional
condition the program will come out
right that's what happens you know so if
you can take the graph and you know make
the circles going to the amount of time
taking in diamond dude look kind of
something like this and no before you
ask me this graph is not drawn to scale
because if it were drawn to scale you
won't even see those edit and run
circles over there so now connector
debug part I mean the way you debug
hasn't really changed at all like pretty
much since the dawn of programming right
and the way you debug is with the same
model of breed bones and the thing about
breakpoints are the breakpoint model is
broken so consider something like this
you onmousemove this method is called
say every time you draw a perfect s this
covers the entire screen a perfect axiom
and once you know that perfect ass your
program crashes so you take out your
standard debugger and you try to debug
it and you place a break point on it but
you know the first time you move your
mouse it brings so you know even grease
the point for you you know make your
perfect ass and then you try something
like you know you try to put your head
down so you try to put some conditions
and the developers drawing perfect SS on
the screen the entire day and are trying
to see if you leave it does the right
condition you know the right head count
and it's just so painful you know so and
just this whole idea of you know you
have to reproduce bugs in 2009 you know
it's such a huge pain you know and for
something like multi-threaded programs
it's impossible right you can you know
it can't even reproduce that and it is
things like bugs which caused programs
to feel it's not typing which causes
projects to feel right and it's even
worse when if it's some code on your
service goes down right i mean something
like if it sounds like gmail or yeah
gmail it's good so something like eBay
or something goes down you know it's
even worse to debug it because you can
reproduce your entire production
environment you know I mean and the site
is down is your main social revenues
it's just crazy so if you like think
about it you know I mean software
development in the past 20 years
hasn't really changed I mean in 2009 it
is still okay for people to use VI or
emacs and combine that with any other
industry again I mean have you ever seen
a graphic artist see no Photoshop is too
expensive i'll just use ms paint a no
you just know what happens right so we
got to change something and how are we
going to change it but if you're gonna
change it by using a very simple
mechanism he is gonna record every
single thing that happens in your
program and by every single thing I mean
everything every method call every
variable that's assigned every branch
that's taken everything that happens in
the program so what does that mean I
mean its cool the recording you know but
what does that mean right i mean well
that means you never ever ever have to
draw up that s again on your screen once
a crisis and as you'll see as i'll show
you now you know the gnu debugger that
i'm going to show you it does not use
breakpoints you do not have to deal with
breakpoints anymore it's broken do not
do this and you know i mean it's
obviously great for something like you
know if you have a problem in a
production side you don't have to
reproduce the entire environment entire
database and try to reproduce your
problem now you may say okay recording
is so cool so why aren't other people
doing and why don't we see a whole bunch
of recording related tools out there
well the reason is because it is really
really really hard I mean think about
your CPU can execute millions and
millions of instructions a second you
know and if you're gonna record
everything and if you're not clever
about it either you run out of memory
really really fast and even if you
somehow circumvent that you program it
goes so slow that will be unusable if
you can't even use a program i mean
what's the use of having the recorder
running so i'll show you just to show
you how this how does this problem is to
solve i'll give you a little demo
so I cannot tell you the exact other
tool that i'm using the compare against
him because no larson advise against a
but what I can tell you you do a google
search and you'll probably come across
it's pretty fast now this is a tool that
has been developed by our University and
the spin in development since 2002 those
paper since 2002 and they have published
papers and groups LA and the even had
demo at last year's Eclipse down or
something so I'll get their particular
build source you know it's not just some
20-something or guys sitting all alone
interview you know doing some stuff you
know so over here you have this program
and it's a sikh empire written in java
and it takes this C file you know
something like this and it converts it
to llvm so I'm just going to run it
normally so you can kind of get the feel
of how the house fastest program as he
runs so I just won this normally right
now and you can see this completes
instantly
just wrote the output instantly just
gotta write you a la loo a.m. and now
I'm gonna run the same program with this
other recording to you and it's running
still running it's still running so it's
taking a bit of time to to run you know
so so I'll do I was run my recorder
while this record is still running so
that's what I'll do
so this this ran with my recorder and he
just completed instantly the other tool
is still running as you can see so I'll
do something else he another so this
file i opened was let's see how he was
you know he was 69 lines wrong right so
I'm gonna run this with let's see
sixteen hundred lines you know ten times
over ten times I guess 30 times I guess
yeah so the Gaza program is still
running as you can see and I'll run this
on the even bigger file this is running
on an even bigger file and you can see
sleep is completed and the other program
is still still running I lastly stop
this program because it doesn't complete
even after half an hour and I gave up
after that so so you say yeah it's good
to have a recording you know it's that's
that's good but what does that mean for
me I mean you just you know adding more
stuff to my program making it slower
what was the use of this thing sashe the
use of this thing
so now i'm going to show you the
time-travelling debugger and how it
works without three points now I tell
you you know like I've been researching
this time travel thing for a while but
it's not being thoroughly researched so
you know keep your belongings you know
keep all of your belongings because you
don't know what will happen so this is a
really small program and it just prints
out a bunch of stuff you'll see I
destroyed it normally for for a second
day or year and you can see this
completing it steadily just prints out a
bunch of lines that's all it does it
does some comparison and it calls this
binary search method a few times that's
all it does it's a pretty simple program
and now this is running in our Eclipse
plugin so near your run and debug
buttons we now have the record button so
now I'm going to launch this program
with recording enabled so I ran this
program and it completed it producer
output and now that recording has been
saved to a single file and I can share
that file among any number of tour on
the purse and they can take a look at it
and rather than a debugger no need to
replay the program so i'll share the
debugger now so now i'm running the
debugger off the recording and as you
can see just like your normal program
right i can see my stack trace and i can
see my local radio votes over here and
and like you're like a novel liebherr in
a key i can step forward and time again
see the variables changing but unlike
your normal debug I can to step back in
time you know I can see there it was
changing back you know and you say oh
that that's time that's time trouble
because I can travel back in time you
know but no do you make full use of this
recording you have to re-invent to debug
so are you going to read when the
debugger well first of all stepping
clean I mean why why step at all I mean
if you look at this you see this green
line it shows you the execution pack of
this call to this method only for this
call and instead of stepping you know I
Kentucky's click
on this line I can step anywhere I want
you know I'd have to step 1 by the one
and you can see the state changes you
know so I'm stepping one by one I can I
can step anywhere i won't i have to look
to it i can instantly see you know this
if statement was taking this L statement
was not taking I don't have to step
through the entire method to see which
statements like it or not and and that's
that's good you know you say oh that's
that's awesome you know but but what
about this loop or sound I mean yeah
this loop from 1 to 10 and you know I
mean how do I step back and forward in
this fight so that's that's a huge turn
let's let me use my normal stepping
methods and again in this loop coming
from like a 12 million right and in a
normal break point based debug or you
can't really place a break point on you
know when the bug occurs so the baby
gonna tackle this problem here since
this loop iterates I i'm just gonna
click on high and shows me all the
values that were ever assigned to I the
thread that I signed it and the time at
which it was assigned now time in this
case is an event counter so every even
that happens in your thread happens at a
particular time value that the debugger
assigns to you so now instead of
stepping through this loop you know I
can actually just click on any of the
values and it just jumps to that point
in time you see is three now I can click
on any other value I just jumps to that
one time yes well this time mean so time
is a counter so every event that is
recorded in your program is a sign a
time value so that's what time is so it
just gives you an idea what happened
before what you know so you're if you're
debugging race conditions you can see
the time value as you can see you know
where there is condition talker so you
know so i can click on any value and
from there on from that point in time I
can step forward or a step backward now
that's good that's great but you have
this line over here you have this line
which has this nested method call and
this could be like a really
arbitrariness next thing again
or it could be a cheer method called
like result or result or result the
result and it's a pain to use the normal
step and function to step inside these
calls because maybe you want to step on
the third calling this line but you
press the step in butter and it sets in
the first call to that line and you want
to see the return values and the
arguments were meth-head United's it's
just a pain to you know see it on a
normal debugger so for that we have a
special view you have this we got calls
on current line and it shows you all the
calls on this line at this point in time
sure it shows you these are the two
calls and I can expand it i can see what
the argument was and i can see what the
return value was instantly and if i want
to step into any call i can just click
on the call and I can step on exactly
that call so that's good but you say you
know I think there are some problem in
this binary search method right and you
know I don't want to step all the way to
it you know so how am I gonna get get
get two day night a novel debug outer
space a break point and I'll just kiss
break on that so how are you gonna use
this without every point well you can
just right click on that method and say
run to method and it just runs to the
next call to that method and again you
can see instantly you know what the
execution path to this call was but then
you say you don't look for sure there
may be like a million calls to this
method and how many times are not gonna
press run to method right I mean how
many how many times are gonna do that so
why not see all the calls to this method
you know I want to see all the costs so
this she shows all the calls to this
method it shows you the return value the
arguments the thread and the time it
which is cornea and I can just click on
any method God I will just jump to that
call itself and you can see the
execution crack changing as a changed
the ball but then you mr. universe on
this this list can be really really long
if this is like a million balls you
expect me to like click on each one of
them and see which one it was well so
it's a way to filter this right so let's
say let's say I
you know all calls which reach this line
this line which I'm just placing my
cursor on so I just put my cursor on
that line and I say filter by line and
it just shows me all costs which reached
that line you can see all these costs
reach that line and again you can filter
by many other ways you can filter by
return value you know I'm calling object
of the thread you can buy these filters
in anywhere you want and that's that's
good you know but you see your work this
program produced some output on the
console you know and this program is not
running anymore but I want to see what
the output was you know maybe that
offered was something important and i
can see that anymore so why why should i
use a debugger but you can see that
output so i'm going to open this view
it's called the recorded console and
shows we both that what was output on
the console and that's that's good you
know that's good that's good for you
know what you can hear you can actually
click on any of these lines of output
and it jumps to the point in time at
which that output was produced so I can
click on three and jump to the point in
time at which three was output so you
know
he said that's good but you know all
this all this time travel is making me
crazy I mean in my normal debugger I
just stepped forward and I know I know I
know where I am but but this is all this
time travel I don't know I don't know
where I am in time now you know I need
somebody to figure this out so to keep
you from getting lost in time I had to
put in some mechanisms in the debugger
so the first of those mechanisms is the
back and forward buttons oops and these
are like the back and forward buttons in
your browser but the keep track of the
last and calls that you said to you so
these these are the same methods but
different calls to these methods that
you were in and that's just this a
preliminary way of you know going back
and forward you know and just kind of
keeping crime but a more elaborate way
is the timeline view the timeline you
shows you the exact time you are at
right now and this progress bar shows
you we're kinda in the execution the
program are you like how far you down
the whole execution of the program so if
I step out and let's say I step you know
to the beginning of this method it shows
me okay yo you're gonna in the beginning
of this execution of the program you
know what I can step near till the end
it shows okay you're pretty much you
know till the end and it can be some
other things like in place what I call
time bookmarks okay these are bookmarks
in time so you can place them on the
same line and the same file in the same
call but at different points in time and
a time you can you can just jump back to
those points in time and you know you
can honestly export these and put
comments on these and share them on
Tamara to other person said you love
take a look at this point I'm something
is happening so that's that's the
debugger you know but you know this is a
pretty pretty small recording and
you know you're probably thinking show
me show me something big like invasion
so i'll show you something bigger now
i'm gonna open a recording of the antler
parser generator and you can see this is
a hundred mb recording and i'm going to
just open this from the file itself so
you can you can see i'm not running this
at all I'm just I'm just hoping it's
from these files just taking a bit of
time in yeah it opens and again see
justlena i can just debug antler you
know just sign as a normally would and
now if you know the creator of antler if
your name is not very inspired and i
asked you know why was this line out but
was there a bug and antler it probably
takes you like the entire day to figure
out to the normal debugger but with this
you just click on this line of code and
it just jumps to that point in time and
you can see the entire stack trace you
can still see the entire tractors and
you know let's click on this line you
can see the entire stack trace and go
back and see why there are awkward so
that's the debugger but your brother
think you know we are we're of vaca me i
mean we are Google again you showing me
all these all these desktop apps so I'm
going to show you a web app now so this
is jai Ryan you might have probably used
it this is a pretty common popular
muckraking tube and I'm just gonna start
it up now now i'm doing something
unusual I'm not starting this program
with recording I'm starting this program
as normally as any of you would you know
no extra arguments on the command line
just are the Box insulation I'm just
starting it up normally and you can see
I can browse browser do here
and it's dis running normally right so
I'm going to do something over here that
was the other one that was not our stuff
that crashed by the way so I'm just
gonna attach or record dynamically to
this running program so you can see gyro
running over here and in this tool i'm
gonna select the process for china which
is this one I'm just going to attach the
debugger to it the recorder to it
normally so now it's attaching itself to
it dynamically without any arguments
just out of the box isolation the
program is still running you can still
use the program so Stratus instrumenting
all the class says you know and doing
all the stuff to have the recording run
she's gonna take a little bit of us time
and again my program using our fully
usable at this point I'm there may be a
little bit of it because the class
you're using maybe keyword but you can
see the loading is still being done and
the program is still running so now that
now the record has completely attached
itself to your program and you know I
can still use the program you know if
you see it pretty much no change in
performance you know it's not taking an
hour to get the same request you know
it's taking the same amount of time you
know it's running normally as you would
expect it to learn you know so now I can
also dynamically detach it so I
dynamically attached the record and now
I'm dynamically detaching the recorder
so now it's doing the whole detaching
bar and you can see produce a single
file over here 35 mb and again i can
share this file among developers and you
know if you are lashing you can debug
this if you want if you don't have the
source for to do that so we can do that
right now so just to tell you some
things about the recorder itself the
record is completely platform
independent you can run it on any OS you
want where you can run java and you can
replay the recordings on any other
oklahoma so you can take a Linux
recording played on the Windows PC or
Mac jvm independent you know you don't
have any dependencies in the Sun JVM you
near the JVM and you can record any Java
program as long as it is 0 because there
are no issues you know you can record
whatever you want opencl program we're
back anything now I'm going to talk a
little bit about some of the approaches
taken by some other commercial tools out
there and how we kind of differ from
them so what's on the other tools out
there do i mean we actually record the
entire program every single statement
that your program excuse every single
thing it does but what's on the other /
solutions out there do is they do
something like this so this is your
program running in a straight line think
of it as running a straight line in time
and let's say you know what recording
everything is going to be too expensive
going to be too slow so what you're
going to do is figure out a record at
certain intervals so the record as you
know each of those intramurals the
capture the full state now when you do a
replay from those programs are in first
off they are platfrom dependent because
they can only run you know most times
again I run the windows recording on a
Windows platform they will just play
back your program from any of those
checkpoints and then they take playback
in a normal D Barbarino none of that
fancy stuff that i showed you
now the whole problem with this with a
playback mechanism here's what if
between one of these intervals your
program called something like get dime y
despues to external state right and it
may be that when you re playing the
program you know that external state is
different so what they have to do is
they actually have to write rap or calls
to you know all the API is the query
exelon state so they actually can record
only a certain type of application so
when you venir you know get one of these
other applications that said you can
record only say tomcat using these and
these these in these libraries and if
you use any other thing you know we can
be can record it for you this is not the
case with us we can record anything that
you want now the recorder works on
assault of a whitelist model so by
default we don't record anything and you
kind of give us in a conflict why what
you want to record so the reason why
this model is there is because something
like let's say you know you are writing
your program you probably do not care
what is happening inside the Java
libraries like you don't really care you
know what happens I'm Java not lying or
if using hibernate at all can you don't
really care what happens inside Tom can
you know and a lot of times you know
some these third-party libraries even if
there is a bug in that me or me you
didn't write it you cannot debug it and
you probably don't even have the source
for it so all those libraries they run
without recording and you just record
what is your source code so yes a you
know i'm just-just include calmed or
google that star star and only your code
is recorded this and you know that's
that's the we kind of works but there is
no there's no limit you know you can
record anything you want we don't place
any limit on what you can can I cannot
record it just it just your choice you
know if you if you want the recorder to
run extra fast you can expect to do
stuff now as far as the performance of
the record goes there are three kind of
applications where we categorize at
least for performance and the first is
command line apps so if you have
something like a compiler you know
or some other command line tool now
since you're running it on the command
line you don't really care whether it
completes in one second or three seconds
right because you're not really
interacting with that much so these this
kind of option even if you learn slow
it's kind of ok and then the other web
apps and again you know very back you
know if you click on a link and it
reaches you maybe you know 15
milliseconds leg that's fine you expect
that so we're back you know the worst
case our desktop apps you know something
like eclipse because you click a button
and you want that instant you know
instant response and if you don't get it
it's in response they need the program
just becomes unusable right i mean if
you press control space and eclipse you
expect the puppet to come instantly if
it comes to after a minute that's
useless for you so that's how that's how
we cannot categorize performance and no
record is kind of built to be scalable
so these are kind of worse you have your
recorded trends which are generating
data in memory and they're using some of
your course now the recorder has these
things called the Lord manager threats
and what these trends do is the capture
all the memory that's been generated so
fast the compressor they process it and
they save it on a disk or through a
network so if you think you know I mean
this is mainly a problem of you know how
are you gonna minimize that memory
that's been generated so fast so if you
think you're running out of memory you
can either add more course so the Lord
maggot threads will be able to process
it faster or you can just add more
memory memory is cheap or if you think
your disk is too slow you can you can
have a raid you know you can have
parallel disks do I have to get that
right speed or if you want you can you
can you can send the output to a net we
can attach multiple ethernet cards and
send the output to a network on the
problem that you know some you you may
think you will face is GC pause times
because you know it is not uncommon to
run into one keg or two dicks of heat
sizes with this but you'll see GC pause
times are not
issue with this even if you have a 2gig
heap you know you'll see sometimes just
instantly comes to 200mb be as soon as
it's cleared the reason for that is
because we do custom memory management
you know so we don't really have that
many pointers in memory and the garbage
collector works only a memory the last
point is the amount of execution
recorded so if you think you know you
have added and of course you know you're
taking care of the memory you've added
your disk but your program is still you
know not up to the speed well then you
just have to exclude stuff you know you
can you can some most of times you'll
see you know in a program this just
maybe one class is doing a lot of work
but you don't really need to record it
and you can just exclude it and then the
recorder on three so that is it for to
this presentation and if you're
interested in the stool you can actually
go to our site and put your email
address in there and we'll send you a
notification how this one more thing now
I told you that the worst case for the
recorder is when you're running a
desktop app like eclipse because you
want that instant response right you
want that it's a response if you don't
get that instant response and it's
unusable well as it turns out when I was
showing you the debugger demo that was
being recorded you just never notice it
and this is the trace file that it
produced thank you so how big do those
files get that one's a 180 4 megabytes I
see and how happy how big those flies
get and and how fast do they fill up I
mean yeah well again that's a really
tough question to answer because it is
really depending on the program so again
you know something like eclipse you can
see I mean we ran for about 20 minutes
or something or maybe 10 minutes or
something I don't know but it produce
about 180 you know but there are some
other programs out there like something
like Jay try we see you it's a small bug
tracking tool like China and even if you
write for you know 20 minutes or half an
it doesn't even produce a file that's 10
MB in size but something like jireh can
instantly produce you know tens of
megabytes so it is really really
dependent on the program but what you
can kind of get it get an idea from
looking at this you know we are
generating gigabytes and gigabytes of
file sizes near the fighters are still
in mb is in a lot in gigabytes well i
mean i'm not i'm not sure right yeah i'm
not sure that that's true i mean this is
this is mb's but you've been running it
for 20 minutes and if you have a server
hmm yeah of course yeah you're running
it of course so I mean VV we are looking
at and desire you said already said you
hundreds a lot of so of course ah so
you're not saying it's not gonna take
spacing it's definitely gonna take space
in the more you record the more space so
again you gotta think of it as a cost
benefit thing you know and of course
we're looking at other solutions right
you know you want to have maybe rolling
logs you know something like you know
keep this keep this log on the disk only
if a certain condition occurred or a
certain exception occurred otherwise
just throw it throw the recording away
so there are other solutions that you're
looking at but of course I mean if you
want to keep everything then of course
you have to provide storage for it but
then I can't even look at the
cost-benefit ratio of it so Andrew ko's
why line system from CMU used a similar
tracing kind of mechanism for debugging
but he had a very different interface
for debugging that rather than trying to
stay at the code level his philosophy
was completely that it was that what
debuggers what programmers wanted was
understanding why a value had was was
that way where it came from and he
considered that would be one of the key
questions that most people asked when
they were actually looking into bugging
is there a reason that you went with the
text-based source code based approach
for debugging and could you actually go
to a wild line based system or do you
think there's things would keep that
from well I don't I don't exactly get
get get get the other approach the idea
talking about so I didn't exactly get
the other approached idea talking about
so what why line did was wide line
wh-why li NE
okay so Andrew co was at CMU working
with brad myers he's now at the
University of Washington so his system
didn't really show I mean showed you
source lines but he said that based on
research that he'd done on on how people
debugged that what people really wanted
was why does this value why does this
variable have that value why is this
part of the screen blue and so
everything he was doing was focused on
that not trying to imitate a old
fashioned debugger with the the port and
back necessarily and I was curious if
there were reasons why you stayed with a
debugger like view and didn't go to
something more ambitious whether there's
technical reasons why you can't do that
in practice for real for something it's
going to be industrial strength well I
mean technically you know we have all
the recorded data so we are actually
just viewing the data and a debugger so
if you want you know you can pretty much
hack and slice it and whatever way we
warn the way we currently have a
mechanism you know for figuring out why
value occurred is really or just to look
at that value and click on it in a
variable history of you and just go back
to that point in time and again this is
this is our matter of debate right you
know some people just want that that
other kind of deeper way that you
described you know and some people
probably would like this d better so
it's it's really not a you know I can't
only give an objective answer to that
because we smooth this is a matter of
preference right this is the approach
that we think you know most people who
like you know and if developers come and
say to us you know you should try this
other approach then maybe we look at
some other approach
you could vary a mat you can very easily
imagine integrating that integrating
that sort of approach into what you've
got I think um did you show us anything
where you looked at multiple threads and
the other question I have is do you
store io events like if I read in an
entire if I read in a gigabyte of data
what happens to that data well so two
questions right so first off about
multiple threads now the recorder is
completely meant to support multiple
threads the demo does not actually show
multiple threads running but the
recorder is completely aware of it you
know you saw there was a thread number
over there that was a record a sign
thread number or the depot is not fully
complete yet so you but you can actually
in the in the fight when the final
release is done you can actually click
on that thread number and show you all
the system assign ID and you know what
the exact name and priority of the
thread was you have the forward and
backward notion and and does that skip
around between threads that well men
you've any doing I wasn't sure when you
do the back and forward in the stack
trace you will see what the exact stack
trace of all the threads was all right
so you'll even do you know look at the
sack race and you know make your thread
and go go forward with it yeah and what
was the second the second question was
about I or if you're reading in a whole
bunch of I out you actually install so
if you're reading in a whole bunch of
i/o now again the recorder just looks at
the bytecode level so if you're reading
in a in a huge byte array you record
that byte array and save it so well
that's how that's how it kind of also
works with third-party libraries for if
I want to clear about that so if you do
not record or third file library or if
you have something like in a file dot
read it will the recorder will store the
argument to that call file dot read and
then store the return value of that call
which is what you want when you're
debugging is you want to know what went
inside and what came out because the
library probably is just a black box for
you
yeah it is it is encompassed fashion so
yeah I mean you it won't be reflected in
your crystal DB that you yeah yes the
Lord mana threats they can take care of
compressing all the data any other
questions so this this is not actually
question is not anything about debuggers
but I I was very amused to note in your
binary search that I think it has the
the bug that every published binary
search has which is that you and which I
coffee download them from wikipedia that
that so yeah so so Josh's has blogged
about that bug and and I've actually
fixed that bug in the JDK the where you
have the the the over when you take the
midpoints of two positive numbers you if
you really really careful you worry
about negative overflow okay so it's not
a very important bug but it is a famous
one well it wasn't it wasn't you were
binary surgicals ratios rock i'll show
you the function looking let's see very
resonant i thought it was just in the
railing
only at Google can eat it's all right
just replace the slash anything else
nope okay thanks a lot for shop</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>