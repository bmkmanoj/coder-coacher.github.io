<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CDE: Using System Call Interposition to Automatically Create Portable Software Packages | Coder Coacher - Coaching Coders</title><meta content="CDE: Using System Call Interposition to Automatically Create Portable Software Packages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CDE: Using System Call Interposition to Automatically Create Portable Software Packages</b></h2><h5 class="post__date">2011-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6XdwHo1BWwY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Robert hunt and I am happy
and proud to introduce to you the
incredibly talented Phillip Gorham
Phillip was my intern in 2007 and he's
still a fifth year graduate student in
Stanford and today he would present some
of his promising research Hey
great thanks Robert okay everyone hear
me okay here okay cool
let me know if you need me adjust the
volume or anything later all right so my
name is Philip and I'm a PhD student
Stanford and today I'm going to talk
about my research which is also an open
source tool it's called CDE and CD
allows you to automatically create
portable software packages for on Linux
and this talk will be in two parts so
the first half I'm going to go through
the slides talking about the system and
how it works and the second half I'm
going to attempt to do a live demo I'd
hope it works
guess before I start I want to make two
really quick acknowledgments so first i
like to thank Robert for inviting me
here today and I'm Robert was a great
boss when I was here in 2007 he he gave
me this really good mix of freedom and
supervision so I'm on hand he allowed me
a lot of freedom in hacking and you know
making my own mistakes and hacking on
the systems but on their hand he was
always very available like you know to
chat and to work on stuff and also
especially after I am even after I left
Google after mentorship is over he was
very responsive on emails when I would
talk to about research and stuff so
thanks again Robert the second person
I'd like to acknowledge is my PhD
advisor at Stanford Dawson so Dawson has
been very supportive my research ideas
over these past few years and he's very
good at asking probing tough questions
they really get at the corner cases in a
break system so it really helped me to
build more robust tools so with that I
like to just introduce the problem
domain and try to convince you of why
it's a pervasive and a very important
problem so the problem has three parts
so the first part is it's hard to
package up your software so that other
people can reliably write so anyone
who's ever hacked on code in any setting
know is that if you want someone else to
run your code it's non-trivial right
because you have to actually package it
up in some way so that when you give it
to somebody else
they can run your software so a
fundamental reason why this is a problem
is that you can only test on your own
machine right like you can't really
predict all the kind of quirks and
different OS versions and libraries and
what
on other people's machines so any kind
of make files or build scripts or
installations directions you write will
be inherently overfit for your own
machine and the graphic I have in the
bottom the slide here shows that there's
this recent study of Labor Statistics
that showed that by now there are about
thirteen million people who do
programming at work beyond just creating
spreadsheet macros or database query so
thirteen million people were writing
code but amongst those only three
million are professional software
engineers some professional software
engineers have this great tool chain and
development process for pushing and
deploying their software and queuing and
everything but for the rest of the
people who are writing software for
these ten million people who are they
right there the research scientists in
all fields or I mean scientists panning
so many fields or running their
experiments computationally and they
want to be able to share their
experiments have other people run them
and build off their experiments these
are designers doing prototypes these are
engineers doing kind of hacking they're
consultants also and also this 10
million doesn't even count all the
countless people who are doing
open-source hacking right or hobbyists
and students so it affects a lot of
people this is the software packaging
problem but the second half of this
problem affects even more people right
so it can be hard to install and run
other people's software all right so
there are an order of magnitude more
people who run software than who produce
it and for them you know installation is
non-trivial so this is even on Google
Chrome on this very well-polished piece
of commercial software there's still
like thousands of discussion form issues
people just having troubles installing
because they're mostly because their OS
variant has some libraries or have
something they have something on there
that the installers didn't take care of
but this is even with you know well you
know packaged professional software this
happens but you know if someone is
hacking on code and wants to share it
you know one of the biggest problems
with installing software is what people
known affectionately known as dependency
hell right so on kind of all operating
systems on Windows Mac and Linux what
happens is software assumes you have
certain libraries on your computer so
and if those libraries don't exist you
have to chase them down you may use a
package manager you may have to compile
them you may have to chase down
libraries in those libraries depend on
other libraries that you have to transit
Lee chase down and eventually you get to
a point where one library conflicts with
there's a library that one program needs
and the library that
that your new software needs conflicts
with that one so you really can't have
it both ways and another reason why it's
hard to install software some people
just don't have permission to install
software so if you're on a lot of
corporate enterprise systems the IT
department administers your machine so
you don't have real permission on your
machine or if you're a university
researcher and you want to run your jobs
on a computer that's a minister by the
university you don't have root
permissions so it's really hard for you
to install software on that that you can
run your experiments lastly unrelated Oh
some people don't even want to take the
risk of installing software so it's like
because installation requires root
access requires mucking around with your
system internals you know some people
don't even want to bother with that
because you have a production server
that's running all these you know system
critical processes and I'm like oh I
want you to try out my software on your
system you know most people aren't going
to be willing to you know do sudo
install it and risk breaking something
already is working so these problems of
software distribution software
installation affect all operating
systems but they're especially gross on
Linux based systems all right so Linux
has all these different distributions
each with their own package managers and
conventions and idioms and ways of doing
things and this this is great for
freedom and openness but it actually
leaves a lot of fragmentation so there's
not a unified easy way to automatically
package your software and have people
run it reliably so I'm going to talk
about how people currently distribute
software right so there's two axes here
in this this graph the horizontal is the
amount of pain you as a developer must
suffer when you're packaging software
and the vertical axis is the amount of
pain your users must suffer so here's
how people currently do so on one
extreme you just zip up everything just
throw it over the fence right so this
this is no pain for you you just zip up
your code or scripts or data files or
whatever and just upload it or email to
your to your colleagues now this is
potentially a lot of pain for the users
because they have to have the right
version of the programs and plugins and
extensions and libraries and stuff
before they can even run your code now
this might seem like a strawman example
but actually this is what happens in the
scientific and research world all the
time right so like scientists are
hacking on some scripts to do climate
analysis or something and you have a
bunch of data files you have a bunch of
Python script mixes some Cecil Huss code
and your
colleagues like oh I want to build off
the experiment can I get your coat I
loved your paper can I get your code
you're like sure is if up your code and
give it to them and a chance of them
actually be will run out of the box or
pretty low so what else can you do so
the next more user-friendly thing is you
make a source distribution all right so
you pack to the source code right so
make files write some configure scripts
documentation it's a bit more pain for
you but the user should be able to
configure and make and hopefully things
work but of course compilation is
non-trivial because they need to have
the right compiler tool chain the right
libraries the right everything in order
to actually compile your software so
what else can you do you can integrate
with the package management system of
your favorite distribution whether
that's Debian or Red Hat or so on and
this requires a bit more work on your
part because you have to kind of try to
structure your software in dependencies
around what is already in the package
management ecosystem but if you do it
properly your users can technically just
have to do sudo apt-get install and
they'll be able to get your stuff and
this works pretty well of course if they
need to require root access to do this
but it works decently well until one
version of one library is not in the
package manager as soon as that you know
you break that beautiful world of
package management you're back to the
source distribution so what else can you
do you can recreate this and more
pain-free you can recreate your entire
environment within a virtual machine
right you can just be like here's my
computer I'm going to start a fresh VM
image reinstall everything I had on my
computer and my programs and my scripts
and everything test it to make sure it
works and then to ship the entire
several gigabyte VM image to my
colleagues and that's pretty easy for
the user they should be able to run it
on any host OS actually and run your
experiment or run your scripts or
programs and so on so it's pretty easy
to use but the problem is that you know
I don't put this very low at the lowest
on the on the y-axis because they're
still not running it natively on the
machine they have this you know they
have their host they have their host
operating system with all their you know
things that they like their tool Chan
and they're running something else you
know they have to communicate maybe
through a local network or through
shared drives or something and this
still doesn't feel natural so the
easiest thing for users to do is for you
to create a robust one-click installer
right so this is the most pain for you
but the easiest for user so they should
just double-click install the software
this is
commercial off-the-shelf software should
work right should be really easy for the
user of course
even then you have these forms of people
having trouble installing software but
and this is a lot of work for the
developer of course right because you
have to go through the whole process of
testing and making sure installers or a
bus and no companies that create
software spend lots of effort and time
on QA their installers so this is the
lay of the landscape now right so
there's this inherent trade-off between
pain that developers must suffer and
pain that the users must suffer so my
Bold claimed during this talk is that
the tool that I've been working on CDE
actually Falls right here conveniently
on this graph
that it in that and minimizes the pain
for the developer and also minimizes the
pain for the end user I'm going to spend
the rest of the talk trying to convince
you of how about you know how we
accomplish this so C D stands for
automatic packaging of code data and
environment so by that I mean we package
up the binary executable code all the
data files and other auxiliary files you
need and the environment which is like
environment variables the dynamic linker
and other kinds of auxiliary libraries
you need so I'm about to show you the
entire CDE users man this is all you
need to know to use it three steps
number one it's a Linux tool so you
create a package on your Linux computer
and to create a package all you do is
you pre pen any set of commands that you
want a package with CD with executable
itself and CD you runs those commands
and automatically packages up all those
dependencies and it does so by
monitoring all the files its accessing
while it's on while it's running and
just throwing them all in this
self-contained package number two is you
just transfer the package a package is
just the directory of files you can you
can move it however you like to another
Linux machine and whatever way you like
and number three is once it gets to the
target machine you can execute the
software from within the package on any
modern Linux computer and by modern
Linux computer I'll show you some
experiment results later basically
anything with the with the kernel that's
around you know you have about a
five-year time window so packages you
create now can run on Linux machines as
old as around 2006 or so but it has to
be Linux only and has to be x86 because
I'm not doing any kind of emulation
Harvard elimination so to run the
commands with an attack
you prepend those exact same commands
after you've unzipped the package with
CDE - exec and CD exec is they have a
wrapper program that will Ex that will
kind of recreate the environment on the
target machine and execute yourself core
on there and it runs it natively without
any installation which means it's
actually running a binary code on the
machine there's no VM layer or emulator
layer anything else it's just as though
it's any other binary on the machine so
three steps to you CD right so there's a
CD executable create the package
transfer the package and then execute
the Packer to CD exec so I'm going to
spend the next part of talk diving into
the internals of how it works so in a
very high-level how CDU works is that it
uses the Linux Peach race system call to
attach on to monitor process to monitor
all the file system calls it's making so
P trace is a way for processes on Linux
to to monitor or spy on one another so a
debugger like gdb or a system call
binary tool like s trace well uses this
mechanism so what CD is interested in is
it's interested in looking at all the
ways the process accesses the file
system changing directories or more
importantly opening files so when it
monitors the action here's what happens
on a time lock that won't jump so the
program first let's say at issues an
open system call right so it opens some
file there's a string in here that says
what the path is the kernel takes
control uses the file system to open the
file but then before the kernel has a
chance to return to the program CD
actually takes control of the control
takes control of execution and sees what
file has actually been open and just
copies that file into a package just
straight up copies it and the packet is
just some subdirectory in your current
directory after it's done it returns
control to the kernel which returns
control back to the program so CD just
is kind of copying pack files in the
package while it's running and on the
other end once you transfer your package
to the other machine to execute it you
run it with CD exec and see the exact
uses exact same P trace mechanism to
attach onto the modern process but
instead of simply spying on the process
it actually reroutes or detours the
system calls so
whenever the process wants to access a
file CD exec will actually rewrite that
system call tiff so that it access is
actually the file inside of the package
itself so here's how it works on a
timeline the program issues an open
system call with some file path right
like Lib Lib C for example the kernel
takes control but then CD exec takes
control right away and then it rewrites
it rewrites the argument of the open
system so it actually rewrites that
string to point to a string inside the
package itself and now after the strings
and rewritten it returns control of the
kernel which opens the file from within
the package of the file is actually you
know the kernel is just blindly
following whatever that string says so
because it's been rewritten it actually
will open the file from within the
package and return the file descriptor
back to the user program so the
monitored program doesn't know that the
kernel has actually been tricked into
opening at a different file but yeah it
kind of works all behind the scenes so
with that CD exec is able to kind of
create this kind of sandbox if you will
that allows the program's to only access
things within there within the package
ok so this table contains a lot of
details I go through one row at a time
so basically these are the details of
what system calls CD actually intercepts
so it only has to intercept 34 out of
the 340 or so about 10% of the system
calls on Linux these are mostly ones
dealing with the file system so it
actually doesn't have to intercept that
much so I'm going to go through each
category of time the most common
category of system calls that CD
intercepts are ones that access file
paths so open is the canonical example
of this it takes some path specifying a
file name and then it it opens the file
so what CDE will do which I just showed
in the previous slide is it just copies
that file in the pack it is very
straightforward and what CD exec will do
is that it will reroute the system call
to open the version inside the package
so the next one new taking the file
system so if you're creating siblings or
renaming files CD you will actually
repeat that same action in the package
to kind of keep it in sync so if you're
renaming a file on the file system CD
will rename the version in the package
just so that they're in sync with one
another and CD exact again will just
redirect the path so that if you try to
rename a file actually rename the file
inside your
package rather than the one natively on
the machine it's important that CD exact
always is redirecting inside the package
because you can probably you're probably
moving files moving things programs to
machines where those files do not exist
on the native file system and if they do
exist they may be the wrong versions so
you have to use the third thing in the
package it has to be totally
self-contained the next type yes
question sure good that's a great
question I'll repeat the question here
um so the question is you know how to
distinguish between files that
inherently belong on one machine like
I'd see like the Khan files or files
that you can share like libraries that's
a really good question um I don't go
over in these slides but I actually have
a configuration file you can specify
with file signor and I just precede it
those with like there's about dozen or
so files and ignore lists and about a
dozen covers one of them is like Etsy
host for example like because if you
move the host file it doesn't network
and doesn't work on the other machine
this is a great question so the answer
to that is that there is kind of this
can list of a dozen or so files it just
from empirical experiences we've built
up and the user can add to that but with
that can list things work out of the box
pretty much all the time
live excellence okay cool so to get the
current if if the program requests to
get the current directory CD will
actually update its record of the
current directory of the monitor
processes the current directory and the
reason it needs to do that is because of
system calls might access files through
relative paths and you need to join a
relative path with the current directory
in order to get the real path so it's
just bookkeeping and CD exec will
actually spoof the current directory it
will actually you know return a fake
current directory that that that fools
the program to thinking that's still on
the original machine so there are some
programs that are really sensitive to
hard coded current directories and if
you don't actually smooth the current
directory things will just break so when
you change directories it's a pretty
straightforward book even as well I mean
if the program changes directory CD
needs to keep track of you know what the
current directory is for
resolving paths again when programs
spawn children so when they spawn sub
processes or sub threads both CD and CD
exec actually attach onto them so that
you're at so that it's able to track
entire process so if you have a program
that launches a bunch other programs it
you'll snatch them all which is really
important and lastly when you're
executing when there's system called
executed program CD will actually not
only copy the binary the executable into
the package it will copy the dynamic
linker as well so a dynamic linker is a
utility on linux that's that's used to
start up to help start up a lot of types
of binaries on Linux and you kind of
need the binders and a blank or need to
have a compatible version so we actually
copy both them into the package and on
the CD exec then once you're executing
it actually runs the dynamic linker from
within the package on the executable
rather than running the system's own
dynamic linker again because they may be
incompatible so this allows us to
actually get farther employed abilities
so this is what what allows us to get
about a five-year bound on around
five-year bound on the kernel
portability because without this dynamic
linker trick you may only get you know a
few years at most cool so I'm going to
go through a quick run example and then
I'll summarize the results and moving
the demo so in this example let's say
I'm compiling source I have some home PG
my project director this contains a
bunch of C C++ code and I just want to
type make and that should compile all my
code alright so but what I want to do is
let's say I want to package up the
entire compiler tool chain involved in
my entire compilation process so that I
can move that package to let's say a
cluster let's say this compilation takes
forever and can be distributed or
something I won't want to just throw
that entire compilation job on a
supercomputer or cluster so I can
compile or my friend might want to edit
and compile my code but not want to have
to install all the same compilers and
headers and everything on his machine so
to do that we can just use CD I can just
because I type make to make my whole
project in order to create a package of
CD all I do is just type CDE make and
what that does is CDU launches make and
attach this onto it with with P trace
make will start accessing files so it
accesses first its own binary and then
it accesses a make file to see the what
commands it should make
and CD is monitoring both and copying in
the backage so that makes pawns a
subprocess GCC to do the compilation CD
attaches onto the child JCC finds itself
it loads some to see Co lo some H files
this is a pretty standard compilation
job writes loading ch+ interestingly not
only is GCC loading source files from
the project directory it's also loading
it also sometimes has to load header
files that are system-wide right like
here there's like user includes Linux so
anyone who has ever try to completely I
would get someone source code and
compile a different Linux distribution
knows that header files are often
incompatible across distributions like
you may have the same name of header and
you try to compile and says oh this
header doesn't have this field or it has
some weirder but CDE we actually package
up the exact header that you need to do
the compilation so there is no conflict
no matter what machine you move it to so
just see my spawn the assembler for
example and that loads some more files
and so on and CD attaches on all of them
and while the program is running CD will
copy all of those files as they're being
accessed into the package and the
package is literally sub direct to call
CD - package in our current directory
and inside the CD package there is a
sudo root directory called CD they're
just regular - sub directors nothing
magical and notice how all the files is
just straight-up copy it into the CD
root preserving their original paths so
we preserve all the paths and if there's
symlinks or other kinds of things we
preserve all those you basically just
want a slice of the filesystem that your
program is access and just moving it all
in the package question yes so the
question is that are we copying
temporary files yes so I'm copying the
temporary files into there and I believe
that what happens is when you um when
you do a remove filesystem call when
that when the does system calls the
delete files actually delete the
temporary files in the package as well
so the package should be pretty funny
but at worst and the general point they
are outgrowing brings up this you know
there might be extraneous files in the
package and sometimes that's the case
but at least you know I want at least
all the files in you know maybe there's
some extras cool so now it's the package
of self-contained is just a directory so
you can tar
jeez if it and move it to another
computer so let's say I started with an
Ubuntu laptop and I want to move it to a
fedora sir
just move the move the package to
another computer has to be the same
architecture of course because we're
just running binaries and once we're on
the other computer what I can do is I
can execute the package now with CD exec
I'm going to execute the entire
compilation job on that other computer
and note that this other computer does
not have make on it it does not have GCC
it doesn't have any kernel headers it
doesn't have anything on just give me
just like a bare-bones computer which is
often what happens with like these
compute clusters there's just a barrier
Linux install so in order to execute it
I have to first change into the project
directory which is kind of this long
path right so you have to go inside the
package go inside the root and go inside
the project directory inside the package
because that's where all my source files
and all my my make file it's more
importantly and inside normally if I'm
in that directory I just type make I but
make doesn't exist on this machine or it
might have a different version so in
order to reproduce that compilation job
I type CD - exec make so I'm typing the
original made command prepending with CD
exec and when it when that happens CD
exec launches make and attaches onto it
with peat raised again to monitor its
actions when make tries to access files
like user they make for example it tries
access on binary CD exec will reroute
that system call so that it actually
points to the file inside the package it
just as a simple string string rewrite
it does a kind of a path lunging thing
and when make a launches children CD
executives on to them as well and again
just reroutes every system call it's
making related files into the package so
the the high bit here is that all the
red arrows go inside the package right
so it's really like CD exec is creating
a sandbox so that all the files that
you're accessing are inside the package
itself but there's not there's not a
there's not a virtualization or an
emulation layer at all right these make
GCC and AAS they're all just executing
straight-up binary code on x86 Linux
there's no there's no magic going on so
they're all executing it nearly native
speed the only time to slow down is when
you're making these system calls have to
do a little bit of overhead context
switching and lunging around the strings
so I'm going to summarize their
experiment results here before moving
the demo so the
binary CD has been downloaded 1700 times
since it was released in November so and
this is obviously tiny for things that
are done at production sale at Google
here but for a you know for a university
research project with one developer I
think this is a it's a decent number and
it's it's a good enough number for me to
have gotten user feedback bug reports
feature requests and and also just
real-world use cases too so it's been
actually really helpful for my research
and people have actually found it useful
in all sorts of domains which I will
talk about later after the demo so the
high bit of the of the experiments is
that you know sixteen CD pack is we took
mostly from our users can execute on
popular x86 Linux tribution x' from the
past five years with no installation or
configuration so all we did was we you
know we asked some of the users oh can
you give us your package ok so you know
it started on their computer and you
know their computer can be any x86 Linux
distros and past five years all sorts of
distros and we just we just threw them
on the six of these popular distres and
the the x-axis shows the kernel
compilation dates so their kernels go
from to 2006 all the way to the end of
2010 and they just ran out of the box we
just threw them on the computer no
installation CD exec ran their things
and these these programs range from like
scientific scripts to to games
to 3d applications to like other sorts
of research II things so all just all
sorts of apps I just run out of the box
so this is a summary of what is
basically a summary of what the CD
system is what I can do and I'll take
I'll be happy to take some questions at
this time and then I'll move on to the
demo so questions okay I couldn't hear I
can't hear you okay Cheryl Ivers okay
and what other files oh it's a missing
system called in shared library okay
well I'll try to hopefully answer both
parts so the first part of the question
was do I copy over all the shared
libraries okay and the second part was
the older systems have missing system
calls and so on okay so I'll take both
them in term so the shared library thing
share libraries just files so everything
is just a file so all in the package are
all the shared libraries you'll even
live see even down to lip see everything
all shared libraries are copying the
package and you'll see this in the demo
too and the second part of the question
is what happens when you go on an older
machine that's so old that the kernel is
missing system calls or the system call
interface is different and that's where
that's where the the thing breaks down
so I you can't take the package back
like a 1995 Linux kernel just because
it's the version so different so the the
limit is really the AVI layer between
the kernel system call interface and the
user space and it turns out that that
layer is actually very stable that you
know all sorts of incompatibilities with
different distros pretty much all
happened at the user space level it's
like people different distros have
different things that they want
different libraries they want but the
kernel from the kernel user space like
they try to keep things very stable so
you have about a five year shelf life
there but anything older than that so
anything older than a 2006 kernel will
face that problem of missing system
calls and it'll actually fail fast too
because as soon as it starts up it will
say the binary is incompatible we can't
run on this kernel I'll take this
question here first okay okay answer one
issue internal go fast those special
files are actually in big norge lists so
actually yeah I don't do praxis or
device device nodes so those kind of
pseudo files I don't take
so from my understand one of the
questions about privacy right of just
exposing information about system you
don't want currently there's no there's
no setting fest so the currently the
thing is you use at your own risk like
you can after you create the package
you're responsibly a look inside the
package and make sure your Etsy password
is in there and if it is a lot of times
like you're saying it probably touches
you know your shadow password file but
it might not actually use the actual
content so I don't do any more detailed
analysis that'll be a good thing for
future work though of how do you make
these kind of safer but right now
there's kind of no privacy guarantees
and you know one thing you can do is you
can just you know create a proxy at sea
shadow password when you distribute so
is there other today one more quick one
and then well um I haven't tried it with
micro Lib C but it I don't think that
should be any issue guys I mean I don't
do anything special of Lib C it's it's a
file I include in the package I mean if
you can imagine binary that don't use a
little C and link something else you can
imagine static binaries - yeah I don't
imagine that will be an issue though
alright question here yes I'm so running
CD on itself so you the reason why you
can't infinitely recurse is that peach
Trace actually only allows you one layer
of tracing so that's actually very good
so Rob brought a great point of you know
one of the things that balances
portability it's actually not the
binding factor but you know what if the
CD binder itself is not compatible
across machines right because it has to
start somewhere the CD binary runs
native on the machine it doesn't you
can't supervise itself practically how I
deal with that is actually a CD is
actually very simple executable and it
has very small dependencies it has a
very bare Lipsey dependency and I can
trick the compiler into compiling
against a really old version of Lib C so
that it actually this 2006 bound is not
because it
CD CD is not the bound of portability
that's it that's a that's a good
question that any other questions this
point cool Oracle kind I'll join the
demo I'll bet right so there is no this
this true kind of gel like create is
it's a fake one there's I do not use the
true system called mechanism and the
reason why is because first true
requires root access to use and second
it doesn't allow you to kind of poke
holes in the sandbox Java say so because
I have this ignore mechanism that I
don't want to go into too much detail
but you know there's a way of
selectively saying some things should be
in the sandbox something should and with
Giroud you can't have that flexibility
but most importantly though is the root
access involved we don't want this view
privileged operation well all right so
I'm going to dive into the demo and I
think hopefully some of the other
questions will kind of fall out while
I'm doing the demo okay so in the demo
itself should show the slide also ah
okay so in the demo what I'm going to do
is create a package I'm going to do this
right I'm going to have I installed two
virtual machines on this computer on my
Mac one is an Ubuntu from oh nine and
another is an optics live CD of blank
Knoppix live CD from oh six I'm going to
create packages on new bun to computer
and then transport them back in time
about three or four years to an old
Knoppix machine and I'm going to do two
demos the first one involves Python
involves a scientific computing
scripting example the second demo
involves Google Earth the 3d map
application well so just introduce you
to the VMS this is the Ubuntu the 2009
de bonne - and you can see that you name
on here it's 2009 and my user name is
just my name my user name by name here
and the second one is an optics ah to
sleep and the user name here is just not
fix yeah soon as the font size okay for
everybody here great okay demo number
one
they'll say I'm a scientist and I'm
writing Python scripts to do scientific
data analysis this is very very common
so add some script it really doesn't
matter what does I just took this demo
from some someplace on the internet
there's some - script and like munch is
some London data set files but it was
like climate data for example so this is
a bunch of data so typically you would
run it like this right so you you run
your analysis and it you know it does
some number crunching and it plots some
data and this is what scientists do and
there's just some random data I plot in
and you interact with it and then
hopefully get some great scientific
insights so in order for me to have run
this program I need I need to have
Python installed but also need these
kind of third-party libraries that you
all this graph now I took all this for
granted because I've been on my computer
for years and I've always had these
installed or I install them once upon a
time and forgot about it and it's like
my computers always worked so now let's
say my colleague wants to run my
experiments they're like oh I love your
paper on blended and climate analysis I
want to rerun your experiments one to
verify your results and two to test my
own hypotheses to build off of your
experiments this is a very common thing
in science that people want to do so I
simulated copying the files over so
great so I'm like fun it's so easy right
there's like a Python script and a data
fine so you know what work you want so
this is the throw it over the fence
right I'll just give you my files I mean
everybody has Python right I mean
everyone has Python so what happens all
right I mean particularly something goes
wrong right this is something always
goes wrong because thing goes around
here is that there's no module name
dumped on so numpy is a third party
numerical analysis in math library for
python that you have to install
separately from regular Python so
there's all sorts of weighted ways to
install it depending on your system
it could be install from a package
manager it could be that easy or you may
have to chase down the dependencies
yourself and install stuff yourself
again this is going to lead to
dependency hell right and this is this
is one path to dependency hell you know
you try to install this you have to
install all their stuff and so on
actually numpy isn't even though only
dependency after this fails there is a
Matt plot Lib which is a graphing
library which has a ton of graphical
dependencies so how could CD help
so knowing CDE what we can do is we can
simply
just run our exact same command right
this is it exact same command prepayment
CD CD is in our home directory so I go
here this will start it up and create
that package right I'll just monitor all
the system calls it's running my program
it's monitoring all the system called
and copying all the files into a package
it takes a bit longer startup because
that sack this program has a lot of
dependencies so once it starts up you
can interact with it it's a regular
program execution nothing funny going on
so I can close it so now it creates the
CD package subdirectory so what's in
here first thing in the package
subdirectory is a CD exec executable
remember this is executable we're going
to use on the other end
once we transport it to the knoppix the
old knoppix machine to execute this is
actually the exact same executable CD I
just copied it here renamed it so it's
actually pretty simple CD full
environment whoa CD full environment is
all the environment variables that were
in scope while you're running your
program so we can recreate the same
environment variables on the other
machine which is important for things
that need like path or home or so on and
then there's some other stuff the most
important thing here is the CD route
right so I'm just going to look inside
so this actually looks inside and notice
how CD route it mirrors the directories
that I had right this is this is my
script right here I copied it in its my
data file this is my Python distribution
it's actually a third party Python
distribution with a bunch of libraries
pre-installed so notice all these ISO
files or shared libraries is some math
libraries for example these are other
Python initialization libraries fonts
and everything there's a surprising
amount of stuff that goes into just
executing a simple Python script
especially when there's graphics
involved all sorts of stuff
more importantly there's there's to
answer your question from earlier these
are the shared libraries from my system
right from user lid and from let's see
user share just all sorts of just
basically everything even including Lib
C right I just packaged up everything so
now I can just tore up this package
right because it's just a bunch of files
and what I'm going to do is I'm going to
tar gzip it and then send it to the
other virtual machine alright so let's
see how big it is
one hundred and seventy three Meg's so
this seems a gigantic just for two
pythons code just for a Python script
but because of those graphics libraries
just pull in so much stuff transitively
it actually ends up being pretty big I'm
going to gzip it so when I do the copy I
have to actually copy from the virtual
machine to my Mac to the host machine
and I'm going to copy it from the host
machine back to the other VM that's just
the easiest way to set up the networking
on here so I'll be this kind of two-step
process alright so how does this zip it
zips moderately well it's like 55
minutes so it's not huge so I'm going to
copy it to my host machine just SCP it
and then on the other end I'm going to
copy it back okay great
so I just copied it back
okay so this is it unzip it and this is
just what similarly what I would do to
give my colleague this stuff right I
would upload it somewhere email to them
okay so now we go into CD package
there's the CDE log file that just tells
me what commands I need to run inside
this package to rerun the thing that the
package create a ramp so first I got to
change into the subdirectory which is
where this all the scripts were and then
I run this command that I'll explain in
a second so once I change into here I
see that the subdirectory contains my
original Python script and the London
dot data file so as a reminder here's
what we are we're pretty deep in we're
in our real home directory inside the
package inside a fake root and in this
science demo directory so as a reminder
let's go back to our original bunch of
machine and we're here right we're just
simply in home Philip global Python
science demo ok and as a reminder here
we can just run Python and do the plot
so I just want to have this pulled up ok
now back on our Norfolk machine now why
can't we do this again these are just
Python files I remember this is why we
can't do it right because this running
Python runs the Python on the machine
itself which obviously doesn't have the
pen C's required so what else can we do
there's this Python CDE file that's also
in this directory that CD created and
all this is is just a shell script it's
just a wrapper and it just executes CDE
exec with the original Python command so
the reason why there's all this funny
stuff up here is because CD exec
actually resides at the top level of our
package so you got to kind of do this
awkward thing to get to see the exact
but that's why we wrap it in this
wrapper so it's easy to invoke so
remember this is as the slides advertise
you run CD exec with exact command which
is Python and take your arguments so if
we do this what happens so this you know
this wrapper is meant to look like
regular Python so this exact same
command except we're going to run it
with CD exec here we go so it pops up so
this is the exact same run before so
this is how my colleague can run my
Python experiment on his machine without
having to install
right and this is a fully interactive
app here sometimes different different
distros of different X server x' and
they have different cutoff warnings and
stuff so warnings you sometimes pop up
when there are conflicts graphical apps
but the functionality works all the time
so as a reminder this is not just that
this is running the real Python the
package right so if I type Python I'm
running a Python from 2006 and there's
no numpy if I run Python that CDE in
contrast I'm running the Python from
2010 I'm running the one from the from
the original machine right this is real
Python this is not just a just not a
replay of a tricks and this is this real
Python right here alright so so we can
do here is that we can not only can we
just run this I mean it's great to be
rerun it but more importantly if you
know my colleague wants my code they
want to actually modify it right they
want to actually mess with the code and
add some more components and do
different analysis and modify it so one
thing they can modify a simple thing is
they can change the y-axis right so this
y axis goes between negative 0.5 and 1.5
if they want to zoom into between let's
say 0 and 1 let's say they just change
the code ah I like VI alright ready they
change the code and now the codes been
changed and they can just rerun it I
mean this is just running real Python
this is not some canned trace or
anything right so notice how this y-axis
here is between 0 and 1 and on our
original ubuntu the y-axis is between
negative point five one point five so
yes question
great that's a great question that's the
question I was waiting for somebody to
ask so the question is you know what
this is a dynamic tracking tool right so
this can only be as good as a pass
you're executing so I mean this is in
the testing world this is your test
suite coverage right like you know if
you don't execute the paths CD is not
going to grab the required file so how
do we deal with this incompleteness
problem
the short answer is that usually you
actually are pretty robust because the
thing we care about is the files you're
loading so when when your colleague
actually modifies this script as long as
he doesn't cause a script like you say
import any more libraries if he says
import some crazy thing obviously that
crazy thing was in the package but if he
can actually make deltas and tweak your
script like tweaking the parameters we
can the algorithm and so on it should
still work the I have a slide later on
they'll they'll kind of explain this I
can I'll be happy to talk with you about
this lo afterwards but this is you know
it's inherently an undecidable problem
right so like no automatic tool can grab
every single dependency possible but
actually the dynamic approach actually
works pretty well in practice because
the intuition is that most programs load
most things that start up and then later
on some paths you might load other files
but as long as you know you're in the
same kind of neighborhood you're pretty
safe but that's a great question I mean
there is no automatic complete way to do
this okay so I'm going to finish up this
demo and give the other one so all right
so here we're done with this and then
I'm going to just glad so yeah so in
short in the Python example your
colleague can modify your experiment so
he can't run a whole new experiment you
can modify your experiment which is the
whole point of you hacked him in the
first place okay so I'm just going to
remove all this Python stuff just to
clear things up okay so the example I
just showed is the scenario where I am a
developer on the scientist who was
writing code and wants to distribute to
other people in a portable way and CD
allows me to do that right it allows me
to allows my users to run stuff without
installing anything the CD is also
useful when you're not even the
developer when you're just end-user
yourself I'm just an end-user myself I
can still use CD to package up
applications that were never meant to be
that portable so as an example I'm going
to use Google Earth so Google Earth for
Linux actually on the website the
average
guys that it works on any kind of Linux
to six kind of distribution I mean the
Installer is a one-click thing that
works fine takes a while to install but
this is installer I just grabbed from
the internet and you know it installs in
my home directory says great this is
like the process used to install any
software right everything looks good
perfect
okay so I think I can run the software
now because I've installed it right and
everything went well so it actually
installed in here so the executable is
here right here so what happens I try to
run this alright so basically the
problem is that the lips the most
fundamental libraries in this machine G
Lipsy and the C++ standard library are
just too old for the libraries that
Google Earth needs and this is this was
not document anywhere
I mean advertised it's supposed to work
right but of course on this machine
because the library is so old it doesn't
work and there's no way to get Google
Earth to run on this machine no matter
how many times they try there's no way
for this thing to run until I upgrade
those libraries and if I have to upgrade
the fundamental C libraries and see the
host library machine it's really like
I'm upgrading to distribution as I might
as well just have a new distribution so
you know why can't you ever get a
distribution wait a one is this is your
enterprise machine if this is your
production servers you can't just
upgrade the machine right you got all
this other stuff running upgrading
machine will probably break other stuff
this is unacceptable to upgrade machine
or you just might have a computer that
just has a bunch of stuff working you
don't want to you don't want upgrade the
machine just to run Google Earth right
for example because you have all your
favorite files and programs on there ok
so we can do though is I install Google
Earth on here also so Google Earth does
run on my bunch of machine because it's
like three years newer so it runs it
starts up ok so what I can do with CDE
is the following I can just run Google
Earth prepend with CDE
and it will create a self-contained
portable version of Google Earth so I
can run out my other computer
so I'll start up okay so let's like
visit some places so again this is going
back to your question of you know how
much behavior do you have to exercise in
the program before you get a good
package and this really depends it's
really an empirical thing so I'm just
going to exercise some typical
functionality like I'm going to like
visit New York for example and I'm gonna
like visit Mountain View there's not
really a good indicator of how much
visiting you have to do I mean I
obviously have to visit every place in
the world to get at your package because
most of the time all the library's
loaded upfront and maybe by visiting you
know maybe like just zooming in I get
like one additional library or something
but there's not a really good way to
quantify that so basically it's just you
know you try it and test it and you see
how complete the packages the one
recourse you have actually for adding
new files in the package it's one you
can run it more time so you can test
some extra functionality and to the
packages are simply files right so we're
a mountaineer the packages are simply
directories of file so you can actually
go inside and just stuff more files in
there yourself
so this enthralling thing will just
start up so um especially if you're the
developer if you're not the developer
you really don't know you know where all
this stuff is so notice how it's touring
of all these google earth libraries I
don't even know where Google Earth
installed so for what else the Installer
damn and the Installer might have put
stuff anywhere I have no idea I'm not
developer it also copies the standard
system C libraries which are really
necessary because on that Knoppix
machine those libraries didn't have the
the compatible versions so it's gzip
this
then we will copy it again to the host
Mac and I'm going to copy it from the
Mac back to the other distro all right
Shh
all right so reminder again this does
not work right so I'm just going to
remove this just to prevent any
confusion so let's extract the package
so this is a school or a package and now
I'm going to in the log file shows me
what I need to do right it's pretty easy
I just go into the directory my home
directory where I actually invoke Google
Earth first and as Google Earth this
Google Earth CDE is simply a wrapper it
just finds a CD exec and executes the
exact same command Google Earth Google
Earth and there we go
and now there's no reason for me to
visit the same places right so let's try
to do San Francisco let's see what
happens so this is pretty much running a
native speed it's hard to tell because
everything is slow in these VMs because
I don't have this is a really old laptop
but pretty much can go anywhere in the
world now I mean I just visited you know
I just visited two places just to test
out the waters I might have only needed
to visit one place just to test like the
zooming functionality but on this goes
everywhere and I can even activate the
3d buildings view it takes forever
because the VM is slow I mean this is a
full on Google Earth right here right
and so in summary what I was able to
accomplish this demo is that I was I'm
just a user of Google Earth I can run on
my own computer I package it up with CD
one command switch it over and I'm able
to run this you know huge monolithic 3d
application on an operating system that
is where it is impossible to run the
program right I mean it would be
impossible for me to run this program
without CD so yep ok cool
ok so any questions about the demo yes
ok let's talk about great this is not a
planet question this transition to the
next phase this slide so it was released
a few months ago we have thousand
downloads emails from user so ok so what
a real-world use cases these all come
from users ok this all come from users
number one actually distributing
self-contained portable software
packages licensing isn't much of an
issue if everything is everything is
with a reasonable open source license
right so
that is true that is true um if you
actually want to make it fully public if
you want to be fully GPL complying you
have to do that it's up to the it's up
to the you know people have done it so
yeah I hope I don't get in trouble don't
get in trouble maybe don't report me to
report them right there are yeah my
hands are washed clean of this so I'm
just going to forward other people did I
didn't do any of this okay first thing
distributing packages right so if you're
distributing software usually what
happens is you have these requirements
right download this download this
download is compiled this it's
impossible no I can do it
number two allow users to run live demos
of prototypes so this is an internal
thing so this is not as bad in terms of
licenses just you know you're
distributing internally within your
organization so this could be
proprietary code you've written you're
not letting anyone outside your company
see it so prototyping is very important
because when people want to try out
different things that experiments you
really need to have a good way of
distributing it and if you're hacking a
prototype you're not going to go through
a packaging thing in order just for a
few colleagues to run it so next use
cases deploying your computations to a
cluster again for if it's a cluster your
university owns and stuff it's fine
you're not making it public this is
important because if you have some
computation you're running on your
machine like you have some scientific
experiment you just want to it's
embarrassingly parallel you want to farm
out hundreds of jobs you can just farm
out CD packages to your cluster without
installing anything on the cluster
usually on clusters you don't have root
permissions you can't even stall
anything that's what other people have
used it for another thing is reproducing
scientific experiment so that's the
Python demo I gave so you're a colleague
you're running some experiments you're
reproducing so you're not making public
you just having your colleagues run it
there's like I like your paper can I run
your experiments see use case next one
is running production software without
perturbing the OS so this is like on
enterprise on certain kinds of
production servers people have actually
use this to try out new utilities and to
kind of play around with them without
making dedication of installing because
they don't want to bring down their live
machine so there's this is the
people don't want to risk installing
stuff and the last one is running
production software
on native environments this is the
Google Earth demo it's like sometimes
you just want to run software another
machine that you know you have some old
machine somewhere that you just don't
want to go through all the burden of
updating so this is a Google Earth
example here's some just quick things
from people so this is some diary app
that someone made it if there's some you
know personal diary
somebody wanted email me and they wanted
to have a portable version that can run
on a USB stick because they wanted to
bring the diary with them to all the
computers he emailed the developer the
developer says said if you want to run
the application itself in the USB key
it's going to be even harder probably
the best solution would be the compiled
omona is yourself statically linking all
libraries it depends on into the binary
I've never tried using almond uh from a
USB key before but I don't think will be
easy so what the developer poses is
doing static linking which is really
pain because you have to get the static
version of all the libraries it's a big
pain and it's really hard and even the
developer says I don't want to try so
what do we do you ran CD almond ax
that's it I got I'm going to work on my
machine because for some because I don't
need a portable or I just installed my
machine ran at create a package and I
showed you the guy who developed it he's
like oh this is cool I'll just you know
I'll put it online and this is kind of
beta mode I didn't really test it very
robustly but at least it lets you just
download it from a USB you know move it
on your USB stick all your files are
self-contained in that folder so like
your sacred diary entries are all in
that USB folder and it's a convenient
way of running it some other examples is
graph tool this graph Python graph
manipulation library I mean look at all
these dependencies here like there's no
way I can even compile all these I mean
sometime you know these dependencies all
their own and something will go wrong so
instead you know the developer actually
created packages for trying it out again
this is the model of I don't want to I'm
not claiming the CD you can replace
permanent package management real
installers this is a good way of demoing
and trying stuff another example this
Arachne this web application security
tools and other security research tool
requirements the person put up a CD of
emphasis - cape the dependency he'll
write his words that you know you can
download the packages escape dependency
how or you can download all these things
app get all these things you know you
know something's going to go wrong we
try to I've got one of these things and
his users actually have complained about
I just can't install your your tool
because they're just so many
dependencies and he wrote me just make
your email saying without CD
would have to manually duplicate CDs
process and package of everything by
hand or disappoint most of my users my
guess is I would have taken half the
time the development process to create a
self-contained package by hand which
would be an unacceptable and truly scary
scenario and I looked in his blog
databases about database consists of
dozens of people complaining that they
can't even install his thing and now
1-click installs it last kind of fun
example this one I made myself is a
Google Chrome so similarly to Google
Earth Google Chrome can not run on older
machines and this actually is not even
supported so I ran Google from a 2010 to
a bunch of machine a modern machine and
I back ported it to that 2006 now a
spreadsheet same one I saw you can see
it like tabs open everything so that's
it this is a tool and here is the
website so I'd be happy to take
questions at this time environment
variables perfect yeah so environment
variables so by default copy all the
environment variables over but with the
other gentleman's question I have an
ignore list also so there are some
environment variables I actually ignore
again this is pre so like exit Authority
some display x windows type stuff so
again it's um
by default copy everything and it's just
a trial and error process you know
getting all these users seeing what
their complaints are and is slowly
adding to this kind of magic list of
things and turns out that you know
efforts hundreds of use cases and stuff
quite a small list I can actually show
you offline quite a smallest maybe a
dozen things a doesn't you know /proc
slash sis certain environment variables
about a dozen covers covers everything
alright thanks the question</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>