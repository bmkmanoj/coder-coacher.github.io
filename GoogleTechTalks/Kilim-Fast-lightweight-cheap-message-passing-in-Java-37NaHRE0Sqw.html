<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kilim: Fast, lightweight, cheap message passing in Java. | Coder Coacher - Coaching Coders</title><meta content="Kilim: Fast, lightweight, cheap message passing in Java. - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kilim: Fast, lightweight, cheap message passing in Java.</b></h2><h5 class="post__date">2008-06-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/37NaHRE0Sqw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is my friend pretty awesome who is
going to tell us about bringing message
passing the courtesy to Java if you
don't care about July never had trouble
with her locks or thanks Anna just as a
brief note some of the techniques that
I'm going to be talking about our I'm
sure equally applicable to other
imperative languages with pointers so
although it says Java the framework that
I have developed is for Java but many of
the techniques are still more globally
applicable and so I was working with our
no and for the longest time in industry
developing high-speed high-performance
transactional frameworks and the last
thing that we did was write the weblogic
application server together and in all
the pieces of software that I that we
developed we ran into concurrency issues
whether it is device drivers or you know
middleware you run into concurrency
issues and there were a bunch of
problems that I wanted to tackle that
keep running into these over and over
again so as a background as we all know
processors processing is getting
increasingly distributed multiple cores
per box multiple CPUs per box multiple
boxes multiple data centers so a
programmer not only has to worry about
distribution at as micro scale its
distribution at a macro scale as well
and everything is distributed there is
one characteristic that concurrency
solutions don't really deal with which
is isolation meaning they deal with it
but it's not given enough respect and
more often than not you run into these
issues where you need something to be
tested and run in isolation and if you
have a lock based system it or a shared
memory based system it's really not
isolated it's not testable in isolation
so to me that's prime car
istic and current problems with
concurrent solutions are how to get
safety along with speed you have to
worry as a programmer with about memory
models and consistency and
double-checked locking and all kinds of
things where to use volatile when not
use volatile stuff like that and of
course the problem with shared memory
concurrency are well known and one of
the things that is important is
incorporating external actions so for
the most part when you look at
concurrency solutions or the examples
that you will see they have to do with
manipulating data structures put a
synchronized block or how to deal with
multiple producer consumers or red black
trees or whatever if you look at
examples but the moment you put in an
i/o action everything changes because
the understanding is that you don't take
a lock and then wait for a file i/o to
complete and the moment you have
external actions the solutions are very
different and that's where all the bugs
come in it's very easy to get a data
structure manipulation right but the
moment you have to interleave all kinds
of external actions you will get it
wrong and that's where because you are
increasing what you thought was
originally atomic you have to break it
down into several sub tasks which
involve IO interleaving and that
including essentially gives you all
kinds of problems with the original
intention of atomicity of the entire
task that you are originally intended
and the final sort of background for
this is that I see server applications
has staged data flow networks and this
whole staging dataflow thing is coming
back in a big way in other areas as well
if you look at graphics using graphic
cards for embarrassingly parallel
computation you know this meme is sort
of coming back so there are lots of
things feeding into why I went with
Killam and message passing as a as a
more fundamental construct than using
shared memory so I tend to see message
passing everywhere now and it's not new
this has been there since tony hoare
talked about
communicating sequential processes so
message passing everywhere and share
nothing so this is a lung idiom and if
you if you will this is my ode to
earlham so shared nothing involved is
equal into a failure isolation right if
you don't share it's good it is easy to
reason about and debug it's easy to
reason about that that's a reason why if
you look at any closest calculate
whether it's CSP or I calculus or any of
the process calculi they are all process
and message oriented and there is no
reason why you need to have two
different mindsets one to reason about
and want to develop it so if any of you
have done you know model checking with
with spin or pramila you have this you
know message passing view of the world
and then you transfer it to the shared
memory view of the world and there's a
huge disconnect between the tip and I
would like to eliminate that distinction
likewise with concurrent and distributed
programming there are two different
mindsets one you do local shared memory
thread based programming and then you do
distributed stuff the two different
mindsets and lot of it doesn't need to
be that way and to me sending a message
to disk is just as asynchronous it takes
a little bit of time before it comes
back as you know a remote computation so
I would like to see a more common ified
view of both concurrent and distributed
program so message passing neatly fits a
bill but in order for message passing to
succeed you also need lightweight shreds
you which is one of the reasons why it's
not taken off i believe which I'll cover
soon and the features that I like about
we're having very lightweight treads
first of all because it's a thread you
have automatic stack management so you
can have no ABC you can call and you can
write it sequential and let the system
worry about the managing the stack and
the second part is that if you have
extremely lightweight reg and i'm
talking about having the possibility of
having millions of these little
lightweight things on a humble laptop
then you can easily map it directly to
use a level concurrent tasks so in your
case so if you have a HTTP request
coming
that can be broken down into lots of
subtasks like parsing you know
negotiation with with security you know
lots of stages there and there are some
stages that are very short-lived so
parsing will be a very short-lived thing
but if it involves security negotiation
of any shot and he sought that becomes a
slightly more longer-lived tasks and the
idea is to be able to spin off these
tasks without thinking about it right
now if you have just kernel threads you
do think about it it's heavy weight so
you tend to form thread pools all that
kind of stuff and you should not have to
think they're that way at all so that's
a background and I believe that one of
the reasons why message passing of some
of the reasons why message passing has
not really taken off and you can correct
me if I'm wrong is that the general meme
is that asynchronous programming is hard
and that's probably because most
successful languages don't deal with
asynchronous programming very well you
have callback based programming
basically which tends to be verbose and
control gets inverted so if you have
something that's written with callbacks
it's difficult to figure out what the
flow of controllers the other problem is
threads have traditionally been very
heavy weight so you don't think in terms
of having you know tasks and now our
threads and message passing between
threads so for more often than not you
will see this message passing as a meme
in fact if you search for message
passing you will almost always land up
with mpi because those are the kinds of
tasks where the computation takes a
whole lot of time and so having a
heavyweight process sending a big
heavyweight message is really not an
issue but it really message passing at
the micro level has really not taken k
has not taken hold and the third part I
believe the reason why my sis passing is
not even hold is that it's seen to be
expensive in order to guarantee safety
in order to guarantee interference
freedom you need to copy a message right
all you have immutable messages and
context switching also is expensive so
essentially these are the reasons I
believe that message passing has not
taken all
and I have addressed these issues in
this framework called kill'm kill'm is
the name that's used for Turkish rugs
it's used in all over Eastern Europe
also so it's got very it's a flat weave
rug with fine threads and very flexible
so hopefully you will see the analogy so
also lightweight threads message passing
is central and I will qualify what i
mean by lightweight like they say beauty
lies and I the beer holder trick
messages are this is a distinction
messages are distinct from objects so
there are objects java objects within a
threads ultra lightweight treads space
and then the unit of currency that's
actually transferred across is a message
that is philosophically different from
objects and it's not just
philosophically different i enforce that
philosophy so one of the things that are
in force is or two things that enforces
no internal aliasing which means that a
node may not have more than one incoming
heap pointer so i don't care about local
variable aliases i do care about pointed
a laser so a node or an object within a
message tree or message graph I guess
doesn't have more than one incoming
pointer which basically means that it's
forced to be trees chip because at most
one pointer incoming which means it is
for sweet reshaped so that means that
there's at most one path leading from
the root to any node and it may sound
restrictive at first but in practice
it's turned out not to be very
restrictive because most events event
based systems you look at the x server
or you look at most even bae systems you
look at her lung message is actually
tend to be simple and one of the reasons
is that you think when you look at
failure isolation as a as a way of life
you tend to make things simple and open
the interfaces are very simple and open
and so I've nearly enforced that
observation and once you enforced
something to be three structure it
very nice inductive properties and the
second part is linear ownership transfer
which is if task a sends a message to
task being tossed a completely loses
visibility of a of that message so it's
exactly like saying free in see where
you once you are delete once you've
handled over the pointer you don't own
it so semantically it is a dialect of
Java syntactically it's it is Java but
semantically there is a additional
constraint that's been placed which says
if you are sending a message then you
lose visibility once you have sent it so
if you want to send a mutable message to
multiple recipients then it is your it's
the onus is on you to make a copy by
default I do not make a copy but I lose
ownership so essentially that means safe
and 0 copy message passing right the you
can have a mutable message that belongs
only to one space and it's logically
transferred over to another space and
the original sender does not get to see
it again at all and the final thing that
this package has in fact in addition to
this it has a code generator as well
which will create this which will see PS
transform and create lightweight trades
is the runtime library which contains a
scheduler you can write your own user
level scheduler it has typed mailboxes
and I'm like many like CSP based
frameworks or whatever I don't have the
mailbox as a first-class perimeter you
can create your own concurrent
concurrency primitives like futures or M
bars or whatever and take advantage of
the type system and of course I'm words
and stuff like that anyway so I just
want to give you a brief overview of the
programming model a Killam task is very
much like a threat the program one looks
exactly like a thread where in this case
it's a HTTP connection which extends to
tasks so it's a task / connection model
so instead of exchange thread I say
exchange task instead of public void run
I say public void execute and after that
i have this annotation called possible
possible tells the code generator that
this may pause essentially that means
that somewhere deep down
it may call another method that may
pause and the built-in possible methods
are sleep and yield okay so possible is
in someone some sense like a checked
exception where if method calls another
possible method it too must be declared
possible okay so this is to pinpoint
those methods that need to be
transformed why the code generator okay
the eventual transformation is very much
like what you would write by hand which
is the return to main loop mentality but
you can write it in sequential form and
you don't have to worry about it it does
all the capturing the closure you know
ripping the stack all that stuff is done
automatically and rescheduling it at
appropriate time all that stuff is done
for you right so you write it in thread
like automatically stack managed form so
in this case you have a while loop right
it doesn't have to exit the loop so you
write it as if you're writing a check
and if somebody calls like in this case
if it says wait for socket then until it
gets the next message this will be
swapped out and you know some other task
will be executed okay so that was a task
pot and between tasks the mechanism
right now is is a simple mailbox which
is just like a queue which is a queue
basically with multiple producers and a
single consumer and it's tight so you
can say in this case it's in a loop it
says mailbox target process the message
out mailbox start foot and as you can
see this execute is possible and in this
case it needs to be possible because get
is possible and put as possible get as
possible because it will pause and until
it gets a message and put as possible
because it will pause if the buffer is
full you have a question
good question so the question is is
there any convention that is there
anything that enforces a multiple
producer single consumer not at compile
time at one time yes so if more than one
more than one task waits on the same
mailbox if says male dogs don't get in
they happen to be concurrently waiting
for it one of them will get an exception
the yes yes all mailboxes are multiple
producers in sokoto tuba but i'm working
on a different flavors sync including
synchronous mailboxes including em bars
including multiple producers multiple
consumers that kind of stuff building on
top of it but as far as I'm concerned
this is merely a library the it's not
sort of baked in to the semantics of it
yeah that's the difference between CSP
and this scheme where mailboxes just
happens to be one facility you can roll
your own and finally the code generator
which I call when pushing the kill em
analogy a bit much it's called weaving
which which takes a class and transforms
it and dumps it into a directory of your
choice or you can supply it a an entire
directory of classes and whichever
classes happens to be which happens to
contain possible code will get
transformed and dumped into the
destination you can overwrite the source
directory as well and the Weaver will
preserve or will correctly adjust for
all the debug information so that you
can debug the stuff in Eclipse okay so
I'm going to take a look at some of the
transformation and the messaging part so
this is a fairly straightforward
transformation I look at continuation
passing style transformations and they
really don't apply very well to jvm
based languages because they don't have
tail call optimization support so but
it's equivalent and these are one chart
continuations so it's sort of like co
routines
so the scheme is fairly simple so if I
have a method like this foo and let's
say bar happens to be a possible method
as well and print is not print is just
system dot out dot print line so bar
needs to pause what are the reason right
what essentially happens is that if it
needs to pause let's say bar calls sleep
what happens is that it triggers a stack
unrolling so it informs sleep informs
bar bar informs it's colorful saying I
need to unroll the stack so save
whatever state you need on for
resumption and return so bar Paul sleep
sleep at some point we will essentially
say return the bar bar will recognize
that Oh sleep is not done yet it will
return foo will need to check Oh bar
need to return but it's not fully done
yet it will package I and O because
that's the thing it needs to use those
are the two variables it needs after bar
and eaten squirrel whatever state it
needs so every activation frame as the
stack is popping every activation frame
squirrels away whatever stated deeds and
returns okay and clearly the way to one
of the ways to do it is all the stuff in
yellow is the is the code that I inject
and there's some bit of coded at the top
and some bit of code around every
possible method so the first part is
that there is an extra parameter added
to all possible methods so like the bar
as with foo there's a fiber that's
attached a fiber is essentially an
object that thread through the call
stack and so anything that you need to
squirrel off squirrel away you attach to
this fiber so every activation frame as
its popping it attaches stuff to the
fiber and pops and so the fiber is the
continuation it keeps track of the
entire control and data plane that's
needed to resume
right so when Bauer returns f is the
out-of-band information which says which
is checked to see whether it's returning
prematurely or whether it's done so if
it says it's returning prematurely that
means it's posi then this activation
frame each is squirrel away the label to
which it each jump to when resuming the
pc and I and O which needs which it
needs after resuming that's a state in
this activation frame that's of interest
it will store this and return foods
caller will do the same thing and so on
the star collapses and the scheduler
will will resume the next fiber right so
it's exactly what you would do in a
state machine if you want to write it on
your own all the stuff that you is
necessary for you to squirrel away you
have to manually do it and do a return
to the main loop this does it
automatically question I'm sorry how do
you make it work for non-void functions
what's the default for the return value
so let's say if it is an integer I can
return any dumb dummy value it's never
check so anywhere where there's a dummy
dummy value I can return whatever is a
default for ins or bullion's or pointers
right so coming back to that when
resuming so again the whole stack is
built up the scheduler will call execute
execute all fufu will call bar and the
way does it is it essentially the weight
sex of the stack is inside foo it says
it does a computer go to to F dot pc
jumps directly to l 1 bar will directly
jump to where it left off and so on all
the way and it will say if it needs
restoring restore the stack the
activation frame that it needs and
continue from where it left off so there
is local surgery around every possible
call which essentially restores all the
local variables and the operand stack at
that point so there is there are lots of
details i'm not talking about for
example you can't just shamelessly jump
into latina into a loop we can say say
go to someplace because the JVM
definitely checks whether the stack is
balanced where the types are right so
I need to pad all the local variables
and the stack with dummy values in order
to get the types to check so I do a
fairly detailed data flow analysis also
make sure that duplicates are weeded out
I don't even if two variables happen to
have the same value then I don't
understand least go a little bit both I
just have an instruction with just a
dupe of that know stuff like that so
there's lots of constant propagation all
that stuff is done automatically but you
would think that you know popping all of
this stack and restoring it all of it is
quite expensive it's actually not really
expensive in the default case you if it
never pauses because it essentially
involves two extra checks but other than
that nothing really happens so it's
pretty much at standard speeds it
doesn't take much of heat but if it does
pause then of course you get something
for that some convenience for what I it
provides so you would think that all
this now stack ripping will be slow
turns out it's such a it's plenty fast
and the term concurrency oriented
programming has been sort of
appropriated by her lung and so I
thought I'd refit to be good to check
against along so here's a micro
benchmark which takes say a ring of
tasks and not a ring actually there are
n tasks he's sending a message to
everybody else so n minus 1 messages n
minus 1 responses and a final messaging
I've done so now there's some lake n
squared messages here so three thousand
thoughts nine million messages in about
less than four seconds so that's about
four or five microseconds per message
which include evil context switch right
actually the context which is the only
thing so you're you're unrolling the
stack and rolling the stack for somebody
else and all the time it's actually
quite fast and Earl on which is also not
too shabby in the scheme of things it's
plenty fast which 1.4 microseconds but
you can see that people keep saying that
you know Java is slow but the runtime is
actually a fantastic run time and you
can get you and I can create lots and
lots of tasks for example
this particular test have created
200,000 of these and I can create half a
million on my old laptop without much of
a problem here yeah yeah yeahs along on
our linux on which it's best done on an
SMP box with hype enabled yeah and
likewise I see far better results with
compared to Haskell now you would think
that Haskell should beat this out right
right they have tail call optimization
they have no mutable stuff I in fact
that they have no reason to be slower
but it runs circles around her at this
point when GHC minus 0 to code anyway so
that's the task part so the takeaways I
mean I don't want to push the Earl an
analogy too much because I have enormous
respect for the fourth at runtime but
you can see that I mean it's a
reasonable case to be made for very
lightweight tasks the second part is
inter task messaging and that's a type
system part which I need to discuss how
do you make messaging safe so the
options are having immutable messages
you make copies you can put a lock but
that's not really message passing you
can have fancy type systems you can have
linear type systems ownership types lots
and lots of typing schemes to control to
deal with aliasing and I have my own
brand of sort of a pseudo linear type
system which does put some constraints
on the way you on the shape of the
message like I said it's tree structure
and that essentially makes some of these
things like ownership types the reason
they are so complex is because they have
to deal with the generality of Java and
I decided to make a trade or there and
say that i'll i'll put some constraint
on what messages against sent because to
me they are philosophically different
from messages and I'll explain why
mutable messages in kilim are different
first of all I mean you have to
implement a marker method called message
and messages can contain primitives
references to other message types and
arrays of these and all immutable types
like string and date and whatever else
you might choose the important thing as
I mentioned is that ownership is passed
linearly and no internal area singh is
allowed and other thing which the
philosophical difference is that I
encourage a non encapsulated structure
everything's out in the open it's
exactly to me as if it's equivalent in
spirited and on the wire representation
or an XML format or JSON or whatever if
you have a message it's open its open to
be audited log-transformed you name it
right so it's different and likewise I
think in your case when you do MapReduce
you're all the structure that is
actually send all the message that is
sent he is open right and that actually
makes it so that allows things like
scripting languages to be used as in the
in the in the data flow without much of
problems so I looked at your google app
product and the interface is actually
very very simple because and it can be
completely encapsulated in a tree
structured form so going in and out of
scripting languages does not have to be
a pain as long as you keep to this tree
structured and open a reflexive types so
how does one do this type system it's a
fairly simple thing I associate
capabilities with every node in a in a
message tree so at the very basic amount
you have the notion of modifiable the
the trees modifiable the trees
unmodifiable or the trees unusable those
three basic capabilities and by
modifiable I mean that structurally
modifiable which means you cannot add to
this tree or this tree cannot be added
to something else right it's you have to
leave it as us so the basic capabilities
are there is modifiable or unmodifiable
or unusable I make a slight distinction
in the modifiable case a sub class on a
subclass or some distinction where I'm a
distinguished between the root of the
message and the rest of them the route
is called free so in some sense i have
four capabilities free cuttable safe and
invalid and that is the order that the
lattice if you will free says it's
modifiable and it's a root of a tree
cuttable says it it is not the root of
it reach some intermediate node but it's
still modifiable meaning i can add i can
modify its fields structural that means
i can add pointer its i can change its
pointer valued fields I don't care so
much about whether you can change its
primitive fields right I only care about
the pointer valued fields because that's
what messes up all the the aliasing is a
big problem so the fact it is modifiable
unmodifiable unusable they are all
transitive properties so all of it is
modifiable all of it is unmodifiable or
all of it is unusable so it sort of like
a deep const deep invalid whatever right
so I'll concentrate on free and safe and
invalid because so every node has these
capabilities and so the way you can
modify structures is clearly through an
assignment you say X dot F equals y and
you change the structures right so I'm
going to look at two sets of rules once
for assignment and one is for method
calls assignment you see extra difficult
why I have a note here it's a node here
that's referred to by a local variable X
and another tree here which is why
clearly in order to maintain the
invariant that a this particular node
cannot have more than one incoming
pointer the right hand side must be free
it must be the root because if it was
already being pointed to by somebody
else I cannot have it on the right hand
side you know and assign it to somebody
else right so one of the things that
drive system checks the precondition is
that the right hand side is free right
and having done that I need to change
clearly this is not free anymore it's
because it's being referred to this guy
it's still modifiable but it's not free
anymore because it's no longer the root
so i need to change its capability to
cuttable so it is downgraded so
essentially from being free it's now
attached to an another structure the
local variable changes capability so
there's a precondition and there's a
post condition in the post action sort
of changes appropriate capabilities and
if there is a third variable say Z that
was aliased y&amp;amp;z were the same thing both
capabilities both y and Z's capabilities
would be changed so the flow analysis
sort of the static analysis takes care
of all of that stuff this is slightly
different from your typical type system
because each type is changing with the
assignment with normal type systems they
are flow insensitive this is a flow
sensitive type system so yeah
does it really I guess my question is
would be easier to institute basically
changing
to introduce the ocean
a first class object called message that
just
the question is can you does it really
need to be this yeah so does it really
need to be this complicated can you have
a first-class message type that doesn't
have pointers and where people have done
it they have value types right you don't
have to but I wanted to make it work
with existing tools existing messages
existing means right so so the point is
well-taken that there's no existing type
that already the message so what am I
being what am I catering for so I guess
I'm more catering to the existing
mindset of dealing with pointers having
pointers right and it just makes my life
easier to to do that and plus it gets me
a PhD so no I'm not I'm just kidding no
but I mean each sense that if you have
to retrofit in Toronto something like
C++ right you need you need pointers so
there are for example x-mas is a chip
company that I'm talking to right now
that has a language called XC that does
not have pointers it is C but without
pointers it feels like a very different
language so if you are a
dyed-in-the-wool C++ Java programmer
it's it's one thing to have you know a
different type system altogether or to
incorporate pointers that you already
know and love right so the point is that
take for example in this case you have a
pointer to an array each fairly
straightforward even if you're a sea
program where you just know you can do
your beloved people are pluses and stuff
the issue is when I do things like
distribution pass messages between notes
I you know I avoid avoid Milton
serialization mechanisms like the plague
actually
create create a message that doesn't
actually use Java type just because
because we know
educated
right that's so so what what you're
saying is that you're you already know
what you're going to distribute and so
you write your exported types the ones
that are going to go on the wire in a
particular way so that they're good for
serialization but the point is that i am
catering to both concurrent or local
solutions and remote and as a writer of
a particular task i do not want to worry
yet when I am writing I don't want to a
priority decide whether it is going to
remote local or in a different language
yeah so point well taken value types are
there yeah it's a different solution and
there are work has been done on that so
I've I've gone with pointers because you
can do things with pointers in language
like Java and C++ where it's just more
convenient right because the idioms are
sort of alone so how do i get these
capabilities assigned to all these nodes
in the first place so i have an event
class and let's say I have a fool method
which says annotated the same
capabilities have free and safe so
essentially i am being told that foo
knows that this parameter is going to be
free whatever argument is going to be
supplied is going to be free and
anything that is being supplied here is
guaranteed to be safe so that's the
interface contract foo says that I
promise to treat messages safe and I
promise to treat EBS free essentially
what fools telling its collar is that I
can do what what I want to do whatever I
want to do I can do with Evie and I
promise not to touch message I don't
promise not to leak it I promise not a
structurally modified that's all so so
to begin with these are the capabilities
I know of and a flow analysis will
basically tell me everything everything
about the particular thing so here p
equals new event i have a new object
which is P and it is free because it is
a new object nobody else is pointing to
and then I say message dot a equals P
clearly this is a compile-time error
because message is safe get better i
will be modified so it it cannot be on
the left hand side right I cannot
structurally modified EV dot equals P
that's fine so now it has set up this
link saying p is now hanging off of eb
it is also made sure that p is no longer
free because it's now being pointed to
by somebody else and this is an attempt
the next one is an attempt to use
something that's not free no longer the
root on the right-hand side so clearly
that's an error and the last one says an
attempt to use message which is
considered safe I cannot export it I
cannot Elias it I can only get through
some with some other channel and so this
is a compile-time error so essentially
given these two annotations and
something like new I can infer through
all the control flow all the nodes that
matter
yeah so I don't want to do
interprocedural analysis because
interpretation analysis also means whole
program analysis right so I want to
avoid that so it is intrapersonal that's
right so save us d constant yeah
so that was about how to infer
capabilities and this is a second part
so one set of rules we have seen for
assignment and other things for method
calls so in this case until this point
it says Q equals P dot F so that's the
image I have P and Q hanging off of P
and print queue that's fine because
print says I'm going to I'm not going to
touch it it's going to be safe don't
worry so that's fine call print mb dot
put Q mailbox or put says I'm trying to
send it but it's no longer the the route
so I can't send it okay so it needs as a
tour so happens the signature says it
needs a free thing untethered completely
nobody else should be pointing to it and
you better let go of everything so M bit
output Q is a compile-time error mb dot
put p is fine because p is the root of
the tree that's fine you can send it
it's not safe it's not much safe so no
problem you can send it but as soon as
you have sent it it loses visibility the
caller loses visibility which which
means that anything thats hanging off of
p is is considered invalid so at this
point if i attempt to use p this will be
a compile-time error saying invalid so
essentially you've given away p and
anything that it points to and you do a
conservative analysis to figure out what
it could potentially go to you pointing
to that's your rule for method calls so
essentially you have the room for method
calls is really simple you only supply
it must at least have as much capability
as that the target is demanding and if
the target says if the target argument
says that it's going to be free then you
better let go of everything that that
pointer points to ok so all this sounds
fairly complex but you you don't really
think about all these mechanisms it's
sort of like I mean the vm does a fairly
decent static analysis for null pointers
or something that's not been assigned
yet but you don't think about it it just
says oh it is not assigned not assigned
yet then you go and assign it you don't
think about all the mechanics of it so
in practice you don't need to know most
of the stuff right you just
to know what the stuff i'll skip the cut
operator cut basically says it gives you
the capability to to snip an edge so a
little bit about the static analysis
here I do something called shape
analysis and of all the heap analysis
methods I've seen shape analysis comes
closest to my problem where I can create
an abstract view of the heap like in
this case what is hanging off of what
right p's q's hanging off of P and stuff
like that image you have an abstract
graph that you need to build up for
every point saying who is related to
whom so that if one pointer is sent and
I want to invalidate something else when
the other variables that might be
related I need to have a conservative
but as precise as possible understanding
of what else might be hanging off of
this so that you don't inadvertently use
something that was you are not meant to
use right that could potentially be
hanging off of the point of the descent
so I do the shape analysis and if you
notice this original notion of transfer
of ownership between the tasks has been
converted to a different problem of
transfer of ownership between methods so
instead of saying sending from one task
to another the problem has become
sending from one caller to Kali and if
the Kali just happens to be doing stuff
with kernel threads that's the Collies
business because if it says free your
job is to supply it a free pointer and
after that it can do whatever it wants
including not send it on another tech
but that's its prerogative which is why
with this type system you can
essentially roll your own primitives
like futures or whatever and not have to
worry about mailbox is being built up so
to summarize kilim has these lightweight
tasks with automatic stack management
and failure in state isolation the
negative part is that it's cooperated
tasking which is the thing I like about
her long because it's pre-emptive
lightweight threads and pre-emptive that
would be nice but with the vm i don't
have control over the vm for messaging
it as fast as safe the receiver can
clearly reorder request because after
all it's a buffer that is receiving from
there is flow control mailbox as a flow
control
and open structures are good for you
know you can essentially it's it's nice
for putting probes in there and doing
filtering and transforming the message
and stuff like that and open structure
is really help you can say that the
downside is tree shaped structures but
it's really not a problem in practice
and also it's the case only when it's
mutable if it's immutable then I don't
care what shape it is as far as ease of
use is concerned it's a uniform syntax
so if you dump something into a mailbox
and you lose all ownership of it if it
just so happens that that mailbox is
connected to a queuing system that's its
rocket up so the view of there's no
distinction really between distributed
and concurrent programs there are
failure modes that might be different
but at least a mindset is the same it's
just message passing it's easy to
monitor because essentially the view of
a task is the external view of a task is
essentially what goes in and comes
through comes out so mailboxes and so
you can put probes there so it's you can
view it like a hardware thing you can
put probes on the pins and you can it
coexists nicely with existing classes
and so I'll leave you to read the paper
about how it does the coexistence the
downside I would say is that you have to
a priori decide what the granularity of
the task is and that's a problem with
threads with processes whatever you I
mean I'm like I mean the only place
where this stuff has been solved is I
guess embarrassingly parallel programs
where you can do know if the compiler
can figure out whether whether the
computation in a particular array can be
done in parallel and stuff like that but
in typical you know non mathematical
tasks I don't have an idea for to solve
it anyway yeah and I don't know if any
other solution that does it anyway so
that's about it I a few references here
about shape analysis about one of the
seminal paper is called alias body and
this is a paper that I'm going to be
presenting at a coop this next month
so that's it so if you have any
questions I'd be happy to take it an
hour offline all right thank you for
very much for coming
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>