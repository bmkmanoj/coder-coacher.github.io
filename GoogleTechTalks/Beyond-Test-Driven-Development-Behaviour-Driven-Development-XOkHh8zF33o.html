<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Beyond Test Driven Development: Behaviour Driven Development | Coder Coacher - Coaching Coders</title><meta content="Beyond Test Driven Development: Behaviour Driven Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Beyond Test Driven Development: Behaviour Driven Development</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XOkHh8zF33o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody thanks for coming to
today's tech talk we are fortunate to
have Davis tells the author of
test-driven development a practical
guide and unfortunately we are not
fortunate enough to have the books yet
but we do have a sparrow page will be
sending it out on on the inch talks
mailing list so look for that and we
promise you'll all get your book in due
time I also need to let everybody know
that during the Q&amp;amp;A section if you have
any questions that might bring up any
confidential information we save them
for the second part of the QA we're
actually going to shut off the camera
and that then you can ask anything you
like they've signed the NDA so anyways
without further ado I guess we're all
here to learn about behavior driven
development the next step after test
driven development Thanks yeah behavior
driven development this talk is in Ruby
because closer to the microphone I hate
those things I'm a wanderer yeah yeah
then I'm good but anyway I will deal
with that don't worry yeah this is in
Ruby we decided to start off in Ruby
partly because I wanted to learn Ruby
and see what we could do with its
language features so it's an easy up
easy enough language so everyone should
be able to pick it up if you have
questions about the syntax and whatnot
feel free so first about me we had a
pretty good job already test driven
development a practical guide i like to
say this the first time i've been to st
west when I didn't win a jolt award this
is only my second time and I also
co-authored a book an extreme
programming so I know how many of you
watch Steve Jobs keynotes but I got some
inspiration from that and also the
slides look a little dif I'm using
something akin to the taco
she style of kina a slide so if you want
to get my slides you can have them but
you're not going to get much out of them
without the audio so first off back one
BDD a lot of people are doing TDD some
people here are doing TDD TDD is
becoming more mainstream they're toxic
conferences there are lots of books out
now lots of information in the press
about TDD so everyone's doing TDD
everyone's happy they're getting the
maximum benefit everything's good at
 I've gone in and train
companies in TDD and talking to people
about TDD and there's a score of
mistakes that people make and mostly
it's because they're talking about
testing right when you're using TDD you
using something like Jane unit or n unit
and you have to start your methods with
the word test or you put it annotation
on let's a test annotation you extend
test case maybe you're making assertions
all very verification specific language
right you're talking about testing and
what do we think about when we think
about testing we think about I've got
some code and I have to know that it
works properly I want to verify that
it's correct right that's what we think
about most often when we talk about
testing so are being constantly barrage
with all this testing nominal kature
this testing baggage and what is TDD is
it testing well if you actually had
copies of the book the first line in
there says this is not a book about
testing it's about design it's a design
process so we want to stop talking about
testing right we want to get rid of that
what we want to talk about instead is
something that's an evolution beyond TDD
we want to talk about behavior all right
this is what we're getting too
and some people ask well what's the
difference you know it's still the same
and yes at a technical level it is the
same you know if you look at your java
bytecode it's probably gonna look very
much the same it's the way I describe it
is behavior driven development is what
you are doing already if you're doing
test-driven development very well right
the problem is most people aren't doing
it very well and our hypothesis is that
you're thinking that that's because
people are thinking about testing while
they're going so another thing think
about testing j unit and you are
purported as unit test frameworks right
so we have this word unit what does that
mean can I get some definitions what's a
unit someone there's a hand up you can
answer then fall small focus module of
code like a class anyone else a method
that somehow doesn't touch a database or
anything else that might make it
that's good I haven't heard that before
from an audience yeah something that
doesn't catch a database or something
else that would make it slow so
something that's isolated right and when
you're doing TDD that's what you want to
do you want to isolate what you're
testing so you know there's a couple
different definitions of unit so that's
a very nebulous term that's very vague
we want something a little more concrete
so we don't want to talk about units
because everyone has their own
definition and it's situational
dependent right maybe you're working on
a class now and a method later those are
both units in a sense so instead of
units we want to talk about behavior
right little fine-grained focused pieces
of behavior all the code you're writing
all the systems you're developing have
behavior have interesting behavior
otherwise you're just wasting your time
right if they don't have interesting
bits of behavior to them and that's what
we want to focus on we want to look at
not whether it's in a method or it's in
that class or its two classes
cooperating to produce it we're going to
look at I've got this little bit of
behavior in my system and I want to talk
about that okay I don't care where it is
in the system right in terms of how its
structured this there's a quote on the
sign for this it talked about the
one-to-one correspondence between tests
and methods or test classes and classes
that is one the biggest problems I see
with people starting out with TDD is
that the stay structure thing so the
structure of their test code mirrors the
structure of their production code so
there's a couple things that happened
there what happens when you refactor and
you you change the structure your
production code do you then go and
automatically change the structure of
your test code to match all right so you
shouldn't have to ask those questions
you should be focusing on behavior and
structuring your your tests or your
specifications and new word we use
around the behavior not around the
structure of your production code but
around what it does what the interesting
pieces of behavior
so now I'll pull out some linguistic
stuff anyone familiar with sapir-whorf
okay we've got some right it's sort of a
controversial theory but you know their
third I think there's some truth in
there that's spelled wrong isn't it
which I guess I was thinking okay the
idea behind safer Wharf is that the
language you use the terminology the
grammar etc in some way influences how
you think it's a language some in some
sense drives thought so the words you
use shape how you think so if were you
saying test all the time you know
there's a very strong likelihood that
that's putting you into a verification
mindset right so if we can step away
from saying test maybe we can start to
think a bit differently right so instead
of test-driven development take that
away and we'll start using behavior
driven development start putting the
focus take the focus away from testing
and verification to behavior right now
stop thinking about what's it you know
how do I prove that my code works to
thinking about describing what i want my
code to do right so get away from state
this is another problem that's pretty
prevalent least in beginning test
drivers the reliance on testing state
and probably the worst case of this I've
seen was on one project where we're
using reflection to get it right I
wasn't they were using it before I got
there straighten them out they were
using reflection in their test code to
access private member variables in the
production code so in the test code that
actually go in put some values into
these private members do something and
then go in and look at what was in the
private member's afterwards and that is
probably the worst example of
state-based testing the you actually is
a very good example of the state-based
test example the worst thing you could
possibly do because this is all fine you
know everything worked and the tests
passed and everything and then we went
through this class that was being tested
grew and grew is sort of one the core
domain classes and it got to a point
where is unwieldy so we said okay we've
got to refactor we've got to split it up
we've got different areas of behave
responsibilities in here so let's start
splitting it up so we do it fairly
conservatively we group the functional
areas and we pull out a class and we put
you know we delegate out to the new
class and gradually find all the callers
and prune them up and so we did this
with one area behavior and suddenly
things blew up all these tests started
failing why because that area of
behavior included a variable which we
moved out to the new class hunt variable
is no longer need it in the original
class we just had the methods delegate
and suddenly that variable wasn't there
anymore and because we used that the
test was using reflection that didn't
show up until runtime and it caused all
the tests to fail all right so look
depending on implementation state in
your test is a real barrier to
refactoring so we want to get away from
that so no more state-based testing and
if looks familiar with mock objects
excellent wow that's good mock objects
are one approach to getting away from
state based testing start looking at
testing the interactions looking at the
interactions rather than the state and
that's really all that behavior driven
development is doing is making that
formal that we're not looking at state
we're looking at interactions we're
looking at behavior what it does not the
internals of how it does it so instead
of state we want to look at behavior
right we get rid of the word tests and
everything that goes along with it
replace that with specifications all
right this is really what your tests are
when you're doing TDD they are
executable specifications of behavior of
your system
sure you can say that what do I say
we're doing computer-aided specification
evolution I don't buy evolution but yeah
we're writing specifications that what
Bob Martin I think says we're writing
specifications of the behavior of our
systems in such a precise way that we
can execute them right so instead of
saying dealing with assertions you know
j unit we've got all these assertions we
want to get rid of that that's test
centric as well verification centric we
want to set up expectations about the
behavior of our code right okay that's
the background any questions there and
he has the protocol
and it
basically a protocol you're putting
something in and you're seeing something
come out you control it you put in and
you know what you expect to come out how
you expect that interaction to to occur
so mock objects could be used there to
basically pretend to be the other system
you know what to expect coming at it you
can verify it that way anything else ok
back to our spec now we get into some
nuts and bolts at first I wrote a blog
post and I talked about behavior driven
development and sort of hand wavy form
and wouldn't it be nice if we could
write our specifications like this and a
friend of mine read that and said okay
you've been talking about that for a
while and me and a couple guys at work
working in a rail shop been thinking
about that and I think we're just going
to start writing this so they went and
like a week or so later they had a
rudimentary framework in place and we've
gone from there we're actually on
version 2 of the the guts of the thing
now so X unit we get rid of X unit
because it talks about tests instead we
need new frameworks meaning new
frameworks that are behavior specific
that our specification oriented and this
led us to our spec right / Ruby I have a
couple there are a couple people when
the guys I'm working with at the moment
who are working on CS spec for net and a
couple of us have started talking about
okay it's time to do with Jay spec which
won't look nearly as nice as I respect
but functionally they'll be equivalent
so from j unit we used to earth sorry
from test unit and Ruby and Jane at by
extension we look familiar with looking
at something like this all right which
doesn't read all that well assertequals
expected comma actual you have to know
the API have to know what the argument
structure is how many people when they
started using 2d DJ unit and unit
whatever consistently got these two
backwards Yeah Yeah right yeah and then
your error messages really helped yeah
so we get rid of that and would be able
to say some
thing like that right where actual is
our value that we're we're looking at
expected of course is that what we're
expecting to see you and say actual
should equal expect it so a result
should equal five okay so I'm just going
to go through the API that we've built
up for setting these expectations and
you can see what things might look like
so here we are for brevity on the slides
I've left off the target object but this
would be you know result that should dot
equal five and all these slides so it
should equal five most of these almost
all of these in fact have a negative
version should not equal five so for
object identity we should be should not
be this is an interesting one that the
guy I'm working with Dave Kalama Sookie
came up with if your target object
responds to a method in this case called
items so for the prototypical you know
car object that could be wheels right it
returns something that responds to
either size or length so now we can say
you know for example car should have
four wheels right so through reflection
we take the last last call there apply
that to the target object get back
something that responds to length or
size call that in this case it should
have the the length or size that we
specify we also have should have at
least and should have at most yeah yeah
don't we worry that something could have
both length and size and it certainly
meaning different things right yeah we
haven't thought too much about that yet
but that certainly is a as a potential
problem that there would be some
confusion there but you know the onus is
always on the developer to know these
things because they're writing the items
method for example and there
the specification and they know what
it's going to do and of course you can
always pass in a block to do some
arbitrary testing the target object gets
passed into the block and then you can
do whatever you want to make whatever
assertions I personally don't really
like this I think it gives you a little
too much rope but we had someone very
vocal that was working on it that really
wanted that back Dorian and it's nice to
have there so that you don't have to
sort of whine and complain that the API
that we built doesn't do what you want
okay just do it yourself of course Ruby
is good pattern matching so we have
should match should not match a regular
expression and you can do an arbitrary
predicate a predicate being a method
that returns true or false may or may
not take arguments in Ruby the
convention is to have the method named
with a question mark at the end of it if
anyone here is a lisp err it's like
thing you know predicate p right it's a
pretty good question so the target
object here is assumed to have a method
method called predicate question so
empty question might be one that you
know collections have so you could say
this result collection should be empty
and there's there's a little bit of
syntactic sugar you don't have on the
slide you could say should in the
predicate so should start right might be
with something or you can put a bee in
there which is just syntactic sugar so
you can say should be empty off of the
sake of readability because don't forget
these these specifications and your
tests if you're using TDD serve of
documentation value so the more readable
and the more clear they are the more
valuable they are so that was one of our
driving goals here is to make things
readable and of course there's a forced
failure violate it takes a message tell
you what the problem was this is called
not on the target object but on the
enclosing context that you rate your
expectations in
okay exceptions how many Ruby
programmers here people have double you
know a croc object is then so if you
pass this to a proc object it gets
executed and you set the expectation
that it should or should not throw a
certain exception methods to check the
direct class of an object methods to
check the inheritance chain of an object
if you will so direct class or one of
its ancestors and should be a kind also
you could it uses AA or an which are
synonymous you can use either to make it
read well and checking whether or not it
supports certain methods messages and
here's a small example from my tutorial
of what it might look like or what it
does look like this will execute and
here's the background code to that so we
see we have the obelisk question
predicate and we also have a facing
question predicate that takes an
argument any questions up to that point
okay so mock objects as I mentioned is a
very important concept when you're
starting to do interaction based testing
and behavior based testing or behavior
specification see it's hard to get away
from that testing word so there's a
mocking framework built into our spec
and we went I went out looking for one
for Ruby and found one called schmock
how many you use j unit or sorry not JJ
mock few people good this is very much
like j mock so i contact it's open
source i contacted the author and said
do you mind if we sort of roll this into
the I respect project and build on top
of it that was cool so it's integrated
right in there's one way to do mocks in
our spec and it's fully integrated
so to create a mock you call the mock
convenience method give it a name you
set an expectation that a methods called
with the should receive call give it the
name of the method tell it how many
times it should expect that call and
with what arguments if any or if you
care and then what it should return when
that calls actually made oh these cool
fading slides don't back up nearly as
nicely there we go so you say and
returns and give it a single value or
you can say and returns consecutively
and give it an array and you know if you
set up an expectation for multiple calls
it'll step through that array the first
time it's called the return the first
value second time the second value and
so on if you hit the end it'll just keep
returning the last value you can provide
a block the same guy who wanted the
block to the expection expectations one
of the block here so instead of setting
all those all those expectations and
settings very declaratively so i want to
call this many times with these
arguments you can do that in a block the
block gets passed any arguments that are
passed into that method call and you can
do arbitrary checks on it and the last
value executed the block gets returned
from the call so here's an example it's
kind of lengthy can everyone see that
hopefully you can always watch the video
later and zoom in so you think you know
mock mock database should receive get
list once with no arguments and return
the array a be
okay one more thing about moxa get auto
verify so if you create them using the
mock the call to mock that I showed
earlier when your specification is
finished executing all the mocks will be
verified so you don't have to do that
explicitly the same as if you're using J
mock with inheriting from the right test
case so why Ruby well it's dynamic it's
a damn a dynamic language I learned oo
by using small talk so I'm a big fan of
dynamic languages before that I did a
lot of Lisp so you know using C sharp
and C plus well c plus plus it was like
a noose job is like a straitjacket you
know so you know I'm a big fan of
dynamic languages and I've been looking
at Ruby for a while and it's like oh
this is a good opportunity to actually
get in do some Ruby Ruby is very
productive again this goes hand in hand
with it being a dynamic language to a
large extent herbs very productive is
very terse not to the point of pearl
maybe but it's very expressive you don't
have to write a lot of Ruby code to do
something right so our whole frameworks
I don't line all right it's very
lightweight framework and it's fun you
know even given that we don't have any
ideas really right they use textmate
it's sort of a new agey max I guess but
even so you know Ruby's a lot of fun to
work in ok any questions on I'm not
technical technical details
okay so this is sort of the Kia how we
doing for time okay good so any
questions or discussion you think my
brains chilled from being up Norris yeah
those open yeah so you know so obviously
right okay so the question was we have
this framework in Ruby someone's working
on in Java not yet there is a BDD
actually the term BDD was originated by
Dan north and UK london or thought works
london who has a project called j behave
and he's recently put together project
called our behave so there's some work
done there he is a Java framework it's a
little different philosophically from
what we're doing and we will be starting
a java version of this framework which
will syntactically of course be a little
different but trying to sort of stay
true to the form that we set here as
much as possible
that's it that's a good question so it
was and I love the way you phrase that
define stuck with Java and stuck with
Jake in it what's the best I can do are
using j unit for ya using java five
using java five yeah yeah jdk 15 okay
are using j unit 4 okay you're probably
using Jane at 38 dot one then yeah so if
you're using that you're kind of stuck
in a way because you have to start all
your methods with test right that's the
one big sort of hurdle because you have
that in there and it's awkward if you
can you should as soon as possible
switch to Jane for there's some backward
compatibility built in it uses
annotations to tag the way if you've
ever used n unit in c-sharp it uses the
Java five annotations to tag your test
methods so you can call them whatever
you want now and so you can start
calling them in a little more behavior
centric way typically we should so you
named your class after the state of the
world so you know empty collection would
be a class name and you could have
methods name saying should have no
elements should have size of zero should
have it in return with empty iterator
you know things like that so you can
name your methods that way that helps
that takes a test focus away and focuses
on what the behavior should be right
that's that's about it but mostly it's
naming there and also also thinking and
I'll get unis I thinking about it from a
behavior point of view a lot of its
mindset and a lot of what we're doing
with changing the Nama khajur and a new
framework is trying to change people's
mindset make them think in a
specification way around the
verification way so a lot of people that
are doing TDD quite well are doing that
already in spite of the framework in
words it uses so yeah you can certainly
start thinking that way a big part of it
is is doing things
instead of focusing on the structure of
your code focus on the behavior of your
code often that means having a lot of
test case classes for one production
class or for a small group of production
class a lot of people have sort of a
mantra that will have class X and class
X tests and that's it and they have all
kinds of you know ways to defend that oh
it shows up together in the listing it's
easy to find and so forth but there are
other ways to accomplish that so
structuring your classes and your
methods around the behavior and getting
rid of that idea you need a one-to-one
correspondence or you need you know you
or I mean this is endemic and a lot of
beginning oh oh is that the afraid
they're afraid to make classes right oh
we want big classes that you know so
have lots of little test classes you
should be building your test
classes around around the set up around
the fixture that you're building right
the purpose of that test class is to
encapsulate this is one configuration of
the part of the application that the
methods inside it run against or run
within so that should be how you're
organizing things and that gets you a
long way toward doing BDD that's one of
the biggest changes is to start
structuring things around the pieces of
behavior and around the context that
those behaviors exhibited in about
systems being discoverable and
transparent several means they're easy
for a not just to get into transparent
and easy for names
limit how do you organize your
specifications or executable
specifications to get discovered
building and transparency and
completeness who did you get that okay
okay a lot of the discoverability is
done through naming so you give good
names that are self-evident I mean that
care we see that sort of a truism right
but if you name the classes well to
reflect what the situation is so empty
list or you know certain did they
reflect what the configuration of the
world is when for that fixture and then
name the methods that read right along
with that to describe what the actual
behavior is that's being tested so
things like empty list should have no
elements that reads and using if using j
unit for this you can actually there's a
product or no product but a project
called agile docks anyone familiar with
that lying test docks is the actual
program name its you can google it and i
think it's on sourceforge but it
basically goes through your test code
pulls out the class names and the method
names and assuming since it's java that
the camel cased puts in spaces fiddles
the case and puts out a bunch of
one-liner specifications so with the
right naming you can actually run that
and get a list of okay here's all the
behaviors of my my programming in the
situations in which those behaviors
occur now being able for an expert to
live in it I don't really see a whole
lot of difference there most of its
navigation just mean I'll find things
knowing where to add new tests when you
need to you know one of the sort of side
practices and tdd is if you come up with
a bug the first thing you do is to write
a test to expose it the question then is
well where do I put that test if you
have you know class X test well ok it's
a bug in class X I'll put it in there no
brainer but you know if you're doing
things a bit more intelligently then
sometimes it's ok
you have to give it a bit of thought you
know what situation does this bug show
up in where does it live best often the
best way is just to create a new test
case class and put your test in there
and look at what do I have to do to get
to the point where I can expose this bug
and maybe that's going to match one of
the existing test case and I'll just
move it to there that's another thing
don't be afraid to move things around to
put them is like with your production
code and your refactoring put things
where they belong best so with the test
code the specification code that fits
too often when I'm working and I'm going
into a new area in the application you
know writing an application test first
or whatever let's just start a new class
you know I don't want to worry about if
there's one existing I'll just start a
new class and check later see how it
evolves and I'll move it if it's
appropriate right or I'll grow it and oh
I should split this up now because I'm
hitting two different little functional
areas and the setup starting to diverge
so i'll split it out into two classes
again do you think i like though i
didn't do that this is that piece of
code I know
so like all the conditionals
I know this is
good cover the question so working with
with Jay and having a test class sure
you're hitting all the different
branches all of your paths through the
code is it harder if you have everything
split up around I'd say if you're just
trying to do it sort of as a thought
exercise then yeah probably but if
you're using some tools to help up now
so you can use clover for example that's
what I used to do code coverage when you
run the whole suite of tests under code
coverage measurement and it just points
out what code isn't getting run by your
tests that's not what's getting that's
what's not getting covered you know when
you're working on a little piece of code
No
you know better understanding of what it
means to really truly invested range
covers
yes okay the question was working on a
small piece of code you have a better
idea of what you needed to test all the
different branches yeah what it really
means to make a proper top of each
player okay and code coverage can be
misleading there because you might go
through that and I get all the nuances
right now that's one answer you
shouldn't had that code in there in the
first place if you didn't have a test
that required it if you're doing true
TDD the other answer is part two of my
answer which is yeah code coverage gets
you so far but it doesn't give you all
the information right it's a good first
pass to make sure you don't have any
gaping holes in your coverage the next
thing to do is sort of more of a
semantic code coverage and for java
there's a tool i don't know how active
it is now but as a tool called gesture
has anyone run into that and I know Jeff
probably has gesture essentially does a
semantic code coverage it takes your
code base and makes one tiny change but
what intelligently makes one tiny change
so it will change a true to a false or
it'll change it'll stick a and false on
to a logical expression or a or true it
will make little changes that change the
logic right that are guaranteed to have
a semantic change to the behavior of
your program and then it will do a build
and then it will run all of your tests
and if nothing fails it logs it all
right and logs logs it in enough detail
that you can get and go back after it's
all finished and get the report and
it'll say okay this line here this this
if statement I made this change and you
know it should have caused a test to
fail and it didn't right so it can point
out some interesting things it can point
out some redundancies where you have an
if statement that
it really doesn't matter which branch
you take for you know if you're doing
some xml processing and DF statement
does some structural stuff but logically
it doesn't make a difference in the xml
that happened to me when i was writing
the book actually which I think it's
mentioned in the book I found that but
it's very interesting to see what will
happen and it'll log it like I said you
can find out you know here point sir
maybe is covered it's executed by the
tests but not enough detail write your
tests aren't hitting all the conditions
to exercise that and there's a logical
condition that that isn't covered
properly all right so automation I mean
for things like that use as much
automation as you can to look at it and
find out what's going on at the back
okay the crux of the question was this
still looks like testing um yeah yeah
like I said it's the same thing you're
doing if you're doing TDD well that's
that's the operative word my experience
most people aren't doing TDD well that's
why I wrote a book okay but yet
technically you're doing the same thing
our big the big reason behind this is to
try and get people away from thinking
about testing and thinking about
specification so really moving this
activity into the design spectrum if you
are the design arena so people aren't
thinking about verification
okay I'm just going to paraphrase that
back you looks like we're writing a
language to write specifications and
whether it's something about whether
it's Ruby or whether it could be used to
write specifications for any programming
language was that it that's a good point
and then some people are actually
talking about that making essentially a
specification dsl domain-specific
language from this we're writing in Ruby
I mean you know I get some reasons I'm
basically because we wanted to write it
in Ruby that's what it comes down to but
we could certainly do that with bindings
to other languages we could write it
could become a specification tool and
translated or hooked in to drive
whatever implementation language you
want it this could be one way it goes
there people talking about moving in
that direction
we started this when did this get
started hmm September something like
that I'd have to look back at my blog to
see when that original post went up but
I think was in september-october
framework I'm not really sure what it's
being used on so I can't really answer
that we're at released zero point 4.0
now so it's very is still very young
likes it a couple weeks ago we sat down
and we got it all those expect a tall
that expectations syntax you saw is
about three weeks old we sat down we
gutted the whole thing out we threw it
out and we rebuilt it using day
chomsky's idea of having helper objects
because before and this is one criticism
that's come up is that we're polluting
the object name space so the interface
of object we actually added methods to
object which is something really cool
you can do in Ruby but it does come at a
price so we had and you know you saw
nice nice expectations with the periods
between them we had underscores so we
had a whole method should be equal was
one method that we added to object so we
backed away from that now we have
intermediate objects involved so there's
one one method we add to object and that
should and that returns an instance of a
should helper which knows what B means
which know and actually bees just a
syntactic sugar it loops back and return
itself but it knows what equal means it
knows what you know the other the other
nominator means and sometimes you
actually get a chain of objects together
that do the work so it's a little little
sort of recursive descent e-type parser
in there too with the objects but now
it's very clean in terms of we only have
one method that we add to object and
it's very lightweight and it's a lot
more extensible now too I think you
thank you the question is specifications
you know by nature are not ambiguous you
don't want to ambiguous specification so
why do we should rather than must the
quick answer that is that I lost that
argument I I strongly wanted it to be
must and to be restrung language oh yeah
just alias it right yeah and you know
I'm not convinced that it shouldn't be
must should you think it ought to be
that way you could change your mind that
was exactly my argument should means it
would be nice for it to be like this but
it's not manage things come from
downtown hard you can t go to jump I
find the acquiesced on that is
temporarily because if you look it up in
the dictionary one of the one of the
means of should is really it's a good
match I'm still not convinced I guess I
have until released one point O to get
that all straightened out yeah
Oh
so the question there was instead of
response to or should respond to to use
understands or something like that
should understand this message yeah and
again is it someone said with Ruby
that's pretty easy in alias methods so
multiple selectors for the single method
so we're probably do some of that that's
a good point we that was sort of the
last thing we add it to that syntax so
it was like oh we have instance I've we
have kind of we respond to okay we can
just put those right in like that but
yeah that's good that's good you should
get involved and send in those comments
like that yeah if anyone wants to try
this out we there's the links later but
again it's a very young project it's
very much evolving so if you try it out
you have some comments please send it to
us yeah
so what's the short you know one or two
syllable word respect okay yeah the
question was you know with Jay and so
for you test its nice snappy word thing
you need to write a test or you need
another test for that we don't want to
go around saying you need another
beautiful specification to that right so
we just call them specs hence our expect
how are we okay so I'm just going to
finish off the slides here's an
interesting comment just sort of on Ruby
more than anything there's where you can
find I respect even though if you have
Ruby installed if he ever be gems
installed you just gem install I respect
that would get it and you can watch my
site my blog for information and
announcements and articles or whatever
on our spec and and other things too but
that's a lot of what I'm writing about
now is BDD and I respect that's that's
my slide set any question</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>