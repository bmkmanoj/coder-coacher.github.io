<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Slightly Advanced Python: Some Python Internals | Coder Coacher - Coaching Coders</title><meta content="Slightly Advanced Python: Some Python Internals - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Slightly Advanced Python: Some Python Internals</b></h2><h5 class="post__date">2008-09-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/23s9Wc3aWGY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody in welcome to
to talk which has a title that may
surprise some of you respect to what was
Bruce Lee announced I my working title
was highly advanced Python undocumented
internals and then I did sufficient
research to confirm to myself the fact
that all of this is actually extremely
well documented Python has never really
tried to hide its internals from prying
eyes or from users everything is very
much exposed for your use and so instead
of highly-advanced I demoted myself to
slightly advanced it's stuff that's
always been there it's well documented
and basically just to summarizing it all
in one place
and it's all solidly documented and
solidly supported in every version of
Python so from this point of view
there's absolutely nothing against you
using it this is the URL from which you
can download the PDF it will be repeated
at the end so you don't have to jot it
down so as usual I indicate what
audience level I'm addressing on the
three point scale of shoe hurry this is
slightly advanced the stokke assumes a
better than average master level sorry
journeyman level understanding of Python
it doesn't really address any of the
upper most deep and complicated master
revelations which is why it's only
slightly advanced so what are what can
you be looking forward to well first of
all a talk on Python two for just about
everything I say it's perfectly valid
into five as well and two vast extent
into six which is going to be out in the
second later tomorrow I just make one
point which is something we've been
looking forward to very long about
Python 3000 also known as 3-0 which is
also going to be out in the second beta
tomorrow obviously not ready to use for
production
but still very interesting to see what's
coming our way
in the near future so what am I going to
talk about well I'm also indicating the
number of slides or subjects so you have
a reasonable idea of how important the
subject is in the economy of the talk
it's a very broad not so deep talk of
them covering five subjects in an hour
six some must be going to talk about the
class statement in metaclasses mostly in
order to understand exactly how does a
class statement work attributable cut
and how that ways with descriptor
objects and bytecode inspection and
generation with a little or intermediate
part on introspection garbage collection
and stack frames and trace factors
sometimes some confusion if you have two
maybe even a little deep into the
internals stuck frames and trace backs
are kind of interacting with each other
will we'll explain that a bit so let's
start with the class statement so the
constituent can be explained very simply
whenever you have class name open paren
basis and then a body what happens is
that Python first of all execute the
body essentially as if it was a function
more or less function without arguments
it created the local locals dictionary
of of the function the niccola's all
they essentially any name that is
assigned the value in the body assigned
a value means so left hand side of an
assignment statement also means death in
class and import those are the
statements that bind a value to a name
so it collects it all into a dictionary
finds the metaclass
to use we'll see how and it finally it
calls the met across the three arguments
the string which is the name to be used
the vases a tuple
of objects the dictionary which has just
been built up by executing the body and
buying that in exactly as if there was
an assignment statement to the name so
where does it bind it well if it's a
module level statement then it will be a
global variable of the module if it's
inside a class it will be available of
the class if it's inside a function it
will be a local variable of the function
and so on and so forth so let's look at
an example of a class body and how that
builds the dictionary that we're using
right after to build up the class object
I'm placing that into a function so that
I can have one argument any of you from
Philadelphia I hope this little bit of
fun doesn't offend anybody almost anyway
I guess everybody even not from
Philadelphia knows what I'm referring to
that IIE should have passed the second
argument for the kind of cheese but I I
think using anything but Swiss cheese is
wrong so this this particular thing only
makes to the sandwich with the Swiss
cheese and of course steak no vegetarian
sandwiches here
so basically couple of statements a
condition of control regarding another
assignment statement and then that's
pretty unusual to see in a class but
it's absolutely harmless it doesn't
alter the dictionary in any way in
Princeton locals dictionary so if I can
call it without argument so it defaults
to plenty and with non to basically make
this if fail and we can look at the two
dictionary you can see that the
dictionary the class is going to use has
a value for onions if this has been
assigned but otherwise it simply lacks
it so there is absolutely no special
rules
I've heard people coming from other
languages referred to this as a class
declaration it's
no such thing Python doesn't do
decoration Python has statement stuff
that executes does think not stuff that
just tells some abstract entity what's
going on so there's absolutely no rule
that says you can't have an eighth or a
while for that matter all that matters
is what are you binding to what names
now a second reason I wrapped it into
into a function is that this makes it
very easy to disassemble so consider
this a foreshadow of the last part of
the talk when we're going to dive deep
into into byte code I basically consider
that looking at the byte code even with
a minimal level of understanding helps
you understand what's actually going on
inside of Python because it's it's
generated in pretty simple minded way
there's no funky optimizer doing weird
things so here's a function constructing
a class that's not simpler than the
simple example because even a few lines
of Python typically become dozens of of
lines of byte code and this is the
disassembler that basically gives you
back the byte code from just about any
executable object but functions are the
most convenient for that so here is what
this function does starting at the line
three which is basically where the class
so they constant X the Nancy and then
object to turn into a tuple of one item
because the bases are always a tuple and
then a constant is loaded which is a
code object which is basically just like
for a function execution always happens
to bytecode so this has been built into
bytecode before getting executed
basically this matters because if you
have a class statement inside a function
that the internals of that class
statement get compiled once at def time
where the outer function is map out so
it's having a factory kind of thing is
very effective you your
recompiling the class statement over and
over it's Allah gets gets compiled once
so then this is made into a function
with zero arguments so note the code
object is the constant the function is
built from it because it needs to know
many arguments it has and then call
function with zero arguments and our
built class does the end of the magic
which is basically what we've seen of
finding and calling the metaclass we'll
get deeper into that whatever built
class leaves on top of stack is stored
into local variable X and then this is
the implicit return non at the end of of
the function since it doesn't have an
explicit return statement it loads the
constant nan and then returns it so
since we did mention that a code object
that's what actually the body of the
class turns into that's important it's
one of the constant in the function in
the code object of the function and
specifically its number to the third one
and so we can disassemble it in this
case with disassembling a code object
rather than a function that works in
exactly the same way and so I'm printing
it just to show what all day all the
constants are there's nan which is
always the first constant in every such
table because it's a widely used then a
mix and then the code object and the
disassembly is first of all they named
under under name and render or as they
always pronounce those things dunder
name the under name the global is loaded
that is the modules name and it's stored
into the named under module every class
object as a dunder module which is the
name of the module in which it has been
defined and this is how it's obtained
and then the code itself which you
remember was just X equal 23 loads a
constant which is worth 23 and stores it
into a name that is y and then load
locals and returns it so they locals
dictionary
of built up by this code is returned and
it will have won the entry module in the
entry why and that's all so we have a
dictionary well executed the body we
have a dictionary which is the locals
built by that body now what now we need
to find the metaclass first of all there
is a very explicit way for the Python
programmer to tell the Python compiler
in run time what Mirek wants to use it
is simply to set as part of the
dictionary that that the trans bodies
building done dramatic loss that
basically means you write something like
the Android metaclass equals type you're
saying use type as my metaclass that's
the ordinary metaclass for normal new
style classes if you haven't explicitly
set down to the metaclass then we try
another thing we look over all the bases
and for each base we get its type it is
its metaclass same thing and the Tamera
class is just the type of the class then
we get the leaf most of these objects in
an inheritance tree so if you have for
example type and a subclass foo of type
then the metaclass resulting from this
will be foo who inherits from type in
therefore is leaf most in this da G if
there isn't a leaf most class made a
class of course that is an error a
runtime error you will get diagnosed if
you ever want if you're working a
complicated multiple metaclass multiple
inheritance situation and want automatic
fix edge for the no leaf most metaclass
issue look at the very last recipe it's
about 14 pages i think in the second
edition of the cookbook where we really
worked out a very general purpose system
for that you will not normally find
yourself in such a complicated situation
we
it really emerges only when you're using
metaclass from multiple different
frameworks and doing multiple
inheritance from classes that come from
different frameworks and that has all
sort of other implications but at least
if you want you can do the resolution of
the know leaf content across problems
what if there aren't any bases what if I
just have class foo column with no basis
at all
well then next thing I look in the
module that is the Global's of the
module is there a dunder metaclass there
if so that's what I use so for example
if you want all of your classes without
basis to have to be normal new style
classes there is use type as there
metaclass the simplest way maybe to
start your module with done dramatic
last equal type and then pass through
colon class bar colon class bars column
these were all be new style classes
because they will all be using type as a
meta pass a more common approach is to
make sure point two applies by narrating
from object that's exactly equivalent
because type of object is type so you're
using that as the metaclass but this
works fine too if none of the above
conditions apply then by default of the
default of the default we use types of
class type the old style classes the bad
ugly inefficient deprecated legacy style
classes why because we care about
backwards compatibility but it would be
totally absurd to use them in any new
code if you've written any code in the
last five years I hope you're not using
legacy classes because there are
absolutely no reason to in a lot of
reason to use in your start instead
finally we have the metaclass we want
the class which is an instance of the
metaclass with appropriate parameters
how do we instantiate it we call it
whenever note that this doesn't just
apply to medical ices it applies to all
sensible objects when I call em I'm not
using the dunder call special method of
M that
make no sense I'm using the dunder call
of the type of em right so basically
this is the clear rule infallible rule
but special methods always come from the
type and never from the instance and
therefore if you're calling them on the
class they always come from the
metaclass if you're calling them on the
metaclass they come on the metaclasses
class and so on is the sharp conceptual
difference that makes new style classes
work so much better than the legacy one
in particular almost invariably your
meta class will be an instance of type
so the metaclass of the meta class will
be type and type dunder coal does
two-step construction which is a very
important video in many circumstances
basically do the construction first and
if that given a satisfactory result then
do the initialization you normally don't
need to focus on the construction part
you can basically start with already
constructed with empty object and just
do the initialization the construction
is done by dunder new and the
initialization is done by dunder init
but the initialization is guarded so
that if the under new returns anything
that is not an instance of the type your
instantiated
then Python doesn't call your you're in
it this is very important because for
example it lets you play all kind of
tricks in a mock up situation when
you're doing unit testing you can
basically you just need to to outer the
dunder new appropriately and everything
else gets tested properly except that
under in it without the dunder init
possibly playing havoc with the object
you want to use for your marking that's
one of many examples so this is a great
system but this is where I for an
instant talk were wistfully about the
beauties of thousand three it's not
perfect it's got some limitations that
we've suffered under for a decade
the press body is executed before we
have any idea what the medicals will be
well not we as programmers may leave at
the Python runtime because the first
place button will be looking into to
find potential matter class is the
dictionary which is built by the class
body so first of all the class body
needs to run to completion so there is
no way you can write a meta class that
in any way controls or interferes with
the execution of the class body the
transporting office is acute in the same
way which is conceptually very simple
very nice but quite limiting in some
cases particularly before because
everything you're doing the class body
ends up in a dictionary
a dictionary does not preserve order so
the order in which you've done things in
your class body is basically thrown away
you only so you cannot tell if it was a
equal one B equal to C equal three or C
equal three B equal to a equal one or
any other of the six permutations you
may well end up with exactly the same
dictionary so for example you cannot use
no matter how smart the metaclass you
cannot just use a class to map the
equivalent of a C struct which has
fields in a very specific order you lost
the orders you you see you're sort of
designs like having a another member
which remembers the order dunder order
equal a comma B comma C or something
like that but that is really unpleasant
to have to say twice because the code
you write does have an order in those
rare cases where you want the order to
be significant it would be nice if you
could just make a smart metaclass which
basically doesn't destroy the order in
which you're executing things so we've
relieved that in Python 3000 get the
data
maybe tomorrow and beta-2 comes out
because it's better one now get the beta
try it out first of all the first
innovation and of course like all big
innovations is extremely simple it is
now possible to define the metaclass
as part of the class clause so you can
have class name open paren bayes's comma
metaclass equal m you have a keyword
parameter named meta class that you can
pass and then if you do that then python
will know while executing the class body
exactly for what meta class it is
intended to and to give the metaclass a
say in what is going on with this
execution there is a special method for
many classes in Python 3 called
dunder prepare which returns a mapping
of any kind so it can be an order
preserving dictionary light data
structure or it basically lets you keep
control or it can be a special object
which whenever something is assigned
does something clever as a side effect
so you can have a sort of tracing happen
during the construction of your class
and so on and so forth
since the metaclass use is now so much
more powerful we've also managed a thing
to eliminate a lot of craft with another
extremely simple idea which is to allow
decorators to be used for class
statement as well as def so instead of
view a lot of stuff that you now would
want to do with the meta class is
basically equivalent of saying class
blah blah and then in the very end blah
blah equal do some changes on open paren
blah blah close paren and this is
exactly the decorator pattern and so
finally in python 3000 is taken as well
you can express that as at blah blah
before the class statement and the
declaration will happen after the class
statement this isn't this isn't to
supplement medicals powers if you are
using a matter cost anyway that's
probably why pointing it is basically to
wipe away at least
half of the cases in which you now have
to use metaclasses so fewer metaclasses
which can it need be more powerful okay
and this conclude the brief excursus on
the of the object model cross creation I
have some time reserved for Question and
Answer at the end if there's something
extremely burning just just wave your
hands and and I'll try to do something
about it but otherwise I just plan to
proceed actually broke up just to fix
our terms I call it getting when you're
doing X dot foo or it's absolutely
identical semantics get after X code who
code it does exactly the same thing and
I call it setting when you do X dot foo
equal value which is again identically
equivalent to set outer of X quad full
quote value so little conundrum here
okay so we know they're getting in the
setting so what's X dot foo plus equal 1
is it a getting or a setting something
else anybody want to try a guess how
would you find out well though in
general the best way to find things out
in Python is to read the nutshell but if
you can't read the nutshell then do a
little bit of code and you easily find
out because everything is so exposed
so I write myself a little pass you
start of course with dunder grotto and
undersea dr. which will be invoked when
attributes are gotten and set
respectively and they're pretty fake
because in every attribute is going to
be there with a value of 23 but they
main thing is the side-effect I want
which is to print get of the name and if
you similarly for the setter don't
actually do anything but I print the
fact that there's being a set of this
name to this value so then I instantiate
that and finally try my extra food plus
equal 1 well I'm surprisingly what next
up true plus equal 1 does is first it
gets 2 gets 23 we know that then it adds
1 and then it's absolutely
so they don't be tricked about that the
plus equal is first a getting followed
by a setting so the attribute must be
defined before plus equal can run and
gets reset after plus equal stop okay so
let's get into getting all of this is
implemented by a special method it's one
of the few cases were really wish
Michael did not expose one of his
internals please don't interfere with it
I've seen many people try to override
under get a tribute I've never seen it
done right even once
I mean sometimes it can be made to work
but it generally slows everything down
so much that you wish it isn't so please
don't do it so what does dunker get a
tribute do for us first of all like when
we do it so first of all it checks is
the string F in the type of X by being
in I mean attribute of the type or if
not X itself any of the classes in the
method resolution ordered under draw in
order so that's all the direct classes
the base classes of base classes and so
on arranged in a linear string if it is
there then we ask and you'll see what
that means who I've got a foo is that a
descriptor if it is a descriptor then
different rules apply and we will see
them later if it's not a descriptor
putting aside for one moment and
remember you have it around then move on
and the check is it is the string a key
in the dictionary or one of those lots
of the class if no then remember they 1
1 2 step where we there then did we
start something aside then let's you
that ok none of this if none of this is
working then you tried under guitar if
the classes has one
and if everything else fail you raise
attribute error so basically all of
these sequences are the first success is
a return statement takes you out of the
sequence with the one exception that if
you found an object named - but it's not
a descriptor then you need to keep it
there for a second because it will it
will be used only because basically they
one way of seeing it is if if there's an
object by the attribute of the name in
the type and it is a descriptor then a
set of rules applies
otherwise they descript the thing that
is in the type that is not a descriptor
can be overridden by it also being in
the instance dictionary or slot yes
anything except the description
description is an object with a dunder
get special method so we will you can
have in the class you if your class has
as we had before y equal 23 well then
the classes that attribute Y that
attribute Y is an integer an integer is
not a descriptor and integer is an
integer it doesn't have a dunder get
method so it's not a rescript okay so
what's a descriptor a descriptor is an
object whose time has a special method
under get if it also has a dunder set it
used to be called the non-data
descriptor I think that's the
terminology you'll find in the - for
documentation is now called a non
overriding descriptor which is slightly
more descriptive because it's not so
much about being data versus non data so
basically the priority in which an
attribute values solve is if the class
has a data descriptor then that is where
the value is coming from otherwise if
the specific variable is in the instance
that is typically in the dunder dick
then that is the result otherwise
unknown data descriptor
present will be used otherwise a
variable of the classic present that was
on a descriptor will be used and then
finally that's where you get to done
Durga tetra so what does it mean to use
a descriptor well for example if B is a
type then B foo means get the fool out
typically of the dictionary but it could
be a base class equivalently and then
called under get with nan and B instance
nan type B if it's already an instance
so X dot foo where B is the type of X
then it's similar but you pass X as the
instance and B as the type how is the
distinction brought about by the fact
that they dunder guitarra between object
gets overridden by the downloaded
attribute in type so but that's one of
the issue is not wise to to further
override under good attribute there's
already two implementation one is in
every object except the types which have
another that's why your meta class
should normally nair it from type and
not try to redo everything our typical
then probably you must have written in
your lifetime of python use thousands of
descriptors you probably didn't realize
it because functions are descriptors in
a Python like implementation of
functions they do function type you'd
have a damn door get basically making
the function of the script not under set
its the non data it's a function of data
which basically builds a bound method
calling types method type or the the
older way was a new dot instance method
but this is the preferred way with the D
function is as in funk and the object
which can be known for an unbound method
and
and they other standard a script website
function which are like obviously
something you write every day the other
standard descriptor that's quite
important our properties
I assume you are reasonably familiar
with properties I'm just reminding you a
property something with an init where
you can optionally set functions for
getting setting deleting and a docstring
and they all get recorded as self that
i've get and so on and then on the
dunder get it basically doesn't do
anything if calls on day on the phone on
day of type otherwise it raises an error
if it does no f get final it causes get
and similarly for set and the importance
of properties of course is to dress up
the call of functions as if it was an
attribute access so you can program
something that relies on attribute
access and then change the
implementation and all the client code
doesn't need to change so that's very
handy
moving on to introspection the key point
i want to make and we make every time
and speak about introspection in python
use the standard library module inspect
somebody's already done all the work of
doing all the possible introspection
work on all kind of objects all kind of
types and so on and make them is
available is very nice function very
nicely documented don't bother calling
deer calling VARs looking at dunder
classes looking at under basis the
inspector does just about anything you
will ever want I particularly recommend
looking at this URL which is a very
concise that summary documentation of
the internal types if you didn't know
what I was talking about an earlier said
f dot func underlying code
 design code is one of the
attribute of functions if the code
object that the function executes and
you find it in that very simple summary
table on that URL similarly I've seen
people call sis dot underline get frame
the underline is there to tell you not
to
it means it's private we have to stick
it insists to make inspect work use all
the functions that inspect makes
available for proper nice access to
frame objects and of course another
thing I always always say when when
talking about introspection it's
absolutely fine it's the cat's pajamas
for debugging including debugging
performance problems debugging memory
leaks as well as debugging functional
problems it may be useful for testing
although this is a bit edgy for me
normally I prefer to be very explicit in
my testing but there are third-party
frameworks like knows that use
introspection very effectively for for
testing don't even think about it for
production code it's not a it's too rich
it makes production code very hard to
debug in to maintain for anybody else
so to inspect objects you typically use
they get members function of of the
inspect module possibly with a second
argument that the predicate predicate
means it will only bother returning the
name value pair for members of obj that
do satisfy the predicate so it's a
basically a function taking this bullet
it supplies many to you for example say
you want to know all the classes
defining module foo well you do that
with inspect get members foo comma
inspect dot is class that basically does
the filtering for you it's a very handy
thing and then maybe on every class you
want to know its inheritance tree
actually you want to know the whole
inheritance tree of all the classes
you've just gotten you just bump that
into the get class tree which basically
studies all the inheritance relationship
and structures it magically takes the
list of classes and returns a list of
list of classes which describe all the
inheritance relationships it gets a bit
confusing in multiple inheritance cases
but Betty still can be useful and
there's a pretty good recipe on the net
to turn that into an ASCII graphic kind
of thing to show you they they
narratives relationship or if you just
want to know how base classes will be
will be walked
then don't go and look at dunder Emma
row again use the inspect get Emma row
of function which does it for you nicely
it also incredibly manages to work on
old-style classes if you have any around
from ancient legacy code if you want to
study a function typically for the
backing purposes and said what's the
exact signature of this function what
arguments does it take and so on get arg
spec does great value for that if you
have a frame which will mention shortly
anyone okay so the function was called
with what arguments again get our values
managers to explore the frame get all
the argument values corresponding to the
various names for you and so on and also
if you're writing a debugging friendly
situation you may want to look at get
source which for example if obj is a
function the inspected source will
assume they're around somewhere find the
Python sources where the DEF statement
for the function was located then and
return them as a list of lives and
there's you can get the path to the file
and so on with other functions
moving on to garbage collection this is
one point where I want to point out very
intensely most of what I say about
Python although I keep focusing on C
Python 2 4 also applies to the three
other big important implementation of
Python Jathan who's just out in 2.5 and
run Sunday on the Java Virtual Machine
ian is fine I'm now supported by Sun
Microsystems after all these years
Iren Python which has been supported as
an official product by Microsoft for a
while and pi PI which has now graduated
from being a research project of the
European community to a thriving open
source commercial venture
but for garbage collection
there is absolutely no commonality
because jython and I are on Python run
on existing virtual machines and they
basically to play well with the rest of
the ecosystem there they need to use
exactly whatever is provided for garbage
collection by the virtual machine which
is typically the mark and sweep
generational background thread and so on
but basically they the Python
implementation there don't really worry
about it they just dump everything down
to JVM and CLR respectively
pi PI one of the strengths of pi PI is
that it's got like half a dozen
backhands you can generate JavaScript to
to send to your browser you can generate
their machine code you can generate just
about anything and so of course the
garbage collection strategy is like
totally different in every case will
cover C Python on the ear I won't even
mention again the rest so the main
strategy for soup and garbage collection
is reference country y reference
counting which is like an antediluvian
technique because it frees everything it
can as soon as it can with it's maybe
not minimal costs that the cost is very
nicely spread out in general it's not
always feasible due to the garbage loops
and so we have a secondary fallback
strategy which is a generational
mark-and-sweep just three generations
but
that's generally played the other
controls at your disposal to interact
with that are in the standard library
module GC it's you can rename a Belen
disabled you can force collection right
now you can check if it's currently
enabled you can set and get debug flags
you can set and get the thresholds for
entering from one generation to the next
so how how often is a garbage collection
cycle run for the youngest generation
for the middle generation or the oldest
generation and you can basically get all
the objects that are being tracked at
you test you can get the reference
foreign objects and the reference
foreign objects which basically all
helps you find garbage loops eliminate
them for for better performance and
there's garbage which is basically where
all the unreachable and collectable
objects objects which have the horrid
thing known as a dunder del which is
another thing that we should never have
had but all you can also put everything
in there to help you find the reference
group by the d-backs able to back flag
moving back onto introspection stacks
frames and Christ backs standard liberal
library module inspector all those
almost all you need to help you with
that but here's a little extra
understanding of what's going on there
again it's absolutely priceless for
debugging in depth particularly if you
have ever ever using C extensions to
Python in your so basically you're
having to look at the Python data
structure from gdb instead of PDB gdb
having absolutely no clue what's going
on it's not it helped if you do end
occasionally for testing and here's my
standard disclaimers against using it in
real life so transness objects are what
you find in the third item of X info you
can basically look at it as a simple
collection of four attributes I've now
got no methods in another so it points
to a frame it within the frame it says
where they index in the currently
executing bytecode where it stopped
what's a corresponding line number in
the Python source and the it's obviously
helpful for debugging and then there's a
pointer to another trace back which is
the next one meaning the next inner so
our trace back is essentially a
linkedlist cue the head is the one that
called the one that called the one that
called the one that called the one where
you're finally got the exception the
formatting and analysis particularly for
display purposes of Christ back is
better handled by the trace back module
instead STD live in Istanbul library you
can use inspect but trace back already
does a lot of heavy caring for you so
that's what you use the frame objects
you can get from trace back that you can
also get from such function as get a
current frame stack and so on get inner
frame get outer frame so which that you
get all the frames that have cold this
one recursively all the frame that will
be cold by this one recursively it's got
a lot of attributes all preceded by F
underscore that's a naming style of some
very ancient Python object that kind of
reminiscent of struct objects in C
before the ISO standard when the
namespaces of different strikes could be
made
so religiously everybody always had
unique prefixes in their names inside
strikes anyway so all the exception
information if there is any any
exception being raised in that frame a
back pointer to the calling frame not
that trace backs point forward frames
point backward that's the a frame knows
where it's been cold from a trace back
knows what a trace back object it calls
the two to be created so it called
essentially so basically we have two
linkedlist pointing in different
direction and they trace back point to
the frame so that allows not perfect
navigation because if you start with a
frame you you basically unless there's
been an exception right there in which
case you can use the F H CTB to get the
trace back and then start navigating at
will it's not immediately obvious
so essentially whenever a function is
cold the cold creates activation link so
one frame at the top of the stack and
the links go the other way finally we
get to speak about bytecode again this
is strictly C Python Python uses JVM
bytecode so that's a separate talk item
Python the uses a common language
runtime of Microsoft pipe I can use
anything there's a back in generating
Common Lisp a back-end the support in
the LLVM and so on and so forth i find
looking at bytecode and extremely
instructive exercise whenever i am not
exactly sure what's going on i'm not i
don't have a specific rigorous mental
model of the execution of what will
happen if using this piece of python
code i disassemble it and that teaches
me all i need to know
altering bytecode on the other hand is
very much one of the things you should
really never do except for like weird
fun in your own time not not for
production purposes just imagine
debugging it if anything goes wrong eek
anyway the Python virtual machine is a
very simple step oriented virtual
machine with basically everything you
would expect from a stack oriented VM
plus if you very high level of course
specialized to Python like the build
class one we saw earlier I'm assuming
some familiarity with stack machines
either you had a HP RPN reverse polish
calculator in your youth or worked in
fourth or hacked and PostScript one of
those beautiful reverse polish stack
oriented I am pretty sure you never
programmed an actual stack machine
because I don't think any is being built
in the last 50 years old a list of byte
codes
very clearly documented I'm just
summarizing here they main a legion
advantage of having a snack orientation
rather than register is a lot of
operands can avoid byte codes kind this
compresses the the structure a lot so a
lot have to do with stock manipulation a
pop-top throw away the top of the stack
rot to swap the two top elements of the
stack and so on there's plenty of those
and operators both unity and unity
operate on top of stack and leave the
results on top of stack binary operate
on the top to leave the result in their
place and they in place once also
basically work on the top of stack and
instead of leaving the result there
presumably leave it to us safely stashed
in some object rather than in the stack
there's a lot of operator for slicing
for example all the various forms of
slices are represented by different
operators rather than different
arguments so there's a for example slice
+ 0 is the notation use is 4 :
among bracket so when you do X bracket :
close bracket that's a slice of a 0
operator annex
so it would be load makes nice plus zero
plus one I forget is plus one is a colon
nothing or colon or nothing culinary but
anyway there's all sort of possibilities
for slice things because you can have or
not have each of start stop and step so
there's like eight two to the third
possibilities there's eight operators
and again for the storing so that eight
and eight sixteen and there's there's
plenty of special-purpose one like print
item is a equivalent to a print
statement a break looper is obviously
used to indicate the exit from a looper
build class we've seen means okay here
we are identify the metaclass and call
it a yield and return for generators and
functions respectively and then we have
some operands with some byte code take
operands but operands in a rather
specialized sense the you normally think
of an operand as say then i don't know i
do x times so one point one well there's
got to be some operator there with an
operand of one point one not exactly
what happens is when pythons and parts a
function or something that is kind of
like a function like a class body it
builds a table of constants like a table
therapist so the constant 0 is always
known suppose this is that one point one
is the only other constant in this it
will become constant one and so what is
needed is low name x load constant one
load a mix is actually load name zero
the first name in the function and then
load constant 1 the second consume the
function and then binary multiply so the
operand is actually a small number
almost invariably two bytes are enough
so most
operands are two white numbers for those
extremely rare places where you need a
number larger than 65535 there's an
extended our bytecode which basically
takes and stashes away it's so proned
and then the next one comes and is
combined to give a four byte operon
that's a very weird way to do some
little bit of sparse optimization so a
lot of those load something a constant
name an attribute global there's
possibility of storing and deleting
almost all of these for example not cost
so there is a load constant all store
comes to con the concept would be
contradictory there are bills like we
typically take the number of items to
take from the start to build a tuple
list and so on there's a sort of flow
control jump condition and an
unconditional setting up of loop accept
and finally construct making functions
and closures and so on
this is what you want to use and the
format is very helpful there's a line
number there's a marker if that is a
target of a jump there's the address of
the bytecode the bytecode has code name
and the operand is shown with a numeric
value and as the human readable thing so
it seems on this this is what I mean
when I say a little function becomes a
lot of bad code I add to switch just
more fun because of that this is very
simple if it's less than 23 you'll see
this is we're lying to start this is
where line 3 starts these two lines are
target's of jumps and usually this is
jump forward to 25 and so on so for
example all the comparison operator are
mapped into a single op code which is
compare up it's the opera and that tells
me which one compare up 0 is a less than
corporation so I try to find some some
sufficiently trivial example of
use I think this is a bit far-fetched
but you know they you probably met this
problem when you do - to star star - and
you get - for wait a second isn't the
square of minus 2 for y minus 4 this is
a bug in Python and this is hint to
illustrate naturally it basically does a
minus 6 star star Y and it shows you
what happened load X load y raise to
power and then negate so basically this
is just a way of showing oh yeah they
raise to power as higher priority than
the unary minus da what a design oh well
sorry it's the way it was designed and
will not go and change it anytime soon
now suppose you're planning for assembly
you say ooh that reminds me of when I
was programming in in their machine code
on my hacked motherboard I wish I could
do something like that for Python well
you can't just don't put that in
production but they probably best
updated thing right now is a single huge
Python module called byte play so
basically you within that module you
build a code instance you're passing you
pass a real Python code object and you
get an instance of this fast code you
manipulate it to your heart's content
and then you call to code and it gives
you back a code object and it's
basically a list of tuples each as the
OP code in the argument or op code non
if if it has no argument in addition to
the real OP code you can also have
labels and satellite numbers to do by
enumeration and the wrapper is very nice
it basically the same as discus and then
all sort of things that would be
read-only in a real code object such as
the list of names for arguments they
still name for free variables so the
name itself and so on become readwrite
so you can reassign them and build up a
code object as you wish here's an
example so say we have a function which
does a complex operation return X plus X
well we
you have import by a week before by play
code from code a phone code this is what
we print as you see it's like the
distance it's a load fast load fast
binary ad return value so now is where
we turn ourselves into assembly
programmers and say I can change this
with a load constant 23 yes I can and
then with new function with the new
piece of code and empty Global's
dictionary and name G I can build a new
function now G of 100 will give me
instead of 200 F 200 would be F F of 100
would be 200 G of 100 will be 123
because I have built a function that
does Lord has takes a load cost twenty
three binary Add and return value the
much-older enricher unfortunately he's
old enough that he doesn't support any
Python to something it's Python 152 only
nobody's ever bothered to port it it's
michael hansen bytecode hacks which in
addition to the code objects that you
work at the level of function objects
method objects and it it does a lot of
cool stuff for you including a small but
funny peephole optimizer that the people
optimization is now in in part of the
official Python I say that doing serious
optimization on that buy code the
bytecode is so high level that is not
all that much you can do but what little
can be done for example computing
constants at compile time rather than
the runtime is now embedded in Python so
if you write to return two plus two is
actually compiled as the same way as
return for so there's not much request
for that and we have five minutes for
Q&amp;amp;A and this is again is the URL from
which you can get the slides so
anybody's got any
yes
yes the built-in function getattr called
e with a constant is identical to doing
the dot constant on the object
it's semantically identical doesn't mean
doesn't mean it's it's like saying that
that x star star 2 is identical to X
timings yes but I'm not saying which one
will be faster measure it with time it
it's a time it is a precious resource
whenever you're wondering about saving a
microsecond or a nanosecond here and
there because it basically answers
exactly how fast is this construct on
this specific version of Python this
specific machine so it's not just a
generic well in general star star to
tend to have a tiny more overhead but
then again it depends because you're
only fetching a variable X once so it's
kind of yes what does time you time it
shuts off the garbage collector yeah so
if you have a lot of other creation it
doesn't give you exactly the right
impression yes that is correct time it
is designed for timing small snippets in
some and precise sense not not for
timing big thing it's not a
general-purpose load testing framework
it's a really micro benchmark
oh no more questions then we're done
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>