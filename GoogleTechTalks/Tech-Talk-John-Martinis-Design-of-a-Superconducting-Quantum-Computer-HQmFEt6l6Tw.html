<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Talk:  John Martinis,  &quot;Design of a Superconducting Quantum Computer&quot; | Coder Coacher - Coaching Coders</title><meta content="Tech Talk:  John Martinis,  &quot;Design of a Superconducting Quantum Computer&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Talk:  John Martinis,  &quot;Design of a Superconducting Quantum Computer&quot;</b></h2><h5 class="post__date">2014-02-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HQmFEt6l6Tw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon thanks everybody for
coming some of the remote sites to
attend the talk by John mustiness about
the design of a superconducting quantum
computer and we are very pleased to have
John here with us yet just a short ride
from UC Santa Barbara and reasonably
excited as John is considered one of the
war if not the world authority on
superconducting qubits so since is the
current machine we're working on this is
based on superconducting qubits of
course his opinion and advice would be a
very important for the guidance of our
project so John got his PhD in physics
in 1987 from UC Berkeley in California
but then went to France to the
commissary yard energiya to make in
Saclay afterwards you were missed in in
Boulder and then in 2004 a Saturday he's
right now being full professor at UC
Santa Barbara and then in 2010 Leah nice
achievement getting the AAS science
breakthrough was a year award for his
work on a quantum mechanical oscillator
so yeah are very curious to hear you
okay thank you very much well one last
thing I should say is you remote sites
when the talk is over at this time you
guys would be able to unmute and then
you can ask questions remotely thank you
yeah thank you very much for the kind
invitation to come here I have a son
who's a computer science major at UC
Berkeley and you know when you don't
know if you have kids we do have kids
and they're young the parents can do no
wrong and then they turn into teenagers
and their esteem of you kind of goes
down and then as they get into the real
world you suddenly become more and more
intelligent for some reason so have
coming to Google for my son is is
totally cool makes me totally cool so
I'm kind of a that much higher esteem
today
doing this I want to talk about our
project now to work on superconducting
qubits and talk about some recent recent
kind of amazing results here this is
maybe one of the first times we're going
to we're talking about these results
quantum computing the ideas of quantum
computing have been around for twenty
twenty-five years or so the idea here is
you can do some kind of calculations
maybe much much more powerfully than you
can ever do with the classical computer
taking advantage of quantum states but
you know it's been 20 years or so and
you might ask ask well is it really
possible to actually build a quantum
computer it's a maybe a Firoz dream or
I've ever heard one peep paper call it a
nightmare physics nightmare to build a
quantum computer it's really hard we've
been going at it for twenty years are we
really going to get there is it possible
and what I want to do is talk today
about some recent kind of some
theoretical understanding the last few
years and some recent results in the
last year really coming up to data I'm
going to show data we taken in the last
few weeks where we really think we can
build a fault-tolerant quantum computer
okay and we can start down a road to
really harvest
take advantage of the power of quantum
computation so the I'm going to talk
about the theory I'm going to talk about
our new super conducting qubits
basically here with the theory for
fault-tolerant quantum computer you have
to make your qubits well with an error
per step of about 1% then you can start
building a quantum computer I'm going to
show here that in fact we've done that
to kind of motivate this I want to talk
a little bit about D way because people
get Google elsewhere are thinking about
that an exponential computing power and
then a little bit more about the need
for fault tolerant computer computation
to do this so let's just start with the
d-wave here's their machine beautiful
blue picture here they have been very
clever in their market to solve
optimization problems essentially math
being into physics of what's called a
spin glass and one of the big
conjectures of the d-wave machine is
because they're doing this energy
minimization optimization mapping it to
this physics problem maybe you don't
have to build a quantum computer with
much coherence at all in fact their
machine has about 10,000 times less
coherence than the kind of devices we're
talking here so it's a different way of
looking at it and the nice thing is is
once you make that conjecture and
assumption it's not too hard to go ahead
and use kind of standard Johson Junction
fabrication and build a build a device
to try to do this so it's an interesting
conjecture the machine has Sapir superb
engineering it really is very very nice
piece of work with the low-temperature
physics involved in all that the problem
is well although they think it could be
useful whatever a lot of physicists are
very skeptical whether it will have
exponential computing power and I've
barely been enjoying talking to people
at here at Google and other places
because they've said well what does
nature have to say in this so they've
actually taken the machine and done some
experiments and I'm just going to review
that the experiments here and this is
basically the system size versus the
time that it takes for them let's say
the d-wave machine to anneal to the
effectively the ground state you're
doing the spin glass problem with some
with random couplings between the spins
and they're plotting a kind of a typical
mean execution time and with the d-wave
machine initially for small numbers up
to maybe a hundred it was pretty flat
but now it's if the latest results up to
512 is starting to grow exponentially
this disk growth exponential exponential
growth is actually matched by some
quantum simulated annealing at both
stimulated classical neoui and other
other methods so you it's it's kind of
the preliminary results here or you know
maybe for this particular class of
problems it's no faster than classical
code although people are looking at it
that's not a firm conclusion yet and one
has to do more work to see exactly
what's going on in 2d wave and can you
use it we're going to take an approach
that's very very different than this D
way machine it's kind of the
conventional classical approach where
physicists have proved theoretically
okay it's still only theory but they
have a very strong belief they should be
able to build a computer with
exponential power let me just explain
that briefly it's easy to understand you
take a regular computer and the
classical computer scales linearly with
say the speed of the processor or the
number of processors it's very well
understood the beauty of like CMOS is
that the growth of this power actually
goes exponentially in time because of
the technology improves provements but
it's linearly with say speed or
processor number however in the quantum
computer these power and his power grows
exponentially and the basic way to see
this is in a quantum computer it's not
just a 0 or a 1 state you can put it in
a superposition of a zero in one state
just like you say that that ad electron
is orbiting around an atom and it can be
on one side of the atom or the other
there's electron cloud at the same time
you can have these quantum bit states
that are both 0 and 1 at the same time
so if here for example we take 3 quantum
bits put it as a super ition a 0 and 1
you write that out you have 8 possible
states that the initial state can be in
and you're in a quantum linear
superposition of all those states and
the idea is you take this one state you
run it through your quantum computer and
that's basically taking the all eight
possible input states and parallel
processing them in one operation through
the computer so the quantum
computer allows you to do amazing
parallel processing here as two to the
three eight states or in general to the
end states so if you have some quantum
computer with 64 bits you're processing
to the 64 states at once to get a
doubling in power what do you do you
just here here you would you double the
size of it here to double the power with
the quantum computer you just add one
more bit and you've just doubled the
price of parallel processing power and
by the time you get something like the
200 quantum bit quantum computer the
parallelization that you're doing is
greater than 2 to the 200 is greater
than number of atoms in the universe so
you're clearly doing something there
that's kind of amazing ok the problem
however is that you're doing this
parallel processing but you only get n
bits when you measure the system only
get n bits of information and you have
to kind of encode the problem and only
can solve certain problems to take care
of that to take advantage of that kind
of optimization so I'm not going to go
into that very much here but I am going
to talk about one application of this it
turns out the government's interested in
this and that is factoring a large
number into its component primes and
this to for example take the idea of
factoring a 2,000 bit number the
algorithms from doing that scales
exponentially and right now if you take
a 640 bit number that takes about 30 CPU
years to factor that into the composite
Prime's and then if you say ok you take
this and you X eventually scale up to
some number like 2,000 bit which is
something you might you might think of
doing what you have to do to get there
so what I've drawn here is I think this
is some kind of Google supercomputer
here I put this especially for this talk
what would you have to build to factor a
2,000 bit number you would have to
basically build a computer farm almost
the size of North
and you see I put it up in Canada you
get natural cooling not too many people
there
I think the polar bears would be happy
for that to be there because there be a
lot of people to eat and that'd be good
for them but with that size if you build
something that size you could do this
problem in a 10-year runtime okay it's
possible with that size however that's
maybe 10 to the 6 trillion dollars which
even with quantitative easing I don't
know if the gutteral government could
even do that
it takes about 10 to the 5 times the
world's power consumption and it would
consume all of the Earth's energy in one
day so you know I know Google you like
to think big but I'm going to just
conjecture you're not going to want to
do this it says this is not practical so
when I get this example because I want
to show you just how reasonable a
quantum computer might look ok and we
don't quite know how to build that now
we have a general idea we need about 200
million physical qubits 100,000 let's
call logical qubits you could probably
put this in some building size maybe
even fit in this particular lecture room
with a bunch of refrigerators and
control electronics may be a small
supercomputer 24 hour runtime I don't
know what the these facts are but
probably be the cost of a satellite or
two and certainly not consume that much
power so it's something you can imagine
possibly doing if you understood all the
technology on how to build this I'm kind
of the basis of how to build this and
the hardware is what I want to talk
about today so if you're building it's
really great you have this potential
exponential scaling exponential power of
the quantum computer but the problem is
is that the qubit states are really
really fragile ok and it turns out that
you've got more power than in fragility
but you have to build this in the right
way to take advantage of it so I'm going
to give an example here and just try to
understand qubit errors take for example
a coin
we're talking about classical bit we're
going to talk about a coin on its Abel
okay this is a stable piece of classical
information okay why is that if I jiggle
my hand some air is going on there it
stays it either the head or the stale
tail State it stays a zero or one if I
jiggle it hard enough you can imagine
the tip of the coin lifting up a little
bit but if it does so the the restoring
first dissipation is going to have it
push it down again it'll stay in one
state or the other and this is the basic
idea of classical bits is you can make
them stable and they can be extremely
stable and you don't have to worry about
them having it error and if you do have
errors you can take care of it but
they're fundamentally can be made stable
a quantum bit in analogy is not stable
like the classical bit so just using the
coin analogy you could say this is zero
and this is one but zero plus one is
maybe the coin standing up on edge and
in fact with different phases it's going
to have a cascoon can turn around you
can have different angles you can have a
wide variety of states here I think the
right analogy to think about that is a
coin in space where there's no table
holding it down to one state and you
could set initially that coin with some
angle which would be some quantum state
but you could see that any small
perturbation any small force a puff of
air whatever is going to start rotating
that coin and then giving you an error
it's just fundamentally different
situation when you don't have this
self-correcting error self-correcting
mechanism that you do with a classical
bit so that's kind of the problem it's
actually when you go through the quantum
physics it's it's really fundamental
that you have this kind of problem and
the idea is you can write a wavefunction
that's in the amplitude how much zero
and one you have and also there's a
phase associated with a the one state
which is like the the coin turning
around in this direction and these two
kind of variables amplitude and
you have to worry about and you have to
think about well will measurement
fluctuations caused these amplitude and
phase to flip in some way now quantum
mechanics says that there's this thing
called operators in that for the
amplitude and phase this is an ant flip
operator which flips a 0 to 1 and 1 to 0
and a phase which changes the phase of
the wave function from plus 1 and minus
1 and these particular operations that
we say they do not commute and it's
basically saying and if we take and we
do an ant we do a amplitude flip and
then do a phase flip that's not the same
as doing a phase flip and then doing an
amplitude flip ok and these two
operations they they're the order
matters and that's like saying that when
you have a electron along the atom the
position and momentum don't commute and
if you try to measure position you
affect the momentum things like that
maybe you've heard in some basic physics
courses this happens with both is
amplitude and phase information that
they do not commute and in fact if you
if you look at it carefully and I hope
people will go away and do this with
your hand doing an amplitude flip and
then a phase flip or a phase flip and
then an amplitude flip you're going to
say hey wait a second those are doing
the same thing classically they do the
same thing but quantum mechanically
those two operations are different
because there's a minus sign involved in
that now you don't normally see that
minus sign because the end probability
of doing something in quantum mechanics
squares that minus sign so it looks like
the same thing but quantum mechanically
if you build a quantum computer these
are fundamentally two different states
and you would see you would see that
effect and this is kind of talked about
that it's the minus sign is that the sum
of these two operations in 0 instead of
the regular commutation relation so this
is a little bit mathematical but I want
to show I wanted to bring up
mathematics to show you how this problem
is solved in quantum computation it's
kind of very simple and you can
understand it it's very much like in
classical error free error correction
classically and what you do here is you
now can instead of one bit which doesn't
work in this way you now take two bits
and now you make a parity kind of
measurement between two bits so there's
an amplitude but we call it a bit flip
parity X 1 and X 2 and then there's a
phase flip parity so it's like having
two coins and then we can flip both of
them or we can phase flip both of them
at the same time this just do some math
where you can look at this commutation
relation which describes the essential
physics you now see that you have these
pairs of these and I'm going to flip
these around with a minus sign okay and
then we use this amazing mathematical
relationship minus squared is equal to 1
you see there's a minus here and a minus
here and that means this thing is equal
to this and that's the commutation is
zero so even though a single qubit has a
strange quantum mechanical behavior when
you look at the relationship for two
qubits they obey classically both in
amplitude and phase and thus you build
error detection protocols that are based
that you can do these essential
classical measurements on two bits on
parity measurements ok so let's say we
take 2 bits because of these we measure
this phase that parity it's plus 1 and
then we do amplitude parity it's minus 1
what does commutation relation equal to
zero means as I can continue to measure
this over and over again I'm going to
get a plus 1 for the blue and minus 1
for the red and it's stable and in fact
one measurement doesn't the affect the
other ok so now what we could do is take
these two coins if you like
and we measure eat in this way and then
if it just stays plus or minus one it
never changes we know that everything is
okay however if one of them changes
let's say plus one the minus one then we
know we had an error okay we can measure
that now of course you're going to say
well how do you know which qubit was an
error and it's very easy once you know
about error correction what we can do is
have three qubits right here we do the
z1 two measurement between here and here
and the z2 three between here and here
and then if this one was an error then
these two these guys are going to change
if this one flipped is it this one only
changed if this flips both of these
change and this flips this one here will
change in this one won't so you see by
having the two measurements and three
qubits we can figure out which one
changed okay so you can identify the
qubit errors so you can see that you can
scale this up and make it more and more
accurate the problem here is if you have
two qubits at the same time that made an
error you can't detect it but if you
make it longer and longer it's just like
classical error correction you can fix
that okay so now I want to talk a little
bit about what the full quantum computer
would look like you bets to basically
take this idea and scale it up some you
make a huge array of qubits we call
these open circles the data qubits and
then the closed circle here our
measurement qubits and the measurement
qubits are measuring the four qubits
around them okay and here's some circuit
that does this this is basically the
quantum version of a C naught or
something called an XOR and this circuit
basically measures the parity of these
four things here and same thing with
this and measures what's called a phase
parity in the in the normal way that you
would think about parity and then you
just repeat this over and over again
repeat these measurements okay that's
all that the surface code does so how
does it work
you have to realize for these
measurements here measuring these four
here and measuring four cubits here are
not going to affect each other so that
they're separate cubits the only time
you have to worry about them affecting
each other is these cubits here and
these cubits here but notice that
there's a pair of cubits that identified
with this and this and that means
because of that paring and because -
squared is one these two measurements
commute with each other and you could
simultaneously know the answer here then
the answer here and if you run the
surface code you'll get a bunch of these
measurement outcomes that will be
constant over time unless there's an
error if there's error you're going to
get like a bit slit somewhere and then
you're going to measure that so for
example you might be running it there
all these measurements are the same and
then at some period point in time you'll
see that this plus one terms o minus one
and this minus one year turned to a plus
one to get a pair of errors this error
here says one of these four cubits
flipped this error here says one of
these four give cubits flip and you
naturally say okay it was this cubit
that was an error okay and you can do
the same thing down here this error here
says one of these for this said one of
three so you identify an error there you
can do the same thing in case there's a
measurement error instead of a
correlative pairs in space it'll be two
pairs in time okay so that's what you do
is you just run the surface code no
errors all these numbers come up the
same time same thing every time if you
see errors in that you can figure out
what thing add the error of course the
problem is is if you run this every once
in a while you'll get a bunch of errors
at one time and then the question is can
I back out what really happened in the
surface code most of the time you can
but the errors come out when you can't
figure that out and that's what it kind
of breaks down and I'll talk about that
a little bit more mathematically in a
second so I've talked about how to pull
out the
errors but actually how do you store
information in this and it's actually
stored in a very similar way you you
that you would see with classical codes
and that we store the information in a
it's kind of in a parity way across all
the bits ok so let's just look at this
for a second we have 41 circles which
are the data qubits and 40 measurements
which are the closed circles and you
might think that if there's one more
data cube it than measurements you would
think that there's an extra degree of
freedom to store the quantum state that
that's true and the quantum state in
this case is stored by a string of data
qubits going across this arranged in the
in a in the bit part is stored in this
way and the phase part is stored in this
way and these particular they're called
operators that describe the state they
anti commute with each other so they act
like a qubit and the all these commute
with all the measurements so they're
stabilized in the normal way I'm not
them no one will get into this in too
much detail but you can make something
look like a qubit because of that just
building a bigger bigger space how big
do you need to make it to make this
accurate well that's done with some
simulations that look into the logical
error rates and what we do there is we
take the basic surface code cycle and
then you put an ability to have some
kind of quantum error in each step with
a surface code cycle okay and then you
run the surface code cycle when you have
some algorithm minimum weight matching
algorithm that says if we measure some
errors what was the actual logical error
and if it matches the errors that came
up and here we say it was error
corrected properly and then every once
in a while you see that the logical
error is not corrected and that will be
a logical error and what this is is the
logical error versus the error
probability P put per step and you see
basically as the error probability goes
down then the logical errors go down is
you
expect but then as you make the array
size bigger and bigger then the
illogical error rate goes down faster
and faster as long as you're below some
number of around one percent in the
error probability okay and this is
called the threshold of about one
percent error and as long as you're
below that and you have a big enough
dimension big enough sigh surface code
then the error will get exponentially
small and that's how you use tor you
have a you can store a qubit state for a
very long time without errors you just
make the make it good enough and make it
big enough no different than classical
error correction just a little bit more
complicated because of the quantum
physics here but the concepts are the
same now it turns out you can understand
this behavior in a simple way this high
school statistics which is these kind of
concepts you use all the time in
classical computing let's just take one
one row here of a surface code array and
say at some point of time I had an error
in measurement here and here and here
and when you see this you say look if I
have an error here and here that means
you had a data qubit Eric here there's
an error here but not an error here so
I'm going to associate this error with
the qubit at the end and this is a
correct Association of a data qubit from
here to here but it turns out that that
backing out of the real error is not
unique you can also take the complement
and the complement also solves this and
your question is of course which one you
take well obviously this has two errors
it's going to go as this P squared this
is three errors P cubed this is more
likely than this so you're going to
choose this and B right most of the time
but every so often with probability P
cubed you're going to get a logical
error given by this and you can work out
the you know this is high school
statistics and then write down a
formula for this and you see that this
very simple description of this it
fairly well matches this and there's
some subtlety that it doesn't pick up
but you basically get the idea okay so
that's how error correction works and it
just means you need to have small errors
and a big enough size and this is just
taking the formula we got here and I say
let's hold our qubit state with a
logical error rate of 10 to minus 5
which is 1 second time 10 to minus 10 a
day and 10 demise 20 little bit more as
the lifetime of the universe and you see
that if you can be like at a point 1
percent error here and make a few
thousand cubits you can hold a qubit
state this fragile quantum state for the
lifetime of the universe that's cool ok
and of course that's kind of what you'd
have to do if you have a hundred million
qubits doing some algorithm you need to
have some kind of small logical error
rate to run an algorithm properly but
you can actually approach lifetimes of
states with this idea like you know what
you get for classical bits playing this
game but it takes a lot of resources
it's just what physics requires you I've
talked about memory you need to do
logical operations on it what's really
beautiful about the surface code is you
just build this big code and then you
can make additional qubits by
essentially what's called putting holes
in it in the middle of this where you
turn off the surface code measurement
and then you have a bunch of states that
can then generate the qubit state and
then you can do operations the most
interesting is is by taking one of these
holes and moving the hole around another
one you then produce a logical C naught
or XOR operation you can do other things
so basically with this basic surface
code you can build up and do logical
operations and do quantum computation
without error if it's big enough
okay so what I want to do now is I want
to talk about how we're going to
implement this and we're using
superconducting qubits and these are
like you know you can think of these as
atomic systems like an electron around a
nucleus but in this case we're building
electrical circuits where the quantum
mechanical variables are current and
voltage so you have a wire and you have
the current flowing to the right and the
current flowing to the left at the same
time with some quantum mechanical wave
function just like an electron can be on
one side and the other side of atom at
the same time so concurrent and voltages
it's possible to do that these circuits
are typically work in the microwave
range 5 gigahertz and to have the energy
of these systems which is HF to be
greater than KT we need to operate them
in 20 millikelvin ranges and that's not
hard at all with something called a
dilution refrigerator this is well
established technology now what happens
is we can build these various qubit
systems if you for example take an
inductor and capacitor or in this case
we have a transmission line of a certain
length which has resonant modes that
look like piano string resonant modes
this looks like a harmonic oscillator if
you look at the quantum mechanics of
that they have equally spaced energy
levels and you would say oh let's just
take the two lowest energy levels and
make that a qubit state that's
essentially what we do in our system the
problem is is that for this linear
harmonic oscillator these two energy
levels are the same so you drive this
you drive this you drive this transition
you draw a drifts transition and the
state just wanders all the way up and
down here with many quantum states
however you can use a Johson junction
which is basically two metals separated
by a very thin insulating barrier so
that electrons can tunnel through that
barrier then you get a nonlinear
inductance from this particular quantum
inductance device you then turn this
quadratic potential into what's
looks like a cosign potential this is
now a nonlinear potential so that when
you look at the energy levels they are
not equally spaced and now when you
drive this transition this is off
resonance and then nothing happens there
you stay within your qubit States and
then you can build a quantum bit out of
it okay so this is how we make them we
build integrated circuits right now it's
aluminum metal for the metal and the
Johson Junction what pink is in here is
basically aluminum it's on a very low
loss sapphire substrate we just use
standard IC fabrication technology
there's quite detailed material issues
you have to deal with which we've been
working on for 10 years and 50
researchers just in my loop group
there's a lot of other people working on
this too but nowadays we know how to
make it so that these are really very
well made these little X straights here
of structures here are these called X
Mon qubits
they're capacitively coupled to each
other the wires to control them are
coming in from the bottom and then these
wires here come from the top and then we
can read out the qubit state by putting
microwave signals through this here and
I'll explain how that works but the it's
really standard IC fabrication nothing a
kind of amazing you just have to choose
the right materials and make it in a
particular way and this X Mon qubit we
basically have a ground plane to the
outside and that just forms a capacitor
in this X we have this Josephson
junction that forms an L that L
nonlinear LC resonance forms the qubit
and then we have a loop here with a line
coming in here and we can change the
inductance we change the frequency of
the qubit can also put microwaves in
here capacitively coupled those
microwaves force electrically force
current into the
the X Mon and cause it to make
transitions from the ground state to the
first excited state so by put it in
microwaves putting in a change in
frequency we can completely control the
qubit okay this is a picture kind of a
graduate student lying on the ground as
he's putting it together in the in the
dilution refrigerator these chips go
inside this aluminum box and then coming
out of it our coax wires through some
filters and other structures and then we
have a lot of coax that Gus goes from
here to the top of the cryostat at room
temperature and then to the electronics
over here and you just as when it's open
you put a bunch of infrared shields and
a vacuum jacket around this and cool it
down with liquid helium and you can get
to 20 millikelvin so that you get rid of
all the electrical noise in the system
and then it's just all controlled with
all these microwave electronics here a
lot of test equipment but everything is
controlled over here by a computer so
that it's easy to set up the experiment
and get it to work so this is just some
simple way to think about the qubits the
first one we call a Rabi oscillation in
this particular case we take our coin
and we have it in the ground state and
then with microwaves we flip the coin we
rotate the coin at a steady rate that's
proportional to microwave amplitude and
a certain time we stop the rotation and
then measure whether it's zero or one
state of course that's probabilistic if
it's going on edge half the time it will
be heads and half the final details but
you can do the experiment many times to
get a probability and what you see here
is you just rotate longer and longer
you're just flipping from heads to tails
0 to 1 up and down and you see that it's
the magnitude of the oscillation doesn't
decrease in time because we have very
good coherence of the system so the
typical timescale that we can flip the
system is maybe 10 20 nanoseconds and
then the typical lifetime of the system
which is given here where we go from
zero to one and then we measure if it's
in the one state versus time and
eventually decays and relaxes to the
zero state but that does that in say 30
microseconds and the ratio between this
and this is a factor of a thousand so we
should be getting roughly 0.1 percent
error per gate and that's that would be
in principle good enough to do this
error corrected quantum computer so but
that's of course only in principle
actually how do you make the gates so I
want briefly to talk about the gates and
what we do and I want to show you that
we can make very complex gates and this
system works extremely well and what we
have here is a something called
randomized benchmarking where we're
putting in a very long sequence of gates
into the system and seeing it for
controlling the state now in this
particular case with randomized
benchmarking we're going from zero to
one or from zero to zero plus one or
four phases so this is kind of going of
six equally spaced points on this what's
called a block sphere so it's a kind of
reduce static quantum states but the
nice thing about going to these
particular set of states and rotating or
getting them into those states is this
forms a gate set that you can calculate
very easily just with classical
computation and forms a generic base set
that you can calculate very carefully
and know what's going to happen so what
we do here is we just take a bunch of
these different rotations to take these
state all around the Bloch sphere over
and over again and at the end we know
where it should be and then we rotate it
back to pointing this way in the zero
and we see if it's in the zero state or
not and then we do that complicated
sequence of pulses as shown here we then
do it for other kind of gates that move
it in a different sequence and then
average all that and say okay do we get
into the ground state and we see of
course that it's not in the ground state
perfectly
but then for you to have an error that's
appear and this is point one sighs so
this is not a huge error we can make
hundreds and hundreds of gates here in
arbitrary combination and we you know
more or less get this right answer here
and you can work out the statistics and
this says that the fidelity of these
operations are 99.9 three percent so
only one gate and a thousand is going to
give you a significant error and in fact
you can understand this a little bit
more you can interleave these with
specific gates here and very much
quantify what's going on here but the
end result here is we can make these
quantum gates well beyond the 99% that
we need to do the surface code and the
error free correction okay that's one
qubit we have to run q qubits at the
same time to do some parallel processing
we take those two qubits set them at
different frequencies even though
they're kind of coupling here
capacitively when you put it at two
frequencies it effectively turns off the
interaction you run your clifford gates
ninety-nine point nine four nine five
individually you then run them at the
same time because they're detune there's
basically the no degradation of gate
fidelity this numbers smaller because
you're adding the errors of this and
this and the way we do it so there's
natural crosstalk you know we should be
able to operate these things in parallel
we can also need to couple them together
we have to make this C not kind of gate
that I was talking about this in fact is
the hard thing to do and this is what
people have been trying to do for twenty
years to get this gate good this is the
hard gate okay and we think we've
cracked this conventional thinking you
operate this qubits in a very stable
configuration so that it's not frequency
tunable it's like an atomic clock kind
of thing it gives the longest memory
then you connect them through some kind
of quantum bus where that qubit connects
to
resonator cavity connects to something
else that gives you long-distance
communication you then do some complex
microwave or photon drive to get all
these things to interact and get it to
work and long is very complex and you
get it to work okay I own traps for
example or at about 99% super ducting
qubits when they do that these are kind
of slow gates ten times slower than what
I've been talking about fidelity is not
so great okay what we've done here is a
totally different design we've taken all
the conventional theory of a thinking
and turned it on its head okay
we use adjustable frequency qubit and
that's actually good because we can move
them in and out of resonance and turn on
and off the interaction we have direct
qubit coupling no intermediate quantum
bus that can give us decoherence and
then instead of driving it with
microwaves or photons we just change it
with a DC pulse to change the frequency
I need accurate you need to do that
accurately but it can be done
theory says this should be really good
acceptable experimentally we do this
these are some tune-up procedures it's
for a control Z that's equivalent to the
C naught we can get this pi phase shift
is minus one side that's shown here this
shows with full quantum states is acting
in a way it should be I'm running out of
time so I'm going to go over this
quickly but basically things are working
right you do randomized benchmarking
these are the control Z gates we get a
fast gate that's very accurate
ninety-nine point four five percent as
shown here and sorry I can't go into
this much this is best in the world okay
the is better than ion traps better than
other qubits we know how to improve it
his basic idea works very well okay let
me talk about qubit measurements I'll be
done in four or five slides or so you
have to measure the qubit what we have
here is this cube
and then it's capacitively coupled to a
microwave resonator right here and then
that is also capacitively coupled to
another through sensor circuit right
here so these being capacitively coupled
it turns out that there's no energy
exchange between the qubit and here but
the frequency of this particular
resonator changes depending on whether
this is a 0 or 1 state so what we do is
we put a microwave signal here that's
resonant with this frequency it couples
to that and because this frequency
changes because of this being the zero
in one state that will introduce a delay
in this microwave depending on whether
it's a 0 or 1 state you then measure
that with a quantum limited preamplifier
in room temperature analog to digital
converter and fpga they measure the
phase shift and you can tell what's
going on in the system so here's just
more details of that here's the drive
signal you put about a hundred photons
into that one resonator that has a
frequency shift here has plotted the
real and imaginary part of the signal
that you're measuring here if you're in
the zero state you have the phase so
it's over here if you're in the one
state the phase is over here and
integrating over about a hundred
nanoseconds you see these two signals
are super well separate as separated and
then you just say if it's on this side
it's a zero and it's sides of one these
are plots that are basically showing
what the separation error is because
they're these have gaussian tails there
are small errors between this but it
basically says in a few times the
operation of our single or two qubit
operations we can see separation errors
that are 10 to minus 2 to 10 to minus 3
so we can measure the states extremely
accurately finally we need to measure
more than one qubit we talked about this
one here we also have another qubit here
with another resonator
these are at two different frequencies
so you put in two tones here this tone
here gets shifted depending on the state
this tone here gets shifted depending on
this state you amplify that all the FPGA
can separate out these two frequencies
get the amplitude and phase and then
tell whether it's a zero one state so
this is just data coming from this is
the readout signal of one qubit versus
the other if we put a zero zero in here
this ends up here if it's one zero one
it ends up here 1 0 here 0 1 here with
the other states these states are all
separated very nicely from each other so
you can accurately measurement multiple
qubits you know in a very short amount
of time we know how to scale that up and
this is again this is above the
threshold everything works well last
thing this is maybe people here will
understand when you're building these
complex systems you have to have
strapped away the functions you have a
lot of complicated things going on here
in our system we can scale with all this
stuff with good control using software
distraction which includes calibration
of the hardware and waveform and
non-ideal realities specific qubit
calibrations ok so you basically
calibrate the whole system and that
takes maybe program hundred thousand
lines of code I mean you're you
understand that and then once you do all
that if you want to do some complicated
algorithm here it's but seven lines of
code you just say I want to do these
particular gates and all the
calibrations are done for you you just
put in the gates run it you're done so
at this point running the programs are
really essentially trivial as it is it's
all just calibrating it up the amazing
thing is that we can calibrate this up
and we run it and it runs super well
it runs as as you know with with the
errors that I showed you so it is
possible to build this hardware system
to extract it away as you would need to
do okay so I'm think it's about my 50
minutes is up I want to summarize and
talk about the outlook you know people
been wanting to build a quantum computer
a fault-tolerant quantum computer that
would potentially eventually give and
give you enough just exponential power
we've been looking at this for 20 years
in experimental realm we think that our
particular technology is now good enough
to do fault tolerant computation this
would be very hard to scale up we have a
lot of technical challenges but the
basic ingredients that to do this are
there it's at least good enough that we
really have to start doing this
seriously ok no more playing around
writing physics papers all over in do
that too it's time to get serious and
build this quantum computer the surface
codes needs 99% fidelity we have 99.3
99.5 measurements good enough we think
this is scalable improvements are likely
here so we can we can do well ok so the
numbers are there we it's time to time
to get started what I'm looking at based
on what I've talked to you here I would
like to start which i think is roughly a
five-year project although you know we
can have problems may take a little bit
longer but I think we understand the
basic technology and it's basically the
scale up 200 maybe thousands of qubits
using the surface Oracle architecture
and then try to do one with an logical
error rate 10 to minus 15 hold a qubit
state these incredibly fragile quantum
states and hold it for in a hundred
years or a thousand years a really long
time showing that it would be ok and
then this would be big enough so that
you can start doing these like braiding
operations or whatever to do logic
operations at 10 to minus 6 errors and I
think this
their science project is what's needed
right now to show that all these ideas
are correct in a way that we understand
that the power is there and then if this
works you would then go ahead and if
you've got all the technology right who
would try to build something you know
that was useful and can do some things
but we really want to focus on getting
the science right and understanding it
in the next five years and we really
think that's that's doable not just me
all the graduate students postdocs in my
lab they're doing the work they really
think this is possible along with me we
look at the technology it really looks
doable looks like something we should be
working hard on so let me end right
there here's our group at UC Santa
Barbara it really takes a lot of people
working together to to do that and we
have a larger collaboration of about 50
people with theorists and other
experimentalists to get this done it's
it's quite a lot of work really takes a
lot of teamwork but by we think the
technology is there so thank you very
much okay John woods feedback it's a
very nice talk so thanks appreciate that
you did it nicely in time so that leaves
time for some questions yes
could everybody use the microphone so
that people on the remote sides can hear
it as well hi I was wondering if you
could compare your surface code
architecture with for example like a
tour code what are the advantages and
disadvantages yeah the surface code
architecture has the highest threshold
that we know of and and that's
incredibly important because you know
it's hard to make good qubits we've been
struggling that now typically initially
people talked about codes with you
needed 99.99% Fidelity's to get at the
threshold that to me looks really hard
but at two nines that's something we can
do the other nice thing about the
surface code is it only requires nearest
neighbor interactions and if you're
building that on the integrated circuit
that's great
so I think those two things are really
the key advantages of the surface code
but you know people are looking at
different codes and different things and
if something gets better we can do that
but surface code looks really quite
ideal for building integrated circuits
thank you there's a question
that's microphone over there
um can you discuss how far along you are
towards a surface code architecture and
how and if you know how what's it going
to take to get from 2 to 41 yeah how far
along so let's just look at the surface
code oh come on
slow computer you have to make a big
array okay here this is couple hundred
cubits there are some simple versions of
the simple code surface code we can do
at five or nine cubits the kind of test
if it's working properly and we're
starting to design the chip and we hope
to have some error detection whatever
working in about three to six months
that is you no one else is even thinking
about doing that we think we can make
quite rapid progress we really want to
show that the this simple surface code
is working right and then at that point
you know I think people will get on
board that this is possible everything
is working great so we really think in
three to six months we may have that and
then we have to figure out how to make
lots of qubits but we have some ideas
but we we there's one that we really
want to demonstrate a simple version of
that code
I'm kind of scared to step in front of
the loudspeaker but connecting to this X
yet one question you mentioned scaling
up would be really hard can you list a
little bit as the main challenges you
know we know how to build more or less
the integrated circuit and we know the
materials but when you build something
like this you have to get control lines
in to all of those qubits now if you're
talking about atoms you know that are
microns apart or less it's hard to get
those control lines in but here they're
separated by hundreds of microns and we
can I see fabricate control lines to get
into that so we think we know how to do
that we have an idea on how to do the
processing and all that and then we have
to bring 100 or a thousand control lines
to the outside of a wafer then wire bond
that up to electronics at room
temperature that's just you just have to
think like a high energy physicist you
just build a lot of wires and do all
that so you know we we think we can do
that from technology we have or maybe we
just have to modestly invent something
but that's the basic idea just bring in
bring out those control wires of the
outside of the chip wire bond them all
these cables going up to racks of
electronics and for doing the scientific
demonstration we think we can do that
eventually if you want to go beyond the
thousand cubits you have to put the
control either right down in the chip
okay and that there's the technology of
classical Josephson Junction computing
which there's people been working on for
years and years and we have truly have a
program to start trying to figure out
how to do that so as we're building up
this kind of brute force way at the same
time we wanted to be developing the
classical control circuitry to do that
going back to d-wave one of the
impressive things d-wave has done is
they built that classical control it's
not exactly what we want but when I look
at what they invented
gives me a lot of hope that we can
figure that out because that's both a
combination of analog and digital so I I
you know we have we have to do the
research but I'm optimistic that that
can all be done it just it's just hard
but okay this is what you have to do and
in fact this is the hard part of
building the quantum computer you know
making good qubits Steven Chen sort
criteria yeah it's really hard to get
ninety nine point four or five percent
fidelity the hard part is the control
circuitry you have millions of qubits
how do you get all that control within
each qubit gives us basically analog
control think you can do it here now
that's going to be that that's going to
be a super challenge again to do some
physics we don't have to crack that not
yet the was also immediate saw that if
you could borrow some of the control
electronics from d-wave and apply it yet
you know their control electronics is a
different mode than this but I you know
there could be a lot of commonality and
for me it's more that they've shown that
you can mix digital and analog okay in
their way and you might want to borrow
some of the ideas or be inspired by
those ideas to do it but I really feel
that you know given people working hard
on that we can crack that problem but
you know it's something eventually we do
however if we want to show that science
works well and to have a fragile qubit
state and hold it for a hundred years I
think you can prove force that which is
one path we want to take and then at the
same time you know work on the other
things that's kind of my view of what
how things should go
there was one more question earlier but
I think me skidding yes
so how small can you make this
practically if you wanted to have and
you show a homogeneous matrix here but
if you wanted to have a bunch of
matrices maybe with some space between
them for control circuitry is this is
like ten by ten the minute yeah so
that's what I'm kind of talking about
here if you would right now we're
thinking the cell size is going to be
eventually between 100 microns to a
millimeter on a size and remember it
can't be too small because you have to
pack all that control circuitry in it so
at 100 microns on a millimeter you can
put the significant amount of control
circuitry and then if you do that say a
hundred microns
you know it's maybe you know meters
across in this direction usually have a
big you know big
so it's if they have to be a big thing
but those are the kind of the numbers
you know everyone thinks from modern
micro electronics if you have to make
everything small but as soon as you do
that you have to make your control
circuitry that small and the control
circuitry is not two transistors or
something that's complicated so that's
why you need it kind of big but these
numbers I think are you can imagine
given enough time you can solve these
problems not they're not easy problems
but I think it's possible yeah
about our basically the oil our
architecture of the our computer so like
suppose you placed a 100 our qubits on
the chip and all the control circuitry
does it mean that you already have a 100
qubit our computer so is it is this
device for practical computations or
basically the difference between
physical and logical qubits here or what
is there yeah it depends if you're
worried about error correction in your
algorithm my guess you are in you know
that's a question we're talking about
today as we get here I'm talking about
building an error corrected device so if
you build a thousand cubits you your
your error rate is going to be a hundred
years but then you could start making
smaller cubits in it where their error
rate may be one per second but then you
could do logical operations with those
qubits and test things so I'm not sure
if you could do anything practical at
that point but you can certainly test
the science and that's kind of what I'm
thinking right now and you know like
with the D way the question is the
science of it ok so we if we do the test
out the science and make sure that
everything was okay that would give us a
lot of confidence that we can move
forward and doing it because there's a
lot of theoretical assumptions here that
we have to deal with but you might be
able to use such an array without error
corrected mode in some interesting
useful way and then we would of course
do that if someone had a good plan but
the error correction kind of forces you
into a architecture but once we have the
technology we can do other things for
sure and you know for example part of
our group is looking at quantum
simulation for physics problems and
we're thinking we can do some
interesting things there now
maybe just a quickly check whether any
of the remote sites may have a question
seem to be okay
case I was wondering the remote sites
was there any questions from there I can
see them from here okay
okay any last question from here so I
satisfied then thanks for a very
interesting talk and that's very upbeat
information okay thank you
you
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>