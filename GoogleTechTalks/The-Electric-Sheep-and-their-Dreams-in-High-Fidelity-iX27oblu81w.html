<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Electric Sheep and their Dreams in High Fidelity | Coder Coacher - Coaching Coders</title><meta content="The Electric Sheep and their Dreams in High Fidelity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Electric Sheep and their Dreams in High Fidelity</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iX27oblu81w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is John Hawkins and I work
machine translation but I'm very pleased
to be introducing to you today somebody
who works in computer graphics he's
worked at DreamWorks and did his PhD at
Carnegie Mellon he's currently working
on his own projects under the umbrella
of spot works he's going to be showing
us some of the spot works productions
art today and also talking extensively
about the electric sheep screensaver
without any further ado I'll give you
the Scotch waves also a spot thanks John
see if we got all of our technology
straight
so what are you seeing right here this
is dreams in high fidelity and it was
made with the electric sheep screensaver
and I'm curious how many people here
already have seen the electric sheep or
know what it is okay that's cool it's
about about half of you and so some of
you you might can put you can probably
immediately see the see some differences
between the screen and the screen saver
in this and what I'm going to talk to
you about today is you know what this is
and you know how i made it and i'm going
to go into a lot more technical detail
than I usually do and I hope you
appreciate that and so so what is this
it was made with evolution and
mathematics none of this was drawn or
modeled or designed by me and it's
really it's really the creation of a
cyborg mind composed of 30,000 computers
and people all over the world mediated
by a genetic algorithm and it would have
taken over a hundred years for one
computer to to create to render this
whole at threaded this whole thing it's
over over one hour of work per frame so
but I'm not going to leave it up during
for the whole talk because I know you
won't remember anything I say so we're
gonna have to turn it off and I was told
to push this button
it's different okay and can you use that
or turn it off oh yeah and it also it
never repeats plays indefinitely it's
self-contained so it's it's running off
of the little shuttle PC that's sitting
over there so I wasn't kidding what I
said mathematics here are some equations
the every image that you saw is the
solution to an equation and the if you
think of the the plane are two and
there's some set a switch is the image a
part of the plane which is what you're
looking at the s in this case is defined
to be is the solution to this recursive
set equation and where these these
functions f sub I are you know map the
plane to the plane and this is sort of
these things called iterated function
systems are standard textbook kind of
fractal been around since the 80s and
this is sort of the kind of images that
they produce this this is the one on the
right is called sierpinski gasket and
when the left is made Barnsley's career
looks like a fern and people were amazed
that a natural looking image like a fern
leaf could be defined or produced or
modeled with a couple of simple a couple
of matrices but you know that's the the
magic of fractals so that's sort of
where we started and in 1992 I was
created a sort of i was working to
create better visualizations of this
kind of process and so I made three
improvements to iterated function
systems one was replacing those matrices
with nonlinear functions the other is
adding color in particular adding color
by structure and the third thing was
tone mapping which is a way of handling
large dynamic range in an image and so
what it comes down to is this this
rendering algorithm the thing that the
algorithm which draws all the pictures
that you just saw is really it's like a
particle system which is a standard
thing of computer graphics where instead
of drawing polygons or circles or lines
the images drawn with thousands or
millions or in this case actually
billions of little dots just like
imagine them as being particles of dust
which are all moving intelligently and
can reform into an into any shape and
the way the rendering algorithm works is
it's a stochastic algorithm it's
actually it's quite simple you've got a
bunch of these functions from the plane
to the plane these transformations or
mappings and the way it works is you
draw a dot on the screen you draw a
particle a random one anyone anywhere on
the screen and then you pick one of the
functions at random you have like a
collection of functions maybe two
functions maybe five functions you pick
a function at random you apply it to
that point it gives you a new point and
you draw that point and then you just
repeat and you can and so you your draw
points you draw dots all over the screen
and if you draw enough dots eventually
the image emerges out of them so here
are the functions or here's what a some
example of the functions that I that we
use are there just kind of little blobs
of algebra they don't have any special
mathematical properties they were picked
because they look good and they are
composed with the linear functions so
this AIX part is a linear function and
then you compose there's a blending
vector the little visa by V sub J's
things which is a knob for each of the
nonlinear functions which says how much
of it is present so the color comes from
adding a third coordinate to the
iteration so instead of just having
points on the plane with two coordinates
that get bounced around you actually
have points in a three dimensional space
and the third coordinate is looked up in
a palette before it gets drawn and this
is a different way of there's a lot lots
of ways of adding color to iterate
function system image and the way that
people did it previously was usually
coloring by density which is kind of a
scientific approach to to to
visualization where you know like you
can imagine like an infrared picture
where like the the parts that are less
dense or have less particles get caught
get like colored in blue and the parts
of the image that are more dense or have
more particles you know get colored in
like red the problem with using that
kind of colerain are that kind of
palette is that it's as the as the image
moves the different parts of it change
color and that doesn't look natural it
doesn't look like an object in motion it
looks like you know you're wearing
infrared goggles or something so doing
up doing it like this is important to to
make it look realistic another thing
that's important is that it actually is
using a palette which is sort of like
you know a list of 256 colors you know
arbic from you know from data it's not
and it's not algebraic a lot of people
who use or do genetic algorithms to do
graphics you have some formula which
gives you RGB values which is the colors
that get drawn on the screen and when
you do that you end up with colors that
look kind of very RGB or they don't have
any
of coherence and the colors here were
originally derived from the palettes
were originally derived from you know
natural things like photographs of
landscapes or like paintings by famous
people and there's an algorithm which
can like derive the palette and then
that was the source of all the original
colors so it's it looks makes it and
think makes it look about much less
mathematical and so these are the kinds
of images that that this fractal flame
algorithm produces and these are these
are the actual files that I rendered
back in 92 or 93 I think so just to
review this sort of the genetic code
here or the parameter space so that the
thing that produces the image is there's
250 floating point numbers in the
genetic code that comes from all those
matrix coefficients those 2 by 3
matrices and then all the coefficients
for the nonlinear functions and it's
notice it's really described as strictly
a two-dimensional process you're just
you have points in the plane and you're
they have color but you're you're
drawing them and as you'll see I'll show
you some examples the results sometimes
look three-dimensional and there's a
sort of an interesting kind of trick
that produces that that I'll explain but
what I want to emphasize here is that
the image is sort of in a emerges or is
a is a resonance that comes from these
geometric transformation so it's not
images that are drawn or it's not
geometry that's strong so it's it's not
using your your 3d graphics card in it's
really just a simple C program that sort
of solves this equation so but it's it's
a simple program but it can have some
rather interesting results here's a one
that appeared a couple months ago and
I've shown you this one in particular
because it has this 3d illusion
if you look at the blue arcs in the
middle in particular to me it sure looks
like those blue arcs are over the yellow
or in front of the sort of orange
background so how did A to D algorithm
do that there's a close up and so the
answer is this this town map so that
when the way the images are drawn the
brightness of any one pixel is
proportional to the logarithm of the
number of particles that are in it and
the reason it does that is because
there's a really wide dynamic range of
of densities like many natural phenomena
is there it follows a power law and
you'll have some pixels that might have
you know five particles in it or 10
particles in it and you'll have some
other pixels and another part of the
image that have you know 500 and another
part of the image it might be you know
50,000 or a million and so it's it's a
difficult if you just displayed a linear
mapping between the number of particles
and sort of the brightness of the pixel
you'd end up with a few pixels that were
completely white but most of the image
would be completely black and so you
need some kind of dynamic range
compression and wrote to be able to sort
of see the image see all the detail all
the information in the image we need
photography and computer you know has
the same problem in computer graphics
has had this problem for a long time how
can you represent brightnesses that vary
from the Sun to a dark room with just
eight bits and so you can't you have to
squeeze things down somehow so I use the
logarithm and it has this interesting
property that say you have so you have
two parts of the of the fractal one with
the density of 100 in orange and the
other one with the density of a thousand
what at which I drew in blue the place
where they cross has a density of 1,100
but the logarithm of 1,100 is only
slightly greater than the logarithm of a
thousand and so
the area where they cross looks the same
as the one that's in front what so more
or less the way the algorithm draws
whatever is sort of more dense appears
to be in front even though everything
even though there's no Z coordinate
there's no actual nothing actually
happening in three dimensions so this
was this was not didn't happen by design
but we'll just one of many things that
just kind of accumulated along the way
so what I described so far who is an
algorithm that can take a genetic code
which is a set of these transformations
in the plane and creates an image but
it's just a still image so let me so
where did the animation come from and
the answer is you know pretty simple by
you know by changing the parameters in
the genetic code by changing some of
those floating point numbers over time
then the resulting image solution
changes over time and that's animation
so what it would specifically what it
does are is it uses the the matrices the
that are in that's in the genetic code
and it just wrote applies rotations to
those matrices and the nice thing about
rotations is when they're when you're
finished rotating your back to where you
started and so therefore the animation
that gets produced by rotating one of
these matrices is also the the image
ends where it started so the Imps or the
animation loops which is makes them
useful for for V Jane for one thing but
also makes them very put together in
this really nice way for playback so it
also makes transitions so between any
two parameter sets between any two
genomes you can do a smooth morph by
interpolating in the genetic space and
then you'll also get an interpolation in
yet in the image space that has the same
end points and it uses sort of splines
in order to get a see one continuous
motion when that may
motion that doesn't have any sort of
jerks or jars in it because it's
possible to have continuous motion that
still has an angle in it and that sort
of feels unnatural and the end result is
that you can it can generate you can
interpolate between any two you know
genomes but it actually only has can
render you know a few of them so what
you end up with is a graph of a video
after you've rendered a bunch of sheep
and so the here we have the the blue
circles are represent individual
parameter sets or particular genomes and
each edge in this little graph of drawn
is a segment of video that gets sort of
rendered and so as you're watching the
screen saver or as you're watching the
high fidelity version of it what the
computer is doing is more or less
wandering through this graph we're just
following the edges sort of head to tail
and every time you know it plays a piece
of video and then wherever you are in
the graph there'll be multiple possible
successor video clips that smoothly
transition from wherever you are and
this is how it gets its how it doesn't
repeat even though it has only a finite
amount of video on the hard disk because
you know your computer may have because
you can sort of go through this graph in
a non repeating pattern you can make a
non-repeating movie out of a finite
amount of content so here's some
examples of animation just in Phillips
trip
so you showing how from from from one
particular image in the up in the upper
left it's got showing 8 transition to
eight other sheep and you can see that
each one is a smooth morph and which is
much more interesting than just cross
fading so these the genetic code gets
stored and communicated in a XML format
which is pretty arbitrary and it has all
the the parameters for the the
coefficients written down here and on
average these genetic codes are 1.7
kilobytes each and I came up with that
number not just by measuring the size of
it but by taking a whole bunch of them
and G zipping them and then measuring
that so that's more of a more telling it
tells you how much sort of information
is really in the genetic code rather
than how many characters it takes to
store so it's really miniscule relative
to say our genetic code or the genetic
code of any you know real animal or even
a plant and so you know why do we why do
I bother calling it a genetic code when
I just call it you know the parameters
or something like that and the answer is
because of you know what you do with
them which
which we'll get to in a little bit so
just so if continuing our our journey
sort of through history and through the
development of the project in 1999 is
when the distributed screensaver came
into existence and when this started to
go from just being a graphics project to
being a network project so it was
inspired by study at home and the ideas
which is the idea that is that you can
use a screen saver to put all the idle
computers out there on the internet to
work and then form a virtual parallel
supercomputer for really low cost and it
the actual particular inspiration was
you know I had written this software and
you know made a couple of test movies
and put it on the web is open source and
hadn't done much with it for years and
eventually so somebody else you know
made a plug-in for after effects and
then you know they worked for a sort of
a special effects company and then they
actually where they had a render farm
and you know they actually made a really
cool movie of these things dancing with
music and they put it on a video tape
this was awhile ago and sent it to me
and I was watching it and said wow this
this looks great you know but I don't
have you know all I have is my dinky
little pc it would take me weeks to even
just right you know to render this let
alone you know model it and and then
that was actually the moment we said
well you know let's just do what study
at home did and distributed on the
internet and it will be done for us so
so the electric sheep client the first
one was written about a week later and
it's open source it's GPL and the way
pretty much the way it works is you know
when your screensaver comes on your
computer contacts the server and it says
you know give me work to do it downloads
a genetic code the server gives you
something to render you render it and
then when you're done your computer
uploads a frame of JPEG to the server
and repeats well that's one thread
another thread is goes to the server and
like tries to download any new any sheep
any kind of completed animations and
displays them on your screen you know by
following that video graph and it became
pretty apparent after using this for a
while and use users started to
accumulate that the bottleneck and the
design was the MPEG video download
because pretty quickly you've got a
whole bunch a robot army of computers
all hitting your server trying to
download mpegs
unfortunately I had a legacy account at
Carnegie Mellon and they have a lot of
bandwidth it was a couple it took them a
couple years before they realized that
half of it was going to this and then
they shut it off would they what they
told me that they were nice but it was
good because then I had to fend for
myself and I found other ways which
which I'll tell you about later but
anyway so that's sort of the the
rendering through that's where the
muscle power comes from but the
intelligence is comes from this genetic
algorithm and this is also why we really
call them genetic codes instead of
parameters so everybody who's running
the screensaver they're watching the
screen there if they feel inspired they
can vote and say I like what I see by
pushing the up arrow key and if they
don't like what they see they push the
down arrow key so these votes are
transmitted to the server and the Sheep
or the designs that are most popular
have sex with each other and reproduce
and there's mutation and crossover
operators and so you probably know
mutation and mutation is you just add
some noise or like pick a random
coefficient and add a random number to
it and a crossover is a little more
complicated that's when you actually
take two genetic codes and lay them down
side by side and sort of take pieces
from each of them in order to build a
composite that's really what that's what
really what sex is mutation is can be
asexual donate the result though is that
you end up with producing new sheep that
actually look like their parents and
there's a lot of in the art world which
hold genetic algorithm thing actually
caught on quite a while ago like 10
years ago a lot of people have used it
but frequently it's effective it's
almost a completely random process if
they're if there's not like when you if
you when you modify the parameters you
know if there if the if the resulting
image is changes completely then the
genetic algorithm is no longer a sort of
a full climbing kind of search algorithm
it's more or less just hit or miss
random search so it's really important
when you do these genetic algorithms
that do the mutations and at the set and
the crossover operators not sort of
stepped too far so here's a here's an
example showing a happy parent and 888
of its descendants and I think you can
see that there's definitely you know a
resemblance so then we decided that
evolution wasn't good enough and
introduced intelligent design into the
system and I resisted calling it that
for a long time they could for the
obvious reason but it's it's actually a
perfect description of what's going on
and so I I accept it and so what is
going on more or less somebody somebody
wrote a genetic editor which is a
standard windows GUI program that you
can wear you can like edit the genetic
code directly and it has a whole bunch
of things that you can like you know
sliders and things that you can drag
around with the mouse and lots of little
dialogues where you can type in numbers
and while you're doing this it shows you
the image that your would have the this
genetic code would produce in draft mode
in real time and so when users come up
with something that they like you know
they can use a menu command to sort of
post it into the gene pool and sort of
submit it and I guess distributed to
everybody
machine it shows up on their screens and
you know if they are and if they've if
it's popular people vote for it then it
will reproduce and sort of variations of
it will appear and an important part of
that is that the intellectual property
Park which is you know more or less we
have artists who are submitting our work
to this you know web server and so you
know and then I'm making derived works
from them or so I need permission to do
that and so the server requires that
every all the sheep that are submitted
to it or posted into it the creative
commons attribution licensed and uh and
that means that that's part of what
makes this thing a sort of a
collaborative enterprises that anybody
can improve or learn from anybody else's
design or download it and sort of see
how it works so in the in the freckled
is about design community which is
really different from sort of most of
the practical design community where
people are normally really secretive
about their parameter sets and they're
sort of techniques and one kind of
interesting experiment I did last year
was to do a comparison of the this
genetic algorithm against the sort of
human design team you know because and
to see we know will we and you know
which is which is better than the robot
or the monkey and the answer was it was
almost a tie I compared the the peak
ratings of other some the sums of peak
ratings so I took the sort of the sum
total rating of all the sheep that had
been submitted by people and the sum
total you know rating of all the sheep
submitted created by the genetic
algorithm and they were I guess the if
the people submitted one then the
the ga submitted 1.1 and so you could I
think of it that I call that a creative
amplification because really if you look
at the stuff that the the genetic
algorithm had done it was sort of who
was less original than the things that
the people had done but there was sort
of more of it so if you think of
yourself as an artist it's kind of like
it's just you know or like as a musician
it's like you do for some particular
drawing or you have some idea and then
the the the software just sort of like
tinker's with it and creates more stuff
like that that's that's kind of
different and so it's kind of like
amplifying your work and so I think you
can part of my objective then as a when
i tinker with the with the algorithm is
to try to boost boost that number up and
if i can make the ga smarter then it
will increase the amplification factor
and ultimately i want to sort of like
have it diverged and go to infinity and
then at that point you can say that well
then then the the AI is sort of being is
being creative in its own right because
you don't have to put anything in or
even even if you put in one tiny drop of
creativity they will be able to amplify
it into it you know something worthwhile
or real so here's a screenshot of the
apophysis okay and so just moving on I
think in 2005 about this time last year
is when i began working on the high
fidelity thing and the screen saver is
runs at normal video resolution 640x480
and nine megabit and pet store does nine
megabit mpeg-2 and each sheep is 128
frames long which is about four or five
seconds but the thing that I showed at
the beginning of the talk is 1280 by 720
so it's three times as many pixels each
sheep is well it says 800 here but it's
actually 1600
and there are 15 megabit mpeg-2 mpeg-4
so it's a whole lot more data I think it
takes 20 times the computational energy
to render one of these sort of
high-definition sheep versus a one for
the screen saver and the whole thing
would have taken over a million hours to
render and there's 1,100 sheep on the
art disk and which would take it would
take nine hours for you to watch them
all if you played them end to end you
know but they're not play to end ended
their played with this sorta graph
following thing which means you'd have
to watch for a very very long time
before you saw the whole thing you can
imagine you know wandering through a
city at random how long before you saw
every house or something like that and
the dreams of high fidelity thing it
premiered in March of this year I
finally called it finished and I
immediately started working on the
successor which is now up to 80 gigs and
that's what I'm showing you now actually
it's not finished but uh it's good
enough for an informal thing and i'm
sure you guys want to see my latest
stuff right but and we'll i'll show you
some more of it at the end when we go
into the QA so some some interesting
things happened on the way to to making
this it wasn't just i will turn up the
resolution because it's those little
factors of 10 that cause you to like
rewrite some code in particular that one
of the interesting thing that i
encountered that maybe you guys might be
familiar with was bad frames you know i
was watching it and everyone every once
in a while the screen would like you
know flash white or black or more
mysteriously half white or half black or
other just weird sort of deformations
and I was pretty baffled of course I
thought it was just my mistake
but eventually I realized that it wasn't
it was you know like bad ram or cosmic
rays or you know other just kind of you
know you're dealing with people's home
machines out there on the internet and
yeah they're just they're they're
flaking in strange ways in particular
there was in this program there's this
sort of window of danger which is you
know between after the final image has
been encoded as a JPEG but before the
tcp/ip checksum has been computed if you
flip a bit in that data and then
decompress it you'll you'll get a bad
frame so if you if there's any kind of
damage after the TCP checksum has been
computed then you know it'll be detected
and you know the network code will will
fix it and if you flip a bit in the
frame buffer well these sort of the
while the image is being rendered you'll
end up with just you know one bad pixel
and one bad pixel for one frame in an
animation you're probably you know
you're not even going to see it but
anyway so I had this this really this
infrequent problem I want vandalism to
which you can't fix please so I decided
I had to just address it when you know
whether or not it's my bug it's just
this guy I have to protect myself from
this kind of random behavior and so I
sort of did the obvious thing which is
redundancy and so each frame gets sent
out to four different computers and the
results are averaged and then it checks
if the difference between the inputs and
the outputs is over some threshold and
if it's over the threshold it redoes all
four so it works great but it sounds
like a recipe for you know losing a
factor of four out of your out of
performance it turns out it actually
the redundancy is not wasted because the
rendering algorithm is stochastic so
there's naturally noise in the image and
in fact the the noise is inversely
proportional to how long you render it
so averaging the render the four images
in the red route and then averaging them
together actually gives you the exact
same result you would have gotten if you
would just run it for four times longer
so actually doing this sort of splitting
up and averaging thing doesn't actually
waste any time at all I mean there is
overhead per frame and in particular
there is the inbound bandwidth to the
server which is more expensive because
of this but the end result as far as
like the keeping the the high quality
you know the perfect quality of the
image up is successful so just of just a
few numbers to sort of characterize the
user base or the community of this thing
there's 30 about 35,000 users every day
and just keeps going up actually
yesterday was higher about about a
thousand people vote per day about it
renders about 35 sheep and about 105
edges between sheep those are standard
resolution not not high definition about
10 cheaper posted and maybe there's like
about the bot you know five posts on the
forum or in the email lists and stuff
like that so there's a certain amount of
kind of like talk and chatter people
sort of know each other and stuff like
that and there's various kinds of
personal drama mostly designers who feel
that their brilliance is not recognized
then of course you know people who vote
for their own work and I post from
multiple computers presenting to be
different people and all that kind of
stuff so it's the internet right and so
there's I've had to develop a lot of
kind of like you know defenses in the
system but anyway to the idea here is
I've got this you know high definition
thing but I can't um I can't distribute
it on the internet because it's way more
bandwidth than this low resolution stuff
which we're already doing and bandwidth
is is the bottleneck so I decided to
sell it and this would be great because
you know it's an open source it's been
an open source project for years and so
I need to find a way to you know a way
to make money so that I can keep the the
free network going once the idea was to
sort of the turn this bandwidth the
lemon of my lack of bandwidth into the
lemonade of a you know of an income so
so I'm so there's a one of these
self-contained computers right there and
it's an interesting question like you
know how legal is this for example if I
had used the creative commons
attribution share-alike Clause then I
probably couldn't do this because the
the resulting video would be required to
be share alike and so then I wouldn't be
able to sell to somebody and say you
can't give it to all your friends so it
was actually so I'm sort of in some
sense I've sort of switched from and
actually when I originally did it the
original electric sheep years ago it was
attribution-share alike I changed it so
I sort of went from the GPL to bsd
licensing for my video in order to in
order to make this work
yeah so the idea is that they're sort of
a would be a symbiotic relationship
between the the free version and the
high-definition version where the free
version provides like the design
laboratory and computational muscle and
then the the high-definition version
provides the provides the the business
side so partly this was like you know as
a I you know I think of this as
artificial life you know where I've got
these like you know virtual sheep that
like live and die stuff like that so
it's kind of like taking the idea of
artificial life to the extreme where you
sort of try to really make you know what
what is the most you know thing you know
life like thing that's not really alive
and the answer is you know like
corporations you know that's where you
the virtual virtual is really becoming
real so that's the direction of going
I'm just a little bit about bandwidth
here after Carnegie Mellon kicked me out
I got on to the coral content
distribution network which is a kind of
like Akamai and it's a and it's a NSF
funded research at NYU but they after
after I signed up they started they had
to institute bandwidth caps 250 good day
which is a far cry from the 20 terabytes
per day that would be required to
actually deliver all the Sheep to all
the users and so the problem right now
and the reason there's only 35 thousand
users is that now the each user is only
getting a tiny fraction of all the sheep
and so when somebody installs the
software on a fresh computer you know
they contact the server and maybe they
get nothing because the cap has been
exceeded so they get a black screen or
you only you only get a little bit per
day so kind of the thing has kind of
grown to the you know it's like the
Peter Principle whatever it's grown to
the point of its collapse and it needs
more bandwidth nor to to grow faster so
the obvious solution is bittorrent
which is what we're wrestling with
premiun right now and it's great because
the idea then is that you can just like
with Cydia at home the distributed
supercomputer shares computation across
the network with bittorrent we can sort
of share the bandwidth flowed across the
network and so the server has an RSS
feed of torrents and it's now delivering
between one and a half and two and a
half terabytes of video per day to the
audience and I was just informed us no
longer it's not 10,000 users it's 12,000
but only these juicy 1,600 by the way
dingo debt is uh one of the people whose
contributes to the project and he he
hosts runs the machine that hosts it and
is especially the last year or two has
done a lot of optimization of the server
so the reason some of these numbers are
as they are is mostly because of his
work and anyway so only about twenty
percent of the bittorrent users actually
have their firewall forwarding the ports
correctly so that they can actually
upload and it's not enough for the swarm
to support itself so we're you know we
got to like do the upnp thing and we
don't really know how we're going to fix
it we're working on so just a little
future history where I'd like this to go
is to sort of to make it a sort of
self-supporting creating system that's
you know fully decentralized and you
know using distributed hash table and I
want it to be like a computation that
you can tune into you know from anywhere
it doesn't have any physical location
but just exists you know strictly in
cyberspace and I would like to you know
I know you know keep extending the
genetic code you know
every year I add sort of more operators
to it more functions to it but i would
like to really turn it into a real
language effectively a turing-complete
programming language so that the network
can support really open-ended evolution
and then ultimately birth of a network
resident life-form so some kind of some
kind of AI thing so that's where I'm
going and I here's it's been a work of a
lot of people and I'm not just Dean in
me hear their names and especially also
the I want to mention the program for
his financial support and let's see and
that's pretty much it those are the
those are the URLs and we definitely
need more programmers especially for
like the clients like Windows and Mac
people who can do graphics and I'm
working so if anybody here can program
then give me a ring and I think we have
time for questions so how about me oh
and let's turn the video back on so
there it is and how much how do you
actually should be bad allocate right so
the question is how does the voting
actually affect what the genetic
algorithm does and the answer is every
time the system wants to create a sheep
it looks at the current flock and picks
the parents and basically ever ever used
I the original system was every vote
that you got was like a lottery ticket
for reproduction and so your chances of
reproducing was proportional to the
number of oats you got I found that
resulted in kind of a winner-take-all
system because the votes disturb the
distribution of votes also follows a
power law there's a few sheep that are
really popular and then there's a whole
lot which are not so popular and more or
less the guys who had hundreds of votes
were doing all the reproduction and so I
changed it to again be a logarithmic
system so it's kind of like I instituted
progressive taxation or something like
that and you know I don't want to play
say I'm like a benevolent or anything
like that I mean nobody nobody like
kills more sheep than I do but I've
found that it kind of had better results
and I think it kind of interesting to
think about like you know what you know
the using these kinds of systems as test
beds to find out like you know where we
can actually tinker with the system and
find out what works other questions
sincerely watching that video between
really between tuition right there
between two minutes half the time so
when does it
if you if you vote during the transition
it's ignored there's plenty of votes
that are right that are right on and I
could probably glean more information by
splitting it like you recommend but I
just never got around to it and it seems
okay you consider having with a sheep
three pieces it kind of goes out of the
gene pool
it's time I've never occurred to me I
noticed on the screen saver you sort of
have generations or you like wipe the
slate clean and start from a totally new
set of just whether you've been writing
for a while because that hasn't happened
in a while but yeah why do you do there
why do I do that well 11 well there's
two answers what one is the reason the
reason that it deletes stuff is because
well if i start a new generation it's
within compatibly with incompatible
parameters and so you know where you
couldn't do a transition and so for
example if i change the resolution i
wouldn't be able to context or just a
miserable but in fact sometimes you know
if they're just because of a server
crash or you know I screw up while I'm
programming the server it I have to
reset the database and then it can more
or less you can just be an accident or
it can be because I want to like make an
incompatible change but just a put so if
you want to not have all your sheep
deleted you can back them up yourself
just like any data file but then after
the generation change comes around you
can put them back into your cache folder
and they will play if unless they're
like apps you know unless they really
are incompatible in which case you're
out of luck
well as into video or as a JPG i use
quality 90 JPEGs so for and then this is
15 megabit mpeg-4 so I mean it
compresses into you know the video
compressor hits the target so I'm not
you know but as far as like the size of
the jpegs you know I don't know it's
like aa 200k I don't know you shouldn't
seem like it very much the content you
mean yeah yeah yeah
the fits the point yeah I don't know I
mean I I definitely have some issues
with the video compression I mean I
think it's really just because I use em
encoder and it freaks out sometimes
you'll see it if you watch everything
goes blocky or worse I but you know so
that's open its open to change but I
think jpg works pretty well in fact
correlation city on
increases tools
it turns my understandings of the last
night with other genetic algorithm
because it preserves votes minutes
so well I'm sure it does a lot better
than random I mean if you pick I I have
compared random genomes where I have a
you know the bay the basis of any
genetic algorithms you have to start out
with we have to start with something so
i do i can create our random stuff and
if you compare those to the things that
were produced by the ga the GI produces
stuff that's much better but it's
certainly true that if you give a sheep
of some rating of some some quality
level and give it to the ga and say you
know give make some children mixing
mutations almost all of the children
mutations will be of lower quality it's
just a fact of life you know most
mutations are bad and so in general if
you look at sort of successive
generations instead of seeing what you
would think of with evolution words you
know every generation is smarter and
better than the previous like us but you
could you know in fact there's actually
degeneracy every generation is ugly or a
stupider but I know you know that's the
way I'm trying to address that as more
or less by having more children and so
because it's yeah really it worked last
time right you know because it's so it's
a random process you know with the GAE
basically you got to get lucky and you
got to keep trying if you want to get
lucky and so and in particular what I'm
what i've done is i got the the Sheep
work being produced fast enough there's
you know 35 per day you know it's just
it's just not a large enough population
to really get some winners and so as of
a couple months ago instituted something
I call the brood which is every day the
server generates instead of rendering
some sheep it renders hundreds of
potential sheep so instead of an
animation it renders a sheep where every
single frame has a different genome
generated by the ga and this doesn't get
compressed with MPEG but it just gets it
pops up you know basically on my web
control panel
I pick the i-screen out the ones that I
like and send those sort of through and
so more or less what this does is it
makes the genetic algorithm search much
broader about a factor of five wider
search and the results are much better
so that's been running a whole lot
better lately and I'm looking for other
ways to sort of continue to improve it
like that just oh I want to say one more
thing about that which I didn't say in
the talk is a lot of effort that I've
put in lately is actually sort of
developing this kind of web control
panel for the flock and so when I
started doing the high definition stuff
like that's when I sort of the light
bulb went on in my head and I realized
oh like I have a sort of a supercomputer
at my disposal you know I can it turns
out it's like a it's as if I had
somewhere between five and ten thousand
node cluster dedicated you know I knew I
need an interface to control it right I
need an interface to sort of to design
sheep you know that that harness is this
super computer and so there's a lot of
stuff in the server now which you can't
see as users which are actually stuff
that i use for like finding edges and
sort of like searching through lots of
potential sheep or like and different
ways of connecting them together and
then picking out the good ones to
eventually appear in either high
definition or in that in the screensaver
so there's a lot of this funny design
stuff okay so where was the question
that was over here in the red shirt
all the question is on the server and is
there a reason for that oh well i mean
it's it's it's the easiest thing to do
and it's not a bad it's not a bottleneck
compression strength and eight thousand
seconds a day of deep dakota creampies
yes so more or less M encoder is really
fast and ultimately everything should be
distributed and then that will be really
cool but uh you know not yet oh wait
somebody new you collaborative filtering
or something to encourage
I think it's a great idea to sort of
combine you know in some sense evolution
is really stupid right but in
collaborative filtering is like way
smarter because you know with with you
get sort of what you want instead of you
know filtering everybody through the
pinch point and getting the lowest
common denominator so some kind of
hybrid between evolution and
collaborative filtering I think would be
great just haven't got there yet I think
it's it's actually pretty hard because
well to start combining it with
bittorrent because the with the torrents
the Sheep actually got package together
into like packs of like you know 20 or
more and so then you can't just download
the exact ones you want you have to get
them in groups you know but maybe
someday we'll figure it out yeah
the way it works is every time it
creates a sheep that creates one edge to
it and one had your way from it which is
essential otherwise you can't play it
then it also creates another random edge
between two up to other random sheep and
so what that happens there is that means
that you start out with you know one
input one output but then if as you if
you live a live for a while and you know
sheep that aren't so popular die pretty
quickly but the sheep that stick around
eventually get hit by that sort of
random edge and so the the ones that are
higher quality and longer lived
accumulate more edges and so there's
more ways of getting to them and so they
show up on your screen more often
although all the way in the back
I think the question was where do the
colors come from and do I ever recolor
them there right okay so the colors
originally came from this sort of
algorithm where I could I could give it
an image and I would derive a palette
but then eventually we opened it up to
sort of in that design program where
people could put in any pilot they
wanted so when people and that software
has that algorithm built into it so the
easiest way to get a palette is just
from a photograph whose colors that you
like but people also hands design their
own palettes but then once they're in
there then they start evolving and so
they're just part of the genome and each
of each of the transformations kind of
has like a color coordinate associated
with it that says we're in the palette
it converges on and so more or less
there's like the subset of the palette
that actually gets used and displayed
izzy is just evolved I never I almost
never correct or fix or change any
parameters or any you know colors or not
I pretty much leave the Sheep as you
know I just worked as an editor I there
like them or I don't like them I don't I
try not to try to tweak them not a
hundred percent but ninety-nine percent
you
oh um you could do that the
probabilities are we out of time okay
where the time but the actually the
probabilities are all the edge
probabilities are all even so they never
there never varied it just just played
it just picks randomly you I think the
and there those decisions are made
locally not according to like the server
so it would be hard to sort of transmit
that information but I think locally you
could especially based on an individual
users voting deter determine white cuts
played back on their machine more based
on their voting in addition to sort of
affecting the genetic algorithm you know
I think that's a good idea and we just
we haven't done it so let's see where's
where's my host there you are so if
we're at a time then we quit all right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>