<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Compiling and Optimizing Scripting Languages | Coder Coacher - Coaching Coders</title><meta content="Compiling and Optimizing Scripting Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Compiling and Optimizing Scripting Languages</b></h2><h5 class="post__date">2009-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kKySEUrP7LA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">he's the maintainer of the PHP compiler
and he's here to talk to us about
compiling and optimizing scripting
languages hi folks thanks very much for
coming along and thanks thanks again for
arranging all this so the the things
that I'm going to talk about today I'm
going to talk about compiling and
optimizing scripting languages
separately and so I'm just going to talk
a little bit about compiling then a
little bit about optimizing and and all
the work that I'm going to talk about is
it is done as part of my PhD under the
supervision of dr. David Greig at
Trinity College Dublin so to to give you
a quick motivation and I imagine that
you guys all know this a lot better than
I do and that a user needs to get their
webpage in in a pretty short amount of
time that there has to be a lot on it in
between so you need of some kind of
database access you need to execute your
scripting marriage and there's also
network latency and browser rendering
that sort of thing and so you you can't
do all that very much in your in your
web application and the idea of our
compiler is to increase what you can do
maybe you can do twice as much maybe you
can do ten times as much depending on
how fast we can get it so the talk is
going to be in in four parts and and for
short parts fortunately so the first
part is just going to be a quick
discussion of what phcs and and for if
anyone is interested in working on or
doing any kind of analysis or
refactoring resource to source tools on
PHP white phc is a good tool for that
and why we recommend that you use it the
second part is going to present a talk
that that I gave last week I bet the
about the code generation that that we
use in in PH scene and why why we made a
couple of decisions and why they're
important in general the the third part
is going to be optimization and that
that's the current focus of my PhD at
the moment and the last part is going to
be it's going to discuss the my
experiences of working with PHP with the
language with the implementation with
the community
and it's going to be a little bit
technical a little bit social and if you
like that that kind of interaction like
I do and then that bit will hopefully be
interesting so to start off phc is our
ahead of time compiler for PHP it's a
it's completely open source project
everything everything you can everything
can be downloaded from PHP compiler org
and it's written by by myself by Edgar
diverse and by John Gilbert it's a it's
released under the BSD license and I
make this point quite clearly because we
spent a lot of time trying to make it
nice for other people to use and try to
try to engineer the compiler pretty well
now it turns out that you don't actually
get a PhD for that so so I'm trying to
try to tell people as about this as much
as possible and so the latest release
compiles most PHP that isn't object
oriented and and what we have on trunk I
compiles most over as well so it's not
complete and cogeneration is incomplete
we don't support the full language just
yet but we support quite a lot of
important things that people need so the
the structure of PHP so it starts off as
a we take in the PHP a source code and
we pass it through a couple of
intermediate representation so it's a
standard compiler process where you
start with a high level intermediate
representation and you pass it through a
couple of stages before we generate C
code and that C code is then compiled
with with GCC and with some libraries to
generate an executable and the
executable can be used in a web context
or can be used in command line context
so start off with your with your PHP
program and we create an abstract syntax
tree so the abstract syntax tree is a is
an idealized beautiful form of the PHP
language getting rid of all the things
that you might see in a parse tree or
semicolons and braces and multiple forms
of the same thing and so we want once
you get to the AST you can on parse you
can unpack the source program in roughly
the same roughly the same form as was
parsed in so we keep comments and white
space too
some degree and you can also you can
also do a lot of transformations on PHP
and Weaver we have a very nice API that
allows you to that allows you to
manipulate this tree in in in in various
ways that we use throughout the compiler
so below the below the AST we have a
different intermediate representation
called the HR the high level
intermediate representation and this
this simplifies a lot of a lot of
constructs that you might see in the
source for example the we convert the
top program here into the bottom program
where we add temporary variables so and
this is called conversion to three dress
code and the hir is still technically
PHP so we can still in parse this it's
still completely valid PHP and so it's
the simplest form that we can transform
your program into while it's still valid
in the MIR the medium level intermediate
representation we add constructs which
aren't technically PHP but are very
useful for code generation and for
optimization principally we add gotas
and that that's the most important
example but there's plenty of features
like for each loops that we that we try
to get rid of and we try to to make them
a lot simpler so that we can generate
code on the MIR is not technically PHP
but for a free testing purposes we can
emulate so one of one of the things that
that was an early design decision in in
phc was to create plugins so you can add
a plug-in at any stage along the
compiler pipeline the even though I'm
highlighting three stages here in
reality each of these stages is a five
to ten passes and you can put your ear
plug in anywhere in the past and so you
can you can transform any of these and
the layer which allow the past continue
to the compiled code or to go back to go
back to a PHP source code and you can
use all the same constructs that we use
within the compiler all the all the nice
visitor patterns and that's the thing
that you can do on any of the ASDs and
the manual is a document that pretty
well it turns out that a lot of people
who use PHP don't know C++ so our
compiler is written in C++ and and
people who work on PHP for whatever
reason
don't know it and in particular don't
like it so so we offer the ability as
well to print it your PHP program to
some XML representation you parse it
into into program programming language
of your choosing probably PHP and print
back to xml and will parse it back in
and it's exactly like a plug-in you can
you can then unpause its pH P source
keep compiling or run other plugins that
sort of thing so that was a quick
introduction to phc and the idea I hope
is that is that people will will use phc
to do all of their PHP source code
transformation needs and refactorings
and that sort of thing and and so
everything you need is is to do that is
on the website so the second part of my
talk discusses the challenges to
compilation that you that we have when
we're compiling scripting languages an
awful lot of what I'm going to say is is
true for a scripting languages other
than PHP however I'll probably keep
saying PHP since i'm used to it at this
point so the this was a this was a
talker presented last week at the
symposium for applied computing and the
talk was called a practical solution for
scripting language compilers with with a
lot of emphasis on the word practical it
turns out that when you go to
programming language conferences people
have very very abstract things that
they're talking about morphisms and
Greek letters and so I was very glad
that we put the word practical and the
title so that people didn't didn't think
that I was trying to put myself on the
same pedestal as they wrong so the work
is done part of my PhD and and and
co-authored with her with etiquette of
recent david greig so to give you a
sneak peek of what of what this section
is about there are a lot of problems
with autonomous kryptonite in practice
and these these are not the same
problems that you get when you're when
you're compiling high school or when
you're compiling C++ they're not deep
theoretical problems they're simply very
practical problems and I'm going to
discuss head how to deal with those
practical problems and the solution is
to reuse as much of
reference implementation as possible so
every scripting language tends to have a
reference implementation and the we aim
to reuse them through the through a POS
that they provide across there's the
term canonical implementation because in
my paper I referred to this as a
canonical implementation until someone
rightfully pointed out after I'd
published and was unable to change it
that that this was rightfully called a
reference implementation of course it is
so these challenges to compilation the
first and possibly the most important
challenge to compiling scripting
languages is that they are undefined
there is generally no semantics provided
in any kind of formal way in any pros
there it is very very difficult to know
what exactly a PHP program is supposed
to do for any particular given source
and in this this is a paper on called
forms of language specification we
really discussed a number of programming
languages and how they how they were
specified and the the second sentence
there is the one I want to draw your
attention your attention to it says this
group specification is an implementation
and there is no pro specification or a
great validation sweet so so that he's
talking about PHP there and and that is
a one it's a real problem that we have
to deal with that it's very difficult to
tell what things are supposed to do and
especially when when they sometimes
change between versions of languages for
bug fixes or and just general lack of
design in scripting language says
there's this concept of batteries
included and it probably started with
Java where they where they submitted a
giant class libraries available for
people's users but scripting languages
tend to have really large standard
libraries and these standard libraries
unlike it in the Java case where they're
written in Java they tend to be written
in C so if the standard library was
written in PHP then your PHP compiler
would be able to reuse all the standard
libraries however they're written in C
and that makes it a little bit more
difficult on this on this slide it's a
it's a graphic taken from from
a blog by Jeff Atwood that the blog was
actually called or the title of that
particular post was called PHP sucks and
and these are all the functions in the
PHP standard library that begin with the
letter A I I canted the number of
functions in PHP 4870 and that doesn't
include 1000 class methods I said at the
conference last week there's a there's a
guy giving a talk on Ruby and he had
exactly the same problem he said there
were 1000 methods written written in C
and it really doesn't matter whether
it's a thousand or 5000 it's completely
impractical if you had if you had a
thousand monkeys and whatever time and
you could probably do it but I'm only
one monkey and I'm trying to get my PhD
finished in in this lifetime at least
and the third and most irritating
problem and I I raised this because this
was the first point that we realized
that we're going to have to do something
special so the language changes between
releases and this this is one of quite a
number of cases where the PHP
programming language has changed
semantics in in releases and I I
highlight this one because the value of
literals should never change in your
programming language it seems
programming languages 1010 what one
would think so so this prints out the
the type and the value of the of the
variable there Rosario of d of the
literal specified in hexadecimal form
and in old versions this used to
truncate to an integer with the value of
long Max in newer versions it overflows
properly that is in the same way that
that normal integer is not specified in
hexadecimal form do and and this is a
little bit tricky to deal with it's a
you it's it's one of many problems like
this with which change where the
semantics change in between various
releases and and I highlight this one
because it's a ridiculous problem that
should never have happened and also
because it changed in a minor release so
changed between PHP 5.2 point 2 and five
point two point three
and the final problem that we have to
deal with with scripting languages or
the unique problem that makes it rather
difficult is is the presence of runtime
code generation so scripting languages
tend to have features that are designed
for interpreters they really they tend
to be open source projects and it'll
take whatever features are given to them
by their contributors and that tends to
be things that are easy to do with an
interpreter so the eval statement is a
is an example of that and but real
programs don't really use eval
statements and perhaps they do in Ruby
but in PHP there's a there's a kind of a
best practices says you shouldn't have
an eval statement in your web
application because that'sthat's a
security flaw however in the in the
second example here there are there are
two forms of source inclusion that the
two forms look exactly the same and and
in fact technically they are exactly the
same the first is a source inclusion so
it's like a hash include or a.m. or an
import statement in Java where you're
simply doing as some kind of separate
you're writing your code in separate
files and you're importing them the
second one and and it looks exactly the
same as the first 49.8 is a runtime
source code inclusion so something where
you're intentionally importing something
at runtime perhaps it's a plug-in
perhaps it's it's generated by a cron
job in the background and the difference
between the two is is not so much that
you can tell a compile-time which which
of these two forms you want you want to
do so obviously we we provide a flag the
dash dash include flag people who want
to include us but there will there will
be very often cases where we will need
to do some kind of run time code
generation and this is a little bit
tricky to handle in a compiler do you do
you make your compiler work as an
interpreter as well I do you do make a
compiler at runtime and then have some
some form of of dynamic loading and it's
it's not the world's most complicated
technical problem but it's terribly
irritating to try and handle so our
solution is to reuse the capi of the
reference
implementation so every scripting
language and and certainly in the case
of PHP is an API called the zend API
which Prue which allows you to sit by
design it's intended to allow you extend
C and C++ applications so so GIMP might
have my lair you write Python scripts to
modify it or very often in the games
industry lure is used for people to
write a lot of their game logic and and
it's linked into graphic sentence and
network engines that are all written in
C and C++ so so this is the API that we
reuse and it's on the left here you see
a compile-time view of what we do so our
PHP sources is brought into a is parsed
by by PhD and transformed and compiled
down to C code the C code uses the capi
so it when we compile it they're all
they are they're all the standard
headers from this says little PHP mm so
you can't see that and and it links to
the two PHP's runtime library so that is
the standard library or the runtime
library expose of the PHP reference
implementation the one that you download
from php.net and is on is on three
million three million web servers around
the world so GCC compiles them together
or compiler review choice to join
executable or that there there is a
similar path for for web applications at
runtime the compiled code interfaces
with the capi and the C API gives you
access to all the functions and classes
and gives you access to to the
interpreter so that we don't so that for
runtime code generation we have we let
PHP's interpreter handle it and we don't
need to write interpret ourselves this
also means that we're functions and
classes change between various releases
we don't need to change anything in our
implementation we are essentially bug
for bug compatible this in standard
library sense of every for every release
and in future releases
well so this allows us to handle
seamlessly changes that have not yet
been made which is a which is kind of
cool so to give you a little bit more
detail there are there are language
primitives in PHP it's called the Z
value or the Z value here in America the
devil is simply a simply a see struct
that is used to represent every possible
value inn in PHP there there are
analogous things in in other scripting
languages in every other scripting now
so so python has a pie object ruby has a
value and lower has a t-value and
there's a there's a an interesting
discussion on the various merits of
these in that paper that i thought i'm
listening to their um so the capi is is
the Z Val plus some macros and some
functions so when you want to call a
user speakers you want to call a
function from the standard library you
pass its parameters as dead value get
its return value as a dead Val the the
interpreter axons evals everything uses
a Zed vallis its primitive and so that's
what we use and so what does this look
like a compile-time well this is this is
the source that we generate or a very
simplified version of the source for
that for the statement is assigned 0 so
on the on the second line here it says
PHP hash find so that is we look up the
local symbol table for the farthest ring
I and we put that into PI and pi is a
pointer to a zebra I so we destroy the
value that's already there and we can't
reuse it for various reasons and then we
reallocated and then we store the value
of 0 into into the Zed valve which is in
that in the in the symbol table so if
there is an eval that ran after this and
wanted to use the value of I it would
also look it up in the local symbol
table and it would be there waiting for
it now things aren't quite as simple as
I've made them at unfortunately this is
the actual code that we generate for for
the last statement and you're not meant
to understand it to be able to read it
it's just much
it's longer than it was in the last
statement around the last and last slide
even worse for the for the statement is
assigned J it gets a little bit longer
and when you want to call it a user
function it gets an awful lot longer
still and it this is this is a little
bit tricky you might be able to see the
the large portions of blue where we had
to put comments so that we could
actually understand what what we were
doing now while this is a little bit
tricky it is infinitely less tricky than
writing 6,000 or 5,000 functions and
1,000 class methods so you only need to
get this right once fortunately so
there's a question of where is
selectable well every scripting language
that has the same problems that we have
and that have that have a reference
implementation with the capi is is
somewhere that you can use this
somewhere where you where you have this
problem and where you can use this
solution in particular this this applies
to perl PHP and Ruby and I'm not
terribly familiar with tickle but I'm
told that it applies to tickle it
applies somewhat to lure and Python low
and Python these days are well specified
so everything is true everything else is
true except for the fact that these have
language specifications now and that
wasn't always the case though there was
a there's a paper about a bed of
implementation of Python from 10 or 12
years go by a guy called John a and
here the section heading titled the
reference manual says what and it turns
out that the that the implementers of
certain portions of the reference manual
didn't know what the reference manual
said and it certainly didn't say the
same as the language actually did in
certain cases but I gather this has
gotten a lot better in recent times for
for Lou and provide them it doesn't
apply it all to JavaScript it doesn't
have any of the problems it doesn't it
doesn't have a reference implementation
so you can't use the solution so
javascript is a different beast but
fortunately it's a much easier beast to
work with as or to reimplement I could
imagine because it is standardized if
life would be a lot easier if all these
languages were standardized like
JavaScript so obviously you're making a
compiler you
compiler is to make things faster
because otherwise you would just use an
interpreter a lot life would be simpler
and so we were delighted when we found
that our speed up was 0.1 times that
that is our compiled code was 10 times
slower than PHP interpreter code and if
you're if you're kind of research
oriented then like myself then you might
think that's an interesting result a
compiler should always be faster than
than interpreters that that's the rule
and and the fact that they aren't is is
somewhat interesting and I'm going to
dedicate some space in my PhD to this
simply because I discovered it and so
uninteresting one interesting point of
this is that PHP is not slowed down by
its interpreter loop typically
interpreters are slower because they
have to have it and interpreter loop
that dispatches and that takes a
considerable amount of time recently
Python changed how they do their
dispatch and there was a result of some
kind of fifteen percent speed up that's
not really the case in PHP and when I
profile PHP I I didn't see any time at
all spent in the interpretive and the
the reason for that is that PHP is such
a dynamic language and it's it's it's
much more dynamic than than a number of
other scripting languages and it doesn
awful lot more it has to do an awful lot
more checks at runtime and so it spends
its time during those checks instead of
instead of an interpreter dispatch so
one of the reasons that we were very
very much slower than PHP was because of
a simple change in our in our three
dress code so three a dress code was
where we added temporaries in the
conversion from the AST to the HR we
accidentally added a touch of an
attorney and and those extra tempers
have a very very pessimistic result in
scripting languages and in particular
languages just so scripting languages
and PHP in particular I have
optimizations to make copies cheap
technically copies tend to be deep
copies and that's that's the case in PHP
arrays and strings are copied by deep
copy however you don't want to really
pin lies p
but for for just copying values and you
certainly don't want to your 10 meg
string to be replicated everywhere you
copy it so there's an optimization
called called copy-on-write however that
doesn't apply when when you're doing any
kind of in place modification like you
are in the first example so so stir is
modified in place in the first example
and that means that it has an order n
roughly in order n algorithm week with
some kind of some kind of complexity
thrown in for the memory reallocation so
let's say it's order n log n the second
one you cannot use copy-on-write because
there are two strings t there are two
variables T and stare appointing to the
same value and this means that you
actually have to do a deep copy and
you're no longer allowed you're no
longer they'll get away with
copy-on-write optimization that means
that the second the second piece of code
here is order N squared and when your
compiler converts things from order n
log in to order N squared seamlessly
without anyone noticing people are not
going to be terribly happy to use it and
this was most of the ten times slow down
that that we saw so we also applied a
couple of optimizations I'm going to I'm
going to fly through these and the first
is constant folding constant folding is
is obvious and it's obvious how to
handle it if if you know the semantics
of your language however PHP has has
many many edge cases and were there
trolling through the source code it's
very difficult to know what they are so
because we use the the PHP capi we have
it available in our compiler at compile
time so instead of trying to figure out
the sum of the string 5 and the values
and the boolean value true we simply
pass that off to the PHP interpreter and
it gives us back the result of an eval
and it turns out and I guess quite
likely if you think about it that the
value is 6 PHP spends an awful lot of
time in memory allocation memory
allocation is probably the largest thing
I noticed in the profile as maybe thirty
percent of PHP programs are spent in
memory allocation and by by pooling
Constance we were able to avoid that
memory allocation so in this example
hello would be allocated for every loop
iteration and after who allocated used
cleaned up in every loop iteration
instead we allocate it once at the start
of the program for every literal in the
program and we clean that up at the very
end and that saves quite a quite a bit
of time PHP has a has quite useful
semantics in that you're not allowed
change change a function after it is
called so you may not know at compile
time the exact function which is called
F and they might be defined in two
branches of an if statement but once
wants its defined it's not allowed be
changed unlike in Python a ruby so we
were able to typically you have to look
these functions up in a symbol table
this this involves hashing and all that
sort of thing and it takes a little bit
of time so we basically cash the result
when we when we've looked something up
and that saves maybe fifteen percent of
runtime this is the example from earlier
and we're where we were looking up the
value a life from the local symbol table
the third parameter is a is an integer
that that's the hash value of I so
typically we would need to look that up
at runtime but there's a the PHP capi
has various has two forms of every hash
table lookup and one of them takes the
takes the hash value which we were able
to to create a compile time because we
have the the PHP interpreter linkedin
and that saves another ten percenter all
these optimizations are really kind of
ten percent optimizations except this
one which is which is probably close to
twenty or twenty-five percent we're so
in the example I gave earlier you have a
symbol table and you don't necessarily
need a symbol table unless you're doing
the really weird dynamic thing so unless
you're doing into vowel unless you're
doing and include or a PHP as a future
called variable variables which also
need a symbol table if you don't have
any of those features and it's very easy
to tell syntactically whether they're
whether or not there's an avowal and
include or a variable variable then you
don't need the symbol table and instead
we store all of the zebra
all the pointers to dead valves in in c
function are in c local variables and
this this doesn't get rid of the
overhead of having a zed val orbit
allocation or deallocation but it does
get rid of that of the hash table lookup
so with all these optimizations in place
we get a much much better result in that
we're actually faster that's a it was
quite a relief when we got there and we
weren't so we weren't ten times there
anymore so this graph shows the speed up
over over some set of benchmarks and and
to higher numbers are better and a value
of one which is here says that we're the
same speed as the PHP interpreter so in
general we're faster up to two and a
half times faster for some programs and
the mean is the rightmost column and
that says that we have a speed-up of 1.5
on average there are a couple of
slowdowns and they were they were
princely because we generated bad code
and and those are fixable but it's not
an interesting research topic of how to
fix them now while this is much better
than ten times slower it's a it's not
quite as good as you might expect a good
C compiler would would be maybe five
times faster ash optimization level two
or three then it would be at
optimization level zero and PHP like
many scripting languages is known to be
maybe 40 to 70 times slower than see
depending on who you ask and hot exact
variables you session that debian
language shooter and so we would really
like to be able to get a better speed up
than 1.5 and so it became pretty clear
that the way we were going to have to do
that was was optimization so this what
i'm going to talk about here is the
current topic of my PhD research and and
it's not finished and so I won't have
performance results to give you but it's
it's designed and half implemented and
and when I'm finished I will I will
write it up and submit and hopefully
that'll be this year
so this somewhat confusing graphic is
something I did on the plane on the way
over which explains why it white white
so confusing so I'll spend a little time
explaining what this means so from our
firm our mir this is the the
intermediate representation that has
gotas we create SSA form an SS a forum
is that is the Big Daddy compiler
representation r it allows you do all
sorts of cool things in a really cool
way and so we convert our program into
SSA form and then we perform constant
propagation if any of you are compiler
buffs then the exact form of constant
propagation is the sparks conditional
constant propagation which is a really
cool one after constant propagation we
do dead code elimination so these are
these are just two very simple intra
procedural optimizations that means
function local optimizations so we don't
take account of colors or Coley's in
these optimizations we merely look at
each function separately after dead code
elimination we get rid of Estes a form
and spit it back out into Mir and we can
iterate over this if it needs be with
our results with then generate see with
this we gotta speed up of a bit too and
I don't have a graphic unfortunately to
show that and but so you'll just have to
take my word for and a to speed up is is
better and this is kind of kind of what
we should be looking for however it's
still not not anything close to either
the 40 times slow down that you get from
riding in PHP in the first place nor is
it anything close to the speed up that
you get from a C or C++ compiler of five
times so it seemed obvious to us that
type inference was the next important
step in particular we wanted to be able
to take Z valves and replace them with
with C integers or C doubles and in
particular where you have some kind of
loop variables this would be a very nice
speed up we hoped however it turns out
that type inference is an awful lot more
tricky in a dynamic language you first
arsch you can't do type inference on the
local level because it
in this example you don't know any of
the possible types of x and y now that
in itself doesn't seem too bad you might
you might be familiar with her with the
type inference algorithm from ml the
Hindley Milner type system where you
would say that that the dot ever between
x and y there is a concatenation and a
concatenation take strings and it
returns a string so therefore x and y
must be strings however life is not so
simple in scripting languages in
particular there are user space handlers
so that is because you don't know the
the type of X X might actually be an
object and an object which has a
two-string handler defined and so the
two string handler would be called by
the concatenation with Y as its
parameter there are similar things in
Python for for operator overloading and
they existed in various scripting
languages so this is a this is a list of
user space handlers and and the one from
the from the previous example it is to
string and to string means that you
don't necessarily have to just return a
string you might affect the global
symbol table you might touch the
parameters you might change the value of
the object which it is a dispatch done
and so you can no longer say as many
things that you'd like to be able to say
you can still optimize with this and
it's you just can't say anything about
global variables anymore or or the
parameters to this function and so it's
it's not great but it's still possible
however you really get screwed by the
presence of the capi handlers so these
are handlers within the C API which can
access anywhere and when I say can
access anywhere I have observed source
code in the PHP interpreter or in the
PHP standard libraries which does access
anywhere and the the second example
there read dimension if you have an
object which has a read dimension
handler set and it is accessed as if it
was an array then this handler is called
that in itself doesn't seem too bad
however the get and the set handlers are
the ones that really screws because get
is called every time that there
is red right over every time that value
is red set is called every time that
value is set or it is written to and
that means that you no longer know
anything about your program if you have
a single unknown type and that's I'd
like to say that's an interesting
results but I can't unfortunately just
pass it off as an interesting results I
you actually have to do something about
this because you can't optimize around
it you could pretend it doesn't exist
but you don't get a PhD for that so the
get variable I so the get handler can
change every variable in your local
symbol table and since it can change
every variable in your local symbol
table you no longer know the types of
any variables in your symbol table and
that means that types propagate they
propagate throughout the local symbol
table and they propagate throughout the
global symbol table into return values
into reference parameters and into
parameters of functions that are called
and that means that once you have a
single unknown type you can no longer
say anything about your program from
that point you may as well turn off the
optimizer it's useless from then on so
we we kind of have to handle that and
and it's it's an interesting point that
you can no longer do the optimizations
that I talked about earlier the the
constant propagation and the SS a format
the dead code elimination earlier made a
lot of made a lot of assumptions and the
principal assumption and you'll notice
it if you work on compilers at all is
that you know where every variable is
used and where every variable is defined
in fact the SS a form is just a
specialized way of thinking about users
and definitions but if you don't know
where things are defined you don't know
where they're used then you're going to
get the wrong results and it's no longer
safe to do any compiler optimization
anything you find in the literature or
anything that that's at least is
performed at the function local level is
worthless so you're going to need
advanced optimizations and in particular
you need to model types precisely
anytime that you have a field you must
know the types in that field and so you
can't just take a simp
fine with us you the same is true with
arrays and the same as i mentioned
variables there but PHP has variable
variables and which which may not be you
may not know exactly which variable is
defined but we need to know some set of
types it doesn't matter if if there's
500 types that we know it is as long as
we don't know that it's unknown and of
course that one of those types doesn't
have some kind of unknown handler or
something like that so another important
point I mentioned this minute ago is
that you can't use the the def use
chains the def use chains are the the
technical compiler name for the deaths
and those uses that I was talking about
earlier and the course that you can't
use s sa because your information is
incomplete when you're creating the
program or when you're when you're
creating your your compiler optimization
form you also have an improvised call
graph this should be a should be rather
clear from the fact that you don't know
any types that whenever something is
dispatched donnish you don't know where
it's going to go exactly you might have
a choice of a couple of points or a
couple of functions or methods but you
don't know exactly which one is going to
be and you can't just rely on it on its
name because there might be multiple
ones including ones for giant yet
defined so the algorithm that we do is
is an abstract execution and what what
that means is that we we start at the
first statement in Maine or the first
global statement in the program and we
we essentially do a trace at compile
time of the entire program so that means
that we we follow loops around we we go
into functions or we go into methods
that are called and we follow the types
everywhere and that that's pretty
important that we're able to tell at
every single point where it isn't the
only real way to do that is to do an
abstract execution or an abstract
interpretation over the program we do
points to analysis that this slide is is
the slide for for the compiler folk
unfortunate but for those of you who
don't know how points to analysis is it
basically allows you model various
properties of objects and the fields and
in C of strokes and arrays and that sort
of thing as well and I
it's star sensitive very sensitive so it
we make it as sensitive as possible to
increase that precision in particular
its flow sensitive field sensitive
context-sensitive an object sensitive if
you know what that means now we do
constant propagation at the same time so
it's very important that while we do the
abstract execution we are modeling
points to information and remodeling
constant information as well as the type
information we modeled them all at the
same time and the reason that we do
constant propagation at the same time is
that helps us get precision so for
example if you have a if you have
something like if debug and debug is set
in the first statement of your program
we don't need to go in both directions
on the branches we only need to go in
the direction that we know it's also
possible that that field names and
variable variables and array indices are
known at at compile time so we know
which which array index or richfield
name you're trying to access and it's
it's not necessarily the case and in
particular during our conversion to
through a dress code we we make this
worse and so we have constant
propagation running at the same time I
mentioned implicit conversions because
PHP is a is a weakly typed language
which allows weird implicit inversions
between different types depending on
Heather access and constant propagation
helps us a little bit there if anyone is
a is interested in a little more of how
these two interact and how they work
together and they're described in this
paper by Anthony Pioli it's a it's
called conditional point2 aliasing and
constant propagation and I mentioned it
in particular because it's very readable
even to the non-specialist so if anyone
is interested this is a really good
place to start to understand how this
kind of thing works finally we do we do
type inference obviously at the same
time this helps us to resolve virtual
calls and maybe turn polymorphic calls
into into monomorphic calls but
obviously this is the important thing
that we're doing in the first half of
the talk i talked about how have
functions yeah we don't need to model
them we don't need to re-implement them
we don't need to say anything about them
because we can just reuse the ones that
already create
however this obviously isn't the case in
India analysis because we want to know
what types are returned and created that
sorting and we don't necessarily know
that from from our earth capi we know
some information but but not enough
unfortunately so it turns out that we
are actually going to have to start
annotating functions it will work if
functions aren't aren't annotated we'll
just have to turn off the optimizer at
that point and and that's not great but
but it does work um and while this isn't
going to be as difficult this is going
to be a little bit tricky and it's going
to take a little bit of effort but
generally you can brought you can paint
broad strokes across things so so you
can say that everything in the read
library returns a string or a brilliant
or null and they and they don't affect
their parameters so it's in quite a lot
of cases you're able to to do this very
simply and where where you don't get ran
into it it will still work we'll just
have to turn off the optimizer and the
compilation will can still go ahead as
normal so there's a lot of complex cases
some of them are our PHP specific some
of them are general to scripting
languages and when I when I gave this
practice talk people started yawning at
about the third one and we're fully
asleep I bet the fifth one so I'm not
going to mention these at all except to
say that they're there and an inquest in
time I can put this slide back up if
people are particularly interested in
any of the in any of the weird
optimization cases of PHP so there's a
couple of interesting thoughts about the
about this optimization that I've had
and the first is that I've noticed that
you get much better results if you strip
off the first loop iteration typically
PHP programs use implicit conversions so
you might not define your variable X to
be an array you might just access it as
if it was an array later so we know that
the type before that is going to be a
null and the type after is an array but
if it this is in the loop then we can't
say that it's one or the other we can
only say that it's we can only say that
it's either however if you strip off the
the first loop iteration typically its
null only in the first loop or in the
first iteration and then in later
iterations that is the entire loop
you you know the type more precisely a
hotspot is a java just-in-time compiler
does does an optimization like this and
sorry does exactly the same optimization
in order to to get better run time
constants and I think that will get a
little bit better results out of this
than they do because they don't need to
know the types or well they already know
the types and that's something that we
need to know it also seems interesting
to me that this might be able to run
since we do since we must do an abstract
interpretation it might actually be
doable at the same time as a as
execution is actually going so it might
work well in a just-in-time compiler or
there's a tracing compilers or tracing
Jets are becoming very popular these
days because of a trace monkey and that
sort of thing and there's a technique
called gal France tracing which is which
is hugely popular these days and
everyone is talking about it so it does
occurred to me that that these aren't
necessarily mutually the you might be
able to do both at the same time one
hopes and the final the final
interesting thought I have is that you
can use string transducer analysis and
this is a this is an interesting
technique that was a that was presented
in these two papers neither of which is
readable even to the specialist so I
wouldn't I wouldn't recommend that you
go there so i'll give it I'll give a
quick explanation basically a string
transducer or as it's more properly
known a finite-state transducer is a way
of modeling finite state automata so you
can model regular expressions with it
and regular expressions of course are
very very important in scripting
languages and it not only does it allow
you model them but it also allows you to
to combine them or merge them or
intersect them which obviously is very
important when you're when you're doing
a flow sensitive analysis and and I
think that well the the Gary Wasserman
in his paper has reported that he gets
great results for security analysis I
think it would get great results for
optimization as well um I don't have
time to do this unfortunately but but if
I keep working on PhD after my PhD then
this would be the first thing that I
would do and I think
it's an interesting idea for other
scripting languages and further ahead of
time optimizations so that basically is
the is my PhD you now know as much about
it as my supervisor doesn't know I hope
that you liked it as much as I hope that
my external examiner will at some point
later this year so the final thing that
I'm going to talk about this is this is
only going to take a few minutes is my
experiences of working with with PhD and
this is more of a it's it's a little bit
technical and a little bit political as
well and people who are who are
interested in working or are interested
in social interactions within open
source projects like I am might find
this a little bit interesting so I
should say yeah that was in the previous
part of the talk I had facts and figures
and here I just have my own experience
my own opinions and conjecture while
I've spent an awful lot of time in the
PHP community and delving through the
PHP internals and trying to understand
the semantics of the language and there
may be people who take some kind of
insult in what I'm going to say and that
is not at all the intention so PHP has a
number of problems and I'm trying to
suggest ways that they might need to be
fixed the first is a language problem pH
or people are well aware both within and
outside the community that PHP is not a
it's not a pretty language it's not a
beautiful language than the way the
Python or that Ruby is or even that
javascript is if that's what you like
and there's there's an awful lot of edge
cases it takes a very long time to get a
mental model of header of head language
works and and this is this is admitted
both within the community and with it
and I mentioned this without going into
it because because it's documented all
over the internet but I'm going to bring
this up again in the second so I just
wanted to highlight that first the the
second thing is a PHP has implementation
problems there are the implementation of
the PHP interpreter is really quite poor
that does the snow
commenting this code that's been there
for for a decade that people don't
understand what it does and a lot of
people who wrote the code initially have
moved on to a to greener pastures in
particular the C API which which I I
talked so fondly of in the first half of
this talk is is really a problem here
because there's a really tight coupling
between the the interpreter and between
the standard libraries and if you want
to change the interpreter in particular
to be faster and then you face real
problems with this and PHP is probably
three to four times slower than the
lower than Python which arbiter which
have fast and good implementations and
not only does it does it detract from
people wanting to work on it but it also
detracts from from fixing from fixing
problems within the language and and
this tight coupling is something that no
one really wants another advantage of or
sorry another disadvantage of this type
coupling is that it's very difficult for
reimplement ations to to reuse PHP's
library so I described one technique but
that technique isn't something that gets
you a great deal of speed and and IBM
and another number of other places are
trying to do reimplement ations of PHP
and they're facing a real problem that
there are that there is this this tight
coupling and and it would be good not
only for the other implementations but
for PHP is implementation itself if
these could be separated and finally
there there are community problems PHP
is a community that likes to bike shed
and I spent a lot of time in in the in
the GCC world before I worked on PHP and
and that that's almost the best you
could hope for in an online community
it's it's incredibly professional and
and and everyone interacts very well and
very politely and very professionally in
in the PHP community there's an awful
lot of people who like to comment on
things who aren't you who don't work on
PHP they that they have opinions on
language features and anyone can have an
opinion on a language feature without
necessarily being an expert in it but it
means that there's an awful lot of bike
sharing and discussing things to death
and that means that real contributors
people who bring patches very often get
discouraged and very often patches are
given without without necessarily
anything happening as a result of them
there's also a need for there's a lot of
interactions between these so the
community problems relate a little bit
to the to the implementation problems so
that there's very little very little
review of code that goes in and when
there is review it's very often the
manifestation of interpersonal
relationships and people say things on
the mailing list that I would never put
my name to on the Internet where people
can read it and unfortunately it doesn't
make for a ver for a good community the
I mentioned the language problems
earlier because PHP is not is not a
beautiful language and geeks like
elegant geeks like like beauty and they
like scheme and they like Ruby and then
they like Python and they don't like PHP
and while it's very obvious that that it
is possible to get great things done
with PHP and people have built you know
Facebook and and and Wikipedia and Yahoo
on the back of PHP and there is a much
smaller pool of talent because geeks
don't want to work in things in
languages that aren't elegant and this
means that there's also a much smaller
pool of talent who want to work on the
implementation there are definitely
talented people there and but I think
it's interesting that in other
communities the the tools andrea
implementations come from within the
community so in the Ruby community
yerevan Rubinius have come from within
Ruby and and and in the Python community
this Jason and there's the syrax and
there's Pyrex and cyclin and Pyrex and
three or four other implementation and
cool tools pi PI for example that have
been built within the community whereas
in PHP everything has come from from
industry typically IBM or they've come
from universities and I don't know if
people have spent much time in academia
but there isn't a great
it for production level implementations
in our production level tools instead
you hack something together you write a
paper and and you might you might if you
get a chance do something better with it
and make it more useful to people but
having the only people who are creating
your tools come from academia is not
terribly useful so there are a couple of
fixes to this and there needs to be a
less of a coupling between the libraries
and the interpreter and the libraries
are typically see libraries that that
are linked with the capi to the PHP
interpreter and I think that that
instead of having people write that C
API code that would be better served by
by doing some kind of domain-specific
language like like Pyrex for example or
some kind of annotations on the
functions where they're automatically
imported and where the where the actual
interfaces in PHP code and in on the
user side so the the interest isn't the
api's of those libraries are written in
user code calling it perhaps to a via
some kinda main specific language to
internals functions and I think that
that by removing the tight coupling
people would be more willing and
unhappier to work on the implementation
and to be able to fix the problems that
are within the implementation that and
that people acknowledge are there and
obviously that relates as well to to the
to the language I think that PHP needs a
pi3k kind of moment soso pi3k was was
where guido van rossum said these things
have been bugging me for 15 years I'm
they're fixing them in a new backwards
incompatible version of Python and I
think that PHP needs needs some kind of
thing like this in order that the people
who work on it actually love the
language and it probably wouldn't take
all that many changes to make to get rid
of the inconsistencies in PHP and to
make it easier to get a mental model and
to like the language a lot more and I
think that that's imposs
for the future PHP that the people who
work on it actually like the language
and like the implementation and finally
that they need to be better community
interactions and I think that that a lot
of what I've seen in the GCC community
could very easily be be ported over to
the to the to the PHP community things
like like reviews before committing
instead of after drinking and may I say
mailing this moderation obviously
obviously GCC doesn't have that and but
it has a very very strict idea of what
you can and can't say even though its
unwritten and I think that that the PHP
the mailing lists need this kind of
professionalism and dedication so that
people can can work on the
implementation can fix the problems
without without the the kind of things
that go on now I think that the per area
maintainer is might be useful as well
but I'm really gone into that so I'll
just I'll just skip it so to summarize
we're at the end and I talked in the
first half about how Harry will you
excuse me reusing the existing runtime
for for libraries is is a good idea for
for implementing and for doing
reimplement ations but a better idea yet
would be what I talked about just now
standardized libraries make the foreign
function interface something that can be
reused by various reimplement ations and
that would lay the the implementation to
get improved as well when you're
analyzing a PHP program it needs to be
very very precise and need to be whole
program because a single pessimistic
optimized assumption I will spread
throughout the entire program and all of
the language implementation and
community needs some level of fixing and
it's very possible that all those are
related so finally phc needs
contributors it's it's an open source
project but doesn't have too many people
working on at the moment and so if
people have have the inclination and
I've liked what they've seen today and
that this details here on how to get
involved and basically you go to PHP
compiled org join the mailing list and
say hello and but i want to thank people
for for coming and thank you for
listening to what i have to say
yes so given the problems that you
presented why did you personally decide
to invest your time in PHP so the
question is if if i came across all
these problems why did I work why am i
working on PHP and well-liked like PHP's
problems come from legacy that this
comes from legacy as well when I started
my PhD the the other guys i mentioned
had had been riding phc already and i
said my supervisor said to me you need a
side project in case your main research
goes and it doesn't work out too well
and so I said right I'm going to write a
Python compiler and and when I went back
to the lab the lad said no no you should
you should join our PHP compiler it's a
half it is written already you should
definitely join that and that's that
sole reason and I I regret not joining
the product I don't regret joining the
project I it's been great working with
these guys now it's a it's a nice
compiler to work on but I do regret that
they made the decision before I got
there the to work on PHP and I wish that
they had chosen the language which was
at least in some way standardized yes um
so the question is just in time
compilers are better right that's
roughly there is a line of thought that
says that just-in-time compilers are
better um I I think that is the case in
an awful lot of things and it's
certainly the case in north lot of
scripting languages in in Ruby people
use evolves an awful lot and they they
change the structure their programs with
thing called monkey patching or ninja
patching or whatever they call them um
and and I think that that that is
certainly a model that will only benefit
from just-in-time compilation there was
a um in in the case of JavaScript you
know that Ajax requires that a vowels
are used in awful lot
so I think that we're only seeing or
that we're going to see that in
JavaScript and in the Ruby space and I
think in the Python space as well that
only just-in-time compilers are going to
be useful however there is a very
special use case in in in PHP which is
that people very very rarely use dynamic
features in particular people don't want
their Jets running at the same time as
their as their as their programs because
they're only tends to be half a second
that that your program runs for and if
your program isn't running for that long
they're not going to get the advantage
that other programs are that longer
running programs see from jets and i
think that PHP in your web application
is one place which will always benefit
from a head design compilation and so
i'm very fortunate that that happens to
be the place that that I'm working on
but I think that shits are certainly the
way in other ways okay um okay so it
looks like we're gonna have to call it a
day there and please come up to me and
ask questions if you're if you're any
more interest thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>