<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Objects As Software | Coder Coacher - Coaching Coders</title><meta content="Objects As Software - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Objects As Software</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_cBGtvjaLM0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello thanks for coming I have the
pleasure in oops apparently not yet
hi thanks for coming i have the pleasure
of introducing Gilad bracha and Gil I'd
turn it over to you okay thank you all
good afternoon and thank you all for
coming hopefully you won't find out you
made a terrible mistake oh so a few
words about this talk before I really
start essentially this is a slightly
evolved version of a talk I gave it
oopsla at the dynamic language symposium
in October of 05 but the history of it
goes the reason I'm mentioning this is
because the history goes back a good
deal longer I started on this topic in
late April of 04 when I got my gmail
account and I use gmail for about half
an hour and concluded that there were
interesting issues that that I cared
about that were worth exploring so what
is this about at a high level it's about
bit rot or rather the absence of it and
and my goal is to introduce it so bits
are these pristine bits of information
right there they never corrode you
cannot spindle or mutilate they never
rot or crumble or anything and this is
often perceived to be a good thing and
and at some point I'm going to argue
that it's a bad thing because when you
have physical objects like your car it
does rust and break and fall apart and
you get to get a new one and the problem
with software is you never really get a
new one and so you're stuck with all
this old crud that lives forever like a
vampire sucking your blood and so my
this is partly about our way of getting
away from this trap of having everything
always compatible till doomsday with
whatever mistakes you made before and in
particular I'm a language grand is the
language talk at some level and
particular there are certain things
about dynamic languages that that can
help us raat the bits so concretely a
software requires maintenance software
has bugs people expect them to be fixed
should you ever reach that happy day
when you don't have fixed they'll
complain because you don't have
new features which will enable you to
introduce new bugs and and renew the
cycle and online update is becoming more
and more widespread of course its
standard practice among operating system
vendors and among the antivirus vendors
who live off at least one operating
system and let me show you what this
looks on unlike on my operating system
so the first thing it does it nags it
says please please can i update listen I
really really need to update now and it
bugs you and then finally we say very
well machine you may update at which
point it turns around and act pricey and
tells you show me your ID show me you're
worthy enough to update and then okay
you put in your password and all and you
think you're done but of course you're
never done without this never ever and
and okay it few people know that below
this line it says you promised your
firstborn child to Apple computer or
Apple phone as it is known nowadays but
that's what it actually says there if
you ever scroll and so you've promised
your life away and then this is really
the annoying thing right half the time
it wants you to restart once you stop
whatever you're doing interrupt whatever
work you're doing it goes off it shuts
down all your windows goes turns your
insurance and comes back again and this
is really one of the things that annoys
me this whole restarting business
rebooting businesses is a plague we
instead of realizing that computers
should not reboot we're making this
worse because now we have phones that
are really computers and they need to
reboot and if you have TiVo your TV
needs to reboot it it's a plague and
sometimes it can get worse right this
doesn't happen that often but something
can go wrong and it won't let you
restart because you have another user
log on or whatever or some process won't
I'm going to ask that you hold the
question I've given this talk a whole
bunch of times what i've found is and
i've done it both ways if you have to it
raises a lot of questions and if you
take the questions in the end there's a
timing disaster and you never get to the
end whereas if you force the questions
into an hour's lot people can stay later
and in fact a typical scenario is
the questions take as long as a talk but
it's better to to keep the questions to
the end if you don't mind so anyway
obviously they're just there's room for
improvement so overall we'd like things
to be better we want to make the
maintenance as transparent as possible
and know that I'm saying as friends
parent is possible but not transparent I
don't think actual completely
transparent maintenances is a good thing
and I'll explain why in a few minutes
but basically we want to minimize the
questions the hassles the problems and
nothing should ever ever visibly boot or
reboot or or any of this stuff that
that's in general something I believe
too if you can do it in 300 milliseconds
or less and come back to where you were
that's okay that's your mechanical
problem of restructuring it shouldn't it
is not something that interests people
you know you know physical objects don't
reboot but you do want it to be always
up to date you do want that maintenance
you do want the bug fixes etc and so
this is a lot like a web application
something that you know some people in
this room might actually know something
about in fact that's a big risk of
talking here is there might actually be
people who know what I'm talking about
and who knows what trouble I'll get in
but web apps have downside now this is
perhaps why I really get in trouble here
right so obviously one problem is the
system software can't be a web app the
operating system the web browsers or all
the major plugins in the web browser the
things that show you your photos your
videos etc and indeed you know the web
browser follows the same model it nags
then it asks inane questions I love this
you've chosen to open a Firefox two
point zero point zero point one dmg file
which is a dmg file in case you didn't
know and what should Firefox do with
this you're asking me you just asked me
a minute ago to do this and all I wanted
was to upgrade to Firefox 24 improve
security and better browsing yay and now
it's asking me what it should do the
people who sit in front of this aren't
all people who work for Google or even
people like me right your grandmother
could be using this your five-year-old
an executive could be using this what
are they to do
what does this mean to anyone right
these hassles have to go away so then of
course you need a bit of patience and
this is sort of premature gratitude
thank you for downloading your download
will become begin shortly so shouldn't
they wait till it downloaded before well
anyway I'm just being petty I understand
where this comes from o ne wait a bit
more cousin sewage it's 18 megabytes
because the whole bloody package has to
be because they've updated something and
you can't live without that and then
there are various hassles like you
actually have to install it yourself and
you forgot to move the file and when you
try to move the file well you can't do
that because Firefox is in use right
again the restart thing everything has
to shut down nothing actually can update
itself without shutting down and more
hassles so there are other downsides of
course to the web apps apart from the
fact that the system software can't use
it there are you I issues and yeah
that's getting better and this all Ajax
thing but you know i got i started on
this issue when i use gmail three years
ago i don't see that things have
radically improved some tools are better
than others but basically i think
there's a real problem both on the user
side and on the developer side with that
model so but that's that's relatively
minor the big problem of course is that
this actually depends on having a robust
low latency high bandwidth network
that's cheap by the way the cheap i
added after my experiences in various
airports my favorite was in Heathrow
where t-mobile had this link us
subscribers go here and I said I can use
these goddamn minutes somehow and then
it told me that you know for ten pence a
minute I could roam the internet from
London and you know the the level of
gouging is beyond belief and yes i know
it's live and the other thing is of
course you really haven't solved a
reboot problem right the sessions expire
you still have to start up every now and
then and it's not just system software
there's a whole world of applications
which could benefit from from being kind
of a real live application locally to
take an example
it's some of you might be familiar with
obviously there's very all kinds of
reasons why why there is a download but
it's a very nice applications fabulous
but it still follows the pester and and
legally sort of model of things because
that's that's what the current state of
technology lets you do so what is
software services is this generic phrase
of course that everybody uses for
whatever unfortunately I haven't quite
caught up with a better one but what I
mean here is of course something that
combines the advantages of web
applications and traditional
applications and in particular it's as
offline capability it's always available
even when there's no network and it is
still always up to date it update itself
over the network nevertheless so it's
running locally but it is Network aware
and in particular and this is one of the
things that distinguishes this from a
long line of in particular all kinds of
startups out there that were in the two
thousandth time frame a few of which I
think are still alive the thing is that
yeah restart free is very very important
I don't actually want to shut down
applications in order to get these
updates I don't want to go through any
major hassles I want it almost
transparent but not quite so how are we
going to do that well hot swapping is is
just a sort of pithy name for for the
process of modifying code live while
it's executing which has a very very
long tradition in a long list of
languages going back to APL and Lisp and
at the dawn of time through small talk
sell for lang are not coincidentally
this is a list of really cool languages
so of course hot swapping you know okay
this is a traditionally done in the
development environment and it's great
and you can you know patch your code
while you're developing and debug and
all that but doing this in production
make some people a little bit edgy there
are lots of their technical issues there
are other issues one of the most
interesting technical issues is this one
suppose you've modified the body of a
function or method and there's still
actually live stack frames what the hell
does this mean both in terms of a what
do you expect the system to do and be
what does this mean for your application
what was the meaning of the program you
wrote under these circumstances then
there's this is basically a solved
problem but it requires some engineering
to deal with you know if you've got an
object-oriented language you've got
instances on the heap and you've changed
you've added fields remove fields
invariance have changed and what happens
to these instances and there are good
solutions for this I think and then
there's a small matter of security that
some people fuss about though it's a
remarkable how little but you know we're
still waiting for cyber 911 at which
point maybe people will start taking it
more seriously so what do I propose to
do about these problems oh well first of
all this is this process of reflective
update through hot swapping it needs
structure and it so happens that that I
have a structure that that's been used
which is called mirror based reflection
and I'll talk a little bit what that is
in a few slides which I believe can can
address a lot of the security worries
around this thing the other interesting
problem is indeed the stack or and it is
of course a lot easy easier if the
program isn't actually out there
computing something with a stack start
doing something if there isn't much of a
stack life is a lot easier but this
doesn't mean shutting down the program
so what does it mean well observe that a
lot of the kind of applications that
would benefit from this model are
actually you know they synchronize
something maybe they synchronize with a
computer maybe they synchronize over the
network with a server they're already
going through a process of reconciling
their data with with some copy somewhere
else and this is a it turns out to be a
very convenient thing for these
applications obviously synchronizing
with the server has all kinds of
benefits putting things on servers I
don't need particular lecture you what
what the advantages are them well the
major ones are written here and I have
this nagging suspicion that you're aware
of that but synchronization is a very
natural point to do this kind of program
update live are the applications are
quiet if you're actually sick we're
talking mainly about user
interactive client applications if
you're about to you know press the sync
button or you could set it up to sink
every hour or some such thing right it's
not doing very much else necessarily for
you at that point it's very natural it's
a hiatus and there's plenty of time when
it with any interactive application when
when the users aren't doing something ah
the advantage of that is there is no
stack there's maybe though at the bottom
of the stack there is an event loop and
depending how actually things are
structured maybe there isn't even that
because maybe it's actor based in the
events or sorry but every actor is
actually waiting for something to happen
in there and none of them actually have
stacks depending how you do it so the
point is that makes that particular
nasty technical problem a lot easier and
equally important the transition is user
visible but very lightweight right when
you sync say a calendar application
you're not going to be shocked if
something new appears you're going to
get new calendar entries new address
book entries whatever by the same token
you could actually get a new menu
entries maybe now there's a dictionary
or a spell checker in your word
processor or some feature that wasn't
there before maybe some bugs are fixed
or something looks a little different
but it's not it you can't have things
change under people's foot like totally
transparently but this is very very
lightweight they don't have to answer
questions and most they have to press a
button for executives there's the mode
where it just does that every hour or
something so it's all based on the idea
of program is data which is of course of
another very old and classic idea and
really what the idea here is to sync the
program as well as the data and in a
well-organized virtual machine your
classes and stuff are objects in the
heap just everything else and actually
really works out that way so the next
thing is again are to make that easy for
people to write applications and do that
so the model here is again software as a
service you're syncing up someone's
providing you the service with back up
and all this stuff on their server and
you have an account
and you synchronize and when you
synchronize you get the applications
that they provide and when you update
your data and it gets backed up and they
push bug fixes to you every time you
synchronize just just to be a little
clearer as to what the general model
here now once you're doing that you want
to make it easy for people to actually
write these application now it's never
easy to write good applications but you
want to make it easier so the idea here
is to basically start with some set of
persistent roots things that have to
persist on the server that have to be
synchronized and of course do the usual
heap traversal and find the subset of
the heap that actually is persistent and
you cut it off by marking certain fields
being transient because not all your
data in your running application is
really something you want to save and
every sink you basically traverse this
collect this data and send the changes
from the last time over the wire so
again you're not sending 18 megabytes of
Firefox necessarily changing what change
in Firefox you know today and hopefully
that's that's very little if you do this
on a very frequent basis and so these
things don't take up time they're not
disruptive etc now transient 8 of course
a transient data in your application
might just happen to depend on the
persistent data and so if you've changed
your persistent data your transient data
isn't going to be good anymore and so
you really need to zap it on every sink
base achill e nil out any transient
field and make those fields lazy so that
when the next time somebody actually
needs that data it gets recomputed so
you can enforce this language wise by
say having something that looks vaguely
like this right if a field is mark
transient it has to be followed by a
closure that says how to initialize it
and whenever it's nil that will be
called and that doesn't mean you can't
get into all sorts of trouble and
whatever you do still have to think
about what what that code is but that
will actually let you update yourself
get rid of any transient data and that
transient data will come back on an
as-needed basis and not be massively
recomputed all at once which which is
sort of what tends to happen in
in some of languages I've worked on in
past oh there may be need for for
another level or there's one of the
natural questions is you know window
handles network sockets there's things
like this that really aren't part of
your of the data you need on on the
server and yet you don't want to zap
them on every sink so maybe there's a
session level or maybe your platform
actually knows about these in some way
that there are a couple of strategies
and I don't have a whole lot of time to
to discuss them but there has been work
on actually bringing these things back
without without losing them now people
who were sort of in the programming
language world know that this is very
reminiscent of the thing called
orthogonal persistent that had some
problems and was heavily criticized and
this is really my high level point but i
actually will bother to back it up so
the problem with orthogonal persistence
that was the idea that basically again
not talking about synchronization as
such but saving stuff persistently to
the disk automatically based on marking
some routes in your program as so as
persistent but one of the complaints
about this is well this sounds all need
you don't have to worry about databases
and saving and storing and all that but
in reality what happens when data data
tends to be long-lived and it outlives
the program so imagine i had orthogonal
e persistent fortran and I had this
priceless scientific data and now of
course my orthogonal persistent fortran
only runs on a machine in the computer
museum and the termites have eaten all
the insulation and we can't run it even
there and and now you know the solution
to to one of the great problems of
science has been lost this doesn't apply
here because the key here is that the
program and data are living together as
part of this service the service bundles
the data and the programs that operate
on them and as long as you're subscribed
to the service you have this data and
every time that data is updated or every
time the program is updated they update
in lockstep now there may come a day
when you want to shut down the service
and then hopefully your contract says
that you can get this stuff out as files
in some format
someone should remind me how I get my my
mail properly easily out of gmail arm
but you know maybe you can get away with
selling this stuff without providing
that the other issue that comes up is of
course if there's transient data when
you do orthogonal persistence in it's
very simple classic form there's
transient data that pollutes the
database there's stuff that's in there
that represents things about your
algorithm state you need to store that
really isn't really part of the real
business objects if you will that the
need to be stored and you know that's
been solved actually in the orthogonal
persistence world already right these
transient markers basically say you know
this is transit data don't bother with
it in fact it gets zapped at every sink
another important point is that if you
do that and you don't save your data
through a database or something they say
there's no cross program interchange
format because the format you're storing
things on the disk is some sort of image
of what you have in your running process
in your program and much as I hate this
answer of smell it is pronounced smell
isn't it some people pronounce it XML
but but a lot of things like you know
Azul or mean X is kind of hard to
pronounce and I i find that fitting so
there is a fairly standard way to deal
with these things nowadays and and it's
sad that this is the way and rather than
say as expressions or something but it's
there you're going to need this with any
kind of web enable thing that will be
you know talking to web services and and
so there is a way to extract this so to
summarize the key points up till now ah
dynamic typing which really makes it a
lot easier to do this hot swapping it
isn't a coincidence that this only works
in dynamically typed languages and that
it's an active research topic with not
many convincing results in statically
typed languages it's not that it can't
be done it's a fine topic if anyone
wants to do a PhD but it tends not to be
done because it's just bloody hard and
it's a distraction once you do the hot
swapping you can do the orthogonal
synchronization that is you can update
your live process
without shutting it down and that's the
basis for this notion of a nice service
that gives you these applications and it
incidentally syncs up and provide
storage and all these kind of things so
then let's let's talk about this small
matter of security so Ott's whopping and
in production already gives people so
willies so doing it over the network is
just there for extra fun oh so there's
several things that are obvious or you
have to verify the identity of the
server well that's not particularly new
every time microsoft updates your pc or
or a mode a better case apple updates
your mac which actually works oh you
you'd better be sure that it's that it's
them and not someone else messing with
your machine so so there are you know as
a sales over there are protocols for
doing that you also have to verify that
the clients are who they say they are
because now they can mess you know they
can upload bad data and mess with you
attic and access your data they can
change your data obviously it shouldn't
be you know some imposter or attacker
but that's no different than any other
web service whether it's synchronized or
not and so these are pretty much you
know regard them as solve problems to
the degree that they're solved and and
they don't really bother me I don't
think it's helpful to have a strong
security model for code here now you can
argue that you don't because you know
the identity of the server and and so
it's giving you presumably good data and
if and and so forth but if this opens up
and supports people plugging in or
adding third-party stuff or add-ons and
so forth it might be a good idea to have
some notion of doing something to make
sure that this code isn't as evil as it
could be in particular excuse me you
will you might be thinking of things
like you know Java or.net which both
have this this model of verifying the
bytecode and I'm not i I've been there
done that so I think that that you do
want something else but but you
certainly do want something because real
secure
is this process of jumping through hoops
and even though you're sure that one
hoop is good enough the hoops break for
the oddest reasons and it's nice to have
a few extra ones to prevent total
disaster from happening so what are we
going to do since I'm not advocating you
know bytecode verification the real
point is that the wire format has to be
dynamically type safe and pointer safe
right most of the real evil things that
can happen if the verifier flunks in
java bytecode have to do with the fact
that the bytecode itself is inherently
insecure oh so no just to take a random
thing JavaScript the assembly language
of the internet platform that actually
meets this criteria there are much nicer
things that you could engineer to meet
them javascript is interesting for the
reasons you you have made the world
learn all too well the other thing that
I care about all here is that objects
have to be strongly encapsulated what do
I mean by that I don't mean java objects
or c sharp objects it's not objects
where anyone who any other instance of
the class can go muck with the fields of
the object or objects where anyone in
the same package or assembly or whatever
it is can muck with that object or
anyone's friends or anyone's cousins or
second cousins twice removed it's real
objects that encapsulate their data and
no one can touch that data except that
object itself the only way to change it
is to ask the object through a method
call to do it that is the basis of what
some people call the object capability
model and that's pretty much the idea
here we're actually going to use these
objects as capabilities how does this
relate in particular to to reflection so
I talked about mirrors briefly before so
mirrors are a technique that was
developed by dave ungar in itself many
years ago and i've done this in in
strong talk for the reflection in that
system there are parts of java use some
of these ideas not java core reflection
that was done my people who weren't
aware of that sort of work and the point
is that instead of having the reflective
calls be calls on the
so the typical model you get is any
object will tell you its class and then
the class will let you query which
methods it has and if it actually has
the capability for art swapping it'll
let you change things and so forth which
means that once anyone has an object you
can go muck with anything the idea with
mirrors is there's a level of
indirection there are specialized
objects called mirrors that reflect
other objects so we get a mirror on the
class and then you get a mirror from a
central point some server object say
capital mirror that will produce a
mirror for something if you ask it and
is in a position to ask that to verify
who's asking and for example it might
give you a mirror that only lets you
introspect it'll only let you ask about
what methods the thing has but won't let
you change or it might give you a mirror
that let you change them but only you
only let you change a certain class
which may be your class or the class you
own or something like that so you can
actually refine this in all kinds of
ways to control who's doing what to whom
and I think that's the basis of
introducing real security with real
reflection and hot swapping at the same
time this is not something you can get
from the traditional reflective api's
for the reasons I just outlined every
object will tell you everything about it
it's not something you get from from
scripting languages where reflection is
basically happening implicitly all the
time your reflection is you you have a
typo and that introduces a new variable
so so that is not really in my mind an
interesting basis for anything secure
the other aspect of security thats thats
related to this is you want a strong
sandbox you do want to control who's
doing what and and again capabilities
give you a good way of doing an in
particular never ever ever have any
global or static state the security
folks call this the principle of no
ambient authority meaning that there's
you know there's things out there there
are in scope that might give you some
ability to do something so an integer ki
might be one but any object that had
methods that could do something would be
a good example of that and so that's
that's not a good idea so security and
sandbox is sort of bring us to the issue
of
larity and there's all kinds of reasons
to use modules so a lot of it is just
for development and some of it is for
deploying stuff and so let's talk about
that a little bit so a module as i
define it is a self-contained parametric
namespace self-contained means you can't
refer to anything in that scope unless
it is defined in that scope or is a
formal parameter defined for that scope
you can't see anything on the outside
everything has to come in explicitly and
traditionally this was a bit of a
problem because you know in Fortran that
means you end up with a list of 50
parameters but there are these things
called objects that are very good at
aggregating things so you can basically
get some same number of things that are
that are your handles on the outside
world and then you you can you can build
from there in particular these things do
not have imports likes a module of 3 or
something imports don't decouple
anything all imports do in the best case
in languages like modular is they
localize your coupling so there's a
panel that says where the cables are and
where they're going to but the analogy
is right this thing is locked in right
if I actually do a modular three module
representing this I take it with the
display with a power cable with a power
station at the other end they're all
connected and there's no way to actually
decouple them right that's not what Reed
that's not the analogy of a physical
module or Hardware module hardware
module has plugs that get plugged in or
Java imports by the way don't even do
that they they're just aliasing
mechanism so that pretty much describes
what a module is and modules are there
sort of my classes there in stantial
there's that one of the things that
disturbs me a lot of these discussions
is people confuse the definition of a
module and an instance of a module so a
definition of any code had better be
something immutable there is a code
should not have state and static
variables are one of the ways in which
people really confuse that and that
causes all kinds of problems so module
definitions are immutable and you can
instantiate them by passing them these
parameters which themselves would be
other objects instantiated from other
mod
perhaps and then you'd get a module
instance which we would be a stateful
object that you could actually run you
know it might represent your application
as a whole for example and this has to
happen somewhere of course you have to
bootstrap yourself so there needs to be
a namespace where you can see the global
namespace but the global namespace only
consists of immutable it's fine to have
this name since this is inverted the
internet domain name convention that job
introduce one of the best things Java
did actually Oh as long as all the
things you see there are immutable as
long as they're in a stateless because
global state is evil and so in a scope
like that you can name different modules
and plug them together and create actual
instances that might represent something
that does something useful it and create
a process of some sort and so the
parameters to these modules are objects
the service capabilities that determine
a per module sandbox so this is just you
know a way I this is not a syntax I'd
use but you know it's a syntax that
probably a lot of people are familiar
with so you can imagine that the way you
actually start an application is by
calling main and you give it an object
representing the platform that's your
actual link to the outside world and
then you you name here com dartford
bardot demo would be the name of a
module definition in the you've gone the
global namespace is basically the
internet namespace com is actually if
you think of it an object representing
the com namespace and it has you know
for google or cadence or sun or anybody
it has sub namespaces etc and eventually
you get this thing and you pass it these
parameters which will create an app now
the parameter is win this case say would
be a sandbox and some arguments that
presumably are immutable here in this
example ought to be safe and the sandbox
is something you ask for get from the
platform so there's different levels of
trust and you might ask for a particular
kind of sandbox that represented the
right level of trust and maybe they'll
call back so it has to to get the app as
a parameter so that's why it's this
electric right these things are actually
mutually recursive and one of the
deficiencies of most language module
efforts is that they don't let you
define mutually dependent modules and
this is you know one of
the litmus tests that I would apply to
otherwise very powerful systems like say
ml modules so this is the way you'd
actually get this object and you could
run it now no static state I've
mentioned this and let's just discuss it
a bit so modules namespaces our values
and it's good to have a concept of
immutable values really worked out in
your language because then for example
you might also use it for other things
like complex numbers rather than having
people complained for years and years
and having to explain them how
complicated is for you to actually do
anything about their problem which is
what happens in some languages oh so why
not static state it's good because if
there's no static state there's no
static state to distribute it's good for
security for reasons we've outlined this
is a thesis of mind that I can't really
prove but my impression in the Java
world was that the static state really
contributed to the huge startup time
problem java VMs are wicked fast and
every time people investigate this they
find oh yeah it's not our fault the vm
guys tell me yeah we checked its it's
doing x million bytecodes per second and
then it still takes 30 seconds so there
must be zillions and zillions of byte
codes being executed why are they being
executed because the model that we give
to program is set up the static
variables for your class which the
minute you have one instance that class
gets set up calling new objects setting
up their classes and there's super
classes and basically you have to build
the Port of New York in order to land a
canoe on my name Manhattan Island that's
sort of the net effect of it drawing in
the whole world early so if you don't
have static state it basically forces
you to to explicitly decide when things
get initialized hopefully lazily as
possible and sort of spread that pain
out are people who I respect and who
know about these things have told me it
really helps their memory management
issues because if the code really is has
no association with state it's just
other objects that you can you can
garbage collect and you don't have to
necessarily be very fancy about dealing
with them as a special case I don't have
time to tell you the story of Java class
unloading but with
it certainly is a real issue so before I
go into this I just want to summarize it
and give you a picture of how all the
stuff might actually be in some sense
made real so obviously the way things
are going you know everything's being
done on web browsers by shoving out
JavaScript out to to these browsers and
module of the security concerns that i
had about you know object encapsulation
which you might be able to work around
with various solutions you can imagine
trying to implement something at this
higher level on top of that provided
that there was something on the other
end that could store objects there was
some object store you could talk to
reliably in standardized and you know
across browsers and in some way that you
could manipulate and that had the right
sort of API for example it would let you
get at all the objects because you're
going to need javascript is actually
very flexible it's or can probably do
the hot swapping effects by changing the
right prototypes etc but you have to get
at all the right objects null out the
right fields etc etc and basically if
that base the extra machinery was there
then people could compile a decent
language into that and you know that
might just happen someday it would also
help if javascript was faster somehow I
have the feeling that these brawls will
work out in time so this concludes the
same part of the talk you might not have
noticed but now let's talk about
something really fun things that can
happen if you start taking this story
seriously and this is usually where
where resistance heats up so what do I
mean no versions versioning every module
system the series talks about versioning
and gets into no end of problems in
there are the wounded are here to
testify if necessary so I don't really
believe in versioning it's a rat hole
nobody's ever solved it nobody ever will
what I'm actually saying here is you
have this service people are subscribed
to it they get the updates and fixes on
every sink and they see only one car
version at any time just like a web page
you know what I really liked that web
page you had an 2003 but I can't get the
google web page version whatever it was
from 2003 right there's no such choice
people don't even think of it so they
don't pester you about it but right
that's very nice that there is from the
users perspective there is no there's
only now and I'm going to take this
further and argue that you really get
away from from releases of course every
time you put out a patch or something
there's a release but in fact you get
away from these things where you know
there's a update releases every six
months and big releases every two years
or five years or whatever it is the
bigger the system no more horrible it
gets and and this is the thing that's
kind of out there so am i serious about
this ah this is a huge change to to any
development model that people have okay
so it's relatively easy for applications
you sort of shown that that it works for
applications out relatively easy i'm
sure enormous amounts of work shut up
machine i'll go into this but the
interesting thing is what if you pursue
this further and say let's do this for
libraries and components so applications
if you change an application and
something is somehow a little bit broken
well as long as there's a human in front
of it they're relatively adaptive even
executives are oh and the difference
with libraries is that it they're very
very brittle it just code and and if
some little assumption probably possibly
unstated and unrealized by anyone
changes suddenly the whole piece hope
house of cards just collapses which is
why people fanatically try to nail it
down and say we're using versions so and
so this and that and you have build
systems are just trying to get the right
thing and enormous amounts of effort are
expended on these horrible horrible
things so I'm proposing to do away with
that in some sense again developers are
subscribers to the library vendors just
as the people in front of the machine
where subscribers to the application
vendors and they sync up they
new versions of the library and they get
this continuously all the time and that
means that things are changing really
really fast right it's not about you
know updates every three to six months
and major releases every two to five
years it's about days or weeks or you
know for a really large system maybe
it's a month or a month and a half on
the outside for for completely going
through the cycle and this requires a
total change of mindset from the people
involved and which is why this is it'll
take a long time for this to happen even
if the first part does because basically
have to shoot you know all the
developers in wait 30 years till new
ones grow I mean this happens we've seen
this happen in the past few years say
with IDs the VI programmers they're
they're getting arthritis and and and
finally we're getting people to use IDs
they're all kinds of things that people
told me wouldn't happen they happen you
just have to wait wait them out till
they die or retire and so basically if
you're in this mindset and you're
prepared to actually deal with things
there are advantages to that it's it's a
little more like open source the bits
are going to rot on you all the time and
you just deal with it continuously it's
also a lot like say homework at school
you can procrastinate which is what I
always did and cope with it somehow at
the end or you can actually be good
which no one really does and and do it
all the time it's actually is easier if
you if you do it in little increments
like your teacher said but you haven't
you need a discipline the difference is
this isn't school people get paid to do
this and I am arguing that this will get
you better software so how would you
actually make this work oh look there's
you can look at it from the perspective
of the people producing library code
from there from their perspective
actually just if you're thinking just
are usually the producer and consumer
you're both a producer and consumer of
course but you know assuming that you're
looking at from the producer side it's
great are you know you can deprecated a
method you decide this thing as a piece
of Miss design crap that that we came up
with in a hurry and we really should get
rid of it and the difference is
deprecating doesn't just say put on
documentation please don't use this
stuff and they'll live forever anyway it
means we're going to
rid of it we're going to get rid of all
this bloat we sent out a notice we know
who our users are everybody is on the
server there's a network there's a
network out there it's not like you have
users out there who you don't know who
they are you can find everybody and you
can notify them this method is going
away in two weeks time here's the
refactoring script script that replaces
a call to method x2 method why if you
don't fix your own code by two weeks
time all your code will break and if you
want to be really aggressive you know
what the server will run the script and
refactor it for you that's that's
getting really radical and there are of
course legal and privacy issue is this
sort of works better in an open-source
kind of model sad to say but basically
you can do senders or whoever all the
callers you can find whoever is calling
this thing and let and find out and if
somehow it's in there are things that
are much more subtle than that right you
have a method and it's Peck to return
nil under some circumstances but it
doesn't really cause someone hacked up
the implementation really quickly but
now you find out that to do the job
properly it really should do that
unfortunately now it's already been
released and you don't know who's out
there depending on this particular
behavior but hey you can still find you
know who the callers are and let them
know and you know what if it if it
breaks again in the development cycle
they'll you'll find out because all your
developers are tied to this update cycle
and they'll let you know and if it
breaks anywhere in the world you will
know which is very different from
sitting inside javis on saying oh god
this is terrible but what can we do who
knows who's using this hmm looks obscure
let's try and see if we can get away
with it not that we'd ever do that of
course now from the consumer side if
you're if you're on the receiving end of
this it's a good deal harder right now
someone's changing this stuff while
you're trying to work and develop and
someone's meddling with this library as
you're doing this although the one thing
to remember is that the base of this is
actually managed right today you decide
at some point we'll go to Java 5 and 2
million lines of code have changed and
everything is different and it's a huge
step whereas here you know
libraries don't actually change every
day right you know this week Oh they've
taken away this method or where this is
a place that maybe you can manage if you
stay on top of it the other thing is
okay they change something and now you
have to adapt to it and you know there's
the old version that did this and the
new version that does that and you start
at nigga scruffty code well if it's like
this do this etc the people have this in
their code everywhere and the problem is
that these cases live on forever and
grow from version 1 to 2 to 16 here
basically these things live a week you
have this you have to put out the the
test because you might put out your fix
before they put up theirs and for a
little while there might be you might
encounter inconsistencies but once they
put out there's you know that all the
data has actually been converted and
you'll never encounter this case again
and you can clean up your code you can
reduce croft and i think that this
effort is worth of value because it
changes from a while where things are
compatible to doomsday and you end up
with vista to something where you can
actually clean it up as you go along and
actually do good programming and of
course you're going to miss make
mistakes and put out bugs there that the
real users will see but you know what
you're doing that anyway and today sure
you go to a lot of testing to avoid that
but when you put it out for the users
what happens well they can write and be
annoyed and they can wait and if they're
lucky in three months there's an update
release if your update release cycle is
rather rapid and if it's a high enough
priority bug that is a lot of important
people have complained etc or they can
wait six months really can wait two
years if it's not a hyper it'll be fixed
in our next release thank you very much
you may actually have more bugs put out
but you can fix them tomorrow you can
actually respond you can fix if anyone
complains in fact if they don't complain
you don't have to have put this little
window that Apple puts up would you like
to report this bug it gets reported
anyway because it's all on the server
you can put asserts in your code that
right an object to the server that said
this thing is not right there's all
kinds of interesting traceability and
things that people could do in this
framework and I'm sure I'm not clever
enough to figure them all out but you
probably are so so I think that this is
is a huge mindset
change but oh I argue that it will give
us better software in the end and the
current situation is just untenable as
these things grow bigger and bigger and
bigger and even if you you know if you
even if you are the recipient of the
global software tax and have untold
billions and thousands of developers it
gets to the point where you can't
deliver anything remotely on time and
you can never deliver anything secure so
that's that's most of the technical
content here oh so a little bit about
related work well mirrors I've talked
about this where they come from so we
have done that I keep its on this this
is the Java debugging interface not the
reflection apt is this annotation stuff
there's a paper anup so for that I wrote
with it with dave ungar that actually
describes mirrors in some detail and
argues for for some other other
properties with good software
engineering properties etc that they
have idea of not having statics you can
see that to some degree in Scala in E is
a very interesting language that sort of
is actually focused on security issues
and of course the security lessons to be
learned from it and from Java positive
negative modules are there's all kinds
of works on modules are this is my
thesis from 1991 which may still find
its way into the scheme units is very
close to what I described is stuff that
was done in scheme are very nice work ml
modules are sort of the standard
academic reference for modules but they
have they have very significant problems
in my mind despite being very powerful a
particularly no mutual recursion and the
fact that they're not first class
fortress has a component model that's
kind of reminiscent of this can we talk
about representation independence this
time but one of the things okay so the
point was when we had the transient
fields that have to be you know lazily
initialized every time because they get
zapped well it really helps if
everything goes through an accessor now
any decent object-oriented language
should make sure that everything always
goes through an access ER and you won't
be able to tell what the actual literal
representation underneath the object is
self pioneered that idea
some of this especially the early part
of the talk you know routes to the
various client work rich clients thin
clients fat client smart clients manage
clients that have heard all these names
no end of effort so flash the macromedia
were actually some of the people who are
really on this very early but the
business model was interesting they want
a twenty percent of developers money I
didn't work out there's of course all
kinds of stuff you know more about this
than me sync email web dev all kinds of
things that sink ml is interesting for
for the synchronization procedure
actually so sort of the big language
technology picture here is you need
object-based encapsulation to do an
object capability model which gives you
security which is necessary to really do
hot swapping in production the other
thing that is really practically
necessary and very helpful to be able to
do it is dynamic typing once you have
hot swapping as I said you get the
software services and there is nirvana
version free software of someday so to
summarize this is my slogan the idea is
that the instructor in destructibility
of bits is actually a curse in disguise
it's not a feature it's a bug and we are
better off with a model that expects
change an incompatibility as a matter of
course rather than a model that says oh
hang on and try and make it work the
same with the old same old crap forever
and ever and using some fairly basic
techniques from dynamically typed
languages that do have features that you
don't really find in practice yet in in
like modularity and security are based
on the object model you can actually
construct a model of the world that
actually works this way so there that
was it thank you very much and if there
are any questions
yeah so this model requires all software
to be available online to everyone all
the software that's being delivered but
yeah I got to repeat the question you'll
have to remind me every question so the
question was whether this requires all
the software to be able to be freely
available online all the time is that
right it requires that all the software
that you're delivering through this
service is on is on the server online
and available I didn't say you know it
whether it's free or not is a completely
you know that's a business model
question there are real issues of course
with what exposure if you want to do
some of these things you know are am I
willing to to let you know which calls
are making and to what extent can you do
that and then there may be intermediate
degrees if it's open source that's a
non-issue if it is an open source you
know your contract it has to say that
you know if you're using my library I
agree to let you know which which calls
up making I may not expose all the code
but I'll tell you that I'm calling these
particular routines and maybe this
number of times you know their
intermediate degrees but yeah and and
really it requires that you'll be
writing in a higher level of the
language that actually enables you to do
the sink that's the real hurdle Robert
yeah well yeah well yeah Oh am I am I
not am i lying about short getting rid
of releases because I'm really just
shortening the release cycle to maybe if
I'm lucky an hour or a week or something
yes I am but that that's so that's a lot
less painful than you know you can't
have a lot of meetings during this hour
for example you can get rid of all kinds
of bad things about releases the process
the the committee you know it but yeah
we are just shortening there are still
versions there's a developer version
possibly multiple versions and there's
the real version out there but people
don't see the versions and and the
number of them just decreases a great
deal yeah okay so how do I evolve the
persistent state if I've replaced I'll
say one object with with a group of
objects so so let's let's start with you
know if I change the shape of certain
objects right you can go through the
heap this has been done people have have
come up with you know you can define a
script that massages old data into new
data if it's multiple objects presumably
hopefully they're hanging off of of
something that coordinated them or
they're in several data structures that
you know several tables that you know
and you go over them and you basically
reconfigure that data structure you make
a copy of it and these objects are lying
in this persistence store on on on your
server and maybe you do you sometimes
will have to do this in stage it's so
you'll instrument your code to update
both of these structures and then swap
right but you can do this over like two
cycles of synchronization or something
yeah so if I
end users as an application that they've
gotten through this model they like that
employs a library that's also using boom
boom the dragon skin correctly and I'm
now on the hook for
continued maintenance
both
some okay so the question was we've got
a user who's using an application that
they got through this mechanism and that
uses a library that is also on this
available through this mechanism and are
an mi and my question is who are who you
meant by i but who's on the hook for my
continued maintenance of both these
things an executive ok so the executive
presumably works for the software
vendors right so yes anyone who's
participating was a vendor who's
providing code through this model is on
the hook for maintenance of essentially
as long as they're in want to be in
business with this model so but if an
end user is using the application who
developed it on the application
development library continues
it seems like I'm in a position where my
application may stop work Yeah Yeah
right okay so so you contract you the
the user is getting a service we haven't
really you know business models or one
can speculate but the service if you are
providing an application then you
probably have a strong interest in as a
service making sure that any application
that you're putting out there is
maintained so if the people who contract
so you probably want to contract the
applications and make sure that that
they have some obligation to you to
maintain this and if not that you own
the code and maintain it and you know
what sometimes that application will go
away because maybe they're not enough
people who make it worthwhile to
maintain that if that's the difference
between software as an artifact and
software as a service software is an
artifact is something you hold in your
hand and and and keep it for for as long
as you possibly can a service is not
something you hold in your hand if you
go to a restaurant and it closed tough
luck you know it's my favorite
restaurant and they really shouldn't
have closed but dammit they wanted to
retire oh so I can complain and in fact
here at least I can complain to somebody
because because the service may there
are issues of managing it yet but some
of these things may go away at that
point we've discontinued the service for
this application and you might have
valuable data which we will give you in
XML or whatever files or you know you
probably want to have some contractual
obligation to get the data but yeah
there are no guarantees in life or in
reality people use applications from
then if they're if they're serious about
stuff is application from vendors who
they know aren't about to go away that's
what distinguishes you know a serious
vendor from from something else so
you're getting a service you're not
buying the thing Oh me huh you don't
minden libraries who very frequent
updates i cocoon did you worry at all
the developers become slaves to make
things that have no time for creating
new features well if I were a developer
I'd worry that they become slaves
regardless of their creativity so the
question is do I worry over the fact
that in this model with this frequent
updates developer has become slaves to
the maintenance and upkeep and don't
invest any creativity and doing cool
stuff so I think there's part of this
first of all there's a worry about the
developers especially the small-scale
individual developers right you're sort
of on online here all the time right if
you are a small business owner you'll
find that this isn't new in the world
right if you want to make your life
vaguely tolerable it's really good to
have a partner so so you can take
weekends off or something and share time
and you and you may and pair programming
for example goes nice with that maybe
you don't want to be the only one who's
maintaining this thing oh there's a cost
to maintaining things at this level and
maybe twenty-four seven and there's a
question of whether people are willing
to pay it not necessarily the developers
there may be an economic model here
where the service actually if you can i
still get someone to pay for it if to
pay for the storage to pay for the
backup etc where they actually have an
interest in paying the developers to
maintain this and so yes they could come
slaves because someone has to keep the
thing but that's especially an issue
with with smaller groups and more bigger
applications there's has to be a team
that maintains it at the creativity you
know the model where we buy software
from someone who sells it has not shown
me software with great creativity or
that I can I'm not worried about that
yeah since the lack of static typing
make it more difficult or API consumers
do it changes from the guy who's hiding
minigame yes so so typing is a
double-edged sword the question was
whether the lack of static typing made
it made it harder for consumers to deal
of api's to to to cope it actually makes
it harder for the producers as well
because one of the things is harder is
to find out you know in a dynamically
typed language it's not so clear who is
calling your method and not some other
method with the same name right so
static typing of some form is actually
very helpful it's like the idea is that
do name completion and all that they can
do a better job with with some form of
typing it's a different top to talk
about optional and pluggable typing
because really this is about the
documentation value of typing in some
sense which is the main value as far as
I'm concerned and that doesn't depend on
having a mandatory type system what
mandatory type systems tend to do is to
encourage people to implement very
brittle systems that break if any of
those type assumptions broken with all
these updates going on you know there's
another story here that you could say it
is statically typed but we we actually
do cope with the hot swapping by having
the server verify that everything is
type safe before we give you a download
I don't like complicated so you know I
don't necessarily advocate that but who
knows how this might evolve in in
practice but it does make it more
difficult and it would be nice to have
at least optional typing to give you
some some handle on that
so we're after three o'clock oh there
actually is a meeting room if anyone
actually wanted to talk about this more
Gainesville but maybe nobody wants to
talk about it more which is fine so Oh a
building oh yes you have many many
buildings it's in building 41 first
floor oh there I think I passed the quiz
so if there are any one has further
questions I'm happy to entertain them
here or there if not thank you very much
for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>