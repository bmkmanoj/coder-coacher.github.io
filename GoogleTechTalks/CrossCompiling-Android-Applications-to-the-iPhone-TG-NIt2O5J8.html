<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cross-Compiling Android Applications to the iPhone | Coder Coacher - Coaching Coders</title><meta content="Cross-Compiling Android Applications to the iPhone - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cross-Compiling Android Applications to the iPhone</b></h2><h5 class="post__date">2010-03-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TG-NIt2O5J8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we have professor on reporter from
San Francisco State University prior to
his current position at SF su he worked
for AT&amp;amp;T Labs research and German
Telecom his research interests include
middleware ubiquitous computing and
applications for sensor networks today
he is going to talk about cross
compiling Android applications to the
iPhone and I'll give it to Professor
Porter then ok thank you lady for the
introduction and well thank you for
inviting me to talk about my research
smartphones have become very popular and
in particular those two way that I've
mentioned on my slide here on the title
slide Android and iPhone have certainly
created quite some buzz and as more and
more of these smartphones are released
of course the the problem also increases
in terms of deploying your application
on different different smartphones
so the technology I'm going to talk
about today is helping you porting
applications from one smartphone to
another and in particular I will be
talking today about well as the title
suggests cross-compiling Android
applications to the iPhone now before I
go into any technical details I wanted
to just briefly introduce the team of
course with any open source project and
and xmlvm is an open source project you
stand on the shoulder of giants
so xmlvm as an open source project is
making use of over half a dozen other
open source projects but it always boils
down to the people so with an our
project there are a number of people who
have made significant contributions to
xmlvm so the core team besides myself
Asha highballing who is actually another
Googler he works out of the Zurich
office and Vulcan Cohen who works for a
consulting company and in Germany blue
kawatte and Luca odd is also a corporate
sponsor of our project now as a growing
open-source project we also have now a
growing number of people who make
contributions to
xmlvm in at least as of today I list
those names that have people who have
done some some some work in our project
well a bit of background I guess it goes
without saying that smartphone certainly
are getting very very interesting if you
look at the growth rate so they have
double-digit growth rates and that I'm
sure is going to persist for quite some
time to come now if you're an
application developer then you are faced
with the problem of rewriting your
application for the various platforms
and that can consume a lot of time and
resources
now while the programming environment is
a little bit different these smartphones
do have similar capabilities when it
comes to their hardware features so
again the problem here is that that you
as a developer are faced with this
problem of deploying your application
cross-platform and on the next slide
here I've put down some what a kind of a
little snapshot here so on the first
column I have the agency g1 I have on
second column the iPhone 3GS and the
third column I have the Palm Pre now
Android is releasing more and more
devices and google has just recently
released its Nexus One so of course even
with an Android there is now a multitude
of different devices out there but again
like for the slide here I guess the
important point is if you look at the
upper part of that slide I give you a
little background on the on the hardware
on the various devices and you can see
they are almost well at least very
similar and if I keep on adding more
more devices here there probably will be
the same in terms of speed in terms of
CPU in terms of RAM but then if you look
on the bottom half of this slide you
will see that that they are actually
quite different when it comes to how we
have to develop an application for them
so I mean you are the developer of
course you look at the smartphone from
from an SDK perspective so how do you
actually write an application for the
phone and if you look at Android well
Android is using Java as the as the
language to write an Android application
and the GUI is based on
well specific Android API that you make
use of writing an Android application
you have virtual machine technology is
allowed on that smartphone and
everything is open-source
well I mean it's a little bit of a
caveat of course there are some
proprietary parts that Google does not
turn into open-source but at least for
the base SDK everything is open-source
if you look at the iPhone that's
completely radically different so you
have a language called Objective C and I
will say a few more things about
Objective C on the following slides
furthermore you have a proprietary API
called cocoa touch providing iPhone
applications and of course the complete
tool chain is proprietary actually you
need even a Mac platform in order to
write an iPhone application I also want
to say a few things about the Palm Pre
actually it's a device I like very much
I think it's unfortunately little bit
underrated it should be given bit more
attention if you ask me but if you look
at how to write poem pre-applications
they actually have decided to make use
of web technology so if you want to
write a native pine pre-application you
end up writing HTML CSS and JavaScript
almost as if you are writing a web
application so again like the point of
that slide is here that while the phones
are somewhat similar on the on the
hardware side they are radically
different from the way you actually
write applications for these phones so
the proposed solution that I'm going to
go into some detail here in this
presentation is that we say well as kind
of a frame of reference we take Android
so so we expect people to use Android
and we do that for various reasons well
first of all I mean I'm in the education
business and there's certainly a lot
more skill set out there for Java than
there's for example for objective-c so
if you look at how much innovation you
can achieve certainly I would argue that
basing on Java is certainly a smarter
choice than Objective C so I'm not
looking at the current number of
applications you have currently in the
App Store I'm looking overall at the
skills I already have out in the
industry
the second thing is that Android was
built from day one or was designed from
day one
to serve heterogeneous set of devices so
in particular Android copes very well
with different screen resolutions and
the iPhone for example is only doing
that now Apple has recently announced
the iPad and only now Apple is faced
with that problem of having two
different devices the iPhone and the
iPad that have different screen
resolutions so only now actually they
are beefing up there and hansung there
there is decay to also support different
screen resolutions so so from that
perspective it makes a lot of sense to
take and draw it as the the frame of
reference and then what we do in our
tool chain that kind of is also the
outline for the rest of this
presentation so the first step that we
that we do is or that we did is to
design a Java API for cocoa touch
remember that cocoa touch is based on
Objective C so the first step will be to
create a Java abstraction on cocoa touch
the next step is going to be to cross
compile Java to Objective C since we are
starting from Android then we won't go
over to object you see we have to cross
compile that somehow and maybe I should
also stress this point because the
iPhone or Apple rather prohibits by
License Agreement the use of virtual
machine technology on the iPhone so you
cannot run a virtual machine on the
iPhone and but by cross compiling we
actually end up with native native
application that does not require a
virtual machine so our tool said is
within the legal framework of the Apple
SDK now the last step that we have to do
is to deal with the API mapping so if
you write an Android application it has
different kind of API than the iPhone
obviously and the last step that I will
be talking about today is how we deal
with that through what we call the
Android compatibility library so as a
programmer is a geek the first thing you
do in any programming language is hello
world so what does hello world look like
for the iPhone well as I mentioned
before the iPhone is based on
objective-c
so if you want to write a native
application for the iPhone you have to
do that in Objective C now I tell my
students sometimes that Objective C is
like the Latin a likely language Latin
you know there's exactly one
in this world where latin is being
spoken that is the Vatican of course
so Objective C is used inside of Apple
but not used much outside of Apple and
it is a dynamically typed language it's
a strict superset of the C programming
language so every legal seed program is
also a legal Objective C program and
what you see here is again is the hello
world program and if you've done any
kind of GUI programming then then
probably it will make sense of it rather
quickly
one thing you often notice the first
thing you often notice when you look at
it at your first objective-c program is
that you see all these square brackets
and these square brackets denote method
invocations so whenever you see a square
bracket the first argument is actually
then the target which can either be a
class object or an instance and then you
have a list of named parameters that you
are sending to that object so for
example if you look at the first thing
here a UI screen main screen basically
UI screen is a class of the cocoa
framework cocoa touch framework and you
ask it to give back the main screen so
what you get back is is a pointer to
this object and you can actually see
here see shimmering through a little bit
because you still have these pointers
that you have to deal with in Objective
C now if you look at the rest of this
program I think you can probably make
sense rather quickly if you done for
example some swing programming so if you
look at class UI window that is being
used here a little bit down that kind of
corresponds to a J frame and if you have
any swing programming a UI view you
might correspond or it might take an
ontology to jpanel UI label then again
correspond to something like a jlabel in
swing so with that I think you
understand what is happening here just
maybe a few side notes here first of all
the the entry point of an iPhone
application is a method that you have to
overload that is called application did
finish launching so that is I didn't
come up with that name that is that is
the official API as defined by the
iPhone SDK so that is going to be the
first thing as going to
we called of your iPhone application of
course you have to derive your your
application class from base class UI
application order 2 to overwrite this
method but but that will basically then
kick off your your program that's the
first thing I want to point out the
second thing I want to point out I
already mentioned that objective-c is a
superset of of C so that's why you have
these pointers I want to point out the
the second line here of my
implementation and I'm not sure if you
can see the mouse here so basically I
asked the screen object for its
resolution and I get back something of
type cg rekt now you will notice that
there is no pointer here actually cg
rekt is a simple struct and unlike C++ a
struct is not a class a struct is just
simply a value type so what is done what
is happening here actually you are being
given back a struct that is copied by a
deep copy mechanism here I want to point
that out because Java as you know does
not have value types so when we do API
mapping we have to also kind of bridge
this while you might call it a problem
when when we have value types and
Objective C we have to represent it
somehow on the Java side so this year is
now the objective-c version of hello
world for the iPhone so the first thing
we have done in our framework is to come
up with a Java API so on this slide now
what you see is is a Java program that
is basically using our API mapping for
cocoa touch but it's well first of all
100% Java and but it has the same
semantics so with all I've said on the
previous slide I guess you can
immediately understand what is happening
here so we've kept the naming convention
so you see drive your application class
from base class called UI application
you have to override a method called
application did finish launching and
then also the other classes UI screen a
UI window we just have taken the same
names of course as as we have found them
on the objective-c side so we are trying
to mimic the API from cocoa touch that
we see on the objective-c side as
closely as possible on the Java side to
make it more easier for
for a program or two to make that
transition so ideally can even go to the
cocoa touch API documentation and then
kind of understand what what these
classes are doing but of course we have
taken some design decisions here in
terms of staying closer to the the
nature of of Java so we have made use of
strongly-typed interfaces for one thing
so wherever we see something dynamically
typed on the objective-c side we're
making use of Java interfaces and also
like for example your constructors we
are using constructors a little bit more
the way they are supposed to in in Java
it's also a little bit different the way
it's done in in Objective C so like if
you take a look at this slide here now
so if you take this java source code
here then basically what happens in our
tool chain is that we cross compile this
Java source code over to Objective C
source code and how we do that I will
explain on the next few slides but once
we have the cross compiled to of
Objective C source code we link it
against a little library that we call
your Objective C wrapper classes and
then what we end up with is a native
executable on the iPhone so there's no
need for a virtual machine so you can
deploy that on your iPhone and again
since we're within the legal frameworks
of the of the Apple SDK we can also push
it on the App Store of course now if you
remember the even a little hello world
application had on the previous slide
was making use of a class called UI
screen UI a window UI label now what you
can do is and that is what I have now on
the slide here what you can do is you
can actually provide a Java only
implementation of these classes so if
you have a class like UI window instead
of just having a skeleton why not just
implement it also based for example on
Java 2d what you end up with is a one or
two percent pure Java version of your
iPhone application that you can run on
any platform so any platform that
supports Java you can now run basically
it's it's our own Java based iPhone
emulator that allows you to run your
Java based iPhone applications I want to
switch over for the first dev
to explain how this works and I'm in
Eclipse here and I'm going to launch now
a little application that is kind of our
trademark application called fireworks
and it does not a whole lot it just
switches into full-screen mode and then
it does little fireworks and I have my
ipod touch here so if I call fireworks
here on this device then of course you
see the same thing now there's one
little gimmick to this application when
we turn it around we use the
accelerometer so you will notice on the
device here if you can see that that the
sparks always follow gravity so no
matter how I turn the device the Stars
will always go to the bottom so and we
have mimicked this behavior in our own
Java emulator here by these scroll bars
so if I modify the scroll bars here by
feeding different values into the
accelerometer then then you can see that
the Stars start flying in two different
directions now again I want to stress
what the application you see here that
the thing is that what is called iPhone
simulator is a 100% pure java
application you can run that on the
windows and the Linux and the
application that you have seen on my
ipod touch is just the cross-compiled
version of the application of course on
the device there the glasses are linked
against the cocoa touch class so to hear
the behavior that you that you have seen
there is a little bit more that's kind
of a fun thing so here actually I have
my ipod touch the little remote control
application and what I can do is I have
created an ad hoc network between my
ipod touch and my laptop here so what
I'm going to do now is I'm going to
punch in the IP address of my laptop I
hope I get this right here
so what happens now is my ipod touch
acts as a remote control for my
java-based emulator and what what
happens is when I turn my ipod touch you
will see that well you can see that the
the scroll bars kind of turn by magic so
basically the the readings from my ipod
touch are being sent here an HTTP
request to our java-based emulator so
when I turn the device my ipod touch it
kind of if I turn it upside down my
device and the stars in my java later I
start flying up now this application
that I've used here on my ipod touch
we've actually implemented using our own
technology so what I can do now is I
could I can go back to eclipse and I can
just simply run a second instance of our
Java emulator and what you see now here
is actually the interface I have just
seen on my ipod touch so I still have
the the fireworks running here in
parallel but what I can do now is since
I'm running both emails on the same
laptop I can just simply type in the
loopback IP address I can turn this on
and if I now use the controls on the one
emulator you can see that it reacts over
on the second emulator so if for example
I go up here with them X starts going
left and right so you can see that
actually for our java-based emulator we
have already pushed it to some extent
here so all that you see here again on
the second immolate err is just a Java
implementation so we have mimicked a
little bit the look and feel of the of
the iPhone by providing a Java 2d
implementation of the cocoa GUI elements
so let me go back to my presentation and
so let me talk about some of the
challenges that that we're facing before
I actually tell you how we do certain
things let me tell you first about the
problems that you have in trying to do
so well first of all as I mentioned
before as it is
we tried to mimic the Java API as
closely one-to-one as we see from the
objective-c API but we make use of
strongly type interfaces so just to stay
in the spirit of the Java programming
language now when it comes to challenges
there are challenges related to the
language cross compilation there are
challenges related to the API and let me
first talk about the objective-c
challenges well first she has no
namespaces Objective C does not permit
method overloading so they allow method
overriding but not method overloading so
Java supports both so when you cross
compile you have to deal with that
somehow the version of objective-c
that's being used on the iPhone does not
have a garbage collector so if you write
an iPhone application you actually have
to make use of a reference counting
mechanism that is given to you by by the
by the iPhone framework but it's your
responsibility as a developer to
actually correctly retain and release
object references so since we don't have
a garbage collector on the iPhone what
we do is actually doing our cross
compilation we insert these retain and
releases during the cross compilation
phase now of course if you if you're
familiar with garbage collection you
will know that if you do reference
counting reference counting although
it's more efficient than garbage
collection but it does have some some
limitations so for example if you have a
cyclic data structure that cannot be
reclaimed by by reference counting so
that is one of the limitations that we
have right now in our tool chain so if
you have a cycle in your data structures
that you build up then you need to break
that cycle manually by by assigning a
null pointer somewhere once you do that
of course then we can reclaim memory but
if you just have a cycle in your data
structures at this point we cannot
garbage collect that now the challenges
we have on the API level well quite a
few well first of all the cocoa is not
as cleanly designed as you might think
so for one thing it's not always object
orientation that they have used in
designing the API so you actually will
see quite a few C functions there
for doing certain things so for example
I've holiday plus one year CG color
create creates a color object but that
actually is a C function so you have to
provide it the RGB values and then what
you get back is some something that you
can use as a color value but this
function here is actually a function in
the C programming language sense so it's
not like a static method of a class as
you might would expect in a clean
optically design but it's it's just a
function there's a question here I
wouldn't say it's it's worse it's just
comes from historic background so of
course the the quartz framework has been
there for quite some time and okay the
chatter the question is that that
creates some challenges in cross
computation well it does because
remember we cross compiled from Java to
Objective C so whatever we see on the
objective-c side we have to create some
Java API for it so since there are no
functions in in in Java we have to you
know create some static method of some
class so we have to basically turn this
more procedural interface into an
optical entity interface so that's the
the challenge that we had to deal with
and I'm not saying that that what Apple
has done is is bad here it's just legacy
basically you know the other things that
already mentioned before like value
types if you look at C direct that is
actually not a class it's just simply a
value type so there are no value types
in in Java so I didn't point that out
and that's like earlier but you probably
you might remember that actually there
was a java class called
c direct so again value types don't you
don't have something equivalent on the
on the Java side so here we again map it
to a proper Java class but during the
API making of course we have to map a
Java class to a value type on the
Objective C so that happens inside these
wrapper classes the next thing that that
kind of cause are some headaches is that
well at least the design of the cocoa
API is using some old little tricks that
people might remember the older people
in the audience at least from the C
programming language so if you need
additional output parameters there's a
common trick to have a pointer to a
pointer basically to to pass back
additional output arguments now Java
only supports call-by-value so you
cannot do call by reference so again
from from the Java API in design
perspective we have to deal with that
and what we have done here is to create
some holder classes that basically are
just act as a wrapper around an output
argument and the last part is again the
delegation that is heavily being used in
cocoa touch and as I mentioned before
here generally we have turned that into
a strongly type Java interface also this
state truthful to the spirit of Java so
let me explain to you how we actually
cross compile Java to objective-c and
the first thing is that we do not have a
Java source code level cross compiler so
what our two will chain what our what
xmlvm actually cross compiles is not
Java source code but Java bytecode and
more specifically we are making use of
the dalvik virtual machine or the Dex
instruction set so you might know that
Android is not making use of the
standard JVM but Android has chosen
their own virtual machine called dalvik
and the by code instructions are called
decks or Dex instruction set the big
advantage of Dex is that it's a register
based instruction set so the Java
Virtual Machine is based on a stack
machine but dalvik is based on a
register machine so we're making use of
that and the first thing that we do in
our tool chain is to take the Java
source code and turn that into an XML
file that where the the implementation
is represented by the dalvik instruction
set so to show you how this works on
this slide here you you see a little
very simple Java class so you see a
class called collec he has one setting
member once it's a secure method called
add it just takes two into
and all it does is just simply return
the sum so it returns X plus y so in our
tool chain what happens is well first
you just take a standard Java compiler
to turn it into a class file and then by
piping it through our tool chain and
again by making use of the open source
tool that with access to from Android we
turn that into an XML file they just
simply represents the the dalvik
instruction set but marked up through
XML so what you see on the next slide is
basically this class color but now
marked up as XML and making use of the
dalvik instruction set so it looks a
little bit we are a little bit
complicated but if you take a closer
look it actually not that not that
they're difficult to understand on the
top level you have you have attack
called class that is your class
definition then you have a method that
is or the add method we had before you
have attributes to denote the various
properties the modifiers that you have
for this method like in this case it's a
static method you have a signature so
you can clearly see that this method
takes two integers as input it takes one
or it returns one int as a result and
then most importantly down here you see
that in the code tech code you actually
have the Dex instructions that make up
the implementation of method add by
means of dalvik instructions and you see
actually there are only two instructions
here there is an ADD end instruction
there is a return instruction now the
add in instruction makes reference to
three registers V X V Y V Z and what
happens inside the dalvik virtual
machine that the the certain registers
are being initialized with the input
argument so actually by convention and
and I won't go into too many details
here but register number one in register
number two correspond with the input
arguments X and Y so basically what this
one instruction at int does here it will
add the
intent of register one with register two
and it will store the sum in register
zero that's exactly what my my java
class was was doing that on the previous
slide and the second dalvik instruction
here then says return and we returning
the content of register zero as the
result of of this method so that's kind
of like your little inside glimpse into
what hack actually happens inside of
dalvik that runs on any Android phone so
but why do we convert this to XML well
that actually is also where the project
xmlvm gets his name from because we're
using XML technologies for then
generating high-level languages so in
particular what we do now is we're using
XSL style sheets for the cogeneration so
on the next slide I'll give you one
example on how we map this add-in
instruction to source code again and
what you see on the bottom here is now
the Nexus a template that will always
fire they will always match whenever it
comes across the add an instruction that
I explained on the previous slide but
then what happens is that whenever the
XSL processor is coming across that it
is going to emit this code that I have
here in the as children of this template
and basically the code that will be
generated is what I have here in this
little yellow box here so basically this
one add an instruction is going to
result in this year our one got I plus
r2 dot i and that is being assigned to
r0 dot I now these registers here r0 r1
r2 are based on a union that is of type
XML VM LM so because a register in
dalvik can hold different data types it
can hold an integer can hold a float for
example so in this union here represents
all these different possible types that
can be stored in a register and by since
we have the instruction at end we know
that what is in those registers are
integers that's why we are accessing the
value through the dot I discriminator
but you can see in terms of cogeneration
so for each darling instruction we have
like a very small very easy to
understand
templates that that will then basically
generate code in in the in the in the
target language now on the next slide
here I'll show you the results if you
take all our templates and if you run it
through the XML file I had two slides
earlier then here's the objective-c
source code that you would end up with
and again you see of course there are
templates that define all these
registers here so we have three
registers they're all of type xmlvm LM
as I explained before you can see here
the add method and here you can see
actually using name mangling to cope
with this problem that Objective C does
not allow overloading so we have our two
input arguments X and Y which here again
on bytecode level are referred to us and
one and two we initialize the input
parameters with the registers here's the
one line so the the addition data is
basically the the code that was
contributed by the XSL template I showed
on on the on the previous slide and then
the return statement then will return
the result now of course if you run this
to GCC here then there will some more
optimization will be happening here you
will no longer see this actual
assignment here so you will do the
immediately on those and one and two so
actually by cross-compiled index
instructions we are capable of
generating fairly efficient code on the
on the target language now we have
different set of style sheets that do
the very same for Java Script I
mentioned earlier that we also support
the poem pray so we also have style
sheets that just simply take this XML
file that contains Dex instructions and
but Maps then the Dex instruction set to
to JavaScript so so we can actually then
also cross compile an Android
application over to the iPhone sorry to
the point pray so after this point all
I've talked about was the iPhone I have
not said anything about Android right so
so I come now to the next part of my
presentation because now that we have
added a Java layer over the
i phone basically the next step will be
to take care of the API mapping from
Android over to the iPhone and if you
look at the way you write an Android
application of course you first of all
you use a Java language and use an
Android specific API so if you look on
the far left of the slide you can see
the Android application that runs on top
of Android is only making use of android
api so whatever you you see published as
part of the Android SDK that is what the
application uses now what we do now is
for the iPhone so we have now what we
call the Android compatibility library
that is built upon a common device layer
so basically within our compatibility
library we have a little abstraction
that actually captures the essence of
the smart phone of the particularity of
the smart phone and those portions of
Android that actually are generic to all
smartphones and I'll give you some
examples in the next few slides but the
way this works is not at the end read
compatibly library it's also written in
Java of course and it offers exactly the
same API as the Android API gives you
and all of that is cross compiled to
objective-c so what you end up with is
again a native application on the iPhone
now we will do the same thing over for
for the for the Palm Pre so now except
of course here we cross compiled from
Java to JavaScript and we have a
different web West later that kind of
adapts the the common layer API to the
way things are handled on the Palm Pre
so to give you some examples on how this
looks like let me give you a three
different examples so first example and
the first example I want to show you how
we map an Android button over to an
iPhone button that's a fairly simple
example so if you look at an Android
button there's a class called button it
lives in namespace Android widget and in
our implementation of our xmlvm
framework what we do is we just
basically our implementation of the
Android button is
basically nothing more than a wrapper
around a UI button and this UI button
that you see here in the first line of
this class button now the Java wrapper
that we have created for the cocoa touch
UI button so UI button is the name of
the class of the of the iPhone button
and if one little example here it's a
little bit more more sophisticated if
you have a button of course you want to
install a click listener well it's
called a click listener in Android so a
click listener basically allows you to
install a callback whenever the user
presses the button then the application
will be notified via this callback and
there is a method called set on click
listener and you pass it an interface
reference called on click listener and
what we do in our implementation now of
course the UI button has something
equivalent there's actually a method
called add target and that serves
conceptually the same purpose as the set
on click listener on the Android side
now of course there is a different
there's a different way of defining this
delegate and on the cocoa touch site
there's something called UI control
delegate so basically what we do here is
we instantiate an anonymous class we
overwrite the raise event and then
inside the implementation of raise event
we basically send the click event back
to on the Android side so what happens
is if your Android application is using
an Android button if we cross compiled
it over to the iPhone what you have on
your native iPhone application is
actually the UI button as given to you
by the cocoa touch library if you push
that UI button on the iPhone what will
happen is it will call a race event of
that UI button that race event is then
forwarding that to the reference the
listener on click which basically is the
is the callback into your Android
application that when you only push the
iPhone button it what will happen is
here now that you will actually end up
calling the the callback in
your Android application now remember
all of that is being trust compiled over
to objective-c so also this little piece
of code here will be cross compiled over
to to Objective C okay second example in
Android there's this infamous era class
and the way you reference resources in
in Android is VR this our class so if
you have for example external image if
you have a PNG fire the way you
reference it is by by making use of this
our class now Android will automatically
create this our class for you so what I
have on the top here is you what you
will see is a little bit of that
generated code that Android generates
for you so imagine if you have an image
resource a fire called ball dot PNG then
what and what is going to do it is going
to create a member a field of static
final class called drawable that itself
is nested inside of a public final class
called our the our class I just
mentioned and it will assign it some
kind of unique ID that ideally you will
not see but when in your android
application when you actually reference
that the way you do that is so if for
example if you want if you have an image
view and you want to actually load it
with that ball or PNG what you do in
Android is basically you say set image
resource and then you just simply
reference this field of this public
static final class by saying our
drawable dot ball and you can see it's
exactly a r dot drawable dot ball so so
far so good that's the way the end ROI
people have decided to design the api to
reference external resources now how do
we deal with that during cross
compilation because when you think about
it this method here set image resource
actually it takes an integer so at the
runtime in our compatibility library
what we will see is we will see this
awkward hex number here so how do we
actually map this back now to a file
called Baldor PNG
well what we do is we make use of Java
reflection and on the bottom of this
slide here I show you a little bit of
code snippet that also comes out of our
Android compatible library and basically
what happens here is here that you can
see that we first of all we're asking
for a class object of this our dot draw
so this dollar sign here is just the
internal way for Java to represent
nested classes on byte code level so so
our dot is the way you you reference the
the nested drawable class on byte code
level but first thing we do is we just
retrieve the class object then we're
using Java reflection to get back all
the declared fields which is basically
an array of field and this API comes
from j2se so that's there's nothing
magic that is just standard Java stuff
and then you can iterate over the all
the fields and then we can retrieve the
name and we can retrieve the the integer
is associated so in particular if we do
this little for loop here eventually we
will see for the ID we will see this X
number here and for field name we will
see ball as a string and from that we
can use then the string to create a file
name and then to actually load the image
resource so we resolve that that those
resources at runtime by making use of
Java reflection now once again this
piece of code on the bottom here is also
cross compiled over to Objective C so
this was a give you a bit of an idea
that our cross compile is actually
fairly powerful in in the way that it
can deal with this kind of Java
reflection third example Android has
layout managers so Android I mentioned
before that Android is actually very
well equipped to deal with different
types of devices and and one nice
feature about Android is that they have
a way to describe user interfaces by
declarative definitions so there are
some XML files that that basically
describe user interface and on the
bottom here I've
listed one of those XML files so that is
basically the the the schema of that XML
file on the bottom is defined by the
Android team and what you see here is
linear layout is one of the many layout
managers that you have in Android and
basically it just defines a vertical
arrangement of different interface
elements and what you can see here is
linear layout is just it has an edit
text it has a textview
it has a button and then another linear
layout that has simply is a wrapper
around a little little logo and here the
screenshot on on the right you can
actually see what it would look like in
the preview of of Eclipse now Android is
open-source Android has an
implementation as Java code that take
this XML file and basically parses this
XML file and it will render this user
interface so what we have done now is
since we are an open source project why
not simply leverage on the open source
so actually we take the original Android
source code of the layout implementation
the app engine implementation we also
simply cross compile it over to
objective-c so at runtime on the iPhone
we also copy these layout files over to
the iPhone so what happens at runtime on
the iPhone that we read in this XML file
and based on this declarative
description of user interface we
actually then start building up the the
UI so here again we we make use of open
source and you can also get a sense of
you know what is all contained in our
Android compatibility library so it's
partially things we have to implement
ourselves like the parsing of the our
class or the the wrapper for the year
for the widgets like button but we also
leverage the Android source code in in
the sense of bits and pieces that are
device independent so if you download
xmlvm there is a little application that
we have done now we are tool developers
we are not game developer so don't
expect too much of that application it's
a little application called sokoban is
actually the gaming ideas is fairly old
you have to it's a little strategy game
where you have to push well in this case
apples to to target areas and so the
little guy in the middle has to push
these apples to the white outline target
areas and the way we have done this game
is by implementing it in Android so we
implemented in Java and it's only making
use of Android API so the screen shot in
the lower right is a simply a screenshot
of that original native Android version
that we have implemented for this
dokubÃ³n game now when we cross compile
that to the iPhone it looks then like on
the screenshot on the lower left side
now I mentioned before that Android is
actually very well equipped with dealing
and different device capabilities so
actually the way we have written this
Sokoban game is that we actually look at
what is the screen resolution on the
device now on the iPhone at least so far
it only has a certain resolution of 480
x 320 but the Nexus One for example on
the Android side has a higher resolution
so actually our implementation of zoko
bond renders nicely even on high
resolution screen so this application
has been pushed out to the App Store
Apple App Store and also the Android
Market so if you have if you have an
Android phone if you have a Nexus One or
if you have an iPhone you can actually
go to your respective markets and you
can look for a zoca bond you can
actually download the application now I
should make one little disclaimer here
because the screenshot is not exactly
accurate and if you actually do download
the application you will notice that's a
little bit different from this
screenshot here and and the difference
is this little guy here in the in the
middle the Android you know initially we
thought it's kind of like a little
inside deck you know like Android
pushing efforts you know but Apple
didn't like that so actually I had an
apt
reviewer called me and he said he said
well the ho shall not have
gods besides me well he didn't say that
literally but what he basically said is
that don't allow any competing they
don't allow references to competing
products so we had to replace the
android logo with something else so we
so so now we have the version you can
actually download now is now we're using
the Linux penguin instead and I guess
for Apple that is not really a threat so
they have they have accepted the the
taxes as the guy okay that's going to be
the last analogy between Apple and the
verdict and I'm going to make here so to
give you an example of a lot much more
complicated and much more elaborate
application so we have been working with
an Australian company called funky
mobile games and this company
specializes on games from mobile
platforms and they have created a
version of a game strategy for Android
so basically they have a fairly
elaborate implementation of this game
for for Android and they have used our
tool xmlvm to cross compile their
implementation of Legion over to to the
iPhone now this application is making
use of quite a few Android features so
they have like they're making heavy use
of activity lifecycle they have sound
they have animation they have custom
dialogues they use a lot of declarative
layouts for the UI and also use file i/o
for the serialization of the game state
they also have a fairly sophisticated AI
engine so they actually there's a
three-time world champion off of this
game strategic certainer who implemented
this AI engine so what I want to do now
is actually I want to do another demo
and I want to actually show you this
game of of legions side-by-sides in both
the end one
and also then the cross-compiled version
for the iphone so let me first so what
i'm what i'm launching here now is the
android version and i can turn up the
sound just for a second here I don't
know if the microphone picks it up but
actually they have put a lot of effort
into this game so they have hired a
composer for the music they have hired
the design artist for the graphics so
let me let me just turn off the the
sound here so let me now launch the the
the iPhone version and here I'm an Xcode
so actually here I have loaded the
cross-compiled objective-c source code
and I'm just launching the same
application now in the iPhone emulator
well it's a lot louder and you can see
that's already like you know it we're
mapping the the sound API here so let me
just turn down the or also turn it off
here to show you that you can do the
same thing
so the first little thing that I want to
point out if you actually look a
side-by-side difference of the
screenshot on the Android version you
have this exit button here which we
don't have on the iPhone version Apple
does not permit exiting of an
application on the iPhone other than
pushing on the home button
so actually we offer a way to the
Android developer to find out if your
application is running under Android or
the iPhone and depending on which
platform you run you can actually then
do things differently so the Android
version is actually also adding this
exit button which you cannot do on well
you could do it on the iPhone but Apple
would not pass that through their app
review so there's like a help screen
here so if you click on help then you
have like some some little help text
here you can go back to the main menu
let me just do that here on the on the
iPhone go back let me start a new game
so here I actually I don't know the the
rules of this game I know that you have
to place these elements here so you have
to pick like little soldiers have to
place them on the game board that's like
the first step of setting up the the
board but what you can also do is there
is a feature called autofill where you
can just simply pick your random set up
here's a little toast that that says
that you can go back you can say start
game it Scrolls down the game field and
now we can start the game or you can
play the game you just do the same thing
here on the iPhone so again you know I
have like this hovering pieces with the
zoom feature I can place them manually
if I want to I can also pick the the
auto fill feature I can go back I can
say star game again its Scrolls down
here now I can I can play it by by
making moves and again I'm not I don't
really know how to play this game so
I'll just do something here
I just got killed
and then the III is thinking it's doing
its counter move and let me make
something similar here on the on this
side so let me also pick maybe it's here
so it does animation it Scrolls over
here again I got killed and then let me
just surrender here because if you don't
know how to play this game so you want
to surrender us a custom dialogue yes
and then lose it will tell you it will
actually open up all the fields you can
actually uncover it and see what what
you were playing against we do the same
thing here on the iPhone surrender yes
and then you see the same thing here
so basically the apart from this one
little thing with the exit button
everything else is 100% pure Android one
percent pure Java all across compiled to
objective-c
all met from Android API over to to the
iPhone so going back to my presentation
of course the question is then then how
far can you push this so I really
mentioned a few times now that Android
certainly is very well equipped with
dealing with device heterogeneity but
what kind of applications can you
actually cross compile well games are
certainly good candidates because games
are not bound by user interface
guidelines you know like you have like
your image buttons and you have these
custom dialogues and apart from this
exit button actually you can pretty much
do whatever you want now if you have an
application that is more based on
widgets if you have a more business type
application and of course things get a
little bit more difficult and the reason
is that of course every handset every
smartphone has their own proprietary set
of of widgets so basically if if you ask
me so so what what you do in that case
well if you look at the
model-view-controller paradigm so the
way you should be designing your
application what we can always
cross-compile is the
and we probably can also cross compiling
a fair amount of the controller now the
view you might want to do a custom
reimplementation based on on the on a
particular smartphone I mean the iPhone
is known for its very fancy widgets so
there is no point in trying to mimic an
Android GUI on the iPhone so probably a
reasonable approach would be to actually
then reimplementation of your
application but making use of of the
smartphone specific widgets in that case
iPhone now of course I mentioned before
as I mentioned before we have a Java
abstraction around the iPhone now so
which means that even though you may
have to re-implement
the the view or the iPhone but at least
you can do so based in Java and one
thing we're currently exploring is to to
mix iPhone and Android so if you do a
custom implementation of a view for the
iPhone that basically you can do you can
use an iPhone widget but embedded into
the android framework so you can take
for example like like a like a picker UI
picker of the iPhone and you can make
use of it using a linear layout from
Android so that it should be quite
possible and that's where we kind of
going to as a next step so here's a
quick overview of a complete xmlvm tool
chain and a lots of little boxes here
xmlvm as a research project began in the
early 2000s and we have many other use
cases that we can do well xmlvm already
mentioned xmlvm as a name is derived
from the fact that we are that we have
an XML representation of bytecode and
we're making use of XML technologies for
doing cross compilation so actually we
do have a front end for for dotnet we
have a front end for Ruby bytecode and
we have also have backends for four
different languages now all these
different paths you can take through
this tool chain of different maturity
now obviously the smartphone portion is
what attracts attention now to xmlvm so
that is the one that we are putting a
lot of effort in right now and it is the
most stable so what I've shown you so
far
now is basically this year so we go from
from Java class files down to Objective
C so that is what I've shown you so far
then we can also go down to JavaScript
for for the pine prey but we can also do
different things so we can do something
like for example we can go from net and
we can also go down to JavaScript so it
would be possible for example to write a
c-sharp application and cross cross
compile it over to JavaScript or we can
also map dotnet bytecode to to Java
bytecode again the various paths through
this tool chain of different maturities
so in some cases like this one in
particular I just highlighted on this
slide is more like a proof-of-concept
but at least it's in the code repository
and I guess you get the idea of whether
you're the product at its name from when
I come to my last slide and basically
you know what I've told you about in the
past hour is well we first have added a
job or layer on top of the iPhone and
then we have created our own Android
compatibly library to be able to cross
compile Android applications over to the
iPhone and I guess the benefits go
without saying well first of all we
support the skill set of people I mean a
lot of Java programmers out there and
you can tap into their skill set Android
has a big momentum so obviously you know
supporting Android developers and the
only API that you have to know is
Android so we deal with all the device
specific details like like iPhone and
Palm Pre so overall it reduces the
development cost and it reduces the time
to market well since there's quite a bit
of interest and on xmlvm at least a
smartphone portion we are in the process
of building up commercial support for
xmlvm and well what we what we plan to
offer is a broad range of our different
services around mobile applications
because we have noticed that quite a few
companies are in this kind of situation
where they I want to be
present in in this app space but they
realized that they first of all lacking
the knowledge of the various platforms
but also they realize the amount of
effort they have to put in on targeting
different devices so kind of to fill
that that niche that is where we are in
the process of building up commercial
support well that comes to the end of my
presentation I would like to thank you
for your attention and if you have any
questions then I'd be happy to answer
them I got a question here on VC what is
the support for things like OpenGL and
things like compasses and some of the
other hardware that's in android but
hasn't been in the iPhones and least
until recently okay so so OpenGL you you
were asking about OpenGL so OpenGL we
actually do map there there was one one
guy who who mapped the OpenGL API so
that's taken care of the compass API we
don't have yet now I mentioned before
that Android actually is targeting
different kinds of devices so actually
Android allows you to explore the
capabilities of a device so if you write
a good Android application it should
cope with that situation where your
application runs on a device that may
not have all the features you need how
you react to it that is up to you you
may say well sorry but I need I really
need a compass and I you don't have one
on your device so I cannot run but we
can certainly cross compile that over to
the iPhone there's another question the
choice to use XSLT for the code
generation can you talk a little bit
about that I mean it's it's a cute idea
but is it more than that I mean how
would that compare to like an ad hoc
just parsing the the Xcode well so the
question is bit more details about the
other style sheets we use and well like
I mentioned the the product xmlvm itself
came from the fact that that I was
trying to find ways of doing bike or
manipulate
through XML technology so earlier I
talked about Nets actually we do data
flow analysis using style sheets maybe
this may be pushing a little bit too
hard on the stylesheet site but I guess
what what attracts me for style sheet is
just a declarative way of expressing
code generation so so basically the
little template I've shown you earlier
for describing the at int you know it's
like like a very clean and very nice
easy way to express know what should
happen when you come across and I at an
instruction on your byte code now of
course you can implement in different
ways right I mean there is no question
that you can also just implemented in
Java for example and that will more
efficient than if you do it in style
sheets but remember the the style sheet
running the starch it happens at compile
time not at run time so the inefficiency
that we might have and in slightly
normal compilation times refers to
compile time not to run time the code is
to efficiently generate is it I didn't
do I mean we don't have any other
reference implementation so I couldn't
really tell you you know how we compare
in terms of benchmark yes it is slower
but by how much I cannot tell you the
game you showed the full game so I'm
assuming it didn't like cross-compiled
out-of-the-box how much work was needed
to to change the original game that they
wrote for Android to actually pass the
well so your question was how much
working we have to put in to cross
compile this legions game or and how
much changes were required in the
legions game itself well first of all we
had to put in quite a bit of effort to
make to push XML to this to the point
that it could cross but otherwise the
guys in Australia hadn't had not to make
any changes to their application that is
just the exit like we just we just no
exit button get rid of that I mean what
of course yeah well that I mean I when I
saw that you know I told them okay guys
you know you cannot we cannot cross
compile in an exit button FL won't allow
that so we introduced certain API we
told them about it but to my
recollection that was really the only
thing that they had to change to to make
it work under xmlvm
everything else they were using from
sounded API to a lifecycle to to all the
layout managers we took exactly as this
without requiring any kind of changes
they didn't need to tweak it no they did
not have to tweak it know what time for
for dances do you have for a debugging
support a debugging support this is a
good thing because the the code that we
generate of course looks ugly right I
mean if I can I can just go back here to
Xcode and I can just simply click on on
one of the cross-compiled classes you
know if you look at this year that that
looks ugly right so so our philosophy is
that objective-c is kind of like the
assembly language of smartphone
development right I mean ideally you
don't really want to deal with it but
you are quite right when it comes to
debugging that is a bit of a problem
because you cannot really correlate that
back to the original Java source code
now if you have a working end road
application and it crashes on the iPhone
then the solution is simple there's a
buck in xmlvm so you know I would
suggest and just post a buck report on
xmlvm and we will fix it now you the
debugging happens on the Android write
an Android gives you all the powerful
debugging tools so if the iPhone version
then behaves differently or door crashes
even that just indicates a buck in our
tool chain but basically we take care of
that and and your
shielded from that so the good news is
the debugging again we leverage the the
Android SDK the other question I had is
what how do you deal with how do you let
the developer know when they're using a
feature that's not really supported on
iPhone so for example I Android like
there's a text-to-speech library that
you can call from the api's which my
understanding is that API isn't quite
available yet all I film you would
notice during cross compilation because
it would be linking hours you know you
would try to link again sometimes not
present okay great so we don't have like
an explicit list API list where you can
look up and see which API we have curve
we should do that I do agree but at this
point if something is missing something
we do not support yet you would find out
when you link because then then you have
unresolved externals okay call Thanks
you mentioned support for the Palm Pre
the Android and the iPhone is there any
support for the BlackBerry well of
course we get a lot of requests
there's requests from for Windows Mobile
there's requests for for blackberry at
this point xmlvm does not support these
as backends but I think you know it we
are in pretty good shape off very
quickly targeting also these these
platforms so the way we go about it is
you know like if we have a client who is
interested in a certain feature then we
certainly put that I on the to-do list
but at this point our main focus is the
iPhone second focus in spine pray and
beyond that we just you know that
customers decide on what they want
Android has a sequel Lite database I
believe does the cross compiling also
support okay the question is sequel Lite
we don't have an API wrapper for that at
the moment but to my knowledge the
iPhone also has a sequel like database
that you can also access so what would
just be it would be possible yes again
the thing is remember that we don't have
to re-implement features right I mean
when you talk about kompis when you talk
about an accelerometer when you talk
about different features usually all
these devices have this capability so
also the sequel my database is present
on all these devices it's just creating
these wrappers so actually making this
mapping is not as complicated as it may
sound so we can very quickly if there is
a demand for a certain feature we can
fill this gap if it's not present at the
moment in xmlvm android also has the up
the OS itself I think the framework or I
guess it provides ways to communicate
between applications like you could
register with the phone to be a media
player and that's not possible
yeah well okay of course you know if
Android has this notion of activities
and you can also call an activity from
another application
so for example if you want to select one
of your contacts you can call the
subjectivity from another application
now the way we plan to address that and
we haven't done it for contacts but we
have done it actually for web views we
have implemented an activity that is
will be linked to your application so
that it looks like on the iPhone you're
switching over to another application
but in fact you're still within the same
application you have launched so I think
in many cases we can we can deal with
that
so we actually we do not do multitasking
which is not allowed on on on the iPhone
anyways but we plan to implement special
purpose activities they kind of mimic
what you have on under your kind of
launch the dialer from you linked with
the dialer and when I click on a button
on my app it'll actually show the dialer
window that you linked with yes and then
the special purpose activity then will
mimic whatever you see on the Android
but it will also of course make use of
it will make use of of iPhone specific
features any other questions well if not
then again thank you for coming today
and thanks for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>