<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Go In Your Browser | Coder Coacher - Coaching Coders</title><meta content="Go In Your Browser - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Go In Your Browser</b></h2><h5 class="post__date">2017-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/h4qnM8ThNDM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">[MUSIC PLAYING]

ALEXANDER DORING:
Hello, everybody.
My name is Alexander Doring.
Like I said before.
I work at Smallpdf.com.
This is a startup
here in Zurich.
And I want to tell
you how you can
run Go code in your browser.
Might sound a little bit
strange in the beginning.
Hopefully it doesn't sound
so strange after my talk.
We will see.

In general, I will cover
two different ideas--
GopherJS, which works
right now and which
I will go a little bit more
in detail with examples,
and WebAssembly, which lies
a little bit in the future,
but hopefully in
the near future.

So what is GopherJS?
The basic idea is pretty simple.
You transpile your Go
source code to JavaScript.
And this JavaScript [INAUDIBLE]
can then run in your browser
as much as you want to.
It has almost 100% support
of the standard library.
There are some small exceptions,
but most of the time most
of your libraries
will just work.
You can just compile them to
JavaScript and they will run.
Go can interact with the DOM,
JavaScript can call Go code,
and Go code can call JavaScript.
So you have interoperability.
So this sounds pretty nice.
It was started by Richard
Musiol, neelance on GitHub,
and we will come to
him later a little bit.
But of course it's an
Open Source project.
Everybody can contribute,
and a lot of people have.
So how would you do that?
Basically instead of
gobuild your Go code,
you can GopherJS
build your Go code.
Then you're just transpile it.
The output is JavaScript file.
You can also serve
your code locally,
so this is especially
nice for developing.
It's even with hot reloading,
just with GopherJS serve.

Let's maybe start with
a really simple example.
I have here an HTML page
with a button, a display,
and a JavaScript source.
This example1.JS will be the
transpiled output of my Go
program, and I will run it
like this in the browser.

Let's look at some
very simple Go code.
We will use a library to
interact with the DOM.
We will get the document.
We will get the clickme and
display by GetElementByID.
But already we have a somewhat
interesting thing here.
We cast it to a type.
This means you can write
a front end code with type
safety in mind, with types.
Then to the button we add
a simple EventListener.
And if we click this,
we display hello world.
The interesting
part is because we
can transpile the
code to JavaScript,
and it's an HTML page.
And the Go Present tool, what
I'm showing you right now,
is an HTML.
This means basically I've
included the example1.HTML
as an iframe in
this presentation.
And I can show you
where code live.
So we have the button
here, clickme button.
We can click it, and
we see hello world.

OK, but this is very simple
and maybe a little bit boring.
Let's do something
more interesting.

For the second example,
keep everything the same,
but change the code
in EventListener.
Instead of just
setting some text,
lets actually spin
up some goroutines.
Yeah, you heard me right.
We are going to run
goroutines in JavaScript.
So we spin up five
goroutines, we
sleep for a random amount, up to
five seconds in each goroutine.
And then we get the text of
the display, append our number,
and set the text of the display.
Let's ignore for now the
slight data rise in there.
You might have noticed it.
Before getting the text and
setting the text, in theory,
something could
happen in between.
But let's look at
this simple example.

Same as before, we
have code in an iframe.
I can hit clickme again.
We need to write a random amount
of time and some random numbers
up here.
This time we can
even do it again.

OK.
This tells you a little
bit already that really I
was not lying when I
said in the beginning
that most of the standard
library is included.
Literally 99% of all
tests work, and you
can use all of the nice
things of Go we are used to.
You can use goroutines,
you can use channels,
you get your type size--
really everything just works.

I need to get out of that.

OK.
The next question is
this is all very nice,
but why the heck
would you actually
want to do something like this?
OK, it is a little bit crazy,
but let me try to convince you.
The first thing I imagine
most of the people like me--
I'm a little bit more back
end developers compared
to front end developers.
So for me, if I were to
write a simple [INAUDIBLE],,
and I don't want to
write front end for it
with React or
Angular or something,
maybe I can do something
really quick with Go.
I mentioned before that I
get my nice type safety.
But This is quite
nice, but for me
not the main reason
why you would
want to do stuff like this.
For me the main reason
is the second point.
This means replace
processing in the cloud
with processing in the browser.
This means instead of
the user uploads a file,
we do processing in the
server and the user downloads
file, which takes some time
and takes the company quite
some costs for servers.
Imagine a future if
all of this processing
can happen on the
computer of the user.
This means for the company, I
don't pay for my server cost
anymore.
For the user means,
depending on the file size,
it might actually be faster
because you don't need
to upload and download a file.
And for the user this also
means this is way better
for my privacy
because I don't need
to send my data to the cloud
to do something on this.
The data in the best case
never leaves my computer.
And the really
nice thing for me,
of us as back end developers,
all the pure Go libraries
that you are using in
your back end today
you can use in the front end.
So if you have currently
a processing library in Go
that runs on your server,
I bet you can just
compile this library without
any alterations at all
and run this library
in the browser.

To do the front end part, I
mean, as front end developer,
I would say they love to use
frameworks for everything.
And there are a
ton of frameworks
and a ton of
different frameworks.
But GopherJS has you covered.
There are bindings
for Angular, there
are multiple bindings
for React, there are even
other bindings for
Vue or whatever
is the current hip framework.
There are even bindings for
Electron if you want to.
And GopherJS itself also has
a really small framework,
a small React-like
framework called Vecty.
And I will give
you a small example
of how to use this as well.

The HTML file of our next
example got even simpler.
We don't have any divs anymore.
We just include the JavaScript
file, same as before.
This is the transpiled
output of the Go file
I will show you later.

We have package main.
We have some includes.
And in the function
main, all we do is we
tell Vecty, render a HTML body.
And the HTML body is
a custom component
that I have declared here.
It's a page is simply a struct.
We embed a Vecty call as one
part to make it a component.
And then I just declared
a text string there.
The Vecty call is the
first part to make it work,
but the other part is we need
to tell Vecty how the hell
should you render
this type page.
And we do that with
render function.

The output of this
is Vecty HTML,
and I guess, at least for me,
this has quite a React feel.
Basically you will
return a component.
What we're returning
here is a body.
We can even style it in Vecty.
So for example, here we set
the font size to 20 points.
Of course, for a
lot of projects you
can also do your CSS
in an external file
and then just use it like
you're normally used to it.
This is not problem at all, but
you can also do it with Vecty.
Then we have an input
element with markup.
The markup is one event handler.
I will come to that later.
So we have an input element,
a line break, and then a text
element.
And the text
element we basically
print the content of our
member variable text.
So what we expect is an
input field and a text field
that we use as output field.
Let's look at the EventListener
now a little bit more.

We get that text
of the input field
and then we double this text
with an empty space in between.
But this means we only store
the text in the private member
variable.
We don't do anything
yet with it.
And if the magic happens
later, Vecty rerender
will tell Vecty to
rerender the page.
And Vecty, actually similar
to React, uses a virtual DOM.
So it is smart enough
to only rerender
those parts of the page
that have actually changed.
And the parts that will
actually change then
is, of course, the
text and the display.

Same as before, I have the
HTML included in the iframe.
Let's write some text.

So you can write quite
some interactive stuff.

So those are, well,
some simple examples.
I have not tried the bindings
for React or Angular myself,
but if you are more
front end developer
and are used to
those frameworks,
GopherJS also has you covered.

One interesting thing
about GopherJS--
size matters.
On the server, we don't care
if a Go binary is 1 megabyte,
or 5 megabyte, or 20 megabyte.
But if your user has to
download this JavaScript,
it matters quite a bit.
So there's a couple of
things you should do
and a couple of things you
shouldn't do to help you
in this regard a little bit.
The first thing-- for
production you should always
minify your builds similar
like you do in the front end
as well.
This is very easy with GopherJS.
It's just GopherJS build -m.
Then of course you
should also gzip this box
depending on what you're using.
I mean, this is
basically automatically.
We are talking here about
a site without a server.
So this is static HTML
and static JavaScript
that you can put on AWS S3.
You put CloudFront
in front of it,
and this will automatically
gzip your resources,
and you have an infinite
scalable interactive website.
You pay for it to
Amazon, but you don't
have to care about servers.
And you can get rid of
a lot of complexity.
One very interesting
thing is even
in the Go standard
library, there
are some packages that
re larger than others.
A particular pain point
here is the fmt package.

This is way too large, so
if you do a small project
and include that, your
code size can grow
by a megabyte or something.
So you shouldn't do that.
There are multiple alternatives.
Sometimes you can do things
with strings or other functions,
but there are also
third-party fmt packages that
are written with size in mind.
So you shouldn't
use the fmt package
of the Go standard library.
Another thing that you probably
shouldn't use is Net::HTTP.
Especially we are running
our code in the browser,
so we don't care
about all the server
parts of the HTTP package.
So this is just a lot
of unnecessary code.
And most of the time we are only
carrying about AJAX requests,
and we can do this with
a different package.
But other than that,
you have seen now
this is actually stuff
that works right now.
You can actually
already do that.

I have a written a
fourth example that's
a little bit more complex.
I've even put it on a new
domain, resizerly.com.
Basically it's a site that
resizes images in your browser
and without uploading it to
the cloud and everything.
And yeah, it is, like
I said before, it's
a static site on S3 with
a CloudFront in front.
So let's take a look at this.

[INAUDIBLE]
Basically I have
a steady website
and it's says drag
and drop an image.
So let's drag and drop
a gopher on there.

Well, so you can see I can
interact with the JavaScript
functions.
Now I have the gopher in there.
I can resize the thing.
And notice that the size of
the image dynamically updates.
Let's make this gopher
a little bit larger.
Let's make it 200%.
And then I have an
almost fake button--
Resize and Download.
The download actually
doesn't happen,
but explain this to a user.
I don't know.
[LAUGHTER]
So let's click on here.
And now I have a resized gopher
here, a way larger gopher.

So you can see this
actually works.
For this particular example
the minified but unzipped
JavaScript is a little
bit over 1 megabyte,
and gzip 1 is a little
bit under a megabyte.
Of course this is
on the higher side,
that I would like that
this would be smaller.
But instead of
uploading an image,
processing it, and
downloading an image,
this might still be faster.
And to be fair, some
or most websites--
1 megabyte isn't
even that much today.

OK.
So this is the technology
that works today.
Let's talk about the
technology that also
works today but doesn't
work with Go today,
and this technology
is WebAssembly.
It's low-level
byte code and stack
machine run in your browser.
It's influenced,
and I would even
say it's the successor of,
asm.js and Google's Portable
Native Client.
It's supported by
all major browsers.
Safari was the last
one in the summer.
So this is really
platform-independent and
browser-independent code.
And this is really bytecode
that runs in your browser.
And by default, since inception
it was always a compilation
target for C and C++.
So you write your C++ code
and compile it to WebAssembly.
As a side note, Rust announced
preliminary support for this,
I think last week.
So the race is on, so to
speak, because honestly I
think this has huge
potential in the future.
Imagine what I told
you about, what you
can do with GopherJS already.
And now imagine you wouldn't
need to pass a huge JavaScript
file in doing that.
So WebAssembly might be a
huge improvement over that.
One part that is a
little bit lacking yet
is the interacting with DOM.
So currently it would be like
you write a function that you
compile to WebAssembly, a
and you export this function,
and you have your
separate JavaScript
code that imports this.
But honestly, this would
even be the same way
of how I would write a larger
project with GopherJS--
you write Go code that
does the processing,
you export a single function,
and then you can write
your front end code with React,
or Angular, with Webpack--
with all tools the front
end developers are used to--
and then you import
the single function.

So let's talk a little bit
about Go and WebAssembly.
So we have this issue 18892.
This was opened in
February this year.
Hey guys, WebAssembly
is a thing.
Maybe Go should have
something to do with it.

As you can see from the thumbs
up, everybody liked the idea,
but it turned out
pretty quickly,
like, we have no idea how to
implement that yet or implement
that immediately.
And after a little
bit of discussion
after a couple of
weeks, the sentiment
was, is this even possible,
or would WebAssembly
need to change that Go can
use this as a compile target?
Because WebAssembly
is a little bit
different than other
things, but I don't
want to go too much in detail.

This issue then lingered
around for quite some while,
but three days ago--
so I intended to give my
talk mainly about GopherJS
and then only dropped two
sentences about WebAssembly.
But literally three
days ago neelance--
you might remember this guy.
This is the creator of GopherJS.
He said he has started working
on this, building this.
And he is very
optimistic, I would say.
He worked on it over a month and
a half only in his spare time.
And he even says this
might land in Go 111.
So what I said
before, this might
be the future of how you could
run code in the browser, that
actually might be in the near
future that happens maybe
next year.

So neelance has a
fork of Go on GitHub.
You can contribute, you can
look what the current processes.
Currently working
already is running
the generated code in
browsers and Node.js.
If you want to do this
particular [INAUDIBLE]----
I don't know if
you would want to.
You have Go code, you compile
it to bytecode to run it
with node.js on your server.
But if you want to, you could.
[LAUGHTER]

The basic operations
already work--
conversions, et cetera.
Interfaces already work and
goroutines and channels already
work.

Stuff that doesn't
work already--
reflections, growing
the stack of goroutines,
garbage collection is an
issue, and of course there
are a lot of optimizations
to do and probably
a lot of other small things.

But let's recap a little bit.
To run Go code in your browser--
of course it's early days still.
I would admit that.
But I really see huge
potential for some applications
for this in the future.
GopherJS it's working
right now, WebAssembly
is going to work soonish,
maybe/probably already
next year.
So I've given you the link
here, so experiment with it,
contribute to it if you want to.
It's Open Source.
And I will give you the
slides in the Meetup comment.
And I also have prepared
a slide for hiring.
[LAUGHTER]
So like I said before,
Smallpdf is hiring.
This is only a side project,
so we don't use that at work.
But I am somewhat
hopeful, if you're
interested in joining
Smallpdf, maybe
you can even work on something
similar in the near future,
because for us this
would be quite nice.
So thank you for your attention.
[APPLAUSE]

Any questions?
SPEAKER 1: I couldn't
hear the topic of channels
working in the browser?
ALEXANDER DORING: Yeah.
SPEAKER 1: [INAUDIBLE]
concurrency [INAUDIBLE]
ALEXANDER DORING: Basically
of course a JavaScript
doesn't run in parallel.
So you still run
only in one thread.
And basically but
parallelism is something
different than concurrency.
So what happens is
this once thread
will schedule multiple Go
channels one after another.
And you have a similar thing as
if you have way more goroutines
than you have cores.
Then you can see this computer
with only one single core,
and then everything has to
run one after the other.
SPEAKER 1: How cooperative
does that have to be.
For example, if I launch
a goroutine [INAUDIBLE]
ALEXANDER DORING: Actually,
this is a problem.
But Go has a runtime Go schedule
method, where you can literally
say I'm running in
this tight loop,
but I want to give Go a
chance to run something else.

I mean, Go has had some similar
problems if you run really,
really tight loops in the server
that even this could happen.
But of course with
JavaScript and GopherJS,
you have to be way
more careful with it.
Other questions?
OK, then talk to me later.
[MUSIC PLAYING]
</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>