<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Anatomy Of A Debian Package | Coder Coacher - Coaching Coders</title><meta content="Anatomy Of A Debian Package - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Anatomy Of A Debian Package</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/82mEKd993PA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so this is jonathan ox's talk on
anatomy of a debian package specifically
we've asked him to talk about how you
born to packaging works john is the
president of linux australia which is a
linux advocacy group in in australia
obviously and he's one of the three
authors of people into hacks from
O'Reilly apart from that is an
all-around good guy and from some crazy
other country so anyway here's John okay
what I'm going to talk about is Debian
packages and I'm going to look at use
debian basically because that is the
basis for a bun tune but essentially
it's the same thing the tools are all
the same the package formats are the
same it's it's all very much the same
thing so we're going to cover binary
packages I'm gonna make a couple of
assumptions here as well how many people
here assisted means I assume there are a
few so I'm assuming that most of you are
quite familiar with RPM yep you play
around with a little bit how many people
have played around with Debian packages
already okay few of you ok so I'm
preaching to the converted what I'm
going to do is talk about structure of a
binary package source packages how you
convert a source package into a binary
package and also a little bit about
what's happening with some changes that
are going on right now with the format
of the Debian package itself with the 2
point 0 format so basically a dip is
just an archive that contains several
items model do is these slides are going
to be available for you to grab but
they're really just sort of reference
what I'll do is show you most of it live
so we might as well go around and start
playing with the Debian package what
I'll do is grab
what I get grab an existing packages I
say TCP dump and have a look at it so if
you are I'll have a look at what's in it
it's really just those three elements
there's debian binary which is just a
little text file all it contains is the
version of the packaging system that's
been used to create this particular
package at the moment that's 2 point 0
which is the new package format control
dr dot gz which contains meta
information about the package so that's
things like maintainer scripts and
various other files that control how the
package has been built and we'll have a
look at those in a second and dr. G said
which is basically data for the actual
file systems that's what's going to get
sucked out and then slept on to the file
system and then other manipulation will
be done to it so an actual binary
package is very simple sort of format
and if you want to you can actually
create it just using you know regular
tools but that's pretty painful so it's
much better to use tools that are
designed for it in the early days of
course this is how all Debian packages
were created you just do you are and
things like that but there are tools
like D package which is a suite of
libraries and user space binaries that
you can use for manipulating packages
for creating packages and things like
that so instead of having to extract it
all manually we can use D package so we
did
something like this on the package you
can get a whole lot of meta information
about it in this particular case what
you'll notice is that in a little while
we're going to be looking at some of the
files that are inside the package
including the control file and what you
see here is very much what's in the
control file so it's got things like the
the section that this particular package
goes into so packages can be categorized
the priority level what architecture
this particular binary package has been
built for a number of things like that
and a description of the package itself
so d package basically provides you a
really simple interface to be able to
talk to the package or interrogate it
directly and get information from it and
also should explain the way the the
packaging tools work in debian is
they're very layered right at the bottom
level there it is the actual package
format and D package which manipulates
it directly and if you played around
with a debian or at a bun to box you're
probably done your apt get install or
something like that apt essentially is
like a wrapper for the low-level dpkg
libraries and then there are and that
act itself is actually not intended as a
user space to lure as an end user tool
that is really intended to be a
mid-level layer which is then wrapped at
a high level by things like deselect
synaptic you know all of those sorts of
user space tools that you then used to
manage the packages installed on your
system the thing is that apt is so cool
that people end up using it directly and
that's what I do all the time so when I
managing packages I normal just do it
off the command line using apt or DP d
package so
the actual control file not in the
when we had a look at what was in that
binary before the control dr. Archie is
that what it contains is a whole lot of
information about the package so the
package name itself so the file name
itself is not important the actual name
of the package isn't stored in the
metadata the actual source so there's
another thing that's interesting about
Debian packages you can build multiple
binaries from a single source you might
have well PHP is a good example within
the the original PHP source tree there
are a whole lot of modules that are
built out of it so when you have on the
end user system you might want to have
modules available as separate packages
not one monolithic PHP package that
includes everything so what happens is
you can have a single source package
which encompasses the entire PHP source
tree and then define multiple binary
targets so that when you run your build
process you end up with a package which
contains the core PHP infrastructure and
then other packages that contain all of
the supporting modules that might be
optionally installed so in the actual
binary package itself you need to be
able to figure backwards where this
package came from so the source metadata
tells you what source this particular
binary came from the Persian versioning
within Debian packages is consistent of
two parts there is obviously the
upstream version so if you've got
version 0.9 point four or something that
may not change even between debian
package releases for example you might
find that there is a security flaw and
you need to patch and rerelease a
package or you might find that there is
a problem with in the packaging itself
so you want to bump the version number
without bumping the upstream version
number because that's always important
to know where that came from so the
version of a debian package is always in
two parts as upstream version then a
hyphen and then the version of the
debian package itself
which can also be composed of multiple
parts there's typically just an integer
which increments so you might have
version 0.9 point for dash one of a
package so that'll be the first debian
package built from that particular
source version and you can also have you
can add a colon and then another version
to it i like it into that right now but
that's useful if you're doing things
like non maintainer uploads or you want
to bump the version number but you don't
want to know just as a temporary thing
but like it's back back to that later
the actual architecture the source
package might be built for a whole bunch
of different architectures in to build
farm or something like that so the
architecture for the target deployment
is important and then the really
interesting bit and this is one thing
that makes the Debian package format a
little bit different to some of the
others is all of the relationships
between the packages in the way the
dependencies are handled within the
metadata you can specify depends
recommend suggests replaces conflicts
and enhances and that defines what well
that controls what happens when you try
to install a package using a middle
level or a high level tool like apt or
synaptic or deselect what they can do is
make use of this meta information to
decide what other packages also need to
be installed so basically it gets around
the whole RPM dependency health sort of
thing which has been largely fixed up in
recent time but for a long time this was
a very big distinction between the way
Debian packages are handled in the way
Red Hat packages are handled for example
the different meanings of those I won't
go into that in great detail but do
things like conflicts is fairly obvious
basically if you name another package
that package can't possibly be installed
while this one is installed so if you
try to install it the system will go
away and uninstall that other one behind
your back but it will give you an option
generally telling you whether you to
whether to let you say whether you want
it to do that or not depends recommend
suggests just different levels and then
decisions can be made within the
management tools as to whether they're
going to be acted on or not so depends
obviously another package has to be
installed for this one to go in
recommends and suggests are just lower
levels of priority enhances is like a
reverse relationship so once again you
can see this particular package enhances
that one over there so it's basically a
backward relationship rather than a
forward relationship
yeah in this particular one you can see
it depends on lipsy six the pcap and
lube ssl but it doesn't have any other
dependencies there are also build
dependencies which we'll get to in a
moment when we start looking at the
actual source at all this came from
okay maintain your scripts
within the package itself there is the
the raw data that's going to be slept
onto the disk and then there are
maintainer scripts that are run at
various stages of the process so as you
are as DP do package for example is
extracting the package and putting it in
the right place it needs to you need to
have hooks as a package maintainer to
tell it to do certain things and the way
the Debian package is working very
flexible about that you can essentially
do arbitrary things at various stages of
the installation process i'm using prius
for example you can have a little shell
scripts it does any arbitrary thing
you've got forward privileges to the
system at that point so like any package
management system basically if you're a
computing a debian package you have full
root access to every system that your
package is installed on so Prince tis
run prior to actually extracting stuff
onto the file system general it's
recommended that pre inst and post RM
aren't used it's only unusual situations
where you absolutely have to do
something before your data is extracted
onto the file system typically you'll
use post inst and pre RM so postings dis
run once that data tar.gz at has been
extracted and it gives you the
opportunity of doing things like asking
configuration questions or that's a
deprecated way of doing it it used to be
very common to just poke configuration
questions to the screen using the post
inside say do you want to install it in
this way yes or no it was pretty typical
to have prompts at that level the
problem with that is that it makes it
very hard to build high level tools like
synaptic on top of it because you can't
pass those questions through in a
consistent way so configuration
questions at installation time now I
typically done using a script called
confit which passes questions in a very
structured manner up the system so they
can be asked using whatever interface
has been selected so you might have some
people that are running apps and it'll
simply be questions on the command line
you might have some people running in a
GD k type GUI or synaptic or something
like that and you want the interface to
match the rest of the GUI this abstracts
the actual questions and answers
from the format of the way that they're
asked so to understand that process the
actual sequence that is run through when
you install a Debian package so if
you've got a package sitting there on
this can you do dpkg minus I for install
it invokes debconf and asks any
questions that might be asked so it then
runs and those the answers to those
questions are remembered for use later
on it then runs the pre inst script and
we'll look at some of that in a moment
when we actually look inside a source
package if the actual package is
unpacked so that data dr. dodgy said is
extracted onto disk and everything is
put in the right place so at that point
it hasn't been configured but all of the
data is sitting there live on disk so it
then runs the post inst script and at
that point everything is there ready to
go so the package is fully installed now
if interrupt if installation is
interrupted partway through the process
you might get a number of errors
occurring for example if you have a
failure within the Dupree in script you
might find that the package ends up in
an unpredictable state so you won't have
data extracted onto disk necessarily so
there's a lot of cleanup that's taken
care of within the D package libraries
themselves it tries very hard basically
not to leave your system in a state
where there is a package that's half
extracted and at most ages will give you
an option of doing a clean up and it
usually asks same questions at the time
removal is just the opposite it's pretty
easy it just runs the PRP RM removed
and pulled everything off disk remote
runs postar and remove when you're
removing a package from disk there are a
couple of different options standard
removal takes the the raw data itself
such as binaries associated with the
package and removes those but it doesn't
remove configuration information it a
lot of the time configuration has been
modified by a local system administrator
you don't want it just disappearing on
you so typically those are files that
are not actually controlled by the
package they might have been edited
locally and so unless you explicitly
state that you want to remove
configuration information with a dash
dash purge option 2d package for example
it likely leave all those behind so what
you could do is apt-get install that
same package again and you'll end up
back in the exact same configuration and
the same state as you were as you were
before you did the remove when you are
creating a package it can be very useful
to explicitly state which of the which
are the files that are put on disk
configuration file so that it knows to
leave them alone some of the
configuration files will have been put
there manually and the package won't
have any idea that they exist others
will actually have been put there by the
system and if you don't tell it to treat
them differently it'll simply remove
them yes you have a question
yeah is that used during the DEF CON yes
stay tuned the install yeah exactly so
what happens is that Deb conf at that
point will prompt you for answers to
questions which could be on the command
line or it could be through a GUI the
answers to those are then stored within
the system and they're accessible within
your script so basically they said is
variables and within your pre inst or
post inst you can then access the
answers that the person has given and
then make decisions based on it so it's
a way of separating out that logic from
the script itself so you don't ask the
question at the time you asked it in
advance
so with the actual package itself you
can specify if for example you were
packaging Apache you wouldn't want to
you might put in an example HTTP com but
you don't want that just blown away when
the package is removed so you can
explicitly state which files within the
package config information and then that
won't be removed unless that purge
option is provided
so look at a source package
source package contains virtually we'll
just start playing with some live stuff
for reference this is the the actual
source pack bots inside the source
package so there's the origin which
contains all of the original source it's
important to be able to get back to the
the unmodified sauce that you can see
what the package maintainer may have
done the Debian changes which have been
applied to that particular source tree
and the metadata so this is what gets
turned into the binary package with
those three equivalent elements that we
looked at before so a source package
very similar once again probably not and
any needs to go through this right now
because it's will see it live in a
second one thing I should mention here
is the the issue of policy one of the
good things about debian is the the
policy that's applied to locations of
things on disk and it's actually quite
strict so when you are building a
package you need to make sure that
everything is installed into the right
location it's pretty common if you grab
an upstream saw star ball for example
you just do configure make make install
it often stick stuff in use a local or
you know somewhere that's typically used
for end user location if you're building
a package that's going to be installed
system wide and then you need to make
sure that binaries are installed into a
standard location which is typically
been or use of n or s beam or something
like that so one of the things that you
need to do is go through and make any
changes that are required to you know
make files so the things are put into
the correct location
now what I'll do yeah ok so the Debian
rules file is the file it controls how
the package is built
what this contains is a whole lot of
meta information this is what forms well
this is basically a make file so when
the actual file is built this is
executed and it's got a whole lot of
different targets in it now when yep
let's have a look at a real one
okay so what I've done is just grab the
source or remove their
the original Deb that was in there
so what I'll do is create a sauce
package based on this particular source
tree and I'll go through and show you
all those those files rather than go
through on the slides so first thing to
do is extract the source
and take careful note of the way it's
named it's best if the actual directory
is named the same as the version and
we'll see you the sooner moment
now what we can do if you're doing this
the hard way what you would do is create
a Debian directory which contains all of
that matter information so what we need
in there is Debian rules file which is
the make file that configures and that
controls the build process of the the
package we also need a Debian control
which contains all of the metadata
including section architecture build a
penance ease and those things we saw
earlier now you can do all of that
manually and then simply execute Debian
rules to build the binary package but
that can be really painful so there are
a whole bunch of build Suites around
that you can use Deb helper is probably
the most popular one it's been around
for quite a long time so install Deb
helper and EH make and then what we'll
do is use DHA essentially to bootstrap a
an architecture around us that we can
use to build a package so if we do d.h
make
they're a couple of flags mean process
we're just passing
the most important one the only one that
really matters is the path to the
upstream tarball is what it's going to
do now is have the litany examine the
directory we're in examine the upstream
tarball that we are pointing to and do
its best to build a all the metadata the
metaphor control files that we need to
actually build this package so it's
going to ask a couple of questions the
first thing is whether you want a single
binary target or multiple binaries as I
was mentioning before we can set this up
so that there are actually a whole lot
of separate control files or separate
sections within the control file that
determine what binary packages are going
to be built in this case we only want to
build a single binary package out of
this and you can also tell it that you
want to set it up for a library or a
kernel module or something like that so
we'll take the simple one in this
particular case it's just going to be a
single binary we haven't specified a
license type or anything like that
and what that's just done is created a
directory called Debian which has been
filled with a whole lot of example files
you'll probably find a lot of these you
won't even need but it makes a fantastic
starting point B can just go through and
change change values and what have you
need so first thing we look at is the
control file so this is the will change
the section there's a whole list in the
the Debian maintained as guide as to
what the acceptable sections are and
things like that there's a at the end of
this there's a URL for further
documentation from the Debian site it's
a whole lot of reference material that
you can use so section has to be one of
a number of predefined sections and
priority this is an optional package so
we just leave it as that there are build
depends that are set there
but it is going to happen eventually is
that the we're going to end up with a
source package and a binary package that
will build out of this people might want
to rebuild the source package but they
need to know what they need on their
system on a typical end-user system they
won't have GCC and things like that so
what you can do is put in any additional
dependencies in here that people are
going to need when they actually come to
to building the package rather than
simply using the binary package that
comes out the other end so what someone
can do if I wanted to build a packages
to app get install dash dash build dash
depends and it will examine this and
then go and grab all of the build
environment that is necessary to build
this package in this particular case
it's you see a number of placeholders
here these will be fixed up
automatically by the build helper
scripts so just take your description in
um
okay that's not much ease
and when you're putting in a description
it needs to be wrapped at 72 characters
and you also need to make sure that
there aren't any spaces the actual
format of this file is quite simple what
we see here at the first section of the
file down to the standards version is
matter information that meant that
applies to everything that is built from
this particular source package after
that where it says package TCP dump
that's where is defining the binary
package that's going to come out of this
as the end result and you can actually
have multiple sections so if this was a
if we're going to be building multiple
binaries
we could basically just define multiple
packages in here and it would come out
here to build multiple packages out of
that which means that you can't have
spaces in your package description so if
you're going to have a multi-line
package description you need to separate
it by dot and it also all has to be
indented by one character otherwise
things get rather screwy later on
the other thing that
you need to have a look at is the actual
rules file so this has been
automatically created obviously but
you'll probably need to go through here
and make some changes for a really
simple package which you can simply do
configure make make install you might
not have to touch this at all the Deb
helper suite is quite smart at setting
this up to suit the source tree that
you've extracted it in so basically go
through here and have a look at the
different build targets so we can see
here right setting some flags if you
need to pass anything to GCC for example
at build time then you can set them in
here and you'll see here the process
that it's going to go through at the
point where that binary is actually
created so there's nothing special you
need to do this is where to start
playing with it you'll also see in this
particular one because it's been built
using the Deb helper sweet there are a
whole lot of calls to these little
helper helpers to do specific things now
the idea is to make it as simple as
possible to to build a package without
tripping over ourselves and making
typical human mistakes so each of these
little helpers takes care of a
particular part of building the package
so you'll see install docks for example
is a helper which is being called and it
looks for things like a readme file in
the original source tree and it
automatically sticks it into the correct
place so each of these does some little
task and you might find that you need to
if this for example Wren
as a GUI and we needed to put a menu
item in then we could enable the install
menu option and then there is a
configuration file for that there's a
man page for each of these as well it's
really well documented so if you needed
to install a menu you would then create
a config file that specifies the
position within the menu structure that
I needs to be located the name the icon
and various things like that likewise
for all of these other options and there
are quite a few of them there are a lot
more than this as well this is just the
really common ones
and then finally it does the actual
field of the binary
so other things that you'll find within
here there is the changelog that we'll
look at in just a moment that's quite an
important file comp at which is just the
compatibility version essentially at
this Debian package so that's just a
number font files directs all of the
x-files our example files that have been
created by Deb helper and you can
basically just go through and delete
them if you don't want to use them so
punk files is the file us mentioning
earlier that specifies which files on
disk going to be configuration files
so if you had a whole lot of files are
you put into etc you might want to list
them here so that when you do a DP kg-
are they don't get pulled off disk
does specifies which directories are
going to be used because what will
happen when this package is built is it
will create a little local lab which is
like a we're going to use fake root in a
moment to build the package or build a
binary within a fake root and it uses a
list of directories here to build a
structure that it puts the files into so
if there are other directories that you
need you can list them here and it will
build them for you automatically one of
the reasons for this rather than simply
building stuff on demand is that there
are some sanity checkers this is all
geared around trying to prevent you
making mistakes so if that you use a
directory which isn't listed in here the
sanity check is at the end will tell you
emacs will ignore those in it d if this
is running as a service and you need to
start it up at boot time it's got an
example in it file which in the control
file is installed automatically will
find that pretty much all of the files
that are in this directory are put in
place using those little D H helper
snippets that we saw earlier in the
control file so if you actually do use
an init d all you need to do is rename
any dtox to init d enable the little
helper that puts it in the right place
and it will take care of it all for you
there are example man pages in there
there's the menu file so if you actually
wanted to put this in as a menu once
again that's taken care of by D H menu
and the post in stand post RM pre
instant pre RM files as a package
maintainer this is basically where
you're going to spend most of your time
just playing around in these so
there's not much in them right now but
these are there's a little shell that
you then flesh out with the specifics of
what you need to do so you might find
that to install a particular package on
desk you need to create certain
directories or you need to move things
around you can arbitrarily do anything
you like in here
mckay be able to
no you need to be sure the shell is
going to be on the end user system
because otherwise there's no way to
execute if you have some really unusual
requirement one you couldn't on a
certain she'll what you can do is put
that shelling as a pre dependence within
your package so that she'll will get
installed and then your package will be
installed afterwards but that's pretty
rare they're generally starting pearl or
bash or something like that so like most
things if you've got unusual
requirements there are ways around it
you can work the packaging system to
achieve just about any end result but
take the path to breathe least
resistance there's a readme taught
Debian file this is different to the
readme file because when you are setting
your your package up you'll probably
have to make changes that caused it to
deviate from the original source
installation structure so you can
document all of those and read my debian
and that way it makes it really easy for
people to see what changes you've made
versus what was actually intended by the
upstream maintainer default interface
and watch actually watches a really cool
little file this is a configuration file
you can use with helper tools that let
you track where the upstream has changed
their version or not so what you can do
is define in here the actual place that
you grab this you grab your sauce from
and by running a script it'll go through
all of your packages and check whether
there be new versions may not released
so if you're maintaining a whole bunch
of packages you don't want to be going
back to the original upstream every day
and checking do have a new version so
this just takes care of all of that in a
really neat little automated way
so they can tell you you have X packages
to rebuild
ok
so at this point what we could do is
simply run the Debian rules binary make
file and we should have a binary package
for the thing is that there are a lot of
things that you might want to do as a
result like when you're building it you
want to do sanity checking and things
like that you want to sign the package
for release so it's typical to use
something like dpkg build package as a
wrapper for it so instead of calling
Debian rules binary directly there are a
number of others as well like dead bill
which then just wraps dpkg bill package
so in this particular case get back out
of the Debian directory so we're just in
the sauce and directory now which hasn't
been modified at all we've got a Debian
directory which has been auto-generated
so basically I've done pretty much zero
work other than bootstrapping the source
package at this point so if we do give
energy bill package and then we'll add
we build it in a fake root in fact will
do
I don't pull it it run properly
so you can watch this and pretty much
see exactly what it's doing you can see
that it's there were some D H tests
right up near the start there where it
was going through and making sure that
those little helper scripts had the
correct configuration files and things
like that and then it's running through
the process of actually doing that the
internal configure make that you would
do if you were just doing this manually
hopefully we got no errors
I am there are some really cool helpers
as well if you are managing a package
where the sources maintained upstream in
CVS or even Archer subversion or
something like that you can use CVS bill
package what that does is manages all of
your package directly within a
repository somewhere and pulls it down
and builds it as required and it also
takes care of stripping out all of the
the things you don't want to go into the
package like if you do a a check out a
subversion for example in that we
thought svn directories everywhere so
CBS pool package recipe and build
package and take care of grabbing your
package and then building it in the
local environment in a clean way
possibly it's okay
it always asks to the passphrase twice
because it's two different files that
assign the Debian package itself is
signed using gpg and at the moment the
the chain of trust is not really that
complete at this point obviously I'm
acting as a debian maintainer so I've
got the original source the idea is that
I should be trusted to to understand
what's going on within that particular
binary I should know that there is
nothing that's been done within the
source that we don't want getting to the
end users machines so basically I'm
signing that to say yes I trust that
this package is ok that signature is
passed on as a detached file so
ultimately once this package is
published the signature can be traced
back to the original maintainer that
built it the thing is that in the case
of debian and ubuntu there are build
farms that do auto builds for multiple
architectures so what's going to happen
is that the source package that i
created in sind is going to be sent off
to the build farm and then we built on
all 14 architectures or whatever are
currently supported on debian the actual
binary that comes out of that obviously
I haven't checked I can't necessarily
trust the Builder the buildi because you
know it's got a modified GCC or
something like that or linker might have
been modified
so there are a whole lot of points along
the chain where you need to be very
careful up in terms of authenticating
the actual package to be able to say to
an end customer this package that you
have installed on your machine can be
traced in an authenticated trust path
all the way back to the original source
so there are some issues with that but
there has been a lot of work done on
that recently to include signature
support within apt for example so that
you can actually check signatures on
packages apt is now set up in both in
ubuntu and in debian in the in the
latest unstable to check archives
signatures so there are a number of
archives the packages are pulled down
from the system will check whether this
particular package has been signed and
whether it can you can trace that trust
path back so what we've got now
in the directory back above us there's a
whole bunch of extra stuff there is the
diff that was created a little while ago
when which is basically the difference
between the original source and and what
we've created there is changes file
which will which defines essentially
what has changed in this particular
release I'll show you the change the
internal change log in a second as well
once we start incrementing versions and
look at what happens when you want to
release a new version of a package
there's the actual Deb itself with the
architecture so in this particular case
you can see it's been built for i386
there is the originator jeezy and there
right at the bottom is the actual source
that we grabbed in the first place
so theoretically what i could do is dpkg
I that Deb which is now a fully built
binary package and have it installed
onto this local machine went to xiv
already installed it there are some
checks that we're going to do at this
point just to make sure that that is
okay there are a couple of automation
tools and also other build helpers I
should mention before I get to that i've
been using dpkg bill patch a bill
package but there are a whole bunch of
build helpers that you can use just
about every debian developer seems to
think that it's a cool thing to build
their own build helper so there are
actually a whole lot of them see DPS has
been very popular recently that's a
common Debian build system so now that
we've actually got a binary package
that's been built out of this source we
can use either Linton or Linda to check
the sanity of the package they what they
will do is extract that package that
we've just created into a little
self-contained lap and go through a
whole lot of policy checks to make sure
that it's not doing anything silly so if
we run Lynchian on
and you can see here in the version
number we've got dash 1 which is the
which is the Debian package version
essentially for this particular source
tree so this is going to come up with
heaps of complaints because I didn't
remove any of those example files so
it's a little bit anal about that it
makes sure that you haven't left behind
any craft that that was put there by the
helper sweet so in this particular case
it's got a whole lot of warnings which
are non fatal it's got an actual error
in there I near the bottom help it
templates in copyright and basically
that's because it created a copyright
file for me because there wasn't one
provided and I didn't specify whether it
was GPL so and it's notice there a whole
lot of placeholders that I haven't gone
in and edited so at the point where
you're editing the all the files within
that directory needs to clean that up
when the changelog down the bottom has
gotten wrong bug numbering closes I'll
show you the changelog now because
that's cool
where are we going
this changelog was auto created by the
helper in this particular case what it's
done is set it up to close a bug within
the Debian bug tracker there are hooks
into the package management system so if
you upload a package with a closes line
in it anywhere it looks for a
corresponding entry in the bug tracker
and closes it automatically so what I
should have done when I was first
creating this package is put an entry
into the Debian bug tracker saying I am
filing an ITP or an intention to package
of this particular package just to make
sure you don't have multiple developers
working on one new package at the same
time and then when the binary packages
uploaded for the first time that can be
closed to state that I've already
created this package so it doesn't need
to be looked at so that's where that era
came from so that should have been
saying it closed on two three four or
something like that
okay so at this point we have a binary
package which could be installed
directly onto the machine using deep
package but that's pretty boring what do
you really want to do is put it up onto
a package server which is really just an
ftp run HTTP server which is stored with
a file that lists essentially an index
that lists all of the packages on that
particular repository so we won't
actually do that now but there's some
very simple instructions there for doing
it using apt ftp archive which allows
you to simply put a whole lot of binary
packages in a directory run the script
against it and automatically builds the
index file for you so it makes it really
easy to maintain a little private apt
repository now once your get this
package had actually been incremented in
version for example if three point nine
point five would come out or I
discovered that I've made a mistake and
I wanted to create a new package you can
use D ch- I to increment it damn i don't
have it installed and i don't have net
access so i can't show that that's
basically all that is is a shortcut way
of
throwing you into an editor all it does
essentially is
is that
and order increments oops
and ordering from is the number for you
you can do the exact same thing simply
by editing the changelog so this change
log is read at the point where the
package is built and the version is
extracted from this strength
so if we did another dpkg build package
at this point that's the version that
would be created
okay we can pin format this is a slight
change that has been yeah if you're
wondering at linux.com today you last
year in Canberra the favourite haunt
afterwards was this little pub called
the Wigan pen and a whole bunch of
Debian developers got together and
started complaining about some of the
limitations within the current packaging
format they came up with a plan to fix a
couple of those problems for example by
allowing busy to compression and
allowing a tarball to be used instead of
a simple diff file it's one of the
problems if you're maintaining a package
that contains binaries for a couple of
images for example is all of those
changes have to be represented within
the diff and so what would happen is
that people would do really ugly things
like you encode JPEGs and stick them
within the deaf and stuff like that so
the new 2 point 0 source format allows
you to have a tarball as to represent
those changes which gives you a lot more
flexibility so you can just put
arbitrary things within it and they're
handled automatically and also multiple
upstream tar balls are supported there
are quite a few projects that have
things like built I'm dependencies that
might be libraries what you see with a
lot of projects is they start off with a
little internal library that has been
created as part of that particular
project they've got some requirement
they can't find a library that does it
and so it's included as part of the
original source at some point they often
split it up so that they think hey this
would be really useful library for other
people to use so they make it available
as a separate tarball but it's all still
stored within the same source tree and
that can be a bit of a problem to
represent within the Debian package as
well so with the new wig and pen format
based taken care of because you can
actually specify multiple upstream tar
balls as representing the source tree
for the package that you're going to
build
other things that we haven't talked
about converting rpm to Deb that can
actually be done in a semi-automatic way
but like any format conversion there are
catches if you have data that you need
for example to create the dip like the
dependencies that information may not be
available within the original rpm so
there are tools like alien that allow
you to take a nap him they rip it apart
and they try to figure out the
equivalent structure for a debian and
they build you an equivalent debian
package they can be useful for quick and
dirty conversions but it's not really
advisable as a long-term solution or it
can be useful if you're as a starting
point to show you what you need to do
rebuilding source packages you know at
the point
back up here we built a number of of
packages one of what we could have done
instead of building a binary is build a
architecture independent source package
so we didn't actually create one here
but that's just a flag that you passed
dpkg build package so that source
package can be taken on to any target
machine and then simply built for that
architecture packaging kernels there's a
whole interesting topic by itself there
is a there are some very cool cool tools
that have been used for almost entirely
automating the process of building and
installing kernels which is very useful
because it means that what you can do is
build kernels on one particular machine
have them wrapped up in a package and
then simply install them on as many
target machines as you like without
having to have all of the the build
tools install on those machines so
that's actually a really cool thing that
and package occasion so if you've got a
whole lot of machines locally that are
pulling down the same package as you
don't want them all pulling down
packages and using up your bandwidth and
do it for each individual machine so you
can run a local cache some people do
that yes
run out the answer is they used to be a
time when after midnight just couldn't
be able 32 and 64 I sounds like that to
fix now but are there tips for how to
deal with Nick systems
yes you're talking about a like a fat
package that's got binaries that will
run on either or just getting them just
hold two separate packages in such a way
okay that is not taken care of very
elegantly at the moment that is still a
problem what do you find a lot of people
do is install stuff within a chroot okay
the classic case is no flash player for
example so if you've got an AMD 64
machine and you want to install flash
player something ball in a sixty
four-bit binary and we don't have the
source there's nothing we can do about
it so a typical solution to that is to
install a 32-bit to root and then run
Firefox or whatever within that
environment there has been a lot of work
recently to try to fix that problem I
know that Red Hat has done a much better
job with that then debian has recently
so I don't know a lot about red happen
my understanding is that you can
actually run 32-bit and 64-bit binaries
interchangeably on I think that's partly
a library issue more than a packaging
issue
yeah package screeching so yeah there's
a whole lot more stuff that's in there
pretty much everything I've talked about
the commands and everything are in the
slide so you can grab their slides it's
lying they're not actually online right
now but they probably will be in about
half an hour the package maintenance
guide is a fantastic resource to work
through there are currently I think
about 1,400 Debian developers and a
whole bunch of people that are sort of
unofficial Debian developers so they
maintain packages and there has been a
lot of work to put up a really good
documentation the basically the new
maintainer guide takes you through
step-by-step the processes I've been
going through here and shows you how to
start with an original source tarball on
how to end up with a package and it's
also got reference information such as
the sections that it can be installed
into that could be defined earlier so
that's definitely worth a look and the
background image which I just think is
cool I grabbed from deviantart so I like
to give a plug for that
so yep that's it for today we have any
more questions yes sir ND
that's a whole big political issue there
has been a lot of backlash from the
Debian community there's been a general
feeling that Ubuntu has reaped the
rewards as we're from all the hard work
put in by Debian developers and they're
not giving anything back there is a
project called automobile I think it is
which is a 12 backwards which is working
to take any of the changes that are done
within the air balloon to environment
and then push those back into Debian the
thing is that pretty much all the core
canonical employees are definitely
developers anyway and so they have a
vested interest in making sure that
debian is as up-to-date as possible but
there has definitely been a lot of
tension there have been a lot of people
within debian that feel ripped off Erza
whereby we want to take them all the
glory for Debbie ins hard work so you
hear different sides of the story if you
ask anyone that works of a canonical
they'll say we give everything back to
Debian if you hear talk to Debbie and I
say don't give us anything but the truth
is somewhere in the middle the one of
the issues is that will do tends to be
more up to date because of their six
months release cycle and so the issue is
largely seems like library versioning
issues so they made the transition to a
newer loop c6 much more much earlier
than Debian did they made the transition
to xorg much earlier which has
ramifications on a whole lot of packages
that depend on X and so there were there
was a whole lot of bleeding edge stuff
that was pushed through a bun to which
is largely been pushed back to Debian so
Debian in some respect has started to
trail and you hear people making jokes
that debian is now derived from a bun
too and things like that but yeah
there's a bit of back and forth there
and lick your question so one of the
things that's always tricky is knowing
what the Machine look like when a
package was configured so suddenly
configure says I've got SSL and I'm
going to use it
is there a limit find out you know what
was the configure what is this package
is soon or happen yes as in what is what
has installing this package done to my
system what does it put in different
places and what options will the does
the package have hold into it at compile
time okay that's kind of two different
questions the first one is that there is
a list option in D package so if we go
for say I wanted to find out what the
TCP dump package that installed on my
system we just basically do a long
listing format and that shows what files
were slipped onto the filesystem at
setup time so these are all the files
that the package management system knows
about that are related to that
particular package which is really good
by finding documentation and things like
that
the other part of the question is in
relation to changes the simple answer to
that one but the naive answer is looking
the changelog but you can see is listed
down the bottom there so changelog
debbie ng said which was installed
automatically so that was basically the
change log that was entered by the
package maintainer the thing is that to
put that
you're trusting the maintainer
essentially what didn't what you're
wanting to know is the difference
between the original upstream sauce and
then what changes they've applied to it
to build the package but even when I'm
looking for so you run down sighs we
figure I'll go out and all detector a
whole lot of stuff yep and I don't
always know
what features it turned on because they
were there on the original build machine
right
what kind of that place is part of it in
the rest of this what did it go yeah
what do you look at the myth fighting
too yes I've seen the fear that is what
they compile and fiber to some extent
that will show you the difference
between what was upstream and what was
compiled but not necessarily
compile-time flags the best thing to do
would be to grab the source package and
have a look inside it I didn't build a
source package when I built this one but
typically there would be as well as the
underscore I 386 deb package there would
be a dot SRC package which is a
shrink-wrapped version of the tree that
i use to build this binary package in
your sources.list file joke
you typically have well is an entry here
you typically have both Deb sources
which is a binary source and a dash
source and this if you enable this what
you can do is have to get install source
of this particular package name it won't
install a binary it'll grab the original
source tree that the maintainer used to
create that package and install it for
you in an unbuilt state so you could
then go into Debian rules for example
which is the make file that then invokes
configure make within the source tree
and you can see what it's done to it so
if they've explicitly overridden any any
built on flags you'll see it in there
yeah any other questions
okay oh thank you if you've got any
other and we also my talk to me that
come see me at please thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>