<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Promise of System Configuration | Coder Coacher - Coaching Coders</title><meta content="The Promise of System Configuration - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Promise of System Configuration</b></h2><h5 class="post__date">2008-12-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4CCXs4Om5pY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Robert and from Google Santa
Monica I'm very proud to introduce Mark
Burgess of cfengine Fame and özil
University he is going to be speaking to
us today about cfengine and the promise
of configuration management cfengine 3
in particular and some neat new things
it involves if you have questions at the
end please use the the the Dory page
which is that go slash cfengine - talk
and if you're local we can ask them
local if you're remote please do it that
way and we'll ask them for you and now
without further ado mark Burgess
thank you very much good afternoon
everyone
oh good day to people at various places
of the planet thank you very much for
the invitation to talk to to Google
about my work for some time now I've
been studying the problem of
configuration management and some years
ago maybe five years ago I decided it
was time to stop coding arbitrary
solutions and just try to think a little
bit clearly about the theory of the
subject which hasn't been really very
well developed I think and so I spent
the past five years somehow developing
some ideas about this and after five
years now I'm in a situation where I
want to stop thinking about it and
actually
re-implement some of these ideas and
this is where cfengine three comes in
but we get along to that as time goes by
management imagine your reaction if a
manager leader or even the government
for that matter said I'm going to look
after you no no I insist but here's the
deal you have to take off all your
clothes all your protection all of your
personal protection all identifying
marks you have to be completely faceless
identical and you have to allow me to
basically do whatever I you have to do
basically whatever I say if somebody
said this to you as a human being you
would probably be rightfully suspicious
of their intentions and yet this is
exactly the model the principle model
that people use for IT management today
centralized push based rollout systems
steamrolling applications to machines
pre-specified push it out nobody gets
the question now I have all kinds of
things that I could say about this this
point of view and I'm not known for not
being outspoken so I'm going to try to
be a little bit outspoken today when I'm
talking about this but the bottom line
is that I want to argue that this kind
of thinking is not just maybe a little
old-fashioned or that somehow the
philosophy is undesirable although it
can also be discussed on those merits
but I want to argue that this is in fact
a poor form of engineering but there is
in fact a better way of engineering
systems are more reliable and a more
specific way of engineering systems that
we can use to solve this problem so if
you like I want to explain my solution
to getting three hundred people to take
their clothes off or if you like getting
IT systems to behave and my story takes
me back to 1992 when I started actually
when I just after I came to Oslo I
started working at the University and
like a lot of people got involved in
managing some workstations in this case
a small handful of Sun workstations and
it didn't take very long to realize that
we needed the help of the university the
university had their centralized
management system they helped us with
their rollout
they pushed out all of their programs
onto our servers and we discovered that
we actually had special needs and anyone
that works in a sort of research type of
company or a university for that matter
knows that special needs not as uncommon
as you would like to think on this very
nice idea of somehow being able to
replicate hundreds of thousands machines
all the identical
is not such a useful thing when it comes
to managing actually people's
workstations so no matter how much we
want to believe in this idea of control
it turns out that it's not such a great
idea and I would say that all we can
really hope for is not rollout systems
making a big impression on hundreds of
thousands of machines but the best we
can hope for is to have some expectation
of the behavior that the system is going
to produce to somehow be able to ask for
a particular specification and hope that
the machine will behave in the way that
we expect now there are all kinds of
reasons why simply rolling out images
and pushing these things out would not
work and I think it's interesting this
picture of course is a picture of horses
and I wanted horses because it turns out
that this term management comes from
horsemanship we trace it back the
etymology of management comes from
horsemanship and anyone that's tried to
ride a horse knows that you can't simply
control these things they have minds of
their own they tend to respond in
unpredictable ways and maybe whispering
in their ears and some sugar cubes we
can get them to do what they want but in
fact it's not just a problem with horses
IT systems also behave in unpredictable
ways not because they have minds of
their own necessarily but because they
have owners who have minds of their own
and have perhaps different ideas as to
how central rollout systems should work
also that the environment itself is so
complicated these days that we cannot
imagine modeling absolutely everything
in the environment and expecting systems
to work in exactly the way we predict
when we develop these ideas in captivity
and then try to roll them out into the
wild so I'm not going to recommend you
whisper into the USB port or stick sugar
sugar cubes into the power supply but
the
have to be better ways of getting
computers to cooperate allowing us to
expect cooperation from computers and
than by push based management and I have
a story for anyone who's a non-believer
which is I thought it was quite
interesting this is from a couple of
years ago at a conference when somebody
was arguing with me about this saying
mark this idea about volunteer
cooperation it's very nice but I don't
believe a word of it at our company we
simply cannot live with the uncertainty
of not knowing exactly what's going to
be on our machines we can't be having
all of this wall and Shi corporation
nonsense we have to know and then he
wanted to show me something on his PC
and he couldn't because there was some
software installed some security
software we said oh no problem I know
how to get around this and then in the
same sentence he'd somehow proved the
point that push based management systems
are not in control systems the end user
with physical access can always override
it and therefore basically what we have
is voluntary cooperation by the owners
of the machines by the software running
on the machines or have we wanted to
phrase it the local machine has the
ability to override any kind of central
management system so we should be able
to expect that and model for it all
right so what I want to talk about is is
the work that I've done on modeling this
and my idea is that the way we should
try to address this question is to to
look at those individual devices to look
at the smallest parts in the system that
can change and start the modeling from
the bottom up instead of from the top
down and in that way understand how to
put together components into larger
systems in predictable ways rather than
trying to force properties onto
collections of components that we will
assume behave in a particular way
now I start this with a slide which I
like very much a couple years ago I
found a book by the author Alvin Toffler
Alvin Toffler was a a writer and a
futurist
at the end of the 1960s he wrote this
wonderful book called future shock which
I was lucky enough to find a copy of on
the Internet
and he's really coming out of the end of
the 60s when in America of course people
were very frightened of communism
frightened of this idea of the
industrial society that mass production
would mean that everything in the future
would be mass-produced and that mass
production meant that everything would
therefore be the same that you would
have no variations everybody would be
wearing the same suits the same clothes
the same hairstyles because all we could
do would be to mass-produce and Toffler
said no this is nonsense the point of
technology is to be able to manage these
variations cheaply if if humans had to
implement these things and mass-produce
them maybe it would be better to
mass-produce but if you have a decent
technology any half-decent technology
should be able to mass-produce lots of
variations as well just as cheaply and I
think this is uh this was a key point
for me in creating cfengine which was
precisely to overcome this needful
variability at the university instead of
having this centralized management we
had all these special needs people and
suddenly we'd have a system to be able
to tackle these special needs there's
another problem with push based
management and this comes from research
into policy based management systems I
don't really know about policy based
management it's been around for 10-15
years about the same time as cfengine
started the idea of policy based
management started and there's this idea
of an obligation policy that you can
oblige a machine to behave in a
particular way and here's my explanation
as to why that doesn't work
imagine the child of British and
American parents the mother says
you have to say to tomato the father
says you have to say tomato and this
poor child is has these obliging waters
from from outside and cannot resolve the
issue by the way cannot make a choice
which will resolve the conflict because
the information isn't local flip it
around and look at it in terms of
voluntary cooperation and then you say
that you ask the child to promise
instead of believing on obligations you
make the child promise what he's going
to do and of course the child can
promise to say both tomato and tomato no
problem if it's he can spawn us to say
tomato to the mother to martyr to the
father no conflict he can promise to say
tomato at certain times of day tomorrow
at other times of day no conflict and
the only thing that would be a conflict
is promising to say the same thing in
two different ways at the same time
which is easily resolved because now the
child is in control of his destiny he
has the ability to to make the change
locally and this is why I believe the
idea of a promise is more useful than
the idea of an obligation I'll mention
this again in just a minute but so
essentially the idea of an external
obligation doesn't increase our
certainty about what the outcome of this
is going to be and what we're trying to
do in management is get some kind of
idea of what we being able to predict
the outcomes of things we're interested
in outcomes and with obligations
conflicts arrive obligations can be
coming from all kinds of different
sources and they're impossible to
resolve so somehow obligations increase
uncertainty they don't reduce the amount
of uncertainty and in a diverse a
situation of diversity I think this is
important because there are many
different sources of ideas many
different sources of specifications the
requirements people need for having
their IT systems and if we're going to
be able to support all these variations
were going to have these sources and we
need to be able to resolve them so
simply steamrolling people into
conformance isn't the answer but we need
to be able to
go down to the individual components see
what properties they need to have and
get them to make the promises about how
they're going to behave and adapt
ourselves to that scenario instead of
trying to force things on them from the
outside and this is not just a
philosophy it's an engineering principle
more than that
all right so promises it's a model and I
want to tell you about what I think of
is the idea of a promise because when I
use the term promise I use it in a
special way perhaps a slightly limited
meaning but in a way that I can
formalize and use in a technical sense
but ok I'm going to try to in this story
I need you just to suspend your
disbelief just a little bit and I'm
going to ask you to suspend your
disbelief perhaps more than usual so
let's start with the the common everyday
idea of a promise and see how we get to
promises that technology can make so
promises from everyday life I promise to
walk your dog I promise that I did feed
your cat while you were away
promises don't have to be about the
future they can be about facts don't
things from IT Help Desk for example the
staff of our company promise to respond
to your queries within 24 hours this is
a promise then we can abstract this a
little bit and say the helpdesk promises
to respond to your requests in 24 hours
and notice now that we've transferred
the promise from human beings that are
typically assumed to make promises to an
abstract piece of furniture and this is
not such a big problem it's just an
abstraction now we can say the computer
promises to respond in 24 hours or in
five milliseconds or whatever the
service level agreement is so we can
make agreements or promises about the
kind of service levels for technology we
can promise that a file will let through
certain packets from certain addresses
and this doesn't seem too bad finally we
can say things right down to the
software level that the software
component promises to have
characteristic certain certain
properties it will behave in a certain
way so this idea of a promise is really
a declaration of intent on the part of
some object in a system and normally we
assume that the decision-maker has to
have some kind of free will but by
association clearly we can make we can
talk about the promises being made by
bits of technology and what I think is
important about promises is that their
function is to reduce our uncertainty
about the situation whether they're
about past present or future
the function of a promise is to help us
to judge the situation and give us
confidence more Trust if you like that
the situation will work out in a way
that we can predict which is kind of
what we want to do in management now
often people say to me well you know I'm
not quite buying this idea the
technology can make promises but an
electrical engineer probably wouldn't
blink twice at the idea that this
resistor is a tiny little inanimate
object but a carbon or something which
prompt which has these stripes on it
which is which are making a promise that
it has you know it will resist I will
resist you with a resistance of 100 ohms
plus or minus 5% this is a promise clear
promise and we don't worry about where
this thought came from it's simply a
property of the component so we can use
promises as declaration of the
properties of the components we want to
put together from the bottom up in a
system and use it just like electronic
engineers do to create something with
predictable properties also and know
that it will work in that in that
framework so the other thing about
promises is that promises document
intentions and intentions are what we
want really to know about in the
management we want to know what will be
the outcome not necessarily all of the
details that went into making this
happen
for example if I give you a recipe
to make something then maybe my recipe
is not a very good recipe maybe it can
be improved upon maybe you don't want to
know all of the details and maybe they
simply cloud the issue what you really
want to know is what comes out the other
end and whether or not it has usable
properties we can do this with promises
alone the promises will therefore hide
those procedural details that we don't
need to know so one of the things that
if you like
I started looking at even years ago in
connection with cfengine was the idea of
using declarations of final state
declarations of the outcome instead of
descriptions of the process in other
words intentions and not algorithms and
this is an important step in making
management understandable because I'll
explain in just a bit so this is not
just a philosophy I'm not saying that
it's you know it's not fair to people to
to push out ideas on to them it's not
fair to technology to oblige systems
whatever this is really an engineering
principle just as electronics engineers
build things up from the bottom up with
components so we should do the same with
IT systems and here's the principle that
works like this we divide the system up
into its basic components the smallest
parts that can change independently in
other words the smallest parts that can
make an independent promise and this
gives us many many promises we document
all of the promises that we have to make
in order for these things to actually
fit together into a working system not
just their individual properties now but
when I put them together and I want the
whole thing to work and have a function
which is the sum of its parts are
greater than the sum of its parts
then I want to know how what kind of
promises was will result when I put
together these individual components the
final detail is that and this is where
the discipline the engineering
discipline comes in is that agents may
only make promises
about their own behavior I cannot
promise things about other people this
computer here can't promise anything
about the behavior of another computer
on the Internet they have no connection
to each other only autonomous entities
individual components locally can say
anything about or can have any
expectation of how their behavior will
be and therefore the only promises they
can realistically make or about
themselves and this is this is the
essence of the the principle so is this
about decorative versus procedural
declarative language is imperative
languages this is a discussion that
comes up again and again at conferences
often in connection with tools for
configuration management and the
discussion rages well here two examples
is a diff here's an imperative
programming language at the top and the
declarative language at the bottom and I
think you can see that they're both is
chaotic and messy as each other so it's
not about readability I find Chinese to
be quite unreadable but somehow
strangely beautiful but definitely
unreadable but millions of Chinese have
no problem so maybe the problems with me
well the same thing with declarative
languages it's not the fact that they're
declarative or imperative that's the
problem it's whether or not they
describe their intentions clearly and if
you pack these things full of detail
that's not relevant if you pack them
full of procedures that may or may not
be optimum may not be correct suitable
whatever then you're hiding the
intentions and this is a problem so in
favor of promises is hide these
procedural details hide the imperative
details and simply talk about the
intentions now the controller paradigm
could also do this of course it could
talk about you know I want you to do
precisely this I don't care how you do
it
but I want you to do this but this this
controller paradigm the obligation
paradigm
dominated thinking has these other
problems of resolving conflicts so it
doesn't reduce the uncertainty it might
reduce the level of clarity so it might
improve the level of clarity somehow but
it still has this problem of distributed
constraints being not resolvable
similarly the imperative paradigm in
computer programming the idea that we
write sequences of commands and follow
the sequences to their logical
conclusion which is dominated
programming for a long time it's very
difficult to escape from but somehow if
we want to move beyond this into a
situation of reliability then we need to
be able to escape this concept of
voluntary cooperation is a useful model
because it allows us to think hard about
systems work figures allows us to give
us a discipline for putting the
components together in using the
promises that we know about them and
being able to understand the behavior
that they're going to have based on
these promises and that will allow us to
focus on what is fixed what's invariant
about these things not details that may
change implementation details but about
the actual properties which are somehow
invariant more stable over time so
here's a simple example which I often
use of how to understand the DNS system
in terms of promises and probably I find
this example interesting because it
shows a whole level of complexity which
we often assume isn't isn't in DNS DNS
the simplest of systems how could it be
how hard could it be
and yet when we start documenting the
individual components there are many of
them there is a program which wants to
look up an IP address there is an
intermediate agent the resolver which
actually will make connections to
various servers the server's make
various promises to listen for requests
of course and to reply if they receive
requests actually it's not enough that
the client simply sends a request this
is some kind of an obligation the server
actually has to promise
listen to it and what that means is that
it has to have a port that's listening
it has to have an open port I know
firewall blocking connections and so on
so this this ask this leads to questions
about what are the conditions required
to make this service work and if these
properties if these promises are not
kept the system won't work if we can
then identify the sources of these
promises
maybe it's the server daemon maybe it's
a configuration file might be all kinds
of different things then we can in fact
trace the the causal connections between
the system and see how it actually works
this gives us a discipline starting with
some system we want we know how we want
it to work we figure out the promises
that have to be kept in order for that
to happen assuming that each part can
only promise things about its own
behavior
this gives often surprising results that
helps us to debug systems we can talk
about this another time is I could fill
a whole separate lecture with this
example so to move on a little bit how
would this take us forward but so far
I've told you how to basically reproduce
what we already know to analyze systems
that we already have possibly understand
them in new ways but how could we go
beyond this and actually use it as a
design principle for building new
systems from the bottom up the first
thought that you have is that these
things form patterns and as we separate
the system into these individually
changing components and the promises
they make they form certain structures
these structures patterns can be copied
reproduced if we have a certain bunch of
things that make certain promises that
give certain results then probably the
same bunch of things and promises would
have the same set of results somewhere
else so we can take this as a new
component and what we get is a kind of
molecular chemistry this is the atomic
view of computer science each agent with
its promises is now like an atom each
promise that it makes gives it a
property
so in chemistry you have you know will
it bond to this or will it bond to that
kind of element in IT we have will the
DNS server bond to its client because it
has some listening open port is there a
binding between them will these things
operate together what kinds of new
systems can I make by binding DNS to a
web server to a database for example and
we come up with these generic patterns
which can be reused so these promises
give us a way of talking about the
chemistry of systems if you like the way
of building reusable components
molecules if you like of computer
systems and therefore being able to
reuse the concepts so this is about
promises and this is somehow the model
that I spent these past five years maybe
you think this is something can be done
in five minutes it took me five years
well maybe I'm slow but it took a long
time to figure out the simple stuff you
know finding the simplicity in it and
this allows us to describe system so now
what I want to do is to try to take this
and apply it to the to the idea of
infrastructure management and I've given
you a clue already from the last slide
about how that might possibly be done
but let's go back to cfengine for a
moment now because this is how I started
the whole thing
what we really want to do is to manage
infrastructure and the Knology that I
often use is this of gardening and I
used to do gardening when I was coming
out of high school and there are a lot
of similarities between gardening and IT
you need to trim the weeds every now and
again clear up the junk you need to if
you want to make nice patterns you can
do that if you want to let it grow more
organically you can do that all kinds of
special needs everybody each taste to
their own and we're not trying to push
an idea or taste onto somebody we want
to allow people to express themselves
artistically and you know promises will
give them a self expression thingy
well patterns have many characteristics
so here we have a very regular pad
we have something more organic this is a
discrete pattern this is a continuous
pattern changing performance pattern of
a computer and then of course we have
patterns of physical devices physical
hardware and networks themselves all
these things form patterns from the
software level to the configuration file
level process level to the network the
physical level all of these things form
patterns so what we need to be able to
do to manage IT infrastructure is to be
able to manage patterns well we can do
that with promises here's a pattern and
I've written by side of it some
pseudocode which is actually inspired by
cfengine 3 you could actually write this
in cfengine 3 to generate this pattern
and what this pseudocode does is it
compresses the structure in this pattern
into a few simple rules we know that
every time we have patterns we can turn
them into rules games of chess we have
certain rules certain kinds of paintings
certain kinds of rules well this is a
particular kind of structure with
certain properties we have certain kinds
of rules for building it so we can turn
components with promises in between them
two components binding together making
patterns and this will allow us to build
IT infrastructure that's the idea and
then comes the the crunch which is this
unspoken hypothesis which underlies all
of configuration management actually
which I have to say is not proven and
that is that all behavior that comes out
of a computer system is basically
associated with some kind of
configuration so what we manage is the
configuration what we want to get out of
it is the behavior and the idea is that
if we configure the computer right it
will behave as we want it to now this is
not simple it's not obvious it's not
even necessarily true it's easy to find
counter examples where we
we set up a system seems to be perfect
put it into a bad situation and it's if
we cannot perform the function that we
configure it to do if we pull out the
plug obviously it's not going to happen
so this this is clearly has its
limitations but if we assume some kind
of general level of predictability
stability then it's not a real
unreasonable assumption that in a fairly
predictable world we can figure
something it changes the behavior and by
we can somehow control or turn the knobs
to make the system behave as we want we
do this by restricting at least in
cfengine we do this by restricting to
certain kinds of promises promises that
have particularly predictable behavior
and this turns out to be related to the
idea of a potential you know an
artificial intelligence there's this
idea of finding the optimum by creating
a potential well so a ball would roll to
the bottom of the well or a bottom of a
valley and this would be the stable
result of the decision and by making
these potentials we can solve problems
by somehow finding the minimum of this
this valley this is an idea I'll come
back to in a second repeatability we
ought to maintain systems we want them
to be updated and watched over and
maintained over time so I choose to
paint my fence green and a couple of
years I may choose to paint it red but I
can't just assume that it will stay
green for the two years in between Sun
wind and rain I'll change
bleaching the colors animals are leaving
their deposits on on it and so on this
has to be maintained the color has to be
a plate updated the original intention
has to be continuously maintained so we
need to be able to repeat these promises
and promises imply somehow that if I
make a promise I'm going to keep this
promise over time also not just I'm
going to keep this promise for five
seconds but it's going to last for a
certain amount of time so the idea of a
promise also somehow embodies this idea
of maintainability now in cfengine
this picture that I use quite a lot to
describe the way that cfengine makes
decisions as opposed to other scripting
approaches this is the imperative
approach this is the cfengine approach
in if we're trying to build a system in
the traditional way we were somewhat
like climbing a mountain climbing up a
hill hill climbing we do one thing we
stop we do the next thing we make a turn
we do the next part and each part new
part builds on the last thing that we
did so sequence of changes forming a
path the trouble with this is that it's
it's easy to interrupt the path we put
an obstacle in the way if one of the one
of these steps fails to complete then
the path is broken and there's no
obvious way of resolving it this is the
potential approach that I mentioned they
are the artificial intelligence approach
if you like or the decision potential
approach the cfengine away and also
somehow the promised way of doing we we
turn the mountain upside down and say
instead of getting to the top of a
mountain we want to get to the bottom of
a valley and we arrange for the system
to be to behave in such a way that it
will always roll in to this point no
matter what change we make it will
always get back to this predictable
point the golf ball hole or the black
hole would have we want to call it and
this is the key to having
maintainability so the bottom of this is
green fence and if any kind of change
pushes us away from green fence then it
will roll back the automation system the
maintenance system will push you back
into this state that you want to be in
which is this spic and span green fence
no question
so the question is can you have
localized minima which is a problem and
when you're trying to optimize these
kind of landscapes yes you can
but there's another another the next
part which is the way to avoid that the
other part of the decision-making
potential here is that each one of these
holes these black holes should represent
an independent aspect of the
configuration itself what does that mean
well let's say you're managing files you
know that you can manage the permissions
on files independently from the contents
of the file the owner of the file can be
maintained independently to the
permissions and the contents these are
three orthogonal changes that can be
made if we always make policy in terms
of these orthogonal directions then
there is never going to be an impediment
those are only going to be a single
global minimum in each individual thing
and the only problem we're going to have
is if we start making things dependent
upon each other so avoiding dependencies
between the promises the second part
again sort of making the not just the
agents autonomous but the promises
themselves non-overlapping and
autonomous and it turns out that this is
optimal in a different way as well
what we do is we create a new language a
new alphabet of commands if you like for
coding these promises about systems
these alphabet this alphabet this
language is a bunch of symbols which
basically represent promises so promises
to set file permissions promises to set
contents promises to set ownership
promises to start processes promises to
configure interfaces there are many
possible promises they don't overlap
they don't interfere but they can all be
catched in this way of a global
potential now when you do this you find
that you need only a single promise to
represent the entire process one symbol
for the whole thing which is somehow an
OP
more coding because in any program to
correctly configure a machine you need
each symbol once and only once which if
you know about information theory my
friend Shannon here Claude Shannon told
us is a maximum entropy distribution
it's the highest amount of compression
that you can achieve in a language
coding in other words each symbol each
promise contains the maximum amount of
information for its representation or
somehow we've put the maximum amount of
meaning into every bit of symbol every
symbol in our language which sounds kind
of good but of course this is a
theoretical result but I thought it
tells us I think is that we can improve
our understanding of a system by
reducing the complexity to just a few
simple statements and each statement has
the maximum if you like level of meaning
per statement that you can achieve so
the the message from this part is that
promises should somehow form valleys and
they should form valleys in these
orthogonal directions if we can do that
we can create a system which will simply
roll into its correct state and this is
the idea behind cfengine I think not
that we don't have to specify these
recipes we just specify our intentions
and the automation will make it roll
into the correct state just to convince
you about this point this is this is my
introduction to information theory that
I give to my students if you like on the
left-hand side we have high amount of
information a high amount of variability
on the right hand side we have low
amount of information information is
defined you know as as how the amount of
information you would have to write down
in order to be able to copy every single
detail to some other locations and make
a precise copy of this clearly when a
very messy picture there's
more information than n a very simple
picture and there's there's no accident
involved in making logos and monuments
very low information structures very low
entropy structures things that stand out
from the background a single symbol
standing out from basically a flat
background and this is how we convey
meaning in the society we make low
information systems so that the the
meaning to information content the
meaning per symbol content is very high
so what we can try to do in
configuration management is the same
thing try to make every statement in our
language be have the maximum amount of
meaning attached to it and then we'll be
able to understand what it is that we're
writing somehow in a clearer way because
each statement will say something
meaningful so we have promises we have
IT infrastructure which is basically
pattern management patterns are simply
variations of properties whether it's in
a garden or in an IT system in a network
in software it's just some variation
that we have to maintain and we know how
to do this discrete pattern so the
chomsky out the Chomsky grammars regular
expressions we know how to describe
these things so now that the challenge
is to put these two things together and
this is what I tried to do in cfengine 3
so see if Engine 3 tries to be a model
of promises the syntax tries to
represent promises and we try to create
a language which allows us to represent
patterns of agents or patterns of
components that will make these promises
the idea being to allow us to see the
intention behind our configuration in
the clearest possible way a promise has
three things it has somebody making the
promise or some component making a
promise it has somebody to whom the
promise is made
now a nightie that might be a
documentation process who is it that
needs to know about this component this
this property sorry who needs to know
about this property in order for the
system to work or maybe in order to
debug it later who needs to be reassured
about this property or if you like whose
uncertainty needs to be reduced it's
really what we're saying so we have a
promise of primacy and the body which is
simply a description of what the
promises about and the other thing is
that these things need to be scalable
and the autonomy principle helps us here
by making every component responsible
for its own promises we avoid this arms
race of of well we achieve scalability
by saying that each agent will simply
make its promises and as we increase the
number of agents the number of promises
increases it's flat we don't have to be
forcing obligations onto these things
from outside in centralized ways
creating bottlenecks and needing to
upgrade our servers our centralized
management points we don't have to scale
them up as the number of hosts increases
because promises will scale
automatically every machine is
responsible for itself we add new
machines then each machine is doing the
same amount of work it scales
automatically so here's the promised
model this is just what it looks like
I'm working to describe it in in great
detail would be another talk at the top
you see a simple promise the file etc'
services promises to have permissions
644 to whom does it make this promise
well maybe the security staff may be an
automatic monitoring system wants to
know about this doesn't really matter
sometimes it's not important to whom
promises are made the fact is that they
are made and they influence our behavior
I promise of course is something to be
watched and main
and verified checked and afterwards
documentation allows us to clearly
relate these checks to the original
intention
this shows the syntax we might use in in
cfengine 3 it has type files it has the
object making the promise et Cie
services the little arrow on the who
symbol is the to whom the promise is
being made it's an optional thing for
now we use it for documentation purposes
and then the body of the promise follows
and the body can be parameterised using
reusable using reusable templates so
that we can somehow create generic
promises that can be reused in many
different situations here are some other
promises and these are in fact patterns
you notice they contain regular
expressions so here's an example of how
we might do some kind of key management
SSH key management so all of the users
under home slash homes dot star matches
all of the users of course in their home
directories and we're looking for the
directory dot SSH authorized keys we're
going to do some edits in this file we
can also once we start putting patterns
in regular expressions start using
things like back references and all of
the power of regular expressions the
ability to match patterns in the
infrastructure and use the patterns
themselves in the description of the
promises so in other words you know take
this garden look at the way it is now
and make these alterations relative to
what it is now as opposed to describing
it from scratch from the beginning this
can still be done in a converging
consistent way but it somehow it
increases our express ability in terms
of the promises the patterns I'm sorry
so here's how we might use back
references here's another promise which
is a search replace promise saying any
line in in my file that starts with the
hash
and continues in some way with anything
is a shell CIM is the shell comment
comment there's a shell comment if we
wanted to convert all of our shell
comments into see comments for example
we could simply take the pattern the way
that it is and rewrite it in terms of
the existing pattern and promise that
that will always be replaced in that way
it's a convergent has a fixed end point
it's completely stable it will converge
to the same point at the end it's
predictable we can be certain of the
outcome and the expression is in fact
very simple we can of course make other
I'm showing these examples about edit
files because people's favorite feature
in cfengine is editing text files it
turns out I'm not sure that that's a
good thing but but at least this is a
way of makeup improving the ability to
it edit text files finding a region in
which to start a lens and edit so if you
have a file containing a whole bunch of
lines you may want to restrict your
edits to a particular region you can
identify the region through its patterns
how does it start how does it end inside
this region we search for other patterns
so patterns within patterns these are
the grammars the Chomsky grammars the
regular languages or context-free
languages and we end up with a bunch of
promises expressed in terms of cfengine
free language or whatever and the at the
end of a configuration run we can count
up how many of these promises were kept
how many of them have to be repaired or
how many of them just weren't kept and
where weren't repaired and this tells us
something about the state of the system
was it good to begin with did I need to
fix it if this is running continuously
how often do I need to fix it what is it
that's changing the most often so I can
now relate the changes happening on the
system to my intention
for the system not simply that such and
such a file changed and such in such a
machine at this time or that time but
this promise was broken this promise
that has a certain meaning which I can
attach to my understanding of the system
through this declarative documentation
was broken and I understand its meaning
more clearly because it was based on my
intentions
well I'm belaboring this point because I
think this idea of promises is so
important and the the understanding
issue of it is important and the thing
that I focused on actually a lot in in
cfengine 3 is connecting configuration
to documentation and really improving
how to improve our understanding of the
rules that we we code and the first
thing you can do of course is to tie it
into knowledge management so I was
mentioning to some people a lunch
knowledge management works in pretty
much the same way as configuration
management by promises you can have a
kind of semantic web of knowledge you
have a topic an issue and it's related
to another issue in a certain way so
here's an example that actually this is
actually made using CF Engine 3 it's a
web page generated by CF engine and
here's an association it's saying budget
is the topic of the topic du jour and
it's saying budget is an aspect of
business driven IT management so we can
click on business driven IT management
and this will take us to a new page
she'll take us which will to start
telling us all of the information about
business IT management if we stick on
this one you see at the top so topic
budget says the currencies of this topic
this is a promise it's saying that this
document which is related to here
contains information about budget and it
contains information of type management
issues these are promises so
documentation can also be understood
using this idea of promises
and so it's natural to try to bring
together the idea of documentation with
the idea of the configuration on
requisites for the system and say I can
understand more clearly this
configuration by relating it to this
documentation and even the documentation
itself can have other topics which are
related which will allow me to
understand it even better we'll find out
more or read more will be inspired more
about this subject so this is Scioscia
tivity that is in promises is also
extremely useful for understanding here
is the project for next year which I've
set myself for me and my team how to
create a smart monitoring system
actually based on promises we've already
said that promises have to be verified
they have to be watched over monitored
checked so why not tie-in monitoring to
knowledge management why not have a
webpage about something like the Apache
web service for example which points to
a bunch of machines running the service
so here we have an association Apache
web server is running on and then here
here come all the machines that it's
running on this comes out of CF engine
or something can detect this apache HTTP
d is configured by and then here's a
bunch of things that tell us about the
things we need to configure in order to
make this work when we click on low as
we get to the documentation for those
things so maybe we get to the actual
promises that have been made about those
things Apache HTTP D depends on open SSL
so now we know we have to check that opa
open SSL is also configured to make this
work and again this this is Scioscia
tippity this ability to connect things
together and the idea of a promise is
simply representing this relationship
very clearly and simply would allow us
to unify all of these different aspects
of configuration management for
describing the patterns to the actual
properties that they represent to this
this nice way of using it as an
engineering tool for breaking the
problem down into its component atoms
and figuring out how to combine them
again into new new things we can use the
associativity of the documentation to
inspire us to new ways of putting it
together or simply to debug existing
constellations of these policies tied
into our monitoring system and just
bring all of these aspects together and
give people an unprecedent precedented
level of understanding of the system the
final thing that I want to do with these
promises which you haven't done at all
yet is to understand how to do process
management based on them everything I've
talked about is about state knot
sequences but these these states that we
want to be in it's somehow a very static
picture of a system we want it to be in
this particular condition I might be
doing stuff dynamically but it's the
environment as a whole the patterns are
static but what if we want to do
something like add employee to the
database or add new employee to to
Google how would we do that well we
first have to register his details which
is a human issue an interactive typing
issue unless the creation of the account
which is automatable then there's a
creation of the home directories the
allocation of resources generation of
secret keys all of these things need to
happen in a certain sequence and each of
these things has to be tied into some
kind of cooperative
I call it choreography if you like how
can we do this in a way that uses
promises and therefore retains these
important aspects of promises the
clarity the pattern matching and so on
is that a possible thing to do and we
were talking at lunch about this idea of
packages for encapsulating promises in
cfengine 3 we have the idea of bundles
which is something like modules or
packages of related issues my friend
Oliver couch at Tufts calls these things
aspects these are simply ways of
encapsulating related issues which can
lend be put into processes in cfengine 3
we can do this already but I think
there's still a lot of work to be done
about understanding how business
processes are modeled by these bundles
of promises and it's quite an
interesting idea to be able to add the
human roles into the story as well not
just the automation system but how we
you know respond to whether the user is
typed in his data or not yet or answered
an email or if an SMS gets passed
between people in our organization can
we tie that into the process as well but
still have these nice these nice
decisions well properties that have
stable outcomes predictable outcomes
this is a thing for future work well I
talk about promises and since I started
this you wouldn't believe the number of
puns and jokes people can make about
promises and my slide promises are very
promising and that's a promise yeah yeah
yeah well not to belabor the word I
think this concept of a promises is
extremely useful goes far beyond and of
course promises are everywhere in in
society we couldn't almost couldn't have
society without promises and they go to
improving our trust and improving our
confidence in the that things will turn
out in the way that they want we want
them to be this business of voluntary
cooperation is so important it's not
just a philosophy it's an engineering
discipline I think this is crucial I'm
not just harping on about promises
because I have certain politics or a
certain philosophy for for life although
these things also have their merits but
I'm doing it because this idea of
chemistry this atomic view of systems
building systems up from component parts
and putting them back together again
is a basic engineering discipline which
we lack in the understanding of IT
management thinking of Toffler from the
beginning how do we manage variations
diversity is cheap and requires no a
priori surrender of autonomy the systems
we don't have to force views onto
systems we can get them to cooperate
voluntarily even if that means that they
voluntarily choose to follow some leader
and centralize themselves again it's ok
that's one possible configuration but
not the only one we can do this as long
as the promises are independent the
agent's autonomous and we can do it in
such a way that this process documents
itself through the promises that it
makes and that the intentions are
extremely clear the coding is even in
some sense optimal in the sense in the
Shannon information theoretic sense
because each symbol will appear once and
only once no I'm completely aware that
the lobby for traditional push-based
steamroll rollout configuration is
extremely powerful and strong but I'm
convinced that they shouldn't detract
from this development in a finer grained
control over system predictability that
is based more on realism than on wishful
thinking and will allow us to develop an
engineering methodology of your system
chemistry so I've been writing cfengine
3 for the past year in order to have a
framework for just realizing this
although I would say there are plenty
more years to go I think from the
position I've got to so far it's now
looking extremely possible to realize
this manifesto and with that I would
thank you for your attention and say
look forward to cfengine 3 it's kind of
exciting thank you very much I would be
happy to answer any questions if yes
things have seemed very abstract and I'm
wondering if you have more concrete
examples of the problems that come up
and how your pomace based system a
consultant like for example you're
setting up DNS you said ok you know
there are promises that could be made
and these require other systems to make
other promises like that my port 51 will
be reachable if I open it and that kind
of thing but you know it's there was
very little detail and there's no fear
little those concrete that oi would sure
to me the the kinds of problems that
could be solved and what the solutions
would look like of course when you get
down to individual the individual
promises you get down to technical
technical levels of detail and it's
quite possible it's it's it's easy to
make these kinds of promises I'm not
quite sure what kind of answer that you
want clearly we can make a promise to
test whether a promise to observe
whether a certain port is up and running
and if that promise has been if that is
verified we can make the other promise
to to use that ports for queries so just
for example the the DNS file itself
resolve confer contains a number of
promises I prom
to search this they might this domain
using these name servers one after the
other and if I don't get an answer from
this one I promise to use the next one
and so on this can be understood as a
number of promises but I can make
promises on top of that which of course
ensure that this file contains these
lines so that they so that the resolver
will always behave in this way and what
I have to do is basically I'm starting
out with an environment in which the
technology behaves in a particular way
and what I'm trying to do in
configuration management is to make sure
that the conditions are correct for for
this to behave to work together with
other components so we simply have to
put together and let's see you know
there was this file well something like
a file looking something like this would
contain a number of these issues and
there would be perhaps a promise for UTC
resolve comp there would be a perhaps a
promise to restart the bind service once
this thing was edited if necessary there
would be a promise on another machine
correlated with this one which allows it
to test whether this thing is up and
running and adapt its behavior in this
case I don't think that's very abstract
it's actually very concrete it's a it's
a particular thing that you would write
in a configuration file it would be
acted upon but perhaps I'm not answering
the question in the way that you want it
well um what's the added power besides
just calling everything a promise I'm
like you could call an imperative
program oh I promise execute this little
code line and then this code line in
this code line and you could call it
declared a file oh I promise to make all
these declarations true but you know
that's just wrapping a paper called
promise around something that's old like
what's the new you're absolutely right
of course the term promise is well the
patron promise of course is not new
because they're everywhere in society
the thing I think that's useful about
the promises that it documents and
intention and we take away the focus on
this
imperative detail and I repeat this word
again and again because people need to
hammer home this idea that what's
important is the intention and not the
detail itself technicians always love
the details but in fact these details
may even be wrong and may be
inappropriate and if you repeat them
time and time again they may in fact
break the system you know in a typical
programming language if you repeat a
program twice it may bring you to the
correct state the first time then you
repeated the second time it actually
breaks the system this doesn't happen in
this model of promises no matter how
many times you repeat the system these
promises are kept in the sense of their
original meaning in other words they
bring you to this for a predictable
location and that's that's the technical
difference between just calling an
imperative thing promises and actually
having this actually having a property
which is different but then what I'm
saying at the end with this process
management is then how do you add that
back so how do you how do you build on
this language of very predictable atomic
changes and then try to reproduce
something imperative like a business
process or a thing with many steps to it
and and keep that predictability of each
step in a way which again the
traditional Lang programming language
can't do because it's dependent on its
initial State this is not dependent on
the initial state it's dependent it
specifies the final state and I think
that's the key difference does that make
sense
Thanks
do we have questions from the larger
world dependent promises circular or
deadlocking promises that end up with
basically creating a local minimum or
ring of minimums that prevent you from
getting to your to your desired final
state is that's a good question and
there are several different answers -
one is yes of course you can create a
contradiction a simple contradiction you
might assume as an error you know set
set the permissions on the file to
accept the permissions on file - why
simply an error and it's easily
detectable in this model because the the
intention is clearly expressed it's
trivial to check but then you have the
situation in what-what if you know I
promise to have these permissions first
and then I wanted to change to these
versions and then I want to change them
back again maybe that's the behavior
that you want to promise so that in fact
you'll your ring cycle is in fact what
you want you know maybe you want to open
a window for transferring some files at
a particular time of day and then you
want to close the security hole that was
whatever the reasons for it you could do
that and it wouldn't be wrong it would
simply be an intention so I think the
difficulty with with contradictions is
an understanding what is in fact the
intention behind them do we mean to have
this first do this and do that in order
or which these things are somehow
parallel then it seems clear that
they're simply a contradiction they're
supposed to be true at the same time
then it's clear that there are
contradictions so then those things are
easy to detect so yes they can occur and
yes they can be detected and they can
even be resolved automatically
what I would worry about more is in
larger systems where these rings are not
as you know file permission levels but
you have some symbol that represents
some aggregation of a very large farm of
symbols below them that inadvertently
depend on each other or conflict with
each other and then you need to figure
out if that's actually what you want or
if that's a mistake right all right I
understand this actually can't happen in
the low-level language because precisely
because of this orthogonality idea all
of these different promises somehow flow
through each other or parallelizable in
a sense so that that would never happen
but as you start building sequence on
top of it then these things can start to
happen and that is somehow you introduce
those dependencies manually into the
language and what's nice about the
promise model is that it forces you to
document that explicitly because the
basic language is is immune to that
problem anything that you introduce will
be introduced manually and your left
will be able to see it clearly again it
goes to this sort of engineering idea of
this is a methodology by forcing you to
make all these things very very explicit
it's forcing you to confront all of
these issues as well and therefore it
makes it more likely perhaps that you
would find them that's the idea anyway
thank you
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>