<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Newspeak: A Principled Dynamic Language | Coder Coacher - Coaching Coders</title><meta content="Newspeak: A Principled Dynamic Language - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Newspeak: A Principled Dynamic Language</b></h2><h5 class="post__date">2010-06-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Z7dct6QG0cE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so so thank you all for coming and bring
thank you PS in particular for inviting
me you can you can attack and later ah
so yeah so this is about what I've been
working on the past few years which is a
language called new speak and the idea a
principle dynamic language is not an
oxymoron but maybe this is actually a
dynamically typed language that is
geared toward software engineering and
doing things the right way so not
necessarily you know some people may
think there are other dynamic languages
that are like that I won't comment but
basically it's a it's a class-based
language and what makes it interesting
are two properties that are sort of
defining properties that are the basic
principles that that everything is
designed around basically you use you as
you'll see you put stake out these
principles and the language more or less
designs itself from that point on so
those are of course the fact there's no
global name space whatsoever and that
that has interesting properties for
example if there's no global space
there's no global data there's no
statics of any kind and that's a good
thing for many reasons which probably
don't need to belabor and I don't have
probably time to do going through all of
them that's all it's all good and well
to say you don't have any static state
but this is an imperative at least this
dialect is imperative there's sort of
work going on on a purely functional
variation of this but an imperative
language a lot of people are bothered by
the question okay there's no static
state but where does it really go
obviously it goes in objects but you
know you have lots of state that goes in
objects but the whole point of static
state is that it goes that it's state
that has to be shared among many objects
and you typically don't quite have a
single object where it seems to make
sense to put it and the answer for that
is an old answer it's been known for 50
years most of the answers
computer science have been known 50
years 30 years I'll basically shared
lexical scope right this goes back to
Algol 60 and in a class-based language
the natural solution is nested nested
classes and those of you whose
experience with nested classes comes
from Java just forget that okay let it
heal and you know if you if you I don't
know if there's anyone here who knows
beta oh okay yeah so so they invented
well they mended object-oriented
programming and they also invented
nested classes and and they were the
inspiration by the way I know for a fact
they were the inspiration for for the
nested classes in Java however didn't
quite work out the way it was intended
largely because simply been is a very
uniform language and all the power comes
from the compositionality that you get
from this uniformity and that uniformity
never existed in Java by the time you
were adding nested classes well there
were rules for the pipes in the fields
and the classes and the methods and
they're all different and then what you
get what becomes compositional is their
regularity write the number instead of
an explosion of power from composing
things regularly which is what you aim
for in software you get an explosion of
complexity when but all these different
rules kind of interact in all and this
is wonderful because you know I can
spend 10 years are getting paid to sort
it all out it's its boundless but but
real nested classes done properly are
wonderful for for a number of reasons
they're great for modeling because most
problem domains have a hierarchical
structure and that map's very naturally
into into this nesting structure with
classes and they are a natural
modularity solution lots of people who
look at nested classes or classmates
languages have the intuition that really
basically we should be able to organize
things using that but in practice it
never seems to work out right it's not
that easy to pull it off but it can be
done and it is a natural modularity
solution I
and a new speak that's what that was is
what happens right there are no packages
templates bundles modules units you know
there's so many names for all these
extraneous things of classes are the
structuring concept and classes top
level classes act as module definitions
and it all works out rather nicely in my
unbiased opinion so the other defining
property of this language is that all
names are late bomb and when we say all
we really mean all so for example what
you can think of it that every every
place you see a name you can think of it
as a first approximation that it's a
virtual method call I message sent here
is is or a small gob terminology that
predates the common association today of
messages with asynchrony so you can
think of having synchronous and
asynchronous message since the
synchronous ones are just virtual method
calls hey asynchronous ones are for
actors and stuff like that which is
something where we're starting to work
on only now but basically it's a very
natural fit and a slogan to capture this
which is a well-known slogan you
probably heard a million times and is
widely used in the Java world and it's
good advice is the program to an
interface not an implementation the
difference is that in you speak you can
really do that in fact you have no
option that's the only way to make it
happen is because if you give people the
option to do it otherwise they will
screw up so everything goes through an
interface Oh an implication of this is
everything is an object right a lot of
you know a lot of people among always
that advocated that you know an
object-oriented language really isn't
object-oriented unless really everything
in the language is an object and that's
a good design principle but it isn't the
design principle here here it's simply
an artifact of the higher design
principle programming to introduce my
interface we mean more or less waiting
what you think of in Java procedural
interfacer bunch of named procedures not
exactly what you think of in Java cuz
you know Java interfaces have a few
quirks like
classes nested in interfaces and fields
and interfaces a lot of weird things but
but the the typical real use of
interfaces right now if you if
everything is an interface well
everything is is an object because you
can't talk to anything in the upper way
so it's so it actually follows for
example one of the artifacts oh this is
right you can't refer two variables
directly because you can define
variables but you cannot refer to them
because you can only refer to things
through an interface so in practice when
you define a variable you get access or
methods automatically and you're really
using those access or methods whenever
you use the name of a variable that's
actually a getter method right and and
this goes not only between objects but
internally within the object so when you
talk to self or this I that too is going
to an interface so nobody not even the
code within the class itself cares what
its representation is right if you have
you want to get rid of some some ver
instance variables which we call slots
oh you do that as long as you preserve
the interface you replace it say with a
getter method that computes of some
value for this etc then no one will be
the wiser not in not other objects not
even your your subclasses not even the
code in the class itself nothing needs
to change so that's kind of a nice
property but that's kind of not really
enough to to justify a language where
things get really interesting are that
you can't refer to classes either
because you really the only thing you
can do is a late bar in the name which
is basically a nicer surrender so when
you define a class essentially you've
defined an access or method or that
gives you the class this of course
implies that classes have to be first
class objects right this is a novice the
same as it's another example of the fact
that programming Twitter to face implies
that everything is an object right oh it
also implies interesting things like
classes are virtual always virtual are
you can override a class in a subclass
with another definition and the nice
thing is you didn't have to do anything
special here you didn't have to say that
we want
tool classes that we're going to design
the knee in consider it just happens it
is a it follows automatically from from
these principles you can't have it on
any other way you don't have to specify
this virtual you don't get choose
everything is laid out now because all
names are found in this way class is
also implicitly defined exists again
without doing anything special because
the superclass that you define is also
just a message sent and so this is class
that supplied the body of a class for
the actual definition of the class can
be bound to some other it isn't
statically tied into some particular
place into some hierarchy because you
can override it right and we make that a
little more convenience in tactical but
basically that that property is already
there and that means you can do class
hierarchy inheritance you can define an
entire hierarchy of classes of library
framework whatever and you nested in
some surrounding class and then if you
decide that you need to change something
no one one point in that hierarchy has
to change you specify that change in a
subclass and the entire library has has
has got this property right again
through through overriding over to use
of virtual quest so these are all very
nice and fairly powerful properties and
they all fall out completely
automatically from just deciding to be
serious about this idea of using
interfaces forever oh so now I'm gonna
do yeah so glad concepts are phenom and
I didn't okay so though you might be if
you're the only I'm said well I think
would be defeated that they know betta
so do you may be the only one for which
this slide is has named people who are
more into this right so so beta has this
whole philosophical spiel about a
concepts and phenomena so so the idea of
being that classes or patterns really in
beta are described concepts and objects
are the actual phenomenal real things
right and and much is made right there's
a whole sort of thought process and
methodology folks in Aarhus developed
our own is
and this distinction is something that
I've always this is one of the points
where I've disagreed with them because
this doesn't really allow for much in
the way of meta programming of treating
programs as data all that kind of thing
right because there's a sharp line
between the concepts in the phenomenon
now if classes are first class right
this is much more in the the list small
talk self tradition right so the point
is that concepts are phenomena to and
this maybe should take it out because
it's a distraction for most people but
it is a point that that only needs to
hear ya does that mean that the language
was like these fast petition mechanisms
as class concept or is that something
you can actually program in the language
how to combine classes oh so I'm not
sure what you refer you if you're
thinking of like a sort of class or
module Combinator sort of like yes I
like my magic pieces yes tom no there's
no real support for that you could
program at at the middle level
reflectively but there's a very clear
separation here as will get to between
mankind and base mirrors and stuff so
that really isn't there I mean the only
real the only real Combinator is regular
sub classy it would be interesting to
add that obviously i am not averse to
the idea but it isn't it doesn't do the
jigsaw style operate you could multiple
inheritance but you know okay so so
mix-ins in my mind subsume multiple
inheritance you what you need to do with
the reason you wanted multiple
inheritance to do that you can use
mix-ins and it had they have a lot less
problems and mix-ins just happen and so
no we don't have multiple inheritance we
don't want everyone to hear or see it
again oh I'm not very opinionated about
these things
so I want I want to do a quick kind of
review of the syntax because I expect
that I don't know all of you but I think
there are about two or three people here
who would otherwise be able to read the
examples this week we go on oh so we're
just gonna do a quick go through the
basics of the syntax before I ice or
switch to a demo and kind of illustrate
all these points more concretely so x
face fool means X dot foo correct right
and the stuff in red stuff you don't
need oh this is no surprise to some of
you but right why do you need these
parentheses well they're used to dig you
need them because you have to
distinguish in most languages between
access to a field or or something like
that and a method that had takes no
parameters right we don't have that
distinction everything is essentially a
method call so we don't need to make
that distinction and that has the nice
property if there are no parameters oh
guess what there really aren't any you
don't need to say here is the list of
parameters of don't exist but just it
also give you the distinction between
Tom of evaluations so you know language
which where methods are really functions
extra true without the bracket means
getting the closure and then adding the
brackets in actually means evaluating
right you never get the closure oh yes I
would argue that an object or in
programming it is of cardinal importance
never to separate that that closure from
its object and and so you don't get the
closure it doesn't work like whatever
problem python and even whatever you
execute he wanted to the closure you put
it in a you store the closure in a field
and you have an access ER for the field
and rights or so but it's you don't we
don't have that distinction so similarly
of course the dot while the dot is the
object member selection operator since
the only operation is select a member
for an object and executed don't need to
say that and as we'll see this isn't
really the main topic of this talk but
the syntax actually
works really well for domain-specific
languages and my lot better than the
credentials in time so we were happy to
get rid of the dot as well um binary
expressions are kind of what you'd
expect so the thing to realize is that
this 3 factorial minds tighter this plus
and if you translate it into something
that's more intuitive it would look
something like these guys what you
actually typically kept right of course
but but you get the idea of what's going
on here right then this is the one
that's probably hardest for people to
digest of the so-called key words in
text and you know oh yeah the binary
expression here is binding tighter than
the keyword so we're sending windows or
make the call called version colon and
the arguments to that are the result of
this expression 7 plus 0i and 7 plus
there is a way to write a complex number
of course and that's that's an example
of how the syntax works better than
conventional syntax because there's no
special support here for complex numbers
but you you actually can express that
very natural and so it's equivalent to
all these things right so this chosen
for residents of the by nature is higher
than the keywords and residents of it
this is higher than that which we've
already talked about and if that's what
you'd expect if you look at how you
would code it in in conventional index
and there is a personal all but what if
you have multiple parameters your
multiple keywords and the order of the
keywords is significant so it isn't
really a keyword syntax in the sense
that just the name matters and you can
shuffle it about add 12 kobo is not the
same as to Kobol add one right those are
different methods and the real the real
reason that I have stuck to this syntax
which of course goes back to to self and
small talk and is it is a barrier to
adoption ah well there's two reasons one
is yes it works much better for doing
specific languages which
original scenario for new sequels and
important using still is all the other
real advantage is that being a
dynamically typed language it's very
useful because you look at yours unlike
say JavaScript where do you get the
number of arguments wrong you know you
go into some black hole somewhere this
can't happen syntactically it's
generally much better to control things
through context-free syntax and it is
through all kinds of fancy mechanisms
like Ted checkers context-free syntax is
one of the very few things that we
actually really have a handle on that we
really understand and really work and
type systems are one of those we don't
have never will but that's another one
of my unaffiliated or sidelines oh so
yeah let's go back to the language the
the goals of this language broadly
speaking are to combine these four
things support for modularity security
reflectivity meaning the dynamic stuff
right the ability of programs to change
themselves while executing things like
that and as you can imagine security and
reflectivity there's an interesting
tension there Anna's and still too to
interoperate with a quote real world the
nasty stuff that's out there as opposed
to say small talk which tends to to
huddle in its beautiful little world and
doesn't talk to the nasties outside
which is a big problem so Oh at this
point I think I'm gonna switch to demo
now I don't know can you see it or or do
we need to sort of zoom this in because
zooming on windows very flaky but works
for us okay and other people have people
far away I've muted their mics so they
can't complain so anyway what what this
particular example that you see this is
this is the news feed ID running here
and it's showing you a class called
combinatorial parsing that represents a
parser Combinator library not even sure
if everybody knows what that is but it
doesn't really matter because we're not
I don't have time to discuss what this
this library is kind of really neat but
I don't have time to really discuss what
it does I want to illustrate sort of
program structure here so it's a library
right so down here
we have a whole bunch of classes nested
inside this list represent some classes
that constitute that framework like
they're all nested inside this enclosing
class and so for example of this is the
class combinatorial parser that happens
to be the root of this this whole class
hierarchy so almost all the classes here
there may be a couple of support classes
but almost all the classes here are
subclasses of combinatorial parts
alright and if we take a look at the sky
then what I wanted to show you is just
this particular method and you don't
really need to know what it does or
anything you have to just notice this
thing that it refers to a name here
ordered collection now ordered
collection is generally speaking a class
it's been renamed since actually but it
doesn't really matter here but it's a
class that say it's it's now called
mutable list which gives you a better
idea perhaps of what it is it's like a
like a Java beautiful array list okay
right it's a collection class that comes
from the collections library we need to
use it here for some purpose right we're
building some structure and we need two
collections so this library doesn't
define collections obviously that's a
different library on the other hand and
there's no global scope so where does
this name come from that's kind of the
issue and if we go back to the enclosing
class then we see actually well here it
is it's defined this this is actually a
field a slot defined in the enclosing
class and it's being initialized here or
to the expression on the right-hand side
yeah it's like that mutable what that's
beautiful field or not this in
particular is an immutable field that's
why it's as equal equal actually means
something and there is a sin taxes so
with a colon colon equal that lets you
define a mutable field right now in fact
how that's an interesting point I was
going to get to so how do we make it an
immutable field there's no type sugar
there's no static analysis going on to
to enforce any of these things however
if you declare it this way we will
generate a getter method and we won't
get generate a setter and since you can
never refer to the
field itself you're really only
referring to the access er if there is
no access er well you're not going to
change it and so it's it's pretty
immutable now you can do all kinds of
things reflectively right once you go to
the meta-level all all bets are off but
but in your regular program you just
will not be able to change its field
after it's been initialize them and this
code right here let's look at a slightly
different view this code right here is
you know this this is called the
instance initializer right this is code
that gets executed when an object gets
created the way this works into the way
you create an object you send a message
to its class that affected to basically
invoking a factory method factoring
method creates an instance and then
invoke sterilizer how do you define the
factory method well this guy right here
that's a method header this stuff well
I'm off by one character right is this
this is a method either but it's a
message called method called using lip
colon with a formal parameter platform
and the class is called commentator
parsing and if you actually put this in
a file the syntax would be slightly more
conventional there be class in front of
it and things like that but we don't
show it in the ID now what does this
header do this header tells us that we
want to have a factory for this class
called using live colon and so the class
object not the not the instances the
class object will have a method call
using lib colon that will create an
instance and invoked instance
initializer running this code so one one
thing to note here is basically the
factory pattern is built it you never
have to work diff spiny factories or
think about it classes are always bad
right and that means that I can take
some arbitrary build an arbitrary object
with a using lead colon that you know
those objects out of a cash or
instantiates a different class or
computes it or what have you and I can
send it along and no one will be the
wiser and let's go actually try two
subclasses they're using it to men
manufacturer instances it's
indistinguishable from a factory object
which is again an artifact of using
interfaces consistently right so there
are no constructors because constructors
don't do faces don't support
constructors constructors
violate abstraction in a really big way
now the formal parameter flooded
platform well this is this is an idiom
right it's very typical I mean the name
there could be anything right we don't
we can name it any any method name with
any number of arguments but very often
we have we use this idiom platform is
supposed to be an object representing
the enclosing environmental program in
the platform and what we do here we send
platform the message collections which
will we expect it to give us a
collections library back an object that
is the collections library and we can
ask the collections library for the
class ordered collection and that's what
we're doing and we store it in a field
because platform these formal parameters
are in scope only in instance initialize
so if I actually want aim to use the new
body of the class I'm going to have to
extract them to store them somehow at
least your step yeah what what is it
that makes it an instance initializer
it's magic this is this is the rabbi how
do I tell it from the same type so what
what part of the is it okay you're not
really seeing this in texts we're not
we're looking at a structured view right
we're not seeing a file right but uh if
we look at let's go back to hear right
so these are the men instance methods
right things like this right there there
they appear later on in a father's
actually you know the parentheses are
lined up and it'll turn into curly
braces once i get round to it so that I
have to stop explaining can't stop
explaining this but it's it the syntax
is such there's a section that
identifies this this is where all the
slots are defined and and their their
initialization expressions are there and
that's what makes it so right so when
you create an infant's will basically
extract this class from the ordered
collection library which we get from
this platform argument right the point
is there's no global scope and
everything I want from the world has to
come to me through these parameters
right all the names i'm using have to be
defined in this class or their abstract
and they'll come from a superclass there
are no global names let's surely there's
a bootstrap somewhere yes but we use
tools we'll get to that toward the end
of the top
right this is the stuff that drives
people nuts is how where do I start how
do what do I stand on of course that
that's actually the that's the
conceptually tricky part right how do
you really get rid of it so so you shove
it into tools basically this is the
short answer so uh given that the nice
thing about the fact that there is no
global scope is that I'm forced to be
very explicit of all the things I'm
depending on right they're all listed
here I know that this whole module the
only thing it cares about from the rest
of the world are these two things so
they Eric laughs and ordered collection
plus no other dependencies strictly
speaking it has no dependencies
whatsoever because it's completely
parametric but it does expect to be
instantiated and have access to these
two things so that's kind of nice from a
modularity perspective the other thing
to notice is because of this the only
way I can access the world or do any
damage in particular to the world is by
is by the things that are given here
right so it's running in a sandbox like
every every top-level class like this
that's a module definition it sees
nothing else everything else is plugged
into it and it is effectively its own
sandbox all right so that if the
arguments to the factory method are the
capabilities that you get because this
works with this is a perfect fit with
via whether Mark Miller sort of object
capability mortgage I don't know how
many of you are familiar but basically
the idea there is that ah right objects
represent capabilities rather than
checking security by by finding who's
allowed to do what are the idea is that
you're allowed to do anything with what
you have but what access is controlled
by whether you actually get those things
then if you have an object that can do
something or can give you another object
that can eventually do it then you can
do it and if you don't there's no way to
do it and so for example we know that
this class will never use reflection we
know that this class will never call an
eight foreign function we will never
call a vm primitive who's all kinds of
things because everything is always all
access to everything including those
features is not true particular language
features but through through objects yes
class some modules then then my question
so that to be featured modules
etiquettes we find out on the
dependences and other modules but the
jaws an emotional interface and you have
types on the brain I know you okay so
it's good time I'm discovering how you
use it in practice if you know that okay
a communitarian pasa of chick meets a
platform object but I don't really know
what the requirements look left okay so
so there are just a long and bitter
argument to be had here but basically
one of the points here is in fact that
types of types are useful for defining
interfaces between things for the
documentation that they're actually may
use is documentation right and there are
inadequate documentation because even
with a fanciest type system you can name
it doesn't really tell you squat about
what the thing is really going to do
unless you really go completely insane
into the curry Howard land and really
turn it into logic right so so realtek
systems I'll give you some indication
some hint about what might be going on
but really to use the any any real tool
you have to know what it is you have to
to know what is too and you can know
what it's doing even if there are no
types written at all because you read
about it on the interweb thingy or
something right documentation someone
told you what it does you'd have to do
that anyway because the types along will
never tell you what you need to know so
the interfaces are there for
automatically checking certain
consistent these things they're not for
telling you what it's do it you look you
know you can find out what it's doing in
many other ways and and this is the case
here now we actually have optional types
which aren't checked yet but which do
give you some degree of documentation
but that that's really not the point you
can you can really can live without them
and as far as modularity concerns types
have been a huge obstacle to modular the
reason that I am able to to you know
publish a paper on this in 2010 when
this is actually a very simple and
straightforward idea is because most of
the people doing research on modularity
I've been hung up about types and that
has been holding them back because types
actually run counter to modular types
propagate everywhere they're sort of
essentially global they make it really
hard to do modularity modularity
this thing okay here i'm going to do
dynamic system configuration now okay
time t0 it was in time t1 it's out okay
every six months old can do this right
that's why they sell these little
plastic things to do pop your plugs in
your house if you have small children
because they can configure themselves
dynamically they may configure
themselves in a bad way and crash you
don't want that right this is what
actual modularity is about is about the
fact that this box can be taken and
taken away if it was done like say a
typical ADA package then I could not
unplug this this would be statically
linked and then when I went to the
airport to go back to the US I take this
and this will take this and it goes down
and there's a power station somewhere
out the other end and you know what
after nine eleven they've been very
harsh about people taking power stations
onto the plane it really they'll force
you to throw it away in a bin before you
get on and all right and I'll have to
throw this with it because I can never
disconnect it like this is what passes
is modularity in most of the type world
okay so so no okay so means that you can
block that exactly the same say country
right or so so it depends right with ml
you can sort of unplug things right with
classic margin of the problem is import
right configuration is statically bound
it never changes there's you cannot do
anything you would only have one
configuration in a given run that's you
know I actually have slides about this
but they take too much time and I
figured I didn't need to to go into that
in this talk I actually talked about
this at epfl yesterday but you know I
may not convince you but sorry yes still
can you refer to the question here can
you statically verify up front whether
the entire instantiation which system
you start somewhere in Google jenya can
you study to verify that all the code
that you have will work that for
generally speaking generally speaking no
and with all the type systems in the
world you cannot statically verified
what the code you have will work you can
verify what the type system is set up to
verify and that isn't
code words that's why programs crash
even in that language now you can what
the kind of thing that you do static we
verify you would need a type system to
verify and you can add an optional type
system to this and that's a challenge
that's a research problem because the
idioms we are using are difficult to
deal with in the current state of type
systems research right there's a whole
body of research on virtual classes that
cannot express the kind of things we're
doing here because they actually are I
know if their point of departure was
types and they the types in that impose
all kinds of restrictions that make them
much less useful and and prevent this I
haven't have some idea of how i would
add an optional type checker to this ah
but in terms of bang for the buck it so
forth far down my list and in the
absence of sub funding for this project
as a volunteer effort it's who knows
when it'll happen but right this is a
dynamically typed language it is not it
is strength is that you can actually
flexibly configure things very easily it
doesn't you know naturally lend itself
to to the desire to tactically know a
lot of stuff so what else did I want to
say about this a couple of other things
that are worth mentioning so yeah so we
have a good fit with the object
capability security also because this is
the centerline region class right I can
have multiple instances of it what is
called side by side deployment right in
Java you use something like osgi and
class loaders and it's rather heavy
weight and complicated oh if this is a
class you can make is Amit obviously you
can make many instances because you know
the distinction between a module design
and its instance this is very important
and you don't tend to see that in
hardware you have to see it right if if
you have a stereo system and it has two
speakers that means you have to
instantiation of the same design with if
if classes are your module description
and objects are module instance that
works if sort of step you know modules
in the traditional sense as a separate
construct are your module design
typically that doesn't work you don't
really have a good way of creating
multiple instances in a given run right
yeah question to the scope a year so
they code in in these nested classes um
does it if they're an implicit you look
up in the outer Yeah Yeah Yeah right so
so if you look at the paper there's a
description of what look up rules right
so so in principle even though even the
local variables and the formal
parameters are conceptually you don't
actually compile them this way because
you can think of them as also being a
look up into you know for a binding that
you don't have a good way of overriding
which is why you can compile them
reasonably efficiently but in principle
every name even even platform is being
looked up that's the fairy tale so side
by side deployment is something you get
obviously for free of course you can
also have alternative implementations
right this library has an API the whole
the library as a whole has an interface
just like a conventional object single
object has an interface which means you
can have multiple different
implementations say if you want to
replace this implementation of the
packrat parsing approach or some other
approach you can do that and the users
need not be the wiser is that interface
explicitly spelled out of somewhere or
is it the fact that the whole bunch of
methods come together oh how about yes
and no or Rob okay so it basically
mainly that the whole bunch of methods
come together they're written you write
you can write up an interface because
they're it happens to be a type
expression some language that that is
optional oh there's the checker for it
and therefore it's almost certain that
this language would have to change in
certain ways because the language we're
using is the optional type system idle
for small talk once upon a time and this
language is more dynamic than that and
there are issues where where that will
probably break down but its main use as
I say from my perspective the main
utility of types is documentation not
error checking and therefore the fact
that I I choose to write this these
types of sites that's where a lot of a
benefit comes from this documentation is
important not only for
for machines all the kind of clever ID
tricks that you might want to play with
refactoring ornate completion rely on
the documentation aspect of types not on
the formal correctness on respective
types but you said in the beginning it
was like you said that you have to code
against the interface pregnant and you
and you have a complete of different
idea of what an interface is an
interface most in a set of the name
procedures but okay that can be late
bound that is the interesting property
of an interface that's why interface
give you flexibility is not about
something that some tool formally
analyzes it's not a type that's not
that's not the interesting part about it
so Oh what do we talk about yeah we
talked about the fact if you have
multiple side-by-side instances we
talked about the fact that you can
alternate implementations basically all
kinds of things that you do with regular
objects is all lifted to the level of
whole libraries because these things can
nest and it's all for free because we
don't have to do anything we just apply
the standard you know protocols and
features that regular object oh and of
course each of these modules because
there's no static stake unless you
choose when you configure them and in
this mythical place we haven't gotten to
where you actually tie all this together
unless you actually explicitly choose to
share state between them then they're
there reentrant right they're not going
to step on each other if there are no
static variables that they are
implicitly touch it so this is all kind
of good Oh what else can we tell you
that's interesting is class class
hierarchy inheritance you were where do
we put that um right so this this class
again it doesn't really matter what it
does what is interesting about it is it
intended to work as a subclass of the
other library and it has a combinatorial
parser class remember combinatorial
parser was a sonesta classic that was a
rule
of the whole pirate and we've
overwritten it here we look at what
we've actually done with it we've
changed some methods and you'd have to
understand what the library does and why
we're doing that and you don't really
care or it would be a more convincing if
I took the time to walk through all that
but that's a whole talk oh but it so
happens in for anything we added a name
so now all the parser objects in this
library will have a name right and the
way this will work is when when you
create an instance of the surrounding
class and ask for any of it of its
nested classes of classes you access
them by this access right you make a
call at that point the class gets
created it's very important that in fact
enesta class is a property of its
surrounding object of the instance of
the object of the enclosing class this
is the great number one misunderstanding
that destroyed java honester classes
right now once you do that you'll have
to compute that class so if we took a
class let's let's go back and see the
original library for a moment so here um
we want to request like alternating
parser it's a subclass of combinatorial
parser now of course combinatorial parts
are here is just a method call so what
happens is when I try to create this for
thought for the for the subclass library
I will call it and I will get the sub
class libraries version of combinatorial
parts so as a result the entire
hierarchy basically gets bound to the
overridden class right essentially it's
the exact same mechanism you have with
any method in an object or in the
program where it's calling another
virtual method it will get rebound in
the subclass same rules same mechanism
and you don't have to think and that's
very important because getting rules
consistent in the language is very very
hard the best way is to sort of design
it so that this all falls out because
otherwise you have to go keep checking
and the temperature that the possibility
of making a mistake in introducing weird
inconsistence these are the temptation
to do it or deliberately because it's
slightly more optimal and I think I know
what I'm doing trust me nobody knows
what they're doing oh I've been to that
so that's that is basically this is a
case of class hierarchy inheritance
essentially we've just been specified a
few changes to this entire library and
we get a new library with all these new
properties so that's one thing I wanted
to actually show you Oh what else did I
want to show you here um so we're brave
new world so here is it doesn't worry
this is a class that's a different
module is it's a little application oh
that's designed to as a demo to do
browsing the file system right so it
just gives you a little window and lets
you look at the file system so again
it's a module it doesn't really matter
has a couple of nested classes that
represent the way we present you know
the view of files a file presenter here
and the semantics of the application
subject we don't really care about them
anyone who's fascinated with this can go
far I gave a talk at Microsoft complete
demo and the discussion video of it on
the net the point is again we're using
the same mechanism right we're using
slot definitions as imports this
effectively right all so we have here a
file directory and ordered collection
again and make color things like that
they're coming from the outside world
we're importing them via our platform
parameter and so the question is again
how do we configure this where where
does it all get wired together and it
gets wired together via tooling and I'm
going to show you some of this tooling
so to do this wiring we basically we
write an expression that will you know
instantiate this this brave new world
explorer object and set it up with the
right parameters and that would
presumably create the object that I
wanted and this begs a couple of
questions which we will eventually
answer obviously right so here we have
this method called main colon art Kohn
this is very much a close cousin of like
main in C or main in Java oh right it's
a it's an agreed entry point by
convention
and the difference is that it not only
takes a set of say arguments that might
be command-line arguments or something
but it takes a platform argument okay
that that's what makes it different from
those guys and there's a bunch of code
in here that basically our sets up uses
brave new world explorer instantiate sit
with a platform argument of extracts you
know some sends its a message basically
runs the application all right so this
is your configuration code in a way and
it's in the language and it's in this
class and suspending disbelief for a
couple of minutes you can see that if I
have an instance of this class of brave
new world Explorer app I can send it the
main method with a platform object and
so I have a standard procedure for for
for creating it right the the runtime
the Newspeak runtime can take such an
object pass it on an object that
considers a representation of the
platform's capabilities and we will get
a running system right the remaining
several questions such as how did I get
this object but we'll get to those but
assuming you have this then you have
basically your this object is your your
binary representation it's your a dot
out and you can call its main function
and run the thing yeah why didn't you
let's go forgetting access to medical
you're getting ahead we're going to get
here as I said we have been several
important questions here but continue
just suspend your lose just a few more
minutes and assume you have gotten this
object then yes you can create it you've
created it you can run a program through
this main interface in particular you
could serialize such an object using
basic object serialization and your
binary deployment scenario would be
deserialize the object from disk and
call me in Cologne arts right and that
actually is a scenario we support so
this is the analog of a JVM loading jar
files or something right except we don't
need classf I'll jar files war files
osgi you know so one of the points here
this is this is very much a minimalist
philosophy we're trying to get a lot of
mileage out of a few very simple
concepts and you either buy that or you
don't oh so that's how we do it and the
question there's two questions that have
to be dealt with one Mattias racism
where did brave new world Explorer come
from again because again there is this
dopey issue right and the other is how
did I create this object in the first
place right which are both related to
the basic where do I stand where do I
bootstrap and start the configuration so
brave new world Explorer is again a slot
and yeah I've got imported in in some
way if we look at the definition here oh
it turns out that this particular object
it doesn't even care about the platform
it's factory method is file browser
classical and it just wants to get the
class that it's supposed to work with as
a parameter okay so that's its factory
method so that's where brave new world
Explorer came from but that that's storm
one step where it came from which so
we're still going kind of moving along
and the question is how did we
instantiate brave new world Explorer app
in particular and give it the
appropriate parameter right and so the
answer to that is down here oh this is
where as i said we rely on tooling by
convention oh we put this message
package using and what it expects to get
is some sort of object representing
conceptually it's the ids namespace it
doesn't really careful Yankees namespace
it cares it is an object that will give
it access to the names it needs in order
to instantiate itself right and what it
does it this is a class method so it's
calling file browser class hole which is
its factory method and it is passing it
the parameter at once which is brave new
orleans for and where is it getting it
from is getting it from this parameter
of the ID name space so the ID which is
the one place where you have all the
pieces of your program they have either
typed in or loaded or gotten
the net that tool it's just a program
just a regular application but that tool
serves the purpose that you usually use
a global namespace for it that's built
into your language the advantage of that
is that you don't have a global name
space in your language and therefore you
do not have all these issues about
people accidentally using it and
requiring them to use great degrees of
discipline and you know ignore
temptations they cannot ignore to just
grab it by name and so forth but it also
means you can't program without the ID
either you there this is one tool you
cannot actually program without say the
file system and a directory system and
something like make which actually goes
and uses the file system as its global
namespace to find the different pieces
that you are putting together this is
doing what make does and I I can make a
really ugly stupid tool there with lots
of dollar signs and stuff that you will
you know type of command line
incantation with 20 minus parameters and
he'll do the same thing and I know there
are people who prefer that I personally
in kind of you know a little more raw
GUI oriented but it doesn't matter
altima tlie you are always relying on a
tool even if you have a global name
space in your program you still need the
tool so getting rid of the global
namespace is is net benefit because in
the end you're still going to use a tool
to put the pieces together and it's only
for putting the pieces together for
specifying configuration that you
actually need this sort of global
anxious and it really isn't global it's
just the names of the pieces that you
need to put together you've got them
from somewhere and if the typical
namespace you use is your directory
hierarchy right that's where you get the
names ultimately for the files if you're
if you're doing conventional development
we're doing it in a slightly
unconventional way now the nice thing is
that for example yes sir so the tooling
can help you here given that we have
this method the the ID can detect that
we have these methods and it because of
that it knows that it that this is
likely a margin application that needs
to be instantiated and it knows how to
do it so we knows how to create an
object and run it so it added this link
here
and I don't know what window this will
show up in of course it showed up on bud
right so now I'm running this little
application and it lets me look at the
directory structure and whatever garbage
is in here right it's a simple it's a
very little simple GUI demo that lets
you browse the file system the point is
I created it out of these modules that
do not use any global names I did it via
the tooling system the other thing the
tooling system can do for me is since
since it knows how to create this object
it knows that you know if I wanted to
deploy it one way would be to serialize
it and I can press deploy and I have two
options one is not flex Newspeak object
format that's basically a serialized
object now unlike the typical scenario
with with serialize up just one of the
problems with serializing an object is
you have this little object you just
want to put it out there and then you
have this 50 megabyte file because you
know one thing points at another and you
didn't realize how much garbage this
thing really really is connected to now
the interesting thing is in these
scenarios again because of the
modularity properties of the language is
that this object when you serialize it
you'll really get like a couple of
hundred kilobytes because what does this
object refer to because it has noble
blank space it refers to its class and
in this case it refers to brave new
world explorer this parameter we sent it
in because laughs that's the only field
it had and that was a class as well at
top level class which refers to nothing
else does it it doesn't refer to a
global namespace so the only things
there are the code yeah does it also
refer to the platform or no because if
you notice what's happening the object
got created over here right no platform
involved it built it by taking this
class and passing it in and if you look
at the initializer right it didn't take
a platform argument your leg light so
the platform comes in the next step
right it's like so the only thing this
class takes is brave new world Explorer
which is a class and that class does not
refer to a platform when you instantiate
it refers to
platform when you give it a platform but
the class itself of class top level
class never refers to anything okay
that's the whole point and so all this
is there is the is the pure code so if i
go and choose the deploy option and so I
we also have the option of deploying it
as a window sexy and dough and I can
show you that as well but if I do this
and where's his head's put it somewhere
on the other screen hello Oh directory
probably yes so so I had this directory
and of course I should have shown it to
you earlier because this these guys
weren't there so it actually puts it out
and put some zip version of it as well
and right so this is a 12 kilobytes okay
now to run this I need a runtime that
can load it and do that and I can do
that from the IDE well of course here I
ran it but I also have the option of my
name is this is here run out yeah okay
if I do this ah unfortunately the
projector was not happy when we tried to
mirror this place so um what I want to
do is God
and it's good open it in the wrong place
again right so again it's the same thing
but what I've done something different
here I've actually asked from out from a
different window that is not pointing at
any particular app to just choose an off
file from the file system and run
longest 12 kilobyte little thing that
does this browser right so that's a
deployment scenario it's not a very
realistic one for us because
unfortunately the world does not grasp
the wisdom of you speak and so you know
think of what java does java does a
lobotomized version of the same thing it
does it's very complicated bloated
inefficient way but they can rely on the
fact that through sun's power if this
thing is stuck everywhere on everyone's
machine and there is a runtime that
understands jar files and all this crap
and it loads it and that we don't we
can't rely on the fact that everybody
hasn't you speak on their machine you
know someday right maybe maybe not you
know what are the odds but you know if
everyone was wise enough to run you
speak on their machine then here we have
12 kilobyte deployed application that's
why we allow you to do or something less
so I subtracted which is to run ok so
there's no way how am I going to show
this I'm going to drag it over here so
this guy is I believe a tech see that
was created earlier by the same process
right I'll poke this application I hope
it is because otherwise it's always
embarrassing at the demo doesn't work
let's find out Yeah right that's a dot X
see it has like the whole the vm in it
and Imogen and it could be made smaller
it with more engineering but it would
still be substantial because oh you know
deploying all this so because it has to
have engineered it so this soil engine
could be a dll there's a lot of
engineering to be done so this is an
image based systems relax mobile or
solve for the list machine it's not a
source based system oh ok so the venture
is not as simple as yes or no Oh
currently the implementation is based on
sweep which is very much as you describe
it in your faces oh because of these
modular
properties it is very easy is relatively
straightforward to to get away from that
right in particularly it is possible to
deploy it independently of an image
right you can you what you basically
however you represent the runtime it you
know it's in fact it's not X see what
the star taxi is is an image inside it
and and linking to the vm and all this
and that's why it's seven megabytes
right but it doesn't have to be that way
but the point of this talking of the
language is not necessarily the specific
engineering of this state but the fact
that the modularity enables you to do a
lot more so maybe I'm an answer do you
push so anyway yeah it does the same
thing right except that it was from a
dot X right the really interesting
option that I'm don't have yet hello ah
yes of course it that put up a window
asking me whether I wanted to quit but
it was I was puzzling um the interesting
option would have been if we had here
another menu item which would say whip
right so kind of working on that a bit
oh right we can compile this I think we
can compile it to JavaScript through
some hoops I've got a a translator
that's pretty far along does some stuff
oh you need to think about the GUI this
is the whole gooeys is written in you
speak and is bound to in this case to
the windows native api's by you know
there's a series of layers at the bottom
there's a mapping layer and that mapping
layer can be plugged in okay the idea is
to plug in a different one that would
map to say something like html5 and I'm
actually start I've started doing that
so at some point hopefully in the not
too distant future we would be able to
actually run at least some new speak
applications and some things that are
really painful to do unless you actually
implement a complete vm on top of
javascript right because some of the
things the system can do with janet
shown like it right you know it's
debugger is written in itself and all
these fancy things wallace javascript
just doesn't have the primitives to to
give you access to some of these things
but most application code we could
probably deploy this way
and that's actually don't the actual
deployment mode of interest in today's
world and i hope to get there so how are
we doing we're probably out of time
aren't Lee we technically have to room
for another over okay so me do it is so
if people want to sit for another five
minutes maybe I'll actually finish my
talk okay yeah we avoid interactive
questions then I know the time gets your
schedule goes out the window but we can
we can we're almost there anyway oh why
did when I was there anything else I
want to show you yeah there is something
I wanted to show you oh so this is the
ID okay we have low resolution and what
do I do with that I don't know what to
do well wait I i think i need to bring
it over here and maximizing it won't
help it's a little going to be too big i
need to be able to scroll down to where
it want to be then i want to shrink it
from the top i said i want to play it
back right so what I like she wanted to
show about here right this is a slightly
different use of nesting which is also
it's related to the 222 modeling right
most domains are hierarchical so here
this is the ID and the nested classes
here are things like browsing classes
brother these are browsing classes for
NSS news feed these are for small talk
this is the ID window so some of these
things are basically just classes that
are used for grouping they're doing what
you would do with the directory or
something right so if I go to the
browsing classes there's a set of
classes in them right I'm structuring
this and and so you know if I want to
get a high-level overview things it's a
lot nicer to be able to do that than to
get this long list because the idea is a
fairly substantial application and so
the nested classes can be used for
structuring as well and so the the
architecture of this thing really is in
the source code and portable with it and
not
relying on any kind of external
organization so that is one more thing I
wanted to illustrate and I guess the
rest goes to the slides I can get
PowerPoint to cooperate again so yeah we
don't that we've talked about all this
and we'll talk about that I want to talk
a little about reflectivity I just want
to mention right so i mentioned that
that how do you how do you resolve this
tension between all these fancy highly
dynamic able to change the program on
the fly change the class of an object on
the fly all these kind of things with
the supposed goal of security and the
thing is this mechanism called mirrors
that goes back to self and this product
present in a lot of systems now I mean
jdi the java debugging interface is
basically a mirror based system not
coincidental ah the nice thing about
that is that's a slightly different
approach to structuring reflective AP is
where the reflection isn't tied into
every object in Java every object had
understands get class and then you get
class and then you know all of
everything goes from there which means
that whenever you hand someone an object
you hand them the reflective capability
to do stuff with right and then you can
start having these fancy checks that go
off the stack and try and find out if
you're allowed to do that or not right
because it with mirrors you basically
separate that the object can't do
reflection on itself you have a separate
factory for all reflective objects
called mirrors or a mirror and it can
give you mirrors with different
capacities some years might let you only
reflect on your your object some of them
I only let you look at public api's so
on the may only like you introspect all
kinds of combination right so you can
very fine good control what these object
can do and you can control whether
anyone has these objects or not because
again the way we we control things here
is through actually access to object so
a mirror is just another capability and
that means that we can support all this
reflection but we can very easily
control who gets to do what let's sort
of the short summary and there's a whole
talk about mirrors on the net
cares uh inter ah well uh you know the
fact that I've demoed all this running
it's running on on real windows windows
that for small talk is or a small talk
like system is non-trivial particular
because it's still portable every August
GUI is specified at a very high level
and and doesn't really care directly
about what API is running underneath oh
and that's that's that's very important
and it also illustrates that we have a
really working ffi which we call them
aliens these are objects that let you
talk to the outside world so from from
your perspective in the newspaper when
there is no there is no construct like
native method or extern or or any of
those things right you talk to an object
it looks like a regular object these
aliens are objects that make use of
particular primitives in the vm or in
some systems the aliens wouldn't be vm
it right it might be just java objects
or javascript objects and you hide them
under this alien api in this case there
isn't a an API that takes to manage
applicability to call to c and the
capability because it is in an object
again you can control who accesses it ok
so that's kind of highlights of all is
oh I forgot about that so I was going to
show you better matching and I was
working on a slide and then I forgot so
we were out attacking anybody and
there's lots of related work obviously
and though the most important ones are
small talk self and beta and the closest
thing to the similar version modularity
is say fealty scheme units but there are
important differences and and I think
our system is basically in a way simpler
we're just leveraging the object
paradigm all the way my argument here is
if you actually if you actually
understood object orientation the way
the way I think it should be understood
it's correct way ah then then you don't
need all these extremity objects and
glasses will do it all for you and it
worked very well you know that some some
yes a lie
lots and lots of different decades of
research on this right uh we're open
source apache two point oh you know
we're basically a volunteer unfunded
effort at this point and basically all
works very well together all these
things are of a piece it synergizes all
whether it's so this idea of late this
late binding virtual classes mix-ins
modularity it works really well for
activates the currency as well Meera
Bais reflection and types of sand
pluggable type systems actually fit in
very well here though there is a real
challenge of actually figuring out what
the rules would be to properly done
check this this is beyond the state of
the art but we can push that so yeah
these are some of the people who worked
on this little these are all the people
ever worked on this well except for some
open source volunteers who have done
some important work since but the people
worked on it when it was a real project
um and me and these two guys actually
worked for this this web company called
google phone Peters in Denmark and
cities in Mountain View and you know
they did a fabulous job obviously and
that's so that's my story and I'm
sticking to it yeah resize it sector
base to see you elaborate like ok so our
view is that an actor would be an object
which would be bound with red of control
and in the unbound to it right so and
the particular model we're looking for
is we're looking at and we like is the e
model capital e mark millar's language
which show so it is different from
example from from Erlang or scout actors
it is in a way closer to the original
actor model as QA Janata describes it
but it elaborates on it in some ways
right so the big difference actually is
that there is no blocking deceive
alright so Erlang actors and Scala
actors are basically
eral a good witness nah I'll have this
idea of of a receive construct that
pattern matches on the message queue of
that actor and this was not in the
original actor model which was more sort
of dynamically oriented in a way and let
I prespecified replacement behaviors and
things like that and so the effective
doing it the other way is that again we
kind of unify actors and objects in a
deeper way because we don't have the
messages that actors process are defined
directly by their methods okay so you
know and we don't have the blocking
receive which i think is an important
issue I just had this debate with Martha
who well has he strong arguments but but
I I am sending you a message to an extra
object you automatically end up in the
threads control that you would
eventually end up with executing the
method of that name with those arguments
in with that actor running on some
predikant roll with it was associated
okay I'll go this way okay and you
mentioned imperative programming at all
how much this is actually imperative
yeah so this so the nice this is an
imperative language as it stands but the
nice thing is very easy from at the
language level to turn it into a purely
functional one because the only place
that you actually define mutable state
is when you define a mutable slot right
because the access doesn't care right so
there's basically this one construct in
the initializer or where or in any
actually method where you define your
slots and if you define them as
immutable than a mutable state and if
you define them as immutable you don't
have mutable state now well and this is
a bit of a lie because the other thing
about it is of course that you can
observe the order right because they're
nil initially now what what should be
added very soon is a simultaneous slot
definitions which is sort of a glorified
literate or a bit more than let Rick but
basically you will not be able to absorb
the order and then if you only use
immutable it'll basically
it'll also have a mutual recursion
because basically what we'll do is every
slot will be initialized to a future for
the expression that's actually written
there and then you can do and this is
important for say mutually recursive
module definitions and stuff like that
at that point you can basically define
with changing that one construct work
essentially we've added it so you'd
actually take out the immutable slots
are and then you'd have a purely
functional language of course there's a
whole quite interesting questions arise
like what about all this reflection
stuff so you can change the pro can't
you change the program or does that have
to go or or is it only me of a function
language at the base level but not a
meta level which is kind of where I'm
leaving right and and the real work is
of course this because it's an
imperative language all these libraries
you know they're there in a pretty good
style but they have them certainly have
imperative parts to them and we'd have
to redo them right we have to redo the
collection libraries there's a good way
to redo the collection libraries you
take Martin's code and translate it'll
it'll work just fine I'll be a lot
easier because we want me to find the
higher kind of types and all that
rubbish oh but it'll just work so so
that would be an interesting project
again here and there I get volunteers
who are interested in we do a little
removing but it's frustrating right
because without money life is hard oh
but yeah and then the other idea is of
course to go further and say well let's
change the semantics and well this
functional dialect and make it lazy and
then you have sort of want to join at
haskell that's kind of an interesting
though I don't think we're going to need
it because I actually think that going
to if I wanted to do that I go to a pure
actor based language like you had said I
wear every expression is theoretically
its own little actor and itself on
optimization problem but then every you
don't need monads and it all goes away
basically what are you said in 1973
thanks another 10 years but we're going
to get there so okay you're we're
getting there and I you stole yes okay
one program that would adhere to many
type system
okay yes I can talk at nauseam ah so in
fact i have talked in there are talks of
probably not recorded that there are
slides on the web and so forth so the
basic pluggable types are the idea of
what all types is again you have to be
very careful about the discipline you
have to avoid temptations so the key
idea about my definition of optional
program types is they do not perturb the
runtime semantics right which is not
true of any mainstream type system in
fact you would be hard for us to find
out a statically typed language where
they have been able to avoid that
temptation right every language it has
types those types change what the
program does I it's now the only
exception to that that I know of is not
a real executable language course lambda
calculus the whole theory of types
that's clean their lambda calculus does
its thing the types are purely a
mechanism that can tell you if something
might go wrong but they will not change
what it does all right that's because
the theory is actually and another thing
over lambda calculus is no global names
right the theory is beautiful a theory
knows what it's doing the
implementations are garbage ah but will
so so it's very important to do that
because if you let the type system
perturb the runtime semantics for
example overloading in Java hi that
means which method you actually get to
run depends on what the type signatures
statically were of your arguments that's
one example of things like that Oh any
temptation to do what say the adobe
folks did where you know they're
optional type annotations introduce
casts or dynamic checks all that
preserves things if you want a huggle
type system yes you want to be able to
add multiple type systems for different
but basically likely they're optional
static analysis it's important that they
do not interact if they perturb the
semantics they're all perturbing a
common there's some common state that
they're all messing with and therefore
they interact in there then everything
collapses there's no way you're going to
sort it out so it doesn't change the
semantics at all the language does what
it does all the type system will do is
tell you according to my rules this
could be a problem and that's all all
all it ever should do and you could do
this you know for for various purposes
of you know the conventional types
checking or or other kind of information
flow there you know things like that
that's the shortest expansion on
pluggable types I can do oh so popular
so I didn't catch that last half of your
sentence popular diner by him to do what
you're missing okay so so yeah that's
not a coincidence i related work means
that there really is a deep relationship
either in the history of the ideas or
something like that right I if Python
never existed it would not change what I
know or think about dynamic language is
one dot right these languages are not
noted for their intellectual
contribution to the state of the art of
programming languages they are
particular implementations of ideas that
have been successful in the marketplace
for whatever reasons and one can
speculate but they do not bring new
ideas to the table I'm sorry everything
that you can do it by thon you doing
list decades before and do better in so
they're not they're not there for a
reason I aren't really not they may
agree with that so so as far as i know
the whole optional type thing there's
quite a lot of history to this research
and i don't believe that that again in
sort of a cadet in scientific research
you know who said something first
matters right i don't i agree with the
python folks on a lot of things i
disagree with some things right but
there's a lot of probably more with IRA
for the python folks in peril you say
the ruby folks or whatever the python
folks are much more software engineering
oriented than some of these other
communities the question in related work
is whether they originated an idea that
is or made an important variation with
with novelty to it on these ideas and no
they haven't they they've engineered a
solution and it's very popular and very
successful broad largely because some of
these properties exist there others
don't but they're not an inspiration for
you don't diss you got jello exists okay
so so I actually see more of a relation
because in Java there is the notion of
nested classes in Python really don't do
anything they don't really nest in in a
semantically interesting way they don't
scope properly unless you can change it
because you can change everything by
them but they by default don't actually
do anything that there's no reason for
them to be there in a sense net nested
classes in Java attempted to do
something they do have a semantics
they're kind of screwed up but you know
that I see more of connection now maybe
you see it differently I I do not see a
connection really between Python or Ruby
or pearl or any of these things beyond
the fat cats are dynamically typed and
so forth not are not in the history of
the ideas which is your something to say
or yeah um so the to the practice of
developing libraries now I see that you
I seem to have more options how to
structure my program I can depend on
another module or requested someone
asked me another module or past week
classes directly and did you did you
find that confusing or come up with a
good way okay so so actually let me
restate that since at least I think what
you said was an accurate right the
choice you tend to have is whether you
get asked a online you set it right
maybe you have a choice between getting
past a module definition sometimes or or
an instance and deciding to instantiate
it once you get the module you know you
can you can choose that
oh that's sort of a design choice to
some extent just like anything else in
software program because we've reduced
it from a fixed menu of very limited
things that is hardwired into the
language to using the general facilities
of objects and instantiation and
parameter pass and then you have a
greater variety of you know that these
tools can be used in a wide way oh we've
you know if we've had some experience
with this right so so we've come up with
these idioms of how we do things but but
that choice may vary depending on what
what it is there's also as always the
big choice of what are your module
boundaries where do I one set of choices
involves do I really structure it as a
big giant monolithic class or do I have
a number of small classes and then have
some some intermediary class where it
pull them together and stuff and some of
that was historical because you know
some things were done earlier and then
something was done later by a different
developer and things like that so you
know you is you have choices of how to
do this if it's a very large module you
probably don't want to end up with a
single thing that's you know 20,000 or
50,000 lines long if it's 5,000 that's
or okay you know so so partly as a
matter of size and we probably need more
experience on these kind of questions
but we have been able to you know the
entire ID is an application structure
like that like like I showed the GUI the
Holy framework which portable retain
graphics and a higher application little
layer each of these they're all fairly
sizable modules and they do they do a
fair amount so obviously our experience
is limited but it's not trivial I
started question regarding the
installation with the S packaged stuff
hmm so that it gets the IDE environment
now that comes from the virtual machine
so say if you want to know it doesn't
come from the virtual she comes from the
ID and he is an application oh it just
has a map and you ask you to load the
class and then it can read in qualicum
compiler and so forth right whatever it
does it's just an application
so in a hypothetical world if you were
working with sort of where you wanted to
do your editing in emacs and then run
the program at the end with that okay so
how would I do so I could edit there is
a syntax and then you can edit it in
Emacs or in VI if you want call dead
fingers or whatever and then that the
question would be how I what tooling
would you choose to use right so you
could imagine like I suggested earlier
if you really want to do that you could
imagine having you know NS make or
something and you put all every module
in a file and you you right up you know
you write a glue of method in just an
expression in glue code and it calls the
compiler and feeds it to subtly read
from the file write it it's there's
interesting mechanics there but there's
nothing really different it's it reduces
the observation is you're always going
to end up using some tool for the
configuration that's how it's done in
every instance and the only thing is if
you if you serious about using that tool
then you realize you don't need the
language to hold itself with a global
namespace as a crutch to but where were
the equivalent of the ID name Spanish
Cup because collectively I'm kind of a
global you know implicitly it's like you
know it's not really a miracle
syntactically but it ultimately so so
you could imagine so this make tool
would read files and match you know
names of files to maintenance classes
read them in produce a dictionary stick
them in or an object really that that
answers these messages because it's
dynamic it's very easy to do these sort
of things to have it forward to a
dictionary lookup right and it would
then pass that object in to this method
right we would have thought to construct
at all yeah yeah oh well okay I'm not
sure I understand how the IDE app to
update 6 class definition so does it use
some method in the platform object
folder ah it all works through
reflection this is this is real
reflection it's not just
respect that's that's why it's a dynamic
language that that's a misnomer right
with dynamic and dynamic language is the
fact that the programs can dynamically
more modify their definition that's what
makes a dynamic language dynamic oh not
by coincidence they're all dynamically
typed because it's just incredibly
painful to figure out the type system to
do that but then basically after it goes
through an API and says okay add a
method remove a method create a class
always and you have I just wanted to
know how things can go wrong with your
experience you use week uyuni bugging
orgasms I will ignore the temptation to
say that they don't go wrong of course
they grow up they go wrong in much the
same way as they do say in something
like small talk except less because
there's more structure here you do have
modularity things like that but
basically you can get a message not
understood are the actual the thing that
for type people is hard to understand is
that that is not the end of the world
again using an interactive ide you most
of these actually crop up with some very
basic testing and you fix them as you go
along and it doesn't take you any more
time than it does to vital the high
school type checker oh so that's the the
most common one of course is is simply
when you have meals right the equivalent
that that's the most common actual
problem that might then might stay in
your system after this is very initial d
buggy and the right answer to that is to
have the version where you initialize
everything and you never have nose like
the functional right but that's
basically all there is a deep there is a
full symbolic debugger you can modify
mean I can demo all this but we're kind
of running late oh I can show it to you
later write it there's a debugger that
shows you the stack and lets you modify
programs on the fly in to fix and
continue debugging and all that kind of
stuff right or it's all in the ID the
still have to happen every time so this
seems to happen every opportunity ah yes
yes yes now of course this isn't a type
system but there there is um since it's
um it isn't
in the sense since we don't have a
formal type system we don't have to
confront this logical inconsistency but
they're nil is basically an instance of
a class called undefined object and we
in it is by in everything inhabit so you
can stick anything in anywhere right
variables do not have types right but
but if you add a type system to it it
will have that property if I exhausted
you finally good thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>