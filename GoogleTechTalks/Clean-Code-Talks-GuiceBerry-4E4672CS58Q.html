<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clean Code Talks - &quot;GuiceBerry&quot; | Coder Coacher - Coaching Coders</title><meta content="Clean Code Talks - &quot;GuiceBerry&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clean Code Talks - &quot;GuiceBerry&quot;</b></h2><h5 class="post__date">2008-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4E4672CS58Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Ursula I go by my last
name just so that we get that out of the
way and here to speak about gooseberry
which is some sort of a library that
would allow you to leverage juice for
your tests I am the creator of that I
owe the work to that I did to many other
people you know everyone from Kevin
meridian was in the audience to row
fernika who did a prior version of a
prior incarnation of this which is the
test service injector our intern dunker
Kevin Scott which-which who did most of
the grunt work of the first shot and
many of the other people that have
encouraged in the allowed and encouraged
me to adopt and adopted it on their own
products this is currently already in
use in several different Google projects
Edwards 300 school Edwards Mineta shards
Adsense maybe Paul and then in in the
team on New York for alerts I believe
this is an adaptation of a talk that I
will be giving it up slow it this is all
public information I actually checked
the box to make this video available and
YouTube don't say anything proprietary
there shouldn't be anything in my slides
is proprietary if you have questions at
any time during the talk you raise your
hand you can ask the question if it's a
very quick question you just asked it
out loud I'll repeat it and I'll answer
if you have something that you want to
say and elaborate on please at any point
in time you walk to the microphone
I'll stop we'll give you the chance to
speak so that I don't need to repeat
that so that it gets registered on the
microphone without further ado Oh so
since it's an adaptation of a talk and
the talk that we were giving uppsala
actually spends a lot of time talking
about juice itself and then it goes into
juice berry I wanted to get a
temperature feel and hear how many
people in the audience do not feel
reasonably comfortable with juice itself
you raise your hands so he got only a
couple of people in there I will zoom in
through the part that covers juice it
covers it under a unit test lenses which
allows us to
a backdrop to the application test
eventually but if you have questions
regarding that you please feel free to
interrupt me as well and the lens the
unit-tests lens application that I'm
going to be showing you no con it's it's
backdrop with a biller shopping cart and
a unit test for those two things I'm
actually borrowing from slides that
jesse has kindly prepared from another
presentation from Google i/o and crazy
Bob had also done that did some
adaptations to those as well I'm gonna
again zoom in through that three
different approach is going to show how
the code would look like before juice
came in how the code would like with
manual dependency injection and then the
by using juice on top of the manual
dependency injection in there so imagine
that we have an interface of a biller we
have a real implementation of that
biller is a Google Checkout biller very
simple thing and then we have a fake
implementation of that which is useful
for us to test that's all about testing
gooseberry so if we have our old-school
factory singleton methods in there
static method factory we will have a
private static final biller instance
somewhere in a way to acquire that
statically from a biller Factory
everybody has seen this code a million
times more than what we wish we had and
then we would have a shopping cart the
shopping cart needs a biller what it
would do is would say ok biller factory
please give me an instance of that
biller and i actually try to take the
take care throughout the slides whenever
we call a static method I italicized
it'll just like your ID would so that
you know it's bad this is this is the
dependencies in there your shopping cart
depends on your biller Factory that
depends on your instance of the biller
it depends on the biller now if we want
to test this stuff there's a couple of
compromises that we need to make because
if we want a unit test a shopping cart
we need to be able to replace a real
biller by a fake implementation of the
biller so out goes define a word on the
private static in there and in comes a
method set in
which probably we annotate at least in
Google with add visible for testing
right and then that's your test shopping
carts test in there the blue part is my
actual tests the black part is the
scaffolding around that is the j-unit
scaffolding at the beginning declare the
method and then the biller the factory
dot set instance also italicized with my
fake biller
that allows me to to test unit tests at
class sure enough there is a problem
with this of course because as soon as I
set the instance of the biller all of
the other tests that come after that
will get my fake implementation of the
biller not exactly probably what I want
to do so my test would also have to do
some setup and teardown in there where
it stores in a private variable the
previous version of the Builder and then
it sets the previous version the
original version and it's teardown who
has seen code that looks exactly like
this everybody ok so Kevin B has created
this nifty thing okay so the prod the
larger problem with this is that if some
exception happens and some more teardown
in there then the biller is never tore
down it's not restored with the other
you know version that he had before
kevin has created the class that is very
familiar to Googlers that do Java is
called a teardown test case it allows
you to put that there down code in the
setup as individual parts so you
guarantee to at least do that so
scaffolding all of this stuff that
allows me to create a test now the
factory observation of course the tests
must pass to fake to the service and
clean up afterwards there is a compile
time dependency from the test on to the
Google Checkout there is a real time
dependency on the Google Checkout biller
even though we never use it
hopefully the constructor of that beast
doesn't do anything expensive which is
not as very likely but you know we have
we actually create an instance of a
Google check our biller even though we
never use it right and then reusing the
shopping cart in another context that's
different from from the one that we
originally intended for is very hard
because in DI language independent
Injection language the shopping cart is
coupled to the Google Checkout pillar we
saw the code in there so how do we fix
that by hand we have constructor
injection is my favorite kind of
injection hopefully it's yours as well
you pass a bill er to the construction
of the shopping cart you make it a
private final it's immutable and never
change it it allows me in my tests to
create an instance of the shopping cart
by passing my fake there's no setup or
teardown required and this is the code
that it looks before and after the
entire scaffolding of the setup is gone
and that red line of builders factories
dot set instance is also gone and I
didn't lose any functionalities it's
exactly the same test only better and
the question is where does the my
dependency go tenancy goes on to the
shopping cart factory then the shopping
cart factory knows how to create a
shopping cart by creating it by calling
the biller factory get instance and
returning a shopping cart in there in at
the dependency injection module would be
to push the dependencies from the core
of the systems to the edges of your code
as far out to the edges of your code
that they are that they can be and this
is the new diagram the shopping cart
doesn't depend any more than the Google
Checkout builder so it doesn't either
compile time or the run time depend on
the Google Checkout builder and what
depends on that is a Google cart Factory
now of course the manual dependency
injection has the older you know it's
Turtles all the way down sort of problem
if you if you have a factory
now that is used somewhere in your code
cause the shopping cart fracture you get
another factory to create that another
factory to create the class that creates
that and so on and so forth and this of
course is where Google comes juice comes
in handy I'm gonna skip a couple of
slides which again are more targeted to
to juice itself because writing all of
these factories this tedious blah blah
blah blah blah this is how you do it in
juice you configure your interface to be
bound to your implementation and you
have it inject flag to inject your your
builder in your test or sorry in your
production code and from there on the
billing module is the thing that really
depends on everything I have this nice
diagram
which which for me is conceptualized how
I view the system on the right hand side
I see that the four different master
layers from this particular prism that
existed at the bottom we have the
interfaces sorry I actually should have
flipped this but I'm not very good with
that OmniGraffle but the interface is
that we have an implementation of the
interface we have the modules that
depends that depend on those real
implementations and then we have
applications that pick a collection of
these modules together likely your
application is itself a juice module
that basically just picks a collection
of other modules and says I am an
application I can be started right and
the the point in here is the test in
juice looks exactly like the test with
manual dependency injection just like it
is it should be okay now now this is the
the meat part and there to provide a
just a backdrop for me we're going to go
into application testing and when I say
application testing in there I want to
differentiate that from unit testing
application testing is also referred to
as functional testing there's a number
of other names for that right unit test
is a white box I'm interested in in a
cold branch and then I used to say an if
statement and if path really one test
test one if path in one method in one
class that's a true units test right on
the other end of the spectrum we have an
application test it doesn't really care
what the code looks like sometimes you
can you can refactor your entire class
or swap it for some brand new
implementation the test might not need
to change at all because what it's
interested is how the code is perceived
by the end user it's black box it
pretends by-and-large to be an end user
it collects through the UI and it
asserts things that it sees in the UI
whatever their UI may be in the case
commonly in here is like a web UI as a
browser so this is how my application
then would look like in the bottom part
is in black the parts that go into
production rights including the part of
the re user using the our application we
have a biller
we have our server or application that
talks to the Builder we have a Firefox
instance that talks to our server on
blue on the top part and there we have
the stuff that we need for our
application test I'm using selenium in
here for what to drive this because it's
just like the de facto standard that we
use in Google is very nice tool that
allows us to drive our applications to
drive Firefox right so there's a my test
code all the way in the top and then it
drives a selenium RC that drives the
application and so imagine that this is
sort of the tests that I want to write
there is I need to create a user for the
purposes of the test I log in as that
user then I collect to buy an item named
iguana then I enter a particular credit
card number I click on the submit button
and I assert that I'm visiting the
submit ok page who has seen a test that
looks somewhat like this in nature it's
done everybody most everybody has done
application tests before right this
doesn't care what the code looks like he
cares what the user perceives when they
collect through the application this is
a scenario test scenario right now there
are two things in here that I omitting
and I'm gonna go into more details in
the next slides to provide sort of the
comparison between how it looks like
without just bearing with gooseberry
under two things is how do I get an
instance of the tools that I need how do
i get if i need to use selenium to log
in to click a button to do something i
actually need to acquire an instance of
the selenium class right and then how do
i bootstrap the environment how do in
the beginning of my test i fire up my
server i put all the pieces together
that allows me even to get started
testing things know together so I'll
start with the blue the first item how
do we get an instance of selenium in
this class in here ok so we could have
in their private selenium selenium and
in it selenium method that's called from
the setup method setup method would
start the server first and you would
initialize the selenium and after we
initialize selenium then we are free to
use selenium to open the login page and
as our user yeah okay so there are two
things that I want to point out about in
this slide which which are first let's
imagine that you would like to have all
of your tests sharing the same instance
of selenium for example all of your
tests in all of your test cases and even
more so more importantly that login
method that exists in this test and here
is useful probably for more than this
one test case it's something that you're
going to use in pretty much all of the
tests that you write for your
application yes so so speak it out how
do you how do you make this code more
reusable for other tests in old-school
j-unit you create a superclass how did I
know that because it's the only thing
that j-unit allows you to do you create
an abstract class my selenium tests it
extends test case you have a setup
method you push your setup method to
dare you push a selenium up there you
push a private-public login it avoid
login method into there and then you
make your selenium of course static
because you want that same instance to
be shared for all of the tests and in
your init selenium method you check
whether it's no where if it's now you
create one otherwise you just use the
one that you have already done before
who has same code that looks exactly
like this okay again pretty much
everybody that pretty much has done
application tests has seen this now I
should have waited until I flip my slide
to the next what are the problems that
you see with this slide in here if any
just if there are no problems that I can
go home okay so one problem is subclass
after subclass after subclass all of the
different things that you might want to
do in there you have to fit into a class
hierarchy which can grow up to be a
monstrosity like an old school off the
extends functional test case if you ever
want to have a lot of fun with class
hierarchies just look at that one okay
another problem with this
sometimes the server can be configured
you might want to configure the server
in different ways for different tests
we're gonna get to this later I'm still
stuck on problems on this light in here
what did you say is that that's one
thing this like I'm thinking okay it's
cheap because you know even if I keep
these things forever on JVM exit hope
there's gonna clean up all of the
resources and that's fine I have other
peels with that the peeves that I have
in here is of course there's a static
selenium we do dependency injection we
don't like to see the word static in our
code that's fine
inheritance is really the only choice in
je units as we were saying before that
that's a very well taken point now three
other points are more interesting in
here is that that test read is like a
kitchen sink test everything that you
can possibly imagine that you can
possibly ever want in any of the tests
in your application has to be in that
one class right and I've seen code that
looks exactly like this hundreds and
hundreds of methods I have nothing to do
with you but someone else in a team that
is sort of kind of like the same team as
yours needs that a they dump into the
same class or in parent you know in
other classes in the same class or arc
it's a kitchen sink rate the other thing
that we don't actually get to think
about when we write our tests just
because j-unit made their brain so dumb
is that there is also compile dependence
compile time dependency on what is
really a runtime dependency my test has
nothing to do with the default selenium
implementation of selenium but there is
a compile time dependency to it it's
it's even hard for me to state it this
way cuz we're so used to cleaning up a
production code and then we end up with
the tests that still do all of the
coupled evil stuff that we cleaned up
the production code we don't even think
about that because we can't quite think
of how to fix that there was one of the
peeves that motivated me to go into
writing gooseberries like I underwent
all of this effort to clean up all of my
static code and my factories and stuff
from production and suddenly I ended up
with test code that looked a lot worse
than my
production code and that didn't make
sense to me right if it's test code I
ought to care about that and of course
all parts are coupled together that's
gonna come back when Peter Peter okay
and when we could go back to Peters
points in there so how do we fix that
with you Sperry
right this is sort of the same test
written in juice berry it extends from I
chose to extend it from a base just
Barry J in a test case is packaged for
you it's so it's as good as extending
from teardown test case or even test
case itself you just need to call just
very not set up in your setup method
that's pretty much what that class does
for you it really doesn't need to extend
from your own abstract base class and it
can have a log in both injected into
this class and that log in bot can be
used to log in as a user and the first
line in the code that you see in blue in
there is just declaring that the
environments that glues all of these
things together is called my ends okay
you parse this slide okay my login box
is just a random Pocho class in there
that is injectable has an injectable
constructor uses constructor injection
to get an instance of selenium and it
does exactly what the method I put in
the superclass and the other example
does it just as selenium door open for
particular URL based on the selenium reg
I I'm gonna say this multiple times in
this presentation is just like your
production code looks like the intent of
juice berry is if you have justified
your production application your test
code would look just like a production
code looks like and this is this is
urine this is a juice module chose again
to make it extend from this juice Barry
J unit 3 and in there which gives me it
installs one basic just very module
which knows how to deal with with
injecting test cases and this
test scopes but basically this is just a
modular juice module an abstract module
where I can bind selenium to a selenium
provider and scopes singleton and that
selenium provider is just a class that
has the code that we had in the
superclass again that knows how to
create selenium based on a default
selenium okay clear questions no
questions okay so the issues now are
solved the ones that I pointed that
leaves the ones that I rigged this to to
point out - there's no more static
selenium because just like in your
production code your singleton is dealt
with as a scope not singleton in fact
scopes are singleton is not the the
scope that I generally use for my
selenium and my application I actually
make them thread-local because it allows
me to run tests and parallel just need
to change that one scope declaration and
there to be thread local scope
inheritance is not the only choice
anymore d I particularly juice is one of
the things I love about juice it
encourages composition a lot so I can I
can break down the parts into as
granular of things as I want and I would
just inject things that actually care to
inject to inject and have available in
my tests in there my kitchen sink tests
then doesn't even exist so it can't grow
unbounded large there's a separation of
concerns as I say the different parts
are granular and they can take care of
the things that they know how to do very
well and there's no compile time
dependency to anything anymore except
the things they suck the interface is
just like in your production code our
test doesn't depend on the default
selenium anymore and all the parts are
not coupled together the coupling just
like in your production code happens in
your juice module in your application a
juice berry and if you if you think
about the slide that I showed all the
way back there is like an application
it's an application that is complete
that comprises multiple juice modules
they are put together in there and
that's where all of the pieces are
coupled together okay up
okay so there's all sorts of fun things
that I can do now right with my tester
in and again this looks eerily like code
that I actually have written in my prior
ain't no stent with the billing team in
here this is a different test tests they
declined credit card transaction in
there I said in the beginning that the
tests pretend by-and-large to be end
users sometimes they actually it's
convenient for them to be able to access
some backdoors in the system so they can
help our test infrastructure know that
we're testing a scenario other than the
only scenario that they support so in
this case are our fake implementation of
the biller can look at that and be told
okay when you get this next request you
please decline that transaction that's
the fourth blue line that you see in
there and then I can assert that I'm
using the credit card declined page and
that because I can inject the biller
controller and here that I can acquire
in any particular way that I want and so
on and so forth if you look at the code
that that uses just Barry you're gonna
see that classes get a lot of things
injected or however many things they
actually need in order to operate you
see it also that even though I use
selenium in this class the selenium just
like in your production code there's a
dependency of dependency of mine right
the dependency in this case of the login
bot so I don't inject selenium into it I
inject selenium into the login button
the login button to this just like in my
production code so the second part that
I wanted to talk about I'm gonna revert
to the stinky old world of Jay on it
without gooseberry is how to bootstrap
this entire thing right we talked about
how to acquire instance of your selenium
but how do we bootstrap this application
I'm gonna get to Peter's point in a
second we have a selenium class that now
I expanded the start server portion of
the setup in there that does a start a
builder of course and before I start my
application I need to start a builder I
build a set of our arguments to my
application where my arguments points to
the address of the Builder
localhost port one two three four and
off I go now I don't want to transform
this into a cell fast or an indictment
or anything about about you know
swapping out real for fake
implementations but I honestly have
found very useful to have the ability to
run my applications against fake major
systems that are external to my
application so in this case for example
I would very much like to be able to
test my application by and large against
the fake biller
because bringing up a builder is
expensive I don't want to do that in my
environment in my development
environment it may drop a hint in here
you may need a version of my C code
that's not compatible with the version
of my sequel of my production code that
lives in my development environment so
it can be a hassle it's not quite the
word that I'm looking forward to to set
it up so by and large I'm interested in
running my tests against the fake
because by and large I am interested in
in testing my code and ultimately I'm
also interested in the wind whether it
actually works but I'm by and large I am
interested in testing my code and the
code that I wrote is not the bill or not
in this case so again if we can modify
it ever so slightly my first slide in
there we're gonna see in the bottom in
there that I can have my server talking
to a real builder or have in process
fake biller installed in my server that
would allow me it will be a fake that is
there is not one of those simple you
know testing on the toilet corner things
there very simple fixes like a very
capable fake that can pretend to be the
real thing as far as my application test
is concerned and then I would have say a
static system property in there that I
can say again by a large I'm interested
in testing the fake pillar so this code
says by default please use the fake
pillar but if I wants to run my test
against the real pillar when integration
tests then I can actually run that test
against the real pillar and that's how
the code would then look like very
simple K I put an if statement in there
if I use the real bill
then I start the biller and if I use the
real biller then I configure the biller
address to be that otherwise I just tell
my arguments that they are to be run
against at that server is to be run
against the fake biller who has seen
code that looks like this okay most
people again have seen code that looks
exactly like this now the problem with
that it comes back with a vengence in
there where my kitchen sink test not
only grows and boundedly large but it
grows and boundedly complex and it's
setup code for all of the possible
combinations of all of these fakes
because my system might depend on five
external systems in there and it not
only compiles that the compile time
dependency to this runtime dependencies
that he has it really is a union of all
of the possible fake and real
implementations of all of the external
systems so not only it didn't make
matters better I made them worse by
introducing the fake because I need to
compile more stuff I need to compile the
real biller and the fake builder and the
real login the authentication server and
the fake one and so on and so forth and
the coupling Peter as your point right
there there's a combinatory explosion of
all of the possible different ways that
my system can be set up for all of these
possible external systems okay now if we
go back into gooseberry we remember that
the only link between this and a
particular application is at the at
gooseberry annotation happens
reflectively in there it's pointing to
my end my ends other than this stuff
about selenium would have say will have
something that looks like this where it
configures by default the builder to be
tied to a provider or fake biller
provider in scope singleton then what I
am free to do is I create a brand new
environment has nothing to do with this
now extend that doesn't it doesn't
compose doesn't it's just a different
environment that says it's an
integration environments so another
application I can configure the same
builder than to point to a real builder
remember my test only knows about biller
it doesn't know about the fake or the
real biller in there and then what just
Barry allows me to do this was built in
from the get-go in Dewsbury
it allows you to tell j'espÃ¨re you know
i had a change of heart when i said that
i wanted you to use my and i were
actually really meant you to use my
integration f so you could get your same
test case running against your fake in
your real biller whenever you wanted
them to without increasing the
complexity of your setup code in there
and this is how you do it you install
remap err you install remember through a
system property a remember can be as
fancy as you want it takes a test case
and the just very end name as arguments
to the remap method and it needs to
return a string which is the name fully
qualified name of a class which also
needs to be addressed very end that's
all the remember needs to do I mean
there's all sorts of fancy things that
you want to do in there in this case
it's does something very simple we say
okay this remember green mapper remaps
anything that he receives to be my
integration environment
I actually commonly create a static
method in the classes in my remap or
classes that can do that sort of stuff
programmatically
like the grayed out stuff in the bottom
in there but it's the same thing as
passing a - the property - to my test
run this this is being used by different
teams in here but teams that use
Jewsbury
in order to be able to run their
applications or sorry their integration
their integration tests and the way that
you do it it's something like this where
you have an all tests suite that runs
your regular tests and before running
that those tests you just set the system
property to be integration so then what
just Barry does whenever it finds the
annotation in the air just variant right
early in the process it's it looks oh so
there's a there is an installed remap or
in here
might have had a change of heart asks
the methods method returns to just bury
ended installs that in and he can't use
that just bury and a he will use that
just very end instead of the one that
you have in there now this is the only
sort of like advances she featured that
I'm gonna cover in here it's pretty much
I am at the letter end of my talk but I
do want to get some feedback from
something that probably went too fast I
will have more questions in the future
but everybody is looking either
everybody understood everything on
nobody understood anything it's a very
dangerous place to be
so there is a tutorial in in disparity
talks about all sorts of other things
and we have a lot of time we can I can
briefly mention a few of the other
things that it can do like test scopes
and test cope listeners and god forbid
even controllable injections which is
very cool but very complex to to explain
there's a tutorial step by step it's all
function where you can run the tests in
there you know and and that's that's
pretty much it so open for questions
there no questions there ought to be a
question thank you where your server
takes a long time to start up on the
order of five to six minutes yes is
there any other mechanism than
implementing something like a global
scope for providing a singleton of that
instance across multiple test runs so
it's actually a long-lived user
environment that lives across multiple
class executions I don't think I made
myself very clear so so it's good that
you brought that up that singleton scope
in there will live for the duration of
for a very long duration for pretty much
if the code is written the way that it
is it will live for the duration of your
test of your JVM what just Barry does is
this it finds whenever it finds a new
just very end something that he has
never seen before he will go and he will
create a ninja
for that guy and then he will hold on to
that injector throughout the lifecycle
of your JVM and it we use the same
injector you can actually you know and
that's exactly what this does right it
creates starts the server he keeps that
instance of the server live forever for
as long as you want you can create a
fancy scope for yes no this is always
been from the very beginning so it's
being exactly like this in fact if you
see the code from our old-school lafi I
created something ever so slightly more
elaborate than a singleton scope because
what happens is we needed to run both
AVI and ICS tests and avi and I says
they need DPL static states to be
different from one to the other so what
I'm what I ended up doing I have a
mutable singleton scope don't don't
throw things at me for that name it's a
mutable
singleton scope where where the server
will be started once I will run all of
my off it tests and it would be shut
down I have a test that then tells the
scope to shut itself down and then the
next test will go ICS and they would
they will do that so it has always been
exactly like that the injector is
preserved preserved forever if you have
multiple declare that you sperry ends or
if you use the remember or something all
of those injectors that you created they
stay alive for the duration of Virginia
that's exactly how it operates yes Russ
if an environment setups a real biller
as you know as opposed to a fake biller
how is that torn down at the end of the
test again so there are two answers
there's a cop-out answer by and large
what you run this just to have that
reclaimed when your JVM exits writes he
reclaims all of the resources that way
you can and again that's what I was
describing that I that I had the need to
do cleanup by
you know telling the system that a
particular scope they say my Butler
really is not a singleton it's something
that can be terminated does the mutable
singleton scope rate you can declare
that that scope is finished it's not the
cleanest most beautiful code out there
but it's the better choice if you have
to live in a world where you have static
state that conflicts with something that
comes after that and then you can shut
down your server you can do anything
that you want shutting it down is
actually rather reasonably simple just
finding out when to shut down you just
need to to have your test if you if you
structure your test Suites in certain
way you can actually tell J units you
can know okay at this particular point
I'm not gonna need the Builder anymore
and I'd like for you to just shut it
down it's possible to do it this way
question of the microphone yeah I'm just
wondering if it would make some sense to
do something similar to this in Python
Python I dependency injection in Python
great juice first in there I guess the
concepts are applicable but I I have
known if anything there too there are
three major topics that are pending in
my head and none of them is Python one
of them is is extending this for like J
unit for which right now is strongly
supported J on a three extending this
support test and G if anyone is a test
in G
a fiction I'll do in there I'd love to
get your input most of the code is not
dependent on J unit except the parts
there are which is very small package
and then doing some other you know more
declarative ways for me to to to start
the server in the beginning that's a
long request from Jesse Wilson sitting
on the juice were we have the juice roll
in there Kevin Jesse and crazy bugs
sitting in the same row don't look that
row or we're all dead in here so I'm
just to clarify I mean it's not on your
list of priorities but I mean do you do
you think that it would be a bad idea or
just totally unnecessary I have never
written a Python program I have never
tested a Python program so I'm in a very
poor position to to make any judgment in
there if you write Python code and you
like the stuff and you see that there's
similarities I you know I I'd feel free
to drop by in my room will give you
spiritual advice as I use just to ask
for Kevin spiritual advice as to how to
do this the principles are very simple
in fact this is something that I tried
very hard just Barry is very simple it's
very small I tried very hard for it to
be as stupid is the word that I'm
looking for as possible it is all in all
the core of the thing with all the
frills and stuff the core of the thing
is not more than 250 lines of code it's
very small its juice it's only juice
it's just is very tiny of linear glue of
this juice and J units to bring those
two very different things
together so the principles are are
transportable there are cool things
there are other features that I haven't
covered in here that could be applicable
but other than that the code is are
there is very simple to be copied if if
that is appropriate for Python drop by
Paul how are you doing then Hey
so just on strings last question I think
Alex Martelli has a deck on a dependency
injection in Python and testability so
go see him thank you Paul more questions
one cool thing that I'd like to mention
while nobody steps up to the microphone
in there is one of the things that I
said in here there is one of the native
things that exists in juice Bay one of
the very few things that just berry adds
on top of juice is a test scope of
course because makes a lot of sense
right you can bind something on a test
scope and then you can dereference
inject that many times throughout your
test and you're gonna get the same
instance and your next test it's going
to get a new instance there is an
example of that in the tutorial where i
bind have a binding to some you know
strictly incrementing counter or an
integer annotated with something to a
strictly incrementing counter and i show
how it behaves differently if you if you
don't bind it in any scope if you bind
it and the test scope or if you buying
it in a singleton scope and this is
something that is very well supported
and there it's it turns out to be
exceedingly useful actually I would say
vital to the functioning of the system
for that to exist and the other thing
that I don't mention in the talk is a
test scope listener there is a way there
is a way for you to to do things that
you might wish in setup and teardown
without having to resort to abstract
classes that you need to override right
the this test scope listener allows you
to to be told whenever a test begins and
ends in a compositional sort of fashion
just declare okay this is a test scope
listener whenever there is a setup in
your test case there's an entering scope
gets called whenever teardown happens
exiting scope is called in that class
itself can have all sorts of fun things
injected into it and it's very useful
for certain applications it's not
strictly necessary in many other cases
if you if you if you don't do anything
you say you're gonna notice that in my
code in there and I
we didn't cheat in that regard this is
my test it doesn't have any setup code
to actually start the server generally
what happens in there is is that by
injecting a login but you need a
selenium to need it to get a selenium
you need the address of your server so
the thing that knows how to give the
address of your server is the server the
server in order to give the address
needs to be started so just like in
regular production code dependency
injection takes care of starting the
server for you the first time around
this can be made to work differently you
can if you use a test scope listener you
can cause it to eagerly start even if
you don't inject anything that depends
on the server you can trigger the server
initialization against something that
Jesse wants is for me to have this be
done in a more declarative manner but
but it's it's it's it's already
supported and with the scope listeners
more questions okay be well since we
seem to have extra time all right did
you want to try taking a stab at telling
us about controllable injection okay
can't put you on the spot - yeah one
hour and a half question in here so so
here's the cool thing okay so so picture
this my favorite example is the geo
coder I'll drop there's there's nothing
in the computer Oh drop the clicker geo
coder is my favorite example your
browser talks to your web server your
web service extracts the IP address then
it uses a database to map that IP
address to a location in the world what
lots of Google properties and lots of
things out there nothing confident about
that we do it right okay which causes
all of your tests that you run here - to
be told by the geo coder that they're
running in Mountain View not very
interesting right particularly if you
want to test things that are
internationalized and adding insult to
injury in there
every time you start your server if you
use a real geo coder you're going to
read I'm not making these numbers up
450,000 records from your database for
all of the IP addresses in all of the
locations in the entire world just so
that he can tell you that you are in
Mountain View which you knew beforehand
okay not very interesting right so what
if you could you know what if you could
tinker with that right and in general
okay let's say you you swap out the real
implementation so you don't have the
insult added to injury and there you
have a binding from your geo coder
service to something that always returns
Mountain View it's so it's a very simple
stub in there you still don't have an
ability to go and modify that result you
want to test what happens to a customer
in France or in in French Quebec do they
get the right locale in French you know
Quebec controllable injections and true
rejections is this fun thing where you
can get your you can get your
description of of your juice modules an
application pick up an application is a
collection of juice modules right you
can parse that you can feed that to
something that
tinkers with that ever-so-slightly that
you only have it's testing only code
this code that never sees the light of
day and production modifies a few of the
select bindings that you are interested
in modifying in there and it allows you
to play man in the middle attack against
your own code or in favor of your own
code and as it may right so from your
test case you would be able to induce
very support so that there's a lot of
talk about a little about the details
but the interesting part is you can
inject something in your test which is
an injection controller and say please
control the injection for the geo coder
and swap out the implementation for this
implementation and here create with an
easy
well I don't know created with something
else and then and then the server part
of your code would look at that man in
the middle that you have created as you
have told your spirit to put in place
you have told juice to put in place
really if you have something that your
test totally to override please do use
that instead of what you would do
otherwise right it's very fun this
generally without just very without
controllable injections I must say is
dealt with by creating some sort of a
static variable that your test it that
in production you expect and you hope
and you pray that it will always be no
right so you write the factory by hand
it looks at that thing whenever it's
always now it returned the real thing
otherwise your tests can go in there and
tinker around with that thing and put
some entry in there and return that is a
few problems with that including the
fact that you're polluting your
production code with tests only code and
you pray that it will always stay in
null in production and and the fact that
it's not thread safe you cannot run your
tests in parallel there's a cool thing
about gooseberry how it does control Boo
injections is if you have five tests
running in parallel each of which can
install their own controlled injection
for a geo coder to say that they pretend
to be in different countries altogether
they will not step on each other's toes
that all happens by the principle is it
uses a test ID which is basically the
name of your test class name of your
method and a random number so you can
run the same test in parallel with
itself so there's a test ID that you can
use in your test and that match is a
test ID and the server end I get set
through cookies the beginning of very CP
requests to set a cookie say this is
this is the test and the test ID for
this test is that your server-side code
looks at that cookie then it does the
right thing it figures out what is the
appropriate controllable injection all
of this is the mum
jungle you don't get to see any of that
it's all packaged for you any-any works
and it's being used already KB so let me
see if I understand this or yes so
you're saying basically that you can
start up a real production server yeah
once but you're starting it up in a sort
of enhanced mode yes and then your tests
can send little messages to that server
saying I want to inject this little mock
for you to use for the geo coder for my
test and another test can have it use a
different one and those tests can run in
parallel and they will get their own
version right controllable injection
it's very cool it's it's twisted too to
kind of wrap your head around it took me
a long time to define but it's actually
rather very simply implemented it's just
it should be quickly that is set in
there more questions please the wise we
have ten minutes that we are done thank
you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>