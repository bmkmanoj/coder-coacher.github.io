<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2011: Developing and Testing WebGL | Coder Coacher - Coaching Coders</title><meta content="GTAC 2011: Developing and Testing WebGL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2011: Developing and Testing WebGL</b></h2><h5 class="post__date">2011-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/olyxa0LVtiI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm happy to introduce Roy Williams I
work with Roy and when Roy first
interviewed at Google I think I was I
think I was your lunch interview which
basically I don't ask him any questions
to sit around and talk it was it was
clear to me that he really knew his
stuff and it's kind of weird at Google I
don't know how many of you all have
interviewed at Google before but the
interview process is difficult well
we'll say and and I remember rooting for
Roy you know hoping that I hope this guy
gets good scores because he clearly
knows a lot of things and so I was I was
watching the scores as they came in and
I was really happy to see that this was
a clear-cut case of hire and then he
came and talked to me about you know
what project you do should I should I
work on and I and I talked him into the
project that he's gonna that he's gonna
talk about now I talked him into working
on on maps which is a really important
area for Google and he's he's definitely
exceeded my expectations on what he's
done not only in a test role but on a
dev role he's written a bunch of tools
about you know when's the best time to
leave work and get home from from Google
and lots of other little add-ons like
that so without any more ado oh well
thank you James so my name is Roy
Williams and for the past 10 months I've
been working on the new version of
Google Maps has many people seen the new
maps GL version few people very cool
yeah so our newest version of Google
Maps is rendered entirely in WebGL so we
just get vectors down from a server and
just says there's a road here from here
to here and it's called this and we draw
everything on the client so with that of
course we had to develop a bunch of
tools for this brand new thing WebGL
certainly talking about WebGL here are
some of our findings here and also
announcing a new tool that were actually
just open-source this morning up with
having to do with WebGL so just by a
quick show of hands how many people here
have heard of WebGL go that's most of
the people how many people here have
actually done any 3d programming before
DirectX OpenGL ok good that's actually a
lot more people and I
thinking how many people have actually
written any WebGL code oh but there's
one dude over there good good so I kind
of figured that so this talk is gonna be
a little bit more high-level we'll spend
about half the time doing a quick
introduction to WebGL then we'll get
down to a little bit of the internals of
how WebGL works and then we'll talk
about testing WebGL we want to give you
guys that kind of preface beforehand
because I just went directly into
testing WebGL without you knowing what
it was it wouldn't really be that useful
Oh too many slides okay that video is
not gonna load but all right there we
are so first off what is WebGL WebGL is
a new JavaScript API that exposes your
end-users graphics cards directly to a
developer in JavaScript so this enables
you to do all sorts of cool things we've
got our version of maps in WebGL you may
have seen the Rome interactive music
video and WebGL you can do all sorts of
visualizations so let's take a look at
some quick demos here on WebGL so first
and foremost of course we have to show
off Maps GL because that's my my
passionate thing I've been working on so
this is our new version of maps here
we're taking a look at the Colosseum the
first thing you'll notice that when we
actually go from satellite mode into
oblique mode you get a nice smooth
transition almost like you're kind of
flying in from a satellite this is
always a lot of fun to do then as we
rotate around the building so having a
little bit of a moscow and center style
problem here where everybody else is
doing using Wi-Fi so I'm not getting
great bandwidth but when you rotate
around the building you get a smooth
transition around the building so you
can really get a feel for what the
Coliseum looks like if you were flying
in a helicopter around it hey here we go
wired internet cool so another great
example of this is to show the building
we're in right now and hopefully
switching to wired Network won't take
like a minute so here we are in the
computer science the Computer History
Museum there we can do a lot of the same
things here we can fly around the
building to get a better sense of the
building and if I get good enough
bandwidth this should work and now when
I drag drag Pegman down for street view
next demo so when it when you have
enough bandwidth you'll get a nice
smooth transition to the street view
instead of waiting 11 seconds for a
plug-in to load and here's an example of
just some games that people have written
in WebGL it's kind of a zombie style
killer except you're Little Red Riding
Hood and you're hunting werewolves
instead of instead of zombies so if
anybody saw me looking at this before
and I wasn't just like playing games
during someone else's presentation let's
go back to the presentation
yeah so you can create really rich web
applications inside of WebGL you can
create 3d games you may have seen people
porting the rage engine onto WebGL you
can create web apps that have parity
with the smartphone the API that WebGL
is based upon is the same 3d API that's
in the iPhone and in the Android it's
really fast and really responsive that
you can create all sorts of incredible
visualizations like google has a really
interesting visualization on the chrome
experiments web page where they're
visualizing search around the globe and
there's different lines flying out of
the globe based upon how many people are
searching in a given area so let's talk
a little bit about where how we got here
how we got to WebGL in my mind there was
kind of three tracks that got us to
WebGL and again this is my personal
opinion of the history of WebGL it may
or may not be correct and you may
disagree the top we've always wanted 3d
on the way
like I remember being a freshman in high
school and I just started learning HTML
took well why my going to HTML is this
new thing VRML which is totally gonna
take off and well be like you know
flying around virtual stores instead of
course that didn't quite take off but
VRML led into x3d and more recently
Google came out with our own standard o
3d all these things were about getting
3d to the web but they never really took
off because you my mind you can really
build differentiating experiences they
were very declarative you could declare
scenes how people interact with the
scenes but you couldn't build games you
couldn't build fast things and then down
below is the model of of 3d development
specifically OpenGL on the desktop we
had OpenGL standardized normal source in
1995 but more recently and importantly
for WebGL OpenGL made its way onto
embedded systems with the OpenGL ES API
now this is the API that you see on the
iPhone it's the API that you see on the
Android and for a web standard this is
really important because we want our web
standards to work across devices we
wanted to work on tablets we wanted to
work on desktops we want to work on
phones if it was if it were based on an
API only work on a desktop with a
dedicated graphics card it really
wouldn't be a viable web api and in the
middle we have javascript javascript
performance now while this isn't
strictly related to WebGL it's really
important to build the kind of
applications you want to build it
doesn't take much executing code to have
something where you can just fly around
a scene but if you want to do physics
simulations or into original
intelligence or drawing roads like we do
in maps you need to have a fast
execution environment game developers
are notorious for trying to eke out
every last inch of performance in their
applications and it's gonna be no
different in JavaScript so the v8 and
things like gave your monkey from
Firefox really all the developers have
come out and helped improve the
performance of JavaScript they make it
actually viable to use for 3d
development so now when you can do a
quick overview of WebGL of the API so
then we can use this as a to talk more
about testing the OpenGL es2 API is
actually surprisingly simple
we have these two programs that can
execute on a graphics called guard
called a vertex shader and a fragment
shader and by the way if you went to
Google i/o and these slides look
familiar that's because I sold them with
permission but I sold them from the guy
who talked about WebGL at Google i/o the
vertex shader takes in a mesh which
would be something like a 3d model and
all the sole job in life is to output a
position now we can output more things
but the only thing it has to do is say
we're in for component space is this
vertex things then get passed down to
the fragment shader and the fragment
shader runs for every single pixel
within a within it within a triangle and
its sole job is to output the color of
that pixel now we get data to these
things through the WebGL API and the
WebGL API is really all about how you
get data down there so data comes
through buffers and through uniforms
these buffers can contain things like
the positions of vertices and a mesh the
normals to those positions in the mesh
the locations of lights in the scene and
uniforms are things that are they're
basically thinking like constants things
that are constant across every run of
the of the shader so here's an example
of something that a vertex shader might
do we might get in a model of this
scary-looking monster here and the
vertex shader is gonna output where
every vertex is for that model we also
notice there's some shading going on
here so perhaps the vertex shader is
also outputting how much light intensity
each triangle should be receiving and it
would do that just through knowing the
location of the light in the scene and
the normal to the surface the fragment
shader is where you get all sorts of
cool effects that's where you get things
like specular mapping or diffuse mapping
that make the objects look a lot more
real one of the fun things about
graphics programming is that deep down
it's all a giant hack it's all about
like well this kind of looks like
lighting so that's a lot of what we do
in shaders we approximate lighting we
approximate sometimes even approximate
physics
the other big part of WebGL is that
WebGL is actually two-dimensional so
here is the simplest vertex shader and
fragment shader you could possibly have
the vertex shader takes in a position
and just outputs that position without
changing anything the fragment shader
just paints everything right so if we
pass in this is a square and clip
playing coordinates we don't really need
to get into that we just get a regular
square if we want to actually have this
have any perspective or have it be in
three dimensions we need to actually add
the 3d so now instead of just taking the
position and passing it through we're
gonna apply transformation we're going
to multiply that position by a matrix
now we're gonna compute this matrix by
multiplying together several other
matrices and if you do get into 3d
programming you'll understand the
projection the view matrix the world
matrix but these things combine to say
this is where the thing actually is so
you the world the world majors to be
where it is in the world projection
matrix would maybe control things like
the field of view but through the magic
of linear algebra multiplying them all
together gives you where things should
actually be from your from the cameras
perspective so by doing all that math
ourselves we do get perspective so I
know it's a little bit much it's kind of
a quick crash course in WebGL but big
things to understand there's a vertex
shader a fragment shader and it's really
all about just getting data down to
those api's and all the heavy lifting is
happening in the GPU inside of these
shaders cool so that's a quick 10-minute
rundown of everything WebGL let's talk a
little bit about testing WebGL
there's we're talking about three
challenges that we faced in developing
Maps GL first is you have to support a
vast array of graphics cards and
different drivers for those graphics
cards second is the api's for WebGL make
WebGL actually kind of impervious to the
rest of the webpage and third is that
there until now we're no tools to test
web gee
were to test this new language GLSL so
it's a little bit of foreshadowing for
later in the talk so first and foremost
you have to support the wide wide
variety of machines this makes the
problem of supporting like different
versions of firefox and chrome and ie
look minuscule because there's hundreds
and thousands of different graphic cards
drak graphics cards out there and
different driver versions for all of
them the good news is the spec does have
a minimal level of support that a
graphics card has to have to say it's
WebGL compliant that's it's a very low
bar though and you can actually use
features that are above that bar if
they're available there's some features
like the feature called vertex texture
fetch which are supported in some cards
not supported at all cards their cards
can support a varying number of things
that you can put into the shaders and
some drivers have bugs or some drivers
will lie so they'll say oh yeah no I can
totally do that feature in software and
when you're doing things and graphics
having it being done in software is as
good as not doing it at all because it's
not gonna be hardware accelerated it's
gonna be really slow so my
recommendations here is to go to your
local recycled PC store and buy a bunch
of cheap machines you can buy them for
100 bucks 200 bucks buy machines that
aren't blacklisted and I can give you a
link to where the list of all the
blacklisted machines are and test your
code on there you'll be amazed to see
what works what doesn't work for people
who have done game development this is
kind of old hat people are used to doing
this but something I highly recommend
and you'll find all sorts of interesting
issues with that another big part is to
code to the minimum spec as much as
possible while on your phenomenal dev
machine you may be able to go above and
beyond and use all this memory and pass
in 16 attributes you're not going to do
that on your mom's machine so by coding
to the minimum spec you help avoid a lot
of these configuration problems as much
as possible
another big part is that if you are
going to use features above and beyond
either have a fallback plan or check
availability before using them you can
crash the users browser if you start
using features that don't exist it's
kind of one of the the fun parts of
WebGL you know that we probably WebGL is
that the canvas is really invisible from
the rest of web applications point of
view from the non WebGL codes point of
view there's this black box in the
middle of this webpage called the canvas
no idea what's going on inside of there
there's no nothing equivalent to a Dom
so things like Celebi selenium or waiter
tools that are going to look for the
presence of Dom elements just aren't
going to work because of you like drew
cube or to a box in your scene there's
no good way for you using existing tools
to test for that
so my recommendation here is to use a
more of a model-view-controller type
application development as much as
possible as much as you can separate out
the state of your application from the
actual rendering of your application the
better you're gonna be so like that
little red riding-hood game if you were
gonna design that you should have the
internal state of weird little red
riding fit is how the bullets are flying
where the wolves are that should all be
stored completely separate from
rendering so you can test all that stuff
you mean test when she shoots a wolf
things still die without having to
actually render the wolf when you do
need to actually interact with WebGL
you're gonna want to fake out the WebGL
context as much as possible
so what you can check to make sure the
calls into WebGL are being made like you
expect and if you do go down the path of
wanting to compare golden images against
references or against test images
there's a really cool tool called
perceptual def which basically automates
the process of eyeballing pictures it
dips pictures not by just are they
binary the same it looks at would a
human be able to tell the difference
between these two images which is pretty
useful because you don't get as much
jitter from like rasterization or things
like that and one of the big things
you're in talking in this talk is the
new language web GLSL GLSL is the
language that the shaders are programmed
in if you squint it kind of looks like
see it runs directly on the graphics
card there
no outputs there's no printf there's no
logging the only thing that's capable of
doing is outputting a color then no
tools existed until now to test GLSL
code so with that I'm happy to announce
the open sourcing of a tool we use
internally called GLSL unit
so let's say that I have my Roy's dating
website and I want this totally sweet
beating heart on my website but I mean
integrated I'm going to change a little
bit maybe it's not going to beat as fast
so I'm going to copy that source code
over here and I'm gonna just we're just
gonna deal with a fragment shader here
to make things simple we're gonna have
our test case here so we've got our
source code here now we can declare test
cases we just set input values we set
expectations for what we expect the end
result of the shader of the test case to
be so let's go ahead and run this
and to give a quick plug to another
awesome Google tool we're using jst D
here to do all of the test case
management and farming it out to the
browser and all that good stuff and
there's some jst D people here do you
want to ask more questions about that
great so I've run my test case and I've
gotten some failures on my test case for
the lower left-hand side of the heart
failed we expect it would be some it
would be some shade of red but it failed
it was actually clear now I know for
most people who have ever written code
before this seems trivial it's like yeah
you just ran a unit test this did not
exist for GLSL before you could not do
this before cool so maybe we go back to
our code let's see what's going on here
if we plug our shader back in we see
okay here's the problem
we're only rendering half of the heart
I'm not gonna get too much into the math
here but if you ever drew shapes and
your calculators in high school you'll
recognize this is one of the equations
you can do to draw heart there to draw
heart shaped function cool so just like
with any other testing framework I can
change my source code rerun the test
case and get the next failure
the same
okay moving on I don't know why why work
in the same field here maybe in there
wrong directory
yep
so we can change our code we can iterate
we can get out the actual values one of
the big things here is that were able to
get out intermediate values from shaders
the way this is working is instead of
actually rendering the heart we're
rewriting the shader code to output a
individual triangle now inside of that
triangle we're encoding the value that
we're trying to extract in color so in
the kit in this example here we're
testing to see whether or not the
fragment color is what we expected we
check the equivalence and in color we
ship that out to JavaScript we can then
extract that value by reading the color
and decoding it we see that the test
case failed and then we go through and
we extract each individual value from
the shader so let's try this one more
time
yes I didn't sacrifice to the demo gods
did I well yep alright so that's the
general idea behind GLSL unit so we're
really excited about this it's a
framework that if you look at the the
source code here if you've written any
Jasmin code this will look pretty
familiar to you we define everything
described in it we have sweets and test
cases we have a suite of fragment shader
test cases a suite of vertex shader test
cases so this will enable us to actually
test our shaders individually outside of
the full rendered image so this is up on
Google code right now there's a project
GLSL unit GLSL - unit so you can go
ahead download it and play with it if
you want I've also found this really
useful just for writing my own shaders
because that you can get that iterative
experience like you would with any other
normal programming language
Oh city view guys some WebGL resources
some really useful so I know we've
talked about a lot of stuff here most
people here aren't familiar with WebGL
so my goal for this talk is to have
something that once you sit down to your
desk start playing with WebGL you can
look back at this talk on YouTube and
have something hopefully have some stuff
that makes more sense then but when you
want to start learning WebGL is a few
researches I highly recommend the
learning WebGL website really useful
website for the running WebGL quick
caveat about that is that the person is
also who's writing this these tutorials
it's clearly also learning WebGL as he's
writing them so his later tutorials are
way better than the first tutorials the
Mozilla developer Network has a lot of
great information about WebGL in general
and one of the once you start getting
deeper you start wanting to learn more
about WebGL you're going to start
running out of resources and that's when
I recommend going to the OpenGL es2
books because the spec is exactly the
same it's just a web implementation of
OpenGL es2 there's a lot more resources
for that because it's useful for iPhone
development and things like that so you
can usually just pick up an OpenGL es2
book and it'll have most the resources
you need then you can do the translation
between the es 2 calls and the web GL
calls pretty trivially and one of the
things I want to talk about is
frameworks you'll notice when you start
writing WebGL code the amount of code
you have to write to do something
seemingly trivial is a ton of code to
draw a cube it's probably 40 lines of
WebGL code now the reason for this is
that I'd almost rather have the actual
library and standard be more low-level
so that way people can come out and
write great api's on top of it in
libraries and they can you can use those
libraries to get a simple view of the
world but if you want to be the John
Carmack of WebGL you have the core or
low-level libraries available to you so
you can optimize everything that you
want there's a bunch of really good
libraries for WebGL now and there's more
spinning up every single day 3GS is
probably the most well established one
out there there's another one that I
really like X 3 D 2 X 3 Dom which is
attempting to almost bring the VRML idea
back but built on top of WebGL so
instead of creating a cube by buffering
objects and textures and all that stuff
you just add stuff to the Dom and their
library will take care of actually
rendering it in 3d for you a three is
another good library there's a new 1j 3d
which unfortunately is the same name
it's the Java 3d library and then
there's geology which is a bit more of a
games engine for for writing WebGL stuff
so cool that's about all the stuff that
I wanted to talk about today I wanted to
open up for questions
yeah totally add its I didn't want to
get necessarily too much into detail um
you can read back stuff from the
graphics card in JavaScript there's an
API called as part of GLSL um there's an
API called read pixels that you can use
just to get the entire state of a canvas
into a binary write in JavaScript so
then yeah yeah and you can use that and
then use that to decode the color and
party on again all the stuffs
open-source so if you want to take a
look to see how we're doing that it's
sort of available to you yep on geocell
unit are you rendering are you getting
that unit test run in the CPU or the GPU
the GPU um so that's actually one of the
unique things about is that we are
running directly in the GPU there's no
Mesa emulation there's nothing like that
so bugs that are in the GPU we will hit
to the bug I was trying to hit but I
wasn't for whatever reason is that
there's also divide by zero error in the
code that I was testing and this
particular graphics card will do
different things when you do divide by
zero yeah so that's one of the big
advantages of it is that it's running
directly on the GPU I have another
question is you mentioned graphics cards
drivers is there a way to work around
those meaning if you're setting up your
your app you know you have a bad
graphics card and driver do you abort
running in WebGL yeah so there's a few
things you can do there one is that the
browser manufacturers are taking care of
a lot of that for you so I mentioned a
black list before Chrome has a black
list of devices that it just won't run
on they have known bugs they just or
they or chrome itself will try to work
around them in the case like there's
some GPUs that say they support certain
features but they don't they actually
support them a software not hardware
Chrome will actually lie to you and say
does the GPU doesn't support it even
though the GPU does claim to support it
Firefox takes the approach of actually
having
whitelist instead so Firefox says it
will only run on these GPUs so a little
bit of a different approach but usually
they'll take care that for you if your
application gets sufficiently
complicated like maps GL did you sign up
for maps Jail no but when you sign up
for maps GL it you'll notice this has
testing your browser to make sure you're
capable so we're actually running a few
test cases on your browser to make sure
that you're gonna be able to run WebGL
one of the interesting parts is that you
don't you can't actually get access to
the graphics card or the driver that
you're running on and most games they
would work around look at the graphics
card and say okay we need to work around
this bug or that bug we can't do that so
we have to do things like benchmark to
guess the capabilities of the graphics
card
yeah
so there's a few we just opened its
source it was the gjs unit James is that
what it was called yeah gjs unit which
is Ivan look too closely through API
it's a little bit different from Jasmine
jasmine has this very nice BDD style
development with the describes it so on
and so forth and the G the GLSL unit
code is completely inspired by by that
you have a test suite a main expects
that's the other stuff we have is more
class-based there's less like global
variables that are being set so it's
kind of just two different approaches to
testing the other big thing about ggs
unit is that it runs directly in v8 it
doesn't spawn up a browser where's the
horse jasmine needs a needs a browser to
Ryan and there was a question back here
yes now how do this the security of jail
so the security WebGL is definitely an
interesting topic there's a so I don't
works rocking the WebGL too well team
I'm just a user of WebGL but we've we've
tested what we've tested we've got a few
layers of security in WebGL at least for
Chrome I can't talk too much what
Firefox is doing the WebGL process runs
in its own process so it's completely
sandbox from the rest of the machine so
if you have some rogue shader code it's
not going to get too far
additionally chrome chrome looks at
their shader code before actually
executing it and looks for things that
could be bugs for example one of the
hypothetical attacks that came up was
that you can do SD users machine by
writing some shader codes that never
exits chrome for example can prevent you
from doing that by not allowing you to
have like say an infinite loop yeah it's
it's interesting it's definitely an area
where we're pretty passionate about
because it is you're running in kernel
mode a lot of operating systems what the
the graphics card can only do one thing
at a time
so if you can lock up the graphics card
you can lock up the machine so yeah it's
something the chrome team definitely
takes really seriously
any other questions up one more how do
we test the end application but it yeah
so we alluded to that a little bit or a
bit when we talked about having more of
like an MVC style application but when
you're doing the actual you for doing
end-to-end testing it gets tricky you
you like the mouse movements for example
are different you know they're like even
just the location of the mouse on the
screen of location of the mouse on the
canvas because you need to like compute
that yourself right like if you're
interacting with an object in the canvas
like you don't get like a little red
riding-hood was clicked on you get like
the mouse is here is a little red
riding-hood there yeah so that's it's
definitely growing area for for having
more test frameworks written for it
we've taken approach of using unit
testing like we showed here and then
doing golden image testing so we'll get
the application to a known state render
it and then compare it with a golden
image so if something goes horribly
wrong
we can we can just know from the from
the image in an automated fashion
something went wrong cool well thanks
everybody I'll be around if you have
more questions about WebGL yeah thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>