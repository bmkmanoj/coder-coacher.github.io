<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Monads and Gonads | Coder Coacher - Coaching Coders</title><meta content="Monads and Gonads - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Monads and Gonads</b></h2><h5 class="post__date">2013-01-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/b0EF0VTs9Dc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm going to show you some code today
now ordinarily I don't like talks with a
lot of code in them because I think
they're tedious and boring and this talk
promises to be no exception but code is
the story and so it's not possible to
tell this otherwise so the topic this
morning is monads monads what are monads
monads are the strange mysterious weird
but powerful expressive pattern that we
can use for doing programming and they
come with a curse the monadic curse is
that once someone learns what monads are
and how to use them they lose the
ability to explain it other people
there's lots of evidence of this on the
web you know go and search for monads
tutorials burritos any of those things
and you're going to find a lot of really
confusing material so today I'm going to
attempt to break that curse and show you
monads for what they actually are so
we're going to start with functional
programming that if you if you can't do
functional programming then none of the
rest of this is going to make sense but
I'm assuming you're all professionals
and this should not be difficult
material so there are two senses of the
term functional programming one of them
simply means to program with functions
so we'll look at that first functions
enter mainstream programming with
Fortran 2 this is a Fortran 2 function
at that time lower case hadn't been
invented yet
so well everything was in uppercase but
it looks quite a lot like a modern
function I mean it starts with word
function and has the name of the
function and parameters wrapped in
parentheses separated by commas really
conventional stuff so as just a
subroutine that had the ability to
return a value and it returned that
value in a slightly strange way using an
assignment statement which would assign
a value to the name of the function and
then the return statement would deliver
that to the caller that has been changed
since then and
now everybody has a return statement
that takes the value and that works
better or in expression languages the
last expression evaluated by a function
is the implied return value but what we
call functional programming only becomes
interesting when we have functions as
first-class objects so we can take a
function and pass it as a parameter or
store it in any variable or stick it in
a field and in a record that's when it
becomes interesting and then we can have
higher-order functions in which you have
functions which operate on other
functions as arguments and this all
became really good stuff with the
invention of scheme and in scheme we
have lexical closure which means that
any function has access to the variables
in the outer function and it turns out
that was an enormous breakthrough and
that is now finding its way into
mainstream languages anyone have any
idea which was the first mainstream
language to have this feature
it was JavaScript that's right
javascript is leading the way so the
other sense of functional programming
sometimes called pure functional
programming and it means functions are
mathematical functions which is quite
different than subroutines that return
arguments because a subroutine is
allowed to do mutation and in a purely
mathematical function that doesn't
happen a function for with some input is
always going to have the same output and
the argument in favor of that style of
programming is it makes programs a lot
easier to reason about because you don't
have bugs that will occur as a result of
side-effects of something else happening
if something works it's guaranteed to
work that way correctly till the end of
time and that could be hugely beneficial
but there are problems that come with
that so you could think of mathematical
functions as being maps you know it will
simply take some parameter or parameters
and map them to some value and that
mapping is constant and so it always
works that way and so it's easy to
predict so whether functions are
implemented as computation or as
Association is just an optimization
trick
all functions should work exactly the
same way either to either time so you
know the difference is served like the
difference between memoization and
caching caching is a deal with the devil
right you know we have something which
is likely to be wrong but is sometimes
right and we don't know when it
transitions from being right and wrong
with memoization that never occurs once
it's memorized it's right and will
always be right so we can take any
ordinary programming language and print
it into a purely functional programming
language by deleting stuff so we can
remove everything from the language
which could have side effects so we can
remove the assignment statement we can
remove loops and use recursion instead
if we need repetition we can freeze all
array literals and object literals so
that once minted they cannot be modified
in languages like JavaScript it means
removing date because every time you
call date it returns a different value
that's mathematically absurd right every
time you call function it should return
the same thing same with random every
time you call random you hope you get a
different value but that's that doesn't
make sense mathematically so we want to
remove that so remove all those things
from our languages then we'll have
purely functional languages and we'll
also find we're not going to be able to
get anything done anymore
because most of our programs are not
doing pure computation they're
interacting with the world and the world
is constantly changing and if our
programs can't change with them then
they become brittle and ineffective
because in the real world everything
changes and immutability makes it hard
to work in the real world now they're
pure functional programming languages
like ml and like Haskell is a better
example and Haskell is a brilliant
language and they were doing interesting
computations with it and then there was
the idea let's try to do practical stuff
in it and then suddenly it gets really
really hard that kind of hard is
sometimes called impossible because you
can't have any side-effects you can't do
I owe
how do you interact with things without
being able to do IO without being able
to mutate so they've discovered a trick
there was a loophole in the function
contract and that loophole is that a
function can take a function as a
parameter and once it does that every
time a function is called with a
function every function is going to be
different right because every function
is a unique thing which is closed over
the thing that created it and so it sort
of gives us a way to escape from the
side-effect free thing you just need to
start thinking about how you compose
functions in such a way that you have
the illusion of having mutability
without actually mutating anything
so the Haskell community had reason to
adopt something called the IO monad
because it gave them the ability to act
as though the language had i/o even
though it didn't and so as they're
calling things they can be assembling
state and that state kind of follows
forward in the computation and it kind
of works and it's like Ray you know it
could be used for practical programming
except it's kind of hard and it turns
out that you want mutation because you
know that is how the world works and so
the i/o monad is a solution to a problem
you should never have but it turns out
there are lots of other monads and so
they're still worth taking a look at now
there are some who will say in order to
understand monads you first have to
learn Haskell and you have to learn
category theory if you don't know these
things
there's just the ways a way to start you
can't learn monads I think that is true
in exactly the same way that in order to
understand burritos you must first learn
Spanish and they're true in the same way
in that neither is true it turns out you
can do a lot of stuff with burritos
without knowing any Spanish you can
order them you can eat them and enjoy
them you can even learn to make them you
can even learn to invent new kinds of
burritos which you and your friends can
enjoy and you can do that without
learning any
- now I'm not saying that you shouldn't
learn Spanish there are lots of good
reasons to learn Spanish you can learn a
lot more about Mexican cuisine for
example and that will allow you to make
burritos and other things which are more
authentic and perhaps even better it'll
allow you to have interactions with some
wonderful people you would never
interact with otherwise and if you're
one of the job creators it gives you an
opportunity to talk directly to the
people who are actually doing your work
for you that's a good thing right so in
the same way it's good to learn Haskell
Haskell has a lot of good stuff in it it
can teach you a lot it's a good language
to learn it's just not necessary to
learn Haskell in order to understand
monads now some people will disagree
with me and say no you have to start
with Haskell and I say no if you have
the chicharrones you can learn monads
without Haskell now there some people
who say well you at least have to start
with the types that you need a really
strongly typed language or a super
strongly typed language in order to
manage monads that you have to
understand this before we begin and I'm
going to tell you no that's actually not
true either Haskell has a wonderful type
system in it it does a lot of type
inference so that you can understand it
will try to figure out all the types but
it doesn't always go right and so if it
is trying to solve your program and it
finds an inconsistency
it stops and you get this completely
opaque message and which is indicating
that if not an inconsistency in a place
which is probably miles away from where
the error actually is and so getting
that stuff to work and compile can be
really hard and once it's done there is
folklore which says having gone through
that wringer you're guaranteed your
program is going to be error-free
and it turns out it's not that there are
subtle errors that happen in Haskell as
happen in all other languages and the
type system actually gives you no
leverage in dealing with that stuff
there's just stuff gets complicated and
when there's complexity
go wrong and that happens in all
languages it turns out that it's easier
to reason about monads if you don't have
to deal with the type stuff you don't
actually need to understand what that is
in order to build a monad another some
will say no that's not true you don't
dare go that way otherwise but I say my
friends if you have the wave hose you
can so what do you say we sack up and
look at some monads turns out the
language you need to learn first is
JavaScript because it has the
higher-order function stuff that we need
and it doesn't have any of the type
stuff to get in your way so you can just
think about what's going on so what we
have here is a story of three functions
we have a function called unit that
takes a value and returns a monad we
have a function called bind which takes
a monad and returns a and a function
that takes a value that returns a monad
that's it so all three of these
functions return monads and that's it
that's monads thank you very much so
you're probably wondering still what
what is a monad a monads an object and
in this case it could be something else
but generally it's an object so if you
know anything about JavaScript you're
looking at the unit function you're
going weight unit is a function that
takes a value and returns an object so
it must be a constructor right and yeah
right that's it that's exactly right so
unit is constructor so nothing magical
there so all the magic must be in the
bind function so and that's it and
there's not a lot of magic so in so
there are three axioms that you have to
hold in order to be a monad the first to
describe the relation between bind and
unit which is basically that unit
creates a monad that represents some
value and the bind function allows
another function to have access to that
value now that's that the interesting
axiom is the third one which tells us
how we can do composition on the bind
method that we can have nested bindings
and that does the same thing as calling
bind with a function that calls bind
that's it that that is monads now we can
make it easier to deal with you
ads by converting it from the functional
notation into methodical notation right
that's that's a really easy thing to do
in JavaScript everybody does that all
the time you need to understand the
mapping between functions and methods
and once you can do that and we can very
easily transform the way we invoke the
bind method instead of saying bind
passing a method or passing a monad will
call the monads bind method it's just an
easier way to do that so in in a lot of
languages or in some languages say
Common Lisp you would recognize that
there are lots of different possible
varieties of monads that you might want
to implement but they all have the same
basic pattern so you'd want to implement
some kind of macro to make it easier for
defining all those different kinds of
monads javascript unfortunately does not
have macros but it does have functions
and so we can create a special kind of
function called a macro which acts like
a macro which helps us to do that kind
of thing that macros do and then let's
see and so this is one of those macros
I want to say something about the
coloring so you've all seen syntax
colouring right that's something we put
in our text editors to make it easier
for kindergarteners to do programming
because each of the elements of the
language is a different happy bright
color and so it's easy to recognize oh
that's a variable and that's the string
and so on I don't get a lot of value out
of that because I'm more sort of a
grown-up and I'm a professional
programmer and I really don't need the
colors to figure out what's a variable
and what's a comment but when I'm doing
functional programming I do I would like
to have color help me deal with the
nesting of functions and deal with the
closure so I wish someone would make a
text editor for me that does this so I
want all of my global level stuff to be
white all the top-level functions I want
them to be green the function was
defined inside of those would be yellow
the ones inside of those would be blue
and
but the color of a variable is the color
in which it was defined and that allows
me to see how things close it gives me a
view of the visibility of variables and
their life expectancy and so on and that
turns out to be really useful stuff so
I'd really like to have this kind of
colorization and I'm going to be using
this sort of colorization through the
rest of this talk okay so so we've got
our macro and we're going to use it to
define a monad and we're going to start
with the identity monad so the identity
monad will build the identity
constructor and we'll call the identity
constructor passing it the hello world
string and then when we call a monad
alert of dot bind passing alert that the
alert function as its method will get
the hello world thing so this is the
simplest possible or the simplest useful
slightly useful monad the identity monad
so let's look at the axioms again using
the methodical notation that we just
came up with we previously looked at it
functionally now we're going to look at
it methodically
and I think it actually makes more sense
in this notation I think it's easier to
see what the relationship between units
and bind is but even better is the thing
that happens in composition that we now
have this thing where we've got a monad
and we call bind and it returns another
monad and we can call bind again this is
a much easier composition pattern than
the other one in which we had bind
nested inside of bind because with the
nesting you have to read the expressions
from the inside out and that's a hard
thing for us to do but in the methodical
form we can read it from left to right
and so composition is a lot easier I can
just keep tacking things on and the
thing keeps getting longer more
interesting more complex now any of you
who have ever done any Ajax programming
might notice wait a minute there's
something about this pattern that's
familiar I've got an object and I call a
method on it and I call another method
on the result where have I seen that
before
well it's the Ajax monad
right all of the Ajax libraries do this
jQuery Yui everybody we've been doing
this for years it turns out it's we've
been doing monads all along so um this
is a example of something I did in 2001
this the interstate library was my third
javascript library the first one was
just something to help me manage the
differences between Netscape 4 and ie 4
which were horrendous
and after I wrote that I looked at what
sort of patterns we were using in using
it and then trying to figure out a way
to incorporate more of that into the
library to make it easier to use and
this is my third iteration and in this
one I realized that if I have an object
which wraps a Dom node in this case of a
text form node and if that object that
monad keeps returning itself and I can
cascade all of these other things on it
and it becomes really expressive and
lots of other people figured this trick
out as well and so this is now standard
equipment in Ajax libraries in 2007 I
developed a system called ad safe which
was intended to make the web safe for
doing online ad online advertising and
it took the same idea of taking a node
and wrapping it in a mode addict object
but also added a security dimension to
it so it wouldn't it would guarantee
that there was no way that the node
could be extracted from the object so
that meant we could give one of these ad
safe nodes to a piece of untrusted code
for example an advertisement and be
confident that it could not break the
containment that it was only able to do
with that node what we intended it to be
able to do with that node and nothing
else it couldn't use it to traverse the
rest of the document it couldn't use it
to get to the network it couldn't use it
to steal our cookies it couldn't do any
of those things all it could do was
display an ad in that window and ad safe
worked and it used the same monadic
pattern um so let's improve our macro to
allow us to do a jack
stuff so we've already seen we've got we
can take an object and call bind on it
but what we really want to be able to do
is call a method on it and so the way
we'll do that and also we want to be
able to have methods pass some variable
number of parameters as well so we'll
expand expand our bind method to now
take an optional second parameter which
is an array of the arguments that we
want to get to the method and we'll
extend our our macro by first creating
an a prototype object which will be an
object which inherits nothing this is
we're going where we're going to keep
the methods of the monad we can use
object.create of null to make that for
us that makes an object that inherits
nothing this is a great new feature that
came in with es5 and then when we create
our monad we will have it inherit from
that prototype object so anything that
goes into the prototype object will be
inherited by the monads that we make
then we'll modify the bind method to
take the second argument which is the
set of arguments that we want to pass
into the method and unfortunately
because of a profound stupidity in the
way JavaScript was designed we have to
manipulate the arguments object and
that's really hard because it is not a
real object and so it's just the things
you have to do to it are horrible
fortunately es6 the next edition of the
language will probably have this dot dot
dot operator which happens to do exactly
the right thing this is going to be my
second favorite feature in es6 if it
ever comes out so I'm looking forward to
that because it took those three
extremely ugly lines and turned it into
one very neat line which obviously does
what it does we're then going to create
a unit method on the constructor which
will allow us to
add additional methods to the prototype
and it simply takes its arguments and
assigns them to the prototype so that's
pretty easy and it also returns unit so
that we can then call dot method method
method on the constructor so it's
monadic in that dimension as well but we
can do even better than that it assumed
that the methods that are the functions
that get called to method understand
about monads but in some cases we want
to be able to wrap functions that know
nothing about monads but have them work
in the monadic context so we're going to
add another method to the constructor
called lift and lift we'll take an
ordinary autumn and add it to the
prototype but it will wrap that function
in another function which we'll call
unit and bind as suggested in the first
two axioms so that it allows that
function to act as though it knew about
monads even though it didn't so it'll
call bind for us and it will then wrap
its result in a monad if it needs to so
this makes things a lot easier so let's
use this one so we're going to call our
macro it again and to make our Ajax
monad
and we're going to use lift to turn
alert into a method on it so we could
change the name here but we're going to
keep the name the same we're going to
take the alert function and use it as
the alert method so now I can call the
Ajax constructor to make my monad and
the monad now has an alert method and if
I call it it'll say hello world array
turns out we've been doing this for
years we just didn't know it
Ajax has always been monadic that one of
the the difficulties we have in some of
our modern languages is the problem with
null null is the thing that represents a
value that is not there and if you try
to do something to know generally
something bad will happen sometimes it
seems that Java was optimized for the
generation of null pointer exceptions
and so you end up having the
nullpointerexception doesn't actually
ever tell you anything except that oh
there was a null that you didn't check
there to avoid and so your code tends to
get filled with lots of if null don't do
that if null don't do that which is just
a waste of time right it's completely
unproductive we knew we didn't want to
do that you know we shouldn't have to
say so every time we touch a variable
that might want to know so there's a
thing called the maybe Nomad the maybe
monad takes no pointer exceptions and
simply removes them from your models you
never have to worry about them anymore
it's similar to the way that nan works a
long time ago in Fortran and other
languages if you ever accidentally
divided something by zero your program
would stop you no exception thing
crashes cours
dun stops so as a result you had to
write in front of every division but if
we're dividing by zero then don't do it
you never intended to have it happen but
you had to guard against it all the time
so we now have nan and nan represents
not a number it's sometimes the result
of dividing by zero and so if we divide
by zero we get nan instead and the
program keeps going and at the end you
can ask oh by the way is the answer nan
and you know that okay something
happened we can ignore the result so
that's much nicer than having to put
guards around every operator to make
sure that nothing is going to go wrong
the maybe monad allows us to do a
similar thing with pointers or
references so we don't have to worry
about that anymore
they just those errors don't happen so
we're going to modify our macro in order
to be able to deal with maybe monads so
we're going to add a parameter to the
macro which takes a modifier function
and that modifier function will allow us
to intercept things that are with that
we're constructing so the unit method as
part of its doing work we'll look to see
if the modifier function is present and
if so it will call it
passing the Monad and the value and that
will allow that function that we pass in
to do something with the thing that
we're making so one way we could do that
is we can use the macro to make a maybe
macro or maybe not monad by passing in
this function which will looked at the
value and see if the value is null or
undefined and if it is then we go okay
this is going to be a null monad and
it's going to have this amazing property
in that we're going to change its bind
method to do nothing it'll simply return
the monad so it turns it into an
identity function and crashes don't
occur so now we can make our maybe monad
this case we'll make a null one and if I
call bind on an alert nothing happens
it's great so if you incorporate this
kind of stuff into your into your system
you never again have to worry about null
pointer errors it's just amazing just go
away bind will prevent it ever from
getting called and everything works
right which is nice it's a liberating
thing so that's our friend the monad
that's really that's it
and there we looked at three specific
monads the identity monad the Ajax monad
the maybe monad there are lots more but
they're all variations on this pattern
and now that you've been through this
talk you might want to go look at the
other monad tutorials so you know go to
Bing and Google for
monad burrito and see what you find it's
going to be baffling stuff but but it'll
work so I have some time left so I want
to talk about concurrency concurrency is
when you try to make lots of things
happen at the same time and there a
number of models for how you do that the
most popular is to use threads and the
problem with threads is that they are
evil with respect to mutation if you
have a process that's trying to do
read-modify-write and another process
that's trying to do read-modify-write
and they're doing it on the same memory
there's a strong likelihood that they're
going to
clobber each other and it's called races
and races are rendus ly bad for
reliability the way we mitigate that is
with mutual exclusion mutual exclusion
has its own set of problems generally
they can cause bad performance problems
or more likely it's going to cause
deadlocks and starvation and that's a
bad thing too there's there a couple of
other alternatives one of them is to go
with purely functional programming
because when we're purely functional we
never mutate and so that's not a problem
but not mutating is its own problem
another alternative is turn-based
processing this I think is that the
right way forward so in a turn-based
system everything is single threaded and
as a result we are race free and
deadlock free and that turns out to be
great but it requires that we respect
the law of turns the law of turns says
your code must never wait it must never
block and it must finish fast attorney
cannot sit there and loop waiting for
something to happen it has to get out as
quick as it can so not all programs can
be easily adapted to that but it turns
out quite a lot of them can so
event-driven systems tend to be
turn-based message-passing systems tend
to be turn-based you don't need threads
you don't need mutual exclusion it's a
much simpler programming model and it's
really effective turns out all web
browsers use this model most UI
frameworks use this model so it's
something we've been doing a long time
anyway we're now seeing this model
getting more popularity on the server
side so there's Elko for Java there's
twisted for Python nodejs for JavaScript
to take the same turn-based model and
make it available on the server now some
people complain that asynchronicity can
be hard to manage and there are some
things you need to do in order to adapt
to it one of the problems is that if you
have multiple things that each serially
depend on each other of the naive way to
write that is with nested event handlers
and that turns out to be extremely
brittle pattern so you don't want to do
that
a much better alternative is to use
Promises Promises are objects which will
represent a future value and a way of
interacting with that future value so
promises are an excellent mechanism for
dealing with a synchronicity every
promise has a corresponding resolver
which is used ultimately assign a value
to that promise and once the value is
assigned then interesting things can
happen so a promise when it's created
will have one of three states well it'll
its first state will be pending and
depending on what happens to it in the
future it can change to either kept or
broken where it may always be pending so
a promise is an event generator once the
promise is resolved then it can fire
events on on consumers who were
interested in the result of the promise
so at anytime after making a promise an
event handling function can be
registered with the promise and those
will then be called in the order in
which they were registered when the
value is known and a promise can accept
functions that will be called with the
value once the promise has been kept or
broken and we can do this with the when
method the when is sort of like on it
allows us to register event handlers but
it will register two of them one to be
called
if the promise is kept and the other to
be called if the promise is broken so
here's a function for making a a promise
calling it in Val so a Val will produce
an object and that object will have
three methods
keep break or promise promises not
actually a method it's an object which
represents the promise itself so I can
take the promise and hand it to you and
in the future when I know what the
result of that promise is I can call
either keep or break and then your
promise will change its state and good
things happen so here's an example
so one of the problems with file system
api is going all the way back to Fortran
is that they block if I want to read
something from the card reader or from
the terminal or if I want to send
something to the printer or to the disk
drive my program stops until that
operation has completed in some cases my
program can stop for a long time I don't
want to stop because that breaks the law
of turns law of turn says I never stop I
never break I have to finish and so a
way to do that would be to have the file
system instead of blocking it
immediately returns a promise so my
program can then continue going I'm not
blocked on it so here I've got a read
file instruction name is probably the
name of a file and it's going to return
a promise and I can tell that promise
when you are resolved call my success
function and it will receive the result
of the file operation and things are
good and if the file operation failed
for some reason you know like file not
found or whatever then call my failure
function instead now you might be
wondering why do you call my failure
function why don't you just throw an
exception we have to think about this
stuff as time travel so what an
exception does is it unwinds the stack
to some earlier point in time and we can
then recover from that point but in a
turn-based system the stack gets reset
all the way down to zero at the end of
every turn so there's no way I can
unwind into a previous turn because the
stock has gone there's no way to go back
in time you can only go forward in time
so we need a time travel mechanism which
goes forward turns out promises do that
right that's that's the whole point
and so promises can have a a positive
consequence or a negative consequence
that negative consequence is like an
exception so the way we deal with
exceptions is by having failure
functions instead which will be called
once we in the future once we know that
the thing actually failed
so I just I think I said all of that
exceptions modify the flow of control by
unwinding the state turn-based system
the stack is empty at every turn right
so one of the nice things about the way
failure functions work is that we can we
can nest promises so each when actually
returns another promises promised on
three on the resolution of that
particular when and we can cascade those
as well so we can say and when we know
the result of that do this when we know
the result of that do that and so on and
if any of those fail and if they don't
specify their own failure then the
failure propagates or its contagious it
goes forward and so the last one the
last failure specified will catch all of
the previous things so it acts sort of
like a try except this is something
that's happening over many many turns so
it gives us a way to manage a
synchronicity so one of the nice things
about promises and the when method is
how they compose so when I say not when
dot when that's doing the same thing as
a when passing in a function which calls
when on another promise and some of you
might be thinking wait a minute this
looks eerily familiar where have I seen
this before and you might be thinking
this is this looks like the third axiom
I would say you are right this is the
third axiom it turns out promises are
monads now they're a different kind of
monad because of all the other monads
we've looked at the value of the monad
is known at the time that it's created
and because it's purely functional they
can't that value cannot be modified this
is a little different because we don't
know the value at the time of the things
created that's going to be resolved in
the future so it gets filled in later
also because monads don't have the the
problem where they might fail to ever
get that value we only need to provide
one function to bind but when needs the
ability to have two functions because it
has to deal with a failure case but
otherwise it works exactly
like the monads so let's look at how we
could build the vowel function in order
to do this now this is about a page
worth of code and and I'll show you the
page at the end but you're not going to
be able to read it so I'm going to be
zooming in on pieces of it so we've got
a a function that is going to return an
object and that function is going to
have a couple of methods or functions in
it that the yellow function will close
over that's one of the nice construction
patterns that we have and the thing that
we're assigning to Vow is not the green
function it's the result of the green
function because we're invoking it here
at the bottom so that little pair of
parens is really easy to overlook but it
turns out is really critical to
understanding this so just leaving it
hanging out there like a pair of dog
balls I don't think is useful to the
reader
I want the reader to have a bigger clue
that this is important so I recommend
wrapping the entire invocation
expression in parens so it makes a
little easier for the reader to see this
is all part of the same thing this is
important if I see a function in parens
that probably mean something I need to
look for that ok so let's zoom in on the
make function it's going to have a
couple of arrays where it's going to
keep the the success functions and
failure functions that get registered
with it it's going to have a variable
for the ultimate fate of this promise
once it's known its status starts off as
pending JavaScript doesn't have symbols
doesn't really need them because strings
were implemented correctly two strings
containing the same letters are equal
which is be stupid for them not to be
equal win it and then it returns a an
object containing the break method the
keep method and the promise itself which
is an object will look at its
construction in a moment and break and
keep both call a herald function
which is going to announce to the world
the resolution of this promise so we'll
look at Harold Harold can only be called
once so if the current state is not
pending then we can throw in this case
throwing is ok because it's a local
thing it's not something that we need to
throw into a different turn and we'll
set the fate and we will enlighten the
queue of waiters and let them know that
the fate is known and we'll then zero
out the the two queues to make sure that
none of those functions ever get called
again
ok so let's zoom in on something else
now to zoom in on the promise the
promise we'll have a property with just
identifies itself as a promise to make
it easier to recognize it and it
contains the when method the when method
is going to register the to event
handlers that depend on the result of
the promise and that will do that will
depend on the current state of the
promise if they're pending then they
simply get added to the queue if the
promise has already been resolved then
it will depending on whether we're
relying on the failure case or the other
case will in queue it and then enlighten
immediately so it doesn't matter when
the promises resolved versus when we
register with the when method so there's
no race there you can register after the
promises resolved and it works exactly
the same way so you don't need to care
about how that race may occur and then
at the end we return the promise then
this is the business that happens when
we include the thing I'm getting bored
now so I'm just going to skip through
this stuff and there's that so the code
is available on github if you want to
play with it it's it's all written in
JavaScript this is it there's just one
page you might want to write that down
so our friend the Monad so we saw the
identity monad the Ajax monad the maybe
monad and the promise monad I contend
that promises are monads which this is
my contribution to this I guess I don't
think this result had been known before
I have some oh and don't forget your
semicolons people it's really important
I've got some further viewing for you
Carl Hewitt was at MIT I think he's at
Stanford now he came up with the actor
model which inspired the development of
the scheme language and a lot of other
stuff I think the actor model contains
the solution to most of our problems but
Carl has not written any accessible
material about it it's all kind of
you've read it obviously it's it's scary
stuff but he did do an interview with
channel 9 at Microsoft it's actually a
very nice introduction to the stuff so I
recommend you take a look at that
channel 9 apparently likes the really
long URLs and I doubt that there's
anybody in this room who could actually
type that in but I'm sure if you go
search for it you should be able to find
it then Mark Miller is one of the first
people to come up with promises which is
based on an idea called futures which
also came out of Carl's actor/model
he's implemented a number of languages
and you just saw an implementation in
JavaScript he has a really interesting
couple of talks that are available on
your YouTube which talk about this and
some of its implications for doing
automated contracting and M financial
instruments and lots of other really
interesting stuff so I recommend you
take a look at that as well it's
certainly worth your time and Miller
works here by the way he is a Googler
good guy and that's it that's all I've
got for you this hour thank you and good
night
so I'm guessing you have a few minutes
maybe to answer a couple of questions in
an effort to keep the video in sync with
questions I've got a lab here so I will
walk around to anybody who wants to ask
a question just waking Patrick and well
we're we're talking about that nothing
confidential please this will be going
public afterwards so you want to start
thanks for the talk I was wondering
what's your take on the cancellation of
promises because that's one of the
questions that hasn't been really
resolved I like constant cancellation of
promises when I register my listener to
promise and I'm not interested in the
result anymore
right so that's a really easy thing to
resolve on on your side you can have
your have a boolean at the top of your
responder which says am i interested
anymore or not so you know you can do it
that way but promises also compose
really nicely you can cascade them
together and stuff so you can have a
counselor you know in that string you
can compose cancellation so there are
lots of higher level of patterns that
you can build out of the simple promises
is there is there a way to communicate
to the resolver not in the promise
system itself but yeah you can always
send it a message and it's similar to a
problem you might have in say timers
right you can have a queue of timers you
might want to say I'm not interested in
this timer anymore and so you want to
cancel it but it might be that by the
time you get the cancellation to it it's
already fired so it's likely you're
going to experience races so that's
probably not a pattern you want to
pursue but it is available to you
it seems that debugging is a real
challenge for turn-based programming if
you set a breakpoint in a conventional
program you can you know see the call
chain that led that gave you the context
for why you're there you can step over
you know you know sub functions and you
know skip whole subtrees of the
evaluation tree and that seems to be a
lot more complicated and debugging is
there practical tools for debugging
turn-based programs I think it's a lot
easier than trying to debug threads the
hardest thing I've ever done in my
career is trying to debug a real time
problem with two threads were chasing
each other I think turns are a lot
easier to manage than that debugging is
always going to be hard and as we get
you know more temporal complexity it
gets harder but I think terns manage
that complexity much better than threads
do
like so I'm going to make my way to the
front a second we got one more hair um
do you have any thoughts on emulating do
notation in JavaScript or there been any
attempts of that thoughts on what
emulating do notation like monadic do
syntax no I mean one thing we're seeing
in JavaScript now is a lot of
experimentation with new syntax you know
CoffeeScript sort of launched that well
no there were there are other examples
before that but there are lots of people
who were trying to experiment with
changing the language we're making it
more expressive I expect we'll see that
research continue where we don't see
promises of as a feature in es6 possibly
es7 but i'm not confident as to what's
going to make it in TS six right now so
it's dangerous to predict what's going
to be in seven and whether it will bring
new syntax with it as well it's I don't
know is the cost of making closures in
JavaScript make these monadic approaches
infeasible right now those no I closures
aren't that expensive I mean they're
just function objects and they're great
I mean that a lot of stuff gets enabled
by this now you could take a you know
sort of a simpler approach to some of
these things I mean there is a cost but
very few of our JavaScript programs are
compute bound mostly bound by everything
else so I don't think it's concerned I
think this is easily affordable
this is a public video yes all right
okay all right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>