<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ReUsable Web Components with Python and Future Python Web... | Coder Coacher - Coaching Coders</title><meta content="ReUsable Web Components with Python and Future Python Web... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ReUsable Web Components with Python and Future Python Web...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ui-mSFuUZmQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">as David mentioned my name is Ben
Bangert I'm a senior software engineer
at O'Reilly Media I work in the online
publishing group there and today's talk
was mainly good to be around WSGI and
developing reasonable web components
with Python and future Python web
development as a result of using WSGI so
to get started here web applications
with Python I've been a fan of this for
a while there's a lot of really powerful
frameworks available a lot of large
companies like Google for example
deploying Python web applications and
there's a huge library of Python modules
to use it's a mature language with an
emphasis on backwards compatibility
except for Python 3000 which will have a
few things of course and it's almost
really good of course when we're talking
about Python and web development so
what's the problem this is too full
depending on who you ask and who you
talk to some people say well there's too
much but I'm gonna break it down
slightly differently first off our
sessions are request shortcuts are
respect response paradigms they're all
unique for every framework pretty much
use dope you have one way of doing it
you use pylons you have a different way
of getting a response back chant go
another way all of these frameworks have
a different way of doing these kind of
very basic simple things there's not
really any uniform way to deploy them so
everyone wrote their own server hooks
some people say use mod Python some
people say no we have our own
application server just go ahead and run
it as it is and proxy to it there's not
really any uniform way to get all of
these things across and of course every
time you change your framework means
that everything you knew was sort of
lost as well maybe you've learned how to
use sessions with one framework you
change frameworks they want to do it a
different way they want to save it a
different way and maybe it doesn't make
use happy as it did in the previous
framework used and of course reuse for
the individual web components is very
difficult if not impossible you just
can't use these things between two
frameworks sometimes you're even lucky
to use two different web components
within the same framework on two
different applique
which of course doesn't make anybody
very happy so what's the solution
well the solution specifies a standard
interface between web servers and Python
web applications or frameworks it was
drawn up over two years ago last
modified April this year and it goes by
the initials Pep 333 it's the WSGI
specification and it was submitted by
philip abbey who's done a lot of great
work in the Python community so a quick
peek at what one of these little tiny
WSGI applications looks like before we
go into the details and guts here's a
hello world application it's very basic
very simple just a few lines and you
have a function your web application
that's called it puts out some headers
and it returns to the content of the
response we'll get into that a little
bit more shortly so first let's go over
the basics of a WSGI specified web
application it's a callable function and
object that responds to call any of
those little things they just call right
away that's all it takes
it's given start response which is
called with the status code and a list
of topple pairs for headers before it
returns a value and it should be called
only once we have an environment in
that's a dictionary of CGI style
variables and the response is an
iterable a list a topple and in a row
iterator or generator so let's take a
deeper look inside of the environment
that's really where a lot of the power
and W Shack comes from doing stuff with
the environment that's going between all
of these little applications that all
speak WSGI
we have dictionary of strings there are
really basic CGI strings you have HTTP
host server name request method path
info query string if you remember
developing perl applications way back in
the day that were CGI's and you have to
go and deal with all of these headers
directly this should look really
familiar you have a few WSGI strings
that are put into this
environment dictionaries well yeah WH a
diversion a URL scheme whi input which
maps to the body of the request that's
coming in and you have server and
middleware extension strings that are
stored inside of environment so of
course that's great and everything and
you have a way to call your application
but what do we do with it
so let's look at a few basic examples
let's say we want to get some cookies
here you have all you need a little
function which takes the environment
which we already looked at which is
being passed around and it goes ahead
and uses the cookie module which comes
with Python and gets you back a
dictionary like object which is your
cookies so you can start building these
little functions now that you know about
WSGI when you have an environment and
you can just pass in and fire into a lot
of them and you can get back very useful
sections of the request they can work
with any request that's coming in that
speaks WSGI because all of them work
with the same specification let's say we
want to parse our arguments we have a
little function here that again uses a
Python standard module CGI parts the
query string and it's going to go ahead
and return it and of course since that's
also easy we want to do something a
little bit more interesting let's do a
little something like intercepting
requests in displaying interactive trace
packs and there you go don't worry I'll
get into that later so interesting side
effects of the specification it only
sets a base of required environment keys
wsj compatible cobbles are free to
improvise on this they can add
additional values and keys to the
dictionary that's being passed around
they can put object references in there
if they can expand a bit and do what
they want to do is sue me that they're
not stomping on somebody else's stuff
and we'll get to that as well so you
have middleware
this is interesting if you have a simple
specification that just says okay I have
an application it's going to be called
like this it needs to return like this
what can I do with it so you have a very
simple specification here
you're just being passed two arguments
you're returning content you're calling
start responsible now this allows you to
get a little creative you can do stuff
that doesn't necessarily involve
returning response right away this is
what middleware is it's an application
that doesn't necessarily do anything all
by itself but it works between the
requests and your application that's
actually going to do something now the
most interesting thing of all that I
really get keen about as far as I'm
concerned this is a new layer entirely
the standard specification it makes
reuse possible and easy at a different
layer than it was before
framework competition is great we all
see all of the different frameworks
competing but what are they reusing from
each other not a lot wsg ice that's a
very low barrier and a very easy-to-use
interface that allows a new layer of
reuse possible in your web applications
so to expand more on WSGI middleware it
acts just like a wsgi application
it follows the WHI specification and as
far as anything is concerned it looks
just like another WC application it's
going to be called let's go to return
all very basic so it could decide to
give its own response or you could call
your application so let's take a look at
a very small piece of WSGI middleware
that's going to do something inside of
the environment here here you can take a
look we have a basic object we're gonna
pretend that you have a really cool WI
application inside of your library and
it's called cool app so you import it
and you have your random work which is
just going to give you a random number
so we have right here environment we're
gonna add something to it we'll called
so this looks just like a WC application
once it's initialized here so we go
ahead and initialize it and we give it
the cool application random where is
good to go ahead and hold on to a
reference to our application and then
when we call it of course we add an
environment dictionary and then we call
it with the environment and so far does
anybody have any questions is this all
pretty basic yes no okay
here's a little bit larger middle where
it's gonna hide an exception from a user
what if our little function throws an
exception we probably don't want to show
that to a user or let it just explode
maybe you want to give them a nice error
screen so here again it holds on to a
reference of our application and we have
to get a little bit more clever as we
mentioned earlier that start response is
a function the function should only be
called once so if we have something
that's going to be calling our debits
jar application we don't know if our
application is going to throw an
exception after or before it's called
start response so in our case we're
gonna give it a fake start response and
all it's going to do is it's going to
record whatever that function call would
have sent out into an array there and
it's gonna attempt to call our
application and it's gonna call the
response on it if it went okay and then
it's going to return it if it didn't go
okay it's gonna go ahead and throw out
an internal server error it's gonna set
it and it's good to go sorry our server
had a really bad day today so because we
can start reusing things at this level
do you really want to write this every
time you write a web application
probably not maybe you're looking at a
framework to provide this for you you
don't necessarily need to look at
frameworks anymore you can look at small
WSG I'm aware it's and little components
and you can plug them in as you want do
you want to capture your exceptions sure
go ahead and do it and hopefully from
this example you can see well what if at
my company I need to email all of them
and then I need to do several other
things as soon as an exception pops up
it's pretty easy just add into your
except clause send off an email and
you're good to go
then you could just slot that in anytime
you want to get out another wsgi
application and you have a reusable
chunk of code there for it
we have what I call WSGI components
these aren't really WSGI applications
that we looked at so far and they aren't
really middleware like last year we
looked at this is more similar to those
little tiny functions you want to parts
of curry stirring you want to parse your
form arguments you want to get in there
and do these pretty basic things that
most people might rely on a framework
for well why rely on the framework if
you only need a few basic things you can
do them yourself pretty much so wsj
components they work within the WHI
specification they avoid binding to a
framework there is not really any reason
to bind to a framework you're working
with specification you know how it
operates and it'll always operate that
way unless they change it someday but
you can already say I want 1.0 of the WI
specification they're typically rather
small we already saw solo from the parse
crew string not very large there are a
few lines maybe a hundred or two lines
for the big ones like that earlier when
we looked at briefly that was an
interactive exception catcher it can get
pretty big and maybe it's not very
pleasant to look at but they're not
packaged I mean these are not really
really big pieces of code most of them
fit in a single module they handle small
typical live activities that you might
find in larger monolithic frameworks so
you might be thinking well that's great
but I'm gonna have this huge bundle of
all of these little functions these
little middleware why have dozens of
packages for all of these little bits
and pieces it can be a bit of a pain and
you're gonna have a bunch of them to an
extent but one person out there decided
well I'm gonna put a whole bunch of them
into one package and he called it paste
if anybody's seen paste or any of the
variants of it a lot of people have
always asked well what the heck is paste
what is it really do so hopefully after
this everybody here and watching this
will know for sure exactly what it is
first off it's a package of common WSGI
components and middleware it includes
little bits of middleware that handle a
whole bunch of the different things that
you're probably going to want to do
these parts by themselves are really too
small to merit an entire distribution
plus you'd have so many packages I mean
who wants 300 packages for all of these
little tiny bits many of them have
dependencies on each other maybe your
request object that deals with
environment to parse the curry strings
maybe I want suppliers to form variables
once to have something to handle headers
these are very common little bits so
it's very useful to have them all in one
package so you can sort of think of it
as a tool set for WSGI development needs
there's a whole bunch of stuff in there
that makes it really easy to develop wci
applications you get reusable requests
and response objects for example here's
a little wsgi application that uses AWS
gel request and a wsj response object
and it goes ahead and loads up the
request loads up the response and now
all of a sudden we have an easy way if
rec top params has key method then it
could write out a response you have a
much easier way to get into your
response here you don't have to be
dealing quite so much with all those raw
cgi headers and all that kind of stuff
we have little wrappers that make it a
lot easier to deal with this kind of
stuff for those that have used Django
the WSJ response might look familiar
it's 99% same code with a few things
added on to make it easier to get WSGI
valid response kicked out of it but
really all it's handling for you and
that response is it's making it pretty
easy for you to set in encoding for your
output it makes it easy to set cookies
makes it pretty easy to set your headers
so it's a little easier than putting
that all into a big headers topple and
passing it back out and it gives you
some nice ways to refine the control on
it what else do you get in paste well we
take the pain out of errors in paste
that is all it takes to get an
interactive exception trace back for
your wsgi application when you're using
all wsj all you have to do is import the
battle exception and wrap your
application inside of a Valek eval
exception if foul exception will now
capture all of your trace backs it'll
hold on to a reference of them and it
will give you a very nice interactive
debugger in the browser for go
through the traceback maybe you want to
email errors back could be a bit of code
in other things here again two lines we
wrap our application we pass it's an
error config this is just some keyword
arguments you want to SMTP server to be
so-and-so you want it to be a from
address a to address a few basic things
like that and Erica fig and you have
email errors coming back to you so paste
contains a whi request and WSI response
object has exception handling middleware
has various WSGI environment handling
functions like query string parsing and
multi-part form parsing I should also
mention that most of the things that it
does because it's pretty basic and
because it's being used by multiple
frameworks and a lot of different people
these little functions are very
optimized and it's very easy to do that
because everybody is using the same base
set of functions to you work with here
we have included sessions transaction
logging proxying a mod Python script
static file serving middleware and much
more so this is a whole bunch of common
stuff that you might want if you want it
to make very basic very bare
applications for the web in Python and
you don't necessarily need a full
framework anymore you can just take the
parts that you want put them in a single
area and you're ready to go but what
else well just because it doesn't seem
like any framework is really complete
these days without one of them we even
have pony middleware and paste which of
course makes a nice little pony that's
totally irrelevant of course so what
other aspects of web application
development drive people to frameworks
because this is an interesting question
that the creator of paste iron baking
was trying to address mainly the thought
was all of these people making
frameworks are repeating a lot of the
same steps they're doing a lot of the
same things over and over again it could
be a real pain to do all of these and
wouldn't be great if they were all
unified into a set of tools that took a
lot of these common parts that were
underneath frameworks and did them for
you pace does a lot about our regular
you have a request object that responds
objects you can have sessions a whole
of advance stuff that normally a large
framework might handle for you emailing
your errors back it takes them all out
into one set of reasonable parts and of
course there's a few other things that
aren't in pace that frameworks do as
well pay script handles project
templates when you make a new project in
Django or in pylons or in turbo gears
you don't want to make everything from
scratch yourself you want a starting
point you want something easy to make it
you know fast to get going you want a
project so you have command-line tools
that go ahead and they set you up with
the directory they set you up with your
basic structure it seems like a pain to
go and keep recreating these calling
parts so this isn't a script you can
make a project template and it will go
ahead and kick out a customized project
a new one for you and pay script handles
as part so that web frameworks don't
need to re-implement it so this
increases reusing the core tools that
frameworks rely on what's another
section that frameworks rely on paints
deploy handles gives us a configuration
file for middleware wci applications it
eases the loading of WSGI applications
as well
so between paints deploy pay script and
paste we got a whole bunch of reusable
tools for making well frameworks or for
not using frameworks at all you could go
ahead and put together the parts you
need and you're essentially in a way
making your own little framework you
have the parts that you need and they do
just what you need and you're not
burdened with a whole bunch of stuff
that well isn't going to affect you and
it's only gonna complicate your life if
you have a bug somewhere down the chain
you're going where the heck did it come
from
oh this module I don't use this module
why is it even here well it's there
because somebody else wanted it and you
can't get rid of it so here's a quick
look at a script at work
we create a little application it goes
ahead and this uses a pay script project
template and it goes ahead and copies
all the stuff out and it makes are
several different directories and it
copies the files into them any questions
so far
WI middleware so we have one component
which catches exceptions and emails them
and another one
which wants to you know give you an
interactive you ever after catching
exceptions
how would you is impossible
okay so the question was if you have
that two different WSGI components one
that emails errors back to you and one
that captures trace backs and gives you
an interactive debugger can you combine
them you could depending on how they
worked obviously if one of them has
already caught the error and generated a
four or four or 500 page the other one
probably won't catch it because it's no
longer being passed an exception up the
chain typically in the web applications
that I develop in the framework that I'm
going to go over in a second here pylons
depending on the mode you're in it
toggles them back and forth so if you're
in production mode it's going to email
them to you and if you're in development
mode it's going to give you an
interactive debugger form the
composability of the components is
limited by nicely
is that protocol their interaction is
pretty much always by the WHI
specification when it goes up and down
the chain in this case the thing that
makes that particular condition a little
different is that you no longer have an
exception going up the stack after one
of them was already been called so
you're looking at all of this and you're
going great that's wonderful only there
is a framework that use all of this
stuff that we just went over well there
is violence I made this and along with
another developer James Gardner and
we've had a few more developers coming
to help us since then first appearances
I apologize if this offends some people
but it does look a lot like rails at an
initial glance this is partly because it
uses a reimplementation of rails style
of routing and I say reimplementation at
this point I tried to port it but I just
couldn't read the ruby code code it was
a cogeneration of cogeneration and
besides for being incredibly horrible to
debug it was pretty much unreadable to
everybody outside of the Ruby core team
who are the rails core team sorry
so we also ported the rails hoppers
because a lot of them are really useful
they did some basic stuff and just
because it was done in rails first I
have no problem copying a good idea in
pylons we have very small core there's
not a lot in pylons itself we don't need
to all of the stuff is handled outside
it's handled by paste which has a whole
bunch of the common stuff we have WSGI
components we have middleware we don't
need to do a lot inside of pylons
because it's already been done and how
do we want to reproduce other people's
work they've been doing it longer
they've got it down really well and in
pretty much every application I've seen
where you have something that's hobbled
together from scratch versus something
that's been out in the wild being you
know put through the test by a large
community for a very long time it's just
not going to be done as well typically
as a version that's already mature
balanced is opinionated feel free to
disagree with it
it's not going to walk you into anything
it provides an incredible amount of
flexibility inside your application you
can even do crazy things like not even
use the pylons application inside your
application you can make a totally
different wsgi application out of the
template that it gives you so what do
you get you get an automatic installer
easy install and setup tools handle the
details and for anybody's that's use
this before you probably realize that
well it mostly works these tools are
still getting more exposure turbo gears
uses setup tools and a bunch of other
Python packages are using setup tools
there's some bugs here and there but
overall we found it to be working
generally very well
turbo gears was kind enough to come
along before pylons and hammer out a
whole bunch of the initial problems that
cropped up a set of tools so it's pretty
nice nowadays you have automatic
generation of a project provided by pay
script you get a standalone server it
comes in pasted space on simple HTTP
server it's very fast and it works very
nicely you have multiple deployment
options WSGI is very nice in this
regards because we have a single
specification for a wshat works when
people write server hooks for wci
applications they work with everything
that speaks of your site so django has a
WSGI interface so you can go ahead and
put it behind there turbo gives talks
WSGI because the core of it cherry-pie
especially cherry-pie 3.0 has a whi
handler at the top of it
Pilon speaks whi and a whole bunch of
the other little frameworks that are
coming out now also speak double yeah
like web dot pi if anybody's use that
before so you have a very common
deployment scenario that if you can
deploy a whi application you can almost
always deploy any wsgi application this
is one of the initial things that WSGI
was created actually to get around you
have a clean URL mapping that's with the
routes we could have done the route that
other frameworks have and trying to
bring more stuff inside the framework
we've tried to push everything outside
the framework into other packages that
could increase reuse routes
I created mainly because I want to
choose with pylons but I made it as a
totally separate package it has nothing
bound in two pylons itself so it can be
used with other applications people are
using routes with cherry pie they've
used it with turbo gears and I've seen a
few people talk about using arauz with
django as well we have powerful
templating options with mighty or you
can use your choice of turbo gears
plug-in compatible templating languages
rather than trying to go around and make
it so that people can use any template
the engine they wanted to we saw that
turbo gears had already put out a nice
plugin thing that allowed people to
develop plugins for their templating
language of choice so you have a whole
bunch of the common ones covered here do
you want to use Django templates there's
now they call it turbo Django which
allows you to use Django templates if
you want to use cheetah you can use
cheetah you can swap out the default in
use whatever templating choice you want
so you get traceback emails in
production you get an interactive
debugger during development we have a
fairly solid MVC architecture we have
sessions and caching we have the helper
functions which were ported from rails
again these are in a separate packages
well called web helpers people are using
these functions inside of Django and I
believe they're also using them inside
of turbo gears so there's so you know
with all of these components they're
getting a lot of use outside of pylons
as well we're getting bug reports back
from people using them and other
projects entirely which is exactly what
I wanted because I wanted to increase
reuse and I wanted to get a larger
community regardless if they necessarily
agreed with all the choices that went
into pylons we have database integration
with it's not tied to any particular
database I'll show in a few minutes here
how it works it basically just uses some
very plain Python import statements to
pull in the stuff that you'd want inside
of your controllers you could use any
database you want to you just need to
load it up inside of an old python
module and it's there for you
we also provide unit testing this comes
with pace as well because the WSGI
specification is pretty basic it's
fairly easy if you wanted to to simulate
a full request coming down the pipe
so you can get really powerful unit
testing capabilities here because you
know exactly what you're simulating to
it and as far as the WSGI
applications are aware it looks no
different than anything else down the
chain so you can do some really good
unit testing here of your applications
by simulating request oh they come with
documentation tools internationalization
error documents for custom error
handling and a whole bunch of other
stuff but really what's actually in
pylons not a lot only 3,000 lines could
this is a very small small amount of
code for a web framework especially one
that's doing all this this is mainly
because most of the code is not inside
of pylons it's inside of these other
reusable sections that are being used by
other people as well a script provides a
project template there's a small fork of
the buffet project which is also the one
that's used in Cherry Pie to get a
multiple templating engines working so
you can use whichever template engine
you like best it's a little bit of WSGI
middleware and mainly a lot of
configuration glue we have to load up
our wsgi application we have to get all
the middleware stack put together you
might not want to do that yourself
especially the first time you're using
all of this pylons does it for you so
where's the rest of it stored beaker is
a little packaged WSGI middleware that
hand gives you session and caching paste
gives us a request object there are
caching and a whole bunch of other
little bits like parsing our requests
and that kind of stuff a script creates
project templates controllers runs the
application and paste deploy helps with
the configuration and we have routes for
our URL parsing we get paste and nose
which is a small little app testing
harness and runner it goes ahead and
unit test our application you have your
database of choice you have the plug-in
API
yeah I've web helpers so what does the
entire thing look like when you put it
all together here's the stack that you
get with pylons at the top we have a
request come in it hits the pay server
you could go ahead and swap this out if
you wanted mod Python fast CG is CGI etc
whatever speaks WSGI you can go ahead
and use it at the top there the entire
application doesn't need to care you
have a WSGI stack this is just a set of
those little function calls as we saw
wrapping up the wsgi application pylons
provides you with a default one it's
inside of your project template so if
you don't like it you can change it you
can put in whatever you want if you have
a specialized education system that has
a middleware component you can go ahead
and slot that in there's the actual
pylons wsgi application this is what
handles making sure that the request
gets to the controller that it's
supposed to so it's going to go ahead
and be the one that actually looks at
the URL it's going to parse out what
controller does it go to it's going to
find the controller call the controller
and then your controller is going to go
ahead and talk to the model and views it
decides and return response back up any
questions on this
so in the routing it looks very familiar
it shouldn't look very familiar to
anybody who's used rails before just
like porosity videos use a rail spring
through their hand one person that's it
one of the nice things that I like is
that I don't have to write regular
expressions too much as you can see I
have one or two in here making sure that
my version is 3 digits back-to-back with
an optional third digit but I don't want
to write a lot of regular expressions
just to get basic URL parsing to work it
should be easier and I think the route
system does a fairly good job of making
not only fairly easy to parse URLs but
generate them as well so here what we
have is the first argument is a name if
you want to name the route we can and it
makes it easier to generate URLs later
it also provides a central part where
you rels come out of so if you move your
application around and you need to
change something that may be 500 pages
end up linking to you have a central
thing you can go back here and change
how links and it's it's set everywhere
this is at the bottom here the default
one it just essentially says the first
part of my URL is going to be the
controller there's gonna be a slash the
second parts gonna be an action that's
going to be slash the last parts could
be an ID and that's how it decides what
controller essentially to map it to by
default
so here's all that rot studs grass is
gonna look at the URL and it's gonna
give it back a dictionary with the keys
set to whatever came out and that's
really all that routes does it also
generates URLs based on this but as no
bindings at all to any particular
framework so if you like routes and you
want to go ahead and make it work with
whatever you're using you can pretty
easily it also gives you your l
generation let's take this route for
example here we have a pretty basic one
the rat is named vici and inside there's
a URL and at the end we have page
because the sites with the colons is a
special variable that's gonna be
replaced and that's what it looks like
using it this is inside the templating
language mighty which again it if
anybody views rails it looks fairly
familiar to rails style ARB templates
we're calling the link to function there
and we're gonna name what the link is
and then we could call URL floor and we
could say well I want a wiki URL and I
want the tutorial page and it goes ahead
and generates that based off the
information up there the use of this was
at the time even though we don't like to
have our URLs never ever change which is
what you definitely should do sometimes
URLs do change and in this case they
changed a little too frequently and I
wanted to make sure that that always
went to the right spot so I had only one
place that I needed to change to the URL
that was gonna be generated allons gives
you a few basic objects make it easier
to work with your application
unfortunately two or three of them have
one letter initials which I know is
against the pet bait but they're used so
frequently it just seemed like you're
gonna get a you know continuous stress
on your fingers there if you have to
keep typing them all the time so you
have h which is your helper object it's
populated through a normal Python import
you have the request which comes from
the pace of your class you have a
session you have a render command and to
render response these should look fairly
familiar to Django users
as well as rails users Django has
rendered two response we have render
response they both do the same thing
they you know render a template and
return it inside of a response object so
let's look at how a controller inside
Palin's would get its form variables
that's all it is
you have the request request stop params
and we saw that also in the earlier
example we're using a WSGI request
object it's the same thing right there
so all we do is return the response and
there we go
zero passing variables templates if
you've used rails you know that
everything that you want to pass to a
template you assign to an instance
variable we didn't really want to do
that
that's where C comes in C is available
inside of your template so if you assign
things to the C object you can use them
inside of the template so there's what
our template would look like
again this is my T and one of the nice
things that we'll go over later is that
for the most part my T doesn't impose
another learning curve on you you don't
need to learn a very unique way of doing
most kind of things you're gonna use
Python you do have to make some
adaptations because Python likes
whitespace and HTML templates don't
really care about it for the most part
in this case the way to deal with that
was this a little bit you have to
comment and you have to indicate when
that line of indentation is going to end
because of course HTML doesn't really
care but otherwise we get to use
completely normal Python syntax so we
get for item in a see that fact items
and go ahead and enter eight through it
and there inside of our variables in
so the big objective inside of pylons
was I wanted to increase reuse I didn't
want to just reuse all of this code I
wanted to reuse existing knowledge if
you already know Python then what can I
bring to the table on top of that what
other things could you learn faster
because you already know Python so let's
go ahead and apply Python principles
whenever we can so the default template
evaded uses normal Python syntax if you
have to indent them of course and you
have to do the extra little and if
statement it looks like it's well in my
white space there that should be
indented as well obviously this can get
really messy if you have a lot of nested
if statements which is why I generally
would assume that you wouldn't want to
have a lot of nested if statements
inside of a template that means that
you're doing too much in one spot and
should really be split up so the goal
here why we learn a new syntax for your
templates why shouldn't be able to use
the Python that you already know the
variable substitution inside here we
have our variable and anything in here
is just evaluated as a normal expression
so we can go ahead and use Python syntax
in there if you wanted to call a
function have its output there no
problem go ahead and call it
this is all that you need for controller
not a lot so where did all of these
things come from we have a render
response we have a base controller we're
getting all this stuff in there and we
don't have to keep on importing a huge
laundry list of stuff all over the place
so the ID ID R idea here is well if we
could keep on importing all this stuff
odds are well maybe you come up with
some new thing and you want it available
in all of your controllers what a pain
is to go through all of those
controllers and add that new import
statement so let's use a normal Python
import and go ahead and import a base
set of names that we want available in
our controller's here is the base one
that you get in a new pylons project it
has all of the basic stuff they probably
couldn't want your response eg a cache
object to request a session as the WHI
controller and pretty much everything
that you want there these last two are
kind of important we don't provide
object relational mapper integration we
could tie ourselves one but then it just
becomes its own little mess all by
itself typically so what we do here is
we go ahead and set up a models package
inside of your directory and you have a
I'm just going to go run it file inside
of there and you can go ahead and define
whatever mapper you want to use it's
imported as model and because it's in
here and this module is the imported
everywhere else you know have a model
available so you get really easy almost
magic like appearance of model
everywhere even though you didn't really
have to do anything magical all by
itself just a normal Python imports
again with pylons HQ dot little helpers
we're going to import that as H now I
have H everywhere we need it for our
helpers you can go ahead and define
whatever names you want in there again a
totally normal basic Python import so
the advantage of course while you always
know where everything comes from you
could just follow it back there isn't
things being inserted in here magically
behind your back you're just importing
them yourself it's also pretty easy to
see where you can extend your project
with your own functions do
have some module that you use and all of
your controllers go ahead and stick it
in the base module and there it is now
it's going to be available in all of
your controllers because it's imported
everywhere so there's a wee bit of magic
needed to make them available globally
and in your templates this is taken care
of by paste registry anybody can go
ahead and use this all it does is makes
it easy to get to specific objects that
are created for the duration of requests
anywhere else in a request because
sometimes you're not going to want to
pass something everywhere for example
the C object you might have several
different places where you want to set
up variables that are going to be used
inside of your template passing these
all over the place quickly becomes a
very big pain in the neck so we have a
few objects that are a little bit magic
to make it easier to deal with this so
keep your friends close
most of pile-ons has done through WSGI
components middleware separate packages
if you like something inside of it you
can go ahead and use it regardless of if
you're using pylons other frameworks
also use parts of these we have rhubarb
tart we have clever Harold some creative
names here and we'll probably have a lot
more rhubarb tart if nobody is familiar
with that it's sort of like a WSGI based
version of cherry pie they like the
object dispatch scheme of it so they
said well that's great I want object
dispatch based off of the URL but I
don't want all of cherry pile and very
WSGI so they made a rhubarb tart and
it's very small I think it's less than a
thousand lines of code to do it so it's
a very small little piece that does that
for you so of course the goal stop
relearning the basics take them with you
you already know how to use these parts
or maybe there's another part that you'd
like to use why should you keep on
learning it every time you move to a new
framework if the frameworks Lib usgi
base you get to bring it with you if you
want to if they're not already using it
make your new friends portable if you
have complex bits or even not complex
bits maybe they're just tedious if you
can write them as wsj middleware you can
use them and keep on using them
regardless of what framework you choose
in the future assuming that it of course
speaks WSGI which a lot of them are
nowadays
so WI middle work keeps web code
reusable despite later frameworks
there's a few unanticipated bonuses in
at WSGI framework these parts make
backwards-compatibility very easy I
don't know how many people here have
been using some of these new frameworks
rails Django pylons any of these pretty
much and they've gone through a major
revision already that's broken a good
section of your code and you're sitting
there going well of course they didn't
claim it was a 1.0 so I guess I should
expect all my stuff to break every few
versions but that isn't very fun
especially when people are of course
writing real applications with these
frameworks now WSGI makes it very easy
to provide backwards compatibility if
the parts speak WSGI you can go ahead
and let people that are using an old
version of it continue using those and
just slot in new ones that also follow
the specification and that way you get a
key backwards compatibility the
components follow a single specification
so if you want to swap them in or out
you can and here's where it gets a
little interesting the paid script
project templates create some new
possibilities allows us to push the
envelope we can do something that maybe
we haven't thought about doing before we
wouldn't want to do before like
sub-classing an entire framework
previously it was impossible or very
easy it definitely was a bit of a chore
a script allows project templates to
inherit from other project templates so
let's say like everything about pylons
or one of these other ones but you
didn't want to use a session layer you
didn't want to use that request object
you can go ahead and make your own
little project template and you say okay
I want to start with the pylons project
template but then I want to change this
file this file and put in a new file
here and I can go ahead and create new
projects that use your own little mini
framework to you know sort of so you can
go ahead and make a new little
frameworks based on modifications to
existing one so you don't need to leave
all of the advancements that and stuff
that they do behind if they did
something really great that's fine
you're still using it and of course the
fun bit especially for companies you
could subclass a framer for company
specific conditions maybe your company
always puts on a little bit of a sign-on
scheme maybe they always make a
uncommon in the wild database connection
why do you want to keep on doing the
same little bit of tedious work over and
over again every time you make a new
little web application for your company
you probably don't you can go ahead and
inherit from another framework that does
almost everything you want and go ahead
and make those few little changes and
now you get a stay with those every time
you make a new project
so essentially wci goes ahead and it
enables reuse and collaboration and
assuming this works here I'll go ahead
and pull up a little demo of this
any questions so far
okay everybody see that fairly well
so I'm going to go ahead and take a look
at all the templates I've available
these are project templates so if you go
ahead and add new ones you can go ahead
and see which kind of projects you can
create if you want to create your own
Google project that has you're sort of
starting point for an application that
you'd develop here sure no problem you
could go ahead and make one
so I'm gonna divide and create I want to
use the pylons template and I'll call a
little project blah and it goes ahead
and creates a project for me so that's
all it gives me to begin with and then
this is already set for distribution it
has a set of Pi file in it it's
packaging entire application and another
directory underneath it and it's ready
to be packaged up and distributed as
well so I sort of get all of that for
just you know when you're ready to get
started it's already packaged self up is
a distribute a lot distributable
application so I'm going to go ahead and
add in a little controller here
and
here we have our controller it's pretty
basic this is one that was just created
let's see if I could go ahead and blow
this up a little
oh let's go ahead and take a look at
what this does so far it's probably not
going to be very interesting go ahead
and start at the application
and now it's all running ready for us to
take a look at it
so for good Oh for the real it
on the side of the window back there -
yeah that's inside of pace it goes ahead
and watches all the Python modules that
reloading involves to detect multiple
changes in realized application so
here's the default screen that you see
when you start up and we wouldn't added
a user's one at the end here which
returns nothing so it should be blank
not very exciting so far and let's go
ahead and play with the interactive
debugger because that always looks great
for demos that's good to cause them to
restart and we'll reload that and we
should get a nice little interactive
trace back there so this is one of the
things that you get for free because
it's provided by middleware and I'm not
sure why all Python web applications
don't come with something like this now
because it makes things really easy to
debug there we see our controlling it
through our error arrows raised that's
great what were the variables that are
around during that time well that's a
good start but what else can we do in
here and right here you got a full
interactive Python interpreter so we
could go ahead and take a look around
and evaluate what we have available to
us sure enough everything is right there
very handy very easy to debug especially
have a lot of objects that are wrapped
up inside of each other sometimes just
listing okay great I have an object here
that's not clear really helped me a lot
but here you get to use an interactive
Python debugger pretty much anywhere in
your entire stack trace back and that's
mainly because of paste eval exemption
again we have middleware that doesn't
work so I didn't need to write this
which I love because I like getting free
functionality about other people Overton
well
so
any other questions
that's it thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>