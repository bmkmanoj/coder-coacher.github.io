<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Speed Up Your JavaScript | Coder Coacher - Coaching Coders</title><meta content="Speed Up Your JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Speed Up Your JavaScript</b></h2><h5 class="post__date">2009-06-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mHtdZgou0qU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Steve Souders I work here
at Google on web performance and I've
started this new speaker series I call
Web exponents and the tagline is raising
web technology to a higher level and so
Nicolas is one of the first speakers in
the officially named speaker series I
worked with Nicolas at Yahoo he's a
JavaScript guru he's the author of
professional JavaScript and I think
co-author of professional ajax from
rocks and he's also contributed a
chapter to my next book even faster
websites which is coming out this month
now I have to start saying that and he
works on Yahoo front page and he does
this a lot go goes around evangelizing
JavaScript best practices especially
focusing on performance so I'm excited
to have him here today and to present
him with the official google Tech Talk
swag bag nobody thinking picture so
please help me welcome Nicolas aqus hi
so that pretty much covers what I was
going to say in my introduction I
usually start with this who's this guy a
slide but Steve kind of covered it all
so I'll just go through it as if I'm
saying it because it don't really want
to repeat so anyways here are the lovely
book covers that Steve's book over on
the right which I contributed a chapter
to out this month anyways moving right
along the problem is that JavaScript is
slow you're just going to start out by
saying that and the secondary problem is
that people notice that it's slow right
because a lot of the web is about
perceived performance and if your thing
is slow and people perceive it to be
slow then you're in a lot of trouble and
there's a lot of complaints I mean this
was just one
things that I came across and I was
looking for like complaining about
JavaScript performance but there's tons
of stuff out there
and so we really need to be careful
especially now where people have really
fast internet connections you know 10
years ago or so people expected the
Internet to be slow and now they expect
it to be fast and that's mostly our
fault for becoming really good
JavaScript developers but the browser's
have been really caught up okay so why
is JavaScript slow people who don't know
anything about the web they usually like
well there must be some sort of bad
compilation going on which of course
isn't true the problem is that there's
no compilation going on I have my little
asterisk there in case anybody was just
going to interrupt and say but but but
we'll talk about that later
so really the issue is that browsers
aren't going to help you with your code
right they don't care that your code is
running slow they're not going to do
anything to adapt for it so really if
something has to be done to speed up
your code it pretty much has to be done
by you and so a show of hands who
thought that you would see a Smokey the
Bear reference today yes
okay so we're talking about JavaScript
performance issues there's a bunch of
stuff to talk about but in this talk I'm
going to focus on just a few areas and
going to give you my regular disclaimer
that these are things that you need to
figure out if you need to do I'm not
going to stand up here and say do this
every single time regardless of what
you're doing because that doesn't make
any sense right you need to take some
measurements figure out where the
bottlenecks are and then figure out if
any of this stuff is actually going to
help you in your job so the few things
we're going to look at today
first thing is scope management which is
something I think a lot of people don't
understand so we're going to dig into
that a little bit data access because
where you put your data and where you're
accessing it from can make a really big
difference loops that's everybody's
favorite topic when it comes to
performance really and then no
performance talk can really be complete
without talking about the DOM
and how slow it is so to begin with
we'll go with scope management so this
is a horrible horrible function that
I've written please don't look at it too
closely because it doesn't do anything
interesting and it really is just a
bunch of stuff I threw together too for
an example but it's a global function
set up pass in some items do some stuff
set up an event handler get some Dom
references and then move on but this is
the basis for a lot of what I'm going to
talk about next
so scope chains when you define a
function and we're going to assume that
this is the the global function called
set up that just saw there's this
internal property called scope and ECMO
262 has the little braces around it but
I don't know how to say that without it
sounding weird so we're just going to
call it scope and when the function is
defined that property is filled with a
scope chain that has a bunch of
information about the variables that
should be available when that function
gets executed so when you have a global
function like setup there's only one
item in there and that's the global
object that has stuff like window and
document and navigator and a whole bunch
of other stuff but I just threw those in
there too to keep this reasonable when a
function executes there's something
called an execution context that's
created and that execution context has a
scope chain of its own that it uses for
identifier resolution and the way that
that's built up is the execution context
is created it takes whatever was
attached to the function object scope
property copies that into its own scope
chain and then creates an activation
object that has all of the local
variables in it and puts that up front
so to take a look at what that looks
like
hey I just said that let's take a look
at what that looks like so we have an
execution context that was created let's
assume that setup is being called right
now this execution context has its own
scope chain so we start out by putting
what was in the functions scope property
there first so that's the global object
and then we'll have this new object come
in and get pushed on to the front which
is this activation object and that has
the all of the local variables in it
which includes things like this and
arguments any named properties and then
any local variables that were declared
in the function so what happens is when
the function is being executed and it
comes across a variable this process of
identifier resolution starts and it
starts by looking at the first spot in
the scope chain and then makes its way
down to the back so if it finds it in
the first place awesome that's what it
uses if it's not found then it goes on
to the next place in the scope chain and
so on and so forth until either it's
found or it's not found and then you end
up getting an error in all cases the
last stop is always the global scope so
why do we care about this the reason is
that local variables are really fast to
access right to read from because
they're in that first location in the
scope chain the further you go into the
scope chain the longer it's going to
take to resolve those identifiers and
that can affect your script speed so
charts very fun this is just a chart
with some experiments I ran to see how
long it took based on how deep into the
scope chain variable was so across the
bottom we have how deep into the scope
chain it is and then across the side is
the amount of time and you can see that
the general trend is that the deeper
into the scope chain you go the longer
it's going to take in order to resolve
your identifiers so we have a couple of
really good performing browsers at the
very bottom you probably already know
what those are but we can
guess those later on then we have some
you know kind of iffy ones in the middle
and we have some really poor performing
ones at the top and I'm guessing you can
probably figure out what ones those are
too so later on as well so this is just
for reading from these variables writing
from variables is not much different but
the general trends are the same the
deeper that you go into the scope chain
the longer it's going to take to resolve
those identifiers so a little bit more
about the scope chain is there's a few
things that will augment it for you one
thing is the width statement and you've
probably been hearing for years now
don't use the with statement this is
part of the reason and I'll give you an
example that in just a second the catch
Clause of a try-catch statement has the
same effect that it artificially
augments that scope chain and they both
do that by adding an object to the front
of the scope chain temporarily and then
removing it later so if we go back to
the example from earlier remember this
is just the set up function that I had
earlier in this and this presentation
and let's say that there was a with
statement in the middle of it as soon as
execution flows into the with statement
you end up with a scope chain that looks
like this there's a variable object
that's pushed to the front so now that
has all of your with block variables and
that means that all of the local
variables to your function are now one
step away in the scope chain and that
will affect your performance so hey I
said that two local variables in the
second slot all the width variables are
now in the first slot so this is why
Doug Crawford oh look there he is always
says with statement is considered
harmful we should avoid it
closures also enter into this
conversation the scope property of
closures always begins with at least two
objects because it's going to be the
global object which every function has
in there but also the the scope of the
function
which it was created so calling the
closure means that at a minimum you're
talking about three objects that are
going to be in the execution context
scope chain when that's being run so
here's the closure in my earlier example
in a very typical event handler just
thrown in there and here's what it looks
like so that's my anonymous function we
have the scope chain so push the global
object on there first because that's
always in there and then we have the
activation object from the containing
function so that has all of the
variables from the setup function that
gets pushed on there too and this is
just the anonymous function object that
has this so then when you go to the
execution context immediately you have
three objects in the scope chain and
that means anything that you're
accessing from inside of the closure
that wasn't defined there is going to
take longer to access than the P others
so some recommendations for this store
any out of scope variables in local
variables it probably doesn't make much
sense unless you're using it two or more
times because you have to take at least
one hit to store it in a local variable
but if so storing them local variables
can really speed things up and that goes
especially for global variables because
those always take the longest to resolve
since they're always the last spot in
the scope chain avoid the width
statement it adds another object to the
scope chain and that means local
variables are going to be slower to
resolve and be careful with try catch
because catch behaves the same as with
I'm not inclined to say don't ever use
it but if you have a spot that's always
throwing an error and you expect it to
throw an error then there's probably
some better way to handle this then
taking the performance hit every time
use closures sparingly if if you can
avoid using them you can usually save
yourself some trouble and then don't
forget to use the the VAR statement
when you are declaring variables because
accidentally creating a global variable
means that it's going to take longer to
resolve this question in the back so the
question was regardless of width and
try/catch am i saying that these
identifier resolutions aren't cached
correct I'm not so it's a good question
I always say that my knowledge of
JavaScript ends right where the
interpreter begins so I'm not entirely
sure going across all the JavaScript
engines what they're doing behind the
scenes all I am sure of is when I was
running these tests these were the
results that came up if anybody here
works on Chrome and wants to fix that
please do yeah so here's just an example
again in the setup function where I took
a global variable document and just
stored it in a local variable and so I'm
eliminating the number of global lookups
here which previously was 3 and now it's
just 1 again this is really
oversimplified example but when you have
a large amount of code that's accessing
Global's you'll see a difference there
so next JavaScript performance issue
data access there's 4 places from which
you can get data in JavaScript and in
general one is your literal values so
your strings your boolean x' your
numbers no undefined variables of course
object properties and then array items
and these all work kind of differently
so just generally speaking accessing
data from
or a local variable is always the
fastest and in most cases the difference
between those two is negligible so you
should feel free to use local variables
whenever you want the interesting thing
is when you're accessing data from
properties or array items that tends to
take longer oh one of those takes longer
is really up to the browser different
browsers have done different
optimizations for this and another
beautiful chart you can see the blue is
a literal value the red if it turns out
to be red for other people looking at
least it is for me is local variables
yellow our array items and the kind of
greenish bluish thing is object
properties okay and for the rest of you
it would be the bar on the far right
that I'm referring to and you can see
the general training and some browsers
perform really well some browsers
perform not so well without naming names
but generally speaking the the literal
and the local variables the literals and
the local variables tend to be pretty
fast compared to property lookup and
array item lookup Firefox has done some
interesting things to really optimize
array item lookup so that tends to be
pretty fast compared to object
properties some of the other ones it's a
lot closer some not so much but again
the general trend is that literals and
local variables are faster property
depth also matters so if you have object
name that will be faster to access then
object name name which kind of makes
sense because you're doing two property
lookups there instead of just one and
the deeper the property the longer it
takes to retrieve so in little chart
just a show as you as you continue on
going further in for further and further
into objects you know dot name name name
things start to get slower and slower
this is a question I got the last time I
was talking about performance was if
there is any difference between using
dot notation and bracket notation to
access properties and there really isn't
except for Safari which is kind of
strange it's the only browser where dot
notation you can actually tell that
there is a difference between bracket
notation and that even goes up through
like the latest Safari for betas but in
general you really shouldn't have to
choose between one or the other if
you're concerned about performance
though some recommendations for this
this type of stuff you should store in
local variables so any object property
that's accessed more than once any array
item that's accessed more than once try
to minimize your deep object property
and array item lookup that'll help as
well so again another stupid little
function just to prove a point I have a
data object being passed in and data
count is being referenced a couple times
data item being referenced
I can change it around so that I'm
eliminating property lookups here so
just by storing stuff in local variables
and if you want to see like does this
actually make any difference in a few of
the browsers here Firefox not that big
of a difference takes about five percent
less time to complete Safari takes about
ten percent less time to complete and ie
about thirty three percent less time to
complete probably not surprising you
tend to see the largest performance
gains in IE when you're doing this sort
of stuff so next part loops always very
exciting so we have a bunch of loops
that are defined for us in ECMO to six
two and third edition for four in
do-while while and then you can throw in
be the ECMO script for XML for each that
Mozilla has
but really we're talking about loops
we're not talking about for in and for
each because for each not used all that
much not implemented everywhere for in
really inefficient if you're just
iterating over a bunch of values in an
array so really talking about in this
context is for do-while and while and so
and basic examples I'm sure you guys all
know how to write these
so which loop do you use if you want it
to be the fastest and I see this tab a
pop up every once in a while and so the
interesting thing is that it really
doesn't matter which of these loops you
use so what does matter if the loop type
doesn't what matters is the amount of
work that's done per iteration and that
includes the terminal condition
evaluation and any incrementing
decrementing or anything else that
you're doing every time through the loop
and then the number of iterations and
these don't change depending on which
loop you're using right you still need
to worry about these so if you want to
fix loops to really easy ways is
decrease the amount of work per
iteration and then decrease the number
of iterations right seems simple and
practice not always so simple but just
for some examples here again the three
different types of loops here if you
want to take a look at the things that
are being repeated for each iteration we
have the terminal condition being
evaluated each time we have this
incrementing being done each time and
then of course the body that's actually
processing whatever value that happens
to be so some easy fixes eliminate
object property and array item lookups
and just talking about this if you're
doing those every time through the loop
it's going to slow things down so this
this rewritten example I've just moved
values dot length into a local variable
so that each of the loops no longer has
to do that property lookup each time
through so just replace those there next
is try to combine the control condition
and any control variable changes into a
single statement because
the best way to make things fast is to
do less stuff work avoidance is primary
when you're concerned about performance
so if we look at this in the terminal
condition here actually doing two
evaluations saying is J less than Len
and then is that equal to true and so if
we can narrow that down so it's just one
evaluation things will end up going
faster
so here I've just replaced those
terminal conditions basically flipped
the loops so that they're going
backwards and counting down from the
last item in the array to zero and that
means that I'm just going to have one
condition to evaluate instead of two
just is that equal to true or not and
that tends to be faster and in this case
it was up to 50%
it took about 50% less time when I
rewrote it like this than the original
one did and that was across browsers so
things to avoid for speed for in because
it's not actually just looking at the
numeric items in your array it's also
looking at the properties and it has to
go up the scope excuse me prototype
chain that tends to be slow for each has
similar issues and not all that popular
because not really implemented
everywhere yet fifth edition of ACMA 262
introduces this for each method on
arrays natively so that's also something
to avoid tends to be really slow and
basically anything that is a function
based iteration all the JavaScript
libraries have them these are just a few
of the examples here those end up being
really slow so why most of them are set
up kind of like this this is the the
native implementation where you pass in
a function to a method that function
gets executed for each item that's in
the array and it tends to pass in you
know the value the index and then maybe
the array object as well problem is that
you're introducing an additional fun
and with it comes all the additional
overhead of executing a function and so
function requires execution we have to
have an execution context created
destroyed also creating an additional
object in the scope chain in this case
because it's a closure so anything that
you're accessing from outside of that
function again it's going to be slower
and in most of the tests that I ran this
ended up taking about eight times as
long as just doing a regular for loop so
if you care about performance you may
want to double check any place that
you're using function based iteration
like this so the last thing I'm going to
talk about today is the Dom which you
really can't talk about javascript
performance without talking about the
Dom or as I like to call it the Dom oh
come on come on there was nothing for
that that was great
Dom is usually the slowest part of any
of the JavaScript that you're executing
and there's a lot of reasons for this
unfortunately you can't go into all of
them today so I just thought I would
pick a couple and show you what's going
on
so the first evil part of the Dom that I
want to talk about is the HTML
collection object and this is something
that a lot of people just aren't aware
of
so HTML collection objects live
everywhere in the DOM and they kind of
do so insidiously all of the collections
that are on the document object our HTML
collection objects so document images
document forms document dot links all
that stuff it's also returned by get
elements by tag name and get elements by
class name so they're everywhere very
hard to avoid so if you look at the Dom
level 1 spec this is the section that
defines HTML collection and you can find
the evil part like right here in the
spec and since it's really small up
there I'm just going to bring it up for
you it says note collections in the HTML
DOM are assumed to be live meaning that
they are automatically updated when the
document has changed so okay that means
that it's not a static snapshot it means
it's going to continue to change even
after you have a reference to it and
this causes problems in a lot of ways so
this example here I'm just getting a
reference to all of the divs there in
the document and then for each of those
I'm creating a new one so in theory this
should just double the amount of divs
that are on the page but in actuality
this becomes an infinite loop and the
problem is because HTML collections
again are live and they're being updated
even after you've retrieved them divs
dot length is being incremented every
time you're going through the loop so
you will never reach the end of that so
I is being incremented that's great
but then I go in and I add a div that
automatically gets picked up in the HTML
collection and that means it'll just
continue going on I will never reach any
limit in this case so HTML collection
objects beware they look like arrays but
they're really not like you can access
the items using bracket notation you can
also access a length property button
they are not arrays they do not inherit
from the native array
they represent the results of a specific
query that was run against the Dom so if
you consider the last example we're
basically saying give me all of the div
elements that are in the document and if
all of the developments in the document
change then that's automatically going
to be updated and the query for this
tends to be rerun whenever that object
is accessed and so it tends to be very
slow again generalization I'll show you
there's yes there's my exceptions so
offer in Safari have done some
optimization for this so that they
aren't nearly as slow doing some sort of
caching but other browsers still are not
and so if we take a look at these two
loops the top one is just accessing an
array iterating over it and there's
nothing being done in the loop at all
I'm just iterating over the array the
bottom one I'm using an HTML collection
to do the exact same thing right and
there besides that there's no difference
between these two loops so if you look
at the performance across a few browsers
here what you find is that the bottom
loop takes 15 times as long in Firefox
takes 53 times as long in chrome 2 and
take 68 times as long in IE and so what
is the difference here that's the
difference right we're doing items dot
length against a regular array or doing
gives dot length against an HTML
collection really really slow so in this
example I've rewritten it so that I'm
storing the length in a local variable
first and then doing the loop so a
little bit of a change there but now if
I run these in various browsers they end
up being pretty much equivalent there's
not much of a difference at this point
because we're just doing one property
lookup in each and we've minimized the
overall effect
so HTML collections bad HTML collections
in loops even worse so what can you do
minimize property access as much as
possible store the length or the items
in local variables if you're going to be
using them a lot the thing that you
don't want to do is have a bunch of you
know HTML collection dot all over your
function that's really going to slow
things down if you need to access items
in order from that HTML collection
frequently and you're just like a
snapshot then you should store those in
a regular array and access them there
because that will be faster and this is
just a function I'm sure many of you
have written something
similar over and over is just a function
that will convert something into an
array you can use the array prototype
concat method in any browser except ie
for this nie that will throw an error
and then you just go through and
manually copy over each item into an
array once you have all those elements
in an array it's going to be much faster
for you to access that information so
next evil part of the dom is reflow I
didn't do the voice for that one because
I didn't think you guys would like it so
reflow the best explanation I found
Chris Watterson from Mozilla reflow is
the process by which the geometry of the
layout engines formatting objects are
computed so what does that mean
it means that's how we figure out how
big stuff is when we're trying to render
it in the browser and so when does
reflow happen well necessarily it
happens on initial page load to make
sure that your page looks the way that
it should it happens when you resize the
browser especially true if you have a
layout that flows it happens when dom
nodes are added or removed because that
may affect the layout in some way it
happens when layout styles are applied
and it can happen when layout
information is retrieved from the dom so
initial page load and browser resize
there's not a lot we can do about that
right that is going to happen regardless
so we'll skip over that let's talk about
when dom nodes are added or removed so
another really bad example is just
adding a bunch of items to a list in the
dom so creating a bunch of li elements
setting inner HTML on them and then
appending them to the overall pattern so
reflow in this case will happen every
time that appendchild is being called
it's updating the document that you're
seeing and so all of these calculations
have to happen at that point in time to
make
or the things are updated appropriately
so to the rescue of my friend document
fragment a document fragment is a
document like object except it has no
visual representation right you can
never add a document fragment to your
document and display it to the user it's
just a construct that can be used behind
the scenes to make your life easier
it's considered a child of the document
from which it was created a child is
probably the wrong word for that but the
document that created it is considered
to be the owner of that document
fragment and when you pass a document
fragment in to add child instead of
adding itself it adds all of its
children so it's a really easy way to
build up a bunch of stuff to be added to
the Dom and then add it at a later point
so I can rewrite this code to use a
document fragment you create it by
saying document dot create document
fragment and here what I did is instead
of adding each of those items onto the
list itself I'm adding them onto the
fragment inside of the loop and there'll
be no reflow there because you're not
actually updating the visual
representation of the page where the
reflow will happen now is just once at
the end I'm going to go and add all of
those onto the list so I've basically
limited the number of reflows in this
example to one where before there was
ten that will end up being much faster
so another time when reflow happens when
layout styles are applied and layout
styles are usually stuff like height and
display and font size and width we
change something from block to inline
vice versa
all of these end up causing reflow so
what can you do about this you want to
minimize the number of times that you
touch the style object if you need to
make a bunch of changes all at once then
the best thing to do is to define a CSS
class that has all of those defined
and then just change the class name
property so if I rewrote that and I just
defined a class called active that has
all that information in it and I change
class name equal to active that causes
one reflow instead of the three that we
had before and I'm just a big fan in
general especially for maintainability
purposes to do this as well because it
can really get hairy if you're touching
the style object in a bunch of places in
your code so hey reflow right there so
the last point where Steve do you have a
question so you didn't know the style
ahead of time so you could define a rule
like that is it bad to do all the style
changes through CSS text so okay the the
question for anybody that didn't hear it
was if you didn't know all the styles
ahead of time would it be still okay to
use CSS text to set it instead so the
answer is yes as long as you're grouping
things together that will just cause one
reflow what you just want to avoid is
you know style dot left equals whatever
style dot right equals whatever and
doing them one by one like that but CSS
text is another valid way to go yes
u.s. Levi see you moving an object
across the page is there
do that much writing that code right now
so the question was if you're if you're
changing a style continuously is such as
moving an object across the page yeah is
there a really efficient way to do that
unfortunately I don't think so
because and and I'm going to just state
my bias upfront I really don't like
animation on webpages but it is one of
those things where you really can't if
you want to move something you know left
or right there's nothing else you can do
aside from setting left periodically at
some regular interval that moves it
across what I would try to minimize is
the number of other dimensions that
you're animating at the same time so if
it's possible to you know just go left
to right and not need to go up and down
and in circles that will tend to be
faster but the more properties that you
end up changing then the slower is going
to end up being until browsers optimize
that sort of stuff the other questions
about that there is friends you have a
manipulation within like table to
surrounding and there's like dude
inserting one element but then we might
wanna change the others like ultimate
bro colors is it effective to them like
copy the entire thing or could they get
out of the dolphin
okay so the the question was in the case
of like working with the table if you're
removing a row adding a row
what's the best way to deal with that
document fragment is just one way of
doing that
really if you remove an element from the
Dom so that it's just not being visually
represented anymore you can do all the
changes that you want and then add it
back so you don't need to attach
something to a document fragment in
order to do that if you wanted to just
say for example you wanted to remove one
of those rows do a bunch of stuff to it
and then insert it back you could say
you know remove child pull it out do all
of your do all of your work on the Dom
node while it's not part of the DOM and
then add it back and then you only end
up with one reflow yeah sorry
two reflows so setting display:none will
work as well I tend to be more of a fan
of just removing things when I'm working
on them but there's no reason why
display:none wouldn't work as well the
only thing to be careful of is how much
that ends up shifting your page which I
guess would be the same for removing a
Dom element anyway so do that too I
don't think this ability none would work
we visibility:hidden
yeah it would engage us yeah it depends
on on what you're doing because with
visibility:hidden you're still reserving
the space in the page so if you hit
stuff but then like you change the
height and it ended up pushing it up
then you would still end up with a
reflow thought there was one more yes
display:none helps a lot when you yeah
so I discovered a few years ago in IE
everyday if it was six or seven that we
took the display:none approach and we
made some changes and even though
elements have display:none ie would
still take action on it in this case we
were setting a background image and it
would normally background images aren't
downloaded until their element is
actually visible and even though the
element was display:none ie would start
downloading the background image so we
our page was slow because we're
downloading all these background images
when we thought the elements actually
weren't going to have any effect but
they were in the Dom and ie ignored
display:none so I think removing them
and then adding them back is actually
better take up from the performance guru
did you do any measurements of across
browsers of different links prototype
chains I did but I didn't include it in
this presentation but generally the the
prototype the prototype chain issue is
the similar to the scope chain issue is
the longer your prototype chain is in
the further into that prototype chain
that you need to go then the slower the
the retrieval of the property is going
to be did you have the same pattern of
winners and losers yes that that pattern
didn't change very much regardless of
what specific performance issues I was
measuring
trying really hard not to pick on any
particular browser so the last time that
reflow may occur is when layout
information is retrieved and I say may
occur because at times during the life
cycle the browser may cache up a few
reflows and wait to do them and if
you're trying to access some layout
information that may trigger the reflow
immediately to make sure that that
layout information is correct so a few
of the things that may end up triggering
reflow such as offset width and scroll
left and then accessing information from
get computed style and those can all end
up causing reflows if things are cached
up ahead of time so again not every time
but something to watch out for so if
you're going to be using that sort of
information certainly if you're going to
be using it multiple times in the same
function you should try to minimize that
by storing stuff in a local variable and
then using that instead just to make
sure that you're not going to be
triggering reflow by mistake so and some
of the stuff to speed up your Dom be
careful when using HTML collection
objects perform the Dom manipulations
outside of the document if possible
change CSS classes not CSS styles and
try to group those changes as much as
possible
be careful when accessing layout
information because that may trigger a
reflow as well and really the the
overall message is just be very careful
when you're touching the Dom because it
can affect your performance so usually
when we're talking about performance a
lot of people like oh man if browsers
would only be better than we wouldn't
have to worry about this like is this
going to be forever and the happy answer
is no so we have a few browsers making a
lot of headway in this respect so bunch
of browsers with optimizing engines you
may have heard of this chrome browser
that has v8
in it there's also safari for with its
nitro engine there's Firefox now
three-five with trace monkey aqua is
also working on one unclear if that's
going to be operatin opera 11 but the
cool thing is that they all use native
code generation and just-in-time
compiling to achieve faster JavaScript
so finally we'll have all of the
optimizations that compiled languages
have and you already saw that in the
charts that I was showing earlier that
the more modern browsers their
performance just blows away the older
browsers so hang in there hopefully it
shouldn't be too many more years before
we're out of this mess so just to go
over we talked about today mind your
scope scope chain management is
important local variables are your
friends you can use them all over the
place a function execution comes at a
cost so be careful of that
keep your loops small as much as
possible and avoid doing work which is
what I try to do not just in JavaScript
but in life minimize the Dom interaction
as much as possible and of course use a
good browser and encourage others to do
so so questions but look ok so that was
more of a statement not a question but
that's ok yep
he does you should be up here so I'm
wondering I'm wondering about this the
scale across the the different things so
for example I want to access this Dom
object a lot so do I do it once globally
as opposed to doing it a bunch of times
locally I'm sorry can you repeat that is
oh let's say for example I want to get
at a Dom object and I could do it once
globally just at the top of my
JavaScript I could say you know barfoo
equals get element by ID block and then
in each function they can access it or I
could say well gee you told me that that
I should use local variables so maybe
I'll just do it locally and not keep
accessing that global variable but now
I'm calling the Dom ten times or across
ten different functions does that make
sense yeah so I mean it really it really
matters where you're seeing the
bottleneck so that's what I started out
with is I was assuming maybe a Dom
access was a magnitude slower than a
global scope access oh I see so really
talking about Dom access versus
accessing local variable yeah again it
kind of depends on what sort of effects
that you're seeing as to what what
approach you want to take usually I
recommend that if you're going to be
accessing any Dom element multiple times
that you store it somewhere other than
just on the Dom whether that be in an
object property or a local variable that
can be up to you
I usually don't recommend storing it in
a global variable just because then you
still have to have that extra step up
the scope chain in order to resolve that
identifier set answer your question okay
Steve yeah I had two questions I'm
embarrassed to say I've never used
create document fragment before is that
supported across all major browsers yes
great document fragment is supported
across all major browsers and then a
bigger question is that comes up a lot
with these types of performance
optimizations is a lot of times it's
hard to get the correct prioritization
of tasks like this compared to other
things like UI changes or new features
do you have any success stories or case
study feedback about how these
techniques were applied and what kind of
you know huge or marginal impacted head
on the site yeah fortunately don't have
a lot of it recent anecdotes I can add
because of the nature of my work
recently but when I started Yahoo I
worked on my yahoo which is the
personalized home page product and we
were rebuilding it from scratch and we
did have some performance issues
initially and a lot of this stuff ended
up applying the major things that we
found were cutting down on dom
interactions were what helped to speed
it up and and when I say speeded up what
we consider to be the most important
thing was really the the users
perception of how fast the app was and
so initially you know we go with a few
beta users people say oh it's slow let
me say okay so what can we do so we went
back and looked over the code and what
we found one major thing was that we had
a ton of event handlers attached to the
Dom so as you were going around the page
there was all kinds of stuff that was
happening and that tended to slow down
the overall page interaction and that
really annoyed people so we went to a
vent allegation which unfortunately
didn't have time to talk about today but
it it follows along with the touch the
Dom as lightly as possible theory is
that when we reduce the number of event
handlers that we had on the page when we
stopped doing animations as the
gentleman mentioned earlier you're just
doing style changes all the time
we removed what I consider to be
gratuitous animations all of the
performance complaints started to slow
down I mean there's always somebody
that's accessing it over some modem
somewhere that likes it slow
but generally speaking the the biggest
bang that we got for the buck was
managing our Dom more effectively we did
end up going back and optimizing a bunch
of the loops that were in the product as
well because there was a bunch that was
going on when the app was first starting
up but really the biggest thing was just
dealing with all of the Dom issues yep
so the Marla is pulling lots of
gratuitous animations in the beta and
then take them out and everybody will be
so happy that won't bother you
thereafter yeah it's it's incredible how
well that works one question about the
global variables you know do you think
it's a better idea to use some like
static variables instead of a global one
for example you know if I have like 20
global variables I split them into like
three groups and for each group I create
a you know global class but you know for
each variable i you know define them as
static members of you know each
individual class you know would that
improve the speed I think the problem
there is that you're then invoking the
property access performance penalty as
opposed to just accessing regular
variable so I'd say whenever possible
trying to keep stuff that you're using
frequently in variables is a better way
to go versus storing it on a property
regardless if it of if it's you know a
static property on a constructor or a
property that's on an object somewhere
sure any other questions
yep oh excuse me how do you do your
benchmarking for the cross browsers you
so I I built a page that is essentially
just a performance test suite and go in
and I have a bunch of different tests to
run and then I specify how many tests
and it just kind of goes off
automatically times it you know with all
the caveats to come with using a date
object for timing per number of
iterations and then it does
a number of times and then takes the
average I can after this is over I can
send some URLs to Steve if he wants to
distribute it out if you want to play
with it yourself and then the other
question I had was it sounds like like
for for each and when you're talking
about the four loops that all of these
things are coming in future versions of
Java Script or ECMO script and they slow
everything down so like why are they
putting them in or why do they encourage
people to use them if it slows it down
in phonetics well I I think that there's
there's a difference between encouraging
people to use them and providing them
for people to use because there are a
lot of people that write JavaScript that
aren't all that interested in
performance and then these become
convenience methods for them you know we
can get into a long conversation about
for each and why that was interesting
and necessary for ACMA script for XML
but the array dot for each you know it's
one of those things that people seem to
have been clamoring for and I think the
evidence of that is that it's in every
major JavaScript library and if we
implement it natively in the browser
that's going to end up being faster than
any of the library implementations so
you could argue they're doing a little
bit of a little bit of help to the
JavaScript libraries in terms of
performance but I don't think that you
can say just because it's there that
we're encouraging people to do something
that's slow because if if what you
really care about is usefulness then
they're incredibly useful if what you
care about is performance then not so
much but you know you could say the same
thing about like why was the with
statement ever put in if it is so
horrible and people have been saying not
to use it for so long at some point
somebody thought it was a convenient
thing to put in and so it's there
hi are there any good JavaScript
profiling tools that will tell you which
parts of your code are taking most time
well
Firebug is of course the the obvious one
that does pretty well WebKit has a new
profiler that is kind of slick you
should check that one out
Yui has a profiler utility but it's
targeted so you need to say specifically
you know I want to profile this function
and then go and run that versus just a
general profiler but those are the three
that I tend to use I haven't messed
around with the ie8 one yet maybe I'll
go home and do that today but generally
those are the three that I use okay so I
give my closing if you want if you want
to contact me at all
they're the various places to do it and
then all the beautiful images here
Creative Commons so that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>