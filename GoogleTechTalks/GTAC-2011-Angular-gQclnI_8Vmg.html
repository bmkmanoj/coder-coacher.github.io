<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2011: Angular | Coder Coacher - Coaching Coders</title><meta content="GTAC 2011: Angular - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2011: Angular</b></h2><h5 class="post__date">2011-11-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gQclnI_8Vmg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we are down to two talks both of them
are going to be absolutely killer I'm
really pleased to introduce the next
speaker myshko and I have been working
together as long as I've been at Google
because you were there way before that
you're also at Sun some we were at Xerox
yeah yeah and we're on Toby adobe done a
little bit of everything myshko is very
active in the open source community
jstestdriver and angular which you're
going to hear about today which is all
the rage at at Google we've never been a
particularly IDE we don't do much with
IDEs and we've actually done a lot with
this one and and you can too because
it's completely open sourced mishegoss
also are kind of agile coach in
residence at Google as well he travels
around the company and helps people
release faster and do cooler stuff on
the web so i am not going to say
anything else just give it over to the
guy with no shoes it's a requirement I
don't know how to get one maybe he'll
tell ya yes we have a couple these fancy
t-shirts and we're going to give them
out for good questions it's a
requirement if you work on on the
project you do not wear shoes so all
three of our developers are shoeless but
let's talk about the project not about
our shoes so what's angular but before
we talk about what angular is I want to
kind of set the stage and talk about why
are we doing this presentation and then
is that I wanted to call to actions if
you are building a library or framework
or whatever else it is that you're
sharing with the rest of the world make
sure that that library not just does
awesome things but it also has an
awesome testability story you know too
often you start building a product you
you go out and you you look at all these
libraries out there and you start using
them and you say graded that's exactly
what I want but it's not really testable
and that's a big part and so one of the
things I wanted to make sure when we
were building angular
is that testability is something we
thought about from very very beginning
all throughout it means premium
permeates what angular is all about so
what is an angular well it's what an
HTML would have been had been designed
for web applications I know it's the
kind of a little vague statement but if
you think about it HTML really wasn't
designed for web applications I was it
was for building static documents and we
kind of hijacked it to turn it into web
app and I think a demo is easier than
talking about it so let's do a quick
demo so this is a simple application
really nothing fancy about it you just
have a list of phones that run Android
operating system one of things you can
do is for example you can search they
can say hey show me all 4g phones and it
automatically searches this now if you
think about is if this is a web
applications the kind of things you
would have to do you'd have to register
listeners over here and then the day we
have some kind of template for each
phone and as you type stuff here the
templates has to be shrunken and
expanded and if i delete now it has to
be expanded back to the original size
maybe i want to sort this by whether
it's newest or alphabetical right
nothing fancy over here it's an ajax
absolutely i've seen millions of times
before but if you think about it there's
quite a lot of code in order to make
something as simple as this and that's
because the way the browser's are it's
all about documents not about the
application and so let me show you the
code behind is what makes angular
possible this is just the HTML page
Twitter bootstrap it but really the
magic is here and this is the basically
it says if you are a particular route
this is the phone list route so if it's
if the URL ends and / phones run the
phone this controller and the phone
lines controller is right over here if
you notice the only thing the phone list
controller does is it says that the
current ordering scheme is by age and
the the list of phones well go find a
phone and run a query and phone is
defined in our services
basically as you know just grab an xhr
from this particular URL I don't want to
get into details about how all this
stuff works the point is it's not a lot
of code and the reason it's not a lot of
code is because all of the magic is
inside a template which can do fancy
stuff like right here this is your input
box as you type in here it automatically
this is the list of phones we got from
the controller and in automatically
filters and changes the list of items
this is just a quick overview of what
angular is and how you can build it so
as you can see there's very little code
to actually make this thing happen but
let's talk about testability because we
are here talking about testing not about
application frameworks so so this is
what angular is and let's think about
how people develop code right so first
you got software engineers and they
write code and this is true for whether
it's a framework or application or
anything else and I made it a big red
box because the red represents bugs and
that's where the bugs are put in right
that will put the bugs in there and then
we have usually some QA and they usually
run some kind of manual test or
exploratory testing and at some point
they like figure out what's wrong with
it and people fix it and at some point
people say well that doesn't really
scale and we need to have automated
testing and so we have to figure out how
to get the test to run automatically and
this is really what the conference is
all about you know how do we do this
particular step so most people start
looking for some testing magic at this
point now there's a lot of different
tools of this level that you can do or
you can you can have but it turns out
that all of these tools have the have
value but they're not the panacea
they're not all that you want they're
just better than nothing but really the
magic actually doesn't happen here the
magic happens up there and the magical
part is not some special tool but the
way you design your code in other words
is the application design with
testability in mind and if it is the
whole testing story looks a lot better
than any kind of tool you can put both
after the fact and so if you are an
application developer or if your library
the report which is even more important
you should have not just the story of
what you're solving but also how are you
going to solve the problems of the
people who are going to use your library
for building tests and tests on them now
it turns out testing is the sum of a lot
of different things so first of all we
have the best practices which is you
know using stuff like global variables
bad idea a dependency injection that's a
breast practice having the tools whether
it's selenium for end-to-end tests or
something like this this driver for unit
testing having the right environment
which is kind of a catch-all there's not
even a good name for this in developing
the world but really it's all of the
pieces that you need in order to read
your first line of code if a new
developer comes in you know that to set
up whether it's the database whether
it's the the IDE whether it's the tools
or servers or deployment strategies so
there's lots of pieces that go into
environment the choices of libraries
will affect your testing story and
finally just knowing how to write a test
is what goes into this and it turns out
if you're missing any one of those
you're not really going to have a good
testing story and and it turns out that
the unit testing story is is different
from an end-to-end testing story so
while there's a lot of overlap you know
just because you're an expert at unit
testing doesn't automatically make your
test expert of end-to-end so how can a
framework which is really meant for
building Ajax application help you do
better testing well because angular is
very opinionated about the whole
building process of an application into
and not just you know it's a framework
for helping you manipulate the Dom so
that you can build an application but it
also has a lot to say about the best
practices you know this is how we think
you should set up your application
because if you follow these guidelines
and you set up the application of this
particular way you're going to have much
easier time testing is and one framework
does this particular well it's for
example Ruby on Rails you know it Ruby
on Rails is a very opinionated framework
that says you know this is how these
setup controllers this is how you read
the unit tests and so on
and they have a pretty good testing
culture so we're trying to do the same
thing with our framework as well we also
come with set of tools whether it's
jstestdriver for unit testing or our own
scenario runner for end-to-end testing
will show you in a sec we also have
already made kind of a seed environment
for you so that you can get started and
many of the libraries for testability
and for third parties we have already
chosen because we think these particular
libraries fit well into testing story
and so we put all of this information
really into a knowledge and we offer
that to you so let's talk about unit
testing story so the first thing that a
library can do for you is just set up
the dependencies correctly so one of the
you know this is basically what a
template would look like and this is the
controller behind this template and what
is very very subtle here but makes a
huge difference in testability is that
the dependency flows from the UI to the
controller in other words the controller
does not know about the UI now why is
that make such a huge difference well it
makes a huge difference because if the
controller doesn't know about the UI
that means you can instantiate the
controller inside of your test without
resorting to having HTML present as well
so a very tiny decision in the way you
set up your project or the way you
choose to implement features of your
library has a great impact on the
testability story of the application so
by a simple fact that we make this very
clear separation between these two parts
we have already enabled a very good unit
testing story for you the other thing
that you're going to notice over here is
that there is no Dom manipulation here
whatsoever right so for example here
when I'm fetching the list of phones
from some JSON feed once I get the
response I simply assign the list of
phones into my property and select the
default one believe for the default
image for the first 20 for and that's it
I don't go and update the Dom this
angular is the really the magical part
which then goes back and back fills all
of the
items over here whether it's a repeater
and so on now what would the test looks
like because we can now write a unit
test without HTML this is what our
controller looks like over here and here
is a test for it notice it's a pretty
straightforward test I wanted to
highlight a couple of pieces in green
because this is the Troublesome part
right you have a piece of code that
talks to a server but instead of a unit
test there is no server and so we wanted
to make sure that when we allow you to
build a web application we also the
story for you how do you do this and the
story is that you will do this through
we have marks for you basically so
angular not only comes with you with
everything you need to build an
application but we also automatically
provide out of the box all of the mocks
that you're going to need whether it's
testing ex hrs whether it's not a ting
for different URLs and so on so how do I
run it right this is the knowledge of
what tools do i need like this test
looks nice and pretty but unless you can
execute this we're not going anywhere so
first of all we have chosen what we
think is a good testing platform which
is something called Jasmine how many of
you guys have heard jasmine how many of
you guys like it yes not so many most
people okay come on Jasmine's awesome
Amy have a runner which we have chosen
which is in this case jstestdriver I
might do a little partial to
jstestdriver but it's corey in the
audience corey the man behind the
Justice tower back there so many
questions that's the guy to talk to and
so let me give you a demo of what this
particular thing would look like oh so
what is this setup well let's just do a
demo so the demo is
ok so the way jstestdriver works is you
first start a server and then you
capture the browser so let's grab this
tab over here notice the the browser
gets captured it becomes green and the
nice thing about it is at the point it's
captured basically do this once at the
beginning of your day you minimize it
and you never worry about it ever again
now go to your favorite IDE and you can
execute the test so let's look at the
tests over here and I can execute the
tests very easily basically by hitting
save and you can see the test execute at
the bottom now here's the cool part
about it the cool part is when i'm
developing I never had to leave the IDE
so let's cause a failure
I can immediately run it and you can see
that it says you know the issue is
online 65 that this particular
expectation has failed surprise surprise
but the cool part is that that you can
really do it on every save you don't
have to leave the IDE its built-in right
this is the kind of environment that we
when I talk about you know it's it's not
sufficient to just come up with the
testing story it also has to be that the
environment that we give you has to be
so that writing the unit test is
actually easier than trying to launch an
application in doing three so what's
cool about our unit test well first of
all there's no HTML files which means
that your web developer can go off and
start building the UI and the web
designer who basically creates the UI
can figure these parts later there's
super fast I forgot to point this out
but look at the timings over here on the
bottom we have executed whopping 0 for
this I know it's not a lot but it took
us five milliseconds which means it's an
average of one test per millisecond for
example for angularjs the our framework
has about 1,000 test and it takes about
two seconds or so to 82 run 1,000 tests
if you can execute so much code at such
a high speed you can basically run your
test all the time on every save now the
reason why the tests are fast is there's
several reasons for it first of all
what's low in a browser is the Dom
manipulation right and so our unit tests
have no Dom manipulation there are use
cases where you want to test DOM and we
have a different testing story for that
but for unit test where you simply are
trying to prove that the code you have
written works properly the DOM is
actually a detriment the other thing
that makes test slow is talking to
servers but here we have provided you
with kohler with marks so that you don't
have to talk to the servers and so you
have the full mocking so all of the test
basically execute synchronously there's
no callbacks inside of our unit tests
makes it fast I will show this but
basically we can execute the test on
multiple browsers in concurrently so if
you have just test driver and I can go
in and I can capture as many browsers as
I want to get it on to that one server
and that every time I hit save in my IDE
the test will all run in parallel across
all of the the browsers and i will get
the report back and what all of this
allows us to do is to run our code on
every save and this is really the
magical part which makes it much easier
to work with do test-driven development
is because the tax of running your tests
is so low is there's no reason not to do
it all the time right so it's so cheap
to run these tests then I can hook up my
ID to basically run these tests on every
time I hit the same key and the more
often you run your tests the easier it's
going to be in terms of finding bugs and
issues and realizing when your tests are
broken I showed you a demo so now that's
the unit testing story let's talk about
the other extreme which is the
end-to-end testing story so in the intro
intestine so in the unit testing story
basically said well we don't want to
have any HTML we're only interested in
inside of our code so in end-to-end
testing story we say well we actually
want to navigate the browser through the
full paces so that we basically are
pretending to be a user so we start with
a blank browser we enter some text
inside of the URL we come to a
particular page that shows us the list
of phones we enter some text into the
search field and we want to assert that
we now only show two phones out of them
all and finally we want to click on a
particular phone and go to the detailed
view page and then show basic the
details for this particular phone so
that's our scenario this is what would
like to test so how would that look like
well in traditional in traditional
testing systems this is the kind of code
you would most likely right this is not
the actual code you would write for
angular I'll show you the actual code in
a second but I want to demonstrate the
kinds of issues you might run into
so first of all you would say well go
navigate to some URL where the
application is running but now you have
a problem you don't know how much to
wait because you don't know how long it
will take for the browser to navigate
over here so usually going to the way
people solve this they have a polling
functions we basically runs every few
milliseconds and checks to see if
something becomes true and once this
part becomes true you can execute the
second half of the test to mystically
continue so now we want to input into
the search field some value and
basically gonna have to trigger an event
to simulate that the user has entered
and now that we have the same problem
again we don't know how long to wait
because it's going to take some time for
the UI to update and refresh and all
that stuff and so we again have to do a
little bit of weight over here now the
trouble is if you wait too much your
test becomes slow if you don't wait
enough your template has become flaky
because sometimes you just start running
before the tests are really done so
furthermore we grab the UL which
represents the the the items we counted
the number of items is two and then we
find the first item in the list and we
click it and again we have the same
problem where we have to pull because we
don't know how long it will take to
transition to the next page fetch the
xhr from the server and so forth so the
trouble with a test like this which is a
typical end-to-end test there's just two
problems with it first of all it's not
clear how much I have to wait between
different pieces and the wood comes back
to it and it is that the callbacks are
really breaking our our thought process
right people don't think in terms of
callbacks people think of in terms of a
list of things they need to do and so
these callbacks while they're fantastic
in terms of what the JavaScript allows
us to do with a single thread they
really break our concentration model
when we're trying to write a unit test
and so this thing has to be taken care
of the other problem is we don't know
how long to the pool or wait for things
and that really affects that the unity
the end-to-end tests are usually either
slow or flaky and the cause of this is
typically pulling and waiting
and we of course need to know when
things are done now the framework might
know that it's finished doing something
and therefore it's okay to go assert the
next step in the test but it's not
really easy to figure this out from
something like webdriver selenium unless
the framework is in some way cooperating
and lastly when we showed you the
templates we had these binding selectors
in there which basically said double
curly and said phones that whatever but
when we are trying to assert that the
right data went into the template we had
to use CSS selectors so we had a
discontinuity between what the thought
process we had for writing the templates
in the thought process we have to have
for writing the unit that so all of
these things together make it that it's
very difficult to write large-scale
sustainable test in the raw format and
so we have to have solutions for all
these pieces so this is what an actual
test looks like in angularjs and all of
the issues we mentioned the second ago
have been solved so first of all we
navigate to URL notice we simply go and
execute the next step which is we say
well find me the input which is bound to
the query variable and simply enter some
text into it I don't have to worry about
triggering any events and I have to
figure out where this input is in terms
of the CSS I just need to know that it's
that query parameter that's buying to
now the important thing to realize here
is that the framework basically figures
out on its own how much to wait before
running the next step and it does so
because the framework is collaborating
with the test runner and this is an
important part that if you go out and if
you build a library or framework as i
said earlier but you really don't think
about the stability simple things like
that essentially become death by a
thousand cuts right and so when you
build your framework for other people to
use you have to think about the whole
story not just you know solving a
particular need so anyway so what
happens underneath here is that the the
angular framework knows when it's busy
doing stuff and basically when is
finished it notifies the scenario runner
that hey I'm done which means you are
free to go and execute the next step in
the sequence so here and that basically
gets rid of all the pulling or all of
the callbacks so next piece is we go and
we find our repeater again instead of
using CSS selectors which is not the way
you think about the whole process you
can go and use phone in phones and what
these things become like a repeater
input or enter it becomes kind of a DSL
domain-specific language it becomes the
language with which you communicate with
your application right you don't talk to
your application in the low level in
terms of CSS and events and so on
between steady you build up something
that's meaningful to you and then again
helps with the end-to-end testability
story because you really want to make
sure that this thing tells a story right
this has to call the scenario for a
reason because you're trying to describe
a scenario a story to it and if you have
too many callbacks and too many CSS
selectors basically the story gets lost
in the details of it so it's important
to have a DSL as you can see over here
notice when I for example click on
something or here's a when I find my
inside of my phones and I find the first
row and I click on the a element again
whole bunch of stuff happens over here
where we have to fetch X hr's we have to
change HTML templates we have to compile
template and this takes some amount of
time before the next step execute so
it's very much simplified for you so
what is what the scenario runner so not
only do we give you angularjs which is
the framework for building your
application we also give you a scenario
runner for branding your scenarios and
what that allows you to do is right
asing to turn your icing nature of
JavaScript into synchronous tests
because that's what fits better for
writing in at this int Olympus and
result of that is that there's no
callbacks the way this is achieve as I
said earlier is the angular exposed
specific hooks so that the scenario
runner and the framework and collaborate
and achieve all these things so
basically we need to know when things
are done
and what that allows you to do is we
won't make the test run faster because
they wait just enough time to get the
job done not longer not shorter and
finally as I said it allows you to build
up a scenario so the language by which
you're describing what you're doing is
very specific to your domain expertise
of the application rather than generic
CSS selectors and so on and let's do a
demo so what does that look like so the
same exact application I can execute
okay so as you can see it's executing is
in its a every single step as you can
see this at at times it took for a
particular test and you can see
individual steps right so it took 300
milliseconds to navigate to a page but
then asserting things within the page or
vertically quickly but then when I when
I transitioned should it doesn't have as
transition see if I can find at this oh
I can't find at this but you would see
that there would be a bigger time for
the transition pages because there's a
more expensive inside of your code these
tests look straight forward they look
like this they look very much like unit
this but really it's an end-to-end
testing story now the cool part is that
we can also do the same thing for our
documentation for example here's a
bigger case where this is running
actually our documentation into an
testing story so you can see that that
kind of eating our own dog food
ok questions
we have some nice t-shirts for the
questions yes back there yes in the
green shirt so could you compare what
you just described with a scenario
runner to what we saw earlier today with
the writing tests in plain English and
how do you feel your tests are
maintained and and and are written in
plain English versus in a very
expressive API which is what looks like
you have okay so there's two parts to it
really first of all should you be using
written English so there is I don't know
what tool you're referring to because
unfortunately it was the cucumber thing
the cucumber okay yeah ah cucumber is an
example of that I think having plain
English is very useful because it allows
you to tell a much better story story so
that's advantageous but my cucumber by
itself doesn't solve the other problem
which is that the framework needs to
tell basically cucumber at which point
it's done so that the next step of the
scenario can be executed and so that's
the piece that is missing we simply
chose to stay in the language with to be
consistent throughout the project to be
with JavaScript all the way through now
I said that we're opinionated about the
way you should test your applications
we're not saying this is the only way
you know we provided the hooks we expose
them to you and you're free to integrate
cucumber into your testing story but it
turns out that most people either
haven't heard about cucumber or if they
heard they're not exactly sure how all
the integration should be done and even
if they have the know how it's going to
take them amount some amount of time
integrating it and so the point we're
trying to get to is that an application
framework or or library should really be
available for you use out of the box and
it should include everything not just
the feature that you're trying to do but
also a testing story the adapter is the
environment and everything you need to
know to get going if you don't like that
particular set up your free to change it
but it should at least have a setup to
get started with by the way I like
cucumber I think it's great project hi
so you mentioned that angular can get
Layton sees of all different URLs or
whatnot in your user scenarios have you
tried using angular for any kind of
performance testing for latency
measurement on the way load runner or
whatever some other we have is divided
we haven't tried using well so it's a
kind of a multi-level question in their
angular in itself is a is a framework
for building web applications you can
use the angular comes with the scenario
runner and the scenario runner could be
used for latency testing but we don't
have anything out of the box probably
should add it to the system but we don't
have it just yet Gail are you being kind
enough to give people t-shirts yes
so um when it comes to jquery and
angular can angular kind of reuse jquery
yes the question so if you think about
what jQuery is John resident who's
pretty the original author of jQuery is
done a fabulous job of abstracting all
the differences between the browsers out
and also he made a was relatively
horrendous Dom API and some into an AP
at it's very easy to use but if you
think about it little further jquery
doesn't change the programming model in
which you interact with your Dom you
still have to register callbacks you
still have to manipulate the Dom etc I
like to joke that you know jquery
shouldn't really exist if the browser's
got the job done right right it's really
a a shim on top of the browser's to make
them consistent between each other but
the difference between jquery and
angular is that angular raises the level
of abstraction to a much higher level
right jquery provides you a very
convenient way for selecting Dom's Dom
elements and updating and deleting them
but at the end of the day if you wanted
to see the demo where I started typing
characters and items got removed and
added into the Dom you would have to be
the one who would register the listeners
you would have to be the one who would
add and remove items into the Dom at the
right location at the right time you
would have to be the one merging the the
model which is the content of the
information about the phone into the
template and angular really takes all
that away from you and the only thing
you have to do in angular just say look
here's a bunch of phones I have here's
the template there's a director that
basically says ng-repeat which says you
know duplicate me for as many phones as
there are in a template and really I
don't want have anything else to do with
it if I add items into the phone list
the UI should automatically grow if i
subtract items from the phone list the
UI should automatically shrink and i
simply shouldn't have to deal with it so
jQuery and angularjs is really not a
fair comparison because it's really too
front things right jquery is a low-level
Dom API whereas angular is a higher
level framework specifically for crowd
applications I think there was a
question over here and then I'll get
back okay can you elaborate around how
the test runner and angular a framework
talk to each other and figure out when
things are done because as I see a web
app is continuously doing things right
so it's not obvious to determine when a
the next step can be executed right so
angularjs framework basically sits
between the browser in your application
code and all of the events go through
angular framework so that what does it
mean that means all the X hrs all over
the callbacks from the server all of the
clicks any interaction with the Dom
basically goes through an angular layer
therefore at any given point in time
angular framework knows if there's any
outstanding callbacks in the queue and
if there are outstanding callbacks in
the queue that means that application is
not ready so when the application is
booting up and you controller loads and
the controller says go talk to the
server and go fetch me the list of
phones because that's a JSON feed there
is an outstanding xhr callback that
hasn't been fulfilled yet and that's how
angular knows that it has to wait so
what the test runner basically does is
it simply hooks into the framework the
angular framework and so angular
framework has to have an API that it
exposes and it basically says please let
me know when the number of outstanding
items is zero because that's kew to me
that I can go to the next step and so
that's basically how that works and I
think there's a question down here yeah
thank you for presentation just wanted
to clarify some things is it like you're
trying to create a web application
framework development framework and you
kind of try and replicate rails in
JavaScript yep Gemma so all those
methodologies and principles like and
making up in the end it framework yep
just curious what was the particular
girl to reinvent some tools and not
to pick up for example Jay behaved
together with webdriver and what kind of
browsers do support as well is your
acceptance testing framework okay a lot
of questions so first of all easy
question we arouser to be soo bored
currently it's ie8 and all the modern
browsers we used to support the reason
we don't support 7 and 6 is not because
there's anything fundamentally
preventing us but it's just a pain to
work with them so we if somebody really
really wants the support for 7 like you
just have to make sure that things work
and which you should be there but
anyways the next question was why don't
we use jb hey why do you reinvent in
some tools like a framework to set up
your sweet and then the driver of the
browser why do you reinvent some tools
like the harness to set up your sweet
and run it like a test runner and second
thing is the browser driver it's kind of
like look like looks like your event it
done right in your framework so you're
saying why did we reinvent certain
things yeah we just wanted to stay in a
single language we did the framework is
really meant for somebody who knows how
to write JavaScript and so we don't
really expect that person to have
knowledge of maybe Java or rails or any
other frameworks we wanted to be totally
agnostic to the world around them and so
we said let's make sure we have a nice
internet texting store testing story for
the JavaScript world and so we just
wanted to make sure we had the tools for
that so because and there are no tools
for JavaScript like that or how there
are okay cool make sense thank you and
also you mentions just to compare it
it's true that angular is has been
inspired in some ways by rails the
difference is that rails is wonderful
for building round trip kind of
applications right it's all about the
server that serves up some piece of HTML
but really all the interesting bits
happen on the server rails is the same
exact idea but I'm sorry anglers the
same very similar idea but it's all
about the client where the whole
application is in a client and we're
really actual
completely agnostic about what the
server has so we're just play jure izing
other people's wonderful ideas and just
turning them where the browser's the
center of the world all right so I i
loved the non waiting the automatically
waits until kind of all the xhr has done
stuff but with all magic occasionally
you want to sidestep the magic like if
you're testing ads on YouTube you don't
wanna have to wait for the whole YouTube
video to download before you can check
stuff in the ads so other ways of kind
of sidestepping the beautiful magic that
it does absolutely that would require us
to go too much deeper into the internals
of how the whole thing works but
basically what happens is when you write
the synchronous code so there's no way
to write synchronous code in JavaScript
right everything's always hating so it's
actually happening is that what the dsl
is is the dsl builds up an internal
state machine of what to do in terms of
testing and then a state machine execute
in a synchronous manner and the state
machine transitions when the right stuff
happens and this is done through futures
and so you can register just the right
kind of futures into the system and then
you can transition the state machine at
your own time really the synchronous dsl
is just syntactic sugar for programming
you could think of it the state machine
oh we have time for all right thank you
guys check it out and just one question
please just for you one more class this
is more regarding the implementation
part I understand that we could probably
have the developers working on angular
making the all the coding according
activity and then also running the unit
tests on from the angle itself that part
is clear unit testing path but when you
talk about end-to-end testing are we
expecting the testers or one who is
doing the end-to-end testing to also
work on angular am i clear
I so your question is are the end-to-end
pesters expected to know how to program
angular yes but not no not necessarily
because the dsl that is created inside
of the scenario runner is much
simplified and so it you don't have to
have the internal knowledge of the of
angular or JavaScript or anything like
that to be able to read one of these
things also if somebody would integrate
cucumber which is very much possible
then it would be even further less like
a code and more like you know kind of
paste these strings in the following
sequence and then the world works okay
you can catch me uh after the
presentation I'm happy to talk more are
you going to beer and brats later on yes
alright great well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>