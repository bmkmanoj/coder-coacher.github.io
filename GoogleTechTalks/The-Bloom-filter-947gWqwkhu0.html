<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Bloom filter | Coder Coacher - Coaching Coders</title><meta content="The Bloom filter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Bloom filter</b></h2><h5 class="post__date">2008-04-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/947gWqwkhu0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm happy to introduce le port from
bar-ilan University le visited Google as
a visiting researcher lost semester he
got his PhD in computer science in 2000
and then after that did this military
service and at the same time worked as a
faculty member about Elon University and
now he's back I think that his alma
mater at the Maryland University so
early and mainly worked on matching
problems and not matching in the graph
theoretic sense but pattern matching
string matching subsets matching and you
also worked on designing sketches and at
the distance and various other ethnic
problems and today he will talk about
the bloom filter okay
okay then I'm going to talk about bloom
filter today this woke part of this work
done with Somalia is actually part of
this light copy formulas Matias that's
mentioned that then the outline of the
talk I will start by defining the
problem give some motivation then I
gives a basic room filter some provement
and the last improvements that I know
then Paloma definition we start I have
you for problems for different for kind
of different problems the first problem
is given a set x1 until xn of a big
universe U of size a big game we want to
play pauses the set in order to answer a
membership query the second problem is
to do it you have a data stream on to
build a construction that will support
insertion deletion and query membership
and the third problem is that because
the second problem is to add to do then
we don't support a a deletion and the
fourth problem is when we have a data we
want to insert an element with the data
we don't support deletion as well and we
want to retrieve the data of the element
and some of the data structure will
enable us to change the data and when I
say that deletion is add you can say
that there are lot of data structures
that doing that
why deletion decision is add when we
want to optimize the space as well and
we see it in the next slide I want to
mention that the data is usually really
small it can be two or three bits a and
all of this talk I will will will
concentrate on how many bits I am using
then talking a set we have the set x1 to
xn a like before I said from universe
began the easiest way to store to store
a set is by storing
sorted array I still sorted array it
will take usually take n time log in
local big big n space because each
element take a log n space ok the coil
will be done in off log n there is a way
to reduce a space it's it's really
trivial I didn't I didn't put in a
reference I just air that there is a
paper way insula 2004 that mentioned
this thing there is a way to do it in n
log n over n plus little of n and this
way enable you insertion a deletion a
query and even you can add data then it
enables you all all that in it another
way to do it is by using perfect ash
than just the regular perfect ash will
take seat time n log n will see some
constant in depending on the
implementation of the perfect ash and we
live a value in of one a time and again
it can be improved to be C time n plus n
time log n over in the form that sorry
there our lower bound that we must use n
log n over n bits then what I'm doing
here then what I'm going to do is if we
allowed some mistakes then the lower
bound at all and the only lower bound is
Omega of N and that what we are going to
do okay it's clear still there okay then
what I'm calling mistakes and mistake
types when a query X if X in the set I
always return 1 if X nothing is I said
I'm a retell in one I'm a mistake
that's called false positive when I have
data structure that that I can retrieve
the value a then it won't a mistake
most of the data structure I want a
mistake on the way value but if it's not
in s it might be the case that I will be
we'll return some random value then use
little motivation there are a lot of
motivation specific in Google you can
think about SS table and seem like this
that you can improve the a the you can
improve the query time to assess a
balancing like this I give you a
motivation for internet cache protocol
when client go to poxy the poxy first a
second cache the cache is in the disk
it's take several millisecond and then
you get an answer that it is not in the
cache after it he asked the poxy self
ask all his neighbors boxes and they
returned to him that he doesn't find
anything and only then it go to the
internet you see that if I have four
boxes then for each query I will ask the
four boxes then then a it's a lot of
query it's a lot of time to get to
getting it in in the disk and I spent a
several milliseconds which you know
Google want to reduce say the query time
even from 200 milliseconds and seven
millisecond it's a lot then what are we
going to do I will go in to do some
allies of the cache by that was actually
like bloom filter when I asked in the
poxy it will it will go to its main
memory which will EV this summarize and
they asked if if this homepage is in the
cache here is the red arrows it's mean
that it's not in a that is answers it's
not in the cache you ask this is the
summary of let's say this foxy you ask
if it's in the cache of the second poxy
it answer that is not yes that if is a
indication with the self boxing then you
its answer that it's that is there but
it might be the case that there is a
mistake then is going to they're asking
you return an answer that is not fall is
Earth for example you asking the the
fourth box is here and then you go to
the internet then first of all
all of this thing was was done a against
the main memory then it was really fast
as you see I have I ever feel query for
each poxy because before each poxy got
all the query of all the user now only
the boxes that gets a query will get a
query and all other poxy will get a
query with low probability then because
of that it's called bloom filter because
it's filter the communication okay yeah
then there was the motivation now what
is bloom filter then bloom filter is
called after bloom from 1970 I start by
allocating an array of bits or the talk
I'm talking on bits then I start by
allocate array of M bits
I will describe what his aim afterward
is I read already in vegan and now I
have M a allocate array of n bits I have
this set x1 until next time I get some I
took some random-ass function and I ash
each element a 2 1 a and 2 1 until name
and I put one in the place of the ash it
might be the case for example ear that
there is a collision if there is a
collision I put one on one I don't have
a problem with that then that all what
they do now how query walk if I looking
for X I then I ask X I I always we find
one cell because my what I done at the
processing step was to ash
I to there and put the one if I going to
sick for y which Y is not in the set
then when I ask why it might be the case
that it will be the one but if the fuel
1 then 0 then it will be with slow
probability then the question is what is
the probability is that I will see the 1
then the probability is that I say the
man is depend on the number of ones then
actually we can
computed it easy to compute this
probability and actually if we choose m
to be n log e log E is on a base of 2 we
will get a probability of alpha now if
you want to reduce the the probability
of mistake we have two option we can set
m to be bigger oh we can run this
algorithm several times if we run this
algorithm k times each time I have you
another ash function a sh1t - K we will
we will get a low probability and
actually what I like in this slide that
we can a on the same array which
array will be a bigger there is
advantage to do it like this way because
in this way we can easily distribute it
and this way it's other to distribute it
then what we get given X we always say X
in s we always say that eating is an S
if X not in s if Y is not in s with
probability to the minus K we will wrong
and we say that it's in a in s the space
is NK time log E and the query time is
of K and I mark Loki and of K in red
because this thing I will improve okay
then what this bloom filter support then
actually I say that it it was clear
possessing the set but actually it
support insertion it's really easy to
inserting I just a and put that one
and it support worry it doesn't support
deletion okay because it might be the
case that there was a collision there
then I don't want to to take this one
and move it to 0 then bloom filter with
deletion our you will do that I will I
will I will put instead of bit I put
your counters and each time I'm
inserting an element I will increment
the counter
for I have your okay our function i will
increment each each each place each time
we want to delete we decrease the
counter with i probability the counter
will be bounded by log of k time n that
because if you if you saw in gray
let's say if you're slowing i don't
empty later if you throw in a d balls to
these cells then the biggest sale will
be logged e of a low-gravity then log k
n it's big is bigger than low K n over
log location then I I to save this
counter each counter will take me log
log of K n bits there is a little bit
problem you you say that it I will I
will word it all if I delete something
that is nothing the bloom filter you can
be a disaster
okay then the space is NK log log n K
okay it's clear it's only the basic
aspect on bloom filter I only sketch it
inspect on bloom filter you want to
retrieve for each element a data for
example how many times I saw this
element a counter then then way when I
want to set X I want to set to give him
the value D whatever what I will do I
will add D to all of this counter and
the an answer to the query will be to
report a minimum with I probability when
I'm adding when I having this counter
for X I which I probability one of the
counter is only for X I and not for all
the other and then I will will see what
is a value of x okay
another version it's another heuristic
there is when I when I want to set X 1
to B D X I to be D what I will do I will
probe all this location I will see which
play all the places that gets a minimum
value and I only increase the counters
that gets a that less than D I will
increase the I will increase that in a
way that the reporting will be correct
and then I want to for other other
element and there is a good secure that
if I see the same minimum twice then
with il probability is a correct value I
don't want to go into that's fishing
then result or a give another way that
was actual that to blue to bloom filter
which called blue mio filter this is the
first version I want I actually want to
skip that because the second version is
better than the version to version to a
bloom you filter the filter is as follow
is is based on on Mizuki paper from 96
and the key word is is AHG which is a
cyclic I pulled off I don't ear a
regular graph but you can think about it
as a hyper graph and what I'm going to
do I allocated a a locate your mm
vertices the N vertices will be the
array of size M now each of my my
element will be edge edge random edge
bye-bye my art function now the value
you this data structure support given a
value of the value of a element will be
the saw of the vertices of the element
for example the value of x1 will be like
the data is the value of a of this node
and this node so of them okay now you
see that I have a problem if I set the
value of x1
I said this note and this note and after
it I set the value of x to us and I said
this node and this node then I have a
problem with 6ly then what
mizuki done and societ all done is that
they because this graph they asked this
graph to be a cycling and with I
probability a random graph like this
will be our a without cycles then they
first they they find an order in their
order they will first give the value for
x slaves they give the value for that
and that and when I give gave the value
for X 3 now to give a value for x1 I
don't have a problem because I have this
free node then I can easily set the
value of this node okay this this type
of graph is only to the node you are not
only 0 and 1 it's a data it can be more
than 0 and 1 and no problem that it
would be a is that it will be 0 and 1
and except that what we are saying is
there is a problem for where it's better
to take it's odd because if it's a even
then you can see that for example you it
might if you have a it will be if it
will be must be a 0 1 0 1 or something
like this then my to some randomness but
I think that you can prove that it will
work as well ok actually the best way to
do it they can do it we say with - the
best way to do it say is to take our
graph of a of 3 it's been it means that
each edge contains 3 vertices and then
they get a
a space of 1.2 sleep NK and actually
this data structure doesn't support
deletion but actually they done a really
clever data structure that will support
a change in the value of element okay
then the lattice actually look like this
I want I don't I won't have time to
explain it then I jump here to a lower
bound and actually the lower bound it's
really easy you see the low bound
actually said that what I what I want to
I want to store a I have this this
amount of sets and I want to store them
but now I willing to add an AVO of 2 to
the minus K then I add to this set to 10
minus K time the big n element but now
it's said I can each one of these set I
can map it to this amount of sets then
for an information point of view you get
you that I need n time K bits okay
then now way more improvement then first
what I call tooth bloom filter from 2002
a tooth bloom filter it's a really neat
trick in bloom filter
I looked only on one place for getting a
I uh valve I look at K place to get a
bigger a smaller probability you know
what I will do I will look for example
you at sleep for each element I will
look at three places and I will ask that
that for example I will ask that at
least two of the places will be one for
example Xie is in the set then you see
that it is zero but here are two ones
okay
for example Y is not in the set then you
see that uh-1 of Y is 0 H 2 of Y it
might be one in H 3 of Y is 0 then it's
nothing it is not in the set and
actually for for bigger K it will work
better because you can see the normal
distribution then we actually get a
better result in in terms of space but
it will be a it will be of K as before
time then actually to get better result
you do need to do it offline
you do need to process it before because
you you want to see you want to see in
this array you want to see for example
if you see that this element a lot of
the X I map to him you give up to if to
one if for example this element you see
that only this X I mapped to here then
you put it 0 then you do some statistic
in order to to choose a which be to set
1 and which be to leave 0 ok compress
bloom filter is a paper form of meeting
myself then as I told you before the
bloom filter is not optimal up to factor
of log in log is 1 over LAN LAN 2
then incompressible filter I just
allocate a big array of 2 to the K time
n then you can see easily that the
probability of mistake would be a lesson
to lesson 2 today minus K and now what I
will do I will compress that I will cope
ways that I write you how many do I see
here at the beginning I see 4 after its
Lee and so on and so on this thing using
open encoding will take me any time k
plus 1 bits but the poem of this data
structure is that it's all the
information in order to give me
probability of mistake mm minus K but I
will do quiet time the query is a it
will take me a lot of time then is
algorithm doesn't super quiet or I may
use it in order to synchronize between
poxy like the first motivation that I
gave and when you synchronize between
poxy you don't Ave the poem by of
compressing them and sending the bloom
filter and then opening the bloom filter
at the second popsie then talk good for
him if I give a heuristic how to improve
is the algorithm then the eristic for oh
I will start by allocating not 2 to the
K time n I will allocate time 2 to the K
time n then it means that I have a
smaller probability to mistake and I can
I can manage I I can I can add this
probability because I have a smaller
probability to mistake so what I will do
I have the ability to add it once when
wherever I want this is the compressed
sentence of this and I added once
whenever whenever I want you each read
one is one that I add and you can see
that if I add this one according to my
mechanism of compression then I will be
able to compress it better for example
you see this thing is is a is bigger but
you can see that I hear a lot of flee
and it's a mole it can compress
more okay and it's really cute heuristic
explanation bloom filter I want to get
you a lot of into details but this is
the data structure that I done we say
yes and in this data structure we use
the compressed bloom filter that we
allocate array of 2 to the K time n and
with a data structure that is similar to
the rank data structure we've been able
to to get a random access to the
compressed string then it won't call it
we won't need to open the whole string
before we will fall query then it's
really the same like the same honey
seemed like a compressed linked data
structure and array over the details of
how it would be little of n but I won't
get into details and I only want to
remark that this algorithm work really
well if I walk in if I doing a bloom
filter on disk because in disk you can
say that the world size is a block size
and then I can compress more now a
another way to look on bloom filter so
in the idea of another way to look on
bloom filter or all these kind of sets a
set of problem is to look on the element
X 1 until xn and to ask them to some ash
1 a dilash mlh1 until H n is the ash of
the values is not the ash function now
each H I I will take to be log n plus K
you will see why it's log n in a minute
I will search when I given given Y I
will a to some H Prime and now I
check if the exist some I such such that
H prime equal to H I now what is the
probability if y is in the set then it
always return 1 but what is the
probability
that I will turn one if Y is not in the
set then probability is easy a the
probability of is that there exist ice
such that H I H of Y will be equal to H
I is is less or equal to the sum of the
probability it says it is a Union bound
which each probability is tooten minus
log n minus K I have an element then
it's 2/3 minus K then I add to use the
extra log answer okay then the only
question now is how to search this hl2
search for H pine and actually I
remarked that this thing walk whisper
was independent
I don't need the modern papers in the
Panettiere okay then one of the ID to
store this H prime is by doing ash then
what I call as bloom filter is I
allocate an element of size k plus plus
C and when I query X I just go to to the
place H of X and I see the award W and I
met if H Prime
if another H function H prime X equal to
W and what is the probability that a
random world will be equal then if if if
this is the world of X then it will be
equal if it's not in the set then the
probability that H of X will be equal to
2 W is to tune - came and you see but
now I have a problem with collision
because if to a element match to the
same place I will f2 to different w's
then I need to or some somewhere to put
them then what I will do I will do
another ash ash table of all the
elements that collide I ever you can see
that I have u 1 over E time in
that will fall on something that already
is there what I mean by falling on
something that Alyssa
if I put if it's not my H X and this was
empty then I put your W now I try to I
ate hy and it fall ill and it see that
it's full then I move to here I try to
enter it here with another ash function
and you know you need one over a time in
space and I will continue by one over e
to the power of 2 times N and so on
oh I can just cut it when it's enough
room for me and run another data
structure that supposed equally ok
actually to optimize it way to get a
better space complexity we can do
several e ash on one away and actually
we can move on more more of that we can
use you we will use Q n cells and
actually it will work better for Q when
Q is less than 1 and this data structure
is supporting insertion the other a
complicated data structure didn't
support insertion ok
and again it used only pairwise
independent - function now this is a
quick survey on a cook washing how how
many of you doesn't know what is cook
washing you don't know then I will start
by explaining what is cook washing then
cuckoo hashing is a really neat
technique to do perfect hashing it's
ashing that when you search for element
you will shall search only two places we
will search you will do Ashwin in search
the element you and and if you don't
find you do ash do in such element here
if you don't find it it doesn't appear
you do only twice three ash then query
is easy but how you build this kind of a
perfect hashing then the answer then how
I do insertion let's let's see now let's
assume that I want to answer
in telex and I get to Ashwin and it's it
falls out and I go to ash - and it's
full it's full fill it with something
else then I see you at the place of I
offer of of ash one of X I see you I see
a then what I will do I will move a to
the - ash - of a and I will see for
example it will be then we move B to ask
to him of B and what I am doing is a
change of of a of moving and I thought
is that the size of this array is 2 plus
epsilon n then you can see that Alf of
the places are empty then it means that
each step I have a probability of alpha
to stop then with really high
probability in average I will do off one
swap which I really I probability I will
do less than log n swap off logon swap
and with really high probability I won't
have cycles that will destroy a little
okay a cycle can destroy this data
structure then which I probably I wanted
recycle then this is cook washing till
need the technique by a page and now
cuckoo bloom filter cuckoo bloom filter
use the cuckoo hashing then first thing
as you see this thing is really wide in
cuckoo bloom bloom filter this thing
isn't isn't wide and other thing this
here it's a time n I just used a this by
little like this
you can change it to 16 or whatever you
want and what I'm going to do I will
even other I will have you array of an
element of white of K - Li you will see
why it
- Li you know in a moment and what I
going to do for for 13 for X I will
start by looking this array on H 1 of X
if I see you
zero I will say that X is not in the set
if I see you one I will say that X might
be in the set
but for checking if X is in the set what
I will do I will do rank query what is
blank query I asking on this array how
many ones I see before what is the sum
of the array until there is a link data
structures that can do it in off one
time and then I will go to this array to
this location I will know exactly which
location I'm going to and then I will
ask if it's equal if it's equal I will
say with I probability that X is in the
set and and you can see that I add a
probability of 1 over 8 to fail you
because only one of only 1 over 8 of the
element or our 0 and if I have a
probability it came in loosely I have a
probability of total minus came a class
Li that this will be equal but now
cuckoo cuckoo hashing and cuckoo bloom
filter it might be the case that it is
in h2 then if this thing's sale I'm
going to to pop to H 2 of X again I will
do a rank operation I will get the place
and again I query if it's the same and
actually what I am getting here I just
say that it's need off log in wise
independence ash function what I'm
getting here that using fall and my
movie bit I can support this array of
eight and bits with rank operation why
how can i stall eight and bit in foreign
bit it because i can compress it this
way
most of it is 0 then I can do it in so
in a memory bit and the space that I get
is n time k plus 1 plus little of n and
the query time will be of 1 because I
just go to this array dwell rank
operation which take me off one and it
compels the element and again go to if a
if it's fail I go to this place
the other incorporation compare
discernment
then it's off one query time and
probability for mistake ovule nine over
eight least nine over eight it depend on
this constant if I do it sixty name it
will be a seventeen over the sixteen
okay and this data structure actually
doesn't support insertion but I what is
support insertion because I can change
it a little bit that it will support
insertion then the first thing that I
need to do to change is the ash function
the ash function as you remember the
cuckoo the cuckoo washing when I want to
insert insert X it might be the case
that this place is full then I want as
an a we want to we ask the elements at
at this place then in cuckoo hashing I
don't have a problem to we ask this
element because I know it in cuckoo
bloom filter when I see you know one I
don't know what is the element our
canary a then what I'm going to do
I going to to describe a hash function
then first as I told you before I take
the X and a sheet a big X 2 log n plus K
bits what I'm going to do I will go I
will take this log n plus K bit and I
say that ashwin will be the first log
and last rivet which will indicate the
place at the 18 array and ash prime will
be the came and sleep a bit and when I
want to we ask for ash - then I we take
it in under display another split I will
start to will be the last log n plus 3
bit and ash double prime will be the
start of the ash and this will enable me
to do that I want to remark you that if
K is small it won't work because it it
will be it it will it won't be a random
F
then out to support insertions and I
need the something more when I want to
insert sing I have a problem that now I
will want to insert something in the
middle when I want to answer something
in the middle of array what I need to do
I will need to move all the element is
that after it then it will take it will
take a lot of time then what I'm going
to do I will allocate 1 plus epsilon
actually it need to be a parenthesis 1
plus absolute Epsilon in a element and
what I put here I will put it all gaps
and in order to enter something in the
middle it would be a faster okay then
this is cuckoo bloom filter I just want
to note that the was a paper of 16th day
dictionary it was in iCub 2003 and if
you look on Six Sigma dictionary it's
actually really similar to exponential
bloom filter then in 66 nationally you
can you can set your universe like
second is a compressed bloom filter to
be 2 K time n you have a universe of 2 K
a time N and you want to store an
element then in 1616 addiction you can
store it in this in this complexity or
this place space complexity and
uncertainty in off one and actually then
I said it really use the same way so the
exponential bloom filter it was in the
same time and actually the optimal bloom
filter that was published at solar 2005
it it used the 16th dictionary ok then
now I will show you something that is
more optimal than the optimal solution
which is nice to do something that is
more optimal by more optimal a the thing
is that ill you have you plus Big O of n
then it's really funny because you say
that it k plus 1 time n plus of n then
while you say this thing
and it won't work it really doesn't work
good enough for a little small K then
that what we will optimize then the idea
is solving equation I will start I have
set X 1 until X X n what I'm going to do
each X I I will I will ask to a vector
of size n plus C C is some constant now
I will look on the following equation I
will everyone until V n is the ashes of
X 1 until xn and I want to solve these
equations now I will say that with big
probability I will be able to serve it
this is the pole this is a bound on the
probability that I will solve it it it's
bigger of the probability that I won't
be able to solve it is a is less than 2
to the minus C when and when I was
solving it yeah actually actually if C
equals 0 I actually have concept
probability to solve it and when I serve
on it what I going to do I will build
the data structure I will build the data
structure by so solving these equations
and I and I will I will do query to do
query I just will take a ash of some of
some why I will give it will give me a
vector of size n plus C and I will do
inner product with this vector then what
we create is optimal space bloom filter
there are no X of n and actually this C
we can set to something like tool and OC
and it will be enough and then you see
that it take n plus 3 but it take a lot
of time to do the processing it's
solving equation and more than that
query time what is the query time we
need to do inner product in a product of
vector of size n it will take off n then
it doesn't it isn't really good then
what we can do then solution now one is
use past equation we can use equation
when VI will be will be only K places
that it's differ it will be K places
that it's one well K is small for
example K can be 5
I will leave you for example v1 it will
be to take be sleek so be 5 so be 7 so
be 10 so be 12 something like this and
then it will be easier to do the is a
query and actually actually it will be
easier to do to the purpose thing if we
take a variable density density I some
of the element will be some of the ashes
will be a density of two it would be
only this week so b5 or something like
this some of them will be of slee some
of them will be of a4 and the
expectation would be some constant the
problem with that that we will have this
off nth term in order to do that to walk
see must be a auto of n but when we say
order of n I mean by like one percent of
N or something like this then in
practical it's good enough because when
I say little of n I actually mean to n
over log in when I mean n over log n
it's a 1 over 32 time n then it's really
the same as as little often and solution
to is more way for a photo logical point
of view in solution to what I will do I
will I will ask this X 1 X n 2 n over
log to the power of 2 of n bucket and I
will do a solution for each bucket like
this I can do a solution for a bucket
like solution 1 but actually I can do it
in in the console I will take this
little bucket and we will separate it
again and when I separate again I will
separate it such in a such way that that
each little bucket here will be really
small it will be log n over 1.5 log log
n to the power of 2 and I didn't choose
this number from there it's by
calculation
when I have this kind of number I just
remark here that I can do all these
ashes really easily I need some polo
girl with McHale and on but I will be
able to to do that to calculate
tabulated to calculate the ash
functioning off one time it's really
easy and I choose this number because
when I have an equation set of V one
until V log n over 1.5 log log n to the
power of two I can say that's no and I
choose this path at this density I can
say that down
Szell Szell Szell few such kind of
matrices so it means that if the only
end to the disk test can find is I can
solve all of these matrices and I can
and after it I will go over these sets
and I will be able to give the solution
in all one I will I will just go to the
array of the solved mattresses I will
solve it in advance then the space is
this which you see you log log n to the
power of two then in case of a 32-bit it
will be a n plus this is a is actually
something like 1 then n plus n time 4 to
the power of 2 it's 16 over 32 then you
get your a 1.5 n but from political
point of view it's give you something
that is n plus a little of m and
publicist in time will take me often and
query time will take me of one because
all of the thing will be at world
operation and that it okay
otherwise I have a crystal you had any
questions from branch anchors to us
I compute them so I have a question so
the bloom filter is one-sided in one
direction right which works perfectly
for this proxy example and also for the
SS table it's open so we aware of any
data structure with just the same
performance but it's one-sided or in the
other direction okay so me need actually
so I was just curious
actually I just want to remark that most
of these things came from implementation
and not from Joetta Clark then most of
these things are really working and we
really squeezed this low key that we
intended to squeeze</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>