<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DocEng 2011: Optimal Automatic Table Layout | Coder Coacher - Coaching Coders</title><meta content="DocEng 2011: Optimal Automatic Table Layout - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DocEng 2011: Optimal Automatic Table Layout</b></h2><h5 class="post__date">2011-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aOvBaQfT6ZI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you everybody this is a joint
work with graham gange and peter Stuckey
of the University of Melbourne and also
Peter moulder from Monash University and
it's sort of a continuation of me
highest talk we're also talking about
automatic table layer and while we
interest in automatic table layout well
tables are used and provided a pretty
much all document processing software
and in most document processing software
editing tools it's really as me I said
really painful to layout tables to
determine the best way of choosing the
best column widths for example tables
are also widely used in HTML and other
web standards and so what this means
there's at least three reasons why
automatic table layout is important
firstly because it can make authoring
tables easier secondly because it cannot
support automatic adaptation of
documents on the web to different
viewing devices and in particular mobile
devices and finally automatic table
layout is really important if you have
dynamic content so and that's important
in variable data printing for example
but also for other content on the web so
automatic table layout is important but
as Mihai said the bad news is that it's
NP hard so this was shown by Anderson
and Sobti and the main reason that it's
NP hard is if you have text in the
tables then you have different
configurations different choices of text
configurations for the cells in the
table and choosing the right combination
of text configurations is a good example
of combinatorial optimization problem
because there are trade-offs are global
trade offs between the different choices
that you make
so because of this the majority of
approaches to table layout have been
heuristics most computer scientists are
scared by np-hard problems and they go
away and they try and come up with a
heuristic so one class of heuristics
such as the HTML table layout algorithm
is based on basically looking at the
content of a column and then using this
to to gets a column width so perhaps
proportionally based on the content
another approach is to use iterative
column narrowing or widening and then
the idea is that you start out from some
very for example some very wide
configuration and choose to narrow
column step by step while decreasing
increasing the height as little as
possible another class of algorithms are
based on the idea of approximating
approximating the table content by its
area so generally all of these heuristic
approaches well they have a polynomial
complexity that's why you're using a
heuristic but of course because of its
do not guaranteed to find an optimal
solution so here's a simple example this
was this was a table laid out with gecko
it's a fairly uncomplicated better so
this is a much more compact layout which
can be found with other approaches so
what are these other approaches these
are complete approaches so what we're
interested in doing in this tool is
exploring complete approaches for Table
layer that is complete approaches that
are guaranteed to find an optimal
solution what do I mean by an optimal
solution well we're interested for a
particular width in finding a minimal
height layout for most compact layup why
are we interested in complete approaches
for at least two reasons the first is as
a benchmark for evaluating heuristic
approaches for table they
so how good you are you're heuristics
well the only way to evaluate that is to
actually know what the optimal solution
is and that was our original reason for
doing this but also it may turn out that
these complete approaches in practice
are fast enough for real world
tablelayout now of course any complete
approach is going to have in the worst
case exponential complexity but as
computer scientists we don't need to be
scared anymore or necessarily scared by
np-hardness exponential complexity
because in the last decade combinatorial
optimization algorithms have improved
enormously okay so it's now routine to
solve hard large rostering scheduling
applications in other sorts of
industries however something we have
learned is that there's no one best
technique so there's mixed integer
programming which mihai was talking
about their a Star approaches there are
local search approaches there are
constraint programming approaches so
that naturally leads on to what I'm
going to be talking about but not quite
now with complete approaches if there
has been relatively little work on
complete approaches the main work in
table layout has been on heuristic
approaches so weighing in would quite a
long time ago talk to Brad a
branch-and-bound approach me high and
pat healy I gave a paper last year about
a nipper proach and me hai has another
the preceding paper here as extended
that but that's basically the work
previous work on complete approaches to
table layout now we extend this I'm
sorry so in this paper what we do is to
look at other approaches to complete
table layout so we look at three new
approaches the first of these is based
on a star the second is a traditional CP
approach and we also look at a CP
approach that uses learning I'll explain
those in a little little while we also
do a fairly complete evaluation
and in particular we look at real world
problems so something underpinning this
paper and the other two papers in this
session which i think is really
important for everybody to go home and
take home as a takeaway message is that
automatic layout really is constrained
optimization and this is a good way of
thinking about it so why is this well
layout requires finding position and
size for the document elements so
essentially we have variables which
capture those geometric properties we
want a layout which satisfies structural
and designer specified geometric
constraints or relationships which are
just constraints on the values that
those variables can take and we also
want something that will maximize
aesthetic quality and readability and we
can encode that in an objective function
so layout is a constrained optimization
problem so how do we formalize table
layout as a constrained optimization
problem this is very similar to to me
heights formulation before so what we
have is the unknown variables in our
problem that the row Heights and the
column widths and what we want to do is
to minimize the sum of the row Heights
the H is so that we minimize the overall
table height and we do that with respect
to the following constraints we want to
ensure that the table width is less than
some set width so the sum of the column
widths has to be less than that and then
for Excel we have a set of
configurations that that cell can take
different lot numbers of lines of text
and we require that for each cell the
width for that cell so that the width of
the columns that that sells spans has to
be greater than the width of the
configuration that we've chosen and
similarly that the height of the cells
that that cell spans has to be greater
than the configuration height now
looking at table layout as a constrained
optimization problem of course the
advantages that
suggests that you can use all the many
many many different techniques that have
been developed for constrained
optimization so I quickly review MEP
technologies and how are they work in
this case now MIPP relies or mixed
integer programming relies on fast
incremental solvers that have been
developed for solving linear programming
problems so what's a linear programming
problem it's that the constraints are
linear inequality constraints over real
numbers and you have a linear objective
function and a MIT model a mixed integer
programming problem is a linear
programming problem except that some of
the variables are required to take
integer values now how am it problem
solved well one of the most common
techniques is a branch and bound
approach so how this is done is that the
underlying linear solver solves a linear
relaxation of the problem which means
that integer variables are treated as if
they're over the real numbers
everything's assigned a value and then
if this is not a solution to the
original problem because some of the
integer variables have been assigned non
integral values then the problem is
split on that variable so it's
constrained to take it the floor or the
ceiling greater than the ceiling or
smaller than the floor of that value and
it splits two problems and then these
are solve recursively now if Lin if the
linear relaxation is very close to the
original problem then MIPP techniques
are very fast however they do require
complex implementations for very good
performance so in practice you have to
use an off-the-shelf solver like cplex
and also the constraints need to be
linearized now in table layout the
difficulty most of the constraints are
linear the difficulty is that the
requirement that for each cell the
configuration you choose one of the
configurations for that cell so this
has the standard 01 encoding where you
introduce a boolean variable for each
possible configuration for that cell and
then you require that boolean variable
or 20 one variable you require that only
one of those is set to one and all of
the others are set to zero now the
problem with this constraint is yes it
certainly captures the requirement that
you choose a configuration for itself
but it's not a very linear constraint
so we looked at some other methods apart
from the technique the first of these
was an a-star approach and the reason
for looking at a star is it is certainly
one of the most widely used complete
search methods for solving combinatorial
optimization problems and it's also a
relatively simple technique so how we
encoded table layout using a star is
that we had partial layouts and a
partial layout was an assignment over
width for the first I columns and then
you perform a priority based search
through the partial layout so each
partial layout has a penalty p which is
a lower bound on the final table height
height and so you keep expanding the the
partial layouts choosing the one with
the lowest lower bound on the final
table higher until you reach a layout
where you've actually found a value for
all of the columns and then you know
because it's a lower bound that you've
actually found the optimal layout and
you don't have to expand and look at any
other possibilities so how do we expand
a partial layup well we fix the width of
the column we have to fix the width of
the next unfixed column using one of the
useful cell configuration with now the
where a star approaches are all the
trickiness realizing them is essentially
how do you find a lower bound on the
penalty function so what we did was
fairly simplistic idea we you computed a
lower bound on each row height in the
cell and for the columns which we've
assigned a width well of course the
lower bound on the cell height is just
given by the cell contents and the
configuration in that cell for the
remaining cell sorry for the remaining
columns where we don't yet have a width
well we just give treat that as a single
column which is a width that unknown
part of the table to the desired table
width and then we take all
content compute the area of that and lay
that out in that single column
we also looked at another approach which
is can constraint programming constraint
programming is increasingly used to
solve difficult combinatorial
optimization problems and it's it's
basically an extension of backtracking
search so the idea is that you do a but
in table layout you do a backtracking
search through the column widths but
what makes constraint programming
effective is the backtracking search is
combined with fast finite domain
propagation so this is used to prune the
widths that cannot satisfy the
constraints how many people are familiar
with constraint programming okay 6.the
if we look at the simple example here
what we have is a constraint X less than
Y strictly less than Y and we have our
domains for x and y that they must take
the values 1 2 or 3 now domain
propagation what that will do based on
that X less than Y will realize that we
can reduce the domain of x to just one
and two because there's no way that the
value three can never be satisfied that
constraint given the values in the
domain of Y and similarly the value Y
can be taken out or pruned from the
domain for y so what happens is that we
combine this pruning domain propagation
with the backtracking search as we're
going through the trees now the big
advantage of constraint programming
compared with mep is that can handle non
linear constraints they can be directly
modeled using propagation and that means
that we can include in directly encode
the configuration constraint as an array
access or as an element constraint
however the disadvantage of constraint
programming is that again like method
requires complex implementation for good
performance and it doesn't have a good
way to direct itself towards the global
solution the globe
minimisation doesn't use relaxation to
do this instead it uses a
branch-and-bound approach so it finds a
layout for the table and then tries
iteratively to find a layout that
reduces the height of that layout and
does that until it can't do any better
another problem with constraint
programming is it tends to do the same
work over and over again it tends to
revisit similar problems but it doesn't
really learn from its mistakes so modern
SAT solving techniques that's that is
techniques that have been developed for
solving boolean satisfiability problems
a very good at learning from their
mistakes and they do that using a track
of no-goods that's assignment 2
variables which lead to failure so
recently a CP SAT hybrid approach has
been suggested and the idea here is that
you learn no-goods when you're doing the
CP search and what that does is
basically keep track of in our context
assignments or column widths which will
lead to a layout which is too high so
let's step back a little bit we've
looked at four different ways of solving
the constrained optimization problem for
table layout the first of these is MEP
and the advantage of that is that it has
a global way linear relaxation provides
a global way of finding that the minimal
height solution we've also looked at a
star its relative advantage is that it
doesn't require you to use sophisticated
constraint solving technologies CP its
advantages that you don't require or you
can directly handle non linear
constraints the configuration constraint
and we've also looked at CP with
learning which has the advantages of CP
but also can learn no-goods so the
obvious question is which is better so
we we perform two evaluations the first
one we collected fifty thousand non
nested HTML tables from the web and laid
those out for three fairly reasonable
viewport widths then we took our a star
algorithm and Joseph the hardest roughly
2,000 tables from that and viewpoint
viewport configurations we separated
those into columns with spanning cells
so with either column and row row spans
which we call the compound cell compound
tables and all the ones that had no span
spanning cells which are the simple
tables we use state-of-the-art nip and
CP solvers a star was at a bit of a
disadvantage we implemented in an a
high-level declarative language which
made implementation simple but probably
slowed it down a little so what did we
find
these are shorter versions of the tables
that appear in the paper but basically
what we do is for a particular time we
give the number of instances of the
tables that could be solved by each
technique in that time so if we look at
CP then in one hundredth of a second we
could solve 1018 instances of the simple
table problems if we look at CP with
learning we solved 1097 in under in
under one hundredth of a second and we
actually managed to solve all instances
of the problem twelve hundred and
seventy one of those in under a second
and similarly for the compound cells so
I think what's surprising about this is
that all methods were very good actually
remember these were the hard problems we
we already took 50,000 tables and found
the hard problems out of those and then
pretty much all of these instances could
be solved by all the techniques in let
in less than 10 seconds and most in less
than one hundredth of a second CP
without learning was probably the worst
method and we were really really
surprised by how well I started given
the simple implementation it was pretty
competitive with the others in fact
sometimes perform better as a second
evaluation we sort of stress tested the
methods in a way similar to how Mihai
described so we created bigger and
bigger tables and these would quite
large artificial tables and here are
look in the paper for more details but
what we found was that CP with learning
was actually clearly the best method for
these artificial tables CP without
learning was clearly the worst method
and meppen a star was somewhere in the
middle
so what's the conclusion firstly we've
looked at a variety of provably optimal
methods for table layout so previously
people have looked at MIT well we've
extended that by looking at a star CP
with them without learning and we found
that they're they're surprisingly
effective for real world tablelayout you
could actually use them in practice CP
with learning at least with our
experiments came out as the most robust
and scalable method however you need to
have some skepticism about that result
firstly we didn't considered nested
table layout all of the methods could be
extended in a way to handle the case
that mihai talked about where you
flatten the table but more complex
nested table layout it's more difficult
to see how to do that the results of
course depend on the choice of the
evaluation corpus and finally this is
probably the most important point the
comparisons depend crucially on the
model of the problem that you're using
with MIT and with CP and the choice of
heuristic that you're using with the a
star so you know an obvious question now
is that we've seen me High's new mitt
models is to go back and compare them
with these and find out how that
happened how will I go thank
Nathan nice
it's a very simple question I was just
wondering if there's any correlation
between the well performing examples in
each of the different methods so did the
the easy the fast a star solutions were
they generally also the fast CP
solutions no I there wasn't so I guess
we got rid of all the simple ones where
everything performed well so we did go
back and check them on that but now it
wasn't necessarily true that this
particular table was hard for all of the
methods I'm sure there was some
correlation but it wasn't obvious
over the vast you disapprove it for
anyway because I'm interested in this
topic why do you think the a-plus has
actually behaved so well I actually
think the table is pretty in reality
it's simpler than we think it is an
np-hard problem but in reality you can
find a fairly good solution fairly
quickly and that allows you to prune
those things away have you found cases
can wear the tools just did not find the
solution ah yes yes if they attack on
forever and yes none of them found it
that's right so if I understood the
research goal correctly you were trying
to find truly optimal solutions to at
least initially to act as benchmarks yes
and but and as you said in some cases
you couldn't or at least not in a
reasonable amount of time but is there
some kind of a lesson for kind of
practical the practical problems or for
you know for real table layout engines
for browser development re do you know
someplace you can take this that goes
beyond the the creation of benchmarks to
improve table layout algorithms that are
that are close to optimal and yet you
can tell people we guarantee it'll we
can almost guarantee it'll finish or we
know that if you terminate you'll be
close to optimal something like that so
given how fast these algorithms are I
think you could probably use pretty much
all of them in a document formatting
tool but maybe have some time out if it
hasn't all fine you know after a period
of time just return the best solution
that you've found so far so it's not
necessarily going to be optimal but it
will almost certainly be better than are
the solutions that have found with
existing
techniques whether or not that works in
a browser it would depend how much power
you've got sure in your present but it
might make a nice paper if you if you
showed that that the results when you
terminate it that way where yeah we're
good we're still good that's right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>