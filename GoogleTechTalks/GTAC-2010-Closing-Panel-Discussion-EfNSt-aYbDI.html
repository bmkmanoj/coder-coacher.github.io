<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2010: Closing Panel Discussion | Coder Coacher - Coaching Coders</title><meta content="GTAC 2010: Closing Panel Discussion - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2010: Closing Panel Discussion</b></h2><h5 class="post__date">2010-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EfNSt-aYbDI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the first session we're going to talk
about test automation and the whole
developer automation group and we
thought we were invite a group that has
been very active in this so Simon Brad
Ashish and Vivek I think everybody might
know people except Ashish and now she's
is that engineering manager for the
engineering tools at Google and he runs
the entire organization that builds the
tools and infrastructure for all our
developer productivity and the tooling
aspect so I invite them to come upstairs
and get seated and comfortable I think
we have mics for you yeah thanks great
so the route the rules are pretty simple
I picked up two topics that were placed
on the lunch tables and they are
relevant and related to test automation
so the first one was best practices for
front and automation and the second was
extreme ID features and perhaps you can
weave that into your discussion your
thoughts and then I invite people who
were held at these tables or the people
who actually were interested in these
topics to chime in yeah I'll kick it off
since you didn't invite me to speak at
this engagement ah for those of you who
caught my pre gtech talked we talked
about this framework we're developing
called angular and I guess my question
is you know not just to sell my own
software but I when we talk about
testability we talk about pushing tests
further upstream into the development
process I think whether this is for
making our front ends more testable or
actually making the code itself better
test than a unit level you know I'd love
us to think more about how can we make
it easier to do the right thing and an
angular what we've tried to do is make
the structure of the application the
application framework itself make it
easier to build unit testable software
and to kind of distill a lot of the
things that rest on Tracy talked about
into best practices that that just flow
naturally because it's it's much easier
to say implement MVC
because we provide data binding we
provide dependency injection in the
software itself I think these I mean I
think these things could translate into
your you know the second topic into the
ID is like what else could we distill
into the Ides that could be my super
suit for a developer that now gives me
the heads-up display as I'm writing code
ah like maybe I can tell me that you've
picked a design pattern that usually
doesn't help you that actually caused
you to shoot yourself in the foot
someone else heavens so I guess you
missed my presentation yesterday oh yeah
so I mean there's there's lots of things
we can do to improve front end testing
one of them is like you say not to
encourage people to write front end
tests but to push it further deeper down
into the stack and help grow trees as
James tells us that we ought to be doing
and then we ought to have testers de
running it no hang on that's not right
is it so I think one of the interesting
things here is is there needs to be more
support from the ides and from the
tooling to let people know that what
they're doing is a really bad idea like
you know if someone sees at the
beginning of a locator double slash then
that's an indicator that are about to
use xpath and they really ought to not
be allowed to check in at all and forced
to find a better alternative because
they're about to make their tests
terrifically hard to maintain and
thoroughly unpleasant you know things
like that yes identifying patterns one
of the worries that I have though is it
keep on giving people good things and
they don't understand why they should be
doing it and so they try and
re-implement bad habits with the new
technology like you give people even
with the most strong guidance
particularly in Google where we've got
incredibly smart problem solvers they
view those those constraints that we put
around them as problems to be solved and
they solve those problems and then we
pick up the pieces of the codebase
afterward you know so i think yes like
more hints about what you're doing is a
bad idea from the ID and flagging things
up
red underlining and not allowing you to
check in but also sort of explaining and
educating why that's a really bad idea
like exceptions when they're being
thrown should sort of try and link to
some form meaningful form of
documentation so a motivated individual
could sit there and go yeah that's why
it's a bad idea I'm not sure whether
this sort of rushed towards dsl's is is
desperately useful though like I don't
know about you but I've never seen
anyone other than a developer reading
developers test cases so sort of
wrapping that up and making it look like
English seems like a bit of an overkill
to me making it readable that's okay but
I can read code and as long as people
use camel casing or or snake case
appropriately I mean it's all good the
vet yeah so I'm not going to respond
with that okay we'll talk a little bit
okay I wanted to talk about something
else and that's really what balance I
think I think one of the things that
I've seen is that there seems to be a
lot of polarization people say do a lot
more unit testing and we'll do a lot
more integration testing and do a little
bit less of that or do only automation
and do as little manual testing as you
can or do only manual testing and do as
little automation as you can I think I
think one of the things that we have to
be all aware of is that we need to have
a sense of balance it's it's not as each
one of these things is not useful it's
it's very important for us to look at it
almost like an onion skin so unit is so
important because they help you test
your classes and help you drive out the
quality of of individual building blocks
a smoke test so important because they
give you a quick way of figuring out
whether your overall system is fine
end-to-end tests are also useful because
they help you figure out whether the
final system in production works or not
I think it's very important to get a
sense of all these different ways in
which you can you can actually dissect
and build in the quality of your of your
software I think that sense of balance
is really important so I actually agree
with what we have a except some time
back somebody on my team at the last
company had written a paper called
portfolio theory of testing and the idea
is to find
right balance of tests I think each type
of test serves a real purpose in terms
of discovering a set of bugs that you
would not otherwise discover or even if
you did you would be working extremely
hard with one type of test to discover
all sorts of bugs something finding that
right balance is important I think
another part I wanted to say you know I
think the work that you guys described
in terms of page objects I think that's
actually very critical but I also feel
we could go a bit further on the front
end testing aspects of it the page
object pieces define the functionality
that a page is offering I actually feel
that each each page that you're that
you're laying out regardless of what
language that you laying it out out in
should have a set of widgets or a set of
components right that you can that you
can operate like so as opposed to as
opposed to having an XPath which is sort
of the absolute detail of the of the
abstraction you go one up and then you
have let's say widgets that define file
menu or something this is sort of one of
the reasons why we were talking about
accessibility IP is like a blind user
doesn't have that ability to introspect
into the page but they need to know what
services offers like I think those API
is that we're developing for allowing
people to do accessibility testing will
also be hooked into that's exactly right
so having just like you know the fact
that there is a menu or the fact that
there's a dialog is is something that's
a common sort of user interface element
and and then a dialogue or a menu
provides a set of services that you can
then write tests against regardless of
how it gets laid out whether it's a
whether it's a horizontal or vertical
menu whether it's a menu laid down as
with a drop-down and so on and I think
at that point test can be more resilient
and more useful more global as well you
know if anyone wants to come up and
rescue us so why do we have your
attention actually you want to speak
anything about the Ides or the maybe the
vision or what IDs in the cloud might
look like and what we think would be the
future actually I happen to be sitting
at that table with Jurgen Anna and a few
others so at least one of the things
that we we have been talking about at
Google at least I've been talking to the
team about is you know if you look at so
the primary users of ids are divided
right there writing their writing a lot
of code using those IDs what I'd really
like to see IDs get to is to the point
where there is essentially just a plain
old editor right you have an editor you
know if you guys have done development
on the Mac let's say for you know Ruby
or PHP or one like most people prefer
using textmate and then they'll you know
and essentially it simply gives them a
very simple file explorer interface and
that's it right you you know these
languages are interpreted so you can
basically just run them straight off
when you're dealing with languages like
C++ and Java whether it's compile and
pests and you know all of those steps
involved you know people prefer more IDs
that is an you know more traditional
form I'd really like to see where we can
get it to the point where there's a
simple editor like a text mate right
that's available that you can just type
in your code and and as you're doing
this you start to see signals that
indicate hey you're about to enter you
know you you you just entered a pattern
that has been known to be a bug because
we've discovered it in the rest of the
code base or generally people guard for
null after this call or or hears that
you know you've basically added code
that currently doesn't have test
coverage and weak and you can do all of
that because this editor is basically
just a dumb bareacres it's simply a
syntax highlighter and what it does is
it connects to services that are running
somewhere in the cloud with hundreds of
machines operating at the same time on
behalf of the developer so that they can
provide these results as quick as maybe
five seconds right so before you can
even switch context you've got the data
in terms of like you know of what you
could do different at this point and
once that dumb better exists as a as a
as a desktop application you can take
that dumb better and put it into a web
browser now you've got the ability to
you know be sitting in this conference
and finishing up the code that you
started two days ago while you were at
your work and just continue on from
there so that's interesting because so
the reason why I use an ID is and why I
really want one for Ruby or Python is
because of like the ability it's go it's
got allow me to think of the code in its
logical form rather than just the plain
text like I want the exact opposite of a
dumb editor I want like the soup
smart thing that allows me to throw
around the concepts and the ideas that
are sitting in my head like I've got to
go through this translation phase where
I've got to somehow convert this sort of
the objects and the views and the the
ideas that I've got into a ski or if I'm
lucky utf-8 and like that's kind of
that's that that that's a painful thing
to do like I'd love it if as i was
typing my code it went by the way you've
just duplicated something your variable
names are slightly different and your
spacing sifrin but your logical
structure is identical to this class
have you thought about refactoring this
and extracting this and doing alert on
the other hand having having a grid of
computers quietly running away in the
background and doing all sorts of lovely
things and compiling my code now that
sounds like fun particularly when I do
the RM minus RF star and and save that
as a shell script and just see what
happens so I think I think one of the
core reasons why people move to the IDE
world especially with languages like
Java was the refactoring support you're
absolutely right i think there's you
know the refactoring capabilities on
java are actually much better defined
then let's say a c++ and and therefore
it was a lot easier like the
functionality that you get on ids right
there however I do believe that it's
time that all of these all of these
operations can actually be just services
that operate over an RPC and now a VI or
an emacs or or eclipse or IntelliJ or a
web ID should be able to provide those
completely seamlessly what would happen
to all the religious woods so I'm just
going to take a quick opportunity to sit
near Ashish since he has a lot of
influence and what kind of tools
actually get built at Google and say
well Ashish is supporting something that
sounds more like a flat editor I really
don't want to give up the extra windows
and views that I have available in a
tool like eclipse so in addition to just
refactoring we have things like
excellent navigation
we can pull up a view that shows the
one-off code wherever the cursor is if
if we've got a cursor sitting on the
literal of a method name then we can
have a view next to it that shows the
actual code in the context displaying
that entire method maybe in another
class but what I do agree with is we can
get the work moved out of the machine
that we're working on out into the cloud
and we can provide a lot more services
that way is it's fair to say that you
could expect a lot more feedback to
happen based on the work that's going on
in the cloud so that there could be
client-based parsing that's going on and
rich editing that you can get from your
client perspective but the feedback from
the cloud because multiple developers
might be working on the code base at the
same year in point in time and the
ability to learn the cloud from for the
potential mistake that you could be
making is you're developing the code
absolutely and and anyone who's used
google has a few tools out there for
collaborative editing of spreadsheets of
documents I would love to be working in
that way on code as well right now we do
pair programming with two people sitting
at a screen and two keyboards but that
really isn't feasible in some situations
if I'm trying to work on a piece of code
from Mountain View and I am working with
a developer in Hyderabad it's not as
easy as it should be so a shisha if you
can help us with that and and let us
edit code across the cloud as well we're
waiting for that ID but this is more
than Google I think
as it turns out we have one of them as
it turns out we have one of those in
fact you can download it it's not
complete but it's a prototype for me if
you go to go / inch tools labs you'll be
able to use it but really I think I
think the work that so at the table it
turns out that Jurgen and Robert Robert
actually suggested this same exact idea
and and and the goal there was to do you
know at least our goal originally had
been we want to get talk video
integration into the IDE so that you
know you could very quickly say from an
editor you know I want to do a code
review or I want to get some help it
shows you right there you know hey
here's the here's the people that edited
the school most recently here's what you
know and and this is the person that's
available now with presents indicated
and then you can just start a session it
shows up the screen on their terminal
either on a web browser and an IDE and
you start collaborating on it on a
really experiment the one that I'm
describing unfortunately it did not get
enough usage from developers so we
actually put it on hold waiting to
complete but you know I you know I think
uragan was extremely interested in this
so we might actually we restart this
sheesh i agree with ashish in most of
the cases just one question is how
opened with the developers or the
companies who are owning the
intellectual right be open to share the
code over the cloud on a different
uh-huh announcer on totally a public
platform that is one question which i
think so that is one of the main reasons
why we as a company in it so we could
not move to cloud most of the covert of
work we do is intellectual copyright of
our clients so and the client mostly is
not so happy to move everything on cloud
so i think you're right i think that
will definitely be an issue but there
are many companies that could benefit
from this i think the cost of building
this infrastructure maintaining it is so
high that if there was such a service
available i believe lots of lots of
people would benefit from it so so i do
believe that we probably see more
say browser-based editors and all that
but I'd like to come back to the
original topic which was really about
extreme IDs and all of that i think i
think is worth asking why do we use IDs
in the first place the way I look at it
is that all of us developers it's hard
for us to keep an entire code base in
our heads yes we will know its contours
will know the basic structure of what it
looks like but it's probably humanly
impossible for us to know every single
line of code that exists in our code
base and I think I think I really view
an ID as something that helps you
navigate your way around a code base now
the way in which it could do that could
be it could be through various things
being able to quickly find out usages of
a given class so that you know what
impact what impact a change in one
particular place is going to happen will
have on other places and so on and so
forth but I think a big angle to why we
use IDs in the first place is really
about productivity it's about figuring
out ways of of knowing what the
structure of your code bases knowing
what you can change safely and what you
can't simply understanding it better
that's one thing that I ever I feel one
more point to add is not only the
structure but also what I want ID is a
place where I get all my tools in a
single place like for example we are
working on plugins on IDs which
automatically ate the JUnit test cases
automatically the j / test cases execute
them in case i wanted from the ID so
it's kind of a single window where I am
sitting in that window I don't have to
alt-tab or to go anywhere I cannot only
open source code but change it and also
make meaningful next steps on the same
so that I feel is the more important
part so the simple folder structure note
that I don't think that we work so we
watchin from the floor here should we
move to a different question so I have a
question most most of the talks we seems
today we've kind of chem done yesterday
as well we've come to sort of agreement
the testability is I mean there has to
be built into the app our lower level
yeah if we look around the room i would
say 99 percent if not more of us I will
are working in test as s ETS or as
testers what can we do to actually take
this testability message to the people
that need to hear it
which is the people that were writing
the code we don't do it I mean 12 and
what happens is a month or a quarter
goes by things go worse you let them go
was still don't do it and at some point
they get horrible to a point that the
product is not shippable and then people
get the point and then then and the true
true I think the right model is a
collaborative model i I don't I think
either extreme as bad but I think the
person writing a particular shrimp head
of code should also be writing the unit
tests and the functional tests for the
shrimp out of code because if he or she
will go ahead and update it they will
update the test and it also helps that
if it's in the same language so I know
yep so one thing I wanted to say is
about say things like JavaScript
frameworks i think i think i remember in
the early days of selenium it was
relatively easier to write selenium
tests they are not that many JavaScript
frameworks out there it is fairly easy
almost full control over the entire
application beginning a lot of harder
after that when there was this explosion
of JavaScript framework that came out
each with their own widget libraries and
so on and so forth I think something
that's really important to almost asked
for or demand from from tools open
source tools and frameworks and all of
that that we use is to is to ask for
testability to be baked in like in the
case of the google web toolkit it's
something that came much later we all
knew that when when we wrote
applications using GWT we wanted to test
them but it's only later that once there
was more demand for it that that that
started that stuff started coming in so
i think i think something that's really
important is for testability to be baked
in into the foundation of some of the
things that we that we use now obviously
this is not something that's easy it's
not always a focus it's just something
that if you feel strongly about you can
always want to go to I might actually
challenge the validity of your question
I actually think there are
water developers who are leading this
charge in tests and testability I mean
Russ and Tracy we shanghaied them into
the testing or that's this isn't there
their main thing but like they're so
good at it how could we not get them
into our org ah you know I'm like I
manage developers who care really deeply
about about test and testability but i
think it's like jeff said this morning
this isn't part of the culture where we
teach it from the beginning this is
something that's happening slowly if we
can get it into the university programs
that would be fantastic Jeff I think
Google would love to work with you on
making that happen but I you know this
is this is the way this is the way
social change happens the developers may
not be here because there's a test
conference and they're like you know
test is part of my job but it's not my
old job so it was a couple of us here it
were kind of a self-selecting crowd hey
maybe I sorry but I do want to talk
about a little bit about the disability
Explorer that I sure so there was a we
had a some people we've discussed you
know is it possible to measure the
testability of code and we took this
concept may be as far as we knew how to
take it at the time where we we try to
come up with a metric that would tell
you how how units and module testable is
your code and what we were looking for
is how much of my the dependencies of my
objects weren't mockable um and and you
know how much work essentially what i
have to do to make my code unit testable
or or how small could i make my unit
test so i can make them run fast and be
easy to change and all the good stuff
and there's a project you can go go look
up called the testability Explorer where
you can run it over a java code base
it'll come up with a metric and it'll
show you which lines of code which
classes are less testable and we think
it's actually pretty good at pointing
out problems where if you wanted to
focus on refactoring and making or your
code base more testable it would we
weren't very good at coming up with the
metric because assigning the cost turns
out that's that's the tricky bit so you
know we did we tried to put this into
continuous builds and you know how
people drive their testability costs 20
oh I think part of it is you know what's
what's the value and actually driving
your testability costs 20 might be a
better tool if I started from scratch
but but go check it out testability
Explorer one thing I would like to add
is a lot of times people forget that
like this whole interaction between
testers and developers is actually a
people problem to a lot of times people
think that like the testers if you if
the need IDs then they can ask the
developer and then they'll put it in but
it is not actually like always feasible
and it's actually a redundant thing
there are there are like tools out there
which do not need these things to be
added to the application itself so one
of the things that like people kind of
seem to focus here is that like the
testability has to be added to the
application only it can also be the
tools are not smart enough to actually
adopt to the applications see look at it
this way if if a tester has to act has
to go back to the developer to get
something done there is going to be a
barrier there is going to be a time lag
between like which happens between these
two events and most of the time it is
because of the limitation of the tool
which is testing it that this happens
there are tools out there which do not
need like these are inclusive IDs like
where they are not required to be added
and using them may actually like may
solve you like eighty percent of the
problem there may be places where in
where you may need to but from my
experience you don't like there have
been applications which the testers
cannot control and they can be
absolutely tested without adding
anything more to it so the testability
things like be a little cautious about
like oh how much you are demanding out
of the application really maybe are
making a mistake in the choice of the
tool really I wanted to pick up the
topic of how to push testing and testing
culture into the developer developers
realm and what we are doing and whether
we're doing something and I want to yeah
like give give some kudos to the to the
developers because in my experience
there are quite a few or quite a lot of
them who are some of them even much more
than I am as a s80 into testing and to
whom I go for testability or refactoring
or design questions and
it's if you want to increase their their
culture and your team go to those people
picking up Russell Tracy's pick your
pick your allies go to those people in
your team empower them or just ask them
for help and this is with a little bit
of luck this is going to become viral
and at least I just have a an experience
but pretty much turned around the
culture of a whole team so I think
neuron made it a very good point but
accidentally and that that is that sort
of he said oh well you know you've got
to go back to the development team if
you if you discover a problem in test
you know what the hell no no you turn to
the developer next to you and you say
I'm sorry would you mind just adding
that right now we need it and the
developer goes of course I'll do that
right now like this the separation of
like church and state you know
development and test is is completely
bogus and like the sooner we break down
that barrier the easier it'll be and
you're right like the tools can't get
smarter and they will get smarter but
sort of the way we write software needs
to get heck of a lot smarter first and
you know this this sort of concept of
like all there okay its a mix of
abilities and capabilities like I
wouldn't ever try and write a user
interface because I'm terrible at
writing user interfaces but if I had to
wire one up I would sit next to someone
and I'd say you know what's that mentor
do you know what would you expect to
happen with that and the same thing with
with the testability of guide like
person who's expert at writing and using
api's should be paired with someone
who's an expert at understanding sort of
where bugs and problems occur in the
later stages
in the later stages you mean to say that
there are no bugs that would be found
when there is no developer around so do
you mean that like whenever there is a
bug it'll always be found when the
developer is wrong and I actually came
up here to talk about something else
Simon keeps keeps putting interesting
stuff into my way so and that separation
of church and state we should separate
church and state but we should not
separate testers and developers we
should bring them before this gets to
political engineer let's let's bring
them together actually they having the
testers separate these we have these
discussions in the corridors the past
two days where the existence of a QA
Department that lives in a bubble
somewhere and just gets a bundle of
binaries and says oh well test this that
is a very bad idea and actually I think
if that lightning talk like between the
DeLorean of the present and the DeLorean
of the future that's where we are at the
moment it is we'll be bringing them
actually closer together and we're
actually dissolving QA departments
bringing the tester in the team and job
like the the roles of an S et in Google
or in the team's I work with you get
somebody who's either a developer with
testing sensitivities or a tester who
actually slides into being a very good
developer who functions as a bridge
between the two they're bridging the two
worlds somebody who knows what in
watching the what's in the black box can
do white box understanding and can then
go back and talk to somebody who's
outside and actually wants to break the
things doesn't want to know how it works
wants to break it and these are the
people that seems has a problem with
losing it is really with it if they keep
the balance as they balance on that
under in the middle they can do the best
they're the best work for both teams but
sometimes people either slide one side
of the slide
the other side that's the problem what
so I have a question on the subject so I
think the whole thing about separating
testing and development or keeping them
as separate organizations one of the
things I feel that really drives
developers to not probably prioritize
testing is probably the the sort they
have hanging on their head about
releasing features and product feature
velocity and product velocity and that's
really a product thing so in fact I
think one of the luxuries we have about
being a separate organization is we can
step back and say that forget it like
like uncle's extreme measure of let it
go down let it go down till it really
gets bad and then you start prioritizing
it we can afford to do it because you're
a separate organization which is
completely focused and has a freedom to
prioritize this so so what do you guys
think about that ok I'm going to leap in
here because this is one of the things
that gets me hot under the collar and
deeply deeply annoyed so there's this
assumption that sort of just banging out
code is fine like i can write code
really quickly if i don't have to prove
it works like you know that that's
that's easy yeah and then i end up with
a code base it's complete garbage like
these the developers do have the sort of
Damocles hanging over them saying
release release release release so what
they need to do is make sure the stuff
they write is actually solid
maintainable and sets them up at the two
to continue delivering software like
it's not a sprint it's a marathon yeah
so you know the developers who sort of
sit there and go I haven't got time to
test I must get this feature out they're
going to hurt themselves in the long run
yeah in the short run it's going to be
okay they're going to be able to go oh
look the feature is there but in six
months time there's going to be
regressions there's going to be problems
they probably haven't written it if
they're if they haven't done it using
TDD is probably going to be harder to
spanner in unit tests later on so you
end up having to like with more and more
of the code in a sort of grotty state
and then you end up in anchored
situation where you go right we're going
to rewrite it and then six months later
if you haven't changed the incentives or
a year later two years later then you
know if you haven't changed incentives
again you end up in exactly same spot so
as release pressure gets greater that's
the point where you ought to start
becoming even more disciplined about
doing test-driven development and really
caring about
putting in that sort of that the things
that we do to shore up the
maintainability and quality of our code
I think it really just boils down to
whether we believe into TDD or not and I
really make it make it a point that I'm
an SE t setting in inch productivity
being an S et driving promoting TDD is
supposed to make engineering more
productive if I believe in that then I
should I should in the long run yeah
well maybe not even that maybe even in
the mid and that's the message we should
we should transfer and first we should
make sure that we really believe in it
and that we don't believe in this
contradiction of feature release versus
testability quality Rattata etc because
if we don't then when the wrong role in
the wrong organization and we should
rather have a conference on graphics or
on skydiving or sailing or something
what one more comment because we won't
like to move on topic there's there's an
extra roll that people in this area I
have it's not just to show how you do
test first how do to motivate the team
to actually test it's actually to also
get the feedback of the test back to the
developers as soon as possible and
building tools like information
radiators and all that infrastructure
that actually shortens that your turn
around cycle that is also very important
and it's probably the one area where we
can do the most good because am an
information radiator also serves as a
very good incentive is like if you have
a buzzing up over your head or a red
flashing screen look you broke my bill
go on go on go on whoever does that we
fix it as soon as possible nobody wants
to see his name on a big 40 inch screen
a pleasure he broke the big fat doesn't
good yes I agree that is what I was
coming to say here like that would be a
PG Tech Talk it had been discussed that
I think so one of the speaker said about
that once a build is broken that message
goes out to everybody saying that this
build has broken on this date after so
and so's chicken it goes to everyone now
once that comes in any organization the
develop would be semi conscious at all
quantity even with this sword hanging on
the release date you ensure that it
doesn't break because of him next person
fine at least not my name highlighted
all across okay I think there are some
questions from the floor about the fact
that you know there's real scenarios
that we need to be testing for or how do
we build the workflow workloads test
data for production scenarios this is
more realistic testing and simulation of
real-world scenarios so i'm not sure who
wrote this but if you want to come up
and share those thoughts or if any of
you have thoughts about that perhaps
Jeff for you know Bob would would have
some insights into this so I first about
the user load workload I think the best
way is to either monitor production
environment for the first initial few
times we at least the initial load
estimate or the second could be with the
PERT manager discussion with the person
was conceptualised was gathered a
business requirement he will able to say
that when he's getting his obviously
basic keeping the base on some factual
data he has done some market research he
knows the exact points which he has
added the certain more additional
features which I would added this of
those will obviously have a lower
priority or a lower workload so these
are two things one in case of fresh
product it should be based on the
pernicious input or whatever research he
has done and in case of existing product
monitoring of production should be done
I think so when tools already available
I would like to point out that we have a
severe lack of leg work here at the
moment and if I understood them their
rules correctly it is not as for who
have to invest initially into leg work
this is getting pretty static and boring
and it worked Oh
Wow good i gotta say these are the wrong
type of chess okay we can sit here well
the idea is if it's getting boring you
need to change the topic yourself if
nobody's out there so you have control
over what you can say in where the
discussion goes so we go in new one yeah
so the challenges to it test data and
yeah production looking at production is
a way of looking at it I think one of
the key way you make just data is not
just by the production right because we
all know the code structure gives a lot
of errors and probably your test data
should be more closer to also find to
the structure and for go find out like
you know all different paths looking at
different ways of like you know finding
the problems because probably there
could be some areas i'm sure we have
been always working with the enterprise
application we've been always saying
some of these code being very stable
working fine suddenly you see like no
one new feature someone is trying to
start using it it starts breaking till
such time it was working fine it started
breaking the reason being not that like
you know it was it was not used so
that's the reason it was it was not
tested so a test data should ensure all
structures are covered not just from the
user perspective if you just monitor the
user perspective you would see keep
testing the areas where people would use
which is very important no doubt about
it but when you talk on a bigger picture
in terms of looking at what next or how
people are going to use some of this
next code and probably you need to
consider the other aspects of aligning
to the structure of the code yeah
absolutely agree with you because most
of the mathematical statistical base
model also tries to find out the code
base based on code base what are the
data to be added for covering those
spare spaces accepted and for the
Russian data of which was talking about
this recently saw something on desert a
management from HP quality center which
was
quite good like they should take a dump
from the production which is a called
gold instead of data and then keep it in
till the time the next release so that
was also a very good concept yeah
fortunately production data is not
always a solution there's all kinds of
legal problems to burst your bubble in
that case the thing this discussion is
pretty user centric and actually with
usually mean real people using the
system my experience
think of verbosity levels and most of
the times we stop there my question is
shouldn't we move to contextual
reporting to make it more testable to
the black box tester there's an external
means application is still a black box
he somehow controls the way what is
locked not in just terms of the length
at which logging is done but what is
being logged for example if I want
performance statistics for a certain
scenario only that gets lon if I want
that I need to know the APA logging what
were the AP calls made only those should
be logged so that is one contextual
reporting for testability open for you
my second question is that we talked of
going beyond the GUI now all these
discussions tend to be more focused
towards web where it's already a script
most of the times but what about
compiled languages what about languages
like Java so can they be a discussion in
this forum about providing scripted
interfaces on top of such languages
which are very very much there I just
want to understand how far they are
being used because most of the testers
are conversing with scripted languages
high level languages rather than Java
and C C++ so how do we increase
testability of such applications in
these two things contextual reporting
second scripted interfaces to Java C C++
or dominant thank you on the select
first the initial point that application
or a thing which has made well why
developers but cannot be tested well by
the tester now a tester is a actually
are just representation of our end user
so we possibly cannot say that there's a
qualification mark for my end user he
could be a novice he could be just be a
total it as well so I feel that that
that tester qualification does not
matter here contextual yes obviously the
more contextual the reporting is being
done it helps but again the developer
also has to ensure that a certain bit of
a sequined of model relaxing or keeping
the things together
proper housekeeping activity done those
are also required at the developer end
because without that it's difficult even
for the test of it even the most best of
knowledge in case the context for even
for the context also supposing a very
very similar simple example if i put say
the login page in a module which is
supposed to be the mayor taking care of
finance part of it even the you that
context everything will go off the hook
i have to intern maintain that login
page stays in the login module or in the
home section or in the root directory
that is my responsibility as a developer
which i should ensure the basic
housekeeping yes i agree advanced things
can be pushed on to that may be testing
site but at least a basic developer
functions has to be there so i have 1
comment on the first part which is
contextual rocking right I think in
google i work on gmail i work on the
same team as on kid did so what i wanted
to mention here is like contextual
logging is really useful like even I
work on performance testing of gmail so
when there's that you know debug
information available that that
information log then you can actually
not only identify that which are the
pieces that are getting called for a
particular action but you can also
identify in case of issues that which is
the piece which is actually causing the
regression which is causing the problem
and then think about when you have
gathered this data over let's say even
over a period of four five months you
start understanding you know which is
the piece of software which is actually
most you know mostly having the problems
James in his discussion said that you
know where one bug exists there's a
tendency that there are more bugs there
right that's so it's really interesting
that when you start identifying those
red pieces of your code then you can
actually go much deeper into it and
improve the product quality to a great
level right and I think we have been
talking a lot about regression testing
etc but it applies to pretty much all
with the fields that we have in testing
whether it's performance testing load
testing regression testing usability
testing
it said I think second part of what what
was talked about is you know scripting
testers having that scripting language
how do we bring it to Java and C and I
think I was going through some of the
feeds I think first behavioral change
that we need to bring is that tester is
not supposed to be just a scripted
tester is supposed to be a software
engineer who can handle complex
situations still we are trying to solve
this problem by just thinking that oh
you know what if somebody no scripting
that person can do testing for me that's
not going to work out I think it has to
it has to we have to accept it as a
complex engineering problem and then try
to solve it that way right so we have to
make sure that the skill set is there to
to get that going I want to see the
thought as well and this is in the
interest of G tag right I'm really
curious about what's going to be the
biggest problem in two years down the
line you know what does this group think
that maybe should be the theme of next G
tag what is going to be interesting the
most interesting topic that we are going
to have to deal with is it going to be
testability again it is going to be how
to make religious faster or is it going
to be something else so I'm really
curious about what others think about it
ok one additional point to most of the
thought process if you see predominantly
we are talking about roles
responsibilities what this person is
supposed to do what is not supposed to
do I think we need to shy away from some
of these problems right because one of
the big challenges towards like how we
measure people I think that's one of the
nice thing we've been hearing also where
you say I we have already come with a
preset mind that like not this guy
supposed to these four things you go and
talk to people what is the productivity
of person number of kilo lines of code
he can write then you talk about are
like know the velocity the function
pointer the time we talk more about like
you know the quality of code say for
example James when you are saying they
are writing little slow but they are
doing a better quality code right again
we have been talking about the
read in which someone can even write
code and think that has gone so much
into our mind in terms of looking at
like you know this curve our ability and
the way we measure people that has to
change first in order to like you know
change the whole paradigm of improving
the testability are like you know
another thing is towards like you know
we need to reduce that thin line between
the development and testing in terms of
what you are measured upon that's very
very important because otherwise like as
some as in the conference also someone
was rightly saying if I am going to be
measured up on the number of defects I
would raise thousand defects which may
not be useful to the product at all yep
right that's not going to be helpful at
all so just a time check we just over
six o'clock and i think the enough
discussion going on whatever we like to
continue for another ten ten minutes or
so that'd be okay so let's continue for
another 10 minutes if you have enough
topics yeah so I sorry should I go away
just a quick point based on my limited
experience so i think when i think of
testability obscurity for me is one
thing that really hampers testability
it's not just scripting languages or
being able to test in things in one way
being able to have a strategy for
testing which depends on how the design
of the system how less obscurities that
just gives you more options that just
helps you text at different levels and
not just complicate the testing from one
point so obscurity of obscurity of the
design is is really one issue and I
think to some to some extent like what
James says right you want to expose data
out there the the expose the daily wanna
expose is probably in terms of the
actual information about the system or
even in terms of the are the
architecture and two I guess the point
that ratchet is trying to see it on what
problems or what discussions we won't
have going forward into in this arena I
think again the more and more we're kind
of enabling users to do stuff and
empowering users to do stuff via a very
platform centric approach to things
whether it's in the consumer world or
whether it's in the enterprise work
we're trying to build platforms you're
trying to build api's we're inviting a
lot of integration points we're inviting
people to come and do things and to
connect to existing stuff so I think the
whole integration testing here and not
obscuring how we do things so that
people can freely integrate and build on
a platform and testing in that space
might be an interesting area for us to
think about yeah yeah i think i was
gonna say pretty much that the on the
future of testability i think the
testability is sort of rising in levels
like testability used to be a problem
sort of like the source of testability
that Russell Tracy introduced where they
were talking about light on a class
level TDD is starting to become a lot
more widespread for most people we're
now seeing testability at this level you
had the sort of unit level people have
testability but the problems of
testability are sort of rising up to a
more system level it's amazing how many
people have really testable units and
yet you have a system where you still
can't replace the database with the mock
you can't you haven't got any hooks
where you can put your scripts and these
sorts of things so I think in the future
testability will just be pulling it up a
level and we'll be talking about a more
system design level testability rather
than the low level testability which has
been talked about quite a lot in this
conference you can actually have the
other without be one so I've seen an
application which I think didn't have a
single unit test that was excellently
testable on a on a GUI level on a GUI
system level I have an answer father and
that's an on Google answer for the
logging in context question and the
answer is log4j or in ported to other
languages I've actually used it in the
log for pearl flavor it allows you to
just a few technical details allows you
to structure your loggers in a
hierarchical way configured with a with
a config file and you can tune up and
tuned down very very flexibly you're
logging levels in different parts of the
as per application or in different
aspects it's a pretty old component from
the Jakarta project and sometimes amazed
that it's not more used I think it's one
of the brightest thing since sliced
bread
so I just want to take on her tits a
thought on what's the you know the
future challenges coming up in next year
a couple of years so I have been kind of
shared this with some people across my
conversation that one of the challenges
which I see is uh we have seen a gmail
is like you know it's kind of a defect
to cloud application as you know
impacting people's libor google com but
what's coming up is the enterprise
clouds right so when the queries up
there was a you know why do I have to
use a enterprise cloud if I have
concerns on the security risks of
pushing my code there so i've been
reading reports that you know Microsoft
has been winning deals over up companies
moving their exchange server on the
clouds and these kind of up new business
models will open up new risks and risks
in terms of I think security I think
that's a one of the major risk concerns
or why people or enterprises you know
hesitate to move towards cloud is
primarily based on so if you take
performance and availability aside it's
a security and storage assurance and I
think we and lot of new services need to
be created for example like
recoverability as a service right what
if my extensive goes down this role of
IP in there so I think there's a I think
even the primary from a development
perspective itself like the
architectures are evolving there and I
think from a QE perspective the whole
you know things are things are going to
spring up in terms of assuring the risk
there okay let's take a few more choir
one or two more thoughts and then we
wanna talk about the future no question
I'm sorry wrong questions or thoughts I
think we have a comment so let's talk
about the future what we need to test in
the future along three three things
spring to mind it's actually quite low
level we've got one big position coming
our way IP version 6 there's going to be
a whole help
making lose their that's quite low we go
parallelism parallelism on the desktop
but I'll is on a cloud we are not
prepared I mean in let's say on the
developer side of the fence they're
starting to think about it with changing
pad exams we're changing languages we're
changing we going functional there is
new areas there that we haven't even
thought in that level for testing
there's also exciting things in the
testing side of those and then we got
devices like Android devices we're
losing the the full-blown computers as a
consumer device and we're going to end
up with tabs we're going to end up with
smartphones we're gonna end up with
fridges that do stuff and that is also
massive scale and quite different
problems in user interface testing
google TV TV that's gonna get smarter
and so on yeah so any other fun don't
play chess against your washing machine
you're going to know jump i have another
question last question and then we'll
whirlwind down so would you agree with
James whiticus for three score or do you
have any other goals for death
hi James so I actually sit about 20
paces from where Alberto sits in
Mountain View and so for three I think
it could go either way because the place
I'd like to see some more investment is
on the education side for our future
developers in test engineering across
our organization we have a lot of
expertise and our goal should be to
bring more and more of that expertise to
every single one of our sui's our
feature developers and that might
require an additional investment in
additional test engineers additional s
cts so that we can accomplish our
current goals as well as the educational
goals ok great I think that will sum it
up here so thank you so much for
participating in the last section of
this interactive session so I think
we're done I appreciate everybody who
sort of chimed in added questions and
also contributed to this interactive
session so thank you
so to wrap this up I thought I'd leave
you all with sort of a thought and
controversial or not but I think one
thing that I heard through this
conference was testability is important
everybody's thinking about what it means
it means different things to different
people it's not even clear where it's
it's the hardest one that I heard was
that metrics how to measure testability
is a hard problem and I think Esteban
talked about it says we don't quite know
how to measure it yet Brad talked about
a little bit about the even testability
Explorer it went up to a certain point
we kind of staggered there and there are
other various efforts that were started
in it so perhaps the thought to talk
about is can we understand us to believe
by trying to measure it and what does it
mean and how can we even think about
measuring it that's the thought that I
would want to leave it with with the
with this interactive session also
overall at the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>