<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Massively Multiplayer Open Source Game Development | Coder Coacher - Coaching Coders</title><meta content="Massively Multiplayer Open Source Game Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Massively Multiplayer Open Source Game Development</b></h2><h5 class="post__date">2008-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tKSYJYV_RGs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the Tech Talk today Keith is
going to talk about multiplayer open the
sauce online role-playing game or memos
or poker call a plane shift plate keith
is being with the project since 2001 and
he's currently the CTO of choice pay as
well so Keith thanks Andrew hi everybody
I'm glad to be here today I'll first
talk about and I'll just try to
introduce Blanchett for those of you how
many in here have heard of playing shop
before or seen it okay a few of you well
that's good you know plane shift has
been around for a long time and it's
been a very ambitious project we're
trying to build an MMO in the vision the
same type of vein as World of Warcraft
or EverQuest or Age of Conan or a
million of those games back when we
first started EverQuest and Ultima
Online were kind of our competition but
considering that we're like four guys in
garages around the world it's hard to
say we were competitors of theirs the
game is free-to-play and the source code
of the game is completely free so it's
all GPL that's all on SourceForge
anybody here can go out there pull it
down and build it it might take you a
couple days to get it to build the first
time but after that that it's pretty
easy to keep it going once it's going
all the content though we have kind of a
dual license system and the content the
artwork the quests the puzzles the maps
those things are all under proprietary
license and that's how we keep the game
from forking and people creating all
their own shard servers and having a
thousand different you know versions of
the game we like to say it's the way we
prevent porn shift so if you think about
naked mods and things like that
we'll talk about some of that in a
little bit project started in 2000 this
is when the 3d project started there
actually was a 2d version of the project
that started in 1992 with Lucca and
Italy and a few of his friends that were
into role-playing games they wanted to
take what they were doing on the desktop
and move it to just you know make a
computer game out of it but the the
modern generation game started in 2000
it got going in earnest
summer of 2001 I joined the project and
I think November of that year the I was
talking to Andrew about this a little
while ago
and I think the 62 coders the named
people that have committed code that's
actually since our subversion conversion
we first started in CVS and so that
number probably is totally wrong we
converted to subversion and I think
summer of 2006 so that was a couple
years ago so we've had 62 committers
since then and just in the last two
years so it's probably more like 150 or
so overall and then and that's just with
the code you know we've had dozens and
dozens of contributors across the
artwork and the writers and the various
other people that have supported the
game it's relatively large you know for
an open-source project we got we used
crystal space which itself is a very
large project so that's over a million
lines of code and then our code is about
400,000 lines divided up into about
1,200 classes so this this creates a lot
of learning curve issues for us as
people want to volunteer and then they
get into it and they see what's there
and then they can't they don't know
where to start or how to do anything so
supporting those people and figuring out
how to enable them to be successful and
give us patches is a big part of my
challenge in turn in terms of making the
team more productive we have over the
past three years on the current release
you know we've had over a half a million
people successfully register accounts
and try the game most of those people
log in they to know they create a
character they run around for a while
they want to see what it is and then
they quit and they go on their way we
only have about a hundred to 200 players
that play on any given day or at any
given moment and they're probably about
five or six thousand that will log in
any given month and we can talk about
why some of that is later to you know
probably no news to anybody in here but
MMOs are very complex pieces of software
typical open-source structure is that
you have a coding team and that's it and
what you're building is you're building
a better version of VI or whatever your
project is and that code is all there is
you might have a QA team if you're a
very formal larger open source project
we have a much more structured concept
and we have much larger complicated team
so the teams that we have today include
the 2d team which is doing concept art
they're doing pencil sketches and
charcoal drawings and things of that
nature to be grist for the mill for the
3d modelers the 3d guys are actually
doing the modeling and then they're
doing animation and generally there are
specialties where the the more beginner
modelers are building items or they're
building terrain then you have more
advanced modelers are building monsters
and creatures and then the most advanced
modelers are the ones building the
player characters because those are the
ones people are really picky about the
sound team does sound effects every
swoosh of the sword every dramatic
trumpet fanfare when you get a level or
something all of that stuff has to be
built on keyboards and you know rendered
if the rules team is figuring out how to
make it into an RPG what is the
progression how are we balancing things
what are the 200 different spells that
we're going to have somebody has to
decide all that that's what this team
does they basically work in Excel that's
their number one tool is Excel then we
have a web development
oh I settings so I forgot settings
settings are the writers they're the
poets and the dreamers I call them
they're kind of the prima donnas on our
team where they are wanting to write
these long descriptive background
stories of you know in order for this
quest to be relevant to this player now
you have to understand a thousand years
worth of history that leads up to this
blacksmith who wants a sandwich from the
sandwich shop so but those guys really
enjoy doing that the web development
team is built really as managing the
content we have a you know a large data
model that supports all the reference
data in the system and so when they add
a new item or they add a new quest or
they do something like that they use web
tools to do all that rather than doing
it with an in-game and then of course we
have the traditional open source project
teams which are the coding team and the
QA team the key learning point for me at
this point was
that the content is much harder than the
actual engine building so typically I
guess most of you in this audience are
probably coders you know I come from
that background and I'm used to thinking
the code is the hard part but in this I
can write a feature in a night that will
maybe I'll build something one night I
built a feature to allow our combat so
that you're the animations that were
played in your combat depended on the
level of the skill level you were using
the weapon you had and when I did that
that meant that now I could link the
skill level to the animation name and it
was all kind of really elegant it was
like 20 lines of code to get that all
going and now that turns into a thousand
hours of animation time for the
animation team to create dozens of new
combat moves and to get all those rolled
into the game so that's where the the
cost of these things is and the effort
and the hard part you know the the two
most obvious constraints that we have on
this team are no money and no money and
so we run a dedicated hardware donated
hardware we're lucky that because we
have a relatively high profile you know
I think the last time we needed another
server Lucca sent a request out you put
a notice on the website saying you know
we need a server can somebody donate us
a dedicated server at all the bandwidth
etc and I think in 24 hours we had 22
responses of companies that were
offering to to provide that for us so
the amount of hardware hasn't been a
problem but even once we have it we
don't have a lot of advanced tools for
deploying this stuff and managing on on
mass basis so for us one server is
already a lot of work to maintain and to
have dozens of them you know we don't
have the tools to do that
and if we do that I said they wouldn't
be co-located either so as we spread
this around we need to be thinking about
a high latency network it's not all in
one rack on a gigabit switch no money
also means it's a volunteer development
team Andrew and I are kind of long
timers on that team but a lot of people
come and go it's a revolving door there
we have a lot of people that have done
one path
and that disappeared and some people are
there for a year and then there they
graduate from college or they change
jobs or whatever and and so there are
situation changes and so as a result of
learning curve issues as I touched on
earlier are a big issue and so we want
to enable people to get comfortable with
a certain area and then to branch out
from there or to move on and somebody
else takes over their area okay so now I
thought at this point I would show you
guys a YouTube video for those of you
who haven't seen plain chef just to get
an idea of what it's like so if we're
flipping settings on video now is the
time to do it and all maximize this
okay okay I think the worst part of that
video is that makes a game look better
than it actually is that was that was
produced by a fan we have there's a lot
of fan generated video stuff out there
and so I just kind of when I was getting
ready for this the other day I just went
out there and tried to find one that
looked good and that's what I found so
the team can't really take credit for
the for the trailer I think they did a
nice job on that okay so that gives you
should give you some flavor for what the
game is like you can see that it's a
pretty ambitious project and I think for
a bunch of people working an hour a day
and here and there and their spare time
when they're not sleeping I do most of
my coding after my wife goes to bed and
you know so my day on this doesn't even
start until usually 11:00 or 12:00 at
night so I think it's been it's taken us
years and years to do but we've come a
long way with it okay so now I'm going
to dig into how this thing is actually
designed and some of the key pieces of
it that I think people here might find
interesting
at a high level you know the server is
basically doing nothing more than trying
to handle thousands and thousands of
events that are coming in events can be
Network messages that can be time
triggered activities or they can be you
know interest server messages that are
sort of broadcast internally in the
server no distinction is made between
these once they're in the system so a
lot of times the network message will
turn into an interest over broadcast if
it's of a certain type threating model
you know basically just one worker
thread doing 90% of the work and this
and Andrews got a whole bunch of
thoughts on multi core servers that
we'll get to at some point but right now
that's the way it works there's a
pub/sub architecture that allows for
what we call managers to then subscribe
to these events and handle them so to
add in new managers in order to
specialize and only learn a certain
manager is really easy to do so the
classes these managers are basically
defined
long functional line so we have a spell
manager we have a GM command manager for
the kind of police that are out there
policing the players combat chat login
authentication etc are all different
managers in the system and so it becomes
it's easy to find the code that you're
looking for if you're trying to drill in
on a specific feature to either fix it
or enhance it or to find it to find a
bug that lowers the learning curve which
means that the volunteers can get
started sooner and you know make
progress and feel like they're
contributing something quicker and it
also means that it's easy to bolt in new
functionality because you can add a new
manager in subscribe to a new message
type and then you're good to go and the
rest of the server doesn't really need
to know about it this diagram is a
little bit old so there might be more
manager there might be a couple more
managers at this point but what you'll
see here is that you know whether
handles all the random rainfall of
lightning and snow and the light and
dark cycles of the day night and so
forth the spawn manager is handling npc
spawning monster responding as things
die and we replenish throughout the the
map progression manager and NPC manager
exchange manager is handling item
exchange and inventory management
between the players that's a big source
of exploits and cheats by the players so
that's probably one of the most
sensitive areas of our system entity
management I'm going to talk about in a
little bit what else you know they're
just a whole bunch of those that they go
down the line and so whenever we add a
new functional area we'll add a new
manager you'll also notice over on the
right the client has a very similar
structure with what we call handlers
where it's doing the same kind of
subscription model either to network
messages from the server you know kind
of events signaled by the server
or by commands issued by the player ok
so now I'm going to dig into the network
and entity I'm going fast through this I
have a lot of slides and I'm going to
try to get through them all you know we
could spend an hour just talking about
entity management or just talking about
how we do our UDP implementation
trying to just skim over the top on a
bunch of different subjects and if we if
we want to drill in on any of those I'm
happy to do that in the Q&amp;amp;A session the
base networking it's all udp-based it's
kind of a subset of TCP that we built
because the TCP because it guarantees
ordering a packets than one held-up
packet can hold up every other packet
behind it and that's really not a good
thing in a game where you're trying to
have real-time synchronization across
the clients we have two priority levels
of messages which would guarantee to
non-guaranteed we need to have
guaranteed ordering for some messages
but not for all messages and so I think
at some point soon we'll we'll be adding
that on a pretty fine-grained level we
pack it all really tightly and we spend
a lot of time on packing those Network
messages together because bandwidth
really is our number one bottleneck in
terms of how far we can scale a single
server a lot of people would think that
it would be the CPU or they would think
we'd run out of memory or something
along those lines but the game is
efficient enough to wear really
bandwidth is our issue the server is
obviously it's all running on one server
today so the entire world is all in one
server at some point we'll probably zone
it out and partition it off but we
haven't had to do that yet and so we
haven't done it an entity is something
we define as any object that's added
after the fact to the map so that could
be characters and monsters or it could
be if somebody drops a book on the floor
now that book is an entity so the maps
are loaded and then the entities are
overlaid on top of that each client then
gets a subset of those based on the
relevance and proximity that they have
to that so there may be let's say 5,000
entities in the world that the server is
managing but each client only sees their
subset of those entities and so this is
my attempt at a simple diagram around
that so player F so the server sees all
of these entities in its model but
player F has a proximity list where he
can only see himself and five other
characters on there and player aged can
see himself and six other characters
and they only have that character G in
common between them so the other
entities in terms of player FS client
machine and the entity outside of that
circle does not exist in his client
that's really important for performance
reasons and kind of network bandwidth
reasons it's also really important for
chi protection and kind of map exploits
and and visibility exploits relevance is
first and foremost determined just by a
threshold distance to the player that
threshold distance depends on the type
of entity so a player character or a
monster could be a hundred meters but a
special gemstone could be one meter and
so you have to physically be within one
meter of it before it exists on your
client that's another thing we do to try
to prevent cheating it has to be visible
to the player and by saying that I don't
mean that it's visible on the screen to
the player in terms of it's not occluded
by a door or something I mean that it's
logically visible that if the player
turns a certain way they could go see it
so this really has to do with GM's that
are invisible or a player that's cast a
spell of invisibility or something if
he's invisible than other clients around
him don't ever have that entity on their
machines at all so it's not hackable and
then within the same instance the game
also supports instance dungeons and
instancing for various reasons and so
the instance for us is a fourth
coordinate so every entity in the system
has at XYZ coordinate and then they have
a W coordinate which is their instance
and only players players can only see
other players that share the same W
coordinate basically yeah
because it means that you have to be
within a meter to see it so if the if
the point of if the game is to like find
the hiding place of the gemstone then
you've got to get there within a meter
you can't just hack your client and get
a print of all the entities that get
propagated to your server from the
server down to you and then know the XYZ
coordinates you need to go to until
you're near it right so the the benefits
I mentioned the security benefits a
little bit and I'm going to talk about
that more in a little bit at the end it
also is very important for minimizing
bandwidth we're sending a lot of
position and velocity updates about all
of these entities you know every second
or every half second and so the fewer
entities we're sending that the fewer
client machines that we're sending that
to the less bandwidth were using so it
makes it much closer to kind of a linear
scaling network bandwidth consumption as
opposed to kind of an order N squared
update model and then it's a very easy
construct to use for the managers when
they're broadcasting because then like
if I'm chatting and I wanted to shout a
message I might shout that to everybody
within 100 meters well that's my that's
my entity list and if I want to do
everybody within 10 meters or 2 meters
for a whisper or something I can look
down that proximity list and look at the
radius of each one of those and quickly
and efficiently just broadcast to the
people within that radius without
looking at all 5,000 entities so the
cost of it is that the server does spend
a lot of time maintaining and updating
these proxy lists and so there's a lot
of work on that and pounding out all the
bugs and that was a multi-year process I
would say right Andrew so this is what
it actually looks like it's a mess you
know every entity has its own proc
celeste around it and they all are these
overlapping lists and they're all being
maintained in real time as one updates
or another updates
okay so now I'm going to shift over to
scripting we use several different types
of homemade scripting languages in the
tool they're these mini miniature
languages first for solving a particular
purpose in the game generally the
benefits of these things are that
they're possible for non-programmers to
produce and I'm going to show you
examples that other teams are using so
the engine team will build a mini
language and then we'll give that and
then the web guys will build an area of
their content management tool that
allows people to put those scripts into
the tool and then the engine team gets
out of it
so if they want 200 spells or 300 spells
we don't care we don't have to code them
all they're just data that also means
once we put it into the database its
proprietary content and so it keeps us
from having to GPL that data so we have
test data out there so we have example
scripts and we have a running server
with spells that work but they're just
demo spells to show you how the the
scripting language works and it kind of
bee test cases but they're not the
actual in-game scripts of the real game
official game but what it does is it
makes the engine team a lot more
productive because we spend our time
really at the metal level mostly adding
new commands and capabilities to the
scripting languages and then that
becomes a whole new toolset for the
other teams to use as they go forward do
what if somebody talking oh somebody out
there yeah they do or they just don't
think that it's possible and so they
don't think we ever intended it for it
to be there when actually it's just a
bug and so then they'll ask for a
feature that they want they're like it
was a possible that we can do this and
we'll say yeah that's been in there for
two years and they're like well we tried
it and it just doesn't work we didn't
think you did it so there there's some
of that that goes on and so periodically
we try to go through and update the
documentation and clean up those
scripting languages so yeah it's a it's
an interesting problem but but I really
like that meta programming stuff where
we're building the tools for the other
people to be productive on it
and that's a much kind of higher
multiplier activity for us to be
involved in so the first one of these
that I was going to talk about was a
math script this is basically what we
use for the RPG rules or anywhere where
there's a calculation involved so if I
am a character and I swing a sword and
hit another character what is the
resulting damage of that hit well there
is some sort of a randomization factor
it's based on my skill their skill their
armor my weapon a lot of different
function
you know features about that particular
situation that leads to that result
that's all done within math script so I
have a couple here that I just threw out
there just to show you an illustration
of it these are just from our subversion
examples but the idea is that you can
there's late binding to the objects any
object in the game as long as it
implements this interface called AI
scriptable can be linked into math
script and then you can get at its
attributes with the colon operator there
you can also call functions on those
objects a worker right here has a
function called get skill value that's
implemented by AI scriptable and so
those can be added to the engine too so
the people that are the non-technical
ones or the non C++ people are writing
this stuff and using engine features
without really knowing that they're
doing that and if they need a feature we
can add it in without changing the
underlying scripting language too much
and get there so it's it's pre compiled
of P code on server startup all these
are loaded in at the beginning it takes
the server about a minute to two minutes
to startup whenever it starts because
it's loading in absolutely everything
and caching absolutely everything
dynamic binding I just mentioned and as
long as they implement I scriptable we
can bind those objects at the time that
you know right before the math script is
called another example is what we call
progression scripts and this is where
this is kind of how spells are done or
other things like that where you want to
describe the effect that a certain event
has on a player or on a cup
a set of players and so in this case
damage you know there's an operator here
we use XML just because it's easy to
parse so the hit points go down by this
this value here is any mascara any
single line math script so that can be I
just put a negative sign in front of the
variable there but you can also this in
some cases this is a long complicated
formula and so depending on how crazy
the rules guys went with their
spreadsheets you know that's what they
end up putting in there and then they
can do some messaging where system
messages show up on the screen and you
know notify players of things that have
happened as well from within the
scripting languages these are compiled
down to virtual function calls you know
each of these objects here each of these
tags turns into an object and then the
script runs by just calling the same
virtual function across each one and so
it's again very efficient way to run
those scripts and they're pre-loaded and
parsed at the time of them start up and
then the value attribute can be any
single I'm a script okay this is the one
that uh that's near and dear to my heart
because it's the least script dish what
this is is a script for how a quest is
done in the game and quest for us is a
generic term that means any kind of task
that an NPC would give to a player to
help them get a reward or progression
points they're not all grand quests like
in a in a novel or something but what we
found was that with the XML structure we
had a similar XML structure for dialogue
and kind of action response
scripting with our NPCs there was XML
based and looked a lot like those
progression scripts but it was too
technical for our poets and so what we
did instead was after two years of
struggling with them trying to use that
XML structure was we went to this and
this is designed to look like a
screenplay so it's much more like
writing a dialogue back and forth and
they can kind of just free associate it
and think of how they want to do it and
then with a little bit of syntactic
sugar to give some hints to the engine
about how to pull this all apart we can
we can make it comprehensible to them so
you'll see that P up here
a stands for player so the player
initiates this quest by saying greetings
and then there's a whole synonym
architecture around there are a million
things I can say that all equate to
greetings behind the scenes then we have
this character named Marth who responds
back to that and says hail you know
would you like to earn a little money
the player then can say either no or yes
I can get my mouse going so they can say
no or yes and then the Marth response
are down here so if he says no the first
response correlates to the first player
statement there and the second response
correlates to the second player
statement and only the second one
progresses the script if he if he does
the first one it says well okay then
have a good day and the script stops
right there and so this to our writers
is understandable that this is how they
have to do it so the positive thing that
advances the quest forward there's
always at the end and then that chains
on to later in there in the quest there
are other things I try to put in kind of
a simple example here but there are lots
of prerequisite scripting they're only
people of certain levels can get certain
quests or if they have a certain item
and so forth you can also link these
scripts together and chain them and make
subroutines out of them and stuff so but
that's all done in a sneaky way to where
the settings people don't realize that
they're coding subroutines but that's
what they're really doing this is all
done essentially through a preprocessor
that loads in these as big text blobs
and kind of parses and mount
line-by-line
creates the XML that I tried for two
years to get them to use and then it
creates that from this and then it runs
that through the XML loader and it's
running that through the rest of the
game okay so that's a an overview of
three of the mini scripting things that
we have we have some others on the
client as well for effects you saw the
sparkly things going on and lots of
different spell visual things that's all
done through xml structures to that our
art team uses so anyway there are lots
of those let's talk about NPCs for a
minute because this is the other topic
that is near and dear to my heart the
basic fact of the matter is that NPC AI
is hard to scale you know it's very CPU
intensive
to do true AI and to really make things
intelligent and in a world where we're
trying to have one server left us as
long as possible and to potentially
support thousands of players we have
thousands of NPCs all managed by one
process on one machine would really
limit us in terms of what we could do
with it but today and our monolithic
server you know that hundred players
takes us less than 5% CPU on that
machine and so that means in theory we
could scale that to to 2,000 years 2,000
players on that machine but at that
point we're using something like 20 20
megabits of bandwidth you know to
support those players and so that's why
bandwidth is our big issue rather than
CPU but AI is computationally intensive
the smart of the monsters are the more
expensive it is to make them that smart
and the AI techniques are constantly
evolving and I wanted to put together an
architecture that would allow new AI
experts to show up
you know my dream idea is that Andrews
gonna be an AI expert soon and he's
gonna come back and he's gonna want to
make the world's smartest dragon he's
gonna have an eight-way box that is
dedicated to making one dragon
incredibly smart okay and so I want to
be able to support that rather than to
say no you've exceeded your 1% budget
for that dragon that's all you can do so
what we do is we pull that AI out and do
its own process and so that's what these
NPC clients here are they're their own
process they connect through the same
networking layer that our clients do and
so they can attach and we can have
multiple of those attached and so the
NPC client that's kind of our default
implementation that was ship with is a
very efficient very basic NPC client I'm
gonna describe to you how we do that but
if somebody were to create the world's
smartest dragon as long as they
implement the protocol that we already
used for NPC client they can snap in
there and that whole server farm could
be dedicated to one NPC you're gonna ask
a question
I can barely hear you what well I mean
in the in the most basic case it would
be things like pathfinding in a big
world if you train a monster and you
chase him over three maps away you know
and then he needs to finally get back to
his home area that would be a very
expensive calculation that I don't want
to hold up the server on that it could
also be that when you know in the
high-end games and commercial games it's
not unusual to have you know kind of 60
players all attacking one monster and so
in those Mass raid type environments you
can imagine that you would have a very
smart set of monsters that were teaming
up and you know kind of working as a
Wolfpack to attack from the different
sides and to optimize how they were
going to do it and so I don't want you
know I don't know what all those
scenarios might be but I want to be sure
that our framework supports that if
somebody thinks of something cool to do
we can do it okay so the key clients in
what I call the super client is that the
NPC client is our default Super client
but it handles today I think it handles
about 300 NPCs and so it is one process
acting like a client on behalf of 300
entities and that's why I call it a
super client because most of our regular
clients are handling one entity which is
the player and just responding to the
keyboard or what have you it connects to
the server over the network it uses the
same protocol for most things so things
like login and authentication and entity
propagation are all using the same
protocol but it has a special messaging
layer for bulk activity so if you're
managing 300 monsters you're probably
like right now it's handling all the
monsters in the world so it actually
needs to know about all of the entities
in the world and it's a waste of my time
and a waste of the server's time to have
300 independent proximity lists for
those 300 entities when at the end of
the day it's all one big activity so
there's a lot of bulk updating that's
going on between the NPC clients that
isn't happening with the player clients
the NPC manager class on the server is
yet another manager and it handles all
of the NPC specific protocols and so
what it does it packs up and unpacks the
things that it needs to and then the
bulk updates it unrolls us into
individual updates and then republish
those internally into the server so to
the rest of the server of movement
update of a player or of a monster are
in identical in the server and so the
fact that the bulk update was done at
the beginning doesn't matter so yeah so
the emulation layer means that there's
no distinction between players human
players and automated players almost
anywhere in the game and on the client
machine there is no distinction between
a monster and a remote player so you
know about yourself and that's special
but if there are five players here and
five monsters on the other side you know
to you you're getting the same network
updates and you have the same
information same stats same everything
about all of those from a scalability
standpoint you know the next place when
we hit a bandwidth limit or a
scalability limit on here we'll pull NPC
client off onto its own machine and then
that will connect remotely and now
instead of two really heavy processes of
our game server and our NPC super client
both running on the same box as soon as
we pull those apart now we've just kind
of doubled our capacity without really
doubling our complexity the other thing
we can do obviously is to pull our my
single database off on its own server so
I think as we start to hit scaling
problems if we ever do that'll be the
most obvious thing to do before we ever
go to zoning or other things like that
so then and we've already kind of talked
about no limitations on AI techniques as
long as we use the same net protocol and
again because it's open-source we can
change in that protocol too we need to
so how do we do NPC AI what is the
default Super client doing okay and this
is what I like to call artificial
stupidity rather than artificial
intelligence
my big example is pac-man where the
ghosts and pac-man have practically no
intelligence to him if you think about
the CPU cycle budget that the guy's had
he wrote pac-man you know that that
thing is doing practically nothing and
yet that's still a pretty challenging
game for most people and so for the
average case and the you know the most
common use case of these things the the
mobs don't have to be very intelligent
to be fun to play against so we really
emphasize CPU efficiency and flexibility
of the scripting because we didn't know
what we would want so we have yeah so
our super client today controls about
300 mobile NPCs and takes generally less
than 10% of CPU on the machine so when
it's not unusual that when we're will
all look at top on the server that may
be a slow time and top will be the
busiest command on are the busiest
daemon running on our machine compared
to the server of the NPC client so how
do we do it the first thing we do is the
scripting language for the NPC's is
another one of these mini scripting
languages and it supports this concept
of NPC types which are basically mapped
to kind of C++ classes so they they
define the overall methods and behaviors
of that of that particular class of
monsters each NPC then is assigned to
that type and gets all of those
capabilities so type consists of a set
of behavior so walking around randomly
attacking chasing fighting those those
are different behaviors and the monster
will switch between those behaviors
depending on what else is happening the
way that they switch is through
reactions to perceptions which is that
second bullet their perceptions are
either sent by the game server hey
somebody just hit you with a sword or
their perceptions generated internally
like hey that monster is out of range or
that player is out of range you need to
chase them that kind of stuff there's an
inheritance structure for the NPC types
as well so you can define a bunch of
behaviors and then you can have a
special monster like the boss
who has all of the original behaviors
plus two other behaviors real easily in
this structure the loose structure does
give us a lot of flexibility and power
but I will tell you it's very hard to
debug because it's hard to tell a bug in
the script from a bug in the in the
client in the super client so then the
NPCs themselves are kind of like
instances of those classes now so
they're assigned to a certain NPC type
and then they maintain their each one
maintains its own individual priority
queue of the behaviors that were listed
for that NPC type and then executes the
behavior that is the highest priority
that priority we call the need so the
NPC doesn't have a lot of needs but then
when you know if it doesn't have a lot
of need to fight it's just wandering
around it's happy when you attack it
that the reaction is to boost up the
need to fight the need to fight takes
precedence over the need to wander
around and then it starts attacking it
starts fighting back so that's how the
behavior is run the other thing that the
NPC's maintain is what we call hate list
and that's the list of all the players
that that monster knows about and kind
of is a way for it to determine who does
it hate the most as who is it going to
fight so if it has five people pounding
on it which one is it going to attack
and so that's another sort of little
priority queue in their priority list in
there that it uses so the reactions only
affect needs and hate and then
everything else is done by just running
the highest need activity so this is a
an example of what an NPC type looks
like in this example it's called fighter
there's a do-nothing that's just to
stand there and so that could loop
around and just play the animation that
stands and breathes and kind of sways
from side to side and that's about all
it does it also has one for turning that
I don't think is used by the script then
fighting finds the target turns to face
the target
and then me leaves with the target and
it has arranged there that it has to be
within three meters of that target or
else it's going to be out of range and
then I have a chase one there too
that chases the target if the targets
running around so if you look below
you'll see in the the third reaction
down there if it gets an event from the
server or perception that's called it
that's called attack then it knows that
it's been attacked and so it's going to
override whatever behavior it currently
had and immediately implement the fight
behavior and so fight then is going to
turn to face the targets going to locate
the target turn to face it and then
melee it damage is the fourth one down
there it adds to the fight but then the
weight factor here means that the hate
list is getting updated proportionally
to the amount of damage that was being
done by that particular the person who
is attacking in we have more
sophisticated things in mind for that
where some mobs may hate the use of
magic against them more than they hate
you know melee attacks or they may hate
slashing damage more than they hate
blunt damage or something like that so
we'll just have to see how that goes but
then you'll notice the the second to
last reaction there says target out of
range and it switches to the chase
behavior so you know it stops fighting
and it starts chasing and then when it
gets back in range it starts a you know
it automatically the need to chase drops
down when when he catches the guy and
then fight now again becomes the highest
priority one and it falls back to
fighting and then death basically tells
it to stop fighting after you know when
the player dies it's time to stop
fighting you don't want to sit there and
keep hacking okay how am i doing that
I'm okay
game security and open source is almost
an oxymoron because the whole idea is
that we're giving people the keys to the
kingdom they can build their own
executables and connect to our servers
with them and so it's a never-ending
kind of battle
and a thought process that were always
in to see what are the cheats that are
possible by adding a certain feature and
then do we care about those cheats or
not so I put up these pictures to show
you that modifying textures is a
favorite pastime of the fans and so
somebody made a Simpsons mod for the
game and they have zip files up there
and you can download this and overlay it
on your plane ship to install and make
all your characters look like people out
of the Simpsons
so anyway okay so hacked clients are
trivial and I listed out a bunch of
different ways that the stuff can be
hacked so speed hacks you know everybody
anybody who's played one of these games
knows that it is a giant pain to have to
run from one end of his own to the other
and and so you could have a 20 minute
run to get somewhere if you have if you
don't have the right teleport spell or
what have you so people will just hack
their client that now they can run ten
times as fast if they press another
button well we need to detect that and
do something about that the same with
teleportation and anti-gravity things
like that those are all kind of fall
into the movement hack thing visibility
mods are another one we had a in the
case of the one meter gemstone we had a
guy who modified his client and made the
gemstone a thousand times as big so that
when it was propagated it was the size
of a city and he could he could see it
immediately and that's why we actually
implemented that one meter range so that
he couldn't see it just by modifying his
mesh just the 3d model on his on his
desktop though it was be there would be
no way for us to detect that so we have
to make it inherently secure from things
that we can't detect bots and Mac rowing
are another big problem for things this
normally applies with the trades more so
than with things like combat where we
have smithing we have mining we have
wood carving and things like that these
are very repetitive activities where
you're sitting there and you're just
trying to get or so that you can you
know smelt it down and make gold bars or
what have you and so there somebody can
write a macro and then you know dig and
then move a meter over and then dig
again and move a meter over and make a
big box and just
doing it that turns out to be really
hard to detect so and we put in
something to detect it and then they get
around our detection because they can
download our code and see what we're
doing to detect it
okay so collision detection hacks are
another one running through walls you
know we try to set up a maze and they
just run all the way through to the end
by turning off collision detection map
hacks are another one
don't don't remove the collision
detection just take out all the walls
and run to the target in the maze okay
so there are things like that that you
know we have a problem with that most
commercial games dome item art hacks I
kind of talked about that with the
gemstones and then texture mods was kind
of that Simpsons thing that people do
for fun just too well I've seen the
Simpsons one my personal favorite is is
ninja shift where they made everybody
look like ninjas and so they're a bunch
of those out there so I kind of grouped
these into three basic areas there's
kind of low impact things that there's
really no defense against texture mods
are really the first one all right kind
of the main one there but there's also
really not a lot of impact of that
people do it they think it's fun it's
harmless it's not messing up anybody
else's gameplay it doesn't make anybody
look like The Simpsons on their machines
it's only on the machine that has the
Simpsons mod installed on it so they're
really kind of only affecting themselves
it's it's not that big of a deal the
high impact ones that are easy to defend
are things like visibility mods and this
is where our proximity lists come into
play where we really use those to where
the client simply doesn't have the
information to ever show it or or
display it in a way that's will give the
player an advantage and then the speed
and teleport ones well we can have the
server not just blindly accept any dead
reckoning update from the from the
clients it can actually compare before
and after positions and make sure that
that's authorized for speed and
teleporting you can kind of just do a
distance and a time interval and and
tell and it's fairly straightforward
there's some because of latency on the
network and kind of jitter in that
latency in the UDP it's harder than it
sounds
to be perfect but you can make it a lot
better to where it's not just open
season on whatever you want okay so then
bots and Mac rowing I was describing
these are the high impact ones that are
hard to defend against these are the
ones that Andrew and I have spent months
and months on with very little success I
would probably add it's extremely hard
to detect automatically because again
the code that we're using to detect it
is in the is out there for everybody to
see so smart players download that see
how we're doing it and modify their
macros to evade our detection so what
we're trying to do is we're trying to
focus on the law of diminishing returns
so that if you you know mine for gold or
dig for gold in the same you know over
and over and over
maybe that's valuable the first 50 times
you do it but if you do it a thousand
times it's not twenty times more
valuable than if you do it 50 times
eventually you'll get to where you just
never find it and so by doing that an
average human player just isn't going to
have the endurance to do that they need
to go off and do other activities and
then come back and that's how we're
gonna basically try to make botting
harder to do and not worry about whether
we detect it or not we'll just not make
it valuable so we're trying to reduce
the impact rather than improve the
detection yeah
yeah yeah absolutely yeah so they could
dig for gold and then they could farm
and then they can go back to dig for
gold yeah so I mean it's a it's a big
problem so the other the other thing
that we do is we try to engender a
player culture where they basically rat
each other out and the game masters that
can be alerted that somebody is bahding
and then the game masters will kick
those people out or ban them from the
game could we give them you mean could
we do that is that what you're asking
yeah we could do that Star Wars Galaxies
did a lot of that where you could set up
automated a tree kind of repetitive
activities and then log off and when you
log back in you'd have a thousand gold
pieces from your repetitive activity
yeah I mean those are all options and I
think they kind of have to just be on a
case-by-case basis as we figure out what
people are tempted to do as to how do we
want to address it but if you want to
have any kind of economy in the game you
can't make everything easily automatable
yeah PvP in our game because as has been
a big controversy from the beginning
because some people really like PvP and
they want kind of free-for-all they want
to kill anybody and gank anybody that
they want at any time and they think
that's the most realistic way to
structure the world other people really
are kind of the Care Bears out there and
they don't like any of that at all and
so what we have in-plane shift is we
basically have an opt-in system to
free-for-all PvP and so we have a system
called duals where players can challenge
each other to duels and then if if you
don't have kind of auto accept turned on
then a box will pop up of do you want to
accept the duel or not if you and you
can kind of set that to either pop up a
box Auto decline or Auto accept and so
the people that are out there that like
free-for-all pvping Auto it set their
thing to auto accept and they just
attack each other you go Andrew is it
time I think I'm done so the just my
last slide here the website is playing
shift IT Lucca is in Italy he lives in
Turin and so he started the project and
it's his website so everything ends and
IT he's reachable there and then my
email address was there as well if he
want to follow up and if anybody any of
you would like to contribute to the game
we'd love to have you and on any of
those teams depending on what you're
interested in and contributing
could you explain a bit more about your
closest media and why you decide to go
down that route sure because it's been
one of the major factors why I
personally haven't contributed to plane
shift I've contribute to some of the
other I'm the source MMORPGs because I
can't then reuse the art like that
that's there in my own type of stuff
right yeah you know there are a lot of
schools of you know a couple different
schools of thought on it of people who
feel strongly about it and I've had this
argument online with people a million
times but I mean it basically comes down
to that our philosophy is that we want
plain shift to be plain shift and we
want the artists who are contributing to
the game to know that they're
contributing to our game and not to
somebody else's game that is going to
misuse their characters or misuse their
art in a way that they don't want it
used and so I think the perception of a
lot of some people on the team just
don't care but the but a lot of the
perception is that the people out there
who are rapidly open-source and what not
only the code to be open-source but they
also want the content and all the music
and everything to be reusable
it's basically they want they basically
want that to benefit themselves and not
to benefit the rest of the community
they just want to be able to play with
it and so we're trying to keep the game
to have as much integrity as possible
and to kind of have its own identity the
engines out there and it's reusable and
it's actually been reused by at least
one other project and maybe two that
have used to use the engine with their
own content to create entirely different
concepts from even the MMO concept so
it's been really fascinating watching
them do that and we totally support that
but using reusing the artwork and
reusing the models and the music and all
the stuff I mean it's I think the
current download is somewhere around 330
Meg to install the game and so there's
an awful lot of art assets out there
that if somebody were to take those and
use them in a million different things
then all of a sudden plane shift
wouldn't be as unique and as special
anymore as it is today and that's
something that our art that our artists
like to like about contributing to the
game as well
anyway else okay thanks a lot guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>