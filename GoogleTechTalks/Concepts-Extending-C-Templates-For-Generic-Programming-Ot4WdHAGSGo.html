<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Concepts Extending C++ Templates For Generic Programming | Coder Coacher - Coaching Coders</title><meta content="Concepts Extending C++ Templates For Generic Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Concepts Extending C++ Templates For Generic Programming</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ot4WdHAGSGo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today's speaker is Doug Gregor Doug is
from Indiana University and he's one of
the leading experts on generic
programming and related in Houston today
he's going to be talking about one of
the major features that's going to be
added to the new version of C++ it's the
word that everybody who works on this
feature uses to describe it his concepts
and if you don't yet know what that
means
Doug will tell you and one reminder this
is being recorded and it's going to be
going out externally on Google Video so
if you have any confidential questions
for dog please save them until after the
talk thank you thank you Matt so I'm
going to talk about concepts and this is
an extension to the C++ template system
to support the programming paradigm of
generic programming so a brief outline
of our talk we're going to talk about
generic programming what is this
paradigm what is it used for and where
have we seen this before then we're
gonna go directly into concepts this new
language feature and talk about all the
various parts of this feature how you're
going to use it try to give you a sense
of what programming using templates and
concepts is only going to be like when
C++ so X the next version of the C++
standard is actually here and finally
we're going to tell you where we are
with the formulation of concepts and the
standardization efforts that are going
on so we start with generic programming
generic programming is a methodology for
building software specifically it's a
methodology for building reusable
efficient software libraries we're very
focused on libraries we call them
generic libraries and there's three
primary tasks when you want to build a
new generic library the first task is
you want to categorize all of the
abstractions in your domain so if you
think of your domain as linear algebra
what are the abstractions in that domain
well we have matrices and we have
vectors now what we do is we describe
these in terms of concepts what concepts
do is they describe abstractions so
there are our core for reasoning about
entities within the domain
the next thing we do is we implement
generic algorithms based on these
concepts now the algorithms are generic
because they work with any data type so
long as that data type meets the
requirements of the concepts and finally
we build concrete models of these
concepts these concrete models are
essentially real data structures and
that meet all of the requirements of the
concepts and therefore can be used with
the generic algorithms so in a typical
library that's non generic you'll
typically have essentially the models
you'll have data structures and you have
algorithms that work on those data
structures in a generic library you have
a level of indirection between them that
is the concepts and that's where we get
the extensibility of a generic library
so there are several characteristics of
generic libraries that set them apart
from other non generic libraries the
first is that generic libraries are much
more reusable than non generic existing
software libraries so think about using
a library typically what you have to do
is you look at the library you
instantiate its data structure copy your
values into its data structure and then
run one of its algorithms on its data
structure with a generic library this is
not the process the process is you take
your data structure you map it into the
abstraction into the concepts described
by the generic library and then you
apply its generic algorithms directly to
your data types so generic library is
characterized by reuse of existing
user-defined data types within their
algorithms and their framework the
second characteristic of generic
libraries is that they're composable you
could take one generic library from here
perhaps for one domain and another
generic library maybe from another
domain maybe from the same domain and
you can map the abstractions of one over
to the abstractions of the other so
essentially you're taking two libraries
combining them together and you can use
them together in your program the idea
of generic programming is to make this
seamless so you can easily take
libraries from many sources and make
them work together efficiency is the
final point generic libraries are built
to be efficient efficient in this sense
means we want the performance of these
generic libraries to be
par with a hand-coded implementation for
a specific data structure if you use a
generic algorithm and it's the same
algorithm as a concrete algorithm that
generic algorithm should be as fast as
the hand code implementation the reason
is purely pragmatic if it's not as fast
as the hand code implementation people
continue to use their hand code
implementations we won't get the reuse
or the composability that you're narak
libraries are intended to provide so how
do we get to a generic library from
nothing or from an existing non-generic
library the way we do this is the
process called lifting and it's central
to the generic programming methodology
now it's an iterative process what we do
is we start with concrete
implementations say we have a handful of
quicksort implementations maybe one
source arrays of integers and the other
one sorts vectors of strings and there
are two different implementations but we
want to study these two implementations
and try to determine how can we unify
these implementations lift-away specific
requirements for instance that we need
an integer here or string here and try
to write something more abstract a
generic algorithm that covers the
behavior of these concrete algorithms by
placing fewer requirements on its input
parameters for example taking these two
sort algorithms why not write a sort
algorithm that works on arrays of any
type T so long as T actually has some
partial ordering on it that allows us to
sort now when we have these requirements
like T has a partial ordering on it we
bundle these requirements into concepts
these are the abstractions of our domain
that's how our domain works how we talk
about it now as I said lifting is an
iterative process we continue lifting
looking at generic algorithms looking at
concrete algorithms and building more
and more generic algorithms until we get
to something that essentially subsumes
the functionality of many many different
concrete implementations and in doing so
gives you the same performance back that
you would get from any of those
implementations when used with a
specific data type and finally there's
usually something beautiful in a in a
truly generic algorithm it fits with it
fits like the mathematical description
of an algorithm it says exactly what the
is but without tying down any of the
details that are there necessary to make
something you implementable in a
non-generic context but you can leave
them unspecified in generic context so
that the user can provide them when
using your generic library if you
recognize the picture of Plato it's
because we're all platonic idealist sit
in at our hearts and we're searching for
the higher truth and the beauty of the
abstraction in our generic libraries
still let's get a little bit more
concrete and talk about the C++ standard
template library now this is the first
generic library that really became
widespread in its acceptance so it
became part of the C++ standard in 1995
C++ standard was released later on and
what the standard template library did
better than other libraries is it built
three different kinds of components that
are all different kinds of abstractions
so we have the container abstractions
now the containers in the STL are of
course lists and decks and vectors and
maps and sets there are many different
containers all of which meet these
requirements of the container
abstractions there's also the algorithm
abstractions these are the generic
algorithms sorting algorithms searching
algorithms etc that are part of the
standard template library now the way
these containers and algorithms interact
is not directly we don't write a sort
algorithm on a vector instead we use
this in-between abstraction called an
iterator now an abstraction that the
iterator abstraction abstract away the
notion of walking through a sequence and
looking all the values in it so the
generic algorithms within the STL are
described in terms of iterators so they
work on any sequence of values the
containers in the STL provide iterators
that can be passed to the algorithms so
you can take any container and use it
with any algorithm in the STL and it
just works in addition you can create
your own containers meeting the
requirements of the STL and use those
with the STL algorithms or create your
own STL algorithms and run it on the
existing containers so we get a lot of
reuse by building these separate
abstractions particularly with the
iterator abstraction to abstract the
notion of data access now performance in
the STL has always been a
very large concern and so I was under
Stepanov built these abstraction penalty
benchmarks which are used to test
compilers to ensure that they're doing
the right optimization so that the
abstractions of the STL cost you nothing
in terms of runtime performance our
performance is key for generic
programming the abstraction penalty
benchmarks help us achieve that in the
world of C++ and because of the success
of the STL many libraries have followed
this generic programming paradigm in C++
and generic programming has been very
popular in C++ it's been very successful
the reason is that C++ templates are an
extremely powerful mechanism for
describing polymorphism for describing
abstractions now combined with
user-defined classes and overloading
that allows us to write generic
algorithms that can work on built-in
types just like they work on
user-defined types so it allows us to
build very very rich generic libraries
and many have been built you can go look
at on the web to find many of them one
of the keys that made templates work for
generic programming is the instantiation
mechanism when you use a template with a
specific type the compiler instantiates
that meaning it creates a new copy of
that template optimized specifically for
that type that's where you get your
performance that's why the STL actually
works now if the situation we're perfect
of course we wouldn't be talking about
extending as did c++ and there are
significant problems the first problem
is that we can't directly express the
ideas of generic programming we can
think about them we can write down
concepts in documentation in the
abstract sense but when it gets down to
C++ code we're essentially using
features and tricks of the template
system to make these things happen
there's a huge cognitive disconnect
there partially because of this and
because of the many template tricks that
have been found to help express generic
programs generic libraries written in
C++ are very fragile we won't actually
see what this means so here is a very
well relatively simple find algorithm
written in the style of the STL in C++
today so we have a template has two type
parameters input iterator and T now the
name input iterator tell
the human reader that well we want that
that type there to be an input iterator
it's a kind of abstraction in the sto
doesn't tell the compiler anything and
what happens is that the compiler will
look at this template and it'll accept
it and perhaps we're going to test this
template so we're going to call find
with a vector it works wonderful well
now we have using the iterator
abstraction we have a generic algorithm
and we can call it with the container of
our choice okay there's also a list type
and say we want to call find with a list
does it work well know from the
documentation it looks like it should
work because lists produce
bi-directional iterators bi-directional
iterators or input iterators and up here
at the top well it looks like it works
the problem however is here we have this
first is less than last terminating
condition uses less than operator that
works wonderfully for vector iterators
because they actually have a less than
operator that orders them however it
doesn't work so well for listed raters
which don't have a less than operator
and so what the user is going to get
back from making this mistake is an
error message that says in the
implementation of this find algorithm
you don't have a less than operator what
happened here well what happened is that
the person that wrote find was wrong he
should have used not equal instead of
less than that's fine but the error
wasn't caught until some unlucky user
tried to use it in a way that wasn't
this specific way that this algorithm
was tested that's the fragility problem
of C++ templates today for generic
programming there's no way to tell who's
accountable for an error is it the
person that wrote the template or the
person that used the template you don't
know because the error messages you get
back combine both contexts together so
the question is can we design better
support for generic programming in C++
extending templates to fix the fragility
problem to make it possible to describe
generic programs and generic libraries
the way we'd like to describe them using
the abstractions we think about but
without sacrificing any of the great
things the templates already do they
give high performance and they're
extremely flexible
so with this in mind we set out with
these specific goals we want to support
all of the ideas of generic programming
in C++ directly the way generic library
is documented we want to be able to
write that in actual code and have the
compiler help us out
second when we add this concepts feature
to C++ we want to get modular type
checking by that we mean that when you
actually write a template like the fine
template the compiler is going to do
complete type checking at the time that
you define that template to ensure that
things are correct with respect to the
requirements that the template if
there's a problem at that point the
author of the template should get an
error on the other side when a user uses
something like the find algorithm the
compiler should check do you meet the
requirements of this fine template do
you meet the requirements of this
generic algorithm and if so everything
should always work it should instantiate
properly you should get no horrible
error messages now if the user made a
mistake in the call they should get a
nice error message telling them that you
don't meet these certain requirements of
the generic algorithm please try again
when we make these changes to C++ we
need to keep the performance exactly
where it is C++ programmers are
accustomed to excellent performance from
C++ templates we can't change that
otherwise we're creating a performance
safety trade-off that never goes well
for programmers also backward
compatibility is a very strong
constraint
there's millions billions of lines of
code out there that use the C++ template
system just like it is
we can't change those we can't break
that code that's the easy backward
compatibility part the tougher part is
that there are a lot of generic
libraries out there that could benefit
from being evolved toward using this new
feature of concepts now if you evolve
these libraries those libraries change
that's fine
but we like all the code that uses those
libraries like the users of the standard
template library their code should
continue to work even if the underlying
generic library has changed that's a
much stronger backward compatibility
constraint now we're adding to C++ which
is a large language we're adding new
features and yet we want to make it
simpler
seems like a paradox how can you add
something and also make it simpler well
the reason we think that we can make it
simpler is that many of the ways that
people use templates now are tricks
they're complicated tricks you can't
even read them in a book in many cases
you have to go dig through news groups
to see how they work or go look at the
Boost C++ libraries to see what those
guys did right it's a lot of tricks it's
not really language knowledge its
language trick knowledge and that's why
templates are very hard to use right now
we're replacing a lot of those ideas
with new ideas based on the concept
system that you can express directly
what you mean
rather than fooling the system into
doing what you want so the end result
should be very simpler and much simpler
and when you're using templates you
won't need to know any of these tricks
anymore you just need to know the actual
language features that you want to use
the final goal is we don't want concepts
to be some academic idea that's played
with once and tossed away concepts are
intended to go into the upcoming ISS C++
standard they call it C++ Oh X because
it's supposed to be finished by the end
of this decade and it will be a major
new feature within the language so let's
move to the actual concepts themselves
so there's essentially three
interlocking features that define the
concepts extensions to C++ the first is
concept definitions so here we want to
state what is a concept and what are the
requirements that it places on its types
this allows us to describe the entities
in our domain that first part of writing
a generic library the second part is
where clauses but where clauses do is
they specify constraints on the template
parameters to a given template function
template for instance the find algorithm
had no description of what the the
actual type parameters need to do except
an ax documentation the names of those
parameters what you can do with concepts
is you can add a where clause it states
explicitly what those what concepts
those types need to meet for the
template to work properly
and finally there's concept Maps now
what concept maps do is they map the
real world of existing data structures
and built-in types into the domain of
concepts so you can state how you are
particular data structure meets the
requirements of a concept I will
actually start in the middle and take a
look at where clauses now today's
templates are essentially unconstrained
there are no constraints placed on the
template parameters so concepts
introduce a new kind of template called
a constrain template constrain template
is essentially a template like this min
here that has a where clause now here we
have essentially the simplest of generic
functions takes the minimum of two
values those values are of type T and T
can be anything so long as T meets the
requirements of the less than comparable
concept so we're less than comparable T
limits the applicability of this
template to types T such that they are
less than comparable once we have that
we've enabled modular type checking that
is the compiler is going to type check
the body of this function against the
where clause to make sure it will always
work properly and on the other hand when
a user calls into this function if they
try to give some function T that doesn't
have a less than operator the compiler
will reject the call to min and say you
don't need two less than comparable
concept so let's take a look at less
than comparable we've seen a generic
algorithm now we need to see is the
actual concept behind it so here's the
less than comparable concept declare it
with the concept keyword this is a new
kind of entity in C++ and less than
comparable has a single template type
parameter called T in the body of this
concept we list all of the syntactic and
semantic requirements that need to be
met for T to meet the requirements of
this less than comparable concept so for
T to be less than comparable on the
first line we have this operator less
than what the states is that there needs
to be a less than operator somewhere
that takes two T's whatever those T's
are and returns a boolean value the rest
of the constraints are semantic
constraints so here we state the axioms
irreflexive the asymmetry and
transitivity we say for instance for the
less than comparable concept to match
well X cannot be less than X that's a
basic property of less than comparable
and so within these concepts we state
all of the requirements that types need
to meet okay this is categorizing our
abstractions now there's other kinds of
requirements you can write for instance
you can write member function
requirements if you'd like to so here we
have a copy constructible concept if the
type T is copy constructible it should
match this concept and we can write
member requirements here that say T
needs to have a copy constructor written
this way the T colon colon T syntax and
it needs to have a destructor of course
you can write in other requirements for
member functions if you like or free
functions or operators essentially any
kind of functional requirement can be
described within a concept and these two
concepts have had a single type
parameter we've always called it T
however we can parameterize concepts on
many different parameters why not so
here we have an equality comparable
concept that's type a symmetric has two
type parameters T and u they can be the
same they can be different doesn't
matter and in the signatures we're
always comparing a T on the left-hand
side to you on the right-hand side and
of course the syntax of stand extends
naturally to any number of parameters so
does the semantics so let's take a look
at some more interesting concepts so the
iterator concepts are what really made
the standard template library a great
library so what we need to do is be able
to express those concepts in terms of
the concept mechanism now an iterator
abstracts the notion of iterating
through values of a sequence you usually
have to iterators begin in an end
iterator symbolized by these arrows on
the left left and right of the screen at
the bottom and the begin iterator points
to data and you can move it along in
steps the end iterator passed points one
past the end of the data this is how we
signify the end of a series and so what
are the operations we actually need to
be able to describe the abstraction of
an iterator well we have concept input
iterator has one type parameter we have
pre increment and post increment
operators in C++ we use plus plus to
move forward we describe those we need
equality and inequality so we can test
two iterators see if we
at the end of a sequence again these are
just signatures we write in the concept
body and finally we get to the
dereference operator the star like
dereferencing a pointer and we come to a
question what type is returned when we
dereference an iterator well it depends
on the iterator if it's a pointer into
an array of integers like this example
here well then the type that we return
is actually an int but we could also
have a list of floating-point numbers
and then the value type here the thing
that we return would be a float the way
we describe this in the concept system
is through what we call associated types
now these are essentially type
parameters that are nested in the body
of the concept so they vary as the
concept varies and so here we state that
every iterator so every type that meets
the input iterator requirements has a
value type associated with it and that's
the type that's going to be returned
from the dereference operator next step
there can be many associated types with
any given concept and so here we call
out one of the other common types which
is the difference type so there's this
pointer this iterator at the beginning
of our sequence and that iterator at the
end of the sequence how do we measure
the distance from one to another
well the difference type is an
associated type of iterators that allows
us to express this distance somehow we
don't know what the difference type is
it varies from one iterator to the next
if your iterator is just pointing into
an array well then it needs to be big
enough to represent the difference
between addresses in your machine if
it's pointing into some large file
system well maybe it needs to be a much
larger type what we do know about the
difference type of an iterator is that
it has to meet the requirements of the
signed integral concept so it needs to
be an integer like type that can be both
positive and negative so we can express
this within our concept mechanism via a
nested requirement which is a where
clause inside the body that states
essentially how these Associated types
need to behave armed with this we can
actually look back at a real generic
algorithm so we talked about find
earlier well let's look at a
it's implemented using the concepts
mechanism so again we've written a
template it looks mostly like an
existing C++ template where we have type
parameters inter and T we take in
several parameters we loop over all the
values searching for the value that the
user asked for so now we have this where
clause we say that the type itter
needs to meet the requirements of the
input iterator concept that's part one
that allows us to iterate over the
sequence part two is this equality
comparable concept we have this
expression star first equals equals
value so weird referencing the iterator
comparing that result against the value
of the user passed in so therefore what
we need is the value type of the
iterator written with this nested type
syntax here to be equality comparable
with the type T and given this
definition of course the compiler can
completely type check this separately
and we'll get better error messages out
of say this formulation then the first
formulation which didn't use any of
these templates
you do not need to say type name as I
mentioned simplicity and making things
easier that's one of the cases now the
reason you don't have to say type name
is because input iterators the concept
concepts aren't like classes and
specializations so inside a concept if
we say value type is a type it is always
a type input iterator of anything : :
value type is always a type compiler
knows that so you don't need the type
name keyword possibly not and I think
you highlighted my next move so ignore
the where clause and look at just the
code in the red box that's today's
templates this works alright this is the
code that you can go into your stay plus
plus standard library implementation
you'll find something that looks exactly
like this modulo naming and so part of
backward compatibility is isolating the
changes that we make so that for
instance this where clause which
describes all the requirements that
could be inside a macro of some sort
such that when the macro is one-way your
compiler supports concepts you use the
full concept based version if you have
an older compiler that doesn't support
concepts preprocessor strips it away
you get an old template that works as it
always did backward compatibility
important and by isolating things in
this manner keeping the where Clause
separate we can get better back with my
pad ability than we otherwise good
no it's not an error to use them
we're technique it's easier that way for
transitioning people that are used to
writing typing you in front of all these
types they even I write these type names
all the time and it's better for
backward compatibility also if you can
write that type name in there it's just
ignored yes you'll get an error message
when you write this template that says I
can't compare star first to a value
we'll see that a bit later in the talk
where we actually look at some error
messages from our implementation so the
last piece of the puzzle is the concept
Maps and for this let's consider a call
to find and we're going to call find
with integer pointers now for this call
to succeed we need to make the call and
then we need to know that integer
pointers are input iterators does the
compiler know this by itself maybe maybe
not the in essence it's going to be no
and so what we use is a concept map that
tells the compiler yes my type integer
pointer meets the requirements of the
input iterator concept the concept map
tells it that it does meet the
requirements the body of the concept map
tells how it meets those requirements so
in this case remember the input iterator
concept had value type and difference
type associated types and those differ
from one iterator to the next so we
state them as type desc inside the body
of the concept map we say for an integer
pointer the value type is int and the
difference type is pointer diff T now
the compiler knows how to make an
integer pointer into an infinite array
tur and the call to find up here are
constrained find will succeed now this
sounds very tedious what if you have
floating-point pointers do you have to
write another concept map well yes
but why not go for more abstraction why
not turn this into a concept map
template so any pointer to any type T
meets the requirements of the input
iterator concept the
now you type is T now because it depends
on what that template parameter is and
the difference type of course is still
pointed if T because that's how you
measure pointer differences the concept
the same thing as inside the vector
class template it should be then you
could put the definition of value type
inside the concept map itself sure yep
one of the the most important features
of concept maps and we'll see this a
little bit later is that you can write
them without changing the concept we
didn't touch the input iterator concept
and without changing the types we didn't
change built-in pointers because we
can't we'll see where that becomes
really important in a couple of slides
now back to building concepts we built
the input iterator concept but the
standard template library actually has a
rich hierarchy of concepts there are
many different kinds of concepts for
instance there's bi-directional
iterators that can move forward like an
input iterator actually they can do
everything an input iterator can they
can also move backward with a decrement
operator so to describe this we use
what's called concept refinement which
is essentially like inheritance of
concepts so here we can state that the
bi-directional iterator concept on a
single type parameter is an input
iterator
through this refinement syntax same as
C++ inheritance syntax except that it
has these extra operation operations it
has the pre incan pre-decrement and post
decrement requirements inside its body
so we write this little hierarchy in the
right-hand side because every
bi-directional iterator is an input
iterator and can be used as an input
iterator we can go even further of
course there's something called a random
access iterator in the standard template
library that can jump around you can
move an arbitrary number of step
in one constant time operation what does
random access iterator well it's a
bi-directional iterator again refinement
with other operations so here I've added
the operator plus that takes an iterator
adds some value some difference type
onto it to jump forward and then returns
the resulting iterator and now we've
built an interesting hierarchy of
concepts here where every random access
iterator is a bi-directional iterator is
an input iterator this allows us to
classify all the iterators in our domain
in different ways but they say they all
fit into the same conceptual hierarchy
now this refinement actually has some a
lot of power when it's combined with
overloading so here's the very simple
operation on iterators we want to take
an iterator X and move it forward and
steps how do we do that with an input
iterator well we write a slow linear
time loop that just steps through X
while decrementing the counter n very
simple but with the random access
iterator this of course isn't the best
approach random acts of siddha raters
have a better way to do this it's that
plus operation we saw as part of the
random access iterator concept so we can
write another advanced overloaded with
the first as the same signature except
this one takes a random access iterator
in not just an input iterator and here
in the body we just do 100 of one
operation that jumps the iterator
forward so what happens when we call
advance so say we have a call to advance
takes an integrator I and then some step
count and now if I is say a linked list
iterator there's only bi-directional we
look at the two advanced overloads we
see if the first one works every
bi-directional iterator is an input
iterator okay
the second one does not work a
bi-directional iterator is not random
access you can't jump around a list so
in this case only the first advance
overload works we pick that overload and
we get oh of endtime question
I'm sorry could you repeat that this is
a shortcut syntax that's very convenient
for a lot of short examples so saying
input iterator of itter here is exactly
identical to saying type name enter
where input iterator evader
now what if in this advance call we have
a vector iterator so I is a vector
iterator is that an input iterator
absolutely yes it is is it a random
access iterator yes it is so now both of
these advanced functions match how do we
pick the better one so concepts have
partial ordering rules that allow you to
choose the bottom the faster advance
over the top now why is the bottom one
better why is it more specialized than
the one on the top well remember every
random access iterator is an input
iterator but the converse is not true
therefore this algorithm works on more
specialized types random access
iterators than the top one it's
therefore preferable so when you call
this with a vector iterator you'll get
the fast o of one behavior
it's a possibility we have a syntax for
it sure there's other ways to I'm not
gonna go into them in depth but there
are other ways to help direct this so
that if you do have an overload set that
can be ambiguous you can help push the
compiler so there always does the right
thing you could do that what you do you
actually use the concept Maps feature
which we'll go into a little bit more
depth on concept Maps and you can state
that even though input iterator and
random access iterator are essentially
separate in that case because they came
in at different times maybe even from
different libraries you can still say
that every random access iterator is an
input iterator but the converse is not
true
I'll show you that well very soon but to
really talk about concept Maps we're
actually going to look at another
critical c++ o/x feature which is a for
each loop so one of the things that's
actually hard to do with STL containers
is just looping over the elements it's
not hard it's regular you always do the
same thing but it takes a lot of writing
you have to access the nested iterator
type so you have to call begin and end
and loop over these iterator loops what
you really want to do is just say for
every V in values do something right
simple interact a lot of other languages
have this and the key to writing this
feature to adding this feature into c++
o X is how do we make it work for all
the containers in the standard library
plus all the things that users come up
with that they actually want to iterate
over so Python has an answer to this
it's the iterator in container protocols
c-sharp hasn't answers to the
ienumerable interface and C++ so X with
concepts has an answer its concept maps
to see how this works let's look at the
underlying concept which is called for
for a for each loop so in this concept
we want to describe what it means to be
able to iterate over something that
something has type X so we have an
Associated type called iterator that is
an input iterator and now from the
container or whatever we're iterating
over we have begin and end functions
that return iterator to the beginning
and ending of that sequence very simple
now what's going to happen is this is a
concept divined by the C++ standard and
we're going to define a translation
semantics from a for each loop like this
down to an actual use of the for concept
to write the kind of loop that you're
more familiar with okay so here we take
just a loop over the vector of integers
called V and what we do is we go through
the four concept to access an iterator
for that vector pull out the beginning
and ending iterators and iterate over
those and then here's the body of the
users loop where we actually create the
variable I that the user asked for up
here and print out the value so this is
a simple translation semantics what it
does is it expresses this new for each
loop through the concepts mechanism so
that users can use errs and the library
can show tell the compiler how do you
iterate over certain things for example
let's do the rate over built in arrays
should be relatively easy right well
what do we do we need some Prime's which
is an integer array to meet the
requirements of the for concept we can
do this with a concept map template so
here we have a concept map for the for
concept it says that any array whose
element type is T and has n elements in
it meets the requirements of four and
here's how the iterator is a pointer to
T and the begin and end functions return
the beginning of the array and one past
the end of the array so just having this
concept map in here which hasn't changed
the concept at all hasn't changed the
built in array types at all makes it
possible to iterate over all built-in
arrays using this for each loop
you can't do the rate over a con Spectre
with this no we can map for here's for
non-convex so say we want a iterate over
vectors which is our original example we
write another concept map that says
vector of T is meets the requirements
the four concept the iterator that we
use is the vector iterator and the begin
and end functions in the concept map
forward through to the member functions
begin and end inside the vector again we
haven't changed the vector to do this
now if you'd like to do this for a const
vector instead of a non-convex er we
would have the four concept map on Const
vector of T we would pass in constant
vector of T references and to begin and
end and then the iterator specified here
would be the Const iterator of the
vector what's going on here is that the
concept map is intended it has to supply
all of the requirements of the concept
now the concept requires a associate err
type called iterator that is an input
iterator and so in the body of this
concept map you need to provide a type
for that iterator via type def now the
type can come from anywhere in this case
it comes from inside the vector because
your type definite from inside the
vector but it could be anything else
with the arrays we just said T pointer
is the is the iterator type
yes there are two namespaces each
concept is its own namespace essentially
and there their names within the concept
that are specific to that concept the
reason for this is there can be many
many concepts all using the same names
they need to be separate otherwise you
get interfaces tangling with each other
built into the language or it's in the
standard library absolutely okay so the
concept itself can be defined in the in
the language as an in the compiler or it
could be in the standard library now
once that concept is there the compiler
itself can of course look up that
concept and try to use it so where the
concept maps come in is that anyone this
would be the standard library could
introduce a concept map for that concept
because you're allowed to write concept
maps for whatever types whatever
concepts and types you want and it's
going to state that when you try to find
a way for an array to meet the
requirements of this four concept here's
how you do it
and it'll pick it up okay now there's
some facilities of the standard library
that aren't containers per se there are
algorithms for instance there's the
equal range algorithm on a multiset and
what that does is it searches for all of
the values that are equivalent so here
we're looking for all the values that
are equivalent to 17 in a multiset what
that's going to return is not a new
container but a pair of iterators the
first iterator points to the first value
that's equivalent
17 and the second iterator points one
past the last value that's equivalent to
17 so say we want to just print out all
the values that are equal to 17 right we
could do it with this loop however now
we need to be able to iterate over pairs
of iterators how do we do this well it's
of course a concept map so we want to
say that a pair of iterator where it er
is an input iterator it meets the
requirements of an input iterator you
can iterate over those the iterator type
def is actually it err itself and begin
an end we return the first and the
second inside that pair so this allows
us to iterate over essentially abstract
sequences into other containers
represented via pairs now going further
we have to write a lot of concept maps
for the standard library for instance we
want to be able to iterate over vectors
lists Dex maps sets multi maps multi
sets it goes on and on it's a little bit
tedious to write all of these for
concept maps but there's some
commonality between all of these
containers that we can exploit there's a
container concept already
it states what's the basic notion of a
container and part of the basic notion
of a container is that you can iterate
over the values right so here we're
going to write one very very general
concept map that says that any type C
can be used with the for each loop so
long as C meets the requirements of the
container concept already and then in
the body of this concept map of course
the iterator that we use to iterate over
the container comes from the container
itself the container concept and the
begin and end are going to pass through
to the member functions begin and end
for all of those containers so this one
concept map definition Maps anything
that is an STL container over into
something that can be iterated on with
this for each loop so we're mapping
essentially a full class of abstractions
over to another abstraction with one
concept map operation
okay I've talked a lot about the
standard library so the C++ standard
library especially the standard template
library was designed with generic
programming and concepts in mind they
were all there and then what happen is
they they essentially took those ideas
and wrote them in documentation and then
implemented using various template
tricks to get it to work
in C++ so what we need to do with the
standard template library is we need to
evolve it to use concepts so we're going
to take these informal specifications
that they wrote down the requirements on
concepts these are just documentation
today and turn them into real concepts
like the input iterator concept that we
saw earlier we also need to take the
templates of the standard like the
standard library such as the find
algorithm that we saw earlier
we need to give those constraints we
need to give them where clauses so
they're now within the template system
we get full type checking and we also
get more functionality so concept maps
give you functionality that we didn't
have before you can adapt syntax and say
that my type here meets the requirements
of this concept here through these
syntax tree mappings you couldn't do
that before so what happens when we
evolve the standard library is we get
the same library it's gonna work the
same way you'll use it the exact same
way except you have more functionality
you have better error messages it'll be
easier to extend and it'll be more sound
and better specified now backward
compatibility is a huge issue we're not
talking about creating a new standard
library we won't do that we're evolving
the standard library in place which
means existing programs have to still
work if they work with the standard
library today they should work with the
standard library tomorrow this is
particularly interesting when we're
talking about extensions so say someone
has created their own iterator types
there's a protocol for that in the
current standard template library we're
actually getting rid of that protocol
and replacing it with concepts is this
gonna break all of the code that does it
creates it's the own iterators no we
can't do this if we break code come
programmers will reject this so what we
do is we actually write concept maps and
they're a little bit convoluted but we
write concept maps that can take the
existing iterators either iterators that
work we
today's interfaces and seamlessly map
them over into the new concepts library
so what happens when you take your old
code and use it with a new concept
enhanced standard library is it's going
to be doing these mappings behind the
scenes that give you transition to the
to the new concepts based version let's
take a quick look at error messages
because this is a big issue for a lot of
programmers so here's a really trivial
bit of code that I absolutely love all
we want to do is call the sort algorithm
on list iterators so we want to sort a
list this way and the compiler helpfully
tells us that we've made some kind of
mistake
helpful right so this error message is
large that's the first thing you see and
that's a problem
because there's a lot to paw through if
I gave you an example from a more
advanced standard lot from a more
advanced generic library it wouldn't fit
on this screen it wouldn't fit in this
building so there's other problems in
here look at all these function names in
here it's double underscore insertions
or mm square final insertion sort the
user never called these directly these
are implementation details that are
leaking out to the user because of the
way the template mechanism works today
so if we back off and now use a
different compiler we're going to use
concept GCC which is our implementation
of the concepts mechanism in GCC with
its new standard library when you try to
make this call you're gonna get it get a
much friendly error message so this
error message is going to tell you at
the point where you made the call not in
the library implementation that there is
no sort that you can call with list
iterators
why is there no sort well there's a
candidate here there's the standard sort
that almost worked except there's no
concept map that makes a list iterator
into a mutable random access iterator in
other words you've failed the
requirements of this sort routine
therefore it's not going to try to
instantiate it it's not gonna let you
make this call if you can write a
concept map that makes a list iterator
into a mutable random access iterator
then it'll let you through
on the other side here's a simple count
algorithm and I'm going to make the same
mistake here that I made
time I'm gonna use less than to compare
iterators but these are input iterators
so it doesn't work now if there are no
where clause there are no constraints on
these then the compiler would accept
this and it would fail if you try to use
listed orators same problem we had at
the beginning of the talk now with
concept GCC we get full type checking of
the count algorithm when we define the
algorithm and what the compiler is going
to do here is when type checks it's
going to look for a less than operator
it takes two iterators first and last
it'll see wait there is no less than
operator defined in the input iterator
concept this is an error it'll produce
an error at this point now these two
sides the user side we saw first and and
the template author side that we saw
here that's modular type checking and
together they make templates much much
easier to use because you're getting the
full capabilities of the type checker as
soon as you write your template you
don't have to wait till later and test
with a huge number of types to make sure
that it's going to instantiate properly
where oh yes I do have a syntax error
there is a stray close as quickly my
apologies its historical so to wrap this
up concept is not the work of one person
it's the work of many people and you may
recognize some of the people up there
the two universities they're doing much
of the concepts work our Texas A&amp;amp;M
University and Indiana University and if
you're interested in concepts let's
bring this around to a summary what a
concept do they provide complete support
for generic programming all of the ideas
of generic programming can be expressed
directly in C++ when you're using
concepts and they're easier to use they
throw out a huge number of template
tricks that were used to used to playing
with in the C++ world you don't need
them
just express them directly using
concepts now if you want to try this out
if you're really interested in concepts
you want to try them I encourage you to
go get concept GCC here's the URL
there's binaries for several platforms
source code to the compiler whatever you
want to play with
and try the implementation it supports
almost the entirety of the proposal it
has a concept enhanced standard library
so you can see the error messages and
play around with concept maps and this
is all intended to go into the upcoming
ISO C++ standard just dub C++ so X so
the whole concepts feature concept maps
including the for each loop should all
be part of the next C++ standard along
with an upgraded standard template
library and we're hoping that this will
make generic programming more accessible
and more widely used thanks for your
attention
can I answer any questions Wow we'll go
this way yes yes yes a couple options so
one there is a default implementation
that you can put into your concept
that'll let you express not equals in
terms of equals the other option is that
there's this thing called standard
braille ops right horrible abomination
because it didn't work
it actually works with concepts because
you can constrain those operations
appropriately and not instantiate and
instantiate them when they won't work so
yeah there's multiple answers sure
yes
it's something that can be checked so it
describes the properties of these types
and there's a lot of ways you can use
them in compilers for instance you can
use them for optimization so if you know
the premise of the axiom is satisfied
well you can possibly do rewrites and
transforms on your system to use a more
optimal version you can use them for
verification if you have simple axioms
right the compiler might be able to
verify that yes indeed you do meet these
requirements the most interesting thing
I think is that you could use them for
testing if you've said that your type
meets the requirements of a concept and
there are axioms in that concept you can
treat the axioms like a verification
tester and if you can synthesize values
of that type you just send them through
essentially the assertions in the axiom
to make sure those axiom hold and you
can do spot checking and essentially
it's another form of unit tests they're
written in a very simplistic form it's
not C++ it's essentially just
expressions and if statements no no that
would be a mistake
very very simple just think if for
conditionals and equality statements
that's essentially all there is
so the concept masses you presented them
provide a good way of mapping like an
existing concrete definition like say
the existing vector yep and some some
sort of concept of the vector that holds
through the vector and the concept map
tells you how those back to each other
inner way to say write a new a new
vector or some other new class and
directly say at the time you write it
this implements these various concepts
and here's exactly how I've now my eyes
have got having to write both by by my
type name iterator inside the class and
then write also a concept map for my
classes as well my generator is this
iterator can I just say here is my
vector iterator in an ICU a terminus
yeah we don't have a special shortcut
syntax for doing that right now the way
tend to do things is we just write the
class and then following it rewriting
several concept maps to state what it
should do and in fact the concept maps
are fully type checked when you write
them so it'll verify that you actually
do meet the requirements of those
concepts I omit all these concepts
yeah it could provide some shortcut yeah
we don't have a syntax for it
essentially but the idea is sound I
think was there something back here nope
yeah go for it yes so we're doing a lot
more type checking when you look at a
template and today's template processing
is essentially a weak syntactic check it
doesn't do very much work now we're
doing full semantic checking that's
going to be more expensive now in our
prototype it's much more expensive
because we have a very poor
implementation of a certain feature of
concepts that slows down the compiler by
a factor of 10 we know how to fix this
we're working on fixing it of course we
haven't done it yet
so we expect there will be some impact
on compile time performance but you're
also going to be getting a huge
reduction in the amount of code that's
actually required to implement a
template library because all these
template tricks they take a lot of code
okay
thank you very much if you have any
other questions feel free to email me or
whatever
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>