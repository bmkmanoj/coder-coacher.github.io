<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Interface Grammars for Modular Software Verification | Coder Coacher - Coaching Coders</title><meta content="Interface Grammars for Modular Software Verification - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Interface Grammars for Modular Software Verification</b></h2><h5 class="post__date">2008-06-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ozUmWZdWBsk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so next we have a typical teen
from UCSB it's going to talk about
modular software verification so this
talk is about this work we have been
doing for modular verification as John
said and we use this interface grammars
basically it's a interface specification
language that we developed to achieve
modular verification so the talk is
based on these papers I'm not showing
these to advertise our papers well
actually partly I'm doing it to
advertise our papers but actually this
is mainly by Graham use my PhD students
so the work is based on its dissertation
you see he's the first daughter on all
these papers so hopefully he's going to
finish his dissertation this summer so
I'll talk about what interface grammars
are and give a case study verification
case study and then I'll talk about how
we applied this to verification of web
services client and server side
verification and I'll show another case
study about that so our motivating
problem is model checking software model
checking and model checking is an
automated software verification
technique right the basic idea is
exhaustive exploration of the state
space of the program so try to check all
possible behaviors of the program and
look for violations like assertion
violations or deadlines and there have
been some model checkers developed for
programming languages like C and Java
and very soft Java petfinder slam blast
CBM see so there are some model checkers
out there we used me in our studies we
use Java petfinder and we focused on
Java programs but the techniques we
developed could be adapt to other
software model checkers too so what is
the problem with model checking well
first of all it's a very ambitious thing
to do checking all possible behaviors of
a program is well impossible based on
some undies
I debility results but even if ubound
the state space to a finite state space
it's decidable but it's very hard
because state space includes everything
all the threads variables control stack
heap but so there are these tools out
there they try to do this right of
course they have a lot of techniques
that try to improve this you know state
space exploration and so therefore you
know it's not just a naive state space
exploration but still state space
explosion is a big problem so if you
number of variables or number of threads
increases performance of model checkers
get worse and worse right now my
regeneration is another problem so you
don't have access to all the components
of the software you are trying to check
probably okay and the simple thing is
there may be a user providing input and
so you have to model the users behavior
you have to provide some input to the
program right so that's the part of the
environment or this is a distributed
program and you are trying to check one
component it's interacting through the
network with some other component well
you have to somehow model this other
program that you're interacting with so
that's the environment again you have to
somehow model the environment of the
part that you are checking so these two
problems are actually related so to
fight state space explosion you want it
you want to do as modular verification
as possible you want to divide the
program two parts that you that our hand
that the model checker can handle
efficiently well if you want to do that
then you have to provide an environment
for those parts and therefore you need
environment generation so these things
are related and so one of the key
techniques people used over and over
again is modular verification right so
modularity is two key to scalability if
you can chop up a small piece of
software and just somehow focus on that
and try to verify that part then you
know hopefully you can do better rather
than trying to verify the whole system
together so so how can so another thing
is actually modularity
a key concept in software design right
so ideally you would like to exploit the
modularity in the program with your
verification tool so this is not I think
this is still a you know direction that
should be explored then I don't I don't
think we explored it as much so our kind
of this work was motivated with this
somehow you know use right interfaces to
show the motability in your software and
therefore use those to achieve model
verification so how to do model
verification well divide the software to
a set of modules check each module in
isolation so that's the basic idea right
it's a divide-and-conquer approach now
how do you isolate a module so you want
to write stubs for representing other
modules like you want to provide an
environment for the module that you are
focusing on so how do you write those
stops for the other modules that you are
not going to you know focus on right
interfaces and from those interfaces try
to generate these environment for a
module so try to generate environment of
the module you are checking using the
interfaces of the other modules okay so
that's the basic idea so from interfaces
you know generate the stub so what is
our approach the interface grammars that
we are working on so user basically it's
a semi-automated approach so we are not
trying to discover interfaces
automatically so we are saying okay here
is a way of writing interfaces use these
interface grammars to specify the
interface and we have an interface
compiler that's going to take this
interface specification and it's going
to generate some Java code which
actually is a stub that represents this
interface there is going to be some non
determinism in this stub actually so so
that's and so it's going to el oh you
know more behaviors than the module you
are replacing and this automatically
using this automatically generated stub
you know verify the component that you
want to focus on
so again Sen are used I want I have two
components may be and I want to check
component a okay so bright and interface
specification for that component be that
you don't want to check look so now we
take your the interface grammar that you
wrote we feed it to our interface
compiler which is going to generate a
stub for that component ok then we'll
check you'll use the model checker to
check this component a with the stub of
component be together so the state space
hopefully the state space of this thing
is smaller than the state space of the
full system with the full component
being right so that's the motivation now
so so that's the basic idea i'll give
you some examples of worry what's the
interface gram so and the way to think
about you can't think of this as yak for
writing interfaces so so you basically
write these contexts reproduction rules
describing your interface and then we
compile it to something that basically
behaves like that module that you wrote
interface for so i have a small example
here and we do it at the basically
method call level alright so it's like
at the api level so this is a very
simple interface grammar for
transactions and all it does is you want
to first get the begin call and then
each begin call is going to be followed
by either a commit or rollback and
that's all I want to see all right first
they begin then possibly a commit or
rollback then another begin anything and
he this would be the grammar for writing
that right it's a very simple
specification now method calls become
become the terminal symbols of the
interface grammar so we are recognizing
sequences of method calls alright so
here is you know if you get a call
sequence like begin rollback being in
comment this grammar should recognize it
and how do you check that well you can
show that there is a derivation you
start the start symbol
goes to non terminal base that goes to
based on that production goes to begin
tail base beginners the terminal it's
the method call and then that can tail
goes to rollback base goes to begin tail
base again and tail goes to comment
based coast epsilon and we have a parts
for the code sequence so this grammar
becomes the specification of the
interface now you can say well actually
this idea people have been doing this
for a while you use state machines
actually to specify interfaces like this
so the interface i showed you can be
also specified using a simple state
machine and this idea you know has been
used a lot in verification right so use
a state machine and it is a state
machine for that interface but with
grammars you can do more so if you have
if you had nested transactions where
basically you can nest within a
transaction another transaction then you
can't do it using state machines so but
you can still do it with grammar so this
would be the grammar for the nested
transactions and it allows basically you
to do begin and another begin and then
roll back maybe and then commit or
rollback know so you can nest the
transactions right and so now okay so
this is fine you can do some stuff using
just these context-free rules but
typically you know if you want to
generate stubs for some component things
are not that simple you'll need some you
know these method calls are going to
have some arguments they are going to
have some return values so how am I
going to specify that this is kind of
similar in yak right you don't only
specify a context-free grammar you also
specify some extra semantic actions
which actually do stuff when they you
know the production's are used so we
also allow semantic actions and semantic
predicates so assume that for nested
transactions I want to add set rollback
only method and when you call that all
the pending transactions have to be
rolled back
instead of comment okay so so I if by
call set roll back only after that I
only want to see you roll back I don't
want to see a comment until all the
nested transactions are completed okay
so how do you do that using the
interface grammar where we we add some
semantic predicates and semantic actions
so here what we edit is a flag r which
is basically indicating if the rollback
only status is set or not and l is the
level of nesting okay so i added two
variables now this is outside of the
context-free you know rules right it's
these variables that I edit and here
with semantic predicates and semantic
actions i'm actually checking or
updating the status of these variables
so for example this is a semantic
predicate it says here tail cannot go to
commit if R is false okay oh sorry so
pale cannot go to commit only if R is
false okay otherwise you can't go to
them so and then here for example I have
some semantic actions which actually set
here r is set to false here it's set to
level is set to 0 and when I begin a
transaction I increase the next level by
one and if you know I commit a complete
a transaction after the tail I decrease
the next nesting level by one and if the
nested level is 0 then I set reset the
rollback status to false if I see the
set rollback only call i set the
rollback status to true after that i
will own the yellow roll back okay so so
the moral of the story is we can do more
with grammars if we add these semantic
actions and we can actually even write
constraints about the arguments of the
method calls and we can say you know the
argument of comet has to be this and I
can put a semantic predicate that
expressing a constraint or I can
construct the return value and you know
return some result specified here so our
language basically supports semantic
actions and predicates and these are in
our language are actually is Java code
so you basically you can insert Java
code here for semantic predicates and
actions and you can do hello stuff so
what do we do with the interface grammar
we have an interface compiler so that's
the true actually we both write so it
takes the interface grammar takes this
language and generates a stub basically
that corresponds to a parser for that
grammar so and that is going to be the
stub for that component so just to show
the so visually this is what happened
what happens ok so I have a program this
is component hey let's say and then
there is a part of this this program
that I don't want to analyze ok that's
maybe outside the scope of my model
checker my model checker is not able to
handle certain things there or I just
want to do modular verification and so
what I'm going to do is I'm going to
write an interface grammar for that
component my interface compiler compiler
is going to generate a stub so this
thing is the stub and now program is
going to call this stub and that thing
is going to behave according to the
interface grammar and return values so
this stub is actually a parser so it
parses the incoming method calls based
on the interface Graham okay so and
semantics predicates and semantic
actions also construct return vs ok so
we did this and you know so other than
modularity I mean another motivation was
for example we were using jpf and JP f
for example cannot handle a native code
right so you have to write by hand
stubbs so we wanted to have a more
systematic way of doing this and so can
we kind of like what rather than writing
some Java code every time we want to
stop out something is there a more
systematic way of you know writing these
stubs so if you can kind of develop an
interface language that can be
translated to Stubb's that will be
helpful so we chose these grammars but
you know I the same idea can be used
with different languages right
so we did that case study using ejb
persistence API so this was basically
it's okay can we write meaningful
interfaces using this language so that
was we wanted to try that so so we wrote
a interface grammar for ejbs persistence
API right and so and then we wanted to
show that okay we can do some model
checking with this and the case that we
did actually we used the hibernate
hibernate test cases that are developed
to show that your ejb client you know
basically checks the high barnet
implementation by providing some clients
okay so and then it for example has some
error cases in it it's supposed to raise
an exception and that showing that you
know your implementation of the ejb API
is actually correct okay so we use those
clients to show that we can actually
stop out to complete ejb persistence api
implementation and do the client site
verification so what we are doing is
actually checking the client okay so if
you want to use jpf to check these
clients it doesn't work because you know
jpf is not going to be able to handle
ejv so you have to write stuff so we
write the interface compiler stubs are
generated automatically so now this is
there is many old part in this so you
have to write the interface grammar so
and then we didn't do any kind of
empirical evaluation of how much how
difficult that is but took Gram a couple
of hours to write it I mean part of our
motivation of for using interface
grammars is people are familiar with
this type of stuff you know people use
yak so so they should be able to write
these context-free rules and understand
what's going on of course you still have
to understand the interface so he had to
read the jb persistence api and under
what the constraints are but after you
learn that you know you should be able
to write interface grammar so then we
did verification with some of these
clients that were with the distribution
these are simple very simple pieces of
code ok so the verification time changes
from two seconds to you know whatever
around two seconds right and these were
very simple example so we try to
parameterize them so they do like one
operation and check if the return value
is correct right based on the api
specification so what we did is kind of
put these operations in a loop so that
you do multiple calls ok we also created
multiple objects and you know so we made
these simple examples parameterised and
then we try to check you know how does
the verification or falsification
performance change with respect to when
you increase the parameters you create
more objects or you loop more and
falsification performance doesn't change
so and this is not surprising for model
checkers right so if there is a bug you
find a bug you know you get do a
depth-first search and maybe if you turn
it more still you know if you are able
to find the shortest path not
necessarily shortest path by the path to
the bug increase in your state space and
doesn't necessarily change your time to
reach to the bug ok if you are doing
explicit state admiration and so in
these examples when we increase the
parameters if there is a error in the
client you still reach it pretty
efficiently okay in a couple of seconds
now however after you remove that error
okay so now you there is no error now to
verify the client you have to explore
the full state space and now you know
verification time increases with the
state space sighs and here so the
verification time increases I think
linearly with the number of objects and
quadratically with the number of
iterations which is actually each
duration the number of operation
increases quadratically with the number
of operations you do so so verification
time increases linear
with the number of operations you have
okay so so the point is ok so it goes to
a couple of minutes even for these
simple examples if you add loops
basically that's the moral of the story
here you know we have a Lupita at five
times but the point is we couldn't do
this with JP f before right so I mean
there was no way you could analyze the
full ejb now at least I have a way of
checking the clients ejb clients okay
and the falsification time is pretty
efficient which is what I said so now
there are some so this for this case
actually our initial setup was I will we
will have an interface for a component
that's actually called by some you know
the program and we will just generate
the stop for that component and we
restricted the case that there is no
call back from the component to the
color right so so that was our first
iteration then of course you may want to
generalize this you want to say okay I
want to handle call back so I call this
component I'm going to generate a stub
here but the component calls back so we
that is possible to do so we extend it
to that you can do that another thing
you may want to do I don't only want to
do client-side verification okay so I'm
calling a component and I'm going to
check the client so I'm generating this
stub for that component maybe I'm going
to do a server-side verification where i
generate the driver so so and so you may
want to using the same interface you may
want to generate two different things
between four different directions okay
so you do both client-side and
server-side verification okay and so we
also did this for web services that
aren't so talk about that a little bit
how many how many minutes do I have
15 min smart okay good so I can talk
about that partner so so the for the web
service is what we did is based on this
idea so basically there's a web service
provided right there is a wisdom
interface for this web service let's say
and I want to generate basically be
right this interface for the web service
using an interface grammar then our
interface compiler generates a stub for
that web service which I can use to
check my client right which is calling
the web service to make sure that's
passing you know appropriate arguments
or the operations are called in the
right order or I could generate a driver
to check the implementation of the
service make sure that you know my
understanding of the interface is
correct with respect to the
implementations that's out there because
maybe I misunderstood what I'm supposed
to do how am i how am I supposed to
interact with the service right so so so
at another part of this is actually that
I won't get into you can't throw in all
the data manipulation all the issues
about the arguments and data structures
to semantic actions and predicates ok so
the control flow the context-free syntax
doesn't show anything about the data
structure let's say so that's one way of
doing it ok do all the data checking or
data creation in semantic actions and
predicate predicates another way of
doing it is can you actually use these
recursive rules to somehow show the data
check the structure of the data or
construct the data and this can be done
so we have a paper on that too where we
use grammar productions to actually both
validate the structure of data and also
construct the data and so this is
basically can be done with recursive
data structures not all of them but you
know a lot of recursive data structures
can be done that way so so for the web
services so this is the scenario i was
describing we have a
service client which is making soap
requests to a web service which has a
wisdom interface okay and you know it's
getting so response so i want to check
the client and the server and i want to
make sure that you know they behave
according to the interface specification
so so we have two steps we have it's
against semi-automated so from wisdom
actually we take the with those
specification and generate some portion
of the interface grammar okay so that
portion is basically going to check for
example your argument types of your
arguments the xml you know data that you
send is correct with respect to the
wisdom specification so it's going to do
kind of like XML type checking okay so
that's one part but the wisdom itself
doesn't contain any control flow
constraints so you may have constraints
like you have to call operation one
before you call operation to and that's
not in the wisdom specification so that
you have to insert manually in your
interface grammar sophistication so
basically will automatically generate
some core interface grammar for you from
the wisdom and then you have to add more
stuff if you have more constraints okay
and then we'll generate the client and
the stub client and the server driver
clients the driver for the server and
the stuff for the client verification
alternative so again this is the
overview now of what's going on so you
take two with the specification we
generate the server interface grammar or
the client-side interface grammar you
add some control flow constraints and
the interface compiler is going to
convert it to either a stub for
client-side checking so this kind of
simulates the service behavior okay and
or a driver for server-side verification
now this is I mean so you know you
definitely have to do something like
this by hand if you are writing a client
for some web service right because you
don't want to keep connecting to do
by sending soap requests and testing
this thing just by connecting this a
real service so it would be first
probably you would do something you know
right to stop here to check that you
know things are working fine before you
connect the real service so we are doing
that semi-automatically basically so we
tested this approach using Amazon's
ecommerce web service so Amazon as a
bunch of web services so we check this
ecommerce one which basically lists
about 40 operations that amazon's amazon
provides to search their product
database okay and we focused on several
of those operations like items search
card create card add card modify my card
get card clear okay so there are
constraints on how you can call these
operations okay so that will be those
constraints will form the interface so
so for example you should not try to
insert an item to a shopping cart before
creating a shocker you know things like
that so there are some constraints right
so so we did basically we again wrote an
interface grammar part of it
automatically generated from wisdom
specification and then from this
interface Club grammar we generated a
stop for client-side verification so for
client verification what we did is
amazon has a demonstration client
showing that ok so if you want to
implement a client for our web service
here's how you would write it now this
client doesn't do any checking on the
request that's that are sent to to
Amazon okay so it's just for
demonstration so it has so if you want
to say so so if you implement this
client it's possible that you will send
weird requests to Amazon and you are
going to get some error message saying
that you know now you know whatever some
XML reports saying this is not doesn't
make sense something is null or whatever
so maybe a better thing to do at client
side make sure that you check what you
are sending is reasonable and if you
user request something weird like
deleting a card without creating one you
give an error message without sending
that to Amazon okay so then it would be
a reasonable thing to check if your
client whenever it connects amazon does
it send some reasonable request so
that's basically what we checked and for
this demonstration client there are lots
of errors because it doesn't check
anything so you easily find errors in it
but it still takes about ten two seconds
to 60 seconds depending on the type of
error you are looking for so we both
looked at like data or data you know
nonsensical data sent or control flow of
errors ok so then server verification
was basically a I'm running out of time
I think but so server-side verification
was checking the Amazon service
implementation that's out there right
with respect to our interface grammar
and basically with respect to our
understanding of the interface ok and to
do that basically now rather than
parsing the method calls or the soap
requests what we are doing is actually
generating sequences of calls based on
the grammar ok so now we are actually
doing census generation rather than
parsing ok so we did two types of census
generation one completely random so you
know randomly pick productions and
generate code sequences the other one
have a coverage criteria and try to
generate sentences for that coverage and
the coverage criteria we picked was
production coverage so I have a grammar
I want to make sure that the sentences i
generate at least use each production at
least once ok so and so for this
directed Santa's generation we use
something called Portland's algorithm by
perdon and it generates five call
sequences it covers all the productions
we had average derivation length
basically average call sequence is 24
operations so it basically makes 24 soap
request to Amazon and five of those and
okay sorry sorry that was the derivation
like that's the derivation like actual
average number of course to soap is
about four
calls per sentence okay and so if you
generate these five sentences and make
these calls to Amazon you would it takes
about 20 seconds to check you know see
what happened we also did randomly so
randomly you know you're generating
sentences randomly so we generated up
200 sentences okay so and then of course
you know you generate more call
sequences your cost increases pretty
much linearly you know how many times
you execute this thing and 400 call
sequences we get about 300 seconds to
check these are seconds and in terms of
you know production coverage if you want
to look at this production coverage as a
criteria after about I think 40 or so
sentences even random generation gets
full production coverage with other
algorithm you just need to generate five
sentences because tries to get
production coverage so we found two
errors now errors this doesn't mean that
the Amazon sir web service
implementation has a bug it means that
there's a mismatch between our
understanding of what it's supposed to
do and the implementation so our
understanding was based on you know the
specification to be read so so you know
so this is what you want to find right i
mean it means if you are writing a
client if you misunderstood it you will
have a bug so it doesn't matter I mean
so you need to understand exactly what
they are doing so so this is a way of
resolving that right so to conclude I
think so ok so I really believe that
modular verification is the key if you
want to do automated verification and so
yeah oh so what word bugs so the bugs
one was so one was basically i think a
container that has a container in it
okay so there's a list within a list and
what happens if the list between a list
is empty is the other you know the
containing list empty or or not you know
so the outside list does it contain one
element
which is a list or is it an empty list
and so there was a misunderstanding cook
on you know what they had implemented
and what we thought would we would get
right so it's a very corner case so that
was one of them and the other one was
actually I think relates to control that
you can't keep adding you can't have
multiple ads with the same item number
or something like that I am not so I am
100-percent sure but it's in the papers
so there it was again some you know that
was more about operation that yeah so so
motor verification I believe is the key
to you know efficient verification and I
think this idea of using interfaces to
generate you know yeah i mean this idea
has been around you know you you do
modular verification and you specify
interfaces and so interface grammars is
a new way of looking at it and most i
mean there's a lot of work using finite
state machines to kind of specify the
interaction behavior so this is a
different way of looking at it and i
think that so there's a lot of things
that can be done one thing is we didn't
you know we generate these stubs but we
didn't looked algorithmically like what
are there more efficient verification
strategies now that i know i'm going to
generate a stub which is going to be
actually a parcel are there classes of
grammars where verification can be done
more efficiently so I mean there are all
sorts of model checking issues that can
be investigated but so so far what we
have is an interface compiler and to
generate you a Java code you know from
the given interface grammar okay
um I wonder what is your model of
concurrency in that so I assume your
your model is one-to-one relationship
between a calling object and a serve
object so if there are multiple objects
calling a single server object what what
what happens yeah we didn't we didn't
handle concurrency at all thanks for the
question so concurrency we didn't handle
at all and I mean so we looked at it
it's yeah it gets very tricky actually
so the most general thing we have now
actually it's there's one object and
then other object and that so that's the
interaction between those two for wisdom
with the web service stuff you know so
that's that you know what we have this
structure works but yeah I mean
concurrency is a issue to be hard 10 but
I mean it you have to extend the
language basically but yeah yeah so why
the hell did you use these old-fashioned
grammars why didn't you provide the user
with the interface to build an hour
Tomata and there I do all this
specification stuff which would be a
sing easier to access so an average user
sir okay so I don't you know so this
automata use automata so how do you I
mean writing state machines I argue that
actually writing it as a grammar is
easier I mean automata what are you
going to write you are going to write
transitions right I mean it's nice for
it could have a visual aid yeah I could
have an editor for that exactly right so
it looks good on visual tools it looks
good on papers the automata but you know
most people still develop software
without visual aid I mean so so this
would be it yeah I'm so I mean I did so
I think it's a different style I think I
think it has benefits you don't need a
visual aid but if you're right i miss
automata is another way of doing it and
but so technically i could always say
this is more expressive perhaps is the
complement to the concurrent client
question but a bunch of servers are sort
of products of little servers or you
might just say
a dispatcher dispatching to a couple
services and in that sense you can
interleave you know transactions with
all these other services is there a way
of easily saying that a service is a
product or a discriminated product of
other services that's the interleaving
of them and would that simplify some big
complex api's so yeah we didn't look at
composition of services and kind of we
looked at just wisdom now one could
think of you know what you maybe you
have like a Bibble specification which
come composes some other you know
services and can you what would it mean
to generate some you know interface for
that so we don't look at that but for
the with the interface grammars but so
yeah that would be something and so if
you have actions the general question
would be I have a bunch of interface
grammars and they're not showing
different components so now i want to
check different components and how do
they compose so we didn't look at that
so we are really at the you know so
beginning of this where you know one
client one server but yeah that that's
definitely in addition to concurrency
there's another thing that I mean if you
even if you just add a sequential
program how do you compose interfaces
have a question have you looked at Jay
mark and easy mark so that you know they
they let you basically they'll create
like an abstract subclass or an
anonymous subclass and let you attach
expectations to it they its kind of
grammar like in the way you could you
know no you know I didn't know should we
shoot okay yeah I don't need I don't
know what's behind the implementation
but there might be some kind of parser
in there right right yeah thanks I never
quite understood I mean Java pathfinder
that's an explicit state model checker
right and I all my intuition is always
say horrible for modular verification so
let's say you have a function X plus 1
right and for java pathfinder it's much
cheaper to do to execute the function
and do x plus 1 then you know any
obstruction of fool you're going to come
up here so it's going to be slower so i
can see like for you know ebj once you
remove
you know lots of lines of code and you
have a narrow channel then you introduce
obstruction it's still going to be okay
but you know if you have a non-trivial
client and you want to do keep in a
modularity you know create smaller and
smaller modules at some points explicit
statement ecker is going to be
completely useless or your obstructions
going to be completely useless I think
that so there are two answers to that
one easy answer jpf does not handle
native code so we I mean you have to do
this so forget about modularization if
you do some network communication you
don't have you may not have access to
the implementation of that other
component so you have to do something
that's the easy answer now the more
difficult answer is yeah there is this
thing about non determinism vs the size
of each state that you have to store now
because if you add more components maybe
you are going to reduce the non
determinism but now the state
description is going to get bigger and
bigger right because I have to store all
the this other component that I removed
so where is the you know that threshold
between you you reduce the state space
so much that actually non determinism is
not hurting you now because you removed
a lot of state information about that
other component so your state
description is much smaller although you
may be visiting more states right so
that actually yeah I mean that's a
that's an issue that I mean for the
examples we had there was no other way
of doing it so but the efficiency issue
is a good issue to investigate them so
where is the where is this threshold and
so so 14 year so we didn't want we
didn't do this just for JP if I mean jpf
was out there and it had this native
called problem so it was a natural mad
but the way we think about it is
basically we provide an interface there
is some non determinism in it you hooked
that non determinism to your model
checker I don't care what your model
checker is I don't know if it's symbolic
bonded whatever you know now you can you
know check this simple let's check this
simple system modularly so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>