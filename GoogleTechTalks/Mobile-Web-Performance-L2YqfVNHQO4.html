<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mobile Web Performance | Coder Coacher - Coaching Coders</title><meta content="Mobile Web Performance - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mobile Web Performance</b></h2><h5 class="post__date">2011-12-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L2YqfVNHQO4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a guy poke poor Johnny he's a CTO and
co-founder of blaze and he's also the
creator of Moby test which is a mobile
performance measurement tool and he's
also contributed to HTTP archive mobile
and he also helped works with the
pattern web page test he's a researcher
of mobile web performance optimizations
maintains a blaze blog which is almost
like the Khan Academy for performance
optimization where yeah that's white
boarding and explains concepts and he's
a frequent presenter in security and
performance conferences and events his
freighter ID is guy pod that's it and he
is a google plus account and you can see
that guy PO has been working on laptops
from a very early age almost two years
old so so here's a guy / so everybody
thanks Frank you for the the intro so
yeah the picture is uh my son two years
old enjoying my laptop in the Google
profile so I'm here to talk to you a
little bit today about mobile web
performance and and basically what we'll
do is all I'll give a brief intro I
think it's probably preaching to the
choir but I'll give a brief intro but
why speed matters and about my why
mobile web performance matters and then
I'll dig into our view of mobile web
performance or my view how do how to
split mobile web performance into the
different aspect the different
attributes of what mobile is and then
how what are the performance
implications of each of those and what
can you do about it and of course then
we'll summarize and open for question so
where I'm curity did a lot of this intro
so I'm the CTO of blaze we in a sense we
try to save you the needs to know any of
this by automatically making your site
fast by applying a variety of these
optimizations work on Moby test which is
a today probably the only one way to
measure page load performance in a kind
of reliable manner on mobile devices and
iphone and android on recently on
blackberry and and yeah in my spare time
such a thing exists I kind of research
blogs and try to take advantage of sort
of those two tools from the different
aspects the ability to manipulate
websites and the ability to measure
performance to try and reach conclusions
and understand what makes sites faster
versus what makes sites well it doesn't
so on to this is just the kind of ground
setting I think probably everybody here
I'm going to be using waterfall charts
through this presentation a little bit
to explain what is what is the effect of
some of these optimizations so you're
probably all familiar with it but
basically quick intro is just waterfall
charts show visualizes the load of a
page each line represents a resource our
request being made within the page and a
response and the two lines that i will
be talking about is page load time which
the generic sense is when the browser
decides the page is fully loaded
document completed sort of the load
event where the browser stops showing
any progress indicators and the start
render time the point in which a user
stop staring at a blank screen and
something starts getting painted for it
so I'll just be using this through this
presentation so a little bit about why
why are we spending the cycles so in
general users expect fast sites right
Google is probably one of the bit bigger
if not the biggest advocate of this this
is one chart from an act my study
there's many others that show the
majority of users are looking for
websites to load in about two seconds
three seconds at most and and they sort
of they have that high expectation that
a fast expectation but the website
loading if they don't get it they go
away they abandon the abandon the site
they go to a competitor's site or a
different site the best illustration of
that that I can think of from my use
cases when I google something up and I
click the first result and if that first
result doesn't respond certain amount of
time I do back and I choose the second
result and and I think that materializes
in many ways when you browse around the
web so the longer your delay the higher
the abandonment rate again that has been
demonstrated in a variety of status I
think this data is based on Forrester I
was published by KISSmetrics
if you do give them the fast site they
reciprocate by giving you better
business and this is a study from ship
Zilla there's a variety of those or if
you improve the site pretty much any
aspect of the business would improve
from conversion rate to repeat views etc
and as well as a fast tight tends to be
a leaner site and therefore makes better
use of your your infrastructure uptime
is better your costs are lower etc so
switching a little bit to mobile a
parallel trend is mobile browsing mobile
is clearly growing within a mobile
browsing these are some big examples
were you know on Facebook their mobile
site accounts for nineteen percent of
the traffic on Twitter fourteen percent
financial time just sort of data they
abandoned apps and they created an html5
web site and they have 700,000 active
users on it so there's a lot of
different indicators show how mobile
browsing is growing and and the mobile
the users are not really cutting a slack
for the fact that it's mobile they're
expecting similar performance 22 on
mobile to what they get on desktop this
is a study by Gomez and what it does is
it demonstrate they asked users it's the
flip question and say no do you expect
your desktop de performance to be better
or worse than your mobile performance
and you know in a nutshell the majority
of users the vast majority of users
expect websites to perform equally or
better on their mobile phones than they
do on their desktops so so basically we
have that expectation that expectation
is growing and again the best
illustration of that is your iPad on a
Wi-Fi network right you're browsing
you're staying at home you're opening
your iPad you want to browse the web
there's no really the expectation is
that the browsing experience would be
equally good if not better to that that
you would get on on your desktop or your
laptop and once again if you don't do it
they would abandon the site and and the
numbers are similar sometimes they might
give you this is not exactly consistent
with the previous data maybe they give
you a second more
but generally they would expect those
fast sites so so we we aimed make sites
faster and we need to make mobile
websites faster and the reason is
basically helped the bottom line when we
talk about performance there's a variety
of components to a performance of a web
page loosely speaking we're splitting
that up into front end and back in time
a little bit simplistic we're back end
is the generation of the web page the
HTML page so that includes the load
balancers the database access getting
the HTML page generating that and
sending that down and the front and is
everything that happens after which
primarily talks about network time and
about browser time the processing time
the networking time so today I'll be
talking about front and performance and
how to accelerate that and that is also
specific to it depends on the mobile
components more than the back end which
is the same for mobile and desktop okay
with all that intro it's just background
to be you know why are we here why are
we spending time on this into a little
bit about what is mobile so what is
mobile is pretty kind of philosophical
question or I know I philosophical that
a hard question specifically for
performance I find the best way to split
mobile app is to talk about the mobile
network mobile hardware and mobile
software that helps address questions
like know is a laptop with the rocket
stick is that mobile is an iPad on a
Wi-Fi network mobile and the answer is
each of them represents an aspect of
mobile some of the mobile software some
of them were well hardware and some of
them a mobile network and each one of
those comes with its own baggage it's
own performance implications and
basically through this presentation
we'll talk a little bit about each of
those components and and what it means
for performance feel free to interrupt
me with questions through through the
process you know no need to sort of wait
for the QA we can have the longer
conversations at the Q&amp;amp;A section okay so
all of that is is just background now
digging into them the meet start with
mobile networks so the problem with
mobile networks is they're slow
when you compare stats about download
speeds about upload speeds of mobile
networks they arrange mobile is very
inconsistent but they range between nine
times slower five times slower they're
very very variable if you're going to be
browsing in the middle of the day when
you're standing by the antenna versus
you know out in the country or or at
night time from your home numbers vary a
lot but while download speeds and upload
speeds are much slower they even bigger
killer and mobile networks is latency so
on your desktop connection on your
broadband you would expect latency is on
20 milliseconds of 30 milliseconds the
time it takes data to go to the server
and back or let's get to the web and
back so you'd expect very very very
quick connections on mobile if you get a
hundred if you get 150 you're in pretty
good shape and if you are looking at
averages that the variability is very
very great some measurements we've done
as well as some studies we found about
this trying to average across different
webs talk about a 300 millisecond
average latency and that's slow and it
means every time you do an interaction
every time you try to talk to a server
you send a request to try to get a
response there's a lot of overhead
there's a lot of slowness so it's
probably the most important attribute of
the mobile networks is that they're slow
and that they have that high latency so
looking at what you can do about it and
in general this is the format we're
going to be doing talking about a
problem than talking about solutions the
the primaries things that you can do
about it is you can reduce requests why
reduce requests first of all logically
if the cost of an interaction with the
web server is is higher every time you
make a request then you get a response
you need to pay a third of a second just
to make that interaction it matters and
it slows you down so reducing those
interactions accelerates your site the
kind of more mathematical reason is
we've we've tried to assess a variety of
devices and try to we measured I think
this was on a fortune 500 websites but
it doesn't really matter it's a set of
500 random websites
and try to see which variable within the
page correlated the most to load time
and across these devices the mobile
devices the number one correlating
factor was the number of requests so the
first one is a little bit more of a
logical understanding and the second is
is a more maybe statistical analysis and
of course there's a lot of different
ways you can measure but both can lead
you to the same conclusion of reducing
the number of requests being the number
one thing you want to do to reduce the
page load time and and of course the the
second thing you want to do which is a
little bit more intuitive is reduced
bites right if you need to download a
megabyte it's going to take you less
more time than if you need to download
100k that's it's a little bit more
intuitive yep with LTE and and those
components well so so the question is
whether you expect we expect latency
whether we expect the latency problem to
be temporary or whether we expect that
as cellular technologies improve it'll
go away and I guess there's no I don't
have a crystal ball but some initial
studies on LTE show that the latency is
still significantly higher on LTE than
it is on the broadband environments so I
think the gap would always exist and
it's also logical there's more
interference and there's you can only
optimize the communication channel so
much as compared to broadband so they
will improve but they would probably
still when you talk about mobile versus
desktop and the mobile network versus
broadband the gap would probably persist
yep
well so this is a the question is
whether why is the bar low on the Nexus
and on the Android devices for the
number of bytes why do they not
correlate so i don't i don't have sort
of an exact answer this is sort of the
the results that we got our
interpretation of it was that it's
there's other variables these are the
variables that correlate the most the
most page load time so that if there are
other components or other reasons that
would drown out the the correlation that
that would there's a relationship
between the bars is what I'm trying to
say is that if they if one component
drives page load time more or enough
then the other components would would
not contribute to pedro time above and
beyond it too much so we did so so i
will kind of caveat this a little bit
that this is about four or five months
old and we did constantly improve the
measurement technology so there it's
also possible there are kind of some
tweaks in the data that can still be
improved so let's see a visual about
this now generally when they give this
presentation i choose the customer in
question or the company in question that
may present at to demonstrate this I
gotta say that on the google website say
i couldn't apply this optimization and
get this effect but this is an example
on the walmart website where i applied a
single optimization called on-demand
images or just in time images which
makes images on the page only load as
they scroll into view so this is a good
optimization that basically in one
stroke reduces both the number of
requests and the number of bytes and the
images that are below the fold do not
get loaded until they actually scroll
into view so on the walmart website and
this is a mobile site this is just kind
of an apparel section you can see that
that took us down from it's kind of hard
to see here from about 330 k to about
220 so it cut down about a third of the
number of of the amount of bytes and
also about a third of the number of
requests and when you look at the effect
that had on the visual it was dramatic I
probably should have put the waterfall
charts here but what happens is all of
those images were downloaded in parallel
so because we cut down a lot of those
image requests the bandwidth was used
entirely for those images that are above
the fold they weren't contending for
that download speed for those
environments and they downloaded the
data much faster so this is we ran
multiple measurements and we pretty much
consistently got those numbers these are
two second intervals so basically go
from about four seconds to about and as
that eight or ten seconds that the page
is loaded i granted when the user is
going to scroll down then the images
would need to be fetched and if you want
you can proactively fetch them after the
own load but you focus your attention to
only loading things that are within view
in the initial page load so and it did a
dramatic effect this is the same data on
MSNBC it's just to say you know this
spans a variety of different websites
ecommerce mobile so same thing went from
a but saved about 15 out of 43 requests
reduced but about a third this is
consistent with dads would see on a lot
of different mobile websites and once
again shave it a lot of the time as well
so that's it about slowness the other
aspect of mobile network is low slowness
wasn't bad enough is that are unreliable
packet loss is very high that one is
incredibly variable it's really hard to
give a stat of the average you know when
you're sitting when you're getting out
of a subway and you have four bars on
your phone and you still can't getting
anything done that's usually packet loss
in play there's everybody who's using it
at the same time there's a lot of noise
the capacity that the channels are being
maintained well and packets get dropped
so you just can't get anything to
actually complete the transactions so it
goes from very very low packet rate if
you're you know in a good reception area
at night time to terrible packet loss in
other environments the impact of that to
performance is that you need to think
about that no resource is safe at any
point in time any resource any file on
the page may get delayed may suddenly
take a long time because packets got
dropped and it takes a while to do that
iteration so so you can
I on a sort of fixed amount of
throughput nor speed so the best
solution we have for that is to
eliminate the single points of failure
as much as you can you want to make all
the parts of the page as independent of
each other as possible so that one would
not delay or block another and this way
you're reducing your you're addressing
this problem a little bit so that at the
very least if one resource got delayed
it would not hold back another resource
this is also good for latency because if
you're doing more things in parallel
you're not blocking one resource on the
other you're also helping accelerate the
site in a high latency environment for
sure yes so if you so the question is in
a wooden doesn't this collide with the
notion of reducing the number of
requests and you know it does to a
certain extent and just two other
extends it doesn't so there's there is
always a trade-off if you combined a lot
of different files and you download them
as one request for instance then you're
you're making that file more single
point of failure versus reducing the
number of requests you probably need to
measure and to test what is the right
thing on your site but the the primary
thing is try to make each one of these
files after you've reduced like what I
would we do and what I would recommend
is once you've reduced the number of
requests try to make those requests that
remained on the page as independent of
each other as possible so you let me
give a couple of examples so when you
look at a web page today the single
points of failure are primarily scripts
and CSS files these are the files on in
a browser in general and specifically on
a mobile browser that would block
downloading of other resources they
would keep the browser from doing
anything else with the rest of the page
until that content got downloaded until
the description CSS files completed
iframes and fonts in various settings
are also blockers single point of
failure might be the right point maybe
where it is blocking resources by the
way those are resources that would delay
other resources until they get
downloaded nothing else does so so this
solution or the way to address this
above and beyond interesting request did
you just make them not block you can use
asynchronous JavaScript to make scripts
download without blocking other
resources so download them and execute
them with your own in line simple inline
scripts without blocking other resources
on the page so not the naive script
source links you can do a similar thing
with CSS where you can make the body
visit set the body to visibility none if
you don't want kind of unstyled content
to show up download the different CSS
files and once you got all the CSS files
turn the body visible but in both of
those cases you haven't really
accelerated the scripts or the CSS files
themselves but you kept them from
delaying other resources so here's
here's a visual it's a little bit hard
to see the page on the New York Times
website on what async JavaScript loan
does for the initial render time talking
about those single points of failure so
what this does is we I've only applied
asynchronous JavaScript to this page so
JavaScript and scripts are not blocking
the rest of the content on the page and
while the load time at the end is the
same this is about 12 seconds the load
time is the same for both cases the user
experience is drastically different in
the first experience the script get
download it's hard to see but there's a
little bit of text over here at the top
and then there's a script that generates
a couple of ads here at the top so they
get downloaded after and then a script
is going off and it's fetching another
piece of ad that's showing up here and
kind of render over here so every one of
those scripts delays the rendering
delays the downloading of the resource
the user experience is that much worse
instead of at around four seconds
getting the bulk of the page and then
getting the data filled up and when you
look at kind of a snapshot of the film
strip oh sorry of the waterfall chart
you can basically see these stairs these
blockers that every time download or
block other resources yep
yeah so the question is how does this
get affected by caching I mean what if
what if is the situation in the real
world that a lot of these resources are
cached and therefore maybe it's not a
big deal or the the impact is not as
drastic i have a whole slide about
mobile cache sizes which is a whole pain
point by itself so i don't know if on
mobile the expectation that they will be
cached is better but also if you make
scripts asynchronous you're not really
getting in the way of caching you're
still going to take advantage of caching
so maybe you're not optimized maybe
there are scenarios in which this is not
a problem but there are many scenarios
where it is a problem and will get
optimized yeah yeah so this is this is a
in this case it's hard to give an exact
example of a packet loss packet loss is
random this it this is actually
demonstrates the latency impact maybe or
the just blocking effect of the of the
resources or your downloading more in
parallel as opposed to packet loss but
it's the same effect that could happen
if scripts got delayed I guess my point
is that if scripts got delayed they
would push off any rendering on the page
while if you used asynchronous
JavaScript if a script got delayed the
the bulk of the page would still be
rendered correct yeah if one of those
scripts suddenly act up and gets delayed
yep
this yes so this is a real measurement
from an iphone yeah and iphone indeed
supports up to six connections per
domain enough to I think in the latest
one it's up to almost I got it to do at
least 60 connections in parallel so it
required it makes a lot of requests in
parallel so I know that Android limits
the number of connections more and it's
true that if the number of connections
becomes the bottleneck you've got a
different problem as opposed to making
things asynchronous so that one was a
specific example just to kind of do a
bit a bit bigger of a bigger example we
tried to uh I grabbed the top 10 mobile
news sites and just ran the same
experiment on them rounding asynchronous
JavaScript looked at at the start render
time and this sort of a similar take on
the same bit of info as you increase the
latency and this was us simulating
latency so again a little bit more
latency than single point of failure but
it's the same the same notion it's in
problem the start render doesn't get
very affected if you're making scripts
asynchronous if they're not blocking the
entire rendering because of those
scripts that need to get fetched and
performed and executed so that's not
that's probably the the other aspect or
the second aspect of mobile networks now
this applies not just for mobile devices
right this is also for your laptop
browsing over a rocket stick last thing
I'll talk about is the mobile about
noble networks is the non-persistent
channel so mobile networks have a
limited amount of spectrum mobile
devices have a living out of power those
components combined make mobile devices
mobile clients and mobile cell towers
not maintain a constant communication
channel if you're picking up your phone
out of your pocket and you create a new
connection a new connection is getting
established to the cell tower just to
get a single bite through and that has a
toll that takes a couple of seconds to
to set up
and if you were scrolling the page and
and read it for you know 10 20 seconds
you weren't really invoking any
additional network activity then that
connection would get dropped maybe going
to half power first and then an entire
power so when you're going to click the
next link on that page same thing is
going to happen it's going to need to
re-establish that connection so so
that's a behavior that sort of needed in
a mass environment you as a website
owner don't really have much to do about
this when somebody just picked up their
phone and loaded the first page but what
you can do is you can try and maintain
that connection alive as the user
browses the site before they're going to
click the stitute to accelerate the next
click they're going to do so if you are
browsing the page and you're going to
click another link you save the user a
second or two once they click that link
from loading if you maintained the
channel communication alive this is a
little bit of a kind of a bad network
citizen type of behavior it means that
you're going to do an ajax dummy request
that's going to run every couple of
seconds to the cell tower and just get
like a 1 pixel bogus response and all
you're doing is you're maintaining that
communication channel alive to the cell
tower and it's a little bit of a gray
area you're kind of cheating you know
like with the TCP fast start right
everybody's concerned about if everybody
does this would be the internet meltdown
right same thing here my view on it is
it's not a big deal is compared to video
streaming as I've compared to online
gaming on your phone all of those
components the doing a very lightweight
ajax request every two second while the
user is actively browsing the page it's
probably a drop in the ocean as compared
to those both from a battery consumption
and from a kind of cellular consumption
but you're optimizing for your use case
that said I would suggest that you put
some time out in your page about it and
you don't keep doing it forever so we
know we go with two minutes so if
something you can do the exact times of
how long does it take to establish a
connection how long does it take for an
idle connection to get dropped seems to
vary by devices by
carriers two seconds two or three
seconds seems safe to maintain that
connection life fully loaded yes right
so yeah so the comment is that the UH
the power consumption is actually quite
significant I mean I would say I I can
see that it has a toll we try to measure
it it was kind of hard for us to really
get a good estimate on how much impact
doesn't make logically we thought it
wouldn't be a big deal but I do agree
that this one is a little bit of a gray
area from a kind of cleanliness
perspective because there's a reason
that those connections have been made ad
hoc okay so that's that's basically it
about mobile networks and those are
probably the more problematic component
the most problematic component when you
talk about mobile but we still have a
couple more we've got mobile software
and got mobile hardware each of them
coming with its own baggage so mobile
software in general is cool it's good
it's a friend it's modern its
performance aware its uses advanced
browsers that are html5 and css3
compliant or support those there's smart
look ahead and you know it's it's a good
piece of software it's probably better
on average than desktop software because
it's newer it's fresher it's more
performance aware so generally it's a
friend for performance the the challenge
from a website owner perspective is that
it sometimes imposes limitations or make
some decisions you may not agree with or
that may not fit your model or what you
want to do with it so look at a couple
of examples of that the first is mobile
cache sizes so that is probably the sort
of single most impactful problem that
mobile software imposes today on you
small sizes are very very small on on
Android
the kind of the factory setting of the
stock android is about four megabytes of
memory and a disk cache more
measurements the on the zoom Motorola
change that it went up to 20 but
generally it's still a very small piece
of cash and from what we can tell that's
both memory and disk cache on iOS memory
cache goes to pretty significant sizes
but it's very very volatile so if you
browse the website and you went on and
you played a little bit with apps and
you read some emailing got back to your
browser that cash is very inconsistent
we really can't rely on it and
persistent cash is zero so if you kill
the browser process if you restarted
your device then cash just completely
goes away blackberry this is the only
race blackberry one with 25 megabytes of
of cash so when you look at the mobile
HTTP archive today a mobile page is
about 400 k in size so 4 megabytes in
android would give you about 10 pages
it's not that clean because maybe some
resources are shared but it's very very
small number even on desktop cache sizes
or too small Sauter it keeps kind of
mentioning that fact and it's true but
on mobile you're in a bigger problem so
you can almost assume on mobile that
your mobile the resources would not be
there in the cash when you come back to
it the next day I know there's now
there's smarter eviction policies that
are being played I know that Android
tries to maintain kind of a far future
expiry components on top of older ones
and the browser's are attempting to do
things now like prioritizing JavaScript
and CSS in the cash versus images of
things of that nature but this has been
sort of supported in some of our
measurements on trying to see the real
cash status on our own website but it
also is just very small sizes so what
you can do about it and this has sort of
a side benefit as well so you can use
local storage instead while mobile cache
sizes are small pretty much all the
mobile devices today offer you local
storage they give you five megabytes
it's really two and a half megabytes in
text because utf-16 characters take two
bytes each of data and and that data is
dedicated to you it doesn't go away
easily it's actually even manually often
pretty hard too
and you can use it to store primarily
CSS and JavaScript files and cash them
yourselves you need to do a little bit
more work to do to get this done the
advantage of it is you're using this
space in a way that is fix your needs or
your support or whatever makes sense for
your website so you can store the things
that are most impactful for performance
and you can manage that the others at
the other side effect of that is you're
creating what we call a scriptable cash
so you're creating a cash that you have
script access to so you can do smart
things like what we call adaptive
consolidation so you can download one
file and then store fragments of it in
the cache as individual items so that
when you go to the next page you would
know that you know if only one piece of
the file is different you only fetch
that piece that's that sort of a good
way to reduce the request without really
interfering with caching so so using
local storage is more effort but it's a
dedicated cash it would be robust if you
restart the device if if a user browsed
a thousand website it's and came back to
your site afterwards generally will be
there and it also helps you with giving
you that scriptable cash I do hope that
browsers overtime you know maybe the
Android uh browser can lead that would
give you that scriptable access because
then you can do smart things with it the
the next piece about yep Laurie app
cache in local storage are are the same
and not the same the most noteworthy so
today app cache is pretty finicky to use
and it also assumes it's it's a little
bit more designed for the page itself to
be cacheable and then alongside that all
the different resources while local
storage can be used for a dynamic page
that is not catchable itself but you
want to cache the different resources on
it the other aspect is that you get
scriptable access to it which you don't
with appcache as far as i know
correct yes if you use local storage for
caching you need to make sure that you
build the cash into it it's not a big
deal we actually had a webinar exposed
to learn our website that has a set of
slides that exactly walk through what
you need to do but yeah it puts the onus
on it this is a little bit I guess this
presentation is tuned for a website
owner versus a browser developer but uh
but basically is web so don't really to
put some logic into managing that cash
it's not a ton of code but it is the
onus is on you the other aspect is that
there's no the local storage using local
stores for caching the way we recommend
it assumes versioning so it assumes
there's no real expiry due to time it's
just a cache and you save something in
it and once you saved it its signature
based so you can catch it forever and
only as you increase or you cross the
thresholds of how much data you're
willing to store then you start clearing
files out so local storage is not a cash
from a browser perspective and therefore
if people it has quota limitations so it
can only store up to a certain amount of
data whether that data is used wisely or
not is is up to the web page of the web
pages bad the use of the data or the use
of the space would be bad yeah the quota
is per top-level domain so the next
important software a difference between
mobile and desktop is pipelining HTTP
pipelining the idea of sending multiple
requests on a connection at once without
waiting for the response and then
waiting for those responses to get back
is is an idea that's been around for
awhile since I should be 1.1 and it's
barely used on desktop it's enabled by
default on Oprah
it's an option on Firefox but it
basically is non-existent on desktop on
mobile Android uses it at least the
stock Android Oprah uses it and now with
iOS 5 iOS uses it so it is much metal
prevalent and it actually accounts for
the majority of browsing sixty-five
percent worldwide probably more in North
America so you definitely want to
acknowledge that or you want to sort of
be aware of it it's a difference between
mobile and desktop the really the single
biggest risk about pipelining when
you're building your own website is the
is kind of the head of line blocking the
idea that you would be sending a request
for three resources the first one would
be slow the next two would be fast
resources but the slower resource would
delay the next one's if the first
resource took three seconds five seconds
to return the next ones could be
immediate it doesn't matter it's still
going to take you to five seconds until
you get those back there's no way that I
know of just kind of tell the browser's
yet don't combine these components in a
pipe etc except putting them on a
different domain so the best suggestion
I have for how do you handle that as a
website owner is separate out the
dynamic pieces and the static pieces to
different domains the browser would not
pipe requests different domains on the
same connection so you kind of have a
fast-food calm and a slow lose calm or
possibly slow and our food calm and you
put the dynamic resources in a fast one
and the static ones in the slow it has
the disadvantage maybe of creating yet
another connection or you're going to
another domain on some browsers like on
iOS that's sometimes even an advantage
on Android it would basically you know
the the max connection limit is the same
per domain and for the entire device so
it's a little bit neutral but it at
least addresses this problem the other
aspect is you want to make sure
different browsers have different
heuristics for how do they identify
whether pipelining is supported
sometimes it's per connection sometimes
it's per server sometimes requests are
first being put into a pipe and then
distributed across connection some
the other way around so we have detailed
blog posts that dig into all the
different browsers and how they do it
and then on Android it also varies by
manufacturer so this is just an example
of it on the Galaxy S the galaxy s has
been modified to allow 12 connections
per well 12 connections in total as well
as per domain it made me pipe as many as
six requests on a single connection this
is just a screenshot of a TCP dump
Wireshark of capturing that data and
then you know again those other details
about whether it data gets put into a
pipe or a connection first so yeah I
guess I already talked about this so you
basically want to make sure you support
pipelining and I would sort of suggest
separating out the slow resources in the
fast resource the different domains to
address the head of line problem I know
there's protocols like speedy I think
they're better conceptually than HTTP
pipelining they're not the reality today
they might be the future they're not the
reality today it's probably going to be
a while before they become the reality
both from a web server infrastructure
perspective and a browser support
infrastructure specifically on mobile
today no browser maybe except this
kindle fire now building on it supports
it publicly right last piece is mobile
of mobile software is that there's too
much of it and this is a little bit the
despairing part of the presentation so
there's a lot of OS as if you're a
website owner your look at this there's
a lot of OSS there's a lot of different
browsers there's very little visibility
even Android it's open source is sort of
open source by delay in Adelaide manner
and the vendors that the different
device manufacturers can change things
and don't advertise that there's the
changes frequently I don't remember the
exact number of Android versions
recently but just in October we got a
new version of iOS blackberry Android
and I think even Nokia so it changes all
the time and there's very little
visibility and understanding into it
kind of lost less tools it's just a
snapshot that says even in Android so it
beyond the high level split like iOS
android blackberry within Android it
actually varies quite a bit
this is just a kind of a thread snapshot
of this samsung galaxy s the samsung
nexus s in the motorola xoom and just
specifically on the number of
connections aspect the it's really hard
to see it in in kind of this world but
the galaxy s opens up to 12 connections
seems to have a thread per connection
yes you guys probably know this better
than I do the nexus s seems to adjust
did it worked this famous the simulator
and opens for connections again thread
per connection and has uses pipelining
well Motorola decided to scrap all of
that and go to a more classic desktop
browser no pipelining no thread per
connection and support up to 35
connections so even within Android this
is just a snapshot you're not guaranteed
that the individual device has it so and
yeah well this is again another example
in Android with also website owners have
the possibility or a kind of the
challenge of identifying Android tablets
which is difficult and we've done a
study who saw that basically the at
least as of a few months ago the
motorola xoom pretty much always got the
same sites that makes assess it while
the ipad would often not get it so they
would very often get a mobile site
that's a bad user experience I'm hoping
these things get improved but it's hard
from a website owners perspective to
separate out it's not the same as just
looking for the word iPad in the user
agent and then changes that happen all
the time just this nice iOS 5 change had
we enumerated about 10 different
performance related changes that
mattered things like adding support for
async script and on the flip side making
CSS in many cases block downloading of
other resources differences or changes
in JavaScript performance so again these
are all posted and kind of goal is not
to go through each one of these but
there's performance important changes
about performance happening in every one
of these versions and they change all
the time so it's a pain for a website
owner now unfortunately I don't kind of
have a magic solution to I to this as a
website owner all I can say is focus try
to make sure that you focus on the right
platforms the right devices for you
android and iOS in the in north america
oprah and blackberry a little bit more
when you talk about globally
so this is just browser stats from the
last three months showing Android and
then this one and this one is iOS its
iPhone and iPod touch these are a
percentage market shares of browsing
based on statcounter com no browsing
sessions like how much of the kind of
browsing of TV's browsed pages or browse
data I'm not entirely sure if it's pages
are data but it's browsing activity as
opposed to number of units out there
this is mobile browsers in general ipad
doesn't really populate and we're up
here so i'm not sure if they measure
ipads but but the ipod touch shows up
and iphone shows up so i think either
way iOS is already important enough for
you to optimize forward and ipad is is
obvious one yep yeah
so the question is how does html5 play
into this world of fragmentation and and
get supported so so I think the html5
standard is not as standardized as we
would want it but what really varies is
not about people's interpretation but
just about the support level so
different the fragmentation does matter
because you can't assume the same level
of support of html5 across the different
devices so it's just about needing to
you know either you settle for the least
common denominator and can only use
things that are supported across
browsers or you need to get fancy and
and support use the features available
to you where it is like you do with a
sink I'd say in general html5 is a good
thing to help address the fragmentation
by creating a standard but because it's
not fully supported by anybody it's not
really fully defined yet then sort of
not an entirely full solution from what
I see people don't tend to take
advantage of the sophisticated html5
capabilities too much I think that
affected by fragmentation and the lack
of the different level of support and
just keeping track of that but some of
it is just about kind of the time it
takes to adopt these things so anyways I
talked about these right now but
basically your best bet for this is
measure as much as you can try to focus
on your own you're right aspects and
sort of understand what are the
environments you're aiming at and keep
track on when do they change what are
the exact attributes so it's not a real
it's not a magic solution it's just
something that you need to work on so
the last bit I have and I'm gonna kind
of rush through this just because we
started a little late and we're already
probably over time is it is it a big
deal if I go a few minutes over I guess
I'll i'll probably I'm going a few
minutes over
is mobile hardware so talked about soft
retractable network and the last bit is
mobile hardware so the first and
probably most well understood or
discussed aspect of mobile hardware is
that it's lower it doesn't have the CPU
power the capabilities that that a
desktop or a laptop has if you look at
javascript benchmarking it you know the
software has taken iOS and Android was
already here but taking iOS from 10
seconds to about 2.2 seconds or sorry to
3.5 seconds to complete the sunspider
benchmark so it improved quite
significantly additional hardware with
iphone 4s doubling the CPU got it down
to 2.2 running the same test on my
laptop takes 230 milliseconds so it's
still 10 times faster the gap is still
very very big Android is is on par like
that the numbers today are pretty
matching and blackberries far behind so
so so the the weaker CPU is is
significant we also try to understand
how does this actually play a role in
real website so is this just a problem
if you're building a JavaScript game or
does this impact your day to day or your
regular website so we took the top 100
website in the US as measured by Alexa
and measured them on iphone 4 iphone 4s
and an iOS simulator all running iOS 5
the advantage of the iOS of using iOS
for this is that the iOS simulator
actually compiles it to the hardware in
which it runs so it's truly the the
laptop hardware that's running this
measurement and we saw a big impact the
the doubling the CPU and iphone 4s went
from 3.4 to 2.9 seconds on average this
is over a fast connection Wi-Fi
overnight we try to kind of take the
network component out of the equation so
it one from 3.4 3.4 to 2.9 seconds
running it on a laptop have that speed
again so some of it is JavaScript some
of it is the cost to render images some
of it is the cost to open connections
and kind of how fast is that component
work all of those components
this measurement isn't for rendering
it's for a load time and it's basically
the point in time the browser told you
so its load event in the browser that
may or may not reflect the right low
time for that page but either way it's
consistent across these three different
devices so it's it's all iOS 5 running
just on different hardware so so it
matters it matters for a regular website
as well so I'm missing a slide about
what you can do about it that I had here
and I keep forgetting to unhide but
basically what you can do about it is as
much as you can you should avoid
JavaScript that's a good option it's not
a good option for hardware like for
tablets for iPads where you need the
rich content it's a little bit of a
better option for your smartphone but
you definitely want to try and reduce
your use of JavaScript the it's not just
JavaScript it's also things like reflows
like putting an image if you if you add
components or you change the visual
elements in a significant manner you
inject some big node at the top of the
browser you inject div elements across
the page you're causing the browser to
re-render trying to kind of reduce that
or reduce the complexity of it it's not
trivial the easiest thing you can do is
just try to eliminate JavaScript or
reduce JavaScript since you can't
eliminate JavaScript the second best
option is to defer javascript try to
push that off try to make it run after
the page load not having to block
anything during the page of all the time
so I my apologies for kind of not having
I have a slide it kind of demonstrate
those but I think that is probably the
aspect that is most well understood
second aspect of mobile hardware is that
it's smaller kind of needs to be to get
into your pocket should you carry around
to be mobile and by being smaller it
being smaller we're talking primarily
about smart phone and tablets form
factor the smaller devices are a design
challenge but for performance there an
opportunity there's nothing slower about
a smaller device it's an opportunity you
can create a lighter weight weight
website even if you don't create the
lighter web wait website what you can do
is you can adapt to the size
most obvious example of taking advantage
of the smaller screen sizes is called
responsive images and the idea of
resizing your images to the display size
and it can make a very big impact this
is an example from the Lonely Planet
website where if you just take one of
these banner ads that they have here at
the top not banner but kind of the main
images the full resolution image is 50k
it's pretty sizable image if you reduce
that to the resolution that an iphone 4
can present its 480 pixels you cut sixty
percent of that size if you could go to
what 3gs can present you're going to 10k
you're having that again and you can go
further though this is a pretty rich
page and you can basically even on the
high resolution of an iphone 4 in the
equivalent android devices today you're
still cutting the page size by a third
let alone on older devices the ipad
resolution is actually lower than that
iphone 4 so on some tablets you'd be
gaining more or equally the same and if
you go for a higher resolution you're
not really gaining much if you want to
be very very advanced what you could do
is you could load the full resolution
images on zoom just in case you want
people to really if you're kind of
finicky about the quality of image that
you're displaying but when the page is
zoomed out the user cannot appreciate a
better image just they're not going to
see it and the last bit again is a bit
more technical about the mobile devices
they use a touch screen again I'm trying
to think about the differences between
desktop and mobile so the input device
is different touch screens are
non-existent basically on desktop and
they're prevalent in window in a mobile
devices and I want is a very very
specific one when you touch a mobile
device the device weights intentionally
lags to decide whether you were doing a
pinch to whether you're zooming whether
you're scrolling whether you're clicking
what is the action that you're doing as
far as I understand it it's not a cpu
problem or any limitations the design
decision about distinguishing what it is
that you really want to do what you
could do is you can make your clicks
more aggressive by turning them into
using touch events to do them so you
would use on touch start to a non-touch
end as an invocation of a click if you
want to be a little bit more careful you
want to say without a non-touch move
without a touch move in between
and and if that happens then you're
clicking we've seen it at work on
Android as well I'm not sure we tested
the very latest Android but we've seen
this work on the Nexus S and on the zoom
so so it's it has a bit of a negative
like if you're making your clicks
aggressive you're making them aggressive
you might be accidentally clicking
something when the user was intending to
scroll so it's a little bit of a
trade-off this is the case where you're
not necessarily doing something better
than the device but you're just changing
your biasing it towards what you think
is the better user experience for your
users on your site okay so so so that's
that's my presentation or that's the
data I have the the key point we talked
about is taking mobile talking about
mobile web performance and separating it
out so if i divide and conquer strategy
talk about network talk about hardware
talk about software and for each of
those what are the different components
and how do they impact performance what
what performance implications that they
have and how can you as a website
developer as a website owner and and
it's it's true from a browser developer
perspective as well it's just again this
presentation is a little bit more aimed
at the at the website owner how can you
help that how can you address that and
we talked about the different different
aspects the different challenges these
are not all the attributes and all the
aspects of each of these devices but
those are the major ones to kind of make
an impact and that's it the questions
yeah so the question is what's the UH
what is my view on the silk browser and
kind of the split browser architecture
where there's a server-side component to
it uh I think it's interesting i think
it's not really as novel as they present
it to be Oprah has been doing it for a
little while but this is different what
they do like they take it to the next
level I think there are real performance
problems that get solved by it so from a
performance perspective I think it's a
good move and it could increase
performance I would suspect that it
would break a lot of sites I'm a little
bit concerned about the fact that HTTPS
goes directly and if it doesn't go
directly I'm concerned about the privacy
implications if it goes directly and
concerned about the fact that HTTPS is
something we want to have more of an not
less of so you're kind of eliminating
the whole value and I'm also am curious
about the costs associated with it so I
think for Amazon it's an interesting
play because they you need to buy a
kindle fire and you probably have some
math about how much amazon purchases are
being timed by every user who bought a
kindle fire so they can probably afford
to lose some money on every user because
they're making money through other
channels but i'm not sure if the math
makes sense for every browser out there
so the bottom line is from a performance
perspective i think they're solving
problems it's like speedy they're using
speedy and there's a lot that can be
done there in fact what we do in in
blaze when we try to optimize part of it
is a similar logic but we're oriented at
the website but the idea of moving
processing from the mobile device to the
to a server and ideally doing it ahead
of time or caching results of processing
these are the types of things that we do
as well and we see that they have real
results so we do think they matter the
question is whether all the other
parameters work well alongside it it
will be faster would it be better I
don't know okay Oh feel free to contact
me after it if you want to talk about
any of this thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>