<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Better, faster, smarter: Python yesterday, today ... and... | Coder Coacher - Coaching Coders</title><meta content="Better, faster, smarter: Python yesterday, today ... and... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Better, faster, smarter: Python yesterday, today ... and...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A--VsTrwoMA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody we're going to talk
mostly about five into five but more
generally how the Python standard
evolves during the years with a focus of
2/5 but a little bit of historical
introduction as well they after the
brief introduction about what happened
between to 2 to 3 to 4 we're going to
move mostly to 2/5 and basically what's
really hot about it they with statement
and the whole concept of resource
acquisition is initialization or the
language changes in standard library and
optimizations and then Q&amp;amp;A but Q is also
welcome doing the talk as usual so
what's Python Python is one language
with many versions
you've heard of jython it's still
pending a bit late but eventually we'll
get there a to 2 to 3 release you
probably have heard about ironpython who
was apparently quite the success at
Microsoft tyrant item 1.0 was released
in August at Microsoft and it's
basically the equivalent of the classic
part in 2/4 you may have heard of Python
the research project of the European
community which is again basically
equivalent to Python 2 4 but not quite
ready for production yet and of course
what we normally refer to as Python is a
reference implementation known as C
Python for either classic Python or
Python implemented in C take your pick
to the to was released just barely
within 2001 and then there were
follow-up releases until 2003 meanwhile
right after that - 2 was - 3 was
released in the summer of 2003 with
follow-on releases all the way to 2005
and so on what was in 2.2 was a lot of
major new stuff it was a really a major
revolution in the language what it was
into 3 was mostly optimization - for had
some optimization we'll see the balance
of our
two-five has substantial optimization
probably higher than two for over 2/3 a
bet has also got substantial new
features a more graphical presentation
of the same concepts is in this timeline
or you see where - through - three -
four - five fit and where all the minor
languages language releases comm tour -
was a real real revolution a backwards
compatible revolution basically just
about everything you had four - one kept
working but a lot of new stuff was
introduced that really made your life
much better as a Python programmer the
new style object model the descriptors
to make it work the ability to have
custom metaclasses pretty easily
i creators same generators - completely
new model nested scope lexical scope
which didn't use to be supported the
start of the long process which is not
quite completed yet merging games and
long the new concept of division which
again isn't quite completed the new
bull-type was actually introduced in a
sub release two to three and a lot of
stuff in the standard library XML RPC
client and servers support for ipv6 the
new email package the possibility to
compile with Unicode encoded as UCS for
which I'm told is quite important in
some Asian locales there's never been
anything that big since python 2.2 we
also got a new rule in the following up
releases of Python we will never anymore
introduce new staff in to dot end of
something that wasn't - dot n we did in
2.2 bull was introduces smack in the
middle of the life of the release and
that made for an annoying of trouble but
we'll never do that again anymore
promise
so the main things having to summarize
out of the lot of stuff that was in - -
was the ability to make new classes and
new style classes and generally by
inheriting from object that you could
also explicitly set the metaclass
instead meta classical type is the same
thing as inheriting goal otherwise
ancestral s the classes from object the
ability to easily make a return lexical
closures as in the fun maker example
here generators with a new yield keyword
which of course being very new how to be
explicitly enabled with a from future
import at the time and more generally
the iterator model including the two
argument I curator using a function in
the sent you know I'm not going to go
over any of these in any detail I kind
of assume you guys are familiar with
Python 2.2 or later so all this
shouldn't be new to you but these are
all huge things introduced in python 2.2
in comparison to the three was a very
stable evolutionary step essentially
there were no changes to the language
proper same syntax same semantics some
minor tweaks in corners of the languages
most people never explore such as they
method resolution order for multiple
inheritance was substantially enhanced
but so that may count as a change in
language semantics but most people
wouldn't notice on the other hand there
were a lot of optimization tweaks and
bug fixes among the most significant one
we gained the ability to import from zip
files sort which used to be one of the
fastest in the business became
incredibly faster than he used to be
multiplication of long finally adopted a
modern advanced algorithm carrot soup in
particular memory allocations in the
Python internals was consolidated into
the new pine malloc concept and minor
stuff such as interned strain can be
garbage collected and so on a lot of new
built-ins which item not counting as
part of going which proper go there
technically in the built-in module or
such as some enumerate the ability to do
extended slices on everything they the
extended slice index was already there
but basically wasn't supported by all
the built-ins before 2/3 and many
enhancement to all built-in types STR
dict list file and so
and many new modules in the standard
library bz2 for better compression CSV
for comma separated variable files of
the day time module for very handy
unified handling updates and times keep
you for heap processed
priority queues I - tools to make using
decorators even easier logging a huge
framework for logging opt parse or
replacement for the good old get up the
platform module to get all sort of
information about the platform you're
running on the sets module to give you
the new data type sets and in variable
set frozen set tar file to handle guess
what kind of files text wrap to do text
wrapping time it for easy reliable micro
measurement of performance and a lot of
enhancement in existing module for
example two-threes the is the release
where sockets gained integrated the
timeout functionality which used to be a
third party module you have to download
separately and and integrate with your
Python installation and work with now
since two three Python sockets you can
set a timeout on so they will timeout
when you want as opposed to when they
tcp/ip kernel in your step one switch is
generally pretty hard to control so two
three didn't really change the language
when it changes a lot else that's sort
of powerful the course our creativity
being constrained because we decided the
language needs a stabilization it a lot
of it went into the standard library
nevertheless these are some highlights
basically from from library changes you
can have a zip file instead of a
directory on the sis part and import
from there you can do the sum of a
series of numbers very easily you can
get the index as well as a content with
the new enumerate built in you can print
the reversed version of a string by
indexing it with extended size syntax
with a negative
stride in this case do we had Universal
new lines to support five maybe mounted
on some file share in your land that
maybe maybe using standard UNIX line
ending or Microsoft stuff line endings
or even others and many other new
modules so moving on we then got to the
four most evolution not quite as a
purely evolutionary as two three but
mostly what we added to the language was
basically generator expressions and
decorators and a lot of teeny
optimization most of the low-hanging
fruit are already being picked into
three so they average program into four
may gain five or ten percent performance
but it's still worth having that five or
ten percent performance come from like
over a hundred fixes specifically aim
for two performance new built in sorted
and reversed basically mimicking the
existing method of list which however
work in place and therefore require you
to copy your sequence into a list and
then do the call to sort of reverse and
then use the new thing sorted universe
to work on the fly much more practical
from any cases further enhancement to
sort such as the ability to pick the
sort field with the key function key
equals argument mayor's into string so
set having proved their usefulness in
the standard library became built-in as
being a very fundamental type so there's
no need anymore to pervert the use of
dictionaries to actually represent SATs
standard library game in new modules
collections intended eventually to hold
those sort of container types it started
with a double ended queue cookie Libba
to centralize and facilitate right side
handling of HTTP cookies for session
processing a decimal like crucially
enhanced and fully comfortable with a
decimal floating point standard
- like you do when you don't really care
for speed but want reproducible decimal
results instead of a whatever kind of
binary floating-point you're harder
supplies with decimal you can get
repeatable totally portable decimal
floating-point results and sub-process
finally unifying and putting at a high
abstraction level all the sort of
function you used to do with AA stop
system must've pipe the pipe to mojo and
so on and so forth and a lot of
additions and enhancements to existing
module such as the use of model R string
the template much faster implementations
of the by sector EQ modules a couple of
new staffing operator module to
facilitate the key equals usage I can
get a natural getter you random to get
actually physically random bits or at
least cryptographic quality random bits
if your platoons support them at all
local storage for threads I could go on
for hours but I'm not going to I'm just
going to summarize this you language
changes so the first example shows you
doing the sum that I've shown four to
three without actually instantiating the
list as such you don't care to take up a
megabyte you store the list you only
need one item at a time and they
generator expression syntax lets you
generate the list one item at a time
rather than in memory or terms or and
they add class method notation in the
second snippet shows a teeny syntax
different.you is basically identical to
what you use to how to express as bar
equal plus benefit of bar right after
the death but it's substantially more
readable and it caused an explosion of
the use of this kind of higher-order
functions in Python in the world and
then some new built-in such as sorted
which is typically used for example in a
for loop without altering the sequence
you pass to it reversed
same difference by the way this is
identical to the existing extended
indexing which I showed earlier with a
minus one stride but it's much more
readable and second problem set of
built-ins of some built-in additions
such as for example I picked cherry
picked a few the new center method the
centimeter was already there but you can
now pass explicitly what dimmer is to be
used for centering the string such as
you want a the field centered in the
string centered in a field of 797 with
pluses around it to serve spaces our
split splits from the right just a split
splits from the left this is an example
of sorted with an explicit key function
this shorted shortest first and doesn't
alter the order this sort is now
guaranteed forevermore to be a stable
sort so the order of items of the same
length such as D and G in this example
is guaranteed not to be altered since
they have the same key they maintain
their existing order they'll never get
compared and I did mention the new
standard library module such as the deck
you type which lets you append and
extend to the right and left of the
decimal module the I Triple E 754
implementation the subprocesses module
to spawn and control sub processes and
the various addition to the standard
library such as I can get her you random
the local which already mentioned a
couple of News functions in heap queue
to get the largest and smallest n items
sometimes I get asked so why don't I
just sort and slice well sorting is n
log M suppose you want the biggest
hundred I came out of a million
if you salt the million items and then
slice you're paying that price
proportional to
million times the logarithm of a million
which can become pretty costly if you
just call Heep and largest you pay a
price which grows with the number of
items you want or the greater of the
number of items you want in the number
of item you've given this particular
linear algorithm using a priority queue
so so that concludes the rapid
historical excursion and I'm now ready
to move on to two to five that it might
be a great moment if anybody has
questions or doubts about to 2 to 3 to 4
otherwise I'm just going to proceed to 5
so in 2 2 we had a revolution 2 3 was
very evolutionary - for almost
evolutionary - 5 keeps stretching the
concept of evolution of a stable
language I would say evolution plus
because there are actually several and
we change them one of them is huge we
now have full support for resource
acquisition is initialization start
programming anybody who comes from say
Java will think it's no big deal
anybody who come from C++ should
recognize how big it is we'll delve into
that we have stuff to support it such as
generator announcements in a new module
called context live which exists
specifically to support the new with
statement which by the way has nothing
to do with the with statement you may
know from us Carl it's a completely
different concept and more similar to
they see sharp using if you're familiar
with that and then plenty of little
things such as you kind of imports a new
kind of try statement new operators
ternary operator and pretty big
revolution in the exception subsystems a
few new built-ins and you know and the
missing method special method objects in
several new stand libraries model
of course we any Python release gotta
have at least five world-changing
library model something fun but
nevertheless there are many
optimizations there was actually a whole
sprint in Reykjavik Iceland sponsored by
WT focused exclusively on performance
optimization I think the name was Need
for Speed I wasn't there but I think
Neil was okay nobody was sitting here
was actually made able to make it
nevertheless they made a lot of huge
optimizations sets in frozen cessful
recording from scratch instead of
basically sharing the mechanics of
dictionaries they're now strictly
optimized for user set index X string
operation got many speed ups some of
them are unbounded we used for example
search of a search of a smaller string
within a larger string within operator
used to use they trivial objects are
bury them well check the first character
until you find it and step on the
smaller string looking for the second
third and fourth they trivial algorithm
you could basically code without
thinking it's order M of n and times n
where m and n are the lengths of the two
strings now in 2/5 we've got a subtle
specialization of boy or more which
basically is of a better big ol behavior
it's Big O of M plus n essentially so
there is no limit to how much time you
can say with that if you were looking
for a million character string within a
billion character strings your programs
are easily going to be thousands of
times faster now you shouldn't do that
probably but if you did you're going to
be amazed at a month here there is low
used to be very slow program has become
extremely fast or structures speeded up
new stylus exceptions are much fun
but not very significant you're not
supposed to raise exception has over
often the main reason to make exception
new style wasn't actually to speed them
up it was basically to like get all the
advantages of new style classes but an
on side effect is that it's not much
faster to raise an exception and many
many many minor stuff most optimization
work is things that give you two three
four percent here and there and there
and here and there that's how you
eventually build off to a big spread out
except where you have some some big
stars such as optimizing string search
from trivial algorithm to boy or more
and so on regular expression module now
uses the Python a locator function
calling has been made faster by simply
keeping one unused frame around if
available at any time it's like the
typical free list thing but just once
we didn't go crazy like sometimes people
do with per type specific free list the
new compiler can actually do a little
bit of custom folding so if you right
sex per day equal 24 times 60 times 60
it is not computed at run time but at
compile time not a big deal but it
encourages you to use this rather clear
way of expression optimization that can
be huge in some cases is during when
you're importing something
they's importing subsystem now caches
the results of whether this power that
file exists or not instead of keeping
repeating questions to the operating
system stat system calls oh I need to
import who does blah blah blah slash
fluids py exists no does not have a
slash 4 py exists no it remembers the
answers
that the operating system is given this
is a minor win if you're importing from
a local file system if you're importing
from NFS or SMB or other network shared
file system it can make a start-up of
your program orders of magnitude faster
we can see that as a big performance
improvement or we can admit that the
architecture of the previous system was
totally broken with compared to two
network share the file systems or we can
turn the fit around in saying that the
network shared file systems are totally
broken because they try to be
transparent try to emulate local file
system but never do a good job but that
is worth a one-hour token itself so
let's skip it and let's move to they
meet the big substantial enormous
improvement of item to the file resource
allocation is initialization something
that happened all the time into for an
older version of item and happens all
the time in job is something like
resource equal sum expression that
allocates in return a resource try a
block of code using the resource finally
a block of code freeing the resource if
you use this resource in a 40 pieces 40
different pieces of code in different
modules this godom boilerplate is going
to repeat again and again and again you
hope because if it doesn't repeat you
have bad somebody forgot whoops to do
the try finally so they just use the
resource and then free and then in the
if in the use there is an exception the
resources never freed and you accumulate
open file handles or maybe never free a
lock and end up in a deadlock a
nightmare which C C++ programmer looking
down their noses that I said well we
don't have that problem we use
constructors and destructors because we
have on stack Auto allocation which
guarantees freeing an exit of block
finally we can really give a substantial
retort to that feeling of superiority
the width statement saves us or at least
our pride with blocker expression
allocating as resource use the resource
the freeing is automatic on exit of the
block whether it's a normal exit or an
exception exit you go out and they're so
script read
so what does it need to use this well
many existing types of hub Dingman made
ready to support it directly for example
files typical example you want to make
sure a file is closed as soon as you're
done with it how do you do that with
open the file path as f the file type
returned by the open function is now
perfectly adapted is what we'll see what
that means in a short while to be used
entirely with so they closed method is
automatically called as soon as you exit
the block same for locks another great
example of resource acquisition is
initialization say that somewhere in
your code you have one global local Sun
lock and instance of threading the clock
now instead of having to do some lot
acquire try blah blah blah finally some
what dot release and if you forget you
keep holding the lock in case of
exceptions and so on now you just do
with some lock all the code you want to
execute as a critical section protected
by the block they with itself make sure
we'll see how that the acquire method
gets called an entry and the
finalization of the resource is the
release
a block exit but no matter whether it's
a normal exit or a exceptional one you
release it so to actually enable the
with statement you have to import it
from the future every time a new keyword
is introduced it's always has to wait
one full release to be a full citizen of
the language so that if you have any
code that actually uses with as an
identifier it could happen it's not
going to be broken you will be able to
run it just fine in Python to define to
make with into a keyword you have to
explicit to five you have to explicitly
import it from the future this gives you
about a year and a half or whatever it
takes me into releases to fix all your
old code removing all your instances of
with used as a plane identifier name of
a variable a function of some time in to
six no doubt it will be automatic so
after you've done that in modules for
which they started the module you have
this important on the future you can use
with expression optionally as far you
don't have to actually have the outbound
Clause if you don't care about the value
like we saw with Locke then any more
typically indented block what does this
mean inside what does it do in terms of
Python internals so to speak it's
essentially the equivalent of what
follows the expression is evaluated in
assigned an anonymous variable which we
will name underlying context just to be
able to tell what we're thinking then
the under under enter enter under under
method is called with our arguments on
that contest object context manager the
result of that is assigned to bar if
there is a bar and as bar close and then
the width block is executed
what amounts to the same thing as they
try close of a try except out take root
note I'm using a try except else and not
a try finally why well because it makes
a difference whether they with walk
terminates normally or not because a
special method : runner exit and runner
gets cold on the context manager but it
gets cold differently depending on
whether the termination was normal or
exceptional for a normal termination the
LCA is here it's called with three
arguments non non non this means
everything went just fine if there is an
exception then the exception time value
in trace buck our passes three arguments
which are the same things return by a
systolic simple very explicit it's utter
than that I wanted to make it a three
three liner it depends on what context
execute terms it can return non or it
can or a false value or a true value i
you can look at the tab with you if you
want these very very fine-grained
details I don't think you should write
your own context object as I'll explain
later so I'm not getting into this level
but good catch yeah they the pseudo code
as written I believe I greed or in the
pet dog wouldn't it on the slide because
it catches everything very continuously
this is just a and waiting
proof-of-concept level so anyway my
point is that we can now retort our c++
brethren for their year-long feeling of
superiority we're better actually Matt
austern they mainship herder of the next
C++ standard words here
we happened to start at the same time so
we got friends by taking the
introductory courses at Google together
and I also admire this book very greatly
generic programming at the STL if you
want to start understanding what journey
programming is that's probably still the
best one anyway
if up and assited into one my
presentation is not a Python programmer
but he was looking at this and saying
hmm we gotta have some of that in C++ I
don't know whether anything will happen
but because yes sometimes the the fact
that it a destructor doesn't know cannot
know whether it's being called because
of a normal accident or an exception
means trouble so you do a sort of trick
structure distinguishing we don't have
to we're better for the moment until
possibly the next release of the
standard so you can write your own
context managers you can write them just
as you can say write your own iterators
you normally shouldn't because
generators are so much handier but the
whole product is exposed we want to go
ahead and write your own I to rate or go
ahead similarly you want to write your
own context manager write a class it
will have some in it because you
probably want to initialize it it will
have an enter and an exit method that
make sure enter returns some useful
variable and exit perform for whatever
is needed for termination if you need to
distinguish whether the termination is
normal or not check if all arguments are
known actually I think you could just
check the extension type if if the
extension type is is none then though it
was a normal terminator the in extremely
general you can do absolutely anything
you want however if you actually had to
do it all the time we would be sort of
chunky like for I traitors you can do it
but after you've written 6 or 12 it
starts getting old so what do we have
that's better I don't know but let's
give an example very simple one
let's say we want a transaction on a
database we're using the standard Python
API for database interface in the DB
idea so we get initialized some
connection object Eruptor body record
what we're being initializer and enter
we generate and return a cursor on that
connection so the color does the width
transaction blah blah as cursor and also
the cursor executes cursor fetch blah
blah if we exit normally we want to
commit whatever that transaction did to
the database if we exit abnormally we
want to rollback automatically in that's
trivial because we just check the
exception type if it's non we commit
otherwise we're all back
and yes this implicitly raises
functional which I didn't get into so
the use is trivial with transaction on
the connection and the cursor cursor
executes this blah blah blah all the
complication of remembering and finding
out whether you wanna commit or rollback
is encapsulated one control by that
class but you don't necessarily have to
write classes like this one because you
get the new context lib module which
helps a lot
essentially the main thing is context
Lib context manager it's the decorator
so you prefix it to a function but
specifically it's intended to decorate a
generator so you write your context
manager as a generator basically instead
of inventing new syntax we repurpose it
if you will be existing syntax and
semantics of generator not for looping
purposes but specifically for the
purpose of doing context management for
our a III so your generator should yield
whatever you want the result of Enter
you normally actually invariably do it
within a try finally or a try accept
gels so the yield is in that try clause
because in the tricep case in the case
an exception was ready to normally raise
it again in this case there is nothing
implicit you want to reread it again but
remember the race statement without
arguments just two raises the current
exceptions so that's not a problem you
have a lot of you other things in
context laid up you have a few other
things it is nested which bothered me
you call with several context manager
applies them nested lis so you don't
have to actually ness to the with
statements enclosing for the very
special case where all you need to do is
to give this object and call closed on
it when it's done closing does that for
you these are rather special cases so
how do you implement a transaction with
the context net it's not all that much
shorter than writing your class but it's
like more organized so basically you
have a function which is actually a
generator which does its initialization
which is very simple of course and then
in the tribe clause of a try except
tells does the yield of what you want
the result to be and in the case of the
exception you do the exception
processing the rollback here and we
raise whatever except 2012 the else is
the bride' you get into when there's no
exception and then you do a commit and
that's it and they the Creator context
the context manager wraps that into what
who fights for expansion and you you say
the the underscore key of your keyboard
that's the main advantage because you
don't have to type and under in it under
under under under under under
under under exit and Andrew they with
the price of an upper and laptop and a
the closet would be to replace the
underscore key they're saving in dollar
amount so a lot but okay this is the
example of the use of nested they want
to locked transaction well you could do
with the lock : in debt with transaction
blah blah : in debt but one of the
principal of the zone of Python fart is
better than nested you want the nested
semantics but you'd rather not keep
indenting your stuff well you call
context if that nested with all the
arguments you want to be context
managers necessary to each other and you
get whatever the result as a tuple of
results and so your body here is just
once removed I believe its first in
first out the first in last out so it
does the locking then stops the
transaction then ends the transaction
and then releases the law yeah and in
the simple cases work all you need is to
make sure that op flows method is called
and that's what closing is for for
example I said that built-in files do
that automatically but say for example
the puter files you get from your nib
dot you'll open don't but you still get
them to do it by coated with contest
with closing instead of just saying F
equal or with you or leave you elope in
which wouldn't work because they that's
not a context manager you make it into a
suitable context manager with a trivial
enter and an exit it just of the close
just because there's so many thing that
wants that are almost like files but
don't support this new wisdom you may
have noticed if you really a fight an
expert that what I suggest here
you couldn't write that if I can't
afford it screamed bloody murder that
you did anybody notice that I have you
ever wanted to put in yield inside of
try but you can do it now you can and
that's one of the great benefits of aii
we had to support that to let
consciousness work so it downwards in
the general case yield can be now inside
a try clause so how do we guarantee that
it finally happens in I mean if your
expert with vital enough to understand
why it didn't work you may remember the
objection so why did they go away how
can we make it work now I can because
yield is known expression it's not a
statement anymore remember any Pfizer
expression can be used as a statement
but not vice versa so yield is no our
expression you can keep using it as it
was as if because it's still valid as a
statement but it also has a return value
so what's that return value well if you
have files into your for code and just
move it to job 2.5 the return code will
always be not but there's a new method
in generators which is send instead of
doing G dot next which is all you could
do on a generator implicitly in a loop
or explicitly in your code you can if
you wish called lead-ups and passing
about you that value becomes the result
of the yield those of you who are CS
majors may be starting to recognize code
routines here it's not a full-fledged
Karrueche but pretty close
gina still works but it's like said it's
become a synonym for decent non so
basically g send is a new g next except
it also takes an argument an optional
argument if you will because we've got
cocoa dinner
defaulting on a widespread opinion and
the north greatest shares it is that I
yield resolved should that actually
return the value should always be in
parentheses it makes things so much
clearer otherwise it's already and a new
method a new new method the throw method
you have a generator object you can now
call G to throw type value right back so
you're raising the exception with a
certain given type and value and trace
back inside your generator at the point
of the yield and a new method g close
which is a shortcut for G dot throw
generator exit will generate red cities
a new exception of course which just
means okay I'm done with you terminate
this loop finally when G's garbage
collected G da closed it's cold with it
if it already happened well so finally
we can use dry finally our try accept or
try anything within the generator yay
so besides this has a lot of other
advantages for example it's pretty
normal to stop looping on a generator
but I'd prematurely will like that as
soon as we found like a item in the
generator that satisfies the condition
we break out of the loop
so what so what then does the generators
stay around forever or until it happens
to be garbage collected or what well we
now we know we want make sure the
generator gets closed we come explicitly
cold it's closed method right then and
there and remember we can also have a
with statement with context about
closing to make sure the close method
his code of any object soon as possible
we exit look so that's one possibility
or the why the semantics of what gets
finalized when is very sharp now so this
is to my mind right after the
optimization is 80% of the motivation
for wanting to use fighter 2.5 the width
statement the generator announcement and
the context lip module that tie them
together but there's plenty more but
wait what's more for example I'm sure
you're familiar with a problem that
import in Python are by default and you
can't really change it in any way
relative so if you're working inside a
package and that package has a module
called foo there is it's hell from
inside any other or occurring itself any
module in that package together a global
module foo
a module food that ism some directory
system because import foo the relative
interpretation takes precedence
that's sort of like the typical beginner
mistake in UNIX so I've written this
program called test but it doesn't work
well no because the built-in called test
take president so you have the other
problem the other way around so we
finally took the first steps toward
fixing this you still have to import
that from the future because by default
anything that working to four will keep
working into five we do not write good
existing code that's our mantra but if
you do import up solutely port then the
meaning of important changes instead of
looking first in the local package and
then it can't find it they're going to
sistah it goes assist us only forget
local
it's nothing to do with it if you want
to go to the local package use the new
syntax tonics and if you actually this
has been slightly generalized in some
might say over generalize you can go to
the father package of the current
package with the syntax dot dot X I
foresee the potential for a overuse of
this powerful feature but there are real
use cases where you really want to go to
the parent package so basically this
supports any number of dots if you
exceed about two hundred dots you are in
serious trouble a psychological trouble
not but anyway so right now since you
need to import from the future most
people will completely ignore it but it
does promise an important simplification
of important antics in the near future a
couple of years from now into six turns
out they are hoping to sex the relative
absolute syntax and semantics of the
company
something that our Java brethren using
use old against us in Python you could
have either a try accept or a try
finally not both magically you had to
nest one inside the other
while they Java friends they were using
friends so were using accept and finally
in the same statement and surviving just
fine but we finally can do that in
Python 2 of the semantics is pretty
obviously that the finally gets as of
you to last so it's equivalent to this
kind of nesting in you can store right
and you can also have an else clause
which we still have Javed bhai in that
the else will be except because it
wouldn't make any sense to of a name for
a finally finally it's always execute
unconditional the else is suppose that
executed no exception ok awesomely the
most controversial feature I think it is
there but it's carefully the making
believe is not missing possibly the most
controversial feature of Python 2 5 is
that we are unfortunately game another
thing our C++ rather and bounded long
way they ternary operator we do it with
the condition in the middle and they
values the left and right and
technically you didn't even have to use
parentheses which I'm sure will help you
let's move on to something a bit less
controversial exceptions are now new
style classes and their yard she has
thought we changed I don't know how
familiar you are with a exception yer
Chi in to foreign earlier but basically
you couldn't really do an accept
exception without involuntarily catching
that poor guy who was banging on control
C because he really wanted they poor
developer generally really wanted to
kill you
program canta canta canta scene but you
were catching all exception said that
unfortunately included he's keyboard
interrupts so now keyboard in Turkey is
not an exception we have the new
class-based exception which is a new
stock line and then there's exception
and all star hundred but system exit
this explicit call of system exit and
keyboard interrupt do not derive from it
so if you do an accept exception yes
whoops okay so it should be here thank
you
yeah well it's a very important
exception so we decided to place it and
- okay all right it's a mistake apart
yeah the point was actually accepting
the system exit ecbert I think memory
error should also have come out because
if you're out of memory or real trouble
but there was a lot of debate on that
this would be there's a couple of new
built-in extremely simple one but then
some were many ones that were introduced
years ago like some and yet they made a
difference because it's psychologically
very different to have it there any you
know pass it a sequence they look and
exit as soon as they short-circuit the
exit as soon as they see by sequence I
mean any eye for both course note what
big thing some debate about that they
have the right behavior on the empty
sequence any for an empty sequence is
what it should be that is
so what should be Eddie on an empty
sequence come on what should be all on
an empty sequence yeah unfortunately oh
there is this is that method of strings
to know that an empty string you ask is
it on digits what the true answer is it
all digits is it should yes but it says
no is the only is something method of
strings return false for empty strings
I've hated that from the moment you've
got into the language I've never stopped
eating it because it's not panic me
wrong but I'm told that pragmatics is
more important than duty fortunately
this was not the case for the design of
these methods the union of a if you get
the mathematical point it would be very
good if you don't get it I don't have
time to get it across the built-in dict
class different dick tyrant has a new
special method it doesn't make any
difference unless you so fast it the and
random missing and random special method
is a hook method meaning a method that
is there basically for you to solve
class unless you do override it in a
subclass forget it's there don't do it
it's not meant to be cold or anything
when a key is not in the dictionary to
point for behavior just raise here
2.5 ba blow behavior cold missing
what does missing do by default it rises
here
QED so unless you override it you'll
never know it's there because it does
just what used to do but if you do
override it you can do whatever you want
when a key is missing and a great
example is uh clearing collections it's
a default dick
it's validly overrides missing to ignore
the key and instantiate a default
factory actually
it checks because if self default
factory is known it still resists here
but you can change or set at in each
time a default factory that gets cold so
to generate values for missing entries
whenever you're asked for them so for
example consider a bag a bag the maps to
say string suit to the number of time
you've seen them mostly said or back
what should have missing
Camie map to well 0 obviously so use the
default factory of int and you don't you
have a map you have a back because int
called without arguments returns 0
basically all the built-in types called
without arguments return their empty or
0 instance it works for all them who
open closes false dict open causes an
empty deftly stop and closes an empty
list and so on and so forth in this
terms this nice regularity turns out
very nice here because often what you
want to do here is basically to use a
built in time that you can do more and
you can do your own override of missing
for more nefarious purposes for example
you might have a okay most strings
should pass untouched but a few of them
I want to translate well make your own
little subtype off dict and basically
implement missing self key is returned
key so in your code you can just always
index this thing and most of the time
you'll just get the string and changed
except that if it's actually in the
dictionary then you'll get whatever you
put in correspondence to it it's
possibly although conceptually speaking
are AAI
is what moves me most about to five this
is the thing i'll end up using most
often because it's the functionality of
need you know lot of time
okay then we have C types the C types is
available for Python 2 2 or even later
the third-party module that it got
integrated into 5 it's basically a
foreign function interface you can load
any existing DLL or s/o or SL depending
on your operational system in call any
function it contains as a method and of
course as the name of the module
suggests you can essentially map Python
types to see types and vice versa in
order to be able to pass arguments and
get result it's possibly the most
dangerous addition to PI can ever make
one mistake you crush bad not exceptions
about it you crash yes
foreign function interface anybody who
wasn't doing Lisp in the 70s being not
worried about it nobody uses this
terminal but those of us were of defense
then finally the problem with list is
never got a standard one and but that's
another the Beck elementary just as c
types is something you could download
and you still can actually I believe
that in the case of a lemon tree you get
more functionality if you download did
they known standard information but it's
not much more and the one that comes
with two five without they main thing
surprise you elementary element path an
element include it's basically like a
doll but yes
what we want to offer there is something
very stable plantain gets released every
year and a half two years so if there's
some great absolutely wonderful
functionality that will be released
every 2 or 3 months that just doesn't
fit into finer so what we released I'm
summarizing to the Mon is a stable
subset we tried doing it another way
years many many years ago with the xml
stuff demo if you ever fought with
underscore XML Plus that was such a
double nightmare trying to have
something that was stable but you could
like download a third party which monkey
patched himself into your Python install
because they somehow people were
releasing every day and we didn't even
then want to release a new Python every
day never again being their tone that
I'll leave that a younger language I
want plantain to be stable that means it
can't have the latest and greatest
version of something unless for it's
guaranteed to be stable for the next
couple years
somatically it's like the dom except
instead of mimicking java uselessly
it's very Python II so you use stuff
like a bit like list a bit like a dick
and you also get functionality that's
similar to the pool Dom if you have used
that in the existing Python XML which is
basically a reasonable compromise
between the fact that a completely
incremental event-driven interface for
parsing like sax it's kind of
challenging to program for except for
very simple things and the Dom takes
just all of your memory if you ever deal
with with big documents you basically do
it incrementally but node by node you
still get a little piece of in memory or
presentation of the Dom or or anything
tree there's a some difference between
pulled on like pulled on by default
throw away things and you have to
explicitly ask - ok drill down now for
this subtree element tree by default
keeps the subtree but you can tell it ok
I don't care about the past stuff
anymore it's not it's if you're
beautiful Dom is very easy to go through
on a tree then we have a little bit
better support for functional
programming with some tools functions
partial is for so called partial
application which I will call keep
called carrying to the end of my days in
honor of Haskell curry but I couldn't be
there on that debate and there's a
couple of more practical things such as
update wrapper and they could have
integrated wraps to basically make sure
that if you ever wrap a function people
do that all the time
you wrap it right basically you get all
the metadata such as the doc string and
and so on from the function you around
another very useful practical thing is
forget all the old md5 in a such a
module were in the FAQ so how do I do
with the change 5:12 after you don't
call this a joke or some maintained
so now ashleighb has all of shi to do 4
to 5 6 3 &amp;amp; 4 in control if you don't
care about cryptography you want to go
but the interesting thing is that it can
work on any platform because it's pure
Python but if you do have open SSL
around it will automatically use it for
the computational engines it's part
transparently for you which is point
things I sure if you really cared about
that you're probably already using
either pi openness itself by openness
ascetic standard or PI crypto but this
is more transparent and more obvious and
more simple last but not least actually
not quite last of course</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>