<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>testing/quick: Go's little-known blackbox test harness (Go from A to Z — Zürich Gophers Meetup) | Coder Coacher - Coaching Coders</title><meta content="testing/quick: Go's little-known blackbox test harness (Go from A to Z — Zürich Gophers Meetup) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>testing/quick: Go's little-known blackbox test harness (Go from A to Z — Zürich Gophers Meetup)</b></h2><h5 class="post__date">2015-11-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/P7EzIJZljhY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone I want to say thank you
for all being here and especially thank
you to thomas sydney and everyone else
for helping organize this this is really
excellent how many of you within the
audience work for google just because I
feel like most of you are unfamiliar
faces okay so um yeah very good to meet
folks outside of the community or why
not so thank you for all coming here so
I'm Matt I work here at Google Surak I'm
gonna give a talk about a feature in the
standard library related to testing that
my opinion I think hasn't gotten enough
attention or at least I think it's kind
of cool and offers some pretty cool
facilities so without further ado so
genesis of this talk i wrote a blog
article about six months ago it's it's
basically about this topic it's much
more in depth but i figured this might
be kind of a cool little introduction
thing maybe for especially in for some
folks who aren't super familiar with
code because this is some pretty cool
power that I think might be I find
pretty compelling for working with the
little language so this talk is
available online right now so I mean I'm
happy to seeing that if you have your
phones out or your laptops out but if
you were interested you could grab it
right here on this app spot address so
it's there for you later okay so let's
talk a little bit about the cast of
characters so how many of you here have
actually done a fair bit of coding and
go okay so that seems like it's about
half of you and among those of you here
how many of you have actually used the
testing facilities okay that's that's
that's about almost one-to-one that's
I'm very happy to hear that for those of
you who are new to go or haven't
actually done a whole lot of testing
you'll be happy to know that there has
been a lot written about how to actually
do proper testing and go and I guess
what I'd say is like I'm happy to say
that also like a lot of what has been
written hasn't been necessarily super
religious and a lot of it's very down to
earth like there's no need to really
grok like major heavy frameworks or
whatnot so I've given you a few links
here if you're interested in how to do
testing and go and namely some of the
practices a lot of that is really kind
of going to be the building blocks for
this talk so those of you who have done
go and have done testing how many of you
separate
from this talk I've titled here have
actually heard of this package here
testing quick okay only actually one of
you raised your hand okay um so this
this could be really introducing you'd
probably do something new how many of
you come to the table with having done
anything at all in haskell okay so there
looks like about eight of you okay those
of you who have done stuff with Haskell
how have you worked with this package
called quick check before okay so a few
of you okay so this will be pretty
familiar for you in some measure if
you've come to the table from the
Haskell world and have used quick check
so new new suspects as they say so for
those of using go this is pretty cool
did you know that go can generate
arbitrary values for types so this is
these are not all the types of course I
wanted to keep everything fitting into
the slide so this is just a quick
synthesis of like you know the little
the gamut of built-in types them to go
did you also know that go could generate
values for arbitrary types even the ones
you make so I built this type here in
this slide point I wonder could I have
the language actually build me an
arbitrary value for this click run and
find out wow you gave us a point with an
arbitrary value here so those of you
maybe not super familiar with the
language or having used reflection let's
talk a little bit about what's going on
here we initialized a random number
generator I'm just doing this just so
this examples deterministic we are using
the reflection library which allows us
to get information about a type and
basically we're just getting the type
descriptor for this point here quick
this is that package I'm telling you
about which is a sub a sub package off
of testing what this is doing here is
I'm passing in the type descriptor and
the random number generator and i'm
saying i want you to attempt to generate
an arbitrary value for this type which
is what we saw when we ran this so I'm
not actually pre initializing this with
anything so this is actually using the
runtime reflection methods to generate
arbitrary values so the real meat of
this is this function here which is part
of the testing quick package called
value
um basically what the signature has
going for it is type descriptor which we
passed in as the first argument the
Ramban that random number generator what
does it return it returns then a
reflection type called value which then
describes the actual underlying value
and then okay which is as Thomas was
talking about his slide while go has a
convention of often using error as a
second return value or okay as to say
like well was as possible or not so okay
it's just a kind of a sentinel of saying
was something able to be generated here
so that's that's how we did this so
let's continue for a moment so how does
this work and by the way if anyone has
any questions please don't hesitate to
just like stopmidi employee raise your
hand and ask okay so how this works
under the hood is this is basically like
white noise generation if you will for
these for these arbitrary types so
there's really not that much that's all
that intelligent going on under the hood
it basically it will look at the type
using the reflection mechanism and say
okay for the given structure of fields
or one that can we just generate
something that's just arbitrary for this
it just at least fits the type contract
so I have a custom type here and a
Thomas talked a little bit about
building custom types so I have a type
here to represent Stooges you know like
three stooges so and we knew through the
course of the whole series of the three
stooges there were well more than just
the three stooges there were several
depending on like whether who is alive
or what not it but at the game time so
we have basically here at this enum of
sorts which is this is kind of like a go
at iam attic way of representing an enum
of a stooge so let's say we want to
arbitrarily just generate a stooge well
if you have a type that fulfills this
interface you're called quick generator
you have the ability to actually
randomly just generate something that
fits with some sort of type
specification so let's see we want three
stooges we don't care who they are but
just give us three stooges voila and
this actually falls back onto using this
generate method here that has been
attached to this type and we just
basically say just give me any sort of
arbitrary stooge that that's within this
range so that makes sense for everyone
ok
so um back to that back to that previous
slide where i showed you i was i said
like okay let's take this type of and
then like this reflect value stuff to be
honest the reflect package is something
that most regular girl programs don't
use on day-to-day basis and it's it's a
little clunky but it does it's does this
job well often if you want to construct
a type literal i try to distill like the
comment classes when you would want to
do a type literal right here i think
this might be kind of helpful for
reference for offline for folks it's not
super critical as you'll see later on
but this is just one of the building
blocks so like if you wanted to get
actually the type descriptor for a you
know say like a standard value type
that's what you use pointer you know a
standard exported type but gets DP r der
an anonymous struct thomas did you talk
about anonymous types in their talk ok
so in go you have the ability to
actually define types with him like
function closures they aren't method you
can can actually make it can't actually
attach methods to them but you can
effectively great like unnamed types on
ad-hoc basis for like serialization or
whatnot so like that's what you have our
here by anonymous struct it's just
unnamed it just represents whatever
values you assign to it so let's talk a
little bit about quick values
limitations for a moment so the first
thing to note is and this is completely
a limitation of the actual quick quick
value function is that it will only
actually generate values arbitrary
values for struts or any sort of child
object related to that type if the field
all fields are exported and Thomas's
talk you talked about saying something
is exported if it's if it's capitalized
it son capitalized it's basically a
private or not visible to foreign
packages so this is purely an artificial
limitation but this is just something to
be aware of let's go a little further
for a moment Thomas talked about what
what channels are so let's say you have
a structure that are struct or something
that has a channel and its actual
definition quick value can't generate a
just a random channel for you this is
actually purely artificial again I have
an open change list actually to add that
support for that but I
it's in that for review yet another
thing is how many here I've have heard
of the go oracle before or know what it
is Wow okay only three of you so if
you're new to go or you're just getting
started or otherwise the go Oracle is a
really cool tool it'sit's aside and
basically helps you with your workspace
management of sorts what the go Oracle
lets you do is the go Oracle scans the
your workspace effectively the
transitive closure of your build project
and it generates basically a description
of metadata associated with all the
things that's able to scan let's say you
have an air face like Rita and you're
like well I would like to know what
types within my workspace fulfill this
type well you can ask the Oracle and it
has a query language associated with it
emacs them I think even a few editor
editors have integration with it so you
can effectively say I would like to know
what types fulfill this interface here
based off of my workspace it's really
handy and it's quite fast too it's
actually part of the well it's not part
of the formal go project but the go
author's themselves have actually helped
helped build it so it's it's it's I
should say like almost like a
second-class citizen in the go world it
has a lot of other things too like let's
so go supports like type inference and
whatnot so it you could say like well
what type is this thing where my cursor
is right now or given the data flows for
this function here what possible car
three types could it be it can give you
answers like that so it's pretty cool so
with that with having said that the
quick value mechanism can't actually
just give you a random type that
fulfills a given interface I wish it
could but there's no mechanism and the
actual user exposed runtime of go to say
well we know that all these types
fulfill this I suppose you could
probably expose that somehow but you
know on the other hand you never know if
that's ever going to be correct or not
so that's a limitation to be aware of
another thing too is let's say you have
say you have you have a data structure
that has well some sort of structural
expectation to it like let's say you
have like you know a graph or you have
something that has like some sort of
topological consideration like no
cursive it's cyclical what's the
completeness well quick value can't take
that into account it's just going to
just generate as I said white noise if
you have a specific way you want to
represent the
object just implement the quick
generator for it and you know you'll
have your way of generating it other
thing too is it can generate unsafe
pointer and Thomas to talk about this a
month for a moment the ghost spec allows
you to cast the unsafe pointer back to
other types and you can do some brave
you can do some obviously unsafe things
with it so if your type has unsafe
corner embedded into it like instructor
otherwise it's probably not a good thing
to work with with the quick value
because you probably get you probably
result in memory corruption or otherwise
so why do we talk what so why am i
mentioning these limitations for a
moment this these are the building
blocks they're going to segue into this
whole topic of fuzz testing and
otherwise now this stuff might hit home
a little bit more sigo swig cogeneration
vendor code you're importing if you're
going to use the automatic value
generation these are places where these
caveats I just mentioned to you are
going to matter like if you're importing
a foreign type and it has unexploited
fields or if it's doing like something
with say sigo or one not these are
placed like all those all these caveats
I mentioned are going to come to the
fore how many here use protocol buffers
with go okay so I see a few of you okay
sometimes I've used the value generation
stuff just to generate arbitrary values
for say you know Santa ad testing or
hardening well unfortunately just due to
the way the go protocol buffer
implementation is which it's pretty good
there are some internal fields within
their that if you use arbitrary
generation will effectively result in
semi corrupted messages even even if
there are otherwise correct I for
testing I actually generated a public
helper here that will basically go
through and recursively renormalize the
protocol buffers so this is one way you
can get those to work correctly so let's
continue on other things too so I
mentioned this quick generator interface
I haven't actually ever seen any sort of
exported type out there in the wild that
implements this a couple of notes I if I
were building a type that's public I
don't think I would publicly implement
this interface here partly because well
it pollutes API number to any user wants
every use quick value or in a sort of
fuzz testing mechanism they're locked
into your implementation
you've provided right there and you know
as we get a little further on you might
see that like you really wouldn't want
to exclude users from one sort of
implementation or another actually as an
essay here on the bottom if you have a
private type or sorry it son exported
feel free go right ahead you know you
know exactly what you're doing with it
so now that we've talked about value
generation let's get to fuzz testing so
basically what this is about is
enforcing and invariant or set of
invariance so let's define an invariant
so basically within invariant we're
saying that like well given some sort of
set of operations we expect some sort of
set of conditions to always be held true
so I think that's probably about as
simply as we can say it so let's take a
very simple example you know we we have
a you know simple mathematics here and
you know we want to like check out the
commutative property of addition so you
know a plus B is equal to B plus a right
okay well is there a way we could just
always say that is this property
enforced well it turns out the testing
quick package offers a quick way of
doing this called check equal I'll talk
about what that means under the hood in
a moment but we have we define two
functions here function f which is takes
arguments a and E and a jerk returns an
integer and does a plus B and we have G
which does basically the same except for
you know reverses them well let's see
what check equal tells us is are there
any counter examples to calm you tative
so or the commutative property here
let's run this well says there aren't
under the hood what this is done is this
is executed functions F and G repeatedly
for many values that's generated
arbitrarily for that previous section I
just talked about and says are there any
for which this thing does not or like
where the left hand side is not equal to
right hand side so this is pretty useful
in certain cases so counter examples
well is division commutator let's find
out so in other words is a divided by B
equal to B divided by a well let's see
let's find out what happens oh shit you
know this thing says we're throwing up
smoke you know this property doesn't
apply so let's dissect what this means
so number one failed on in on this
put large integer large integer so this
first integer here is a this second
integer is B and then it says the output
output here from the left hand side is
negative 1 and the output from the right
hand side here is 0 so this allows you
to actually see like what was evaluated
on as input and any respective outputs
for which this wasn't true so this is
pretty this is a pretty cool feature I
think so let's talk a little bit about
what's going under the hood here and
we'll by exploring the method signature
or the function signature here so f ng
interface well I unfortunately even the
documentation I found when I read this I
wasn't super satisfied with it so I'll
just quickly just spell asada and
layman's terms so f and G are functions
that have equivalent argue or there are
equivalent signatures both argument and
and return and they have to have to be
that way so and then configures
obviously the configuration to be honest
you can read the go doc on that and it's
pretty self-explanatory and using this
facility we want to say using reflection
on F and G let's determine what types of
arguments to take and we'll just
generate for every actual argument they
take a respective permutations or
variations of that and see if there's
any case for which you know G for these
arguments is not equal to F for these
arguments simple as that and again I
guess yesterday the caveat being is all
the arguments have to be generated will
by check quick value which is why it's
been all that time talking about those
inputs and what works so um let's say
you're like well um guys I've come up
with this awesome sorting algorithm you
know I think this is good I think this
is going to be the best thing ever I
think Rob Pike is just gonna smile you
know when I propose to replace the
standard sort mechanism and go so um
you're like I want to first of all make
sure that this thing is correct before I
send in a change list for this so I have
my function implemented here and for
those of you who are not who are not
super familiar with go or with the
sorting package the sword interface here
is basically a type that fulfills a the
requirements for sorting which basically
like you know how is this type how is
value
or the left-hand value versus right hand
value what's the ordinal placement and
how did you swaps for the given data
type that's all that this is an inch
slice is an internal type or a type
alias i should say within the sort
package for like a slice of integer
slice of integers that fulfills this so
what I'm interested in doing is the
function f is the reference
implementation using shortcut sort and
this is part of the actual ghost
standard library right here and I'll
talk in a moment I'll talk to you about
this Restless boilerplate is all about
and here here's my bubble sort now in
reality I needed to have defined this as
actually like a local function but this
is partly a quirk of the go present tool
so let's run this and see if if these
things are always equal to each other
well I'll be damned they are but you
know reality the bubble sort isn't so
fast so you know I don't think Rob Pike
would be very happy with it so let's
continue on ok so the check cake will i
think is probably one of the simplest
ways of just doing like invariant
testing and go so when is this thing
useful um i personally like this thing
when I have a known good implementation
or reference implementation of something
and I want to check it up against a you
know proposed one or something
experimental like it's it's a very nice
fast way of doing it so how does this
thing work under the hood and are there
any caveats to be aware unfortunately
there are so in go anal slice is not
strictly equal to a empty slice even
though the mutation operations with the
Pens length capacity and whatnot
effectively act like the same they're
not the same so reflective equal will
say that if one were to run side has a
null slice vs an empty slice they're not
the same same thing goes for a no map
forced to say an empty map and to be
honest I think that's really where like
the bigger like the way you're going to
encounter more run time problems will be
so these are these are these could be
like little trip points you should be
aware of with respect to the the
function implementations with because
the the quick value thing uses reflect
DP equal under the hood so I personally
wish
that the check that the check equal and
other facilities would actually give you
a more nuanced error message that talks
about explicitly saying like well this
component here was not equal because of
this or something like that that's the
topic for later dead so another thing to
be aware of is with the way the F and G
are called using the reflection library
the values are the arguments for F and G
are actually the same and they point to
the same space in memory so if either f
or g mutates the arguments well you're
going to have some complications with
your test so when I back to this example
here I just outside of the scope of this
thing here I just wrote a quick function
and just defensively copies the data
that's why because sort actually mutates
the data in place does that make sense
so far ok so let's continue so there's
the second thing and I think this is
actually pretty cool this is called the
quick check function now this supports
all sorts of invariants like to be
honest any of the invariance we defined
with the check equal could be completely
represented with this this really is the
Swiss Army knife of the of doing like
just fuzz fuzz value generation so very
similar story to check equal like the
same kind of caveats apply about the
argument generation so the xfit the
fundamental expectation is this f can be
a very attic function any argument it
takes has to be able to be generated by
quick value but it has to have a rest of
the unary return signature and a bull
and the value of the bull return
signature just simply means like if the
value is true all the invariants that
we've identified pass we're good if it's
false oh something broke let's
short-circuit the test and we've
identified a input for which you know
some invariant has been violated the
report you would get about the violated
invariant is basically very similar to
that other one I just showed you where
we tested the commutative property on
division it would basically say well
this argument on this iteration count
and yeah and that's all they would
actually tell you it's not super it's
not super informative but the overall
pattern of how the usage looks like is
something like this here
I just wrote this in so this is a good
so those of you who are not super
familiar with go test or like just
testing ago this line here in this
linear are basically the common
boilerplate you would see on a test
function the the T the T type here I
should said the t value is the local
state of the actual test context and
like this is how you'd signal to say
like oh we've encountered an error you
know let's abort out a year or something
like that that's the standard way of
doing it now for the parts that specific
to quick check you would normally define
a function within this or it could be
external doesn't really matter that a
that basically orchestrates you know
getting everything in order for the test
actually exercising the system under
test like actually executing the thing
that produces the side effects and then
you validate the invariance or
assumptions now this needn't be strictly
how every actual test function looks you
could technically have it be you set up
your context you do one operation check
invariants do another option check
invariants dadadada until the cows come
home you know it's it's pretty flexible
in that but this is just like one quick
pattern and at least from the test
context often you would see something
like this you know run quick check if
the error you know is night cool and
yell that indicates we probably had it
violated invariant or a bad assumption
somewhere let's report that so where
does this thing come in as helpful well
if you're running decoders and encoders
this can be quite helpful if you have
the ability to like do bi-directional
operations with it I wrote a delimited
protocol buff or a link to limited
protocol buffer encoding scheme I'll
show you very quickly here and it has
tests associated with it but some should
jump to the line my apologies okay radio
so I can't use quick value to generate
the values here but I have a separate
mechanism that generates them for me
this basically just gives me a slice of
random protocol buffer messages that
then fill that using quick value under
the hood I write them out to a byte
stream here own byte buffer and then I
just read them and then I read them out
using Rida limited now each step of the
a well actually here you see some error
reporting here where we just simply just
abort out if we encounter some sort of
problem writing now we say let's start
reading them out let's make sure that
the left hand side is equal to the right
hand side for every message we've
actually read strange this buffer and
we've and we're doing that and then if
we can counter something weeks that's
that we don't like we just simply bail
out here with this fatal I actually
should have just had this thing return
false but I you know is kind of sleepy
when I wrote this thing's so so many
many moons ago so you can see this is
basically a quick wave into wind just
passing in all sorts of garbage into
this encoder and seeing if I'm able to
get back out exactly what went in so
encoder encoders are one place you'll
see the shoes like in fact if you look
at the standard go distribution you'll
find the shoes probably about 25 places
or so in in places related to encoding
so also places where you have like very
just like very discreet requirements or
assumptions about like inputs and
outputs or where you can quickly
determine that based off of arbitrary
input so if you have a public API I
think this is especially useful because
you never know what your users are going
to throw at you and you want to make
sure that you don't blow up in an
unexpected way or at least you you
return a meaningful error back to your
user this is not the end all be all for
malicious input but I think partly this
point above allows you to capture this
now here's another place where I think
it really is magical let's say you have
like props something that's
probabilistic and you're like well how
do I build tests for that you know you
could build you know you're very
case-by-case TDD oriented thing for it
but at some point you start you you hit
this case below in a way where you like
well I have a large number of inputs and
have a large number of expected outputs
k is there any way I can rationalize and
simplify this well my friend Sean wrote
are implemented a streaming quantile
estimation algorithm and this algorithm
has a couple properties associated with
it it says that i will guarantee for
certain memory requirements that the
error or that the error of the
estimation is no is no more than
whatever i allow it
be so what he did was he defined this go
test here and said I wanted to make sure
that the actual respective error for the
99th percentile is is this so he built
himself this within error function that
basically just generates some arbitrary
values and it then just it then says I
want to actually just validate a couple
in variance with this and as we see here
let's see the fits so this fits part
here is actually what does that quick
error error estimation with that I want
to have to go and show you the whole
code here I mean if this is too small
for you to read let me know but so this
is the part here where he actually does
that that quick thing like this is
actually fit this estimation and what
quick check does under the hood is it
just turns all sorts of arbitrary value
set throws at this thing and he's
basically saying I want to make sure
that always within no matter what one
input i get that the actual like
respective error rate is always within
this allowed tolerance so and if it's
not you know you can see that we just
simply return whether it is or not and
then boom we're done ok so those are
some of the really handy places where
you can do that because to be honest
like I I like table testing and
otherwise and go I think they're really
handy but sometimes you know when you
get these these combinatorial inputs
where they're just so onerous like you
just want to be able to simplify it and
I think this is really powerful so
another thing my friend my friend
Richard who works in this office
implemented as skip list this is another
probabilistic data structure and in this
case unfortunately well I have a list I
I wrote a simple invariant test here
this so right here we just quickly just
have this is passed into quick check
here this basically give me a slice of
arbitrary integers I didn't say well I
have a reference copy of like what so
the Skip list is actually a ordered data
structure that you can traverse
relatively efficiently but the
probabilistic that is how it's indexed
for traversing itself so i'm basically
saying i have an expected set of sorting
order which I'm going to let sort do
here I assume the actual sort package is
going to do this correctly great
and I then say okay I'm now going to
actually add this to my skip list and
now what I want to do is I want to make
sure as i iterate over the actual every
value of the Skip list that it
corresponds one to one with the actual
sorted list I have so you know the first
thing we do is we make sure that the
actual number of items we've encountered
is not more than what weaving what we've
actually put in there next thing we do
is we say or whether the actual values
match and at any point where this isn't
we abort out and one thing I want is
what i want to show you here that's
important is and that i'm going to talk
about this on a later slide is good
technique and the good technique is when
you have a violated invariant or
assumption you should make sure that
your actual test reports what was
violated where and why and what it means
because as you saw on the previous slide
if it just tells you the inputs and
outputs well what does that mean why did
that break well having this information
like these log messages here or you know
the trf that's really helpful for
understanding like what was broken or
why so let's go back for a moment and
let's just run this i think this i found
a bug actually on the local app engine
thing so this might not work oh there we
go so we're able to say for all sorts of
values of vendors in the slice that I
while traversing the Skip list they're
always ordered exactly like assorted
slices and we're almost done here so
yeah so basically what I just told you
there about having that special error
reporting about those contexts that's
pretty helpful um okay let's talk about
other things that do things kind of
similar to this so dmitrieva cough he he
works on go I think part time mostly
works in the memory memory and thread
sanitization projects here at Google you
might have seen him actually write a few
publications or one night he discovers
some pretty fun problems in common code
um he contributed the race contact race
detector to go and other things so he
wrote this nice tool called go fuzz go
fast is relatively modern it does
relatively similar thing to what we see
here in testing quick it if I understand
correctly can run both on a local node
as well as I'm a machine
farm work and unlike testing quick it
does have some ability to apply learning
to the actual data set where you say
like well this produced error let's see
if we can try to localize it around
other problems related to that it's
pretty cool I guess the question of when
to use why testing quick has been around
with go since 1 point 0 go fuzz has been
on the side I think it's a fantastic
project it's found plenty of bugs and go
and other projects question is like
which which is like lighter weight for
that like you care for a light weight or
heavier weight solution up to you so
that's just another alternative I
actually got started in software now
I'll talk about what this means here in
a second by doing by as a test engineer
many years ago working on medical
software basically we had software that
was used for tracking the workflow or i
should say life cycle no pun intended of
patients in the hospital and my um my
boss at the time was a really good was a
really nice a mentor and really good guy
and i remember one of the first things
he had that really scratched my head out
because we were building so we're like
we're building basically automated test
suites to validate stuff and like one of
the things he was like so i have the
stochastic monkey test and i spent a lot
of time booking this thing because this
was built in like a derivative of a
visual visual basic made by microsoft
called rash awhile called called
microsoft test which is then Bob my
rational software it was basically
visual basic with with pointer support
and some other funny things like that
and so it allowed you to come do some
terrible things like this but basically
what this thing did was it was like well
I know the application starts in some
sort of known state and we can apply
certain transitions and bring it to
States ABC and D and then from those
states there's an event again another
set of transitions would comply for
various sets of events and then each set
of the transitions it would basically
validates from invariance this piece of
suffer we had was terrible it drew
directly to the windows GDI we did
basically the variant testing by doing
regional or sectional screenshots and
then doing by byte differences with this
and Microsoft Windows Phone rendering at
the time was done deterministic so
depending on on the state of the mood of
the computer when you booted it you
would get different font rendering which
is rough all the tests
and no error tolerances whatsoever this
thing was absolutely terrible but anyway
has turned me on to this kind of this
interesting concept nonetheless I mean
keep in mind this was like year 2000 so
now we are still in the dark ages so
anyway I built this I built something
kind of like this stochastic test for a
quick facility and go where I would do
the state transitions and what was kind
of cool was I like after certain number
of iterations on these state transfers
the actual level of code coverage you
can see by the time we hit like about
like ten iterations or so almost hit
like ninety percent and then when we get
close to about sixty hits one hundred
percent now this is not the end all be
all for testing but this is a pretty
cool way of like just doing full into in
like let's throw all sorts of junk at
this thing and see what happens and this
was all basically driven by a quick
quick check in the end so I have an
article that's about halfway done
talking about what I did here and how I
did I mean it's not really i think all
that useful but you know maybe some
people who have author complex systems
might appreciate it so takeaways if
you're already testing with go great
this is just another thing for your tool
belt don't abuse it don't ever use it
like really like I just I kind of showed
you guys a lot of mundane features here
most important things are designed for
testability in the first place because
if you don't do this you're not going to
have a good time I don't care what your
testing tools are what your harness is
what your framework is you're not going
to have a good time and you're not going
to have fun maintaining your code this
is this topic has been spoken about I
think in my opinion ad nauseam by all
sorts of people my friend tamartian art
gave a nice talk and gopher con this
year called embrace the interface and he
talked a lot about the composition with
interfaces and using that to aid for
testability and you know that's a nice
thing to fall back on in the go world
for those of you new to go especially
even testing there's this concept called
table driven testing where you you
basically create anonymous table row or
anonymous trucks this table rows that
defining inputs in expected outputs and
you just iterate through that running
your tests and it's it's good it covers
a lot it covers a lot of basis but again
let's say you have that probabilistic
data structure the table driven tests
might fall short there so this is where
I think the testing quick comes in
helpful
and also like really am and you want
your tests to be simple in the suite you
want everything with your test to be
simple so you know there's also they
topic how you configure testing quick
the go doc for that is explains
everything you need to know i can let
you read that on your own are there
future opportunities I told you I have a
change list them about to send out for
channel generation I really wish the
error reporting with this facility was
better um they're okay sit like I
promised you like if you start using it
and like maybe within a week or so
you'll probably like bang your head up
and saying gosh by making this area I
don't understand what's going on you put
some like Prince de materia like all
walls because of this well you know the
thing is they're they're a rough edges
with this library and even though it's
part of the standard library it's I
think it's gotten in like probably I
would rank this in like the bottom three
most polished libraries in the standard
library but because of the Conte
stability contract guarantee of go or go
one not much we can do with it so I want
to draft a proposal about how we can
make it better for beyond go one um I
told you this thing for the standard
built-in types it will generate a lot of
states I think right now it will
generate may be about eighty percent of
the possible states for the known
built-ins core exceptions I could just
tell you right off the top are like
let's say you have a slice like right
now it won't generate a slice where the
length is less than the capacity or its
No okay and changeless to actually add
support for that because again those are
valid states for those objects and you
might as well know what's happening on
as an input for those of you coming from
the the Haskell world quick check you're
probably familiar with the ways you
could define a custom value generators
kind of ad hoc well I think there's I
think there's a lot we could do to
improve the way how custom value
generations done because right now you
have to use reflect and reflect is kind
of a terrible API I think and I mean
it's not as bad as the the quick testing
facility but you know it's not so nice
so we can make I think as a community we
can make it easier and lastly if you
have used quick check you're probably
familiar with this concept called
shrinking what shrinking is all about is
let's say you found an input that
basically serves as that counter example
for violating the invariant what's
shrinking would do in the quickcheck
world is you're basically you try to
reduce that input down to the smallest
case where that actually still violates
invariant so base
you could set you could basically more
easily understand why that's happening
so right now this doesn't do that I
think I saw a change a change request to
add something like this I don't really
know where it stands right now but
that's one thing so that's all any
questions and again if you want to read
this later what
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>