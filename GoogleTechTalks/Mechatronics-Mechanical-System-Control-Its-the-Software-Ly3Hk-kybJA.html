<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mechatronics Mechanical System Control - It's the Software! | Coder Coacher - Coaching Coders</title><meta content="Mechatronics Mechanical System Control - It's the Software! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mechatronics Mechanical System Control - It's the Software!</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ly3Hk-kybJA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">for coming this tech talk I got to tell
you that I am truly truly excited to
have dr. David Islander here you know I
was at Berkeley when I met Dave I was a
material science major doing my graduate
work and I thought yeah I'll take a fun
class in some outside of my field let's
take a mechanical engineering course I
kind of looked through the catalog and
thought his sounded most interesting and
I sat in on it and WHAM two things
happen one I regretted studying material
science instead of mechanical
engineering and two I said when I get
out I'm gonna go find jobs in mechanical
engineering and that's what I'm not
doing here at Google it's what I've done
in my previous job and so Dave I just
want to say thank you I really love this
line of work and I've been so excited to
bring you here because not only is it
something dear to my heart mechanical
engineering but it intersects so well
with what so many people here Google do
which is programming so please help me
welcome Dave here for the Tech Talk this
this mic on ok ok good ok thanks very
much just as a matter of interest in
that regard I think we have some
mechanical engineers over here i what
what kind of background do we have for
any other mechanical engineers no okay
we got the whole mechanic we must have
the entire mechanical engineering
contingent of Google here electrical
engineers CS English okay yeah right
okay what I'd like to talk about is
what's generally referred to as the area
of mechatronics mashing together of
mechanics and electronics and otherwise
known as mechanical system control and
kind of my view of the the software
perspective on mechatronics and
mechanical system control first of all
the name mechatronics goes back to the
early 1970s it was originally coined by
yaw scow electric describing at that
time the brushless motor sometimes
called brushless DC
Motors sometimes well brushless AC motor
they actually trademarked the name for a
while and then gave up the trademark and
the name has come to mean the synergy of
putting mechanics and electronics
together to get something that you
simply couldn't conceive of otherwise I
say don't take the name too seriously
because what's happened in the interim
has been the addition of software to
this which has changed things as
dramatically as the initial addition of
electronics perhaps even more so what
the the general theme here is that the
the value added in mechatronics is
really software today and so that's what
I'd like to focus on if we look at
mechanical system control and I'll give
a little history in a moment if we look
in the past the issue is how do you
build complexity into mechanical systems
if you look at the present the issue is
how do we manage the complexity we have
so we've gone from scarcity in some
sense to too much and that's really the
whole issue of how to deal with
mechanical systems so there's been a
long history complexity has been
something people and mechanical systems
have looked for we're looking here and
when I talk about control of mechanical
systems I'm looking at the issue of
modulation of power for delivery to a
target okay so that's what I'm calling a
mechanical system any kind of system in
which real physical power in some sense
or another has to be delivered to a
target that's that's a mechanical system
when people in some other fields might
disagree with me like Chemical
Engineering and such but I consider all
of that to be a mechanical system so
motion systems so when you think of
mechanical of course you think of motion
first but thermal systems fluid systems
chemical systems they all come under
this and the thesis here is that
software has made this whole field into
an entire new game it just is totally
different than what you would look at
say 25 years ago it's a completely
different field all the rules have
change as have the potential okay so a
little bit of history I think gives some
perspective in terms of this complexity
issue
and and how things work and I'll look
here just at three interesting
precedents steam engines the jacquard
loom and the DC motor just to give a
little feeling of complexity control
computing and how this was done
historically this is a the remains the
remains as of 1880 of a steam engine
that was built in 1760 the purpose of
the this particular engine was to pump
water from coal pits okay so so you're
looking at 18th century technology okay
and the interesting thing from my
perspective so this actually early 18th
century
okay so Newcomen invented the steam
engine 1712 a so called atmospheric
steam engine and what's interesting here
the way this engine works you have a
chamber you have a fire you have a
boiler steam goes into the boiler at the
appropriate time you close the valve and
squirt water in here
cold water and when you squirt water in
here the steam condenses lowers the
pressure in the cylinder pulls down the
piston okay and that of course on this
side operates a pump okay so it's an
atmosphere so called atmospheric engine
because the the pressure difference
across the piston can obviously never
exceed one atmosphere
what's of interest here is this area
right here this is kind of the
equivalent of what you might call an
18th century FPGA okay this is where you
built the controls and complexity and
the object here is all of this
mechanical gadget ree is to open and
close valves at the right time so you
have to open the steam valve close the
water valve let the steam in or then
close the steam valve and open the water
valve and let the water in for the right
amount of time then close that valve in'
and that makes the engine run okay so
you've got a basic system running on
what we would call control logic of
course all built in to the to the Macan
Nicolle gadgetry that runs the engine
this is somewhat later steam engine so
this is a 19th century steam engine came
out of a cotton mill okay and at this
point just sitting out in a field
someplace the interesting thing on this
engine to look at is right there okay
the the fly ball governor and that gets
us into a lot of issues of computation I
should mention by way of of giving my
biases that I'm in mechanical
engineering department at Berkeley but I
do controls controls is my main interest
so if you you know if I if I get a
little biased and more interested in the
controls part of things that's why if we
blow up this a little bit more here you
see the classical watt governor
so the Watt and Watts comes from James
Watt who is a steam engine manufacturer
in England he invented the watt governor
what happens here is this shaft over
there is connected to the main drive
shaft of the steam engine as it spins
these fly balls spin up and down okay so
the centrifugal force drives them up and
this linkage over here that linkage
connects to the steam valve okay so as
the fly balls go up because the engine
speeds up it closes down the steam valve
in order to keep the steam engine at
constant speed okay so up to you know
pre-computer days or pre electronics
days so middle of the 20th century this
kind of represents the state of the art
in feedback control and mechanical
systems the interesting thing to note
and to keep in mind here is that power
passes from the shaft through the fly
balls through the linkage and is used to
operate the steam valve okay that's an
important thing to keep in mind as we
move forward that there is a direct
power path all the way from the sensing
all the way through the computation and
to the actuator in this case
the steam valve here's another type of
computing this is a lot more like what
we would call you know modern digital
computing this is a loom jacquard loom
again 19th century very early 19th
century what you see over here are
punched cards they're wooden cards about
this big punched full of holes and what
those holes do is give you the
patterning on the loom so the the
patterning on the loom is controlled by
those those holes that's a piece of silk
woven on jacquard loom the threads on
that silk in this case were our actual
gold and silver threads this was done in
Japan and so that loom is capable of a
pattern that looks like that and so
again when you talk complexity you know
pre-computer pre-electoral pre
electronics when you talk complexity you
really are dealing with quite
significant degrees of complexity this
is just kind of for fun this is a a
steam valve in a lab at Berkeley still
functioning still in use 1893 steam
valve again if you look here the sensing
is all done mechanically and again think
of it in modern terms the question is
how do you get that information out of
there all right well there's only one
way to get it out visually yes it's way
up on see it up near the ceiling in the
lab I don't know I mean most of the
valves of this sort are there are the
bent tube
so you you know you have a bent tube
close to but as the pressure goes the
tube tends to unbend that's the way most
of them work but I've not looked inside
that one I have no idea how accurate it
is but as you can see it's telling the
pressure happily in use for 120 years or
so okay electrical motors okay keep in
mind this power path business again this
is the classical Faraday motor 19th
century the way a brushed DC motor works
as you've got your permanent magnets
okay see you've got permanent magnets
you've got a coil if you run current
through the coil you get a magnetic
field if the magnetic field crosses the
magnetic field of the permanent magnets
you get a torque generator a force is
generated and it moves but if you don't
change the electric field in the rotor
it will move and stop because it'll just
come to equilibrium with the field of
the permanent magnets so you've got
actually a split in the coils in the in
the wires that deliver current to the
coils and as you cross this split you
simply reverse the current okay now this
this shows only two pieces this is
called the commutator shows only two
pieces a modern motor has lots more than
that but the idea is the same
so as you're about to come to
equilibrium well you flip over on the
brush you swap the current current goes
in the other direction and the motor
keeps going okay and that's how you get
a motor that keeps turning when you've
got a DC current driving the motor so if
you look out here where you're driving
the motor you just see standard DC okay
so you just see a current in one
direction but by crossing back and forth
across the commutator you keep reversing
the current the motor keeps turning now
the interesting issue here is again
thinking the white terms of the white
governor you're delivering power to the
motor through the element that is
sensing position because this is
connected to the rotor and doing the
computation the computation here is
which direction should the current be
going as a function of the position of
the motor okay so you're delivering
power directly through the element
that's doing the sensing in the
computing okay and this is the classical
brush motor millions of them around
you're still in use they're all over the
place so it's still a very common
engineering component okay so that gets
us to the classical control of
mechanical systems the issues here that
we deal
with no separation of sensing
computation of power
okay so we've just been through that
that's the issue okay so early 1970s
yoshikawa dealing with the brushless
motor invented the term mechatronics
okay the idea was that if you added
electronics you had something that was
totally different than anything you had
had before so here's a brushless motor
now what you do in the brushless motor
now is separate these components so you
invert where that where the permanent
magnet Green is still a permanent magnet
but it's on the rotor now and the coils
are on the stator but notice no brushes
brushes are gone in their place is
computation sensing and amplification
okay so what you've done in order to
make a brushless motor is separate out
sensing computation and amplification
and that's of course why electronics
made the whole control of a mechanical
system a completely different animal now
you're free to optimize to the best of
whatever you've got you can optimize
sensing you can optimize computation you
can optimize amplification using
whatever technology is available to you
whereas in the previous system you
needed a low impedance path all the way
through the system in order to transmit
power and so you couldn't do that okay
so this system motor works by exactly
the same way when the position gets to a
certain point you change the current so
nothing has changed except with the
absence of brushes I can make a motor
that in the same space generates a lot
more power because the power in the
brushed motor is primarily limited by
the voltage and the voltage is limited
by sparking on the brushes if I push the
voltage up too high I'll get more
sparking on the brushes more sparking on
the brushes they wear out lots of high
frequency RF frequency noise the brushes
burn up etc so you have maintenance
problem so your your voltage is very
much limited on a DC brushed motor he
here your voltage is not limited run
your voltage up anywhere you want high
performance motors of this sort and
servo systems will often run two to four
hundred volts so you can run these at
quite high voltage and get a very very
compact package in terms of the power
per unit weight okay so that's the
brushless motor okay then that gets us
to what you might call you know the the
last third or so of the 20th century at
that point you add in a compact
computation okay so the the development
that gets added in at that point is
compact computation and these are a
couple of definitions this is what
happens when you let a committee they've
defined something I much prefer for
mechatronics um rather simple definition
application a complex decision-making to
the control of physical systems on
that's kind of what I use for
mechatronics we get there to this kind
of decision because of compact
computation small and cheap okay so
where we go today control complexity is
now limited only by software complexity
notice how much compute power you want
to buy is your only limit and complexity
so that goes back to my first comment
that we've it now inverted the problem
is in the earlier you systems as you see
the the problem of building complexity
into the system was the issue how you do
that was really difficult anybody ever
seen the inside of a mechanical
calculator and they're wonderful gadgets
okay and you know for for function
calculators they were common you know
through the middle of the twentieth
century every office that needed to do
computation had them but you know was a
device about this big okay and just
absolutely filled with gears and
linkages and cams and unbelievable it
worked that's what the Wright brothers
did by the way
I mean before they got into the airplane
business the Wright brothers did did
adding machine
another issue which i think is less
important than this audience but in most
audiences I speak in in the academic
world if you say control people think
you're talking about feedback control
feedback control which is another
subject is of great interest because to
the academic world because the
mathematics of feedback control are
rather complicated and interesting and
so control in the academic world usually
means feedback control in this case I'm
interpreting control much grow broadly
in terms of all of the things needed to
coordinate the motion of complex
machinery so when I say control I don't
mean just feedback control I mean
control interpreted broadly in terms of
machinery ok so if we look at enabling
technologies in going from classical
mechanical control to modern
mechatronics or mechanical control the
first one is amplification and our
direct you know that we are direct
descendants of the vacuum tube basically
the vacuum tube would gave us electronic
amplification and that's we have
followed through into solid state but
the idea is basically the same an
interesting side development that really
falls into this category that I've never
seen anybody follow up on is the the
pneumatic particularly the pneumatic
controls anywhere from early part of the
20th century all the way through the
1970s and even into the 80s if you went
into process plants you'd still see
pneumatic controllers pneumatic
controllers were based on something
called a flapper nozzle valve turns out
if you look at a flapper nozzle valve it
is really a pneumatic operational
amplifier it's really quite an amazing
device and it allowed pneumatic controls
to have full independent computation of
derivatives and integrals and and
proportioning yeah
well Theologica flapper nozzle valve is
mixed logic a flapper nozzle valves
rather simple if you imagine a chamber
pressure and a little nozzle and then a
flapper okay and what happens is small
motions of this flapper will change the
pressure in that chamber and that's the
whole basis of a flapper nozzle valve
fluidics is all fluid no moving parts so
this is a mixed technology but way way
earlier than fluidics so fluidics was a
1960s invention and so this is like 1910
and even earlier okay so amplification
enabled the isolation of measurement
computation and actuation what you want
to do is mismatched impedance so you do
not transmit any more power than you
absolutely have to across each of these
interfaces okay then the second is the
emergence of software originally
software was implied in the applied in
the process control industry for the
very simple reason that they could
afford it you had large expensive
hardware improved productivity and
reliability in that industry
tremendously the kind of computers we're
talking about we had one in my lab when
I started in Berkeley of this sort just
to give a feeling for what we're looking
at it the computer had 18 bit words was
a PDP 7 at the time we expanded the
memory which was a big deal we added 8k
8000 18 bit words and the cost for doing
that was about $30,000 in 1960's dollars
so you know you can see why only the
process industry could afford it but
they were willing to spend that kind of
money and it made a big difference the
invention of the microprocessor
dramatically changed the cost of entry
and now if you look at the issue if I
have any system in which I'm trying to
modulate power the cheapest way to
control it today is with a computer of
one sort or another so now this is the
least common denominator if you want to
control a module
relation of power the only time you
normally will find that kind of
computation being done in something
other than a computer is where you have
speed limitations so you go to either
analog or FPGA okay real-time software
is the key to mechanical system control
or if we look at the general notion of
software the magic of software is its
data reproducible if I run a program
once and run it again I get the same
answer okay this interestingly really
from the perspective of people brought
up in the world of analog systems is
magic you have a system in which there
is no error propagation with no error
propagation there's no complexity limit
and this is true magic I mean if you're
brought up in the computational world
for example with anybody know here know
what an analog computer is okay phew
that's more than I get most places but
if you're brought up in the world of
analog computing ok analog computing
complexity is ultimately limited by
signal-to-noise ratio
those if you're willing to spend enough
to keep the signal-to-noise ratio high
or noise to signal low keep the noise
down you penned a lot of money
ultimately though that noise will
propagate everywhere and if you go too
far you're going to get nothing but
noise this is not so in digital systems
ok digital systems don't do that oh and
it's the magic of you know you have to
think back to the 1930s when the basic
binary representation was developed and
it had to be idiotic right to think in
the 1930s when vacuum tubes were really
your only means of amplification that
somebody said let's carry one bit of
information per wire instead of an
analog signal which could carry
depending on again signal-to-noise you
know anywhere from 10 to 15 bits of
information on that same wire and you're
dealing with tubes I mean your small
unit you know is about that big for a
vacuum tube and some idiot says let's
put one bit per wire you know has to be
crazy at the time really crazy but what
it did is define a domain in which era
doesn't propagate and that domain is
indeed truly magical it makes all a
difference however okay software is not
time reproducible okay in the general
computational sense I mean so if you
look here for example a very simple
histogram of how long it takes a program
to go around a loop okay see you just
write a loop nothing but a loop and each
time around the loop your time how much
it takes and then you take that timing
and you drop it into a histogram okay
and here you can see in this particular
computer at this time it was taking
about four microseconds most of the time
okay overwhelmingly most okay so
certainly from an average point of view
the performance was very consistent but
not from a detail point of view okay
because look out here where you begin to
get outliers these numbers are way off
they're not they don't reproduce at all
okay and you can get a system that will
run for microseconds most of the time
okay and look at where you're out here
you're out at half a millisecond windows
what's that's where we're getting okay
so the issue the issue is what's between
you and the processor okay and how do
you design your software this is not a
function of the computer the bear
computer right what you're seeing here
is a function of the operating system
environment okay but but nobody lives
without some kind of environment you
can't do anything complex without some
kind of environment and so the question
for real-time software is what kind of
environment do you want to have
okay so where are we in real time for
mechatronics control one of the
interesting things again if you look at
the if you look at the real time
community is a lot of effort in the real
time community goes into what's called
hard real time and hard real time is
defined as something with an absolute
deadline if something does not happen by
some deadline the system is can consider
to have made a major error hard deadline
in terms of mechatronic systems is not
common most of the time statistical
timing that is statistically
reproducible timing gives you adequate
control for most mechatronic systems the
other problem with with the real time is
that in a mechanical system a lot of the
activity is asynchronous and therefore
you can't do deterministic scheduling so
again what happens inside the processor
becomes statistical as distinct from
hard real-time which cannot be
statistical has to be entirely
deterministic okay so where that gets us
is to a fundamental design principle and
that is if any mechanical components are
present primarily for the purpose of
transmitting information think about
replacing them with software or
electronics okay and think for example
well here are the ones that we just
talked about with a little addition so
we took a DC motor and replaced a brush
with a brushless motor okay and the
brushed motor the commutator is used to
transmit and compute information the
brushless motor that's done in a
separate component look at the modern
automobile the carburetor is used to
meter fuel that is to provide the
correct air fuel ratio to the engine
regardless of the operating condition of
the engine the carburetor is very much
in the same mode as again you're talking
late nineteenth century for the
carburetor the same mode
the brushed motor the computation the
sensing and everything is all wrapped up
into the same components I've never
personally taken one apart and tried to
adjust one but I've seen it done okay
and and it's a nightmare
it's a real nightmare to adjust one of
those things so we replace that with
fuel injection the injector is dumb okay
it depends on a separate computational
element to tell it when to open and
close
okay kinematic linkages and cams
replaced motion profiles and motors air
dampers running this building if this
building is reasonably modern you're
using variable speed motors on the fans
instead of dampers to control airflow in
the building just some of the examples
of what happens when you look from this
perspective of saying if there is
information being transmitted computed
by mechanical components don't do it and
okay replace them in order to do design
you need a context and so the context
that I deal in and the one I look at is
what I call the unit machine hey the
unit machine establishes a domain of
applicability those whatapp look what is
your design methodology applicable to so
the definition is that the unit's the
elements of the unit machine either
directly exchanged physical power or
exchange material with little or no
buffering that represents what I call a
unit machine and the basic design issues
are if you select your unit machine too
big you end up having trouble handling
the complexity if you select your unit
machine too small you can't optimize
because you've modularized too much and
you can't do global optimization so a
fundamental design decision in any
system is what's my unit machine and
when I design the mechanical system
designing the unit machine is important
one of the reasons a lot of systems fail
is that the machine design and the
control are done you know as if they had
nothing to do with each other okay so
some designer will design a machine and
then they'll say okay you control guys
now control it and if this decision is
made badly the machine either will
perform badly or unreliably because the
unit machine was selected too large and
you never could get a handle on it
or it will not perform well enough
because you couldn't optimize it either
of those here's an example from
semiconductor manufacturing by way of a
little disclosure this comes from
Berkley process control which is a
company that that I'm a co-founder of
and still associated with so this is
internal stuff in that sense this is a
typical front-end of a semiconductor
machine you can see a wafer typically
the wafer is taken in and out of the
carriages that move them around and then
placed into processing and in and out
and you've got these robots this is a
typical R theta Z robot it goes up and
down and it goes in and out goes around
there's an aligner here there's no wafer
on it but that's what finds the center
of the wafer and if it has a notch it
will also find where the notch is you
want to handle these wafers efficiently
obviously they're expensive the
throughput of these machines are
expensive this was a particular project
at Berkley process control in which the
machine was designed but was
underperforming okay and the people who
designed the machine came to Berkeley
process control and said hey this is
underperforming with no essentially no
redesign of the machine at all but a
change in the control philosophy as to
what was the unit machine the
improvement was three and a half times
okay so almost a 400% 350%
in improvement in performance what was
the issue even today if you go into a
semiconductor plant you will find almost
all the time unless it's a berkeley
process control controlled
machine the robot will have its own
controller the notch aligner will have
its own controller the whatever kind of
modules are used here will have their
own controller so the unit machines have
been defined too small okay and when you
define them too small for example if
you've got a robot hand off like in this
system with two robots you've got to
keep the robots separated if the
controller in robot a doesn't really
know where robot B is you've got large
exclusion zones that takes time okay if
you've got a single controller
controlling all of them you can do a
robot hand off like this because the
exclusion zone moves with the robot
because you know where it is all the
time so issues like that our fundamental
design decisions in terms of what
constitutes the unit machine and they
make a huge difference and you know you
don't you this is low-hanging fruit you
don't usually get this kind of
difference but you can hey so control
software for a unit machine needs access
to all internal information sensor
actuator States commands you have to
have this information fast enough to use
in control loops fast here by the way in
a mechanical system most of the
interesting activity in a mechanical
system goes on at the millisecond level
okay so most of the interesting things
happen are happening roughly at the
millisecond level so that's the general
time there are a few interesting things
like encoder events happening at the
microsecond or faster and then overall
system operation of course something
like that happens over several minutes
in order to complete a full cycle of
operation so the timescales run from
microseconds more or less up to minutes
where as I say the most interesting
activity is mostly focused around the
millisecond level a couple of examples
so there's the way for handling robot
the Denver Airport Fiasco is a good
example of this defining the unit
machine to big the the design for the
Denver air
when it was built under going to service
seven or eight years ago 92 okay a
little more than that 15 years ago so
when the design was done 15 years ago
the baggage handling was going to be
completely automated right so you put a
bar coded piece of baggage from the
clerk onto the conveyor and it was never
touched again until it got to the right
airplane but this entire from what I can
tell I was not inside this system okay
but from what I can tell this entire
system was viewed as a unit machine and
it never worked I mean it would it would
fling baggage out because the carts were
going too fast and the baggage would end
up in the wrong place and the carts
would end up all focused on one I end
when you needed them on another there
were just no end to problems it never
worked
it cost the airport something like a
year or a year and a half late opening
up which cost them something in the
order of one to two billion dollars
because of that era the baggage handling
systems were basically ripped out and
converted when United when they finally
opened the airport United Airlines was
having people carry baggage from the
check-in to the airplane I mean that was
the but this was a good example of a
unit machine being defined incorrectly
so you have two examples here one where
the unit machine was defined too small
and you get some really nice low-hanging
fruit in terms of improving performance
the other where it was defined too big
and you get a total disaster the system
never worked
these are extremes of course you know in
the middle things are a little more
moderate but the same general problems
another interesting issue dynamic
definition of unit machine when you go
from walking to running again this is
conjecture I'm not sure it works this
way but I think it does when you walk
your whole body is a unit machine you
can freeze you can stop you know where
all your joints are I want to show I
won't demonstrate but when you run you
can't do that and I think the unit
machine for running is the legs and then
you separate basically navigation of the
body and control of the legs because
typically when you're running if you
find some
unexpected change in the grade you
really can't correct it until the next
step
and so again conjecture I think you've
got a dynamic change in what the unit
machine is to account for the difference
in speed
you simply can't compute in the human
brain fast enough to keep track of
running but you can for walking yeah
you're using your arms for dynamic
balance and running and that's
absolutely true so mm-hmm
but if you look at that again you know I
this I'm not an expert and I'm just kind
of conjecturing on this one that what
you're looking at is within a stride
pre-programmed behavior and and what
changes is stride to stride and that's a
unit machine issue here that they're
controlling the horses in response to
real-time things happening as quickly as
you know much less than a step interval
will not argue at all so the issue I
repeat the the issue is athletes and I
would add to that musicians so if you
look at that and and we're a little off
topic there but basically what's
happening is you're using vast amounts
of feed-forward in those operations
which is why it's so hard to do because
quote when you say learning so learning
I play the guitar a bit okay or piano or
or baseball or what-have-you
when you're learning what you're doing
is using a huge amount of feed forward
and pre-programming and so to be a good
baseball batter for example it's
probably one of the single hardest
things to do right is you have to make a
judgment as the pitch leaves probably
even before the pitch leaves the
pitchers arm you have to make a judgment
and then set the right program in motion
right because absolutely smaller and the
time costume for the runner carrying the
ball you see these things that's right
that's right but the difference is to
use a unit machine on that time scale
we're into a different subject we're
interested back control versus feed
forward control
generally speaking feedback control is
nice because it's cheap okay feed
forward control is nice because you can
get really good performance but it's
very expensive because you have to learn
a lot so just think about practicing
your instrument and you get feedback
versus feed-forward which I say it's
another seminar but but relevant here
where do we go here Mechanical Engineers
don't understand software and software
engineers don't understand machines you
said that not me okay so what I'll
describe very briefly here is is how I
deal with this this is basically how
Berkeley process control designs its
machines and how I teach design of
machines we need some way of describing
control we need a design language we
need to be able to design and document
we meet we need a communication vehicle
among all stakeholders so we have to be
able to talk not only to people like us
who understand you know see job or what
have you but also to people in
manufacturing you're gonna make this
thing people in marketing are gonna try
to sell it
people in maintenance we're gonna try to
figure out how to fix it okay and
generally I don't care what language you
using it's unreadable
okay code is not readable by anybody
often not even readable by the person
that created it so that you need some
language that's an abstraction layer
above code to deal with we use a fairly
simple design model based on tasks and
state machines okay so no real good
definition for
tasks beyond the dictionary definition a
well-defined responsibility is it tasks
this kind of to layer model suitable for
the unit machine we're talking about not
suitable for a much more complex system
hey you need more layers we use a
hierarchical organization of tasks the
lowest level map to the Mac mechanical
system hardware the higher levels of
goal oriented ok so you get a model for
tasks where these boxes represent tasks
a task in computing terms is a
continuously running simultaneously
operating piece of logic ok so all of
these tasks are operating simultaneously
okay at least pseudo simultaneously if
they're all in one processor over here
you have the software Hardware boundary
up here you have the software outside
world boundary in terms of
communications you've got an operator
you've got an internet you've got a
factory network etc up at these upper
levels you have rather abstract issues
ok how do I make the most money out of
some particular raw product that I'm
processing
so think refinery ok so every time a new
tanker comes in I've got a raw product
that's different than the one I had
before chemical properties are different
I have to figure out what do I do with
this stuff so coming out the other end I
maximize value ok way down at the lower
end I have to actually be able to deal
with an actuator ok so I have to be able
to make some kind of actuator produce
the amount of power that I want and so
on through here feedback control
supervisory control mmm giving set
points to the feedback control etc this
structure serves for organization system
organization tells you what you're doing
in the network sense it allows you to
look at these layers independently put
them together work on them with
different teams to some extent we use
finite state machines so state
transition logic to the
find what each task is doing we do not
allow nesting of state machine so each
each task has just a single state
machine and the idea is if you can
describe the task with a single state
machine you can probably have something
that's simple enough so that you can
deal with it complex enough so that it
can do the job it's a kind of trade-off
between complexity and understanding
state machines are nice because if you
want to get into a detailed discussion
with somebody takes no more than five
minutes that to explain to somebody with
any kind of technical background at all
what a state machine is and then you can
be arguing over how the machine works
why if this sensor goes true here do we
do that operation and you can you can be
arguing why the machine and how the
machine behaves and you can be doing
that quickly okay implementation
languages portability huge huge issue
clean syntax you know we live with what
we get we'd like it but we don't always
get it efficient footprint and operation
of course getting less and less
important as the price of computing
comes down well-documented
portability is important because of the
development stages of the machine so you
start off talking when you're working on
a machine you start off talking about a
machine that is some kind of prototype
you know with sitting on a bench with
wires in all directions and motors
hanging out and what-have-you and some
PC sitting there running the machine
when you finally get into production you
know you've got some embedded processor
that is many many generations removed
from the PC the other issue is the life
cycle of a mechanical product the life
cycle of a mechanical product anywhere
from five to twenty years ok whatever
car you're driving the base engine in
that car could be as old as twenty years
old what's been changing on it is the
controls and how its operated so you
have to be able to take a basic machine
and compare that to the processor
generation time about eight
months and be able to update that
machine every 18 months or so typically
you update Berkeley process controls a
good example of the controller that they
use is the core for all their products I
don't think in any generation has ever
even used a processor from the same
manufacturer going from one generation
to another yet all of that software has
to be ported along you need to focus on
mapping design to software the critical
issue how do you go from the state
machine to the software is the critical
issue here you want to weaken the
dependence on language operating system
and the environment and the hardware
specifics okay that will give you the
the best portability you can get there
is you might call mythology in the
real-time world that real time means
interrupts and interrupts mean loss of
hair I mean nothing is more frustrating
than trying to operate and debug
something in the interrupt domain of a
processor for most of the real-time work
in a mechanical system you can do it
with cooperative multitasking if that
one big if you have to write
non-blocking code hey if you impose one
stylistic rule you can move from the
interrupt environment to the cooperative
environment and you can save yourself a
huge amount of development time and some
hair okay so the nice thing about it is
this fits the state machine extremely
well so whereas a lot of people write
real-time software if you're waiting for
an event to happen say a sensor to close
with a while loop write an empty while
loop so you put a while loop you put a
test for the condition and then an empty
statement and you just sit there now in
an interrupt environment you sit there
for a while then you get an interrupt
and it goes away and does something else
and it comes back in a multi cooperative
multitasking environment you can't do
that
okay because you're now hung in the
cooperative environment but if you move
those kinds of decisions to the state
machine level a they're visible to other
people and B you can now do them
cooperatively because in the state
machine environment all you have to do
is return the answer to a question do I
need to do a transition now or not all
you have to do yeah what long is in the
eye of the beholder of course so long
relative to whatever your critical times
are absolutely
but again the state machine gives you a
nice way to break a computation into
pieces so so what computation time in
terms of non-block non-blocking means
predictable okay once it's predictable
then you can compare it to your
specification
again depending on you know the right
the question is in non-blocking code if
you have a code that executes a long
time do you have to break it into
smaller pieces and the answer is it when
you look at the interaction between your
code and your timing specifications you
may have to do that or you may have to
get a faster processor one of the big
and again in mechanical systems the
accountants are in control okay and the
accountants are heavily focused on Bill
of Materials software does not appear in
the Bill of Materials so if you look at
the Bill of Materials for a piece of
mechanical equipment you will not find
software you'll find the cost of the ROM
that's plugged in right but you will not
find the cost of software and that's
phony accounting okay big is the cost of
software time to market system
reliability etc is heavily dependent on
the speed of the processor and you know
along with that amount of memory ok when
the cost accountants get ahold of that
they look at the Bill of Materials and
say well you've got a $4 processor in
here I'll bet you could use a $3.00
processor ok and sure enough you know
they win that argument and then income
the control guys the software guys and
you have to go through heroics to make
it work and you have to play games of
the sort you're talking about breaking
pieces up doing calculations just
missing your deadlines by fractions of a
millisecond the system is unreliable
takes longer to get to market etc so
there's a real mismatch between Bill of
Materials accounting and accounting the
real cost of the machine by the clock on
the wall I think I'm about out of time
here so I'll just stop right there
there's more stuff in the same domain
but I think you get a flavor for you
know how I'm looking at mechanical
systems and how software is a critically
important and B you have to look at
design methodology if you want to do
successful design and I think I'll just
quit now and open for questions
discussions etc thank you
that's a really good question the
question is do I see value in small
independently operating mechanical units
that operate in some peer-to-peer way
and the answer goes right back to the
system definition and the unit machine
definition the answer is yes if it's
appropriate notice think of a sensor for
example okay so if I have a sensor
that's smarter that for example can do
its own calibration that can do its own
fault diagnostic that calibration fault
diagnostic is in some sense offline
activity it's not crucial to the unit
machine to know that sort of thing it's
if I can afford it in the particular
machine it's worth its weight goal on
the other hand if you look back at that
way for handling example those robots
were small independently operating
systems and because they were broken
apart like that you couldn't optimize
the overall option operation of the
machine so the answer is yes but with
care
great thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>