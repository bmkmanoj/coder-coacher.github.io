<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2009 - Even Better Than the Real Thing - Lessons Learne | Coder Coacher - Coaching Coders</title><meta content="GTAC 2009 - Even Better Than the Real Thing - Lessons Learne - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2009 - Even Better Than the Real Thing - Lessons Learne</b></h2><h5 class="post__date">2009-11-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TFfEjo3oFfM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone thanks for coming back
we're moving straight on with Nikolas of
edge tines talk about grit testing
Nicholas joined Google two years ago
here as an SCT and is now working out in
Sydney one of the perils of having to
work for Google where they have nice
weather apparently and it's warm please
come back here just to give this talk to
you Thank You Nicholas thank you oh
alright hello everybody yes I'm Nicholas
I'm a nset working on google wave and
I've started working google wave a
little while ago and before that I
worked here in zurich on different
projects most of them are a lot of them
involving grit grit is the google web
toolkit and while working on those
applications i learned a lot about how
to write a great application but also
how not to write a good application and
this a little bit what i want to talk
about during this talk so we're in this
brave new world where the web is not
anymore just used for content the web is
more and more becoming our platform for
writing applications especially here at
Google we like it a lot it has a lot of
advantages you know you don't have to
burn cds and ship them out to people
people just log on from wherever they
are they don't need to install anything
in the machines so it's a really great
environment but it comes with a certain
problems right so one of the problems or
a couple of the problems that we have is
that we need to reinvent the entire set
of developer tools which we already had
you know but Java for c++ actually I
guess this industry has gone through a
couple of circles like that where we had
to reinvent our tools this is the latest
one
but also you have to deal with some new
challenges right so suddenly a software
has to run in browsers which are all
sort of more or less compatible to each
other on different operating systems
what's happening now very recently is
that we even want to run those
applications on our mobile devices or
just smaller species like the netbooks
which have a very limited CPU and memory
resources right and what also is
happening is that the type of connection
that we have available is changing as
well right so suddenly you don't know if
this laptop could be hooked up over a
wire over Wi-Fi or over 3g card or
whatever the characteristics of the
connections differ so these are all
things you have to take into
consideration today if you want to write
a web application this is why quit is
your friend because basically it is a
layer that takes away a lot of these
problems and deals with them for you or
at least that's the idea so it lets you
write for those so who in here doesn't
know quit or has never seen good or
excellent everybody knows quit fantastic
all right so it gives us the chance to
work with a toolset that is has been
used in the Java world for many years
and has been developed in that world for
many years so it's quite mature it's
versatile there's tons of debuggers and
I des and lots of I don't know code
coverage tools and whatever you wish for
whether this is an advantage or not is a
topic of discussion I guess we're not
going to get into it here I think it is
an advantage and grid as I mentioned
will handle for you the
incompatibilities between the browsers
and it will even be able to generate
JavaScript code that might be more
efficient than the JavaScript code that
you would develop by hand because it
takes your Java code and cross compile
to JavaScript so you can do nice things
like method inlining or removing that
code or all these kind of things and
this built-in support for
internationalization and accessibility
and one of the latest things that was
introduced is that we can have on demand
code downloading which means that only
the parts of JavaScript that are being
used right now I'll being downloaded
into the into the browser which is
especially useful if you have mobile
clients all right so this is a shiny new
world of grid since you've all seen grid
applications before I hope I'm just
going to go through this very quickly
this is a very simple web application
that looks a little bit like the Google
search page it contains a text box in
the button in with google tradition and
a label where we're going to put our
results what you can see that we set up
our service we set up all our different
panels we can display this whole thing
and here's the method that will put some
logic into our application so when
somebody clicks on the search button we
want to should of this query and
displaced we display the results that
come back so it's all nice and shiny and
for those of you have written swing
applications or have worked on other
another similar GUI tool kits will will
find is very familiar so that's all nice
and good but how do we test all of this
there are basically a couple of ways of
how we can test late applications the
one that probably most people are
familiar with is webdriver or similar
tools like selenium or rational robot or
plenty more out there these tests have
the big advantage of the very realistic
they test the system how it actually is
like a user would use it unfortunately
they are relatively slow and it is it
can be very hard to maintain them
depending on how your application is
written and I think we may be something
about that from the developers of these
tools on how to make them these tests
more mate to maintain but in general my
experience has been that it's quite hard
to maintain them and also it's quite
hard once you find a problem to pinpoint
the line of code that you actually have
to change to make it work because it's
big end-to-end test right so what the
great tool kit gives us is the great
test case which is basically a java unit
that's re yeah a j unit test case that
is cross compiled as well into the
javascript world and executed against
the JavaScript version of your
application this is a bit less realistic
and running webdriver test it runs
faster it still requires a lot of
compilation though and it's easy to
maintain and debugging again we sort of
not quite sure because what we see is a
line of JavaScript code that tests
another line of JavaScript code and
finds a bug but actually we have to fix
the Java code that's behind it so this
is basically why we thought we found at
Google is that what we really want is to
run right a lot of our tests in j unit
and execute them in java against a java
version of this great application it has
a downside that is probably not the
realistic most realistic approach but
it's very fast it means you can write a
lot of unit tests you can use all your
existing tools that you know for code
coverage maybe even automatic test
generation or whatever you do in java
and it is probably the closest to
pinpointing about basically this has all
benefits of traditional unit testing so
this is what we set out to do we went
into different projects and try to
convince them that this was the way to
go and start looking into their
applications to see how hard it would be
or how easy to make as possible and here
are a couple of the problems or the
biggest problems I think that that we
found so one of the first problems we
found understand since we're dealing
with Ajax applications and I should
mention that some of this is basically
applies to any sort of development so
that includes development of traditional
web applications maybe what are you
using javascript PHP or whatever you
will run into very similar problems one
of them is the nature of these
applications so the a in Ajax the
asynchronous it makes development a lot
more painful generally so we end up with
things like this where what we do here
in line number three we we make a query
to our back end to a server and we we
have to define the callback that will be
called once the server decides to give
us an answer or maybe never so inside
this callback versus onsuccess method
which then will does a whole lot of
complicated stuff right there's a lot of
complexity in there there's some ifs and
else's and for loops and switches and
whatnot and this is basically the part
of the application that we would like to
see tested now with a traditional test
you will have to use something like a
mocking framework to even get a hold of
this anonymous inner class that was
created before you can even start
executing that anonymous inner class
you'll have to execute all the code down
to line 12 and this is where you can
actually start your test very annoying
there's a very simple solution though
just take this call back and in
onsuccess method you call another method
which is not inside this scope that is
hard to excess and suddenly your test
becomes a lot easier there's no more
capturing of anonymous classes or
anything we don't even need a service
anymore to test our class we can
basically just generate a fake response
and make sure using traditional unit
testing approaches that this does what
we wanted to do the second problem we
ran into is that the developers sort of
tend to they start working with grits
they start liking it grid basically
provides me the whole API of different
widgets in different ways to lay out
things on your web page and sometimes
they're just a bit too lazy to find out
exactly what grid provides them with so
the thing huh that's not really problem
because with great i can also access the
dumb so the the basically yeah the page
directly and just do it they're not
bother which is nice and a quick way to
do things but of course it has a problem
that it becomes completely untestable
into Java world because the Java will
doesn't have a Dom that only exists in
in the compiled application and again
there's a pretty simple solution to this
learn the API and it provides it with a
lot of the stuff that you need and if it
doesn't if you really have to write your
own widgets that are not supported then
separate them into a nice class so that
later on you can mock it the problem
basically which maybe I should mention
is that it's very hard to instantiate
these things in the Java world this list
box doesn't really exist right we'll
have to replace it with something that
just looks like a list box but isn't
actually dead and but for functional
testing that should be enough the third
problem we ran into is very similar is
that people tend to mix job
javascript so yeah I found I found this
is something we found a lot of places
basically great allows you to write
native Java methods which only have an
implementation in JavaScript again works
perfectly fine if you cross compile all
of your code into JavaScript but if
you're trying to test in Java sorry
there is no implementation so we cannot
test it so here's an example of an
application where maybe we want to have
to youtube players on a page and we
would like one start button for both of
them so that would start both videos at
the same time one way to implement such
a thing would be this piece of code
which creates this button and you can
see again down here deep down in this
button we call this method called start
both players and at the bottom you can
see what a native JavaScript method
looks like in wit very simple but again
we can't really test any of that in Java
this Java will tell us that this method
doesn't have an implementation we can't
execute it so if we want to do something
like this pack it into a separate widget
and make sure you can replace that with
something with a mock during your test
and the fourth problem is again it's
basically a very general problem and it
applies to practically every kind of
unit testing it is that in general what
we want to do is we want to have this
class on the test and we want to poke it
from our test case and we want to see if
it does what we think it should do now
if this class on the test uses a lot of
static stuff or of global data we end up
with something like this usually when a
class on the test suddenly depends on
all these things that
that we will just have to deal with in
our test case right we might have to set
up some of those classes to have the
right state so that when we run our
tests they do what they're supposed to
but actually you're not even introduced
in testing those right remember we're
doing unit testing here and it gets even
worse in the great world if some of
those classes happen to have a
JavaScript implementation only it
basically means that you can forget
about testing any of this in Java even
though what you're testing might not
actually use this so I had a pretty
nasty example just recently where I was
trying to test a class that was using
this date utils class and in Java these
util classes have a tradition of being
purely static so every method in them as
the static keyword the problem here was
that as well spend about a day finding
out that this get format method calls
get default day time constants which
calls which uses this local info class
notice how we're still everything is
static once you remove into the static
world you basically stuck there this
local info class has a static field that
creates a new instance of something
which uses grid create and Whittle
create is basically the dead end for
your unit test because there's just no
way you can replace that with anything
that exists in Java we create basically
creates instances of classes in the
JavaScript world so even just to find
this like we spent about a day so what
can we do about this basically we can
use since we do not care about
everything that our class on the test
interacts with during our unit test we
can change our code so that these
classes become injectable right so that
our test case can tell our class on the
test
what we should pass through and what the
class on the test should use now we can
pass in this plenty of names for these
things some call the moxx of face which
was a bit of a general term here that's
test doubles but basically we can pass
something in that just will behave or
have the same interface as the
collaborators would but doesn't actually
do anything right and this is then how a
usage of our day to utah's class would
look alright so now it is not a study
class anymore and in our constructor we
can pass in an instance of day tootles
or something that implements the same
interface state you tools without
actually being that class or the
coniston we can't instantiate so now
suddenly my class becomes testable right
and that going through this pretty quick
this is already the last of the pitfalls
I ran into and really the biggest one
don't worry this last bit of code you'll
see and you don't you've actually seen
most of it already is our application
again our little search box that
displays different results now what I've
tried to do here I hope this is yeah
it's pretty visible so I try to color
code the different lines and what their
responsibilities in this program right
so the yellow lines deal with displaying
the information on the page the green
lines deal with talking to the server
getting the results back and the red
lines deal with processing those results
to make them to put them into a form
that can be displayed so how can we
separate those three concerns this is
what we learnt all when we learned about
object orientation is that we should
separate these concerns or concerns in
general
so here's a possible way that we found
that works pretty well for separating
those concerns and it is based on
something called the Model View
presenter pattern or it's not really
padded it's more than a pattern but
basically we want to separate our code
into these three classes we call them we
call them the view and the presenter and
the service the view is basically what
the user interacts with and it's
hopefully it's the idea would be that
this is a very very thin layer it
doesn't contain much complexity at all
it's mostly concerned about laying out
things on the page and displaying them
to the user and reacting to events that
they use it generates so in this case if
our user types in a search query and
basically the view receives this message
the the on click event and just passes
it on to the presenter it doesn't really
process that in any way it passes it on
to the presenter now the presenter is
the place where we want to have all that
logic all right so it will disable the
search button while we're doing our
query it will talk to the back end once
the result comes back it will tell our
view how to update itself in pretty in a
lot of detail so that all this complex
code that we saw before is basically
inside this presenter and now why did we
do that the reason we did that is that
if we use dependency protection on top
of that that we saw before if we inject
a view and the service into this
presenter we can now in our test replace
them with a mock right so we don't
depend on the view side of things
anymore on the user side we don't depend
on any server anymore we have all our
complexity in this one class which now
is pretty much unit testable
and basically this will make your
application way more inaccessible that
doesn't mean that you shouldn't also
test your view and we just before lunch
heard a very good talk about how we can
test our views very efficiently but when
we do that we don't really want to deal
with the functionality of our
application we want to deal with the
fact that well we want to deal with or
find out whether the information is
displayed in the correct way right we
want to deal with the fact that maybe we
have maybe we have the same interface in
French right and the word cherchez is a
lot longer than the word search so will
the world cherchez still fit into the
search button but that has nothing to do
with the actual code that performs the
search and that displays the results it
has purely to do with the layout so by
separating these issues we also get
another benefit which is that we can now
maybe generate a view without a real
presenter and without a real service so
maybe we can inject some canned data
into our view and use that for testing
right so that will speed up um the front
end part of the testing quite a lot as
well and yes in the end so the
conclusion pretty much for me during
this one half years was that a lot of
what I did was really not so much about
writing tests it was about getting the
software to a point where it can be
tested and this is usually the really
difficult part and the way Google tries
to approach it is to take engineers and
put them into testing and make them talk
to other engineers and it works you know
sometimes better than in other times but
basically we can spend a lot of effort
trying to make something testable that
really isn't it really just isn't and of
course you
can argue that static methods are there
for a purpose and the designers of the
Java language thought about yday we
should have static method may method
sorry but we go through a lot of Hoops
would you jump through a lot of hoops
for lots of reasons when we do software
development so why should we jump
through a few hoops to make our
applications easier to test because the
amount of time we save by making by
doing that is HUGE right and often you
just don't notice it because you're
testing organization doesn't report
don't do the same structure as your
development organization and they run in
a separate budget so the development
organization maybe never even realizes
what a pair costing right so that was
pretty much my message here are a couple
of suggestions suggestions if you are
interested in learning more about all of
this I can really recommend this clean
code book it's very entertaining read
it's very much about how to write clean
software very very nice a couple of good
articles about mocking about a
dependency injection and about these
architectures we talked about the Model
View presenter and will be control
architectures um I like to plug our our
blog that we have here at Google where
we try to update you with those nice
little testing on a toilet episodes and
other things and a couple of other gtech
talks that are also very interesting and
entertaining about similar subject right
thank you very much
um
hello yep that's an interesting talk and
it's clear that the you know a testable
application is an important part of good
testing but when you speak to these
engineers and say now you've developed
this great Ajax application but now you
have to refactor it to use a pattern
like MVP how does that get received so
at Google this actually works relatively
well in general because the
responsibility for the quality of an
application lies with the development
team and that the testing team is here
is there to support them but in the end
they will be the people who will be held
responsible if their application doesn't
work in production or crashes all the
time so in general we have we do have
mixed experiences and a lot of this I
mean a lot of people would say that what
I just said you know makes a lot of
sense and other people with argue
against that and also of course we end
up in in discussions until now we've
been with the great world within it the
great developers have been very
receptive or the ones i've worked with
which you know it's can mean many things
can be in that that my managers have
allocated me to good projects where i
can have an impact or so i don't know i
mean that there probably are teams out
there but that you know that don't
believe too much in what we do but we
try to work with those where where we
know that they will take our advice
seriously and hope that the good example
will convince others and yeah but
basically the the Java world seems
relatively open to unit testing to pack
to design patterns to all of these
things that we try to advocate yeah
generally it sort of works out
two questions one quick one MVP vs MVC
is is it anything other than a letter is
there a reason um there is a difference
yes I well to put it shortly um I have
to slide about this which I removed damn
the the model-view-controller pattern
puts more logic into the view so
basically in the movi in the classical
model view controller pattern the view
is a listener of the model it reacts to
changes in the model and the controller
doesn't modify the view it modifies a
model so some of the logic to deal with
those changes will still be in the view
whereas what we're trying to say is that
the presenter really has all the
complexity you can write a view class
that basically has not no ifs and no for
loops and nothing and all of these
should be in the presenter so I've been
doing your v0 that look exactly like how
I've been doing oh well excellent I
don't care much about how you call it as
long as you do it right it just declares
kind of view elements and the other
thing was in terms of these models or
patterns does does quit do anything to
optimize for any particular ones does
does it care if you're using NBC
parenthood it doesn't really force you
to do it there have been there are some
attempts in grids to come up with with a
sort of pattern language that will
basically generate the View for you from
from configuration files I don't know
how far that's god Simon might know
there have been some efforts in doing
that but really great is not this is why
I think we ran into so many
because grip makes it easy to make those
things wrong like to get those things
wrong it doesn't really force it to do
that so for example it contains tons of
static methods itself so if you just use
it as it was intended to originally you
will yeah you will do that because you
think or basically that's what they show
you how to use it but it's just going to
create something around this thank you
yes
you
I'll say that again ray Ryan at Google
i/o did a talk on writing enterprise
great applications which covered a lot
of architectural patterns that you can
follow in order to write a maintainable
testable great application thank you Jim
yep so rewrite any more questions um
yeah with with my testing cattle and
I've always felt that the developers
should have primary responsibility for
testing of writing and with my developer
hat on I don't really want any tool to
sully if you like my comb to have to
make allowances for it do you not feel
that maybe we should somehow have better
tools to allow us to mock object without
having to alter our code to allow for
them I totally agree with you we should
have better tools that allow us to so
the one problem i have with dependency
injection does it kind of breaks
encapsulation a little bit so me to tell
the application what it's using it may
be the outside world should even have to
care what I'm presenting is the product
pragmatic approach but you're perfectly
right we should come up with better
tools having also other things like you
know faster quick tests would be a big
help as well or faster web private ends
would be big help as well but you know I
mean in the current situation and the
way we are we just realize that people
are not writing unit tests or not very
useful unit tests or very expensive unit
tests that don't really add much value
so yeah with the current tool set and
the current situation we feel like this
is a one way to go though hopefully will
improve things but yeah please everybody
keep developing better tools for us
we'll try so as well
for marking do you have a centralized
marking service or every developer build
their own marks because if there are
multiple versions of marks for the same
thing they will be coming to
inconsistency and a follow-up question
is how much effort does this mock intake
and is it easy to maintain or to upgrade
with the actual services right so
actually with with Java we were in a
very happy situation that we have three
very good mocking frameworks that are
open source available there's jmark
there's easy mark and there is no keto
and they basically make it very easy to
create your marks on the fly just for
your test case you don't have to check
them in in many cases you can just use
them right there and then create a new
one or your other test so you never
really run into the and they're created
basically dynamically based on on
reflection information so they will
always be up-to-date and that helps us a
lot yeah but yes I mean if you want them
up or basically generate something by
hand yes you will definitely run into
that problem
you
I'll repeat the question hello okay
great my kid i I'm from Tel Aviv my kid
asked me to bring him back some three
letter acronym things I'm sort of game
boy I don't even know what he's talking
about so anyway you mentioned that it
took you a day to find the problem with
the static static wit initialized that
that was way down in the object
hierarchy okay and there's a couple of
other issues that you talked about the
kinetic connected with just basically
the static state of the code so as
anybody in the room actually tried to do
static analysis of Java classes or Java
code to try and detect these problems
and save people like yourself for me who
join a project that's been around for a
while it's full of legacy code and we
don't really want to spend those days to
find out why it's really hard to mark
out for testing purposes of course
considering this is the test automation
conference that's really what you'd be
doing for me I personally haven't tried
we've been just yes like we've been
think about some things along those
lines but we haven't tried it yet as
anybody tried it Simon Alex it's
conveniently the other end of the room
like I wrote a tool that used q docs to
pass the source of Java code base and
then what it would do is it would output
a juice module an interface containing
every single static method juice module
would then wild up that interface to an
implementation that delegated down to
the static implementations so the idea
was that you wouldn't have to remove all
the status from your code base but you
had a mechanism where you could pass
them in
thank you
well I haven't actually built anything
myself but I'm fairly certain that's
what the testability Explorer is
supposed to do which I don't know if
anyone who's worked on that is here I
assume they would have said so if they
were it's another google project I think
music oh Henry is at least partly
responsible and the as far as I know
it's a static analysis for java to try
to determine the testability of code
yeah if you're interested in that look
up that yes very good point yes the
testability Explorer will cover some
things it will identify some poor
development styles such as having lots
of statical I don't think it covers quit
specific things but it would be quite
cool to extend that to do quit specific
stuff
say thank you very much Nicholas then
can we have you back in the room by just
before half past you've got time for a
quick blue break or a bottle of coke but
not too many cigarettes so thank you
very much Nicholas thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>