<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Crypto Strikes Back! | Coder Coacher - Coaching Coders</title><meta content="Crypto Strikes Back! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Crypto Strikes Back!</b></h2><h5 class="post__date">2009-08-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ySQl0NhW1J0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone I'd like to welcome nate
lawson giving a taste talk on wind
crypto attacks nate is the founder of
route labs and is one of the
co-inventors of the blu-ray content
protection systems and really looking
forward to this talk he's been a help
with some of our open source releases of
our keys our library which some of you
may know is keymaster internally and
without further deal I'd like to turn
over to Nate thank you thanks Steve so
yeah it's just a little bit more about
my background I've been working with
crypto systems for a while which is why
I'm here to talk to you my day job is
that I design and analyze various
systems most of them are based on
cryptography in some form or another so
my focus is really embedded in kernel
security and particularly software
protection DRM crypto protocols so for
instance this picture here is a fast
track transponder you may be familiar
with from commuting so I took one of
those apart last year and gave a talk on
security flaws in the fast track system
and that was just the side-to-side work
for me before that I was at a comedy
called cryptography research up in San
Francisco and we worked on also the same
kind of thing designing and analyzing
products that really depend on crypto
and it was interesting about the markets
for those products is we worked on
things like satellite TV systems where
you have really active attackers who are
being paid a lot of money to break
systems and so it's a very interesting
adversarial model there that's where I
worked on the blu-ray disk protection
layer before that I reviewed crypto
products for come be called info guard
labs which is related to the NIST FIPS
140 program so that's where the
government basically has to review the
products and make sure that the crypto
secure before they're willing to buy
large quantities of software or hardware
and before that I worked in intrusion
detection so what we're talking about
today though is what you know why crypto
why would why would we fear crypto
attacks it seems like a really well
understood problem right
I mean you block ciphers you know you
put plain text in you use a key get the
cipher text out it's really simple you
the inverse also works you know public
key you have this sort of analogy of you
have a mailbox where you drop a package
into the
mailbox and only sign with the key can
unlock the mailbox and get the package
out again so these these models are
simple conceptually and so crypto seems
simple there's books like applied
cryptography that make it really easy to
understand and it also is very appealing
because you have things like proofs of
security using things like the random
Oracle model where you're looking at a
site when you're saying these
constraints hold then the cipher is
completely secure and so crypto sounds
really good and along the way people got
a few lessons with crypto so early on
back in the early 90s anyone here used
PGP so no okay oh one person okay a
couple okay so anyways back in the early
90s PGP actually had its own custom
cipher I can't remember even the name of
something fish that was just a bunch of
stuff that Phil had thrown in there and
of course got crypt analyzed and so
people got the message that hey
inventing your own block cipher is not a
good idea
no one invents their own block ciphers
these days I hope and people got an
additional lesson that hey you know it's
probably good not to implement your own
ciphers there's a lot that you can screw
up and writing your own AES or Triple
DES a lot of testing you need to do to
make sure you got it the implementation
correct so just use the libraries write
all your operating systems come with it
you've got in open SSL you have lots of
free libraries and Java you have things
built in and so people sort of moved on
from looking at the crypto as a
difficult problem and said well we just
need to sit down and argue about what
the key lengths we should use do we use
128-bit or 256-bit keys and if it's that
simple I wouldn't be here today
so crypto is actually very dangerous and
this talk will give you some idea of how
very little small problems with crypto
implementations protocol design and
things like that can cause your systems
to be totally utterly compromised so
crypto is strong but it's fragile it's I
think of it like carbon-fiber
and I'm familiar with that but
carbon-fiber is a very strong composite
but if you bend it the wrong way it
snaps and crypto is a lot like that the
other thing about crypto is it requires
review that's a
two to ten times the development cost
both in terms of time and resources and
it's it's very difficult to build your
own crypto systems and be sure you got
it right
it can't be secured by testing unlike
other kinds of software where you can
just throw a random data at it and see
what happens and say okay well it mostly
works you can't do that with crypto you
can have a system that works perfectly
well that takes any inputs and any
outputs and seems to work correctly and
someone can basically compromise it to
to get your private key and when crypto
fails it usually is a terrible
catastrophic failure you know you get to
change out your route private keys and
another thing was gone through that but
it's not a fun experience so what can
you do about this well first lesson is
just just don't implement your own
crypto the cost is too great and there's
too much of a chance of failure so
instead what you can do is if you're
doing something with data in flight use
SSL or SSH these are well understood
protocols and for encrypting data that's
going to be stored somewhere you know
use PGP it makes sense these have been
around awhile they've been well reviewed
if you can't seem to make your design
fit a model of data and transport data
rest then try reworking it a little bit
if you still can't if you still feel
like you need to implement your own
crypto at least use a high-level
equipped a library and what else I'll
talk about the difference between a
low-level library a high-level librarian
in the future but a good example is you
know Peter groopman script Lib which has
sort of a mixed license and GP GME which
is interface to GPG and Kezar which is
an open source Google project so all of
these work with crypto at a really high
level for instance you ask it for a key
and it provides you a key back and
that's not just a binary blob but it
actually has identifiers with it so you
can't use an AES key with an RSA
primitive or even beyond that you can't
encrypt a message without also integrity
protecting it and these these kinds of
things are important I'll talk about why
so don't use the open ssl or crypto API
on microsoft products or jce or anything
these things directly they're too
low-level I mean you wouldn't write your
webserver and assembly you know you're
working a much higher level there's no
reason to expose yourself to that kind
of risk
so I've talked a little bit about what
you can do to avoid using crypto but if
you are in a situation where you're
reviewing some crypto that already
exists here are some simple things to
watch out for so an obvious confusion of
in the documentation or in the source
code comments people will talk about
like I'm decrypting a signature in order
to verify it that's really a confusion
of terms even though in systems like RSA
does anyone here know what RSA is the
algorithm okay great
less people that's awesome so an RSA it
seems like the primitive for signing is
the same thing as decrypting or
encrypting with a private key you know
the same things like that but cygnets
assigning is actually a much different
process than encryption in RSA I'll talk
a little bit about that as well people
will use the same names or redundant
names for the same operation or or data
field in a protocol so that's a sign
that people aren't really meshing with
their understanding of how a protocol
works a lot of times we need a
cross-site development for instance
people be overly focused on weird
features like salts as what the main
feature of their product and the words
rainbow tables which seem to recur time
time again so also you'll often see
things like arguments about why this is
right why what I'm doing is it's not
standard but it's okay it's really
strong here's why you know because I use
really big key so no one can guess the
key attackers don't really know what
we're doing in here or some blog post
you know hey this blog post said do it
this way so I'm doing it and that
actually happens more frequently and
you'd think there was this Jeff Atwood
article on coding horror sure some
people here read that where he's talking
about he found some crypto flaw in his
product where it was using ECB when he
thought it was using a CVC and he had
this whole post about how it's better to
use CVC than ECB and and so if someone
posted a comment to that and they said
well you know actually ECB does have
valid uses you know whole disk
encryption and then hour later actually
oh sorry scratch that actually for whole
disk encryption you should be counter
mode instead of ECB and even that is
actually not quite correct
so don't depend on blogs for your
sources of crypto information other
warning signs
people will build a long message that
has multiple blocks and try to use rsh
and crypt multiple blocks there's
generally not a good way to use RSA
people will insist that in their
particular scheme the IV for a block
cipher needs to be kept secret
usually that's a sign that the system's
poorly designed spec diagram some
Wikipedia always a good one
anyone can figure out what this is
actually specifying here I'll give him a
dollar I've never seen so many symbols
before actually so I think they took it
down actually after I mentioned this
before so JavaScript crypto that's
another thing actually that's a little
bit of a warning sign there's not really
any reason to do JavaScript crypto and
we have a lot of people come up to me
and argue that oh you know I really need
to encrypt something on the browser side
and and I really I really have to do
this for performance reasons or whatever
it is but you need to follow down the
route of trust in the system so if you
look at it where did the browser get
your javascript code from well from a
web server right you know which web
server well hopefully we use SSL so we
can verify the certificate we can be
sure that the JavaScript wasn't tampered
with while it was being downloaded to
the web browser
but what keys is that JavaScript can
gonna use well it's being supplied by
the web server so who are you actually
trusting here you're trusting the web
server your web server supports SSL it's
already been implemented rather than
rolling your own crypto with JavaScript
and and not really changing anything
here in terms of root of trust and what
you're depending on just use SSL and
don't try to roll your own JavaScript
crypto so I want to talk more about
other failures I don't know if I've
convinced everyone that it's a good idea
or not to implement your own crypto so
I'm going to talk about various attacks
and hopefully we'll see what way systems
can fail so the first category is
system-wide flaws so these are things
that happen sort of regardless of what
cipher you chose or what your prior
protocol works so this is actually a
real example I hope no one here finds it
familiar but this is from a real company
so they decided hey we've got an old
cookie scheme and we just realized it's
insecure
we were using CBC mode to encrypt a
cookie but we weren't doing anything to
add integrity protection to it so we're
we're trusting in the fact that because
it's encrypted the the client can't do
anything useful with this before sending
it back to us and does everyone here
know what CBC mode is or have an idea
okay good some some hands shaking yeah
okay yeah so CBC mode is is okay for
encryption but it doesn't provide
integrity protection so an attacker can
actually modify things intelligently in
your plaintext just given the ciphertext
and so what they said was well let's add
integrity protection to the cookie so
this is good they're making a change
they're improving their security
so they used H Mac which is a reasonable
cipher for that a reasonable hash
function construction and so great so if
someone said all right what do we do now
we've got all these cookies out there
with the old scheme and we've got this
new scheme which is better
so let's upgrade these cookies in the
field rather than forcing people to log
out or whatever
we'll just transparently replace these
cookies so how would this work well they
take the client cookie and they say oh
is this an old format cookie yes great
let's decrypt the data you know check
the length that's fine okay we
conversion that's an old cookie now
let's take the contents of the cookie
encrypt it and put integrity protect it
with H Mac and send it back to them
and to replace the other cookie this is
great right anyone see a problem here
yeah exactly you can either reuse old
cookies continually or even maybe you
know create your own old cookie and
always them to the server even though
it's not issuing old ones anymore all
right that's the system type flaw
another one is your your pseudo-random
number generator so your source of
randomness your PRNG construction so
either doing a bad job with this or
poorly seeding it so unfortunately in a
lot of languages high-level languages
the default PRNG is not a good choice so
if you look at you know pythons default
random Java is default random dot Nets
default random all of these languages
provide a random number generator
pseudo-random generator class that is
not cryptographically secure so you have
to actually specify that hey I want to
use the secure version of this not the
one that's used for simulation or
whatever and a cryptographic random
number generator has to have particular
properties that don't matter if you're
running Monte Carlo simulations or
whatever so like for instance you need
to constantly reseed your PRNG as you
get new entropy because as you're
providing random numbers from your pool
you're exhausting the entropy in the
pool over time and that's not necessary
for simulation you don't care about that
you just care about having a long period
and also you want to make sure it's
impossible to guess or perturb the
internal state so let's say you have a
PR ng where you're reading in timestamps
from files on the file system Firefox
does this and if you had a poor PRNG
construction an attacker could actually
create timestamps on files specifically
to exploit the contents of that PRNG
pool at a particular point in time so
you're allowing someone outside to
control the state of that and think it
for instance force it to zero or to some
constant number then your keys are
totally insecure even though the
attacker can't see those keys directly
so you need to use a good cryptographic
PRNG
when using it with cryptography also
there's a case of cold boot where if
your server just rebooted and you're
starting to get requests immediately
that's the cell request or whatever
signing requests your servers only been
up a few seconds do you have enough
entropy to really created 4096 bit
private key
that soon and if not where are you
getting your and should be from is it
possible that you're replaying IVs
somewhere or challenge values and then a
higher level question who here is
actually responsible for this case is it
this server admin is the programmer is
it the library author is that the person
is selected the library so identifying
and knowing sort of who is actually
taking responsibility for all these
things is important another thing that
happens at a system level independent of
your particular cypher construction or
protocol you're using something called
side-channel attacks and side channel
attacks have to do with the fact that no
one gets to run crypto on a theoretical
machine you know you see all these
research papers and it'll say you know
given that the attacker has this and
that and can see two bits of this or
three days of that then this is provably
secure but crypto doesn't really work
that way so when you run crypto it has
to run on a CPU somewhere on your server
farm on your desktop on your PDA or your
cell phone runs one of these places you
can have Hardware implementations of
crypto but just like a CPU those are
running in a particular location so this
is not a true black box in fact an
attacker has some level of measurability
for instance they could possibly submit
queries to your server and see how long
it takes to get a response back so
there's measurability there's a lot of
shared state on systems even if you're
running with remote users where you've
got like let's you have different key
ssl keys for different sessions but the
crypto that uses those ssl keys runs in
processes on a unix or windows blocks
and that crypto creates little traces of
its behavior in form of you know CPU
caches whether something's on disk or in
memory branch prediction branch
prediction buffer and even like remnants
of data on the stack so all of these
traces provide some level of information
about what's happening now it may not be
enough information to do anything but
there's been a lot of useful research in
this area where you take a small bit of
information over a long period of time
and you're able to reconstruct someone's
private key additionally there's another
type of side channel attack where the
attacker has some sort of control or
influence over your choices of keys or
resource usage on your server so for
instance if I can open a lot of
connections to your SSL server I can
maybe exhaust your port P R and G C by
just repeatedly establishing new session
keys and using your PR ng that way if
someone has the access to be able to
start a process then they have ability
to use the memory of that process there
was interesting paper at USENIX security
a few years ago where someone talked
about intentionally degrading non
cryptographic hash functions so
basically if you had just a normal hash
table for you know just a database or it
was some other lookup for key value
pairs and if someone knew the particular
hashing algorithm you were using they
could create degenerate queries that
would cause your hash table to gym
degenerate to a single linked list in a
single hash bucket and so then you have
a denial of service attack against that
particular implementation so all these
are cases where an attacker has some
level of measurability or control over
how crypto is is actually running on
your system and from that they can
actually attack the crypto things like
timing attacks there's actually a paper
called remote timing attacks are
practical where Dan Bonet actually and
his team compromised an SSL private key
just by measuring the variation of a few
multiplications
on a server over a land and then even a
win so it took required a lot of
collecting a lot of samples but they
were eventually able to do it and that
attack was fixed and open SSL a few
years ago but there's also power
analysis attacks if you're if anyone
here is working on Android for instance
you know you have the people have the
physical device in their hands and
embedded systems are particularly
vulnerable because you're giving the
device to an attacker and basically they
can measure power consumption while
doing cryptographic operations they can
repeatedly trigger the same operations
over and over with different data they
can measure electromagnetic radiation
heat sound disk access patterns lists
the sky's the limit so this is the case
where a system-level problem can
actually compromise your crypto
let's talk about encryption now that's
what people think of I think most when I
think about crypto so block cipher modes
of operation I've been throwing away
around these terms so a lot of people
here have heard CBC or ECB mode ECB mode
is where you encrypts data just a block
at a time with no relation between the
blocks CBC mode is where you take the
previous block cipher text and XOR it in
before you do that encryption so you
chain together the ciphertext blocks so
that's great you know if you're familiar
with this you know you've seen these
terms before that give yourself a hand
but you know there's a lot of other
modes out there that people are using
ofbe cfb counter mode these are all
stream cipher constructions so you take
a block cipher you make it act like a
stream cipher where you're just
generating key stream and X oaring it
with the plaintext and because of that
people can just go through flipping bits
if they know the plaintext at a
particular point they can flip the bits
of that plaintext intelligently there's
no there's complete malleability there's
no integrity protection and it's fatal
if you ever reuse a counter or the key
stream output there's some new things
like CCM which are authenticated
encryption modes where it actually
provides integrity protection along with
encryption but again these have some
constraints on them like if you ever
reused an IV you basically compromised
your system so even even with people who
manufacture devices get it wrong so
here's the USB key I looked at this one
had actually a doc that came with it
they talked about how good and how
secure this USB key was yes
oh sorry it's okay ivy is it
initialization value so when you're
encrypting a message and you're using
the same key over and over using a
different IV makes each encryption
different while it's still based on the
same key so if you encrypted the same
message twice like hello hello
the ciphertex would be different if you
use a different IV but if you reuse an
IV this high protects would be the same
and so someone could see patterns in
your messages and they can also modify
your messages intelligently so this one
I said it was TD EI electronic codebook
t ECB mode which basically boils down to
we're using ECB on your USB Drive it's
not something to be proud of
another problem with encryption often
people will reuse counters in counter
mode and that's a big no-no so you
really paid attention to your design
you've got a client that's using a key
you know you've done a lot to make sure
the counter is unique maybe you say that
state as you use each time you force it
the key refresh if the other side gets
rebooted so you're not using a counter
value maybe even persisted it in some
kind of database or disk store so you're
sure that once you start up with that
key again you're not going to reuse a
counter value that's great
what about the server side so if you're
using a shared key two-way communication
with the server session key for instance
you end up with key stream you use which
is fatal for counter mode if your
counters ever overlap so in this case
you know one counters is behind the
other counter but they're in the same
space and they're sharing the same key
with key stream using counter mode
basically what's happened is anytime an
attacker has seen a single message from
you and then you reuse that key stream
later they can completely decrypt a
different message because they know all
they need to basically XOR with your
cipher text and get the original
plaintext back so never do that
integrity protection flaws so we talked
about encryption integrity protection is
how you make sure that an attacker
hasn't modified your cipher text after
you've encrypted it so a lot of people
will build their own hash constructions
anyone here like work with cookies
building your own cookies stuff like
that okay
few people so what people often do is
they'll say hey I've got this nice md5
or sha-1 here it's built
my PHP or whatever and they're saying I
want to be able to send a cookie to the
user and I don't want them be able to
modify it so I'll basically take a key
and concatenate it with the data I'm
gonna authenticate in the cookie and
shot it right you get this nice random
looking hash out if you change the key
or you change the data it changes
significantly all the bits flip great
it's working right ship it the user
doesn't know the key right you choose a
128-bit or 256 bit key and the user
doesn't no need to know it they can't
Forge these cookies right that's wrong
there's actually a length extension
attack here where if you look at how a
sha-1 operates under the covers if you
look in this little sidebar there's some
chaining variables that are initialized
at the start of sha-1 and at the end
it's basically after hashing a bunch of
data into these chaining variables that
chaining variables are returned to the
user so these these kinds of hash
functions are subject to a length
extension attack where once you've seen
the sha of some data you can always
append data to it and update that sha
result to match the data that you
appended to it so as you as you can see
here in your cookie construction if an
attacker ever got the sha of some short
cookie for whatever reason they could
then append whatever data is like you
know maybe changing their user ID or
something like that to the cookie and
create a valid cookie that would be
authenticated as correct by your your
system so you should use H Mac as a
construction instead of arbitrary hash
function constructions there's other
more esoteric attacks if you for
instance do key appended with data
appended with key again and sha that
there's there's other attacks that can
be done on that's a little more esoteric
but just just use H Mac instead here's
another standard does anyone familiar
with the IETF XML standards for soap etc
work with that great so there's a
standard called XML D sig which allows
you to authenticate your XML basically
make sure it hasn't been changed and it
worked with this thing called H Mac like
I was talking about HMA is a decent
algorithm where you're using a hash
function in a way that an attacker can't
create or Forge authenticators for your
plaintext
as long as they don't have the key but
there's a lot of problems with how XML D
sig actually specified the HTML
algorithm so anyone want to take a stab
at this one here's a valid signature of
sorts you know you would have the H Mac
of the data is stored in this XML format
so there's this there's a couple things
here there's actually two problems so
the first one is well okay it says the
output length is 160 that's actually in
bits which is good but what's wrong if I
just specify 0 for the length well now
I've got a nice shiny H Mac that no one
verifies any of the bits of the
implementation goes in and says how many
bits do I verify zero okay you pass not
very good and even if it checked for
zero you know said to one you have a
flip a coin 50-50 chance of getting the
HM @ correct and two tries you have a
hundred percent chance so also there's
another thing where it has this
algorithm specifier and what the
standard said was this algorithm
specifier is required to be supported
but other algorithms are also optional
so who knows what implementation of the
standard out there allows MD 2 or MD for
or whatever for the HM ech
hash functions which have been broken so
why is this field even here though who
is thinking that hey we can truncate h
max you know you can do that somewhat
safely and it saves a couple bytes per
message I mean a couple of bytes we're
talking about XML here all right if you
had a single comma
anywhere you would be already exceeding
the amount that you can save in this
field but actually the field itself
doesn't work for its intended purpose
because the tag itself with the start in
the end tag is 38 bytes and the most you
can safely shave off sha-1 is about 10
bytes so you lost 28 bytes creating a
new field that allows you to truncate
something to a less secure value and
gave implementers a lot of different
ways to interpret this field the u n--
optical revise and spend six months they
spent six months in IETF notifying all
these vendors you know I won't name them
all but you can go to the CV web page
and see the vulnerability of all these
systems big names basically go on there
saying yep sorry we screwed up we
screwed up we screwed up there's no
reason for doing this this was a new
stain
there is no backwards compatibility with
truncated h max no need for this
it adds overhead and is another field
that people have to validate but yet it
still persists in the standard it's
still there but now they say oh you need
to check for the value make sure it's
not less than 80 so here's another one
it's this starting get a little more
complicated so put your thinking caps on
for this so if you've got CBC encryption
with an H map okay this is better we're
improving systems here but we're also
improving our attacks so for AES let's
say you're encrypting a message block
that the message is only 14 bytes long
so the block size for AES is 16 bytes or
128 bits so you have to put something
there you put zeros in there do you put
some random data what do you put in the
remaining two bytes before you encrypt
it well with a lot of systems they have
this custom CBC and CBC padding where
you put the message length minus one in
the bytes so if your message had two
remaining bytes the last two bytes would
be set to one I've had three remaining
bytes it'd be two two two three three
three three
you get the idea this gives you a way to
validate that you've got the correct
padding value but let's say someone
implemented the system and they did a
very straightforward thing so error
turned values are good right everyone
likes to know exactly what went wrong
did you bug your system so here's two
different error values in this data
block so the first one says padding is
incorrect we decrypted it but the
padding bytes are wrong we got five five
five for instance that's not a valid CBC
padding another one is integrity failure
the padding was valid but someone
modified the message and if your
implementation returned these two
different error messages then an
attacker can actually use this to
decrypt your messages here's how it
works you take the last the ticket take
a block and it is second to last one
usually and then you set up the block
with different guesses for the last byte
of the message you don't know what the
last byte is but you're going to it
early guess this the plaintext and what
happens is if you guess it correctly
the result will XOR to a 1 and you will
basically know
that you get an integrity failure error
if you got an incorrect guess of course
you get padding incorrect and from just
these two this one bit of information a
different error message you can it early
go through decrypting the last byte then
the second to last byte third to last
until you've decrypted the whole message
you work your way backwards really
powerful attack and one that's very
subtle it's just an error code
distinguishing attack signature flaws so
most of these are public key based but
some of them are just dumb mistakes so
here's one that I hope no one's made
basically comparing a hash value to the
correct hash value very simple right
everyone can do like mmm compare or
whatever so this one actually was found
in the Wii game console people use this
to be able to attack it and load their
own games so uh what you do yeah so
you've got RSA here you're going to
basically verify signature on some
firmware update or whatever you run RSA
correctly you verify the padding data
talk about that little more later
and return you know check if stir comp
return zero
let's drink off actually well what does
this mean anyone know how string
functions different from mem comp yeah
okay so the attack basically you just
create two hundred fifty six messages
find some byte in the random in the
random padding area that you can vary
and just calculate a bunch of Shahs of
these things and once you get zeros in
the first byte you have a message that
will pass before your bogus firmware
update so here's a little python code
which will generate it for the magic
number is so if you add the number 26 to
the magic number is you get a zero in
the first byte of the sha-1 a really bad
okay
lacking structure and sign data so we're
going from very simple to a little more
complicated so when you sign data you
actually have to know what you're
signing think of signing as basically
you're you have a root shell on every
machine in your entire company and
you're gonna type a command so and hit
enter you better check twice or three
times what you're typing before you hit
enter because that's what a digital
signature is saying you're strongly
attesting that I said this
information so Amazon Web Services had a
flaw in it it basically allowed a client
to sign a URL so what they do is they
take the URL and they break it on the
common parameters you know that the
ampersand delimiter and then key value
pairs of equals between them and then
concatenate key one with value one key -
value - and then H Mac the whole thing
right so anyone see the problem with
this all right so what about these two
URLs so the first one is good key one
good value one bad key to bad value -
but that's really just a value all those
and in the second one they're separated
by the ampersand and these are two
separate keys and two separate values
these both have the same H Mac in their
scheme so you can send the first one
hiding your bad data in some unused
field like a comment field or whatever
and then get the H Mac for that then
take the one with the bad key send that
with the same H Mac and it will
authenticate because there's no
structure here - what it's signing the
delimiter is that were there were
discarded as they were signing it really
bad thing to do you need structuring
what you're signing an even worse thing
to do but a little more complicated is
some people have actually I saw this in
a microcontroller product they actually
decided they didn't want the overhead of
sha-1 so what they'll do is normally a
signing you take a sha-1 of a message
then RSA process it adding after adding
padding and you get a signature but what
they did was they say well we don't
wanna do the sha-1 step let's just take
the data that we want to send it's
smaller than an RSA block let's just
process that with the private key and
send that out as our signature well
there's an attack on that it's there's a
reason why there's padding in RSA
basically what you can do is you can
just choose some Prime's
as some messages send each Prime in to
get signed so my message is 3 my message
is 7 my message is 11 just send these in
and you get signatures on each one of
these now because RSA has the
associative property to it you can
actually combine signatures and combine
the data and the results is also a valid
signature on that new data so like let's
say this there's a
special message 21 I'm using small
values but the message 21 means delete
everything on the server so you really
want to make sure you check the
signature before you allow a message 21
in but if the attacker can sign message
3 and message seven which are maybe some
innocuous messages then they can just
take the return signature values
multiply them together take the messages
multiply them together and send that
those two together and now they have a
valid signature on the message 21 and
you get to clean up your server and this
is the same property that allows what's
called blinding which is an interesting
property I might have a chance to talk
about so anyone here familiar with like
just basic network protocols padding you
know be careful what you what you create
but be lenient and what you accept that
kind of thing
so padding is usually something you just
discard you know who here validates
every cero byte padding field in every
message you get or random padding or
whatever almost no one but in crypto
padding is not something you can ignore
so the pkcs1 signing standard actually
has a very specific format for padding
because of that previous attack I just
talked about as well as other attacks so
what you do is to sign data you prepend
some constant bytes a bunch of FS 0 0 0
1 and basically and then at the end the
sha-1 hash of the data you're signing
and this is because the hash is smaller
than your RSA block size so your RSA is
to say 2048 bits but your tall ones only
160 bits so you have to fill in that
other data was something else so you
generate the signature over this padded
data and to verify it it seems simple
right to a normal implementer it's like
hey you know I can do this it's easy you
know I first of all process the message
by raising it to the public exponent to
verify the signature then I just throw
away all the padding get a get the hash
value validate that against the message
right seems good now the attacker can
create forgeries though because for that
same 2048 bit key and half sha hash
there's another 1,800 bits that can be
any value the attacker ones because he
throws all those away you didn't verify
those byte those bits so especially with
small public exponents like 3 or 17 or
whatever this is I've actually seen this
attack in a hardware system where
they used random padding further
encryption and they didn't verify it in
any way
so because it's random and in that case
what we could do was we could basically
calculate a bunch of different values
for the message we wanted to Forge and
by changing those up or 1,800 bits which
are all thrown away you can create a
valid signature for the lower 160 bits
of your choice you have to verify every
bit of padding data encrypted protocols
and how you Pat and verify them is also
very important so remember what I talked
about before with an error distinguisher
you have to be careful not to return the
wrong error or multiple errors while
you're verifying every bit of padding so
you're damned if you do damned if you
don't in this kind of system all right
public key flaws so we talked before
about the mailbox analogy so let's see
where that breaks down so DSA the
digital signing digital signature
algorithm from often used in elliptic
curve form it fails if you know the
random value K so basically the way it
works to sign some data in DSA what you
do is you generate the signature R and s
and basically don't get too lost in the
math but basically you take a random K
you raise it to a base I'm sorry you
raise it using a base and to take the K
inverse and you have your hash your
message that's important and your X
which is your secret key that's the most
important part of this your secret key
but if you know K you can basically just
with some simple algebra refactor this
equation in terms of X and now
everything is public you know H of M
because you know your message right so
you can calculate the SHA hash of that
as good as anyone that's public
you know the R value because it got sent
across so you can calculate R inverse
you know the K that's the given here and
s also is sent across the wire so now
you can calculate the server's private
key so just by knowing one random value
from the server over thousands or
millions of signatures all you need is
just one and you can calculate the
entire private key directly it sounds
pretty bad right well it gets worse
there was that bug in Debian's PRNG
for OpenSSL anyone heard of that
advisory opensl yes a couple of people
okay great
for those who didn't hear about it
basically what happened was someone
commented out essentially one line of
code that was all the random data that
was being fed into the their PRNG to
seed it and therefore the only bit of
varying data that went to their PRNG
was the the current process ID so
there's about 15 bits of entropy going
into that you can easily exhaust 32,000
values really quickly so this was a bad
bug right well people were out there
going okay how many open SSL certs do we
need to reissue whatever whatever the
real question they should have been
asking is how many packages have we
signed using DSA with a vulnerable
system because everyone who issued a
single package including old ones that
are in the archive an attacker once they
know that this problem exists can go out
there and it can basically sorry they
can basically go out there look at the
signature look at the software and
basically say okay I can calculate
directly what the person's private key
was so you have to revoke every private
key that was used to sign a package on a
vulnerable system not generate keys so
generate keys is bad enough every key
that was generated has to be revoked
that's what revoke any key that was used
even if without your knowledge to sign
something on a multiple system it's a
big deal but it gets worse
so crypto attacks always get worse so
there's an additional very surprising
finding that's not it's not really well
known it's somewhat know in the crypto
community but even there it's a little
bit less well-known that basically even
if you know only a few bits of K and can
get a lot of signatures you can
basically use this to recover the
private key but it's something called
the hidden number problem which is a
bunch of number theoretic stuff but
basically what it devolves to is that
you're using a lattice reduction to
basically look at all these numbers
which are partially known and you're
finding little bits about and combine
them all together in a giant lattice
where you can use little bits of the key
in multiple places to recover the entire
key and very very awesome research by
Bonilla and other
on that so the question was you know how
many is a few bits so it varies based on
how many messages and signatures you can
collect the less fits the more messages
you need so but it's theoretically
exploitable down to one bit so if even
if you could predict one bit reliably of
the K and get a lot of signatures you
can recover a private game so this
question is you know can you just take a
guess zero or want it and try that yep
but the number of messages is really
large so because because if your if your
PR energy is good if you see that it
well the chance of you getting a zero
one is 50% approximately for each of
those signatures as long as there's no
bias there in that in that bit you're
okay but if you know it for sure for
certain for instance if I know it's zero
and now I know it's one of no it's no
it's zero then I can use that
information to tax system okay we'll
cover them what we have more Q&amp;amp;A at the
end so here's here's another thing of
confusion of terminology I'd say so
people talk about I'm going to encrypt
something with my my private key right
okay so DSA it's our RSA RSA has you
know public key and let's say that
you've got some device you've got a cell
phone your cell phone has an RSA key in
its flash it's a public key and what's
going to do is it's going to verify that
your Android updates came from Google
right you want to make sure that you
have the right firmware that you're
going to install on your system it's not
a Trojan or something so you take this
you could take this public key and you
can verify the signature that's all fine
okay we're okay so far someone comes up
with a bright idea they say well we also
want to encrypt our updates and we don't
want to be able to only have to put
another key in there we just want to use
the RSA key we already have we're gonna
encrypt and crimp to the updates as well
as verify the signature that way people
can't find out you know we've obfuscated
what code we're loading and what the
update is so they said well let's keep
the public key secret this doesn't
actually work you can't keep a public
key secret that's an amazing thing about
RSA anyone connects
see your signature updates your firmware
updates if they can see just two of them
and two signatures they can just using
some straightforward algebra calculate
what your public key was notice they
can't calculate or private key but they
can calculate a public key so this is an
example using GCD and two signatures how
to guess the modules N and at that point
you know en N and you know the person's
public key so this is an example where
conceptually it seems fine if you have
two keys and you're not revealing one to
an attacker they shouldn't be able to
guess your key right but because of the
particular properties of RSA if you can
see something about that key some
results that key being used
you can always calculate the public key
now the private key you can't do that
anyone here heard of SRP it's a password
based game good
so SRP is a great protocol and it's
actually a family of protocols that what
it does is it gives you password
authentication without people be able to
do dictionary attacks on the password
that goes by on the wire for instance
and at the end of your negotiation you
end up with a shared key between the
server and the client that you can use
for encrypting things so SRP plus SSL is
a great combo because instead of having
this ad hoc construction where you use
SSL to connect to the server then you
type in your password in plain text over
you know standard base 64 encoding and
password submission
SRP actually allows you to use the
password to derive the session key and
that goes in the SSL so it's great it
works you get authentication plus
encryption and a user login and all that
this is a description of the protocol
seems easy right I mean everyone got
that yeah so there's a bunch of numbers
going back and forth bunch of steps we
have to look up or verify various
parameters and like all public key
crypto SRP is very sensitive to what
these values are so here's a particular
bug if you look in step 3 and step 5
what if the attacker just is the client
they send a value a equals zero this is
just some random data to the ghost' of
the server and then you see this little
multiplication on the right side so it
gets multiplied by some stuff
and equals capital s well capital S is
is if you go back to the original thing
is part of how it uses to verify that
you're authenticated or not so the
server does this fancy exponentiation
twice and multiplication times a with
all these private pieces of data and
things like that and get to the value 0
well obviously the client knows that and
can predict the result so there are
other bad parameters x 4's repeaters
like about 10 things you need to verify
that sir P to be sure that a client or a
malicious server and someone
impersonating server can't screw up your
exchange there and there's actually more
attacks I could go on all day about all
this there's an attack against tor and I
keys which is part of like IPSec where
thing called diffie-hellman small
subgroup compliant confinement whereas
if you let the client choose certain
parameters of how you do the encryption
they can basically force you to choose
one of a small set of signatures like 0
or 1 and there's also things where
people have decided let's use a CRC for
integrity protection just encrypt it and
hope people can't modify it that failed
for SSH v1 that's why we use SSH B - now
fault injection where you actually have
control over the device and you're
sending in voltage spikes or whatever to
try to induce false and RSA signatures
and from that you can extract the
private key so all of these attacks are
interesting and there's a lot more of
them so what do you do about all this
anyone
well as I said at the beginning there's
a lot of good reasons for not doing your
own crypto and if you're working
directly with ciphers like AES PRN geez
unless you're really a crypto system
designer and you're willing to spend the
ten times the review time it takes to
really be sure you got it right just
just don't do it you know work at a
higher level use things that are already
there like SSL GPG these are already out
there there will validated you're free
and available systems use this as your
first resort and if your design can't
fit that really try to rework it see is
there any way we can change how we share
state or whatever to reuse this these
capabilities if you really can't do that
the next best option is use a high-level
crypto library not a low-level one use a
high-level one where you get primitive
or the interface to it is something that
for instance you say take this encrypt
and authenticate this blob and it
basically provides you back a sanity
check component that you can pass along
so high level libraries are good crypt
Lib and keys are both pretty good and if
you ever end up using something like
this especially if you end up having to
regenerate your own crypto by using
low-level crypto primitives make sure to
get a really extensive review of it I
mean there's a lot of ways
cryptographers publish all their stuff
because they know that the peer review
is the best way to be sure that they
don't make any mistakes
but just publishing code open source
doesn't guarantee you're going to get
that kind of review so if you have to
design your own make sure you spend the
time and resources to really get an
extensive review you have some people
here that know about crypto a little bit
and or a lot and would be great
resources for that so now open up to
questions and any comments Thanks
I think questions I'd like to ask you to
line up at the mics some people on the
VC can hear them
there are no questions I'll just go on
and on about IKEA or something
how do things like the HTTP Mel bite
bugs survive for so long okay the
question is regarding a recent
publication at blackhat of to
researchers independently found a
problem where they can request a
certificate on two values one that's
malicious and one that's not and this
name that they would request for the
certificate would be you know a one name
with a null by following it and then
another name and it turned out that the
CA the person who was generating the
certificate would validate one of the
fields up to the null byte and the
browser who is responsible for using the
certificate would validate the other
half and so the attacker can carefully
provide both halves and each party would
look at the part that they care about
most
which is great for the attacker this
would allow you to get a certificate for
you know amazon.com or Google comm or
whatever and have it validated by common
browsers how does this persist along a
couple things first of all the people
who write the software for the CA are
different from the people who write
software for the browser in fact each
browser sort of has its own different
crypto implementation you have NSS in
Firefox you have Microsoft crypto API
and opera and Conqueror and all these
others and you know Apple and has their
own as well
Safari and all of these use different
crypto implementations so it's
conceivable that one Krauser could have
been vulnerable to it and made that
mistake while all the others were fine
so the problem is is that there's a lot
of software out there there's a lot of
different people creating different
parts of it and they're not all working
together and you don't have someone I
mean I don't know anyone who's been
hired to review both the CA software and
a browser crypto engine to make make
sure that these kinds of mistakes aren't
in there so it's just a lack of overlap
between different work problem domains
any other questions
the attack you were talking about where
you would put random things in the
padding and eventually work them out
because of two different error messages
I understand how you could work out the
padding but once you start going into
the message I don't understand what how
the logic would be there okay that's a
good question
it's it's a little bit difficult to go
into all the details of it so I'll try
to give a brief summary so for the CBC
padding attack where you can distinguish
between the two different errors the the
property of CBC is that given the
particular XOR construction of it you
can actually if you know bits of the the
plaintext of a block you can modify the
bits of the previous ciphertext block
and cause chosen changes in the
subsequent block while garbling the
previous block so there's this problem
of you can make changes in it and you
can you can basically garble one entire
block while making specific changes
which don't result in any garbling to
the next block so if you can get this to
line up the right way for instance on a
padding field that no one verifies then
you can intelligently make changes in a
CBC encrypted message without knowing
all the details about all the blocks so
this attack actually is not based on
that though what happens in this attack
is that you know what you're trying to
produce in the plaintext in order for
the client to or the server to accept
the result so in other words if you have
a single byte remaining so you know 15
bytes or whatever you might want the
last bite to be a zero and since the
length is external the attacker can
truncate the length to whatever want
whatever they want it's like let's say
the original length of the message I've
seen is that they want to decrypt is you
know 32 to 2 AES blocks so they could D
they could decrease that counter to 31
because it's not protected in any way
and then change the last byte of the
subsequent of the second-to-last block
and as they change this they don't know
what the actual plaintext value is but
once they get the value correct the XOR
of two numbers that are identical is 0
right and 0 XOR some number is
that number itself so once they can get
the difference to basically be one
between these two or zero in that case
they've guessed the last bite and now
since they know for what they can set
that bite to be constant and they can
choose that to be whether they wants not
they've guessed the last bite they can
change it so it equals one in the next
round and they send that message again
to the server so that the last bite is
now set to one and then they keep
flipping through the second to last bite
until they get that one to be matched to
be one then once we have that correct
they know the last two bites and they
can iterate it that was a night attack
was found by a guy named Serge Vaadin a
questions
oh well there are no more questions I
just like to think Nate again and give a
round applause</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>