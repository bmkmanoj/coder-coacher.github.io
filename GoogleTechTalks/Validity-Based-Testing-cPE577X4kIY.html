<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Validity Based Testing | Coder Coacher - Coaching Coders</title><meta content="Validity Based Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Validity Based Testing</b></h2><h5 class="post__date">2018-01-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cPE577X4kIY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to be speaking about validity
base testing today the slides are online
and you can find them right there I just
wanted to put that up so you can
actually follow the slides along if you
want to the slides are just marked down
or it's just the big text file with that
let's get started to start off the
motivation I need us to all agree that
there is a situation that happens every
so often which is where you have
invariants in your program in first off
maybe I should have a look who here
writes Haskell as ever written Hosko
there anyone who cannot read Haskell I'm
gonna be showing you quite a bit of
Haskell code if you can't read it that's
fine you should probably be able to read
it if you've ever done any nuts but it's
good to know who is the dumb not sorry
who's ever done what I'm going to be
showing you is how score code but all of
the principles also apply in other
languages at least it should and the
library that I'm going to be presenting
could probably also be rewritten in
other languages it just so happens that
it's rather easy to do in Haskell and I
have not tried another Rigas so when we
have invariants or our data types we
usually just write a comment says that
says invariant there is this invariant
on our data type in this case I can
define new type over integers that
represents that this integer must be
prime and then the invariant says this
prime that is contained within this
constructor needs to be prime or this
integer needs to be prime for this prime
to be valid it would be much nicer and
also as it turns out much easier to deal
with later if we can actually explicitly
define the code that will check whether
this invariant holds true and for that
we made this type class called validity
which allows you to specify with this
function called is valid what it means
for your value to be valid for any value
of your specific type that you declare
to be an instance of this type class you
specify this is what it means for my
value to be valid and there are clear
semantics for what is valid at issue how
they should behave is this should be an
under approximation meaning that for any
invalid value you must say that it's
invalid for any valid value you should
say that it's valid as long as you keep
to these semantics you should be fine
with respect you say see later now we
have some standard instances for example
we can speak about the validity of Lists
if we could speak about the validity of
the elements in the list and because of
these strong semantics that we've talked
about earlier it's really easy to define
the validity of bigger types given that
the validity of that type is only
defined as the validity of the supports
and then in fact the library can write
all the code for you so you just say
this type should also have a validity
instance and then the entire
implementation can be generated by just
the last line on this way now that we've
defined what it means for a certain
value to be valid we can ask is this
value valid but the problem is once you
find a value that is in fact invalid you
still are no closer to figuring out why
it is invalid so here we have a list of
supported Prime's and it turns out this
list is invalid but we can't figure out
why it's invalid based on just looking
at the results so there is a second
function in this type has validity
called validate which allows you to
figure out why something is valid or why
it is invalid and then if you look at
the same list of primes I showed earlier
you asked why is this valid or not and
if it's not valid why is it not valid it
will tell you the third element in the
list there is a problem namely that the
variant that it has been violated and
this invariant is called Prime and then
you can immediately see oh six is indeed
not a part now every sudden everyone saw
with me up until here now I'm going to
be talking about how we apply this to
testing but I need to take a bit of a
detour just to define some firm there
will be speaking about in testing
specifically so when we look at the most
basic kind of test which I will assume
to be a unit test the idea is to run a
piece of code if the code crashes we say
that the test fails if the code doesn't
crash we say that a test passes you may
say well there are some details with
assertions for example and I will argue
assertions are just a smart way to make
your code crash so the the fundamental
definition of a unit test is some point
some piece of code if it crashes then it
fails if it doesn't crash then we say
passes so this is the unit test we
define property tests as something like
a unit test but now you also take an
argument this piece of code that now
takes an argument if it crashes then it
fails if it doesn't crash then we say
the test passes so we say that my test
passes for four as an argument so this
is a property test applied to the
argument for a random property test is
similar but now you will choose a random
number you will choose a number and run
the test for random arguments that
number of times we say that a test
passes if it passes for every one of the
arguments we say that the test fails if
it fails for any one of the arguments
then there is also exhaustive property
testing which is where you go over all
the possible values of the certain
argument that is the input there is also
specialized exhaustive property testing
which is where you take a subset of the
input argument type and go over all of
the values of those as an example we
take the prime type I showed you earlier
you wouldn't give all possible integers
of the argument but all possible Prime's
which is there are details
we've gone over there but that's the
idea then there is also specialized
random property testing which is where
you take random values of a special
subset of the type you're looking at or
a given number of tests we say that the
tests passes if for a certain number of
values that are randomly generated from
the subset of the type that you're
looking at all the specific sub tests
pass now how do we do this in practice
there is a type class called arbitrary
in quick check go check is the property
testing library that we usually use in
hospital which specifies what it means
to generate random values of a given
type so for any type that oops I need
type instantiates arbitrary there exists
a function called arbitrary which can
generate random values of this type so
arbitrary int means that there exists a
function or rashard which can generate
random integers then we have a separate
function called property which allows
you to turn any function that takes an
argument that can be randomly generated
and returns a boolean to turn that into
a test and then there the quick check
framework will take this function
generate random inputs and test it for a
hundred cases if it passes and it passes
so this is one of the cases that I
talked about earlier now as soon as you
go to specialize random testing you get
into trouble for example if you wanted
to test functions that deal with primes
you run into issues specifically how
would you implement this instance of
arbitrary for crimes there are some
considerations so the first thing you
could do is only generate valid values I
will argue this is the wrong thing to do
because then you can never generate
truly random values of
the type of prime if you only generate
valid valid are used you will never
generate prime SiC for example if this
prime six ever occurs in your program
and you haven't tested against it you
run into safety issues you can also
generate all possible values but this
may all be also be the wrong thing to do
because a lot of the functions you deal
with are supposed to only deal with the
valid values and you don't care about
whether they work for invalid values so
then you only want to test them for
valid values you can also say oh we can
write separate generators for each of
them but this may also be the wrong
thing to do because now you lose the
entire composability of these tests that
you can possibly put together for
example if you have a function called
associative which can test whether a
certain binary operation is associative
by generating random inputs and seeing
if this oath if associativity holds and
you have a separate one for identity you
can put these two properties together
given that the input can be randomly
generated in the same way but as soon as
it started requiring separate separate
generators this is no longer possible so
we've solved this in a different way we
said we'll take two separate type
classes the first one is called gen
unchecked which allows you to explain
how to generate truly unchecked
arbitrary random values ignoring all the
invariants as opposed to arbitrary this
has very clear semantics all possible
values that could exists at runtime
should be there should be a probability
that they're generated and because these
semantics are so clear now we can let
the compiler completely generate the
entire implementation of how to generate
these values the second type class that
we've made is called Gen valid Gen valid
allows you to specify how to generate
valid values but again because the
semantics are so clear according to
validity we can generate the entire
implementation and in fact the default
implemented
rather simple generate an unchecked
value if it's valid then return it if
it's not try again now as you may
imagine this can be rather slow for
example if the predicate is expensive to
calculate for example checking whether a
number is prime or if there aren't a lot
of valid values that will be generated
by genuine checks for example primes
in that case you can also write your own
generator which is what I've done in the
second half of the slide in this case it
says generating a random prime means
either generating - or generating a
value making it odd and then checking if
it's prime and then all value is more
likely to be prime than an even values
that's the idea of the second generator
and you can make this as fast as you
need it to be for your test to run fast
enough now that we have this entire
framework of validity general check gen
valid and there is also gen invalid
which you may you can it is it does
exactly what you think it does now we
can write more general testing
combinators that will make the entire
property for us and we can just supply
the functions that we want to have
tested instead of having to define the
entire property ourselves every time so
for example if we have a function that
could possibly fail by returning nothing
instead of just a value then we can now
say this function fails whenever you
pass it an invalid value as the argument
we can also say in the second example
whenever this thing succeeds it will
return a valid value the third one is
whenever you give a valid value it will
succeed so you can write very general
testing combinators because there is now
this framework and in fact all of these
have been written already so you just
have to plug them into your test suite
and start using them but why stop there
you can make your properties not just
for anything that fails or for specific
things related to validity but this also
solves the problem of what to do if your
functions only care about valid values
for example the first Combinator that
I've written here at the top is called
equivalent on
and it checks whether two different
functions are valid as our equivalence
but it only cares about valid arguments
we don't care about whether these two
functions are equivalent when you give
them invalid arguments so only valid
arguments are generated and tested
against there is something similar for
associativity the third one says these
are two functions that can both fail we
can both possibly fail in separate
different ways but whenever they succeed
we want to make sure that if you apply
them one after the other then you get
the original argument X so you can write
very very general testing Combinator's
to make the properties for you instead
of having to write all of these
properties yourself but we can go even
further you can generate entire test
Suites by just looking at the type this
is a assuming you already use an a given
test framework you can start writing
those test Suites you're generating
those test Suites for example here's an
apple and an example if you use H spec
which is where spec is an entire test
suite now I can say I wrote this custom
instance for ordering my specific type I
want to make sure that this ordering
still makes sense so you say or spec at
my type live so now it's a force back at
my type and it will generate the entire
test suite that makes sure that the
ordering instance for your type makes
sense
for example equality needs to be
reflexive inequality or sorry more than
or equal to meet the Venerable all other
need to be answer reflexive etc etc you
can also say this only needs to make
sense if we're dealing with valid values
for example for doubles we've chosen to
define not a number to not be a valid
double in which case
reflexivity holds for doubles
for valid values etc you don't have to
stop there you don't have to stop at
simple or type kind of types you can
also for example test whether the
functor laws hold for your function for
example here is an example of the output
of what you see when you say check
whether the function laws holds for
lists and it will generate the entire
test suite for you these are the baked
in type classes but you can also make
these for custom libraries for example
we have something similar for Jason in
census so you can say I have a custom
instance that defines how I want to
serialize my value to Jason and back now
generate me the test suite that will
check whether this makes sense if you
encode it and you decode it then
everything is alright if you encode it
then we'd go and crash anywhere if you
decode it that it returns an error
instead of crashing that kind of thing
now these are all the different kinds of
tests that we can generate so now we
actually have to write very little code
to test our entire does it make sense
part of the code and not the business
logic so this is all of the code you
have to write just to be able to start
using these functions so you have to say
this is my type my type is a generic
type which means that we can deconstruct
it ahem
on a library level as a poster on a
compiler level it needs to be generated
for arbitrary values we define validity
in this case we don't define custom
didn't find custom validity so it just
means using validity of the support and
because this is all and it needs to be
possible to generate valid values and
now you can immediately start using all
the functions that use your type and
start testing them based on the standard
properties that have been defined in the
library by the way also all of the
combinators have separate versions where
you can supply your own generators here
are some custom
companion libraries that have all of
these generators for entire test Suites
built in already for specific companion
libraries that are used a lot for
example for Jason for binary instances
and for hashable instances this is all
defined for you already that's all the
slides I have but I have a bit of a demo
for you as well let me see if I can make
that work see the running of a test
suite of a library that uses this kind
of test I use this in production a lot
so let me just show you also what it
looks like if you write one of those
I say I have some settings and I have to
find my own equality so I quality needs
something sent I sir that generating
valid values actually generates valid
values and I'm also I also have a custom
Jayson instance so I need to make sure
that these Jayson instances make sense
with respect to you applying them back
and forth the next step which we're
already working on is to do this all for
you as well which means we will have
some custom code that will look at your
entire library look at all custom
instances you've defined and then
generate all of that does it make sense
that's for you as well one that I mean
that that's the the end of the line for
this kind of library there is also a
similarly interesting way of doing
things that I've been working on on a
completely separate project which is
where we look at your code and figure
out what your code does propose to you
hey is this what you think your coach
would do and then generate the test for
you as well the idea the entire idea of
this of the these kind of projects is to
make testing your code easier than not
testing your code to make it cheaper to
write correct software than it would be
to write any correct software I'm more
interested in the practical how can we
make this work because acknowledging
that we're dealing with humans aspect of
dealing with this as opposed to the
industry way of we know they don't use
it but it would be nice if they would
kind of really this is all make sense of
you all right this is all of the content
I had if there are any more questions
I'll be very happy to answer them if you
want to take me apart later and we'll
also be here for at least five more
minutes after the talk they'll be very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>