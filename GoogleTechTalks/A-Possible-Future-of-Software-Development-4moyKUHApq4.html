<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Possible Future of Software Development | Coder Coacher - Coaching Coders</title><meta content="A Possible Future of Software Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Possible Future of Software Development</b></h2><h5 class="post__date">2008-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4moyKUHApq4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon hi my name is Mark Paul
eager engineering director for client
applications and I'm here today with
Sean parent from Adobe Systems Sean and
I have known each other since 93 94
something like that long long time when
we worked together at Adobe on the
Photoshop team and Sean has done a
tremendous amount primarily in and
around photoshop up until recent times
for the work that he's gonna be talking
about today
put amongst other things automation and
UI layout and just a transfer capability
into Photoshop and of I guess the last
couple of years has moved on into more
of the the research side of Adobe and
has concentrated on areas primarily
centering around STL and Adobe additions
to them and also sort of looking at the
whole problem of user interfaces and
their complexity and behavior and why a
lot of the software that we have works
maybe despite itself and despite the way
that it's it's built so with that I will
turn it over to Sean okay so it's my mic
on yeah so that was a nice introduction
thanks mark I've been at Adobe now for
something like 13 years and about the
last four years working in in either our
advanced technology group or now I run
our software technology lab which is a a
small team trying to rethink how Adobe
goes about building software now this
talk came about because byung-eon is
true strap who created c++ invited me to
give a talk down at texas A&amp;amp;M and said
you're in the industry why don't you
come give a talk to the students about
the future of software development and
I said I don't know about the future of
software development I know about what
I'm building which is hopefully the
future of software development so I'll
give a talk on the possible future of
software development for those of you
who don't know much about Adobe a little
background information for a big and
growing company about two and a half
billion dollars of revenue not currently
nearly as fast as Google or as big as
Google but we've got about 6,000
employees worldwide very distributed we
do a number of products some of these
you've probably heard of so internally
we're structured loosely like this it it
varies from business unit to business
unit but we have product lines so
Photoshop is not just a product it's a
product line there's Photoshop Elements
Photoshop extended edition and we have
product teams where we typically have 20
developers working on a product team
about 30 testers which surprises most
people more QE than engineering
typically one or two of UI designers
working with the team and then we have
about 20 share technology groups which
all have similar structure to the
product teams dealing with libraries for
vector graphics typography color help
localization sure things like that so
development process we strive towards an
incremental development process but the
business were in tends to push things
into more of a waterfall process there's
a huge lag between the time say you have
to reserve press to print the manuals
and the manuals have to be done between
you when you can actually ship the
product since we do physical boxes
getting everything done in the
quantities we demand takes a
manufacturing ramp and that tends to
push the development cycles into more of
a waterfall model where you sacrifice
quality early to get the features in so
you can write the manual and ship later
we ship mostly Macintosh and windows
simultaneously English French German
Japanese are Tier one languages and by
the time we're done usually about three
months after the first ship
we've covered about 24 languages with
the products so if you're gonna talk
about the future of software development
I thought I'd do a little research on
what do the analysts say you've got lots
of buzzwords I spent some time going
through analyst reports you hear lots of
about Java and c-sharp and XML and web
services and open source and some of
these things I agree are important and
some I don't think are very important
best practices and methodologies is is
listed first up there because that's
where most people think the problems are
I pulled some quotes from analysts that
I just thought were interesting the
second one being the most interesting
Microsoft's rolling out a new
development process this is a directions
on Microsoft which is a analyst
publication that's usually very friendly
to Microsoft and the fact that they
would go through the trouble of putting
together a whole development process
when analysts say they don't think it
will necessarily help the company ship
its products on time or with fewer bugs
the top one is talking about the problem
of security and and the number of
analysts who believe that the solution
to security is more and more testing
which I think has a very very
diminishing returns if you already have
30 QE people to 20 engineers if you
double that to 60 QE people testing for
security holes you might find you know
another quarter or half of the security
holes out there you're not gonna close
the holes that way ultimately though
this is why I think the status quo and
software development fails this is a
quote from John Bentley from his book
programming Perls published in 86 John
went around teaching classes on on how
to develop software and gave a test to
mostly senior engineers at IBM in Bell
Labs and asked them to write the binary
search
problem given a specification write a
correct binary search 90% of the
programmers failed finding bugs in their
solutions and of the solutions where
they couldn't find bugs many of them
they still weren't convinced that they
were correct okay to put it in
perspective this is a correct solution
to john Bentley's binary search problem
okay and they were not given just like a
few minutes to do this they were given
several hours to try to do this
Photoshop uses the same problem and has
for many many years as a take-home test
and more than 90% of the candidates just
failed miserably at coming up with
anything remotely resembling this piece
of code I think the worst case is
probably 48 pages or something like that
of code and once he figured out what the
48 pages of code did it was wrong so
that's a problem now John Bentley's own
solution is considerably more
complicated than this solution okay and
considerably less efficient so our
experience at Adobe in teaching
programmers is that the same rule holds
and you can take you know PhDs from from
Stanford which comprises large section
of Adobe's advanced technology group and
90% of the PhDs from Stanford can't
write a correct binary search so how in
the world do we ever ship a product okay
if you can't write that much code
correctly how do you get Photoshop out
the door how do you get word out the
door how do you get Google Desktop out
the door well these are actual bug
graphs from product cycles inside of
Adobe and this is a clue what's going on
here is we're not solving problems we're
approximating solutions and some of
these curves this one in particular I
don't believe what happened here
is there was a projected ship date out
here the little peak here is because QE
stayed over a weekend to finish their
regression tests well engineers went
home so you had a little peak which
caused a panic which led to a nearly
linear slope the linear slope is not
fixing bugs it's deferring bugs ok so we
never hit a 0 bug count even pretended
to here you'll see we're still off 0 but
in reality what's not showing here is
the number of bugs that were just plain
deferred that's the bottom so that's
what a current programming methodologies
do they allow us to iterate and refine
and approximate a solution but never
actually come up with a correct solution
so one thing my team is working on is
studying how do we go about writing
correct software ok if you if you want
to write it correct to begin with how
would you go and do that and this leads
us to generic programming where my team
spends a lot of our time the idea with
generic programming is you start with a
concrete algorithm you refine the
algorithm reducing it to its minimal
requirements clusters of related
requirements are known as concepts and
we have a little more formal definition
that we'll get to in a minute then you
define the algorithm in terms of this
concept supporting maximum reuse so if
you have an algorithm and you can then
prove that it's a correct algorithm now
what you want to do is lift out that
algorithm so it's written in terms of
its minimal requirements so that you're
going to reuse it in the most number of
areas now there's a parallel here
between mathematics and generic
programming programming is mathematics
in generic programming we have what we
call semantic requirements in
mathematics they're called axioms ok
well we call a concept in generic
programming is an algebraic structure
like a ring or a mono I'd in mathematics
models we use the same terminology
in computer science and then generic
programming will what we call an
algorithm is just a theorem okay so an
algorithm is written in terms of concept
just as a theorem is written in terms of
an algebraic structure both rely on
axioms for the correct definition so a
regular function a function with no
side-effects corresponds to just a
mathematical function and the one thing
we have as computer scientists that
mathematicians don't have to worry about
is complexity right we have to worry
about how long does it actually take to
compute the answer here now we can
refine a concept just as mathematicians
can refine an algebraic structure so a
mathematician would say that a mono it
is a semi group with an identity element
if you ever took any abstract algebra
okay that's an equivalent statement to
saying roughly equivalent a
bi-directional iterator is a forward
iterator with constant complexity
decrement okay so you can take a concept
and add additional axioms semantic
requirements okay in order to refine it
and that will give you something which
is in some sense more powerful in that
you should have algorithms that you can
execute more quickly on it more
algorithms but you'll have less models
okay less types that you can actually
use with this thing we also refine
algorithms which is something
mathematicians tend not to do
mathematicians typically do not refine a
theorem a refined algorithm is saying if
you have a a concept which is itself
refined then you can perform the same
operation that you could on the
unrefined concept on the refined concept
but potentially you can do it with
better complexity or reduce space
requirements
so in C++ this is the way concepts
appear in the existing C++ standard they
are tables that appear in the standard
itself they're not expressed in code and
in fact the tables are very very weak on
their semantic requirements on this end
so my group takes it a bit more
seriously and apply as much stronger
semantic requirements to what each of
the axioms are so we're here by backup
we define the notion of copy to say that
T is equivalent to you the reason why
the standard uses equivalents instead of
equals is because it doesn't require
that equal be defined in order to define
a copy but if you want to define what it
means to have a copy then you have to
require equality
now concepts enable equational reasoning
about your code just as as axioms and
algebraic structures enable equational
reasoning about mathematics through
concepts you can prove algorithm
correctness okay and you can then reason
about your system in its entirety
generic programming often gets confused
with you know angle bracket templates in
C++ generic programming is not a
programming style as object-oriented
programming is a programming style
generic programming is a way to reason
about code I can reason about code
through the axioms defined through
generic programming even if the program
is written in an object-oriented style
okay the same axioms hold so the axioms
have to exist and the theorems have to
be correct if the system functions
correctly and works and where it doesn't
it's because something's been violated
okay so you can use the same ideas from
generic program its programming to
analyze an existing piece of code as
well as a right of correct piece of code
now in C++ it's pretty horrible right
now so we can't do generic programming
in the language so what we do is we
approximate it with templates which are
really just macros and we have comments
so when I say type name I or in this TL
that might say tight name input iterator
or you know random access to the rater
and here I say imodels random access
iterator just to be a little more
explicit random access iterator is
naming a concept that you can formally
define regular is naming the concept you
can formally define in fact that was the
definition of regular couple slides back
okay so in C++ 0 x if anybody's been
following the progression of the
language much of what's written you up
here in comments you can now write in
code in your C++ so this is a big part
of what my team is working on now this
brings us to a small pause in the talk
okay so great so we can write sort we
can prove sorts correct and we can write
reverse and maybe we can write some nice
image processing algorithms going this
way so how do you get from there how do
you get from forward iterator to
Photoshop it just seems like this very
large chasm okay how do you get from STL
to Microsoft Word how do you span that
gap so we're gonna change gears a little
bit here I have a conjecture which is
that all systems eventually grow and
turn in to some kind of network problem
okay so if you have any problem of scale
what that usually means by a problem of
scale is that you have to be able to
reason about the system as a whole by
being able to reason about it locally
okay such systems become graphs with
sets of rules that apply to the graphs
and those describe an awful lot of the
systems that we build so if you go and
you look at Photoshop what you'll find
internally is it's become this massive
network of objects these objects are all
interconnected they form some giant
implicit data structure there is
messaging between the objects so those
messages do something hopefully that's
an algorithm
we use tools like design tool or like
design patterns Scott Myers you know 50
rules for writing the C++ program to
come up with local rules that if we
apply them hopefully we get a correct
system out the back and then the once we
assemble all these objects we
iteratively refine and refine and refine
and refine until we can ship the product
until it's good enough so take a moment
and define a generic algorithm for
solving a large system if you're if
you're just you know build word how are
you gonna go do it well identify the
components and how they connect this is
my generic organize the system into a
directed acyclic graph okay
everybody know what a dag is hopefully
engineers here so the reason why a dag
is important okay if you have a dag is
just a directed graph with no cycles so
if you have a cycle in your system it
makes reasoning about the correctness of
that system very difficult ok you can no
longer reason about the correct
correctness of the system with the only
local knowledge you have to have
complete knowledge okay and know what
the effect of that data feeding back on
itself is so you want to define your
system in terms of a dag now of course
you're gonna have loops you're gonna
have things that do iterate and what you
want to do is encapsulate those figure
out where the loops in your graph are
and figure out what the algorithm is
that's done by that loop and write that
algorithm and make that algorithm be
just a node in your graph it becomes
just a processing node in your graph and
then ensure that for all possible states
in the system
you know this dag is gonna be changing
things or conditional stuff coming off
on and off
that cycles don't pop up okay that this
thing stays a dag and then make it
generic which means once you have this
forward figure out how you describe
similar structures to build other
applications now this all sounds very
complicated but the idea actually for me
came from this one of the things I
worked on at Adobe was a layout engine
which is used in most of the Adobe
products at this point to layout user
interfaces and it's a constraint system
of sorts but it always forms DAGs and I
had this realization one day that I
could solve a spreadsheet inside of the
layout system and that I could turn the
layout system into a spreadsheet if I
wanted to and this is why they both form
DAGs so this is just a graphical
representation of this we're just
summing up three numbers well I can draw
it like this okay I've got three cells
feeding into a plus operator and coming
out with one result when you start to
talk about constraint systems and
declarative programming which is what
we're talking about here people have a
panic attack
mostly because in school they might have
been exposed to the wonders of prologue
prologue is a rule-based system in some
sense a spreadsheet is a rule-based
system but prologues was striving to be
a turing-complete system a complete
programming language where you could
write anything you can sort in Prolog
you really don't want to sort in Prolog
okay so sorting is an iterative loop if
you have a rule-based system that's
iterating it becomes very difficult to
reason about so what we're talking about
here is more the long along the lines of
something like HTML or a spreadsheet or
SQL or lexing yak
those are also declarative rule-based
systems of sorts okay
let's strive not to be turing-complete
some of them are accidentally but in
general you stay away from the scary
edges so part of what my team has been
working on is something called the
property model library which is to apply
these ideas to a real system and this is
the domain we went after it's a piece of
a user interface so this is the data
flow of a small section of an actual
user interface in a product that
mark-paul eager is very very familiar
with the the symbology here are
basically these four items in the middle
are widgets UI widgets you can think
about them that way so the top two
editing numbers the bottom two or
checkboxes just boolean x' and we have
some code that sets up the dialog so it
populates these widgets with stuff and
then we have a bunch of event handlers
so if I enter a value into one thing
then it percolates and changes the
values in my UI and I literally went
through the code and drew a connection
drew an arrow anytime one piece of code
was connected to another piece of code
data could flow from there to there and
the complete section of this dialogue
has 14 widgets I think in the middle I
stopped after four and said screw it
it's just a big ball of spaghetti I did
add this one box down here which is
script validation so what's happening
here is you know we have UI this is is
setting an image size for a particular
width and height and you can also drive
it without a UI attached by executing
the script and all the validation logic
that's contained in the spaghetti code
of event handlers has to be replicated
into the script validation code so that
you make sure that you know whatever I
record up here I can play back without
the UI and not end up with an error
so in fact if you look at Adobe's
codebase a third of the code in our
products ends up being event handling
code of this sort part of the big ball
of spaghetti and if you survey our our
bug database you'll find that half the
bugs during a new development cycle are
in this body of code now when I first
saw this I thought cherry-picking go
after the this problem I come up with a
solution and I'm the hero I eliminated
1/3 of the code and half the bugs what I
didn't realize was this is indicative
that it's a very hard problem so and
here's why if writing a correct
algorithm itself is difficult then
writing a correct algorithm when it's
implicit okay when you don't actually
have the algorithm as loop in your pay
on a on one page what you've got is a
message to another object that
eventually loops back to you or not and
the algorithm is buried in there gets to
be almost impossible so start to break
down this problem how would we define it
well you have to start and say what is
this thing you know what what's this
event handling logic how can we even
define this and when we've backed all
the way up and said we don't even have a
good definition of what what it means to
have a user interface so we came up with
these as working definitions for what it
means to have a user interface and it's
just a system that designed to assist a
user in selecting a function and
providing a valid set of parameters to
that function so what distinguishes a UI
in a product from say consuming a movie
is the fact that the user is trying to
do something he's selecting a function
and then executing it now a graphical
user interface is just to use our
interface that's a visual and
interactive
a big part of the code we're talking
about here is not the code that deals
with selecting the function right you
pick the menu item you've got the dialog
box or you're on the pallet and the
function is implied it's going to set a
set of properties on your document but
what does it mean to assist the user in
providing a valid set of arguments to
that function so we have two loaded
terms there one is valid you know we
know what arguments to a function are
what does it mean that they're valid and
what does it mean to assist so valid is
pretty easy it's just a predicate that
corresponds to the preconditions of the
function assist there are many many many
many probably an infinite number of ways
that you can assist a user but if you go
and look at the applications we have
general patterns and you can start to
categorize these patterns so here are
four that we're dealing explicitly with
one is validation which is given that
you have said predicate to know whether
or not your preconditions are satisfied
you can simply validation is simply
rejecting bad input saying no you can't
do that
okay correction is the idea that let's
say I have a valid set of input and now
I poke a value and now the system's
invalid how do I get it back to a valid
state that's correction so prediction is
letting the user specify the values for
the function in terms of the desired
result okay so if I want to take a a
file and split it split it into four
catch unk's then depending on the size
of the file I'll get some number of
files at the back so the user could
specify the file that they want and how
many pieces they want out the back and
you can calculate how big the chunk
needs to be so prediction is specifying
the parameters for the function in terms
of the desired result then related
values so if a user is specifying I'll
use our example here the size of a
document
in pixels which might be the only thing
the application cares about that might
not be a natural user interface there's
a related value there of inches which is
related to pixels through resolution so
you end up with related pixels or
related values through which you can
define the arguments for the function so
let's make this a little more concrete
flip to a demo here are the questions at
this point people following think I'm
nuts
okay so this is a little picture of the
UI that we had the big ball of spaghetti
about for and this is fully functioning
here okay so we can change values there
constraining proportions to the original
document within height which is up there
we can toggle our display between
percent and pixels we can unconstrained
and change a value and then we can
reconstruct eighths appropriately and if
you put this in percent they'll always
be equal so that's the basic idea for
this UI over there on the left you see
the complete description for the
underlying model for that and we also
have a description through our layout
language of what the visual portion of
the UI looks like so this is looks very
much like a box model the solver is is a
little more general it automatically
does things like line up colons and has
a little more smarts underneath it but
things are described in terms of a basic
mock box model and you'll see these bind
statements against things you know
there's bind here bind here bind here
the bind statements are what connect the
UI to the model so the way most people
tend to write an application is the
application logic reaches up into the UI
and mucks with it and if your
application is doing that your
application knows all about the UI you
can't have an alternate UI on it
you can't reshare that logic for
scripting so here what we've done is
we've factored out the description of
the model which is how these properties
are connected together independently
from what UI is bound to it and we can
demo that by opening up another UI so
this is another UI that we just attached
to the same model we can see the
original document width and height down
there
and you'll see these are actually
attached to the same instance so if I
change the UI or if I change the values
up above they're reflected down below
and it's running non-modal so I can
change it here and it will change up
above and unconstrained and change and
rican strain okay so two alternate UI is
or I can do a third UI and here I want
it to represent my percentages as
sliders so I've got two sliders and it
will roll through the numbers and all
the other other views and it's pretty
traditional model-view-controller stuff
that you probably could have seen demoed
on small talk-- systems at xerox many
years ago but somehow we've forgotten
how to do this what we've forgotten how
to do is define models okay so that's a
basic idea of what we're talking about
here back
now when I came up with that piece of
code I went in found one of the I think
one of the best engineers at Adobe guy
named mark Hamburg he was chief
architect on Photoshop for many years
he's responsible for Photoshop Lightroom
which is recently shipping and I said
hey Mark this little mini image size is
just a portion of the Photoshop image
size just got a couple of connections
fully specified I'll tell you exactly
what the specification for this dialog
is write the code in the language of
your choice and the framework of your
choice I don't care about how your UI is
laid out I just want the logic for this
dialog this you can zoom in on it if you
want or get really close to the screen
is his resulting code it's written in
objective-c
to Cocoa on the Mac only the gray areas
here roughly correspond to the logic
that's in the model and the rest of the
code is code that given a change in the
model reaches up into the UI and
manipulates it it's all the event
handlers going on there yeah there's no
nib file here there's no description of
the UI this is just the logic for it
what's that
oh no it is there is a nib file then
there are bindings so it's just not
showing it okay okay yeah yeah yeah this
is not like trying to recreate the world
this is as small and tight as he could
give it okay this is my solution in
comparison okay
yeah there's yeah so the amount of code
to interpret that is 2,000 lines
hopefully the next time I get around to
rewriting it will be about 1,500 lines
in comparison the code for the complete
version of image size in Photoshop is
6,000 lines so so my complete system for
the UI layout engine the solver for the
models and both the parsers is smaller
than 6,000 lines okay so this is the
resulting structure that you know if I
were to draw that this is what we end up
drawing okay so here the notation here
is a solid arrow with the solid point is
a fixed connection okay that's a
directed directed connection the soft
arrows here can go either way they can
flow around the dotted line here this is
a conditional connection so there's a
predicate attached to that which can
toggle it on or off and that describes
the complete system
so a little more about the structure
it's always expressed as a bipartite
graph it's very similar to spreadsheets
except directionality can be determined
at runtime so you can kind of flip
things the way they're going data is
flowed from higher priority cells out
towards dependent lower priority cells
so there's a link reversal algorithm
this employee employed to reserve soft
cycles which there are systems where if
I tried to pin two values it becomes
over constrained but if I only pin one
then it's not over constrained so that's
a soft cycle hard cycles are very easy
to detect so we just detect and reject
them in soft cycles we just solve them
now
kind of a full notation here we have
sources which just have n outputs sinks
just have a single input a cell can have
0 or 1 inputs meaning it can be derived
or itself can be can be a source and the
remaining are outputs on it and then
relationships have n inputs in one
output always and conditional
relationship is the same with just a
predicate on it so those are the basic
computational structures for the system
now we're attacking 30% of the problem
we're getting pretty good traction right
now of last time I looked we had this is
going in as part of part of future
Photoshop and several other apps and
last time I looked we've got 20 maybe 25
dialogues reexpress this way and all the
thousands of lines of code underneath
them worked out so it's it's took a long
time to get traction but now that I have
traction the role is actually going
pretty quickly my estimate is that 85%
of the existing code base can be
replaced with small declarative
descriptions and a small library of
generic algorithms if you go and look at
a product now that's not these small
declarative descriptions there are other
problems that manifest themselves in the
applications and they need to be solved
but that's my gut feeling looking at the
application code in fact if you look at
all of it I think we're about two orders
of magnitude off from the minimal
expression for any large application
which Photoshop is roughly three million
lines of code last time I counted which
means I think you ought to be able to
express all the photoshop in about three
hundred thousand lines of code well
there sorry 30,000 lines ago
I'll let you guys read the rest so if
you guys want more information I've got
some links up here we've got our open
source site all the example here the
example application that I'm running
this through and I can give examples all
day of the system is available on open
source try to do be calm you can
download it all the code is there
stepping off papers calm
Alex stepping off if people know who he
is the guy who created STL he works for
me on my team and we have a website just
for his collected works one of the
things we're working on is a book kind
of bottom to top here these are the
drafts of the book the first failed
drafts I can failed draft and the draft
or on so we will get this thing out one
of these days but please or read them
give us feedback we're specifically most
interested in feedback on the top which
is our current attempt this is the book
that I think Alex should have written
when he released STL well almost 15
years ago now people look at STL and
think it's a nice container and
algorithm library and not it's a
different way to think about code so the
point of this book is to explain what it
means to do generic programming not to
teach you about how to use STL that's it
Adobe's tag line question
so sure I can I can repeat the question
yeah so the problem of concurrency we've
done a little little work on concurrency
usually when we're stuck on something
else our two side projects have been
have been threatening issues and Unicode
issues I think the same basic techniques
apply to concurrency meaning that
successful systems that I've seen that
are concurrent are written basically in
one of two ways either in a structure
similar to a UNIX pipe system which is
basically flowing data out into a dag
and at each node you have a queue and
the queue provides enough elasticity at
the join so that you can wait until you
have enough enough data to progress
along the dag the other systems are ones
where they are algorithmically parallel
where I can do you know a reduction
algorithm things of that nature so so if
you look on kind of the algorithm
parallel parallelization side there's a
lot of work that's been done on you know
there's the stable project to take Texas
A&amp;amp;M which is parallelizing STL
algorithms I'm drawing blanks on example
but there's there's there's many out
there especially in the domains of
linear algebra image processing and we
have a fair amount of work going on at
Adobe in those domains on the the how do
you structure an application into a a
sequence of processes you know basically
even though maybe they're threaded
they're not full full processes but how
do you go about building an application
like that and describing the structure
much as you would say on the the command
line of a UNIX shell to string together
a bunch of a bunch of UNIX tools how
would you build complete applications
piping a bunch of components together
and that's where my team's most
interested and I think there's some good
work to be done there so I don't know if
we'll ever get to it seriously but haha
but that's my my thoughts on it
currently yep
yeah the code under the hood certainly
uses templates and generic programming
the language itself is oh oh do it is
like a meta programming language it's
not part of our goals one of the guys
that Adobe has done that for the layout
engine there's a there's a
domain-specific language done as meta
programming in C++ our goal is to get
the mathematics correct to describe what
the computational structure of these
systems are and and give a generic
description of what it means to solve
one of these systems not to do C++ meta
programming
well all the libraries are implemented
in C++
do I think C++ is a good generic
programming language I think C++ is is
the the closest approximation that we
have to a good generic programming
language and getting better
so so you know Alex wrote STL in Ada
long before he wrote it in C++ and it's
been written in portions of it in scheme
and Java and C and we still tend to
prototype code sometimes in scheme so so
it's the ideas of generic programming
supersede what language you express them
in you know typically what we do is we
work out what's the generic description
of this what are the axioms and what is
the algorithms and then you go through
the painful process of how do you map
that into C++ you know what I want is to
just be able to write a type function
and what I have to do is write traits
classes and partial specializations to
get them to dispatch and C++ because I
can't just write a function in the
natural terminology that manipulates
types so so yeah so and yet one more
point there which was which is are we
trying to convince people of this I've
got nothing to sell I mean we're we're a
very small team everything we do is
open-source the reason why we open
sourced it is because it's interesting
problems and I'm interested in
collaborating with other other people we
do a lot of work with Indiana University
in Texas Texas A&amp;amp;M I see a general trend
in this direction I think eventually
this approach wins out you know by this
approach I just mean a mathematical
approach to programming I don't think we
can continue to treat programming as an
approximation our systems are just
getting too big and too complex and
without perfect approximations it just
means more and more and more failures so
seeing with this approach what's easier
to solve or are they harder
so we're seen pretty much zero bugs so
far the once you have your description
out there the challenge is giving the
model written in the first place and the
system right now does a fair amount of
checking not quite as much as I would
like but it does enough that it tends to
bitch at you so the whole reason for
coming up with a way to draw the picture
and eventually we're gonna wire that in
with graph is and use dots so you can
the system can automatically draw the
pictures for you
is that is that you know if the system
bitches and says there's a cycle here
because you over constrain the system to
finding too many relationships it you
need some way to to figure out well what
did I do wrong and how do I get it right
so there tends to be a more thought
process upfront and it's more difficult
to get kind of anything working once you
get it working you're done what is
missing from Haskell type classes that
would make them useful as a
representation of concepts I would go
and read let's see it was a Doug and
Yoko and that crew did a survey paper
not not too long ago that that covers
that in far more depth than I could give
it justice here because I'm not much of
a Haskell programmer my opinion is I
would program in Haskell if I had a
reasonable or some you know whatever
language worked the best if I had a path
to deploy that in products to fund my
team I have to ship software and right
now that means I ship in C++ so so I'm
not
not a religious zealot when it comes to
C++ I do think it's the best language
out there for concept based programming
we've done some some some somewhat wacky
things with it we've used the modeling
system to describe overload sets for
functions in C++ so you describe the
relations on a set of parameters and the
system will go through and iterate what
all the possible overloads for that
function are that have any meaning we've
used it too well the layout engine which
I didn't talk too much about here we've
used the layout engine which usually
does two DUI layouts to describe 3d
worlds and the same thing that connects
baselines made sure that the that you
had had had paths between rooms that you
know you didn't end up with completely
walled in in spaces the solver here has
been used for doing dependency tracking
for installers what else somebody Apple
used it for doing music mixing and the
graph solver itself is fairly
independent of what the equation is on
the node it doesn't doesn't care what
the function is on the little circles
just just that things are connected so
so you can plug whatever you want in
there so people have used it for music
processing you know how far it how far
it goes I don't know I mean from the
from the UI standpoint we solve a good
chunk of the problem right now but we
still have little pieces that are
hanging out we're focused on not
figuring out more domains for it
to maintainability yeah yeah it it lends
itself pretty well the interesting thing
is is developers have a hard time
changing the way they think okay so what
tends to happen is frequently the
request comes in and says well the UI
designer says they want it to work this
way and that might just be a view
behavior on the outside it has nothing
to do with the model the model itself
doesn't change and giving developers in
the mindset where if it does come come
and impact the model I mean this is a
model of parameters to some function and
you and the goal is to try to make the
model as complete as possible and that
gives the UI designer as much
flexibility as they want to put a big UI
on it or a little UI on it you know you
don't have to expose everything you can
expose whatever subset you want so long
as the model is consistent in correct so
so the system tends to be fairly easy to
maintain what tends to be hard is
recasting the problem into into what is
what is the relationship here that is
being asked for how do i express that
and since what I'm modeling is typically
a set of parameters to a function or a
set of properties in a document going
from that relationship to say well what
does that imply about what the function
has to do these things don't just exist
externally okay so you have to you know
I'm gonna go change the behavior of this
function and what it does and then I'm
going to go and express that in my model
and that's a it's just a different way
to think about software I mean my my
experience so far has been the more
years somebody has spent doing the
object-oriented programming you know
myself included you know over a decade's
worth of object-oriented programming the
more trouble they have have expressing
things in terms of the relationships
within the model as opposed to how
events are flowing through the system so
you know one typical example people will
say well I want this checkbox when this
checkbox is checked I want this thing to
be disabled okay well what it means when
something is disabled in the system is
that it's disconnected from the output
so that no matter what value you put
into that cell in the model it could
have no effect on the result okay so
there isn't any way to say disable this
thing when I click this checkbox what's
implied by that request is that there's
some relationship to that checkbox that
tends to disconnect that cell from the
output what is that relationship write
that down in the UI will just work
so other questions I've got I know three
minutes I can give more demos or ask
answer a question
yeah the the QA team likes the models
because it gives them you know a very
concise spec of what's going on the
other thing is we have a set of just
command line tools so you can check the
model as independent of the app and it's
also nice you can you know we've got a
little sample app here so you can bring
up a model you know what they'll
function attached it on the back end so
I can bring up like the complete image
size from Photoshop with all the 14
widgets and all the connections between
them and fully test the thing without
launching Photoshop okay and from a UI
designer standpoint it means that I can
play with my UI and say oh I want three
panels instead of two panels and I want
the revealing wood and I want a slider
here and never have to touch the code so
they like that the one thing that where
we do have tension with QE as QE is used
to working in kind of a puppet string
world where you know a lot of the
automation test tools will like like
reach into the UI and say what's the
state of this checkbox and in our system
our checkbox don't have any real
intrinsic states there's simply a view
of the underlying model so you can ask
the model what's the state of this cell
but it doesn't make any sense to ask the
checkbox what its state is and and our
automation QE team has a hard time
getting past that hurdle they're like
well you know what if the model is
correct but the connection to the UI is
wrong how do we test that so so I think
that's just friction that will fold out
over time
yeah
so so I think eventually you end up with
a shift and what it means you know for
people to be programmers
I think assembling collections of say
generic algorithms is an easier task
than writing the generic algorithms to
begin with I think even you know
constructing these models for a system
is is somewhat easier I can show you
it's a hundred lines for the image size
in Photoshop and it's way easier to
write that hundred lines than it is to
write the six thousand lines of code in
Photoshop and Mark can probably attest
to it and the six thousand lines is also
wrong and I can prove to you what's
wrong okay I wrote one version of it so
so I do think it makes it easier but I
think what you want is is a shift I mean
at this at this year at this point in
history I think it would be great you
know if you could get a a PhD by
trimming a couple of cycles out of one
of the STL algorithms that should be you
know get you a PhD coming up with a new
algorithm that's generally useful
certainly should be worth a PhD and yet
right now very few people you know we
don't have a massive library of this
stuff very small libraries and
everything's very primitive and my team
spent the last week and a half working
on a formal definition of integers
because math the mathematic definition
of integers doesn't hold up real well
when you have haven't have integers of a
fixed range right we can define Z but we
can't define what the Z over a range of
0 to n is because n is Z if you
what's that Z sub n which doesn't quite
capture say signed arithmetic it works
pretty good for two's complement
unsigned so so also piano axioms which
is how mathematics are defined or in
terms of successor so you start with
with 0 or 1 and then you add 1 you can
build up all of mathematics with with
just just successor with basic increment
from a computability standpoint that's
very unsatisfactory right we don't we
don't add two numbers by 1 2 3 4 ok it
just doesn't work that way so coming up
with it kind of recasting mathematics
into axioms that apply to computer
science it's a part of the work and you
know eventually these should be
textbooks and you know we need our we
need our euler's and our Euclid's and
and those folks more questions
yeah there's a back on so thank you
Shawn</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>