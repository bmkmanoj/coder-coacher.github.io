<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ZuriHac 2016: Monad Homomorphisms | Coder Coacher - Coaching Coders</title><meta content="ZuriHac 2016: Monad Homomorphisms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ZuriHac 2016: Monad Homomorphisms</b></h2><h5 class="post__date">2016-09-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YTaNkWjd-ac" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I did this sort of as a joint trip I
what I went to memetic Warsaw and gave a
talk in Poland and then I came here I
was thinking about doing the same talk
for both venues and Gleb was constantly
pestering me for my talk title for the
like the last three months and I finally
told him yesterday or the day before
because I didn't really want to do the
same talk as I used in in Poland at the
end of the talk I gave there I said ok
we built up all this stuff for the last
hour and a half and here's all the
problems with it maybe I could get away
with something simpler so now I'm going
to try get away with something simpler
and you won't have to burden yourself
with what was in the other joke so
here's here's the sort of problem that I
want to address you know we have all
this work going on with effect systems
and we have the MTL lying around and
what have you and I'm not going to get
into effects versus MTEL MPL today but
what I do want to get into is that the
way that we use the MTL is in many ways
suboptimal or the way that you use mine
at transformers is somewhat suboptimal
in terms of the code that we get
generated so what do we teach everyone
to do when they go to write MPL code
switching to the yeah I went to sleep on
me here screen should be connected all
right whoo let me make this thing big
enough so that a reasonable scale for
people to be able to see all right good
we teach people to write something like
you know I have my commentator foo and
it's gonna take a monad writer and I'm
gonna add state s m and if we're really
Lenzi we might have has foo and all this
kind of stuff and then we generated like
an M event and I run out of screen space
this is the style that we teach people
to work with it with the NPL because
they write their function
parametric in the choice of monad just
so long as any monad that has access to
a state and has access to the ability to
scribble out to a mono I'd you know
whatever he was then this will work so
they can add new layers to the money
transformer and this will still work in
the larger environment right and the
sort of has foo has bar kind of
constraints that people who like to use
lunges can then build up the big product
environment or the big product state
okay the the problem that this approach
has is what does GHC do when you when it
encounters one of these things like if
you if you wrote this perfectly generic
definition for my particular error for
this you know completely abstracted out
monad what is how does it compile a
small function that's written this way
well what it's going to do is it's going
to have to look up through one I'd
writer lookup the superclass of it fine
that's monad go into the monad figure
out how return and bind work pull out
how get and tell and put work by looking
through these dictionaries right and
since this is written to sort of an
abstract M every step is whether may i
how do I go get return okay all right
I'm gonna bind the result of that to get
okay and how do i bind the result of
that what a i'm f mapping here each one
of these things is constantly doing
dictionary lookups so we go home well
the inliner will solve that right and it
won't be a problem anymore it'll get
specialized away based on the inlining
this code but the moment this stuff goes
is a recursive function the in liner
really kind of gives up so if we're
teaching people to write in this very
abstract style what we're teaching them
to do is to write really bad code from
an efficiency standpoint and even the
core implementations are like all but
like monad did stuff like that for the
various transformers up until this very
last release that i got Ross to push out
where we finally added all the inline
pragmas in the appropriate places like
the MTL wasn't in lining very well just
even when you're working with a concrete
stack but now if you
with a concrete mana transformer stack
it can be quite efficient so what I'm
interested in is is there a better way
at least potentially from a performance
standpoint to write magnetic code okay
and still have sort of power and
flexibility of the MPL and when I was
playing with this before I used the for
the first stab that I took at this I'm
the the very thing that I said I wasn't
going to drag in this talk was to play
with lenses in different categories so
it turns out that lenses can live you
can build lenses on any category that
has a monoidal category and last year I
gave a talk here and I introduced
monoidal categories and then I went
through and built up like contouring it
forms of a blicket evander build
discrimination and all that stuff but if
you if you remember the definition of
monoidal category from last year I'll
just assume everyone here does you can
then show that the category of monad
transformers if you drop a couple of
pesky monads forms of monoidal category
and its own right and he can do all
sorts of crazy things there that wasn't
good enough to get the behavior I wanted
so at the end of that talk I sat down I
said well maybe I can just get away with
building a library for manipulating sort
of monad homomorphisms so let's talk
about what a monad homomorphism is we
can get some basic vocabulary for how to
wire these things up because my goal is
to be able to say I have a big Moana
that I want to run my computation in
ultimately I have a small monad that
that has just the features that I need
the little for this particular thing
that I want to do I want a monad
homomorphism that embeds this
computation in this larger context by
Swizzle about the parts of the
environment or the state or the result
type or whatever that we're going to
that we need feeding into this
computation and then pulling the results
back and swinging them back in the place
in the larger Moana that I want to run
it okay and so in order to make that
make sense we need to have the
definition of what I'm gonna tell
morphism is in order to be able to
reason about them I'd like to talk about
some vocabulary that comes out of the
degree theory world about Manik and epic
and I saw ice morphisms and stuff like
that and then we can start seeing what
Mona trans what Mona homo erectus if I
have which ones of them satisfy these
quantities and these properties and we
can go from there
does that seem like a reasonable
direction for this to go okay so let me
pull up oh I got bosses you're gonna get
start sharing yes alright so I binged
out this yesterday in the day before and
this makes a nice sort of way to
precursor to keep people from getting
too distracted by what's coming ahead
they can't see anything yet okay so yes
we keep going past so we have a bunch of
existing one at Noma morphisms that we
know lifts from Mona a trans is that is
a moan at home amorphous ooh it says
that if M is a monad then T of M is a
Mona we really want that T of M to be a
monad Mona had trans isn't smart enough
to tell us that we're missing something
what's going on well what I want is we
have class monad trans T we have lifts
as M of a goes to TNA right and this is
for any Miami and this has some laws
lift of return a is return a and lift of
M bound to some function half is lift am
bound to lift off right we can state the
laws that lift distributes over this
it's a it's a monad structure preserving
natural transformation so natural
transformation takes you know a some
functor F to a functor G it Maps F of A
to G of a for all a in a natural way
which means that if you were to f map
before you apply the natural
transformation or F map after you apply
the natural transformation you'll get
the same answer so if you F map then
transform or transform then f map you'll
get the same answer this is the same
thing but now it's a so you can think of
a
a natural transformation is a functor
preserving map this is a Mona
homomorphism is a monad preserving map
it's that plus the extra laws about
return and bind so this is the
definition that we all know and love but
there's a problem if you actually start
using this in anger I mean there
actually was a library that attempted to
do this there's a mem morph library and
at the last minute this morning I
changed all my vocabulary to match the M
morph libraries Combinator names so I
may get things totally wrong the the
problem is is that there's a missing
concept here that makes it so that that
library has to jump through some hoops
and that is that monad trans is missing
something that it should be a ballista
it should state one more thing which is
not just that there is a Moana at home a
morphism from M to T of M but that T of
M is a monad if M is a monad right I
want something that proves to me that if
I know that M is a monad then T of M is
among that now this funny symbol here is
something we can define by building a
little library and I built it on hackage
it's called constraints but sort of
unpack that for people who are really
Haskell savvy and want to this is peen
tales dig Q there so in seven for max
Bolingbroke gave us the ability to
abstract over constraints the stuff that
goes on the left hand side of a double
arrow before we used to be able to
define something like data or dict a
where or dict was given or two of a I'll
give you or dick for a but you'd have to
do this point wise for every individual
class you wanted to deal with now we can
abstract over things have kind
constraint so there's a kind
constraints such that if you look at
board or it has kind start a constraint
and monad has kind start a star to
constraint so here we can say dict has
type dicta Vandana org int go capture
the ordering on intz in into this thing
and so if I open it up in a later
context I can I can work with it and
another example would be using the thing
that I wrote just below this I can say
go prove to me and GHC you know I can
say like foo equals subject so I said GG
please do all the work to show me that
if I know Ord of a then Iike list of
list of lists of lists of a is there
right and GS you will compile that and
just say yes and that thing will be the
proof that given a dictionary for Ord of
a we can walk up to the super class
getting order of ek and we can use the
instance instance ek and Hales eke of
list of a many times to get to that
particular concrete thing so Gigi will
just do that that's what I said here sub
picked sub which creates a context that
demands in this case and Ord a and then
tries to figure out how to build this of
a dictionary for us so we can so this
stuff is all nicely packaged up well
maybe not nicely but I'm packaged it up
and in that package let me actually keep
this thing because now I'm at least
self-contained there is a another
ridiculously generic class I have called
lifting and lifting PF has one operation
which is that if I have P of a then P of
F of a okay that looks
viciously like transform but swap in
monad for P and M for a and T for F I
should have chosen my letters better
right and if we do that that lifting
then transform is just a special case of
this so we're looking for a lifting
monad instance for my particular monad
transformer that's the piece that is
missing from monad trans what is so what
I want to do is this that we I want to
think a little bit about the category of
monad homomorphisms the category of
monads over haskell datatypes okay so
there is a so we have the category of
haskell datatype tory we have functions
as our arrows and we can compose them we
have the identity function and that has
all sorts of rich structure we can look
at the category of monads over haskell
and that also has interesting structure
so the arrows in the category of monads
will be monad homomorphisms from one
monad to another so they're gonna like
preserve at least the structure of
return and bind and map them the things
are above Monette and then what is monad
trans in terms of that category right
it's this is morally equivalent to the
pointed class which I don't particularly
like in the Haskell ecosystem
it's that there's a written there's like
that it's return right if you squint at
this you kind of look at if you get rid
of the A's right this is a goes to M or
M goes to T of M right it's it's it's
the it's morally returned but without F
map we don't have an F map what's going
on this isn't even appointed functor so
we can try and make this a little bit
cleaner looking by making a little type
alias it says for la emmab a goes to n
of a and I'll imply that this will
always be a Monat homomorphism when i
write write these just because that's
the domain of my of discourse today so
now we can write it that way and now it
looks a little closer
let's go build up a notion of like a
monad functor well what do we want we
want some operation I'm gonna use the
name that I used originally that I think
a real stole for EM morph later on which
says that if you give me a monad
homomorphism form m2n I'll give you a
monad homomorphism from TM to TM
darn it that feels very funky and this
has to be for all for Mona dam and Mona
den right
that's a functor on the category of of
monads of yes of monads of rascal the
thing that's missing here is that we
really need to know that this list
Monnet lifting monad T and that says
that you can play games to open up this
dictionary whenever you really need to
prove that T of M is a monad because
like if you were to nest monad
transformers s of T of M you're an
otherwise we end up with all these
annoying constraints that Monette has to
be a kamon ad or M has to be a monad but
T of M also has to be a monad and that
then we can say that s then you can lift
into ass you've probably if you if you
beat out MTL and anger sometimes you'll
get these these annoying I needed the
monad 40 uh it just this lets me work
around it by doing horrible cases in
places that I don't want to do but it
was a missing thought so we can call
this like M pointed down here which will
be lifting monad T and monad trans T
will be the sort of equivalent of the
pointed functor class would you say hey
there's an instance so this is now if
you're familiar with the type Isis then
we have the fact that we have this
constraint kind you might be wondering
why I didn't bother to write like type M
pointed didn't didn't go sleep on me I
did
is this right there they seem equivalent
except for the fact that this type alias
can't be partially apply I can't not
I can't talk about em pointed without
applying it to an argument if it's a
type alias this thing here I can apply
to apply to an argument so even though I
can make type aliases for constraints I
almost never can get away with actually
using it side tangent so we have pointed
we have functor we can also build monads
in the category of monads what would be
an M monad right what would she be M
pointed which should be an M functor we
have some sort of MU like operation here
let's call it our squash I think was the
app aging in the M morph okay boys
squashes I think what they called it
there this would be like T of T of M T
though so what is this this is something
like if I if I need if I have two levels
of Reader T for the same environment I
can mash it down and get a reader okay
using the bind form of it's perhaps a
little more useful but now we've got
something that sort of feels familiar if
you think about it monad trans the thing
that we've always had is almost pointed
so we can think of monad transformers as
almost being pointed functors on the
category of monads the problem is is
that they didn't have an F map and then
if we say well we can always equip it
with an F map we're wrong because Kant
doesn't let you do that so there are
certain things that like conscious like
the moral equivalent of like set you
know you can't you can't make the the
functor instance of it but it's pointed
it's that sort of messy thing that
doesn't let me do all the the rest of
the stuff I don't want but you know it's
we still need to use it so we have
functors on our category of monads we
have all these pointed structures now
let's go back to the thing that I
actually wrote before so
lift is the sort of canonical monnet
homomorphism from M to T of M and I've
got a little note here that says it's
Monica unless T is terminal yeah this is
gonna be great fun to explain so when so
when we do we work with sets we start
talking about functions that are
one-to-one or on two or surjective or
injective we all use different
vocabulary for this like you know does f
of does F of a equal F of B imply that a
equals B kind of stuff right when you
move into category theory you you just
have arrows floating around and like the
the meaning of these things is a bit
more abstract so how do you like model
that same kind of concept so I wanna be
able to talk about injectivity so I know
that everything that I can express in
this monad expresses a distinct thing in
this target Monat I don't lose any
information and I want to be able to
talk about when everything that could be
expressed here can be expressed in this
monad bit like the image of this is the
entire range of this Mona these are the
two cons like this is this is the sort
of injectivity surjectivity kind of
equivalent that arises in category
theory so and the way to go back to that
little sort of note-taking window that I
have here if I have say let me just draw
a little diagram pictorially I have two
objects I have an object a object B and
I have to I have two arrows huh look
there to them they go to an object C
right we call this one half and we'll
call this one G and this one H right how
do you like my asked yard so what what
we're saying is something like if G F is
equal to H dot
does that imply that G equals F okay RG
n equals H do I get that right yes
G was age so I want to know if I can
subtract out a common prefix and you use
it to reason about equality okay and
this only really works if sort of what
is this if F can generate every single
possible be right if you think about
this in terms of sets right so in the
sort of this is the one to water onto
there's a surjectivity equivalent is the
ability to say that I can sort of rip
off a common prefix if I can reason that
these two arrows are in composite are
equal then I can rip off a common prefix
and the residue will be now we're gonna
do more ASCII art nope you can guess
where this diagram goes you have G and H
it's not as exciting F and what we're
saying here is that what F G equals F
dot H entails that G equals H okay
and what is this if if we only have
access to these then this every B has to
be left unto a distinct C right this is
one-to-one we can't lose any information
in this map here we had to be able to
sort of generate everything here we
can't lose any information and since the
the category of of monads a / Haskell is
sort of like set plus some stuff the the
set like behaviors where you know we're
the sort of injectivity surjectivity
intuitions actually hold okay now
it turns out that if you have a right
inverse that means that you have if
we're looking at F and F has a function
let's call it G such as f da G is it'd
if there exists such a thing right if
there exists something that you could
you can take the input into G and then
split it out into all the different
equivalence classes worth of data that
f12 the process and then make sure that
everything got mapped back so you you
didn't lose any information if G can
kind of only put one thing in each one
of the the distinct places that F has
that's going to produce each output then
we're automatically epic and we call
this thing a split this is a crazy term
a split epi morphism and I lose everyone
in the room okay this is sort of like
what we're looking for is a sort of
right inverse to death and it turns out
that if you have and so if you have such
a thing then you can take let's let's
call this let's call this R then G dot F
equals H dot F would tell me that G dot
F dot R equals H F dot R I can smash
these together show that this is Edie
and this tells me that G equals H right
so split up for morphism implies F a
morphism so it's it's a stronger
condition it you know that we have a
right inverse that we can actually talk
about it and then you can guess what
we're gonna get down here we're gonna
build this thing we'll call it a split
mono morph is 'm and this is that will
have like L dot F is it'd and well this
will imply the same thing because we can
do the exact same trick putting the left
inverse on the left of our F and showing
that it cancels and that you get the
thing you want okay and then these are
sort of weaker conditions than just
saying that we have a monad isomorphism
which is that we have an
an F inverse that's at F dot F inverse
equals you know after equals in an F
inverse dot F equals it right
so a isomorphism will be both a split F
P morphism and I split montemor fizzle
right because it has a left and a right
inverse which is just its inverse
they're the same thing okay now I have
the vocabulary that I want to use to
talk about the different monad
homomorphisms that we have I haven't
quite decided if it's worth trying to
capture the injectivity notion in some
sense if I'm trying to use this to sort
of Swizzle the parts of my state or my
environment for my monad down to run my
titer computation it would be nice to
know but I don't lose any of the
information that the smaller computation
is using if I'd want to not lose any
information than this embedding should
really be an embedding it should be a
amana morphism right that I didn't I
didn't forget anything it's also useful
to be able to talk about the rest of
them so maybe I don't want to create
something I don't know we would call it
maybe a mono morphism restriction about
how we how we work with these particular
wellheads
maybe maybe we don't want to create
another one of those but it's that's the
core vocabulary we have okay so now lift
says that the embedding of M and the T
of M is monic unless T is terminal what
a help I'm in there okay
so we have a we have a category and then
category theory we have this notion I'm
an initial object or a terminal object
so what is the initial monad in the
category of unintel morphisms anybody
hmm identity yes the identity monad sort
of plays the role of the one element set
in set there here it's the and what is
return return is a map from sort of
identity of a to M of a we just kind of
get rid of the identity because it's a
real identity there right so return is
this the canonical morphism from my
identity monad to my particular monad
so return like with a run identity
bolted on the front of it is a monad
homomorphism that's sort of the first
one that we all know and love lift here
is a monad homomorphism and it we have
the initial object but what's the
terminal object in the category of
monads this one's a bit more of a tricky
question because it's not hmm it's not
quite it's actually proxy life eeeh
so I have in in the data that proxy
module which is now in base there's a
proxy a as proxy yeah this is a monad
what's return proxy what's fine its
proxy what's right it's a great monad
you can do anything you want in it
it's hard to run well you can run it you
just you don't get any of the data that
you actually wanted to do right but this
monad should be an infant's of like
everything right it should be ammonia at
i/o you can embed i/o actions go its
proxy so lift i/o yes it's missing
instance for lifted I oh wait I have to
put a patch in for that yeah it actually
it actually matters that that lift IO
that we have this terminal instance I
actually needed it yesterday
okay so so so proxy is our terminal
object that means that there is a unique
monad homomorphism from every single
monad to proxy what is it's the unique
map that sends everything to proxy right
it just takes gives you the proxy data
constructor and ignores all the
structure you had before okay the unique
map from identity is to use return and
get rid of the identity constructor so
what I'm saying here is that it's Manik
unless T is terminal means that every
lift that you can define for every month
and you can come up with will have to
you have to keep the information for for
identity you have to be able to be out
you have a little map your in this case
it's for a Mona transformation so if you
embed a monad into another monad into a
month using them on a transformer right
em meds into T of em in order for that
to work I have to I have to be able to
produce the output a or whatever that I
had I can't forget any information
through lift so lift never forgets
anything and the only way that it can
forget something is if I had a terminal
monad transformer so we can have mono
transformers where we talk about the
initial monad transformer will be the
initial monad transformer identity T
such that the way that we map the we
have monad transformer homomorphisms
which map say for all monads em I'll
take an object say I'll take SMA to TM a
would be a monad transformer
homomorphism between s and T right and
so then we need if we have identity T as
our initial mono transformer what would
be the terminal monad transformer this
is a concept that is been missing at
Haskell I didn't bother to write it till
now yes let's make proxy T proxy TM a is
proxy T we have a lovely monad
transformer here if M is a monad proxy T
is definitely a monad right and it
should be an instance of all the things
this really should be like an instance
of like monad state for all possible SS
however we can't be because you know we
have a little pesky fund out and Romans
probably laughing right now anyways so
we have proxy T we have this initial and
terminal monad transformer we have an
initial in terminal monad and what I'm
saying here is that lift has to be mana
that must t is the is isomorphic to
proxy T right you can't use anything
less than all of the result on that okay
so that we trying to use this to build a
little bit of familiarity with these
with these terms these sort of concepts
IO to s T and s T to IO these sort of
just established these two things are
isomorphic hey we haven't one--at
isomorphism unsafe io task T on safe
stdio well you can leave that to your
that's between you and your priest
lower Co density we have lift that can
take em and embed it into Co density of
em but there's an operation that lets me
take code into the of em back down to em
and it acts it's a split FP morphism it
and that it's surjective we can we can
generate every single possible M from Co
density of M M is the code in C of M is
bigger than M it retracts the lowering
lower anchor density sort of in jet
contracts away the like expansion that
we get from lifting into this larger
context unit and KO na darts the same
size as the original thing and these are
examples that if you haven't had to use
these particularly monads don't worry
about it if you have then then those
lines work for you if you use lens
there's zoom which lets you zoom in on
port part of a state you can say I can
run a if I have a lens that knows how to
get a smaller state out of a larger
state I can run a computation for the
smaller state directly in the larger
statement and so if L is a lens than
zoom will be a monomorphic because we're
basically able to embed something
designed for a smaller state magnified
is the same thing for environments for
reader kind of stuff and these I didn't
bother to write the type signature here
because I don't have that much screen
space B if you like flip run if you flip
run Reader T or whatever you're gonna
get given E
I'll give you reader TEM goes to M I'll
give you a money at homomorphism from
reader key e about 2m do you think this
like almost like lowering back out of
reader you pick the environment gonna do
and you can run you look at eval state P
like you give me a state eval state like
discards the out though the results
state right we lost some information so
but it turns out that I can get you any
computation in them using state PS m
which isn't surprising because lift this
is sort of unless undoes lift right and
in a sense and because lift can't care
about the particular choice of state
that we ran our state machine well and
so
um this has to be split up II all right
okay so we have what a Mona morphism is
I already sketched that just because I
wanted to get away with fewer
parenthesis I use this little flip F map
thing from glen's which you can think of
the less the less than dollar sign
greater than this is the version who
puts the function second because the
function tends to be big and long and
the thing that I mapping over tends to
be small and I would usually otherwise
have to put parentheses around any
particular local lambda and now I don't
so transform we've already established
is just we use the lifting class and
saturated at monad right we have our
notion appointed which we talked about
earlier I have some existing code entity
or data etcetera example so I can just
say that we can lift those because I
wanted to be able to work with them in
this framework pointed teeth oh that's
wrong this is just lifting my head
hopefully I didn't break everything just
by changing it I did okay
oh yeah I started redefining proxy T
which I'm redefine later and hoist is
this F map like operator and I was
saying before that you can't map over
can't with hoist because let's look at
con what Scott - you look like TR
ma is Conti and we have a goes to M of R
goes to M of R right and then run con te
or something like that
yeah which is just enough to push it off
the screen making it less useful than I
want it okay
so with this with T how can I map
if I have a monad homomorphism from M to
n I can map over the result M and give
me an N but that doesn't want me work
with the argument because argument the
arguments in canto rank position so I
would actually need a mapping from n to
M you need a full Monat isomorphism
you need to know that M is isomorphic to
n so I can convert M into n and then and
M willy-nilly in order to build a map
under Conte I wanted to show you that
Conte really isn't a functor on the
category of monads like the other monad
transformers that we have lying around
and almost any of the cps timon ad that
we like to use for like efficiency where
we code in to be something or like CPS
it but then put lots of M's in negative
position none of those will work this
way so keep that in mind
so I can I can I can make like a one-off
Combinator for hoisting can't well
you're you're supposed to prove to me
that these things are two halves of an
isomorphism so maybe it would be better
for me from a like a software
engineering standpoint to like make
types for capturing whether something is
Eppie or you know split Eppie or iso or
whatever so that I can drop in you give
me an ISO here and I'll make sure that
there's less lying that you can do to me
without really being explicit about
lying I haven't decided yet
so I'm still playing with this this is
the API is entirely open for discussion
and a lot of this is really just like M
functor and this kind of stuff is more
or less the M morph API because I stole
their names this morning with the
addition that instead of just talking
using monad trans I absolutely need that
lifting monad thing that is the missing
concept in M morph okay so each one of
these things is an M functor what's this
thing says that I if I have a monad
homomorphism from M to n I can run
underneath identity key or underneath
state T or underneath Reader T these are
all boring boilerplate we have the
unique monad homomorphism from M to
proxy which I mentioned before the
lovely instance of Monett i/o for proxy
that is missing from base now that mana
do is
bass we have so I started playing around
what I want to be able to do is like
figure out how to swivel these inputs to
to get to the money that I want and you
know monad transformers don't commute
right you can't always push every monad
transformer or every other man's form
without changing definition changing the
meaning fine let's be explicit about
when we're changing the meaning and then
you can use that as your way to embed
this smaller action into this larger
contacts or even a larger action into a
smaller context by providing it in an
environment or state or wherever you
want so this lovely thing says give me
two mana transformers S&amp;amp;T
and I'll say that they commute if you
can give me this morphism and I'm not
going to claim that this is an ISO but I
will say that commute that commute
commute should be commute right that
it's either got a left inverse or a
right inverse if if you if you can write
this it'll-it'll then if you write the
commute for S&amp;amp;T and for TNS then darn it
one of them should be the inverse of the
other that at least gets me something to
racing about so turns out that we can
always push we can always pull reader T
out if I have an S of reader key I can
always get a reader T of s yes that's
correct
if you have both instances then you'll
have the commute commute to me a blog
yes but that law only yes that law is
remarkably painless unless you until you
write both instances yes so we can
always pull reader T out in general
there's a sort of obvious in retrospect
law that says if you have m of you know
yeah I can always give you e 2 m of a I
can take the e and F map over just
applying the e that I've got to the
function right so for any functor F or
for every at for any functor m there's
always this so this gives me a sort of a
distributive law
we pull readers out and then there's a
similar law I'm gonna actually make this
the font a little bit smaller because I
didn't I wasn't just careful with the
code here all right so let me look at
this a little bit closer yeah this is a
mess isn't it so I have s of reader T
I'll do one of these in in detail so we
can see it so in order for me to be able
to work with the output here I have to
know that reader te of som I need to
know that s of M is a monad to talk
about reader te of s of M as I'm on it
so what we do is we say hey look if I
told you M was a monad could you please
tell me that s of M azamun ed and
transform will do that so I just case
match on that and that when I open up
this sub it's going to take my monad in
and when I pattern match on this deck
that will give me back the monad for s
of M so now I know s of M is a monad so
within this case statement I can use
that fact within the body here so now we
can say reader key e and here I'm going
to give you something in the s of M
monad which will be we're going to run
our previous computation which is s of a
reader computation and I need to turn my
reader computation into an mm
computation right I have reader Tem and
I need to get em underneath s so we have
to hoist to get under s and then we
basically run reader key at the
particular choice of environment which
we established earlier was epic and we
are all good okay yeah so this works for
every Mon ID transformer and reader key
I mean so reader he can we only have we
only have to write one instance here but
then too when you when you want to have
reader key on the left each one of those
is going to be
point wise and writer key is the same
kind of property that we can distribute
in products we have if you have a comma
M of a you can always build M of ikana a
by capturing the e putting it in the
environment F mapping over this with a
you know put the pair with e so there's
a distributive law something shove
products in and pull functions out those
are the kind of two distributive laws
that we have available to us on haskell
actually those are the only two
everything else is a good one
and so we have commute for writer which
is a mess I have to use to transform
twice and placed and lift right yeah but
it works we can commute reader in states
so like when we work with monad
transformers a lot of the steam that the
out that the sort of algebraic effects
community gets is that certain run i
transformers all commute like
reader/writer state doesn't matter which
order you handle those effects the
results are all all the same right RWS
exists as a monad because yeah like you
throw them all in a blender and they
just all commute so it doesn't matter
the order you lay of them anyways so if
I commute reader with state it doesn't
destroy it or create any information but
commute reader with writer it doesn't
create a destroying the information
reader with accept even reader is wit
reader reader commutes with accept which
is the I their T that we finally got
into the MTL state commutes with writer
so state writer reader we expect those
all to be able to commute in all
positions except with state is not
semantics preserving so so we have the
exception transformer and state in one
layering we have a state when we fail we
have state that survives failure in the
other setting we have the either on the
inside so let's see what do we get we
get either s goes to either E or
a comma s or s goes to either ei us
these are the kind of two layerings they
get for steak T and other T so I'm I'm
assuming that the underlying Minette is
AI is identity and using either rather
than but so these two things have
slightly different semantics
well this one is surjective it's on two
we can represent every computation in
what every computation that of this form
given this one so given one of these I
can give you one of these and every
single one of us the second can be
represented given the first but when I
come back I lose some information
there's like because when I what I don't
have a state because I terminated early
the only thing to do is give you back
the original state so I lose information
and this is why like maybe I do want to
start being careful about whether it's a
mono morphism or an epimer fizzle and
I'm just trying to figure out if I
should right now I can just talk about
could be a voiced commute well it's
shuffle things around and pull monad
transformers up and down the stack
willy-nilly and then since you're being
explicit about how you get the monad do
you want your okay well it's on you yes
this doesn't say that the yeah I didn't
like this does not I did not require I
so I just know I wanted to I wanted to
commute these two things and whether
they actually are whether the result is
an isomorphism or not is something that
this may or may not stay as one class
they may split them to get the embedding
projection kind of pairs but I just
wanted to sort of start getting a
vocabulary for talking about how to move
money Transformers over other Mon I
transformers and this was the sort of
the first thing I could think of was but
start sliding them past each other at
least in part
so at least I can be explicit about when
it's a split mono split that'd be right
and maybe the type should capture that
you know because we like those I stole I
think I was calling this like in it or
something like that because it's the
initial morphism we have that thing
lying around and we can always sort of
how to put this let's get a good example
here's a fun one you can always run a
reader computation inside a state you
take the state and make it your
environment right reader is sort of less
expressive than state but everything you
can express everything you can express
with reader with state so this is a so
if one who embed a reader computation in
state it really is a mana morphism and
it's split because there's an inverse
which is basically eval state key with a
reader T bolted in so we have like
evaluate that read-only as it'd and we
can go back and forth between these two
representations what are the fun ones do
I have lying around here I have a writer
to computation I can always forget the
the thing that I was calculating the
mono I just forget the mono ID and
that's a monotone morphism if you give
me a starting environment we have a way
to project out a reader and these this
is split up B because it has lift as its
right inverse right there is a right
inverse there's a way to embed into this
thing that this thing doesn't are
preserves so I started talking about
monad monads and they were more about
curiosity because like what other things
can I do with layers other than start
flipping them I can start smashing them
together and it turns out that Gabriel
had already implemented this class in
the EM North Library so I stole his
names after after we implementing it so
yeah we got to the same point the
difference was is that he used
I think embed is the primitive
definition and because I have access to
transform I can actually
either one works for me without
transform and you could only you can
implement the other one in terms of
embed really easily but implementing
embed in terms of the other needs the
ability to prove that T of M is M own
had given M as a monad yeah so this lets
me sort of squash layers so if I have a
reader T of a reader te of a reader te
of something which is not a situation
that ever actually arises in practice
you could smash it down to a reader te
by sort of sharing ease you can do the
same thing to writers and much other
stuff identity may be you know they're
kind of obvious when you think about it
okay so I want to go back to the bit
that I started with when I was talking
about how the category of moneyed
transformers is a is a monoidal category
and has all this fun stuff at the very
beginning in this talk so this is the
thing that this was the construction
that I was building to make the polling
taco which is that if it's a monoidal
category there's some tensor there's
some by functor on the category of monad
transformers that is associative and has
a unit and satisfies McLean it's
pentagonal coherence condition and all
sorts of fun stuff so what is that well
this would have to be you give me two
money transformers and the result is I'm
on a transformer right so well let's see
how do we do this with compose we nest
write monads don't compose but when I
transformers do because the money
transformer kind of contains its
distributive law of how it gets very out
that is distributive law but it's its
operations of how do I build them on out
of it under underlying Winnett but in
order for this to be I'm on AI
transformer I need to know that T of M
is a monad which again that same lifting
monad concept that was missing all along
so in order for tensor to exist I need
access to lifting monad in order for it
to be by functor because it has to be a
by functor on the category when i
transformers I have to be
map over this with a monad transformer
homomorphism one will give me a money
transfer morph sir I knew it would turn
s of T of M of a into s prime of T of M
of a given a money
when a transformer homomorphisms or SS
prime I even will do the same thing but
that means I need to be able to hoist
over s so what does that mean that you
can't use can't with this tensor this
isn't really a tensor in the category of
mouna transformers it's a category on
the subcategory amount of transformers
that happen to be real mm functors or
monad functors on the money so okay so
you know what product doesn't ask oh
right so what we're looking for is
something where you have like an
associative yeah you need associativity
we're gonna need a few operations you
need like an associate ippity operator
which is going to say something like i
can say a b c and it should be natural
and all the right things you should be
able to go back and forth between this
and a b c and if we have a unit we
should have something we'll call like
lambda these are terrible names which
should take and say this is isomorphic
to that i should be rho and by the way
these are for left and right huh I
didn't name them
blendin mathematicians they like the
Greek letters so we have these things
with the obvious identities that well
not so obvious identity involving like
if you associate twice and use the one
direct review if you try to associate a
b c d into if you try to go from here
all the way to a b c d there's two
different paths you can take using a
sock a couple of times in one direction
and once over twice over here and three
times over here yeah with if you how you
move the the tuples around that has to
commute and a little couple little
triangle diagrams have to commute but
they're all the obvious things right
need this associativity you need a unit
and it's kind of the place that you
build ma nodes is that like well if you
think about it I'm append we write it as
M - M - M well this is sort of mmm
goes down and what's the unit for tuples
it's well unit right so empty we write
this way but a category theorist would
be happier thinking about it this way
right so whatever the unit was for my
particular tensor I give you a UV a
morphism from that 2m and you give me
one that goes from the tensor of mm to M
and we get something interesting so we
moved to like the category of functors
over haskell okay we can equip that with
a tensor
we're gonna pick oh these are gonna be
you go from compose mm to m and what's
the unit for compose so what's the
identity I'm sorry what's the identity
so what's this well this is if we turn
this into this is return and bind right
this is how monads are mono AIDS in the
category of endo functors they're mono
eight objects with respect to functor
composition being the tensor okay so
that's where the name comes from it's
inspired by that and so we just need
this we need some ability to associate
we need some ability to put on and take
off a unit right so let's go see those
operations in this horrible format which
isn't that horrible the instances are
horrible let's skip those
so it's lambda lambda needs to be able
to put on or take off identity key
because identity T will be the unit for
a tensor so what do we do we just put on
or take off identity key I'm not on the
outside it's easy on the inside we have
to hoist right and then we can a sock
which okay that's a little dense but
what we're saying is that if you have
tensor of
so you have s T tensor s t10 surd with
you can be turned into tensor of ass
into tensor of tu right and then the
vocabulary here is unfortunately verbose
but whatever in order to do that I have
to use that proof that M entails monad
for M I'm gonna add 40 of em right twice
and then I can hoist and play some games
right
so yeah it's messy and then on a sock
does the same trick cancer cancer hoist
run whoa well we're doing is putting on
and taking off the tensor new types at
the appropriate levels so so that exists
I don't have a purpose for it yet but
it's it's it's coming together so what I
have this like we can say that if you
know we have we SMT are everything here
should be really be an M functor or
whatever we really want to get it so we
want to again say that if if like s into
you're both monad trans then the result
is mona trans you need you need real
pointed on one of them in general
lifting monad on both of them implies
the whole thing lifts we just asked you
to do all the work if both of these
things are functors on the category of
monads the result is a functor on the
category minutes cuz we can hoist yeah
that's fun we build the functor instance
by lifting the definition of f map we
basically steel s of t of em's
f map and just use it for ourself and i
do that overall for each of the
operation this point y individually so
that they all get the optimal definition
that's available that would be available
if you just composed the underlying on
that transformers so all we're doing is
associating the way that we nest our
monad transformer it didn't we gained
and lost no information here right we
just regained the ability to use that
look at all of the monoidal category
vocabulary for talking about this stuff
which didn't do me any good which is
what i went and did all the rest lista
and then like in order to be able to
work with the tensor of two transformers
and like gonna moan at state instance
for it which is going to be like the way
that monad state propagates out through
mono transformers is peculiar to each
one we steal them directly from well do
we have a monad state on s of T of em
great then we'll use that one monad
writer etc and you can very easily see
which affects your algebraic by if they
don't include Ren tensor because that's
partially handling some stuff so which
indicates that eventually I should have
get around to breaking the entire
Haskell ecosystem and splitting apart
monad reader and monad writer into two
subclasses
each because you really want the ask
part and the tell part separate from the
pass and listen and the local operations
that we baked into reader because
there's lots of things that can be can
supply ask but can't supply local but
the screaming of every user of the
Minette transformer library is something
that I'm not looking forward to and so
I've been kind of just turtling and root
ending that I don't have to do this okay
so what do we have here so we've got
those things we've got our proxy T right
which is my trans and check it out as a
phone card let's look at it I have some
wonderfully well-thought-out instances
here and I really want to be able to say
that it's a monad state for all ass but
I'm not gonna remove the fund up from
the MPL and so we've got all the things
I can play with a few other ways to
transform my environment and I'm gonna
run a little long here so I'm I'm more
or less running out of steam so don't
worry which is that like if you have our
nested readers in many ways you that's
nice if you have a reader T of
a reader peek of e of something a reader
T of a terrible letter choice reader T
of C of reader T of C of reader T of D
of something then this is also this is
equivalent to having reader key of C
comma D of something so one of the
ability to start moving multiple states
or multiple readers into one to glommit
together into one environment or one
state and so this is sort of my again
part of my attempts to let's start
trying to build a vocabulary here I'm
not I'm not fixated on this particular
implementation of vocabulary I'm fixated
on the notion of having a better
vocabulary for talking about these
modern homo morphisms so here like if
you give me if T of a is a transformer
and T and T of B is also a transformer
then what I want is that T of a B should
be a giant should be I should be able to
should be able to take a T of a of T of
B of M and give you a T of a B M &amp;amp;
unpair so I should be a little too
planning to pull and then because I want
writer T to be an instance to this
writer he only works if the two things
are mono IDEs well a good thing that
product wanted exists so here what we
get is if you can prove to me that a and
B are both objects then you should be
able to prove to me that the pair of a
and B are objects with respect to that's
right though if in this case it for
writer T it would be like if if a is a
mono I didn't be as Aman I'd then darn
it the pair of a B better be a mono
omoide or we won't be able to build
writer T of pair a B and then I need
some proof that if a is an object then
of T you know the thing that that T is T
of a is a is a transformer whenever a is
an object that we're willing to work
with so now I can build things like oh
and then lower unit lets me go through
and say but that writer T of unit of M
is nice
I am actually so this is actually the
other half of Liz Lee if I lift into
writer T of unit I should be able to
smash it back down or if I lift into
state T of unit I should be able to
lower it back down like these are just
things that should exist darn it
so I can build the instance of lets me
merge neighboring states or I can build
one that lets me merge written
neighboring writers or neighboring
environments and I thought I'd be able
to do either that way or do either two
that way but of course it's not it's
gonna you actually need to use Co
products for that so we have the sort of
dual construction here where we want to
be able to take T of a of T of B of M
and give UT of either a B of M and T of
either a B of M and go back and this one
works for things like accept T so you
can say you know either T and either T
if you're less the two levels could be
either T of either the two possible
failure types yeah so I've got these
things lying around I'm looking for
better bits of vocabulary though for how
to do these embeddings I'm not really
sure if I should package these things up
the way that I have where they're just
naked moanin homomorphisms or if i
should use a more lens like trick where
what i do is i can package an ISO as a
thing you can compose with dot and then
give you a commentator that lets you run
the isomorphism forward or flip it all
around and run it backwards the lens
like vocabulary is not quite right
because it would be like having ISOs and
getters which would get you sort of Mona
and homomorphisms and ISOs but I mean
this whole continuum in the middle of
eppy morphisms and mono morphisms and
split FPS and all kind of stuff right
for which way I have an inverse
if I really want to capture that
vocabulary and I don't have the answer
here so I'm more than happy to talk to
people about this if they have strong
preferences or like have ideas
there's stuff that I would like to be
able to do like I would really like to
be able to sort of automatically
construct the are a canonical selection
of a mono morphism if it exists to embed
given a list of constraints give me the
type for a for a monad transformer stack
that implements that chain of
constraints the monad state the Mona
this so a little checker that just takes
a like an H list style list of
constraints and tries to build a monad
transformer stack out of it which turns
this into an effect system so there's
some stuff that I would like to have
there that I don't have yet I haven't
quite worked out the vocabulary for and
I'm happy to talk to people later on
today and tomorrow about this or
whatever and I think with this slightly
long rambling ending I have covered
everything everyone wanted to talk about
today thank you
yes yes performance is my goal I don't
have a good benchmarks for you yes so
it's going to happen is this if you
write to a particular concrete monad
transformer right if you wrote to if you
were to either T of state of something
right of Io right darn it
then what's gonna happen is GHG will be
able to in line all those dictionary
lookups to go it's going to know exactly
how to do I out here and by the time it
gets done doing in case of case kinda
else and stuff like that like that'll
turn into really tight code for this
this core loop of whatever it is that
you wrote well the goal is you don't
write to the polymorphic case you write
a particular concrete computation and
you tell me the money homomorphism that
lets me embed that thing into my monad
so my goal is to sort of worker rapper
transform mo of my monadic computations
write the concrete thing that I want to
do and then write them on at home
amorphous and lets me run it in the
larger monad that I'm interested in now
I won't be able to get away with the
exact existing monad transformer
vocabulary because I can't just say
month at state one or whatever and build
up the magnet constraints and have the
worker convert it to that form
particularly and come back I have
there's going to be some extra noise but
that's the gist yes well no cuz I don't
know yet like the holy the whole point
here is I'm trying to figure out what
the API should be I have the gist of it
right I have like you can look at the EM
morph documentation because Gabriel is
much better than I like putting together
long-winded examples about how to use
this code and that gives like logistic
like how you can use just the stuff that
we have today I don't know that that's
the API that we want in the long run and
I don't I don't think I can sit here and
bang out a big long H list ish kind of
sketch quickly we can definitely talk
about that when I'm on offline
so any other questions all right I think
we're good thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>