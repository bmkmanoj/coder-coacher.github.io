<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reverse engineering techniques to find security bugs: A... | Coder Coacher - Coaching Coders</title><meta content="Reverse engineering techniques to find security bugs: A... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reverse engineering techniques to find security bugs: A...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mwrhRP2PswA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello there my name is Alex sawed-off
and today we'll talk about how to use
reverse engineering to find security
vulnerabilities and in particular how I
found the a and I vulnerability which
was the first publicly disclosed
vulnerability in Windows Vista it was
patched last month first let me
introduce myself I work as a security
researcher at determine ah I do
vulnerability analysis I reverse
engineer the Microsoft patches every
month I have a lot of exploit
development experience and I've also
spoken at a number of security
conferences over the last two years I
also discovered a couple of Vista
vulnerabilities that were patched in the
last couple of months and I have a few
more in the pipeline that they're going
to patch you know soon hopefully but
first let's start with a demonstration
of how to hack Vista this is probably
why you're all here alright so what we
have here is a what I have here is a
Windows Vista installation it's just a
default installation nothing on it
I have Internet Explorer and I have
Firefox 2.0
I have this exploit here which exploits
the anti vulnerability and it's written
as a module for the Metasploit framework
I'm going to run it while it loads the
Metasploit framework is this framework
written in Ruby for writing developing
exploits it provides implementations of
all kinds of network protocols and other
exploit related libraries and utilities
so you can utilize a lot of that to make
your exploit develop and go faster now
the exploit is now running this is a
browser exploit so the exploit is
listening on a web server the exploit
has started a web server and it's
listening for requests so we're going to
start Internet Explorer and we're going
to do we're going to go to the web
server and now while it's loading there
it is I send the HTML page to the client
that sends the anti file to the client
the anti file exploited Internet
Explorer and we got a connection back
from the Vista machine and now we have a
command prompt and we can do all kinds
of things can list things and so on of
course if you're doing this with some
nefarious purpose you're not gonna use a
shell you're probably going to install
some you know malware on the box or
whatever your fancy is now we're going
to launch the exploit again and exploit
Firefox now the vulnerability is not in
Firefox itself it's a Windows
vulnerability but Firefox ends up using
the same the same vulnerable code and
user 32 DLL so both Internet Explorer
and Firefox utilize this core windows
API which leads to the vulnerable code
so actually the Firefox people didn't
have to do anything to fix this
vulnerability in their code
you know they just have to wait for
Microsoft released a patch and then when
the patch is applied Firefox is not
vulnerable anymore so Firefox is just an
exploitation vector I'm going to run the
same exploit here and then I'm going to
go to the website again yeah there's the
exploit so for to exploit Firefox we
have to wait a little bit it won't take
long
what is interesting that since this is a
default installation of Vista I haven't
done anything to I haven't disabled
firewall I haven't disabled any of the
protection features it's running you
know as it would run on any machine
where a normal user just installed it
and as you can see there we just got a
shell and now we're in the C program
files Mozilla Firefox directory this is
because we exploited the Firefox process
so again we can do things there you can
start a notepad and now that popped up
like machine we can do more fun stuff
probably too but I hope that's enough
for now it's enough to give you a taste
of what you can do with these exploits
so how did I find this exploit
I actually want to do a live demo of
that too
but before we get to that let's talk
about reverse engineering and how it's
used in computer security and in
particular how I reverse engineer
Microsoft patches and also why so if we
look at if we look at the Microsoft
security bulletins there have been more
than 500 released since 1998 which is
when they first started tracking them
and numbering them but the number of
vulnerabilities that they've patched is
actually much higher than that there
have been most Mouse bulletins patched
multiple vulnerabilities so there have
been probably thousands of
vulnerabilities patched just in the last
i patch which fixed the anti
vulnerability there are five other ones
that were also fixing Microsoft has a
fixed release schedule for these
security patches every second Tuesday of
the month they release them with very
few exceptions however the bulletins
don't give you the full story there are
a lot of security issues that Microsoft
fixes silently without telling anyone or
without publicly acknowledging them what
typically happens in this situation is
that a security researcher would find a
vulnerability in something like Internet
Explorer or some other component they
would report the vulnerability to
Windows and sometimes the vulnerability
would just be a crash report that
Microsoft gets Microsoft will
investigate the report they'll build a
patch for it and they will also audit
all the related code around all the
related code around this the location of
the bug so as they do this they might
have they might discover additional
vulnerabilities and then they'll fix all
of them in the resulting patch but the
only vulnerable 'ti that they will
publicly acknowledge and list and the
patch is the one that was publicly
disclosed to them and not any of the
internally discovered ones in addition
the service packs also fix a lot of a
lot of bugs and vulnerabilities
if you look at the release notes that
are early lists specific instances of
security vulnerabilities often security
bug fixes just get described as a
reliability fix or it just fixes a crash
without actually telling you whether
this crash is exploitable or it's just a
crash even when you get information in
the bulletins
it's almost practically useless in most
cases here's a typical way they describe
a vulnerability and I'm gonna read it
there was a privileged elevation
vulnerability in Windows 2000 caused by
improper validation of system inputs
this vulnerability could allow a logon
user to take complete control of the
system now reading this description tell
me what the vulnerability is or even
where it is you can't improper
validation of system inputs what are
these system inputs is that if I move
the mouse in a particular pattern I'll
get elevation of privilege I mean the
mouse movements are a system input too
but we don't know the only way to really
understand what the vulnerabilities are
is to reverse engineer the patches
unless of course you have a third party
advisory that describes what the problem
is but in most cases we don't the
security industry uses reverse
engineering a lot the entire AV industry
is built on reverse engineering the
viruses and other pieces of malware as
they come out in addition the patch
reverse engineering is a subset of the
general reverse engineering is used by a
lot of security companies to find attack
vectors for different vulnerabilities
build package signatures for a network
detection of these vulnerabilities
people also do it for vulnerability
analysis so they need to understand
exactly what caused the vulnerability
what type of vulnerability it is is the
vulnerability of memory memory
corruption bug in that case there's some
systems that might stop it but if it's
not a memory corruption bug then maybe
they want so the vendors of these
systems would need to understand what
the vulnerabilities
the vulnerability assessment people use
reverse engineering to figure out the
changes in behavior introduced in the
patch so that they can use it to
remotely detect whether the patch is
installed or not and finally there are
security vendors who use reverse
engineering to analyze the
vulnerabilities and build exploits for
them they're actually a couple of a
couple of companies that sell
penetration testing tool kits that
contain a lot of exploits so every patch
Tuesday they go and look at the
vulnerabilities build exploits for them
and then ship them to their customers I
do it I do it mostly for the second
reason we have a vulnerability
protection product so I need to
understand whether our product would
stop that or not and also to test our
product I need to do exploit development
and actually build working exploits that
we can run against the systems and find
out if it actually stops it or not so
the tools that are the tools that I use
and many other people many other people
in the industry use - our first and
foremost Ida Pro which is a disassembler
I will show you I'll show you a demo of
that in a little bit
it's a disassembler and it's been in
development for over ten years now I
believe so it's pretty advanced and it
has a great plug-in API and by great I
don't mean that the API is actually
pleasant to work with but it allows you
to do you know things that you can't
really do in any other way so in this
way Ida Pro has turned into a platform
for developing reverse engineering tools
and building various analyzers on top of
the basic disassembler engine one great
example of that is the bin diff tool
which is a plugin for Ida Pro Ben diff
is a really really cool plugin it allows
you to compare two binaries and find out
if there's a and find out how similar
they are find out what the change is
in them are for example if you have a if
you have the patched version of some dll
file you can compare it against the
unpatched version and bin DIF will tell
you exactly which functions and the DLL
have been changed and even more it'll
highlight what the changes are on the
basic block level and it doesn't do this
by just comparing the bytes of the DLLs
because that doesn't really work it uses
the underlying disassembler engine to
build a call graph and it compares the
two call graphs and it looks at the
actual basic blocks and the instructions
inside them I will show you a demo of
that too in a little bit another tool
it's pretty neat is PI May it's a it's
it's a basically it's a debugger that's
scriptable in python it allows you to do
various dynamic various dynamic analyses
of applications you can do tracing and
visualization of the traces as an
application executes for example you can
send if you have a web server that has a
vulnerability you can send a normal
request to the web server and trace it
and then you can send an exploit request
to the same server and trace it to and
then pi may will Allah will let you
compare the two the two traces and it'll
show you where they diverge so this way
you can find out exactly where the if
statement is that you know leads your
code down the vulnerable path or down
the safe path another tool that I use
extensively as VMware in addition to
using it for a number of in addition to
using it to have a lab on my laptop I
also use it for backwards debugging
that's a term that I came up with I
haven't I haven't heard anybody else
name it before but I'm sure other people
have thought of it - what VMware allows
you to do when you do debugging is
actually go back in time for example if
you're debugging and you have a
breakpoint on some function you'll it
will step on that function
and you write on that function you have
the choice of stepping over the function
or stepping into it and actually seeing
what the function does now if you don't
know exactly which function does the
thing that you're looking for it doesn't
make sense to step through all of them
because that will take a long time it's
much better to step over them until you
find the right one
but once you've stepped over the
function normally
you can't go back to the function and
see what it actually did in more detail
unless you restart your program or send
another request but in that case you
might get a different memory layout and
the environment will be different so
what you do is with vmware you take a
snapshot of the system like when you're
sitting at the beginning of the function
then you step over it
if it turns out that this function did
something interesting that you want to
look into more detail you revert back to
the snapshot and you step into the
function and since VMware does multiple
snapshots you can actually do these
snapshots on every function that you
step on and then you can go back in time
you know arbitrarily so it's a pretty
cool technique let me show you a demo of
been def and we'll get to how I
discovered the anti vulnerability so I
was doing I was doing I was reverse
engineering one of the Microsoft patches
from the beginning of 2005 the bulletin
number as MSL 500 - this patch fixed a
stack overflow and the code that
processes animated cursor files they
usually have an anti extension it was
discovered by E I in late 2004 so I was
looking at the Microsoft patch and
trying to understand the vulnerability
and here's what I did
I will open the patched DLL in Ida this
is what kinda looks like you just have a
nice disassembly output and then I will
run Bend if here's the plugin I will
tell you to diff this binary against
this one which is the previous version
of that DLL released by Microsoft
Binda if is actually pretty quick it
will only take a few seconds and here
are the results
so bin def shows you a huge list of what
it calls matched functions these are the
functions that it identified as
identical between the two dll's and
you'll notice that we have names for all
these functions this is because
Microsoft provides debugging symbols for
their DLLs this makes our job much
easier but bindiya also works even if
you don't have the symbols but all of
these all of these functions haven't
been changed in this window we see all
the functions that have been changed so
if you want to understand what Microsoft
changed in the past you just need to go
and look at each one of these functions
and certainly this is much better than
reading the entire user 32 DLL
disassembly the function that's really
interesting is this one load cursor icon
from File map as you can tell from the
name it loads animated cursors from
files we can do a visual diff
which will show you something completely
incomprehensible but what this is is a
graph of the basic blocks in the
function the green arrows indicate true
branches and the red arrows indicate
false branches and you can zoom in and
you can actually see the instructions
inside all the basic blocks the basic
blogs that are highlighted in yellow
our basic blogs that Bend if could not
find a match for in the other file which
means that this basic block was removed
and then there were three basic blogs
that were added and Bend F is not
perfect it uses a variety of heuristics
to do this so it doesn't always get
things right but it's a it's a pretty
good tool to start your analysis instead
of going through the graph I'll just
show you the result of analyzing the
function so we're going to go to the
function and here's the actual
vulnerable code the anti files consist
of a we should we should do a brief
digression first the anti files consist
of a series of chunks that contain chunk
length a chunk tag which is a four byte
signature which tells you what type of
chunkiness followed by the data of the
chunk and the length of the data is
specified in the length field that's in
the beginning so to process these chunks
the user 32 code uses this read tag
function which reads the first two
fields of the chunk which is the tag and
the length then the code here compares
the tag with a and IH which is the tag
for an animated Heather for animated
cursor Heather that's the first chunk
that's supposed to be in the file then
the code compares the length that was
just read from the file
with 36 the Heather a chunk should be 36
by 36 bytes long that's
size of the structure if it's not then
we go and you know we raise an air if it
is 36 bytes long then we go to read
chunk which reads the data from the
chunk into memory and it's actually read
into a static structure that's just a
local variable in this function so they
have the animated Heather structure
there and they read into it so this is
in the this isn't the patched version of
the file and the unpatched version this
check here for the 36 bike length is
missing and it's pretty that's pretty
obvious to see once you look at the been
different output so if the length if the
check is missing it means that we can
have a chunk that has more than 36 bytes
and it will be read into this statically
size 36 byte structure on the stack so
if we have a chunk that has 100 bytes
it'll be read into that local variable
and it'll override the stack past the
end of that 36 byte structure so this is
how you this is how you exploit that
vulnerability that was found enough it
was patched in 2005 so I looked through
this I understood what the vulnerability
is I understood how they fixed it it all
makes sense how would you go about
finding other related vulnerabilities in
this code and that's a question that
somebody can answer there any takers yes
the answer was look for other read tax
and that it's correct
and actually you can look you can look
for other reet axe and read chunks and
reads chunk is probably the most crucial
one because read chunk is the one that
actually does the Stack Overflow so
let's go do that we're going to the read
chunk function and then we're going to
open the cross-reference this window
which gives you all colors to this
function Ida provides them
when we see that we have three colors
the first one is the one that we were
just looking at so that one was fixed
and then there are two others two other
calls in the load an eye icon function
one of them is safe but this one is kind
of interesting if you look at the code
you'll see that again they do read tag
then they check if the tag is an IH and
then they jump straight to read chunk
there is no length check and this is
actually the patched version of the file
so they had the exact same vulnerability
in two almost identical pieces of code
they fixed one of them they did not fix
the other one I think that this
vulnerability I mean the vulnerability
itself is pretty cool finding it is not
that much of an achievement because you
can find it with a grep if you have a
source code I it's kind of I don't
really know why Microsoft didn't catch
it when they were fixing the original
bug but while I was looking at the patch
I found his bug and I was like oh cool
let's try it out and it turned out that
this code is present in all versions of
Windows like from a NT all the way up to
Vista and Vista which was you know which
was just released I tested it on it and
it worked there too so this is how you
go about finding vulnerabilities
sometimes it's a little bit harder so
now that you have this vulnerability
what do you want to do obviously is
exploit it there are a number of now
stack overflow vulnerabilities you know
have been exploited since the late 80s
you know maybe even before them so the
you know the methods for exploiting are
pretty simple all you have to do is
override the stack override the return
address that's on the stack
and pointed that return address to some
place in the code where are you going to
go and then you can take control of the
problem execution and you can have it do
you know whatever you want however in
recent versions of Windows and other
operating systems too there have been a
number of protection mechanisms that
were added to prevent the exploitation
of these simple vulnerabilities in Vista
these are the GS stack cookies address
space layout randomization and data
execution prevention and I will go into
more details on those so first let's
look at the GS stack cookies this is a
this is a special feature of implemented
as part of the compiler and if you pass
the /gs flag to the compiler it will add
this special prologue and epilogue
to most of the functions in your code in
the beginning of the function it will
assign it will create a special cookie
value on the stack right right next to
the return address and it will put a
random value into that space at the end
of the function it will check whether
that cookie on the stack still has the
same value if the value has changed it
means that the attacker has overwritten
the stack you know going from some
buffer and overwritten the cookie to get
to the return address and since the
cookie is right next to the return
address it is not possible to override
the return address without overwriting
the cookie assuming that you have a
standard overflow that just starts at a
certain point in you know keeps going
like a strain coffee or a main copy
function this the the valley of the
cookie is also randomly generated when
the program starts up so the attacker
has no way of guessing what that random
value would be they can try to guess but
the chances of success would be very
slim so you cannot build a reliable
exploit without bypassing this cookie
check
in some way and there are some methods
for bypassing the cookie check however
in the case of the and I will nura
bility we did not have to do any of this
because the function where the anti
vulnerability happens the function where
this 36 bytes structure is does not have
the stack cookie why is that for
performance reasons the compiler does
not insert this cookie check in all
functions I mean I would have a pretty
serious performance impact if you have a
lot of tiny little functions and you
know maybe your inline or didn't inline
all of them what the compiler does is it
has a set of heuristics that it uses to
find out whether the function needs this
GS cookie or it doesn't and the
heuristics basically boil down to if the
function has an array then add the GS
cookie otherwise don't because most
buffer overflows happen either in
strengths which are character at race or
in other types of arrays in the case of
the anti vulnerability the data is not
read into an array the data is read into
a structure and the compiler decided
that you know there can be vulnerability
there so it did not add the cookie check
after this vulnerability came out was
exploited Microsoft released service
pack 1 for a Visual Studio 2005 which
contains which contains some extra code
and there was a special fragment that
you can set which tells the compiler to
be more aggressive and put the cookie
checks in more functions and this primal
would have stopped this particular
vulnerability at the expense of some at
the expense of some performance what is
interesting now is whether we'll see the
next service pack of vista recompiled
using this pragma or not
and the reason we might not is because
they'll have to recompile every single
binary in the operating systems which
means the next service pack which will
be as big as the vista installer is now
so they'll have to ship it on a DVD
maybe they'll decide to only compile
certain critical DLLs with the new
compiler so you know maybe it'll work oh
yeah so we didn't really have to bypass
GS to exploit this vulnerability but
there are other protection mechanisms
that would still present a problem one
of these mechanisms is what is known as
a SLR which stands for address space
layout randomization the idea there is
that usually attacker when they
overwrite a return address or a function
pointer or something else in the program
they would try to point it at some data
that they control the typical thing you
would do on a Linux system a couple of
years ago would be to put some code on
the stack you know and some buffer on
the staff and then point the returners
back there and since on linux the stack
always used to without a SLR the stack
would always start at the same location
you would know that your code would
always be at a predictable address so
you can just hard code this address in
your exploit on Windows you can't quite
do this because most programs are
multi-threaded so each thread would have
its own stack at a different location
you don't know exactly which thread is
going to be serving your request so what
you have to do there is use a jump ESB
trampoline so this works this way you
take some Windows system file like MT
DLL or kernel32 you know one of the
common libraries and then you search
this DLL for all instances if they jump
ESP instruction
and this instruction is only 2 bytes so
you're gonna find it somewhere once you
find that you hard code that as your
return address in your exploit so when
the exploit happens the program will go
from your vulnerable function to the
jump ESP instruction and that will
redirect it back to the stack and that's
where you put your real shellcode so
this way you don't need to know where
your stack is located because you use
this indirect jump instruction to direct
the problem execution flow there this
works because windows is distributed as
a set of binary x' and they don't change
very often so if you have a version of
fainty DLL you know it's very likely
that the victim will have the same
version of this library that you have
and there are actually some DLL files
that haven't really changed much between
different service packs so you can use
the same address and exploit all
versions of Windows 2000 because that
DLL is always at the same address so you
always have that jumpiest be trampling
their SLR is designed to prevent that it
randomizes the locations of all
executables and libraries as they're
loaded which means that if you load you
know if you load your program two times
the address layout is going to look
different so you don't have any fixed
addresses anymore
it also randomizes the location that the
base address of the stack and the heap
so it the goal there is to make sure
that you know there's no predictable
data at a predictable location in a
problem and this works pretty well for
blocking the use of gems jump ESP
trampolines so what are we gonna do for
our anti exploit
how are we going to get around out well
there are a couple of ways to bypass a
SLR one of them is to find something
that's not randomized now before Vista
there's some third-party SLR
implementations and they had issues with
randomizing executables because most
days acute herbals were not compiled
with relegation information so you
cannot move them around and also there
were issues with randomizing anti DLL
and kernel32 because the Windows kernel
had some dependencies on them being at
the exact same location always so this
was possible before vista but in vista
since they've implemented this in the
kernel they've they they've gotten
around all these issues and they've also
recompiled all of their executables with
relegation information so now you can
move them around the problem memory as
you want so this doesn't really work
very well anymore the second option is
to write our shellcode somewhere and
then jump to it it's vulnerable to
specific but sometimes you do have
vulnerabilities where you have
vulnerabilities that give you the
ability to write some data at a specific
location that you can that you determine
in that case you just pick some random
location in the program memory write
your shellcode there and then you jump
there and it should work however for the
anti exploit we'll use a heap spring
technique which is great for browser
exploits heap spring works by filling
the memory of the application with a lot
of copies of the shellcode it can be
done from javascript because javascript
strings are stored as just sequences of
bytes in memory so the attacker would if
the attacker controls the contents of
the JavaScript strings they would also
control the contents of the memory here
we have the custom code which allocates
200 megabytes of memory and it does this
bike by concatenated two strings one
that has a lot of knob in structions and
then another one that has some shell
code so when you do this here's what the
he play here's what the heap layout
would normally look like if you just
start one Internet Explorer process you
know you have the heap it's a little bit
fragmented in the big
you have some extra space after you do
the allocations for all these JavaScript
strings you would end up with the
fragmentation filled up and then you
have a lot of memory which is it which
is filled with your shellcode so now if
you pick any address you know in that
green area you know any address around
two hundred Meg's would be you know you
would be very likely to have shellcode
located at address and the shellcode is
the the code that you want your exploit
to execute so we're going to use this
technique we're going to fill out fill
the Internet Explorer memory with our
shellcode and then we're just gonna jump
randomly somewhere and it will work it's
extremely reliable actually it's
surprisingly reliable there's one more
thing that can stop us and this is the
data execution prevention or DP it
relies on the NX bit which most modern
CPUs now support they didn't use to this
bit allows you to create pages of memory
that are executed there readable but not
executable so the operating system that
supports that would mark the stack the
heap and other data location is
non-executable it's not executable so if
you have if you do the heap spring you
would have all this data on the heap but
if you try to jump to it you'll get an
exception because this this this part of
memory is not executable so in this way
DP prevents code injection
however on Windows DEP is not enabled
for the Internet Explorer process this
is I believe for interoperability
reasons because they're all these random
plugins that can load into IE and some
of them don't work with DP so in order
to minimize the internal problems
they've decided to you know lower the
security of IE
so the exploit that I just demonstrated
at the beginning of the talk did not
have to do do not have to bypass DP
because I just used the default
installation of Vista yes
now because the question was why did the
Firefox not have DEP and the answer is
no it did not because I'm on the desktop
operating systems like XP and this stuff
DEP is in is running an opt-in mode
which means that only the critical
system services are protected and
applications that you may newly am but
everything else is not now on Windows
2003 they're running in opt-out mode
which means that everything is protected
by default unless you add an exception
but for a consumer operating system it's
a little bit harder because users yeah
you download some random game you try to
run it and dep makes it crash and i have
a problem so that's why in vista Firefox
does not have DP out of the box unless
you manually enable it so if we had to
bypass DEP here's how we would do it the
standard technique for bypassing
something like this is to use a
returning to Lipsy attack on linux but
you can also do it on windows the idea
there is that you would override the
return address and make it jump to the
system function in Lipsy or win exec in
Windows or some other function that does
something interesting
since you're reusing code that's already
executable in its part of the normal
executable library DEP is not a problem
and since you control the stack you
control the arguments to the functions
so you can have it execute been SH or
net add user is a good is a good command
line to run on windows the other
approach to dealing with DP is to
disable it and in anti DLL there is
actually code that turns off DP for the
current process it's there for
interoperability reasons again because
there's some DLLs that dll's can be
loaded at a at any time in the program
and there's some DLLs that are not
compatible with DEP usually program
usually files that are packed with some
kind of executable Packer
so ng diello has some curious
and it tries to detect these cases and
if it detects a dll like this it just
turns off DP for the current process so
the code is already there in a known
location the question was is the
location not randomized and the answer
is yes it is randomized on vista but
it's not randomized denying speak
because XP doesn't have a SLR we'll get
to the randomization issue on the next
slide but if you if you don't have
randomization that anti dll code will
just be at a fixed location and you can
just jump to it it will disable DEP and
then you can jump to your shellcode on
the heap or on the stack or anywhere the
third option is to jump to a virtual
protect function which will allow you to
change the protection on the heap and
you can make it executable yes
yes that's the only thing that actually
minimizes the impact of the of the end
of the exploit the question was about
the protected mode feature and ie where
I is running in a low privileged mode
this doesn't stop us from opening a
shell obviously as I demonstrate it but
in the shell if you actually try to
override any of the system files you
will get access denied because your
shell is running as a lower privileged
account the interesting thing is that
you can still read everything so you can
read all of the users data you can
access you can also you have full
control over the internet explorer
process so you can insert some code into
Internet Explorer to intercept
keystrokes passwords and so on and as
long as the user is using that same
trend Explorer don't close it any side
that they visit in that browser window
you know you'll be able to intercept so
the impact is minimized but there is
still a lot of things that you could do
so exploit it does not prevent the
exploit from being useful completely so
the point of its a lot part of the
reason for a SLRs existence is because
DEP is so easy to bypass if you don't
have a SLR you can jump to these static
locations in the program with a SLR it's
supposed to be owned by Pascal because
you cannot guess where the code is that
disables the protection however the anti
exploit is the anti vulnerability is a
special case because it is wrapped in an
exception handler that catches access
violations it means that regardless of
what your program does like it jumps to
some invalid memory it tries to execute
some invalid instructions anything it'll
be caught by the exception handler which
will recover and let it continue also
the SLR implementation in Windows Vista
only has
bits of entropy which means that there
are only 256 possible locations for
ntdll
to be loaded at all we have to do is
create 256 different anti files with the
different possible addresses and send
all of them to the browser most of them
will crash but the exception handler
will handle that and let the program
continue and then we will hit the one
that will hit the right address disable
DP and continue execution if that's not
reliable enough for you there's also the
partial override technique which I'm not
going to describe here because I'm
running low on time but it allows you to
it works by overriding just the last two
bytes of the return address and the last
the last the the randomization happens
in the first two bytes so you can
basically change just you can change the
return address by plus minus 64 K so if
you can find some code inside user 32
that's around the real return address
that does something useful like a jump
ESP instruction then it works and the
Metasploit exploit actually uses that I
used a different technique all right so
now that we've seen how easy these
vulnerabilities are to find and how
horrible they are when I exploit it what
can we do to prevent to prevent these
vulnerabilities from happening and this
can be this can be the this can be the
topic of a you know whole another talk
or series of talks or a book or a series
of books I mean it's certainly not
something I can covering you know the
next 10 minutes but I just have a few I
just have a few observations and ideas
from personal experience so this is in
no way exhaustive
it seems that the earlier you implement
the security in your development project
the better it is if you if you come in
late after all the code has already been
written and then you start trying to
audit it and make sure it doesn't have
vulnerabilities you know it's going to
be really expensive it'll be a lot of
effort if you can if you're starting on
a new project then you'll get the most
bang for your buck if you just choose
the right platform in the right language
in the very beginning for example using
a Java using Java Python or a similar
type of language with virtually
eliminate buffer overflows from your
code because the language does not give
you the ability to manipulate pointers
directly and overwrite data on the stack
well if you look at if you look at web
based exploits certainly cross-site
scripting is you know the main one if
you look at there's sort of two
different categories so you can compare
them directly but if you look at attacks
against the actual executable code like
attacks against the platform like a
attacks against Windows there the
percentage buffer overflows is like very
high like I don't have any numbers of
that but I would just guesstimate you
know something like 75 percent obviously
you know for web based services you know
they have a whole different they have a
whole different you know threat modeling
but for overflows for a minor part of
that but my experience has mostly been
with no actual operating systems and you
know assembly so buffer overflows are a
pretty major issue in that environment
so if you use if you use a language it
doesn't let you override buffers then
you're not going to have buffer
overflows and this will save you so much
so much grief later also if your C++ is
probably the wrong show
in all but a very limited set of
circumstances and that's just my
personal belief C++ combines the very
low-level features of C the ability to
you know mess with pointers and data
directly you have to allocate your own
memory it combines that with the high
level abstraction features of
object-oriented programming so it
combines the worst from both worlds
because it has this abstraction on top
of the low-level stuff it makes you not
think about the low-level stuff as much
as you would if you're programming and C
and you actually have to you know keep
track of every pointer you know very
rigorously so in some cases you might
have vulnerabilities where the
programmer just didn't think about you
know who freeze that where the you know
where the pointers come from what the
sizes are if you use C++ as a pure
object-oriented language you know you
use the STL use all of these you know
object-oriented features then it's not
such a bad language but most people get
tempted into using C++ is just a
glorified C it's like C where you still
use malloc you still use mem copy but
you wrap all this and object but you
encapsulate all that to make it even
harder to understand who is actually
copying what and where so that's why you
should you know if you C++ you should
use it properly
but you should unless you're writing
something really performance critical
you should seriously consider it
writing it in a higher-level language
and even if your stuff is performance
critical in most cases it's possible to
encapsulate and encapsulate the
performance critical code as a library
or an engine and then have all the extra
stuff that is not performance critical
written in a high-level language that
just talks to the C++ library
yes why is PHP so back again PHP is not
so bad if you use it properly but it
seems that the PHP language was designed
to make it hard to use it properly
especially I mean now there's been a lot
more attention paid to PHP security but
in the beginning they had all these
features that are enabled by default
like the registered Global's feature
which basically allows the attacker to
define the initialization value for
every variable in your program yes well
the other thing is that it provides it
provides very limited support for
encoding HTML properly which is needed
to avoid cross-site scripting bugs and I
don't really know of a I'm not that
familiar with web based programming so I
don't know if any other languages are
actually better than that but it seems
that in PHP encoding your HTML data
properly is something that you have to
manually take care of you have to make
sure that every every piece of input you
know you properly encode before you
print it back out and it seems like this
is something that the language could
incorporate in itself especially since
it's running in a VM so it can actually
track that oh this string is coming from
the user
so before I print it out I have to
encode it whereas PHP doesn't really
have any of that and you know you just
have to call the functions manually and
if you look at I mean as I said if you
use PHP right then there's no problem
but a lot of a lot of a lot of
programming samples and tutorials and
you know other things where people
originally run PHP from
don't really pay much attention to that
you know maybe some of them are old and
written from before this was a big issue
but they're still out there so you're
going to have a lot of programmers who
just don't know any better because
they've never been exposed to these
issues was that good enough so I will
give an example of a program that's
written in PHP that's actually you know
very very good yeah okay I'm just a
little bit more time left so here a few
hints about designing secure software
probably the most important thing you
can do after picking the right language
is to design yourself correct so that it
split along the trust boundaries between
different components in the system if if
your system use it if you system
processes both user data and trusted
data or some pieces of it run as root
others don't or some pieces run as
unauthenticated anonymous can be reached
by unauthenticated anonymous users and
other ones from car authentication you
have to split this functionality in
different components and the channels
between these components have to be very
narrow and very well-defined ideally you
would have a actual formal specification
of what the data is that goes between
these channels and you would have a
validator on both ends of this channel
one great example of the is the SSH
privilege separation feature which takes
all the code that's supposed to run as
route runs it as a separate process and
just uses a you know very narrow channel
very well defined to just pass the
information about functions that have to
be run as root everything else runs as a
low privileged user which means that a
lot a lot of a lot of vulnerabilities
that we've had an SSH recently have been
we haven't had a lot but the ones that
we have had
would be in the low privileged code
because that's where the majority of the
code bait of the code is and they would
not allow you to allow you to exploit
there's a sage service and get route
alright here's the more controversial
slide sometimes yeah I understand that
you need features in order to get people
to use your stuff well there's some
features there just a really bad idea
and you shouldn't do them when you look
at them you should say like that's you
know we're not doing that
ActiveX is probably the best example of
that I mean it should never have been
designed the way it was you know it's a
horrible security-wise and in Vista they
have finally come around and they have
does it they basically fixed ActiveX by
essentially disabling until the user
explicitly unless the user explicitly
enables a certain control and that is a
much better approach than what we've had
for the last you know almost 10 years
with ActiveX the Google Desktop Search
web integration is another example this
feature means that any curls domain
vulnerability in a major browser
immediately gives any website access to
your local desktop search data and you
cannot rely on the fact that major
browsers do not have these
vulnerabilities they have had them in
the past there was one last year that
actually was like there was a
vulnerability last year that was
exploited exactly you know through one
of these bugs I'm sure that there will
be others in the future so you know
choosing to choosing to rely on the
browser being secure in order to secure
your product is probably not a good
decision but you know who am I to say
the PHP registered Global's setting
which I previously mentioned you know it
makes the language really easy for
newbies but you know it's really really
horrible if you know you're writing
serious software
one of the things that you should try
not to do unless you're a huge monopoly
and your whole business model relies on
you know having this thing is you should
not try to add security on top of
something that's already broken the
windows legacy code base you know what's
really horrible security wise in order
to fix it Microsoft had to spend a huge
amount of effort on an effort and money
and time on actually going back through
it auditing it it was you know really
really hard and expensive for them you
know in that case they had to do it
because they had no choice but another
case is Oracle which is sort of in a
similar situation they have like a huge
legacy code base very insecure but
unlike Windows I don't really see them
you know making very good progress on
that and here is a there's a smaller
example you know probably closer to home
WordPress versus MediaWiki MediaWiki
written in PHP which is not a very good
language as I've already said but it
hasn't really had any vulnerabilities
you know the number of bugs and it had
been very minor it's because it was
designed well and written well so the
quality of media week is pretty good
WordPress on the other hand seems to
have been written very quickly and
without much attention paid to security
so we keep seeing WordPress bugs you
know every couple of months there's a
new one
and they keep fixing them just one by
one but you know the two months later
there's probably going to be another one
so they are the WordPress people are in
this situation now where they have this
legacy code base full of holes what do
they do and you know since we're pressed
is now that big I would actually advise
just rewriting it you know using the
MediaWiki approach maybe you should get
the media wiki people to write the
WordPress thing and actually get it
secure and this is the final slide you
should assume that all your software has
bugs because anything you do you know
regardless of how good you actually are
at implementing all these previous
things you're going to have issues so
you need to built in you need to built
in things that will make exploitation
harder and that will make it it'll
minimize the damage in case one of your
system components gets exploited the SSH
privilege separation is a good thing the
GS cookies in ASL are in Vista you know
in the case of the anti vulnerability
they didn't stop it but they would stop
a lot of other stack overflow
vulnerabilities so they are serving
their purpose avoiding single sign-on
for web services a few single sign-on
you know if my gmail gets exploited the
attack would immediately be able to
access my Google Finance stuff and I'm
not I'm not sure that that's the best
thing to do if I had to log into each
one individually then you know a
compromised and one of the components
would not affect any of the other ones
it should be a good thing how many of
you use OS X raise your hands all right
pretty good number here's a table of the
exploit prevention features and Vista xp
service pack to Windows 2000 the latest
Red Hat OpenBSD on OS X you can see how
Microsoft has improved the security of
or the protection features in their OS
you know 2000 didn't have anything XP
had stack and heap protections Vista had
the full thing with aslr Red Hat and
OpenBSD
are also there as are you know a lot of
other Linux distributions OSX seems to
still be stuck and you know circa 2000
it has non-executable stack and heap but
at but but but that only works on the
Intel processors so I have PowerPC all
of these at vulnerabilities would still
be exploitable so that's just food for
thought and I will leave you with that
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>