<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>State of the X Window | Coder Coacher - Coaching Coders</title><meta content="State of the X Window - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>State of the X Window</b></h2><h5 class="post__date">2008-02-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-oFxhqYn-g0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning I'm cat Allman with
Google's open source programs office and
we're here today with Keith Packard
principal engineer at Intel and Bart
Massey associate professor of computer
science at Portland State University
they are both safe to say extremely
important to the x.org project and
they're here today to tell us what's up
with that
so Bart and Keith the folks at the
remote sites can hear us okay
excellent excellent
so I'm Bart this is Keith together we
are the among other things the officers
of the extubation whose logos in this
screen there what that means is that we
do a lot of administrative work that
cares about but Keith is also one of the
lead developers of x over the last long
while I have convinced I think it's safe
to say over a long period of time in the
development of X and so between the two
of us we probably know something about
what's going on we want to keep this as
interactive and informal as possible
today we absolutely have no interest in
talking at you so please don't hesitate
to you know raise your hand and if I
don't notice you because I tend to be
that way sometimes stand up and yell do
whatever you need to do to get our
attention cuz you know it'd be great to
actually have us help us know what would
be most interesting to you we took a
stab at it
excellent so um you know what we want to
talk to you today is about the state of
the X Window System and you know it's an
interesting time to be talking about
that because the world has sort of
changed over the last few years in X and
so you know what the message we have for
you today I was taught by a my adviser a
long time ago that you get to have one
message and this is our message for you
today which is that you know we are back
we are back to be
the place which where the
state-of-the-art desktop development is
being done and where you can see what
the future of desktops is going to be
like in a lot of different areas and
that's a position that we held in the
early days and it's a position that we
didn't hold for a long time but now
we're back to sort of being in that spot
again and what we want to do today is
talk to you a little bit about the
specifics of that talked to you about
the specific technologies we have
developed and are developing and what
those technologies mean for everybody
and specifically what they might mean
for those of you who have Google related
interests so that is one of our plans I
think for what we're trying to do excuse
me for using words like Harbinger on
slides I know that's not good but so
this is the X Window System I'm assuming
that not all of you know it's insides
also well and I describe them because
they're somewhat different insides than
you would find in a Macintosh Window
System or a Windows Windows system oh
yeah
the important things to see here there's
this funny upside down server client
architecture where the server it's a
server because it provides a network
service right is actually attached to
your display and keyboard and actually
is the thing with which the user
interacts the client programs are
notionally separated but from the server
by a network of course in practice the
network may be a UNIX domain socket
which is plenty fast or it may be shared
memory which is even faster so there
isn't really any performance impact here
when everything's running locally but it
does allow you to do something that the
other Windows systems don't which is to
actually run your application on a
different machine than the display and
keyboard or on it's a nice thing and it
also provides a layer of separation in
terms of providing this nice
well-defined interface the X protocol
interface between these things and so
one of the themes that you're going to
see over and over in the X stuff is that
everything is very very modular and it
really does have
small narrow strictly enforced
interfaces between the pieces I'm a
client-side guy and I drew the diagram
and so this diagram tends to be a little
heavier on the client side than the
server side trust me that there's a nice
complex picture to be told there to the
most interesting piece of the
server-side picture is probably the
device drivers which is where the bulk
of new work is being done and the
support for extensions which goes across
client and server one of the smart
decisions that the ex protocol
developers made 25 years ago was to make
the protocol extensible and we use that
facility constantly such that we don't
ever have to bump the version number and
old programs continue to work but we
provide major new chunks of
functionality that way all the time and
we need those major new chunks of
functionality because of what we're
doing with the hardware on the client
side there's this whole stack
this is xcb which is the new version of
X Lib we also let you use X lab if you
want this sort of provides a language
programmatic language interface to the
protocol and a little bit of utility
functionality um
glued on top of that is typically a
toolkit that's your dome gtk or your a
you know KDE cutie toolkit or xfce
whatever there's a plethora of toolkits
and the toolkits the toolkits are sort
of where Keith and I mostly stop we do
some work in there but there's whole
groups of people that do that kind of
development and interact and interface
with with the sort of core x.org
community that's the freedesktop.org
project is sort of the coordinating
thing for that and free desktop organ
and x.org are tied together in some
interesting ways so there's that stuff
and that another big distinction here is
that the window manager the thing that
provides your title bars and that sort
of thing is itself a client and not a
particularly privileged client of the
window system and so there again we have
this very modular separation with real
pluggable stuff between not just between
applications and services but between
you know
but between the management application
and the normal applications so it's many
of you may know this architecture I may
be preaching to the choir but I think
it's a nice architecture and the
architecture itself is to the test of
time pretty well and so what we want to
do is talk about some of the pieces
today and like I say please don't
hesitate to interrupt with questions
comments what are we go so I'm gonna let
Keith talk a little bit about the
history because he's better at this kind
of thing than I am and was there for
more of it
okay so X as we know it x11 started in
1987 when a bunch of companies came
together to standardize on a window
system that had started in the UNIX
space called X X went through 10
actually nine versions X 1 through X 10
in about 2 years and people said it
would be cool to have a common UNIX
window system for all the various UNIX
workstations obviously SGI apollo and
sun at that time had their own
proprietary window systems Digital came
along and said hey we can we can fix all
of this and come up with a standard
window system and get rid of their
competitive advantage so kind of a lot
like the web has done in the last five
years or so digital came along and said
well what will make all of your
proprietary window systems or all of
your proprietary networks like we've
done today will make all of those
irrelevant by coming up with a standard
so in 1987 we came up with a standard
x11 and for the next 20 years or so that
standard basically remained unchanged
the functionality from 1987 till about
the year 2000 was the same for 13 years
exactly the same there were no - no
major new functionality so when you came
to a UNIX desktop in the year 2000 or
even 2004 you saw something very much
like we used in 1987 how many people
remember so it really took until about
the year 2001 or 2002 before we started
saying wait a minute all this stuff
really sucks we need to throw all this
stuff away and and layer some new stuff
in and when and politically there were
two options obviously we could either
start a new windows
and if you've seen projects like the why
windows system or the fresco project
those were really ideas to say well that
the X Window System is is dysfunctional
it's not doing what we needed to do it
and provide the the user we can't build
decent user interfaces with this Windows
system anymore what do we do
and so what idea of course was to throw
it all away and build a new Windows
system the problem with that is that we
had the legacy application called
Netscape in that time which didn't run
on these Windows systems and even in the
year 2003 it was very obvious that the
fundamental way you were going to use a
computer was radically changed and in
the over the previous five years we were
no longer fundamentally accessing local
applications and so this the web browser
literally drove the adoption of X as the
continuing standard through this process
it would have been very easy to abandon
X and go to another system except the
only web browser that we had was the
close source Netscape so to some extent
we can thank close our software for this
accepted modern success of the X Window
System and thence over the last five or
six years we've started taking the X
Window System and saying well it is
broken how can we fix it let's add a
bunch of new extensions let's add some
new mechanisms and start writing
applications in a new way and that's
what we've done so this is what you used
to see this is actually cool it's the
Wikipedia page for X so if you look at
if you look at the you know the the
Internet's the Internet's archive of
information about our fine Windows
system this is what they think it looks
like today this is the canonical
Wikipedia X screenshot which is
hilarious it looks just as good as it
does today as it did back then you know
three dollars
yeah three colors is a bonus Y Flags
cost
that teal color was the color in 1990
you know like the bright green we have
today in 1990 was this teal color every
new high-tech company had to have teal
in their logo it was amazing that was
the only color we supported pretty much
but this isn't 1990 our computers a lot
different now you know most of us wear
wear wristwatches that are more powerful
than the SGI computers in a nightie
we assume today that you have no
resource limits so in fact the two most
popular toolkits that we use qtn and gtk
they have a big abort in the middle of
memory allocation function if it fails
to allocate memory it your applications
all crash so that was not true in 1990
acres and acres of code in in the
toolkits of the time to manage out of
memory conditions most users these days
don't have one monitor how many of you
use a machine with just one monitor when
you're not on an airplane yeah one
monitor on your desk you need two of
those the cool kids all have two right
um and more importantly when we take our
laptops around now we plug them into
things right how many of you go home
with your laptop and and use just a
laptop screen yeah see you guys are
primitive yeah see it does work now
that's the cool part the other thing is
is that people expect a lot more from
their computer applications in terms of
graphics capability in particular we
used to think that ASCII was pretty cool
right and in 1990 we made it all the way
to the point of thinking that ooh ISO
latin-1 now that's cool you can actually
have accents on all of your letters
we've moved a little beyond that now and
since that time most most people now use
utf-8 which covers a few more characters
than that and the other thing is you
want to be able to present text in the
native persons you know in it
typographically correct for the language
that you're presenting it in so when
you're presenting Arabic you don't
present you don't present just single
individual letters right
use the cursor forms the letter the
medial terminal and initial form as
those letters to merge those word to get
words together so we expect decent
typography we expect decent graphics and
the other thing is people expect
animation now people are used to I used
to system like Google Earth where you're
where you're constantly zooming around
the screen is no longer static all right
so the ability to animate the screen the
ability to integrate 2d objects into
your animated environment all of those
things have become in an expectation so
now everything's supposed to be able to
move and the other thing is we want to
be able to take one application a single
application developed anywhere in the
world and take it to the rest of the
world we're going to be able to develop
OLPC applications and take those out to
the third world we want to be able to
take Google applications and take those
into countries where Google has no
presence I'm sure you don't have much of
an office in Zimbabwe so we want to be
able to localize and internationalize
our applications in some very
sophisticated ways and I already asked a
question you know too many of yous are
clearly stuck in the in the 1990s with a
single monitor it's so sad
it's a real problem yeah yeah X used to
have this wacky notion that you wanted
to have multiple different kinds of
screens so you wanted to have your black
and white screen and your color screen
when was the last time you used a black
and white monitor pseudo color monitor
or anything other than 24-bit RGB right
and the whole notion that you would even
want to support that anymore this notion
that you want to be able to have windows
in one bit and windows and eight bits
and windows and sixteen bits
simultaneously on your screen
that's so 1980 the notion that you want
to have multiple simultaneous users
connected to the same keyboard with
disabilities and keyboards connected to
the same secured yeah no we still do
that in really Martian applications but
what was the last time you did that yeah
so what we did in the late 1990s was he
actually said okay we'll unify all the
screens into a single virtual desktop so
you can actually move windows between
your screens wow this is like a
Macintosh welcome to 1984
it only took X about 15 years after that
so we fixed that now all your screens
live in one giant virtual desktop so you
can move stuff around
everything is 24-bit color let's see
yeah here's a here's a nice quake
instance for instance this is an X
environment running quake on 24
simultaneous monitors fully 3d
accelerated what special I mean you you
the X you get out of the box will do
this just fine if you figure out yeah
he's gonna fight enough computers enough
monitor we've actually taken to trade
shows as many as like 16 monitors and
it's just crazy you know trying to fight
cables and power adapters
not actual physical water respect me
that CRT is what a disaster okay so one
of the one of the things that we have
moved to is we moved away from this
notion that color is something that the
server provides in terms of asking for
resources oh I want to have a red pixel
now and you ask the X server so what
what pixel values should I be using for
red on today we've moved beyond that and
pick one of the other ones so we're to
the point now when all windows are 32
bits deep and they all have 8 bits
already if it's a green 8 bits of blue
and 8 bits of alpha where we have not
made it to yes we are not using floating
point pixel formats and there's a pretty
good reason for that SGI has a patent on
floating point frame buffers so in terms
of doing open source software
development is very difficult for us to
even consider moving into using floating
point pixel values in terms of the
values stored in the frame buffers so I
would like to be able to move beyond
that I don't know you know how that's
gonna change so we're at this point
we're just an integer pipeline and in
terms of the actual stored pixel values
um this is an odd story in 1991 we came
up with a color management system
although totally embedded in X yeah and
so it's all it was you know that was we
hadn't done a lot of color research
since the 1930s but they were starting
to bring color research into computers
and they were going back to these french
studies from the 1930s and starting to
create computer color spaces based upon
these you know the CIE XYZ reference
standard observer that was developed in
the 1930s
so we developed a color system based
upon those and it was all kind of
client-side which which means we kind of
this weird way the api's couldn't
actually convert pixel values they could
only convert color values so if you had
an image in one color space you wanted
to convert it to another color space
there wasn't any support for that you
couldn't
convert images what you could do is you
could you could you could ask the server
please tell me what pixel value I should
be using for a CIE XYZ - 2 - you know
whatever color value had it could do the
conversion on it on a color by color
basis so is a color space based entirely
upon this old notion where you allocated
pixel values one at a time not very
useful for applications you couldn't
take an image and convert it so we've
pretty much that never took off
shockingly one of those many bad ideas
that kind of died on the vine
fortunately and now we're trying to get
back to the point where we have
legitimate color management systems and
this is one place with a Linux desktop
lags the Macintosh I'll by a long ways
we don't have any credible color
management's story yet today it's pretty
yeah so what we've built today is we've
taken the old X Lib api's and we've
completely replaced that we have two
main rendering api's now have Cairo for
2d graphics and then we have OpenGL for
3d graphics Cairo comes right out of
PostScript so if you've ever programmed
PostScript or PDF you won't be surprised
by it so we didn't really invent
anything when we came up with a new
rendering API we just took the kind of
existing standards and codified them in
a nice easy to use binding they invented
a lot of things but the things they
invented were implementation techniques
we tried to keep the API as familiar as
possible while and I say they I guess I
helped a tiny bit but um they tried to
keep the API as as PostScript as
possible while trying to do some really
nice things with the actual underlying
rendering tricks and Keith in particular
dug up this ported of compositing model
and got it to do some clever things that
we'll talk about it yeah so no tricks
then that's one of the keys right we're
building a standard here one of the
rules about standardization is you don't
invent things when you standardize you
codify existing practice and so that's
what pyro tries to do it codifies
existing drawing practice so if you've
ever programmed in flash
you ever programmed in PDF to to write
complicated PDF documents that whole
rendering model is very familiar
Kairo still needs some still need some
work for gradient support it has fairly
primitive gradient support right now but
we're trying to figure out how to codify
existing practices you look at the PDF
model for gradients and it's like wow
that's really complicated I'm not sure
we need all of that and I'm fairly sure
I can't accelerate that on to many of my
hardware engines and then you look at
the flash model for gradients it's like
well that's a little simplistic we need
a little more than that so somewhere in
between there will try to codify
something reasonable we're moving
through opengl 2.1 we were going to be
moving to opengl 3.0 i'm not sure how
well opengl 3.0 is going to do there are
some conflicts in the opengl community
right now about that api so we're gonna
stick with our existing opengl 2.1 api
it's a fairly sophisticated 3d rendering
environment it's not quite as
complicated as DirectX 10 yet but they
are adding some additional extensions to
OpenGL to make it do the things that
direct x10 does today we've recently
replaced the low-level protocol binding
on the wire with something called xcb
and I should let Bart talk about that
there isn't too much to tell because if
you haven't seen exilim you don't care
and if you have seen X Lib you
understand why it was time to replace
this you know it's a classic software
engineering story really there was this
dumping ground
in the no-man's land between the
application space and the server space
where over 20 years a lot of things got
dumped and at some point it became time
to take this literally megabyte of wacky
library full of protocol bindings and a
complete color management system that no
one ever used to the point where it was
literally broken for a couple years and
no one noticed um and you know complete
implementations of all these crazy
character formats that no one in their
right mind would touch in a utf8 world
throw basically all of that away and so
x cb was a fun project because to
architect because you know i got to
start with really a clean slate and say
well what do we want and the answer was
I want a protocol binding and I don't
want
more than that and I want to automate
and ease the job of constructing
protocol bindings and what we ended up
with actually was something that one of
the coolest features of is that what we
ended up with is complete XML protocol
descriptions of the entire X protocol
including all the extensions and so now
not only can we generate a nice C
binding from that protocol you can and
people have picked it up and used that
same protocol description to generate by
bindings for other languages Python for
example and probably popular in the room
and so you know it's it's been one of
those things where that's kind of an
example of the kind of stuff we've done
all over the place which is to pick up
and say well you know the past is behind
us now we have mechanisms to replace
things without blowing things up let's
actually do the piece of engineering
that maybe we should have done in the
first place but certainly in retrospect
would be the right piece of engineering
to do and you know one of the themes of
some of the stuff we've said so far that
you're gonna see again and again in the
few minutes we have remaining is um this
theme of moving things off the server
side and onto the client side one of the
things that the original sample server
did and the original protocol
specification did is really wanted
everything to all the computation all
the work everything to be done at the
server the server is where the users
interacting so the assumption is that
you know the hardware there is going to
be better you know the 1990 assumption
is that that's where the you know the
stuff is and um it's one of those
distinctions that doesn't seem like a
big deal you're like well who cares
where you put it most of the time it's
all running on the same machine anyway
why would I care um it turns out that
from an architectural point of view it's
most often the clients that know what
they want to do and what kind of
computation they want to get to generate
it and the more you can pull stuff out
of the server and stuff it in the client
the better the client's control over it
and the more that you have the ability
when you do have clients running
remotely for them to do the right
computation and send the results over
the wire which turns out to be a good
idea in the modern world and it tends to
clean things up the server is a big
giant mess and anything that makes that
big giant mess less big and giant we're
very very happy about so things get
split out into libraries etc a good
example of this would be the
translucency stuff which definitely
Keith should talk about because he built
most yeah so we've taken if you look at
the Macintosh window system with its
transparency support it provides an ADD
notion of alpha and Windows and the
Windows system intrinsically I it takes
that notion and inside the window system
itself it has this notion of how windows
are composited together onto the screen
it blends them in Z order from back to
front fairly simple notion in the X
environment when I went and implemented
that back in nineteen yeah really was
2000 the year 2000 when tried to
implement that it made the Windows
system very very brittle a huge number
of changes in the Windows System but all
of a sudden all this cool cool
functionality they wanted to be able to
do like have little little live icons of
your applications or wanted to be able
to do some animated too animated
minimize and ikana fication stuff like
that all of a sudden that had to all be
built into the Windows System and so
instead of this notion of pulling stuff
out of the windows system I I was
dumping more and more into the Windows
system and the server was getting larger
and larger it's like I had to put
projective transformations into when I
was presenting the window so that I
could so I could tilt them to the side I
had to have multiple projected
transformations so I could warp them in
odd ways and all of a sudden is the this
very simple notion of doing alpha
compositing in the Windows system became
an enormous extension so I threw all
that away and sat for three years and
was able to figure out a mechanism
whereby all that I really needed to do
was have the applications paint into an
off-screen region and then tell an
external application about all of these
off-screen images and let that external
application do whatever it was and that
note that fundamental notion of taking
the control of the composite' out of the
window system and placing it into this
external new agent called a compositing
manager
meant that I could do some very simple
extension it took me like three days to
implement and all of a sudden it unlocks
this tremendous amount of capability I
don't know if any of you have played
with either the core X compositing
manager or applications like comp is
that are able to do this tremendous
amount of you know eye candy that was
impossible only a few years ago with a
very small change the X Server itself
and that was kind of a neat thing Oh
similarly we did all the same stuff with
the rendering now all of the rendering
is now done on the client side with the
minimal amount of stuff that the
hardware can actually accelerate put
into the window system server itself so
things like spline Tesla a polygon
tessellation spline decomposition actual
rendering of glyphs from outlines all of
that work is on the client side and the
only thing it's in the server's event a
simple rendering engine it looks a lot
like OpenGL now OpenGL is a very
obviously open jelled has driven
hardware design and vice versa for the
last 20 years so to ignore how other
high-performance api is used the
hardware would be foolish so we have a
very similar notion of only doing the
low-level stuff in the actual graphics
library and pulling all the high-level
abstractions up into the application one
of the interesting questions is okay now
we've got you all this capability to do
eye candy and we've got a lot of eye
candy now one of the things that I'm
kind of interested in is what kinds of
useful things will happen now you know
right now we can make your windows catch
on fire and burn down that that's cool
but you know our hope is that this will
lead to leveraging some really cool HCI
things that will actually make a
difference in how people use computers
that's where we're hoping to go umm yeah
I know it's hard to believe that you
would first go for shiny but there you
are via the drawing the drawing model um
the original drawing model was literally
from my understanding and Keith will
correct me if I'm wrong a hack that was
meant to be replaced later the nobody
knew quite what to do about drawing in
the late 80s and so X did something and
it turned out to be horrible in ways
that we could spend all the whole talk
telling you about more stories about
how it went wrong the good news is
protocol extensions so we replace it all
we did this render Cairo thing that
Keith just described and you know not
only is it pretty but it has the
potential to be hardware accelerated by
your 3d Hardware engine and we're
working on that and getting starting to
get some results with that and what that
means is that you get pretty and you get
at the same time nice quality and in
particular um I think it's important to
say Keith will certainly say this as
well I'm sure that typography isn't just
putting text on the screen and it isn't
just putting it on the screen in a font
um it's more than that it's about you
know making things work in ways that a
professional typographer would
understand as pretty and the back and
even to some extent windows have made a
lot of progress over the last 20 years
in you know being able to use
professional-grade fonts that are
properly hitted for the screen and being
able to control you know things like the
lighting and inter word spacing and
inner character spacing and blah blah
blah
being able to render you know properly
splined you know shapes etcetera so that
you you go from you know remember that
1990 slide we showed you with the bitmap
fonts of doom all you know equal equals
spaced mono space characters it's like
so you know we needed to fix all that
and Keith really there again was the one
who did a lot of that work so probably
so in the year about 2000 or so there
was this push to get any alias text into
the X Window System and there was just
there was this idea that maybe what we
should do is take the existing core text
primitives and somehow sprinkle pixie
dust on them and make them any aliased
and in fact there's a whole
implementation of server-side anti-alias
fonts from the same era in the same time
others of us realized that anti-aliasing
wasn't all we wanted now that was not
sufficient it wasn't
sufficient just to make each individual
glyph look good on the screen we really
needed to move beyond that and get to
the point where the text on the screen
looked good and we also wanted to be
able to provide a for applications to
render text in new ways and still get at
the underlying acceleration primitives
of the system so a lot of the ways that
people are doing a hinting of text and
laying out of text right now they're
starting to change where glyphs are
located on the in in a sub pixel matrix
they're starting to change how using
colors on LCD screens to improve the
appearance of fonts all these kinds of
optimizations are really nice to be able
to experiment with well doing all that
work and the server-side made no sense
because there was no way we could
experiment there's no way we could
explore beyond what the server offered
so instead and at the same at the same
time in where we were redesigning that
text in the window system we figured out
that maybe it would be a good idea for
applications to be able to provide their
own fonts if you're riding a PDF viewer
if you're writing in any kind of
document preparation system that
document preparation system is going to
want to be able to provide its own fonts
if you need to be able to provide if the
client needs to be able to provide fonts
you have to have an entire mechanism for
the client to provide fonts if you're
going to provide a mechanism for the
client to provide fonts why do you also
need a mechanism for the server to
provide fonts and that was the big
Epiphany it's like oh wait a minute we
have to do client-side fonts we have to
provide this as for an application
requirement why are we also going to
develop a parallel mechanism to do
server provided fonts and so we just
decided to throw all the server provided
fonts away there are no fonts in the
windows system anymore the windows
system renders glyphs and you provide
the glyphs as little RGB or little alpha
valued images that's all you get to
provide as a mask and as many as you
want and so now the application is free
to render the glyphs however it was
using subjects hinting using sub pixel
positioning whatever it wants to do it
can provide as many different glasses at
once and so all of a sudden now the
client is in total control of what's
presented on the screen it doesn't have
to rely on the server to do anything Sun
actually came up with a new text
presentation system
that use the that pumped all of the text
for your document all the way into the
Windows system and through to a separate
server on the other side so you take an
entire paragraph of text and hand it to
the X server does this seem like a good
plan and then it would go through to a
separate back-end server which would do
all the layout and font computation and
basically construct an image of that
paragraph to put on the screen so your
application was doing text editing by
sending X protocol requests that that
was really the alternative you know you
either did everything on the client side
or you did everything in the server side
and we decided that maybe standardizing
on a text editing protocol over the
network wasn't the best plan so we
pulled everything client-side I mean
really at the end of this process uses
the same api's to render simple text
that you do to render simple graphics
and it means that things like printing
now automatically work one of the big
problems in mac and windows world is if
you have magic api's for doing putting
stuff on the screen and they're
different from the api's that you use to
provide printable stuff then what the
heck do you do we don't have that
problem because cairo is designed from
the beginning to render to multiple
services and just do the right thing and
you know if you look at what silver
lights doing on the Microsoft side now
they're basically in the same space but
you know by a much different more
elaborate approach than you know sort of
what we ended up with where we can
generate the right things magically
here's some dumb little examples of
cairo rendering output you can hit cairo
graphics dorgon's see this and you know
the reason I wanted to put this slide up
is just to show that you know the end
result of all this engineering is that
you know that is pretty I'm sorry you
know one of the one of the things that
we were we've really lacked on all these
systems for a long time is that the
details need to be right and the user
experience with a presentation of
graphics is gonna be really flawed if
the graphics aren't anti-alias
perfectly if the court if the curves
aren't real curves if composite alpha
compositing isn't done the right way
those little things that you think ah
who cares only graphics geeks care about
this stuff it turns out no not so much
um if you just look at the output
experience that we get as the result of
all this work it's a nice output
experience um we need to speed up or
we're gonna run out of time so now we'll
fly through some stuff and then do some
demos and take some questions but uh the
the 3d rendering um situation I think
we've talked about a little bit one of
the important things here is that really
we're trying to blur this distinction
between 2d rendering and 3d rendering if
you go to cig graph these days and look
at the papers you know 2d rendering is
considered uninteresting and except for
some specialized you know stuff it's
considered an uninteresting feel and
there's this sharp distinction between
the two things we think that isn't right
we really desperately want to be able to
use the 3d Hardware to do good
accelerated 2d rendering and we really
desperately want to be able to UM you
know sort of use the 2d window system
model with 3d stuff and so it's it's a
it's it's a tricky thing to do and one
of the things that's an inhibitor of
course and everybody knows about this I
know we get questions about it so we
have to say is look you know we've had
this problem which is the Apple has had
very tight control over its hardware
Microsoft has had very tight control
over the driver manufacturer I was sorry
the hardware manufacturers and between
the two things were left in a situation
where we've been trying to play catch-up
and actually getting this stuff to run
on real hardware the good news is that
today for the first time really in a
long time we're starting to win that
game of catch-up again and really be
able to go back to have open source
drivers for everything right now
ATI has some given us some docs and
promised us some more Intel has just
released full documentation for their
latest chipset and has provided
open-source drivers for all their
chipsets Nvidia is still in binary land
but there's a good reverse engineering
project underway and some other things
that are happened
to try and deal with that problem and so
you know this grand plan which depends
ultimately on us being able to talk to
modern hardware what a surprise
really is underway input um you know one
of the things that gets neglected in a
Windows system sometimes is input and in
recent years there's been a real
resurgence of interest in the HCI
community and not just what do you
render on the screen but how do you talk
to the stupid thing and in that space I
think we've done some pretty cool things
our our system we just modernized so
that it actually interacts properly with
Hardware and interacts properly with the
with things like USB devices that have
an NH ID specification yeah okay so the
question was what about magic devices
like six degree of freedom input things
what about that my understanding is that
the very latest bits we have have made a
lot of progress with this I don't know
when the last time was you tried it but
keep yeah so the problem is is that we
have two totally separate input
mechanisms in the in the Windows system
today we have the core the core input
mechanisms that only support a 2d
pointer and a keyboard that's all the
core supports we also have a totally
separate neck mechanism called X input
which does support as many axes as your
device has
actually getting oh that part we have
solved actually we have the hot plug
notions the hot plug notions we actually
now use a Hal and D bus mechanism for
notification and new devices in the
system and we automatically incorporate
those into our X input stuff
automatically sets the first two axes
right down listen right that does not
and now it's configurable you can
actually configure it on the fly so you
can actually change which axes are being
used so that's literally the last couple
of months yeah using the wrong two axes
yeah yeah every time you plug in a multi
access device it's like oh my scroll
wheel now is my mouse the input is still
an area where we're doing some intense
research and try to figure out how to
get hot plugin to do the right thing
most of the time the other area that
we're working very actively right now is
multiple multiple pointer support where
you actually have multiple pointers on
the screen simultaneously so if you look
at devices like the iPhone which
supports multi-touch or used to have
look at devices like the Microsoft table
where you have multiple users
interacting with the device
simultaneously we have support for those
devices today and so you can actually
have we actually have a multiple X
pointers stuff supports this notion of
actually doing image capture on every
motion motion of whatever event you can
actually get an image capture so if
you're if you're if you have a camera
device pulling for hand location on the
screen we can actually get an image back
of the hand every frame so you can
actually track the shape and position of
the hand on the screen if you want so we
have devices like that we have and you
could have as many of those as you want
identified as different users now we
have cool Kluge that actually integrates
that with the existing Windows system so
you can have two people using the the
same window system simultaneously
interacting with two different
applications that patches on a branch
and unfortunately the person doing that
work is going off on vacation for two
months otherwise I would have had him
integrated
last week but he's getting his
dissertation published and defending it
here in the next couple of months yeah
then he goes on vacation because after
all when you were done with your
dissertation you should go on vacation
trust me on this one but uh but yeah
absolutely he's done this incredible
piece of working the important thing to
emphasize about that piece of work is
this isn't like some particular
multi-touch device with some particular
display in some particular magic drivers
this is to the extent that it works it
works across everything that you might
want to plug into it all the time and
that's you know that's one of the things
we've really tried to do is not just you
know have demo Kluge's but have things
that really are paths forward you know
the people are interested in Android
phones you know we should say a little
bit about you know sort of small devices
and what the deal is there which is that
you know on the one hand small devices
you know are not so interesting anymore
because the small device smallest
devices you can get now tend to have a
lot of resources and we're we're sort of
recapitulating the 80s and 90s at
Lightspeed in the small device space on
the other hand you know and and as a
result there's sort of not
there's decreasing reason every month to
not just use X on these platforms and
one of the nice things about X is that
it really does scale just fine to these
platforms so you know you can see some
of the things that people are doing that
already do a lot of that okay
yeah yeah awesome this is crap most of
that is X Y a you know so in the above
the so when I say X sorry so the
question was well no the open moko's X
interface sucks sort of in terms one of
the problems that we have all the time
with X we've had it for 25 years is that
the word X is to some extent you know
one of these horrible horrible things at
the toolkit layer and above you know is
a very different world than the server
layer the thing that's getting in your
way I would claim and I think Keith
would agree with me is not the X server
getting in your way and it's not even
the low level X stuff getting in your
mechanisms getting in your way it's that
the kinds of toolkits you write for
small devices and the kinds of
applications you build on those toolkits
do need to be different and X will
support all that and you know we
encourage people to not just compile
genome or you know KDE and run it on
their phone that that isn't a good idea
but what of the things we have is that
the GT k2 GT k windows the GT kfb port
if you run GT kfb you measure
performance of that system in terms of
memory usage and speed and application
interacting response it actually turns
out to be better to run GT k on top of X
because the gtk FB has reimplemented a
window system badly so in terms yeah and
the thing the same thing is true of
other embedded embedded window systems
like this X as a fundamental window
system is lightweight and efficient X
with a cut with a giant toolkit on top
of it is not any better than the giant
toolkit on top of a dumb frame buffer
but it is it is altogether too easy to
say oh we have an embedded device it has
enough memory let's take our desktop
toolkit in our desktop window system and
put those in our embedded device and
that's not such a good idea
um in terms of lightweight toolkits if
you look at something like alt K those
are action that's actually a fairly
lightweight toolkit now it even has even
has GL support in it these days ik and
it can provide a much higher performance
experience in these smaller devices it
is not as pretty as GT K and it's
missing some fundamental functionality
one of the key things we've been talking
about is text presentation one of the
key features of the genome environment
and the QT environments are real
internationalized text layout engines
which are not small it's a huge one
fortunately fonts don't provide enough
information to do credible
internationalist internationalized
layout without the layouts engine
knowing about the language that it's
presenting which really sucks
which means that every time you take
every time you want to do a new a new
character system and present that to the
user you have to write more layout code
in your text layout engine and so these
layout engines grow and grow and grow
and so you have the Devanagari text
layout system you have the farsi text
layout engine you have the you know the
latin one text layout engine they're all
different which is crazy you know the
font designer should have be able to
figure out some programmatic way to have
the fonts know how to lay themselves out
but they don't and so embedded systems
have this fundamental conflict they want
to present a desk type level a desktop
type experience to the user and they
want to do it on the cheap and so what
do you cut out you know do you cut out
your text layout engine do you cut out
your double buffering you cut out your
3d engine do you cut out your
floating-point numbers because you're
using an ARM processor you know that's
that's some huge costs that you take in
terms of taking desktop software and
moving it into a bedded platform it's a
it's a difficult experience certainly
not using X can save you a bunch of
memory mostly because X live is a
megabyte of totally useless code yes so
there are some things we can trim out an
X I have done X on very small
environments if any of you ever seen the
compact it C or other other small
devices that we did it at at Dec the
western research lab built some very
small devices a long time ago we
32 megabytes of memory we were able to
run a complete X stack now we weren't
able to run kinome we couldn't run QT
but you can run X so the question is do
you want X in an embedded environment or
do you want the toolkits that sit on top
of X and if you don't want the toolkits
to set on top of X it is a legitimate
question why do we want X at all then
and sometimes the answer is because X is
more efficient and we found that over
the years every time we do a custom
window system that is tightly tied to a
toolkit it turns out to be a huge amount
of effort to make it go as fast as X
does with that same toolkit API which is
kind of surprising I could go on long
stories but we probably should about
internationalization and localization I
don't know how much more we need to say
there except to say that you know the
thing that's really one of the things
that's really driving this of course is
that open source is nice here because it
means that the local users localize
their stuff and that turns out a way to
get more and better localization what a
surprise then you would have gotten by
trying to pay a team of people to do it
you know one of the things that you know
happened really early as pango which was
our sort of internationalized text
layout engine Unicode text I enjoyed
plus Keith's font config stuff which
help do font selection for that plus xft
that did rendering of Mystic fonts so
with that combined solution we were
really pretty
ahead of the curve in actually getting
what both the Mac and Windows
environments have right now which is you
know the ability to do things like this
you know this is not this is not just
this rotated right this is you know what
if you have mixed languages that all
some of our left-to-right some of them
are right-to-left what if some of them
are top to bottom and by the way you
know there's all kinds of rules for
combining characters and for you know
which rotation of characters you want to
have this is all auto-generated you
basically stuff UTF text it you
they text at Pengo and it does this
that's pretty cool and it does it across
a wider range of languages and a wider
range of constraints really even today
than the competing systems do so it's
pretty cool so we'll wrap up here you
know everything we've told you today I
mean from a Google perspective might be
a little bit well so what the desktop is
dead OH
and you know there have been people
predicting the death of the desktop over
the last few years it's going to be
swallowed up by convergence devices it's
gonna be swallowed up by the web the
only we'll be back to where we were
Keith alluded to originally where the
only application you care about is your
browser on the desktop it's a real
legitimate concern it's one of the
reasons why we're pushing so hard on
this work is that at the end of the day
there's some tremendous advantages of
the general-purpose desktop as a
platform it's a wonderful thing to you
know you can get an immediacy you can
get some resources you can get a bunch
of things that you just don't have with
other platforms but we've put ourselves
in a weird situation over 20 years and
by we I mean the large we of the entire
computing community where it is so hard
to develop for the desktop and develop
quality applications for the Dug desktop
and get those applications to run
cross-platform and to get those
applications to run well um you know and
to give the user a good experience at
the end of the day that people have been
desperate to do anything but develop
desktop applications so the open
question I think the question that I'm
trying to answer in the affirmative is
can we do an order of magnitude better
can we make it so that you would
credibly consider writing a desktop
application instead of writing a web app
or developing a custom device a custom
piece of hardware for pity's sake to get
your user what they need and you know I
think the answer probably is yes but
it's a challenging question do you have
stuff you want to say about that key
yeah and you know in conclusion I just
wanted to say that depending on how you
count this is the seventh eighth or
ninth year of the Linux desktop has
proclaimed in various technical and
trade publications so
what's going on here right how can how
can it keep being the year of the Linux
desktop and yet the limits desktop
hasn't apparently taken over the world
yet and I think you know there's some
really interesting answers to that
question I mean X is arguably the
largest running the longest running
large open-source project in history you
know and over that time you know numbers
of users rate of adoption has been a
constant upward we've you know the
percentages haven't necessarily been a
constant upward because the market has
grown so much in the mean time but we
always have people picking up and trying
stuff and one of the weird things that
happens in this space is that everybody
expects these exponential growth curves
and something's considered a failure if
within a few years it hasn't sucked up
everybody um X isn't like that X is
going to be slow and steady and you know
the thing is that you know we're working
in a weird part of the space we really
are to go back to our original message
trying to invent the future we're trying
to not just keep up which is hard enough
but trying to trying to go where the
desktop is going over the next 5-10
years um we think we think we're finally
back on track doing that we think we're
to where you know you can look forward
to things happening on the month time
scales that used to happen on the multi
years or never time scales and we think
we're with things like MPX or cairo that
we really can be where the major
proprietary folks won't get for a while
and really give users the experience
that they really need to have that's I
think I think that's our message we'd
love to have some questions in what
little time remains
tell Jeff I know if you guys released
the the output not plug last time and I
connect it to my HDTV at home for a VGA
cable and it will not detect and then
this is kind of like specifically for
the car I'm just wondering if this kind
of thing I mean I think it's just a
driver issue but it would not you know
dude it would not read the text like the
front remote lines and everything
during yeah so how do we solve technical
problems with things like drivers
connecting to specific monitors in this
particular case it you have a monitor
that is offering EDI D over DT C which
is an i2c protocol over a wire on your
VGA cable and it's not working why is
that well the the DDC specification is
rather vague about the clocking that we
use for that protocol and the vendors
oftentimes use very tight tolerances in
the monitor and there's not something
the right protocol and so we fail to
make a DD C connection and so we fail to
read the edid data out of the monitor so
we have no idea what modes the monitor
was the driver is appear to be able to
do it like by startups okay actually
this this is actually a very simple
problem then if the problem right now is
that we cannot resize the frame buffer
after we start the X server and this is
a dumb bug and so if you start with one
monitor connected that's small and plug
into a larger monitor
I can't resize the frame buffer to cover
the new monitor it's just a stupid bug
and so what you can do is you can
configure the initial frame buffer size
bigger and then it will work and there's
documentation the right thing is to make
it and you know be fixed in a couple
months
everything's fixed in a couple months
but the larger issue is that there is
this giant push which this brings up to
get rid of configuration and the reason
that we know we're so appalled about
bugs like this is because our eventual
plan is exactly what you say you plug
arbitrary hardware into this thing when
it while it's running you fire it up
when it starts up but unless you're
asking for something very freaky which
what you asked for isn't it should just
work and we've made more progress in the
last two years I think on it should just
work than we made in the succeeding 10
but there's still a long ways to go
we're not fooling ourselves we're done
yet well no actually you know in this
particular case the devices offer the
data to the system not the point is the
administration that have to know or care
so distributions yes how much are we
working with distributions to make their
configuration systems work better for
users and a lot of that really is direct
developer to distribute our
communication about what not to
configure anymore
it used to be you had to configure
everything to make anything work at all
and right now what we're trying to teach
people is no we can auto detect
everything and for setting for the auto
detection is going to work please don't
configure it because you'll get it wrong
and so Debian for instance right now the
default X configuration doesn't have any
mode lines that has any screen
information it's all auto detected and
that's because I'm a Debian developer so
I can tell them to go fix things
yeah that's Annette yeah
question over here
right nvidia nvidia has provides binary
drivers for their chipsets under linux
the trouble with that is if you have a
PowerPC machine like it old Macintosh or
you want to run 64-bit Linux instead of
32-bit Linux you can't use their drivers
or you have the wrong kernel version you
want to build your own kernel you know
shocking or so there are a lot of users
who can't use the binary drivers the
other trouble the binary drivers is the
distributions like Red Hat with their
rail distribution they won't support you
if you use a binary driver because they
have no idea what that does to your
kernel so there's a lot of users that
have very credible reasons for wanting
to use an open-source driver and so what
a bunch of users have done is actually
reverse engineered the hardware to the
point where they can write a video
driver for a chip without any
manufacturers support now you might
imagine this is an not a very easy job
it's a horribly complicated job and
effectively what they're doing is
they're monitoring reads and writes to
registers on the chip as they run the
proprietary driver and they have some
amazing Kluge's include up to and
including page faulting every axis so
they map the card read only and they hit
a page fault every time you try to write
to the card they'll tap the page fault
disassemble the instruction that was
trying to do the right figure out what
address and data is going to go to the
card I think the best pressure that
we've been able to apply is is the
efforts of ATI and Intel to support the
community in the way they want to be
supported by providing documentation we
don't ask for open source drivers and I
work at Intel and we are providing open
source drivers but I think far more
valuable than those drivers is
documentation so that users developers
distributors can fix bugs in the driver
and implement new features that we'd
aren't interested in doing so it would
be nice if indie video was able to do
that as well and I'm hoping they're
going to certainly that their two major
competitors are so if they want to play
in the in the Linux space in the future
they may be forced to it I'm hoping
there will be they will feel compelled
to
yeah whywould invidia NH guy you can
bother because the mark is so small it
is a small market but it is also a
technological adopters market and so
this to some extent there's a well
actually for Nvidia and ATI there's a
there's a non non-trivial market Nvidia
ATI both play heavily in Hollywood and
Hollywood is pure Linux these days they
don't run Windows so if you want to sell
your high-end graphics cards into a into
a Hollywood production studio which is
worth a lot more in marketing they will
ever be worth in actual sales you need
to provide them Linux drivers so in
terms of playing in the Linux space they
don't have any choice but to be in the
space because a lot of the customers are
demanding it in terms of providing open
source stuff a lot of these same
customers are starting to demand rails
support or souza support though from
Novell they're starting to demand things
that the Nvidia drivers it's fair to say
to that well I don't minimize the Linux
desktop market is small it's not as
small as you think it is the the size to
the extent that we've been able to gauge
it of sort of stealth large scale
deployments of in industry of X desktops
is actually quite large and the thing is
companies have no motivation to talk
about those deployments and in fact they
have every motivation not to make a big
issue of the fact that they're using
Linux inside their companies but there's
a ton of them out there and you know the
thing is right now a lot of those
companies are making purchasing
decisions about what they're going to do
over the next five years with software
you know and between sort of some
uncertainties in the Windows space about
what's going to happen and you know this
and that I think it would be very risky
for any kind of manufacturer to sort of
write that market off because it seems
small today yeah well you want to take
one more to us
let's take it's an excellent question
it's cool to actually have the question
what's coming in the next two months
because it means we're doing the right
thing to some extent we're making
progress every couple of months so in
the next two months the were completely
architecting the Intel driver so that
video mode setting and moves into the
kernel so that we can do pretty boot
stuff we can do fast user switching
without flashing the screen and we can
have reliable blue screen of death you
know
people complain about the Microsoft blue
screen of death because it means the
operating system is crashed
well in the linux world you can tell
your operating system has crashed
because your mouse stops moving on the
screen I would most users most
developers would far rather actually
have information about the crash so
we're hoping to be able to provide that
yeah so and the other thing we're doing
is MPX will get integrated so you have
multiple pointer support and we're also
switching the 2d rendering architecture
from user space down into the kernel so
that you would so that you have 2d and
3d integrated in the same pipeline you
have objects to sharing so yes happening
in the next couple of months we do need
to go though it's 10 after thank you
much for your time today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>