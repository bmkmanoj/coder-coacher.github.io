<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Expressive Languages for the JVM | Coder Coacher - Coaching Coders</title><meta content="Expressive Languages for the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Expressive Languages for the JVM</b></h2><h5 class="post__date">2010-08-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WlsD2FiBIbg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright good afternoon everyone I'm John
wadell and i'm here with Charles nutter
today he's been working on a new
language called mera which I've been
working with and Ryan Braun from
Google's also been doing some work with
it and we're real excited to see where
it's at today take it away Charles ok
well hi this is my first text hockey
google it's fun to be here we'll jump
right in my basic info been doing java
for a long time jruby for like five
years now full time and now working a
little bit on another language called
Mira that would kind of get to in the
second half of this so first of all I
want to see like who who's who's doing
JVM based stuff first of all okay so
most of the folks uh is it mostly java
or yeah java since any scala folks no
closure and like playing with it may be
a little bit anybody doing any dynamic
language work ok Python mostly now Ruby
closure know what other uh okay well
that gives me a good sort of picture
where we're at so a focus of all the
stuff him to talk about today is on the
JVM i'm not a vm engineer I'm fine using
the JVM I'm happy with it so the efforts
that are putting it on JRuby and now on
Mira are for me someday in the future
when I start actually writing real
applications to do more work and less
time be able to use the tools I want in
the languages I want and the jvm is
obviously an excellent platform but you
know it's it's not not all wine and
roses all the time Java is a little bit
cumbersome I don't find it to be a
particularly bad language but it is a
bit verbose and a bit large sometimes
there's a lot of interest in fixing that
lots of different JVM languages now more
than really going to be practically
applicable probably but lots of
experimentation and they all
introduce all their own quirks dynamic
languages have their performance
considerations the static retype
languages are sometimes over complicated
or have their own runtime library
requirements or version to version and
compatibilities things like that so
we've got a lot of different tools and
I'm going to look at two today so first
off get to talk a little bit about where
JRuby stands what been doing with it
what other people are doing with it so
compatible with Ruby 187 we're working
on 19 support as that sort of solidifies
and its really it's just Ruby on the JVM
but it's a lot more than just doing Ruby
so I'll do a quick little plane around
with demonstration here um so let's see
jruby demos all right so I think I'll
just go with the MIDI demo because it's
a fun one ok so let's load up a little
window and it's just going to listen for
let's pick the right job huh there this
will open up a little window and listen
for key events and basically turn the
key events directly into MIDI notes and
play it so it's like actually hear that
actually the numbers seem like they're
in the right the right key code or a ski
range to be good scale all right so
that's a little example let's take a
look at what the code looks like for
that and of course this is just using
java swing libraries java midi libraries
a little splash of assembly there that
was fun okay so this is all just pretty
ordinary Ruby code and really other than
the the preamble stuff that's kind of
typical to Java none of this looks like
it's anything but regular Ruby open up
MIDI synthesizer get the first channel
open up a frame to receive events and
then for each of the events turn the
notes on and off it's really all there
is to it and you can do this with pretty
much any Java libraries really nice to
be able to script this stuff we put a
lot of work in on making that that
interface feel like Ruby and it's it's
pretty much like you just have an
entirely new set of libraries all the
libraries you're used to on the JVM
available from Ruby code alright so
that's the basics it's not too hard to
understand this stuff this is just just
Ruby on the JVM and you can do
everything that you could do with other
languages on the JVM so I know there's
not a whole lot of Ruby going on at
Google what what kind of things have you
guys heard these are these are the three
that I keep hearing from people that
Ruby slow right Ruby can't scale
obviously Twitter had to switch away
from Ruby at least for part of things
because it doesn't scale deployment
sucks rails doesn't work well in
existing organizations existing
platforms so I figured I'd go through
these and talk a little bit about why
they may have been true at one point but
they're certainly not now so as far as
speed goes it is true that regular Ruby
18 the standard day-to-day
implementation most people use is not
fast of the mainstream languages if you
want to talk like the top 10 or 20
languages that people use it probably
has the distinction of being the slowest
out of those but that's talking about an
implementation that's really not changed
substantially in 10 years or so ruby 1.9
which does include which which is a byte
code based engine has a lot of
performance improvements is now by most
measures about as fast as running Python
which is at least as good if you're
going if you use to using Python you
know you can get the same sort of
performance out of ruby and j ruby is
actually as fast or faster than ribbon
point nine on most measurements small
applications benchmarks whatever and so
how does this actually work most of the
time when we talk about JRuby people
expect that it's not going to be as fast
as the sea implementation at the very
least but most people think that it's
going to be Ruby running mostly
interpreted on top of the JVM might be
able to get some of the JVM benefits but
there's it's probably worth looking at
three different areas that are important
for what it means to make Ruby run fast
the biggest one I think the most
important one is that all the core
classes strings arrays hashes etc they
need to be as fast as possible you have
to have good memory management because
Ruby is a very memory intensive language
and then eventually being able to run
the Ruby code itself as fast as possible
is kind of the last mile for performance
so as far as jruby goes all of the core
classes strings in a raise and whatnot
they're all implemented in Java so we
get that performance automatically
they've been refined for several years
that we've been working on JRuby using
whatever tricks we can find from the sea
implementation tricks that we know on
the JVM and of course the / moments is
never perfect for these but it's it's
trending well and pretty much any of the
core classes in JRuby should should be
faster than the sea implementations
versions and if they're not we want to
know and we want to fix it so there's a
lot of a lot of effort going into that
memory management I probably don't need
to say a whole lot about this the vast
majority of Ruby applications that we
see on the standard implementations
eventually bottleneck on GC process gets
too big conservative collector can't
keep up with it cranking through too
many objects the heap space gets
fragmented and you've got a lot more
space to scan so JRuby using the JVM we
this is almost a non-issue for us we do
crank through a lot of objects we
actually end up hitting allocation rates
as a bottleneck more often than GC the
GC is still barely a blip on a
performance schedules but we're doing
way better than just about any other
implementations just because we're
piggybacking on the JVM
so then the final one is actually being
able to run Ruby code fast which is
where I spend most of my time on JRuby
so JRuby is mixed mode we do have an
interpreter for Ruby code which means we
can run on phones things like that but
we do switch over and get that code as
it gets hot it's fairly naive right now
after about 50 invitations will compile
that method and then the JVM takes over
if we put everything in the right place
if we line up all the calls if we if
we're very careful and very nice about
how we generate that bytecode the JVM
will run with it and do the additional
layers of optimization for us so can we
make this faster right now saying that
we're around 1.9 performance is pretty
good we don't spend a whole lot of time
worrying about it and for everybody
that's running applications on us
they're able to get stuff to run just
about as fast as they need but we want
to go more there's there's another level
of performance that we could get and the
fact is since we're actually running
mixed mode since we have an interpreter
we could be doing a lot more as far as
optimization the current compiler when
it compiles the code is really not doing
any anything other than static
optimizations looking for specific
patterns trying to reduce the use of
heat based scopes if it doesn't seem
like they're going to be used very naive
very top level sort of optimizations and
that's gotten us very far at this point
we've done a good job with that but
since we are running the interpreter we
can gather information like what calls
are being made and what values are being
used the types of objects coming in and
start using that a bit more to optimize
the eventual compiled code so it's a
work in progress but some of the stuff
that we're working on now probably if
some of this will be in JRuby 16 we can
look and see what the exact target
method was in many cases now we can
actually turn that into a direct static
call with not none of the normal dynamic
call plumbing we're starting to look at
doing actual local variable
optimizations like propagating values
propagating types unboxing when possible
reducing fixnum algorithms fixing a math
down to raw winterlong math so this
stuff is all kind of a work in progress
we're looking at the future things that
are
parts we may eventually need to do we'd
like to be able to be really aggressive
as far as optimizations and back off if
it turns out that we're wrong jvm does
this all the time but it's harder for us
we actually do need to do all the D
optimization work manually so this stuff
will probably come a little bit later
and possibly looking at doing manual
inlining for at least trivial methods or
small methods that don't have a lot of
side effects on them so the die not work
is what i'm calling is right now for
JRuby what works at the moment is being
able take the last method and do a
static dispatch to it it adds a little
guard based on the last serial number of
the type it saw so it's kind of a type
check and a modification check all in
one there's some implicit for a few of
the core type so it can call directly
into fix thumbs and floats and whatnot
and as an optimization for recursive
calls so let's take a look and see what
this looks like ok all right so we'll go
back to Jay Ruby all right so we'll just
use a stupid benchmark like fit which
actually ends up being in JRuby more an
object allocation benchmark than just
about anything else the call to call
performance doesn't make a great deal of
difference it doesn't show up in
profiles but because we have to allocate
fixnum objects all the time for a normal
object passing call path we crank
through lots and lots of objects in the
allocation cost actually gets to us and
I've actually done some measurements
that shows that we in on a benchmark
like this numeric algorithms we end up
saturating the memory pipeline just
trying to grab all those objects so
quickly so how can we improve that let's
take a look and see what it runs like
normally bench fib recursive I think
this is just doing fib 30 so we'll see
how that works out dash dash server okay
so around point2 I think we won nine
runs this in like point three or so so
about thirty percent better or so there
are some repetitions around a little run
faster than this a lot of the ruby
implementation is one way that they're
able to do fast on integer math at least
is that they use what's called a tag
pointer
the first bit or a couple bits of all of
their memory references are just
basically used as flags to know whether
it's actually a fixing on value so they
support 30 bits or 62 bit values and
then they're able to pass them around as
though they were references we don't
have that on the JVM so we pay that
allocation costs but if we can actually
start lining up code a little bit better
for the JVM it can start to eliminate
some of those allocations it can
actually start to help us a lot more
than if we just did straight up dynamic
dispatch the first thing I'll show you
now this will be fun how many people
spend a lot of time looking at JVM
bytecode draw JVM bytecode well you're
going to look at it now all right this
is what I do all day long I look at JVM
bytecode and assembly traces from hot
spot okay so let's go find a fit method
and there's the file method to bytecode
byte byte code and I see fit Rudy ok so
here's the actual method and the
interesting bit here is up at the top we
get call site 1 and we load some
arguments into it and eventually do this
invocation this is actually what we do
every single time we have a math
operation we're doing an invocation
through a dynamic call site to fix them
and that eventually will do the math
return a value for us now if we turn on
some of the die not stuff
dash I'll dine opt equals true all right
let's crank through so let's see what
the performance looks like on this now
this is doing is going to continue its
going to pipe tit okay good enough so
it's about point two before what the
dynamic optimizations are getting down
below point one for this and what's
happening here is it's not commedia
compiling it not doing the naive
compilations letting it run for a little
while so the first result there you see
was a little bit slower than the first
result in the previous example but as it
runs its able to pick up that all right
it's calling fix num plus and fix num-
it's calling this recursive this fib
function recursively all of this stuff
ends up playing into playing into our
hands so to speak so we can actually
let's take a look at the the bytecode
for this I don't know the other junior
you guys love that I keep adding all
these properties okay so actually dumped
out the bytecode for this now okay so we
see a number different methods this is
the one that actually ends up being fib
here this chunk let's make that a little
bigger so you can see now i remember up
at the top there where we actually were
going and getting the the call site now
what we have is basically this code here
so what's happening here we're doing all
the same loads getting the variables in
the right places but you see this LDC
499 so it's loading a constant 499 which
was the serial number of the fixed num
class at the time this compiled loading
that directly into the bytecode and then
it does a check a guard in front of that
that says okay is this the same type has
it changed since last time if not we go
through and we proceeded to just cast it
to a fixed num and do a direct
indication to the less than method
that's the first up first one up in that
the fib algorithm if it fails then down
here it'll do the original
slow version of the dynamic invocation
so it's still true to Ruby but it puts
all of the static moon vacations in
there so JVM is actually able to inline
this stuff a whole lot better and
optimize it much more so that's work
that we're doing now I'm on an algorithm
like this I've run a couple benchmarks
couple tests and this essentially gets
to be as fast as java using Bop using
boxed math which is pretty good we're
not paying any of the dynamic cost any
more we're still paying the boxing cost
the next step for this is obviously to
say okay we're always using fixed
numbers this VAT this variable is always
a fixnum every single call happens that
way can we just do a fast version that's
doing long math and then have a slow
version that does the the dynamic
version with objects if we need to and
that is coming up as well that muchly
won't be too difficult to do alright so
that's the performance kind of stuff now
the scaling thing you know there's
there's a lot of different ways to scale
applications most of them boil down to
at some level processes or thread in
some way maybe lightweight processes and
lightweight threads but essentially you
have a lot of these little bits and
pieces of execution that are running on
and it's true that the sea
implementations of Ruby are not
concurrent like Python they have a
global lock and even though even in 019
does use actual native threads they're
still all blocking on each other waiting
for stuff to happen sometimes you can
give it up if you're blocking on Io or
if you're blocking on external calls but
you still end up largely having to due
process scaling which can kind of be
painful and kind of suck so the JRuby
has always just done Ruby threads as
regular Java threads so creative ruby
thread you're actually running with
regular native thread on the platform
and the JVM handles a lot of the details
for us I think some of the newer Ruby
implementations are starting to add
concurrent threads but it's it's a big
challenge unless you plan for it at the
beginning luckily we don't have to deal
with that so now the downside of that is
that as far as thread safety goes in
regular Ruby it's it's probably all
thread safe as long as you don't
actually do anything concurrent which
isn't really that useful to us people
write these wonderful threaded libraries
and wonderful actor frameworks and
never test them on JRuby so that's
starting to change people are actually
starting to realize that if they want to
test for true concurrency and they want
to make sure stuff is running well that
they need to run on JRuby and you know
we're starting to slowly add
alternatives like adding an atomic class
to Ruby that basically does what atomic
reference or atomic integer can do
adding some nicer locking primitives
hooking into languages like closure so
you can use the closure STM and the
closure data structures entirely from
within Ruby it's all very easy to do so
all of these other options that are on
the JVM are just available to you from
Ruby as well so now kind of the truth
about threading everyone's every every
couple years it changes which which is
the right way to do concurrency but
there are a few immutable truths as far
as the writing goes so mutable shared
state is obviously bad you have to do
your own management you're on
synchronization around it you can just
cut that out and say okay that's that's
the worst end lots and lots of mutable
state shared across a bunch of threads
rough rough times immutable shared state
is good that's immutable nobody can be
concurrently modifying stuff then
everybody's happy but I think the most
applications are probably going to fall
into the middle one of the problems you
run into with entirely immutable shared
state is that you're cranking through
even more objects than Ruby does you end
up burning those allocation rates and
out and GC time very quickly so if you
can use mutable structures only within
certain contexts only within unshared
contexts and then make sure all the
shared stuff is immutable that seems
like it's kind of the best balance right
so along these lines in it when about
rails 22 or so there was a big effort to
make rails itself thread safe they were
sort of coming under attack from other
Ruby frameworks that made this decision
early on and they realized that they
needed to clean this up they wanted to
be able to run multiple requests through
a given process through a given instance
and not have to pay the not have to
worry about the thread safety issues and
not to pay the cost of all those
processes all the time so it actually
runs really well now and in duncan says
continued on through rails 23
rails 23 and rails 30 which is now an RC
so if we go from here to concurrency or
to deployment I can actually show a
little bit of this so deployment has
definitely sucked for rails and Ruby
stuff and it's still kind of goofy
almost all deployments of regular Ruby
applications are still trying to manage
end processes and you know you look at
you look at the history of this and
they're all all trying to solve this
problem of not being able to use a
single process to handle multiple
requests at the same time so start out
basic CGI stuff fast cgi so pre spin
things for you and manage those things
in the background then mongrel came
along and it was a much better server
but you still had to have an external
manager killing processes that went bad
and starting them up and making sure
things were still running passenger has
done a lot better on this they do all of
the management of those processes for
you and it's considered one of their
best features that if a process starts
going crazy that they can just kill it
and start another one which on the
surface that seems great but it would be
nice if you actually didn't ever have to
kill that process and you just could run
and have it keep going and be rock solid
right so this is this is this is the the
basic plan for scaling Ruby and rails on
regular see Ruby we got an anyway
machine and then you can just choose
choose the way you want to die because
you're going to have to have whatever
your formula is n plus 1 or 2 n plus 1
instances processes to be able to
saturate that machine these applications
grow and grow there's no upper bound on
the limits of the regular C
implementation as far as memory and the
fragmentation and conservative GC stuff
contributes to that as well so
essentially we got people running with
gigs of gigs and gigs of Ruby processes
in memory just to be able to saturate a
machine and you know that's that was
like the what WTF moment for me when I
came into the Ruby community I was like
what year is this so the nice thing
about this is since everybody's always
scaled with processes none of these
individual rails instances actually
shares anything the shared nothing
architecture is alive and well in rails
and sessions are usually back in the
database or in memcache or push to the
browser and a cookie there's very little
mutable state that actually exists
within rails itself and that seems to be
trending towards something right so
thread-safe rails really the big things
they had to do was go through and all
the lazy loading libraries make sure
that they eagerly load them if they know
you're going to in thread safe mode any
of the mutable structures that they do
have they did a little bit of wrapping
and clean those up almost all the other
shared stuff they made immutable and
just constructing the whole request
pipeline fresh for every single request
so now you really can do with JRuby for
example one instance actually one
process or one application deployed to a
web job app server and handle all the
requests you want and actually scale
across all the course so the concurrency
thing is a bit of a myth let's actually
show what this looks like all right so I
got a really simple app here so a little
simple rails app and I have a little
demo controller in here all right only
two little actions here and then
actually the interesting one here is
going to be this slow one where we're
going to simulate some sort of blocking
call or some sort of delay in the
request processing so if we actually hit
this house
foo slow alright so it's going to take
actually start the server up that would
be a good thing to do to turn a dad so
Trinidad is actually one of the little
embedded servers that we have for jruby
essentially takes just the web
components of tom cat and puts a nice
little Ruby command line on it and you
can run a server just like that so
Trinidad is thread-safe more run
productions there's no other stuff going
on ok test app just do it like this all
right so we start our little Trinidad
Tomcat rails server and should be up and
going down to to bootstrap JRuby a
little bit ok so there we've got our
process we've got our we got our little
controller and every request is about
half a second right it's like we'd
expect so let's actually play with this
a little bit and see what sort of
requests we can crank through it we'll
just do 10 requests to localhost mmm
slow ok so this should take about five
seconds
mmm it's about right a little less than
two requests per second now if this was
regular Ruby if this was the sea
implementation you'd pretty much be
stuck you'd have to spin out multiple
processes to handle all the load and
then you have to manage however many
processes and as the request to get more
complicated and take longer you're going
to be just scaling out with processes
all over the place and trying to manage
them watching them grow watching them
die it's like a little family really but
if we run this since we run ins with
JRuby we're running with tomcat which is
going to be able to crank up all these
threads and we're running in thread safe
mode so it's only the one instance we
can do you know fun things like actually
put shove concurrent requests through
this let's bring that up a little bit so
we're going to see it okay so its basic
concurrency two should take about half
as long I my two core system all right
so concurrency to get about full request
through per second and let's go up
higher so have fun with that concurrency
20 and 100 requests for a second or 100
requests june so now at this point we're
mostly starting to saturate things but
you can see we're still cranking more
and more requests through Tomcats going
to spin up those threads it's going to
park requests that come in but if it
doesn't have enough room to process them
but they're all going to keep going so
rails and Ruby can scale just fine if if
you're using jruby that's that's kind of
the key the key detail performance is
good scaling is good I mean it's really
nice framework as well which I'm not
qualified to demonstrate as much but a
lot of those myths about Ruby go away if
you use the right implementation in the
right platform so that was kind of the
point of these first section okay now of
course you can do all the stuff in the
platform that you want to do you saw I
called into MIDI libraries and swing
libraries and that stuff all works fine
you know all the tools that are
available for the JVM they work great
with JRuby
there's really not any reason to use it
or not any reason not to use it other
than you know you just not a groupie fan
so there's some new frontiers for us a
couple of these are familiar to you guys
App Engine there's a lot of folks doing
jruby applications on App Engine because
jruby can just bundle up as a web
application actually i'll show you that
quick so let's say we want to turn this
into a java web app here in my rails
directory there's a library going to
stall called warbler and that gives you
a warble command and what this will
actually do is it'll pull down the rails
libraries it'll pull down JRuby
libraries bundle everything up and in
the end we have just a war file so any
rails app that you're developing you can
just bundle up and toss them to any job
application server use all the same
libraries deploy it alongside all the
other apps and it works just fine so
given that since we have google app
engine out there there's a lot of people
that have been putting apps up on google
app engine using JRuby there's some nice
tooling and some nice libraries to make
it easy to help you push it out there
woody or ryan can definitely show you
some of that if you like to see it what
I'm going to show though I think it's
kind of cool there's some work being
done to put android apps or make android
apps in JRuby as well let's actually
jump over there and show one of these
all right so I got my emulator huh so
JRuby whoops that's not the right one
jruby on App Engine I've dubbed rubato I
thought that was kind of a clever name
so we actually have here I'll zoom in a
bit so you can see this nicely this is a
little interactive Ruby console that
runs on the phone now the nice thing
here we can't actually generate JVM
bytecode on the phone well we sort of
can there's some tricky ways that you
can get it into Dex format but we have
an interpreter too so we can actually
just generate new code and run new code
on the phone and play around with it so
if I start interactively writing stuff
here puts
hello let's see he's a Java library
java.lang system get property java not
home okay things like that okay so
system on the phone you know and
actually almost all of this interface is
also written in Ruby and we have a few
different demo applications the one that
I like the best is actually the one that
goes through and implements the Android
API demonstration entirely in Ruby as a
lot of code here and I would strongly
recommend against doing heavy
development with this editor but you can
see we're pulling in android libraries
here escape out of this we've got our
rubato activity we don't have quite
don't have all of the demos there all
right the point is you can actually
write ruby apps you can generate new
code you can do all the same stuff on
the phone that you would do with with
java or any other JVM languages and it
works just fine so Ruby apps for Android
is largely a solved problem we're just
working on getting tooling and and some
of the performance thing is cleaned up
so let's go back to the slides now okay
and like I say anywhere you got a Java
server you can deploy jruby stuff like
any other application ok so now forget
everything I said about jruby I'm going
to switch from Ruby and all the dynamic
language love over to Mira and the
beauty of static typing okay so let's go
back and look at what my day job is I
write Java code all day long to write to
work on JRuby I right Ruby for libraries
and for little side applications on
occasion but largely I write Java all
the time I do little JVM utilities
usually around usually surrounding JRuby
or for JRuby I do lots of byte code
generation it's amazing when you're able
to write like 50 lines of bike
cogeneration and it just runs the first
time that's kind of a scary moment I've
got little I've got interested in doing
mobile and embedded applications I've
done some really small like sub ME
embedded java stuff where like I had to
write my own streams and stuff fun but
you know I've got a fairly narrow scope
and within this narrow scope ruby has a
little bit of trouble fitting so my
problem is that I really do like Ruby I
like the syntax I like the feel of the
language but I write Java all day long
for JRuby is there a way that i could
start using more Ruby I mean we can get
Ruby to run really well but it's going
to be hard for it ever to replace on a
performance level on a footprint level
what we actually do with Java so the
idea for mirek started like this what if
instead of writing this Java class with
all that extra noise that comes along
with it what if instead of writing this
I could actually just write this and
lose nothing at all this is the Ruby
class version of this okay and that is
essentially what we're doing with mirror
so in mira we're pulling features from
various languages are pulling syntax
from ruby the bits and pieces that we
like we're doing local type inference
like Scala and actually some field
inference here and the goal of this
let's take a look Mira's kind of at the
moment like a nicer way to write Java
its Ruby syntax with a few modifications
like type annotations for four
parameters coming in but it ends up
feeling a lot like Ruby and compiles
directly down to Java or two JVM
bytecode and you can produce Java source
with it as well that's one thing we've
been doing is keeping feature lockstep
so you can generate both Java bytecode
and Java source for the equivalent thing
but the key the key feature here and I
think this is one that has escaped
almost all other JVM language
implementers is that we're really
working hard to introduce no runtime
library at all the code you write
compiles to class files and that's it
done with it which makes deployment on
small devices deployment on mobile
devices obviously much much easier so
let's let's dig in a little bit on this
so features from Ruby that we do have
working
optional arguments can show will example
what that looks like a basic internal
iteration closures are functional now
most of the literal types from Ruby
string interpolation it's nice to have
we have plans for things like mix-ins
and open classes those will be coming
along there's other features that we
want to pull from you know your favorite
language of the week for example
extension methods something doing it
something like c-sharp does but making
it look like you're actually opening
classes in Ruby right implicit type
conversions possibly from Scala which
opens up a lot of dynamic dsl sort of
stuff without actually changing any of
the static typing behind the scenes
pattern matching and case classism it's
all sorts of stuff that we could do and
I think we can do almost all of these
with just a compiler and not introducing
any new libraries that's that's the goal
that's the goal right now so let's see
what this looks like in practice here's
you know a simple the hello world from
Ruby and the hello world from mirror
identical code except that this ruby
version is going to require you to
immediately ship a five or 10 megabyte
JRuby jar file along with the
application hello world has now
encumbered you with that library in this
case there's no and no other
dependencies so this is the basic code
that we end up generating the bytecode
we generate for the Ruby stuff and in
here you probably can see that there's
the call site logic there's some
preamble logic and this isn't even the
whole story the call site logic is going
to pick up the puts method from
somewhere that's going to construct the
string from somewhere else and then it's
going to do that call dynamically if you
do this with Mira we're essentially just
turning it into system out print line
same code but compile straight down to
regular bytecode and does does what you
really want it to do under the covers
and then the Java code that we generate
so we have mirror just spitting out
regular Java code that does basically
what you would write if you're going to
write it in Java another example we go
back to fib there's the Ruby code
there's the only change required for
Mira
now we now of course you can't there's
no way you can read this there's about
six different call sites in there it's
constructing all the fix and I'm objects
doing all of the the the dynamic calls
in there will be able to compress with
some of the dynamic optimization stuff
and Jerry but it's still a lot of noise
and a lot of overhead the bytecode for a
mirror essentially it's almost identical
to what you would have if you wrote the
code in Java and wrote compiled it with
java sea and then the Java code of
course which is not the most beautiful
thing yet but we can always pretty print
that or something optional arguments now
of course in this case we probably could
infer that both of these are ants and
just go with that at the moment the way
that the optional argument syntax works
we do have the type on there as well and
here's just the Java code for that
chaining the methods just the same way
that you would if you wanted to create a
series of overloads with optional
arguments the Ruby code for a simple
internal iteration your code is
essentially identical and there's the
Java code it generates and you'll see
we're doing the same thing as Java 7 at
this point creating an unmodifiable list
of those values and then doing like a
Java 54 loop pulling the iterator out
and doing all the iteration for you but
it looks and feels like you're actually
doing a regular Ruby iteration so things
like each and map and select and whatnot
they're all available just by using the
existing patterns of what works on the
JVM without extra libraries a simple
closure so here I'm actually creating a
new thread with the closure and the
logic there is just to do print out some
text again same thing in mira and here's
the java code we generate for it so
digging into this a little bit we're
creating a little binding class it's
going to hold the mutable closed over
state and then creating a little
runnable class both as little in as
little inner classes all behind the
scenes so closures in this case end up
just being sugar over doing anonymous
inner classes anywhere you
got a single method interface you can
just have a closure a block of code and
it refers the types of the arguments and
furs all that stuff looks like Ruby and
feels like Ruby but it's actually just
doing the all the noise of an inner
class that you would normally have to do
okay so now it's important to point out
that this isn't Ruby this is just using
Javas library it's basically java's type
system you don't have things like eval
and mutable classes we can make it seem
like you're opening classes up but it's
it's not Ruby it's a lot of the things I
really liked about Ruby the apparent
features of the language on top of Java
so I can use those features and nobody
really even needs to know i'm running a
ruby and actually you know you can have
like a commit hook that generates the
Java code if you really want but that's
the thing it feels like Ruby all of
these features that people will talk
about that they like so much about Ruby
in ninety percent of the cases their
surface level features their skin deep
just syntactic sugar syntactic niceness
and you hear a lot about the new
languages that say well our syntax is
just as nice as Ruby and it's just
seemed logical to me why don't we start
with Ruby syntax and mate and see how
far we can go to compile it down to the
fastest possible bytecode no runtime
library we'll see how far we can take it
all right so now a little more fun with
Mira just to show a little bit more
interesting code for this there's a
plication for Android called Garrett
written by Phil Hagel Berg's kind of a
playing around with Mira so let's open
that code up and see what looks like
alright so I've got all this application
noise around it and one file here let's
make this little bigger alright so we'll
walk through just a little bit now you
know obviously it looks a lot like Ruby
right because it's just using Ruby
syntax and Ruby's part Ruby parser I've
got a few imports and from here on down
the only things that are really going to
be different from if you were to write
this actually in Ruby code are anywhere
we have to clarify or narrow it or cast
the type so here we're declaring the
variable a is a context here we're
making sure that these are stored as
floats in what essentially gets inferred
as fields on this class x and y and
radius and the rest of this is all
pretty much just Ruby we've got the
bounce logic I'm starting to get curious
about what this does aren't you move
we've got touch events we're doing stuff
with release what is that to historical
X so okay we're tracking some stuff
tracking some some deltas and then draw
drawing circles drawing some text on it
let's actually see what this application
looks like now it's actually interesting
to note this again this is all the code
you can pile this and you get a couple
class files out of it no additional no
additional dependencies no external
dependencies other than all the android
stuff you're using right and it looks
nice if you like Ruby syntax this is
this is pretty pretty clean pretty clean
stuff all right let's go find this app
Garrett have no idea where you got that
icon from okay ah there we go so let's
let's play our little game actually this
used to be just a bouncing ball but I
thought I'd turn it into an interesting
game so we're gonna grab this ball and
just throw it as hard as we can yeah
okay that goes what's my score still
going
31 32 don't think it's going to make it
33 it looks like I think this version
I've still got a limited to velocity of
50 max but oh it did make it sweet 34
okay so let's go back to the code in the
app like this is again this is all ruby
but when you compile it down i'll see
how big these applications are you're
going to make an application like this
with JRuby for example and ship it you'd
need to strip a bunch of stuff out the
jruby jar is anywhere from five to eight
mag depending on how is compressed the
decks process can strip it down a bit
more but you're still have to ship a
pretty big application i think that
rubato IRB app clocks in at about 10 meg
and it's in the marketplace so you can
install it if you like but it's a big
app it's a lot of stuff to ship this so
I've got debug builds here 16k you know
and it's essentially the same code you
would write if you're going to write
this in Ruby but compiling it straight
down we don't have to worry about all
the extra dependencies on a ruby runtime
hey woody where would I go let's see
let's take a look at dubious that would
be good and that's on the mirror account
right let's take a look at this one I'll
just look at the code here so on the web
side dubious is a little framework
that's written pretty much all in mira
but doesn't have the dependencies on a
runtime library other than a few little
things that it ships with doesn't have a
language runtime that it requires and it
runs really fast because it compiles
everything to Java code so let's make
this bigger so you can see all right so
here we go again like we did with Mira
we like Ruby syntax we like the way it
feels let's start from there woody
decided he likes the way at rails
applications are laid out the way
they're structured let's start with that
and see if we can actually do the entire
application in mirror instead of doing
rails let's take a look at a controller
here
contacts is the good one here contacts
controller you have the generated Java
code in there too right alright so what
was it dubious demo spot look all right
here we go he even sort of copied the
rails front page isn't that adorable
okay so here's our appt structure and
now in here we can take a look at our
contacts controller even got syntax
highlighting and largely again it looks
like Ruby looks like you're writing a
rails application index show new etc
we've got some of these things what are
these curious things down at the bottom
looks like they're pulling out some
templates of some kind right now what do
those do let's go back and take a look
and I could say this all can compile
straight down to Java source if you like
you can go to JVM bytecode but you can
also compile at the Java source if you
take contacts controller and turn it
into Java source this is what you get
out so we've got our index a logic it's
actually pulling out a data model here
if we go down and see the different er
bees that were pulled in the different
templates it's done all of the inclusion
of that into this controller done all
the extra logic of turning it into
string of pens stringbuffer repent
stringbuilder appends and this is
essentially all you really need out of
this application but this is this is the
only dependencies you have other than
the google app engine stuff that is
running with you taking what looks
exactly like a rails app and feels
almost as nice as building a rails app
and compile it straight down to java
source or JVM bytecode that's the goal
with mirror
alright so a little bit about the code
base and how it works wheezing JRuby
sparser right now probably going to be
reworking that so we have a little bit
more flexibility to add minor to syntax
changes like I say there's a JVM
bytecode and a java source back end
there's also been prototype proof of
concept work to do a c-sharp source code
back end again since it doesn't have any
specific dependency on the platformer on
the type system you could use these same
syntax with different libraries slightly
different inference engine and output
code for other platforms that's another
goal that may come along on the future
essentially does ast transformation
takes the Ruby Ruby ast turns it into
our parser neutral do ba st in the
middle or mirror mirror AST in the
middle runs type inference over that
depending on what the platform is that
we're running on and then generates the
code and at this point for everything
that you've seen here we've got a mirror
code base with the JVM bytecode and java
source backends that's essentially
10,000 lines of Ruby code type inference
is all written in Ruby the the but the
code that drives the code generation
will not the assume that the ASM library
itself but the code that drives that
generation is written in Ruby the ast is
Ruby so here's the basic sequence Ruby
with type annotations and our modified
parser comes out and we get a true da st
with type nodes that goes through our
transformer to the doobie AST and we
have various plugins along the way in
macros that can do sort of compile-time
transform time modifications to the code
we run it through the type and ferns
logic which again can have
platform-specific plugins or you know
crazy wild type type systems if you like
we got our typed ast out of that and
then we generate whatever the native
code is for the backend since we have
all the type information we have the
whole structure we can generate just
straight-up statically typed JVM
bytecode or Java source so it's small
but there's a lot that you can do with
this and being small means it's very
easy to add new features the optional
argument stuff i showed you i think was
50 lines of ruby code to add
it takes almost nothing to add
additional features to the language how
much how much code did adding literal
hashes costs do you think not much I
mean I think I added literal arrays that
do the unmodifiable arraylist in like 30
lines of Ruby code so you can you can
kind of it you can kind of build the
language the way you want build the
language around your application or
around the libraries you're running with
so places with us being used today the
java bits and pieces in the JRuby App
Engine tooling was actually written in
mirror i showed you dubious there's a
contributor on the list that's actually
adding the bits and pieces necessary to
do GWT applications writing writing in
in Mira instead I think the main thing
was just getting the little inline
JavaScript native things to work of
course it showed some early Android
experiments and it's a young code base
but there's a lot of lot of fun stuff
you can do with it and there's a lot of
hacking going on right now all right so
it showed you the ABS ok so futures for
this the code base is kind of grown
organically it's still only 10,000 lines
of code but we want to clean it up a
little bit and isolate the different
tiers better mentioned the parser when
actually formalized and expand the type
system and actually learn how to make a
type system the get the remaining
features from Java like Java one we're
at like Java 10 level there's a few
little things that are above that but
figuring out whether whether or not
we're going to do generics enums other
java 5 features and you know additional
backends and maybe even front ends since
we have that standard AST in the middle
there's no reason we couldn't transform
other syntaxes I like the Ruby syntax
you know some people are married to
curly braces and they really need curly
brace syntax but there's a lots of
possibilities for this just building up
a nice tool chain that can generate all
this stuff for you all right so then the
last the final plugs that I'll do and
we'll have some questions we do have a
using jruby book that's in bait and now
so if you want to get the basic overview
of a lot of different areas of JRuby you
can pick that up we had a JRuby
for the first time last year attached to
Ruby cough that was pretty exciting this
year we have two conferences planned
already there's JRuby kagi attached to
Ruby kg in Japan next month and we have
JRuby conf 2010 edition which is
basically taking over the enterprise
ruby conference that takes place in
columbus and i think we may have another
one next spring another jvcom in
Minneapolis where I'm from that'll be
fun too okay so there's a few links and
that's about all I have I can open up
for questions on Ruby or JRuby or the
state of the Ruby world or anything well
I think we're probably going to start so
the question was how we going to be do
the process of formalizing the type
system I think we'll probably start by
making sure we have everything in a
needed to represent at least javaone a
level type system figure out which of
the features that we're doing like like
some of the crazier stuff like macros
and implicit sand what not will fit into
that type system nicely and I guess kind
of just looking for suggestions on what
features people are interested in from
other languages especially type type
system oriented ones we don't want to go
completely off the cliff and make a
giant nightmarish type system that we
can't manage but we we think we can add
almost all of the apparent features from
those different languages just by minor
changes to the type system and compiler
and we're looking for folks that are
interested in helping on that stuff too
yeah over here that that's a good
question the JVM bytecode back-end the
question for anybody else is what's the
advantage of having both a JVM bytecode
and a java source back end well
initially since all I do all day is
generate JVM bytecode I just worked on
the JVM bytecode back end Ryan came
along Brian Braun whose another Google
guy here and he was interested at least
initially I think possibly using Mira to
do GWT stuff so the java source wasn't
record as a requirement at this point
maybe there's not a whole lot of reason
to maintain the two backends but it is
nice to have something that's going to
do the full bytecode compilation and
generation for you rather than spitting
out java source and then having a second
cycle to do the Java Sea compilation if
you needed to do something along the
lines of adding circular dependencies or
having external Java dependencies that
require the full Bravo build process to
run together this is the Java source
version is also kind of a nice cheat for
that I think we've talked about only
having one back end but it really isn't
a whole lot of effort to maintain both
of them and it actually kind of keeps us
honest about where we do where we
implement the features of the language
if we can implement all of the features
in such a way that they're mostly macros
and ast transformations then having to
backends is easy if we ever start to
slip into one back end or the other we
know that we're tying ourselves a little
bit too much to one particular format
and doing a c-sharp back end or other
backends would be more difficult at that
point so it's kind of a kind of an
interesting exercise but may actually
have some benefits for the language
itself other questions
time is in that we do have some more
time I could if you guys want to see I
could dig into the App Engine app a
little bit to show you how to actually
works do you guys like to see that okay
and actually if you don't mind just
bring back that browser you had yeah
sure so this app is entirely written in
mira there is no Ruby in it whatsoever
the advantage to doing this is that the
app spins up in about a second java app
engine now supports app yamel in order
to configure the app i just modify this
app llamo file so the app itself has
this little properties window that i can
see what's going on the controller that
we were looking at is actually this i'm
basically copying a a scaffold
generation I don't need to fill this
whole thing out you can generate an app
that looks just like your scaffold in
this case I've decided to use
unobtrusive JavaScript and so that's how
that works now Charlie showed the app
earlier how we had a controller the
views associated with that are here I
have an edit form in in this case I
basically looked at what would the rail
scaffold generated file look like and
just try it just start with whatever
rails is using and then make changes in
order to make it work if i go back to
the framework file itself I have this
params object down at the bottom here i
have this delete method sometimes you
want to pass in an ID because you don't
have it in the URL i can generate this
java style overloaded method chain we
wanted to create something that looked a
little bit like data mapper so my model
really is just this I have a property
keyword I'd specify the names of the
attributes and I specify which types
there and you'll see here I'm using App
Engine types like postal address and
phone number I also need to have those
things imported so that's what's to
import statements do now when I compile
that
Ryan Browns done some great work to
create everything I need to access so
instead of going through datanucleus
he's just creating the methods I need
based on the attributes that I defined
the properties are defined so if you
scroll down here and notice he's got
some methods where he's he's handling
how to get a hashmap of properties or
possibly set the properties and he's
generated all of this code for me so now
I don't worry about type safety I just
do something that feels like I would do
with data mapper or active record I
suppose and it's it's handled all right
well thank you very much every thank you
charles nutter</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>