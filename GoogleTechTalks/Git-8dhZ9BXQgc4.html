<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Git | Coder Coacher - Coaching Coders</title><meta content="Git - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Git</b></h2><h5 class="post__date">2007-10-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8dhZ9BXQgc4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I just want to introduce our speaker for
our get Tech Talk today this is Randall
Schwartz most of you will recognize him
from his many published books on purl
such as learning purl he's also a
founding member of the purl mongers
group the founder and president of
Stonehenge consulting a widely
recognized open-source trainer and
advocate and a contributor to get so
thank you very much
Randall Schwartz for coming today and
this is the get Tech Talk Thank You
Larry thank you thank you everyone thank
you for the honor of allowing me to
speak to you today I also want to thank
my friend Linus Torvalds for kind of
leaving you hanging about six months ago
about what get really was all about let
the great opportunity for me to come
down and actually do my talk that I had
written about a year ago to rough with
the same thing filling all the gaps he
told you what get wasn't about six
months ago I'm telling you what get is
so he'll be more direct for the people
that are looking to get as a chance of
participating I think my talk is going
to run about 45 minutes or so so be some
time at the end for questions so I feel
free to interact with me a little bit
when we get down to the end so I have to
begin of course by giving my laptop of
whack until it gets running here hello
hello there we go
I do want to give a bit of a disclaimer
I have actually been around the git
project since it first began rather
fortunate coincidence was that Linus
moved to Portland Oregon my home about
the time that he started yet and I
invited him out for a chance to sample
some of the local micro brew and he took
me up on that and I said so what are you
doing these days he goes well bitkeeper
just went away and we have to have
something to work with Linux kernel
where so I've been working this little
thing called get and so I had a great
conversation with him right at the very
beginning of when it all started so I've
been around since the beginning of it
and I have personally used yet on small
projects and I've used of course other
systems in my 25 year career almost 30
year career now getting old on both
small and large projects so I have a
pretty good sense of what change control
management's all about and things like
that and
I've also read a lot of people talk
about get seen a lot of things on the
mailing list so I been tracking get
since the beginning that way
they've even provided some patches
forget and suggestions for user
interface changes and I have worked on
small teams with git just small being in
the order of three or four people
nothing really large yet and so I just
also want to say that I don't have any
experience working any large team with
again so that makes me less credulous
well ignore that okay so let's ask
answer the question that line is sort of
stepped around a little bit when he gave
his talk six months ago so git is a
change control manager it's managing
changes to a tree of files over time and
the keyword tree there is important it's
not an individual file change control
management system like say RCS or even
CVS so git is optimized in a particular
set of ways that line is found useful
for the Linux kernel team for example
it's optimized for distributed
development because the Linux kernel is
being developed in many many different
countries simultaneously we have to have
some way of having everybody have their
own copy of things to be able to edit it
and so on and because there's about
35,000 files in the Linux kernel it has
to be work really fast it has to work
really well with large file sets with
lots and lots of files you can't have
something that is proportional to the
number of things in a change set it's
also really optimized for complex merges
this means that we can take the two
people's work and bring them together
easier probably would get than almost
anything else out there I would say
anything else but somebody would
challenge me on that I'm sure it's also
optimized in an interesting way for
really really really encouraging you to
be speculative we'll see how this works
in a few minutes but to really just sort
of say I'm going to try something here
and I don't know about you but when I
try things sometimes they don't work and
I don't want other people to know that I
tried something that didn't work and so
this has kept me in the past from say
making the changes in keeping track of
them in the centralized repository
because I don't want people to see that
I made mistakes so I'm kind of
embarrassed that way when that happens
what's great about
is I can make all these changes and all
these managed changes in my local repo
and never publish it if it never works
out there's not even an advancement of a
version number to even notice that
something went wrong so it's really good
it really encourages a sort of
speculation which is very good it's also
optimized at being fast so just getting
things done really really quickly like
you know 1/2 a second for a merge or a
couple seconds to do a diff and things
like that for 35,000 files in the Linux
kernel tree it's also optimized for just
working to just continue to work there's
very few ways that things could possibly
blow up and most of them won't result in
the loss of any data so your stuff isn't
going to get lost it's very very careful
to check things as they're being created
and only add objects in the tree and so
on so to contrast that with what git is
not optimized for let's say you know
because it gets not everything it's
optimized for these sets of things it's
not optimized for tracking permissions
and ownership because as as was decided
by the design of the thing it's really
about source code management source code
doesn't have permissions and ownership
source code only becomes things that
permissions ownership when they're
finally installed so it's up to your
install tools your build tools to
actually add that layer of metadata to
it and it's also not optimized for
tracking individual files with a
separate history so for example one task
that get will definitely never be really
good at would be say putting your entire
home directory under get because the
relationship of changing some file in
your home directory compared to some
other file on your home directory
generally doesn't have a relationship
and but get really wants to make sense
out of the fact you made both of these
changes and it doesn't it's not good for
that sort of stuff
putting slash etcetera under get would
also be a bad idea too although people
have tried it people trying some really
weird stuff with git now it's also not
optimized for making things painful ok
we got rid of that we'd say that's not
really the thing we want to make it do
so why again some of the background here
was absolutely essential for Linux
kernel development because it was
created about two years ago two and a
half years ago when bitkeeper suddenly
became unavailable and the story behind
that you can go read on the net I won't
the bad karma from that but what's great
is that with git you don't have to be
special to start making changes that can
be tracked you can simply take the repo
for the entire Linux kernel or or the
the KDE tools or or wine or whatever
these projects are that are using git
you just take that the entire repo and
you start making commits in your own
workspace and then you can publish that
and if people want to accept that back
in that's fine but they can do it at
their leisure you don't have to sort of
first go please make me one of the SPN
committers or one of the CBS committers
here you just go ahead and start making
your changes and you publish it when
you're ready
so anyone like I said can clone the tree
they can make and test their local
changes to make sure everything works
before publishing it out to the to the
the center and then git has two modes
for publishing your changes you can
either send them back in as patches via
email and a sort of highly structured
email that's human readable but has all
enough right bits in there so you can
tell what change this is against what
changed set this is against that's and
so on
even what file it is but of course you
can also publish your own repository so
if you have a publicly available web
server or a machine that can you can
have a inbound connections to you can
put a git server up and say ok I've made
these fixes to the software you're
developing they're published at this
address here's the URL come look at them
and if you want them merge them into the
mainstream because I that would be
really handy so it's great you could do
the submitter miss patches or about
publish them as a repo and what's great
also is that the tools that allow me to
develop individually of course the rest
of the world will still continue to
develop more on the same software so
there are good tools for tracking that
being able to make my changes now relate
to this release instead of the previous
release so I can rebase my changes we'll
see how those tools work in a few
minutes so really
although kernel and org is still the
place where you would get your Linux
kernel from it's really just a
convenient watering hole they could just
be that we all connect to Linus's laptop
wherever he happens to be and it would
work exactly the same way or any one of
the ten lieutenants that are sort of
looking over each individual area they
all have exactly the same code so
can connect anywhere really and pick up
the code and the changes that we want to
get they all have the same history so
how does it do that well it has a couple
of specific properties that make it
really interesting one is the odd notion
of a universal public identifier you
will see in a few moments this thing
that this notion of the sha-1 we have a
40 character hex string that is
absolutely unique
you know Universal unique identifier and
it allows us to talk consistently no
matter where we are about a particular
commit or a particular file or a
particular directory with direct ease
and in a way that's cryptographically
secure none of this you know my 245
release is really your 992 release and
we have to somehow coordinate the
numbers to make it make sense once we
come together another key feature of yet
is that it understands multiple
protocols so in other words we can
actually access a get archive over HTTP
relatively done protocol there if we're
going to be doing uploading pushing back
we're probably going to be using
something like SSH so we SSH and there's
a restricted shell available so we can
have a controlled uploads and through
SSH and there's also the git protocol
which is a good way to pull things down
because my git client can when it's
talking to a get server can compare
notes about what it needs to pull down
and do the transaction much more
efficiently another thing that's really
interesting about the way it has as a
property is that the objects the files
the directories the commits the tags are
all stored in a very efficient manner
we'll see how that works in a few
minutes as well another thing that's
essential to get that makes it work
really well is that everyone has the
entire repo and the disk is cheap not
only that but because of the efficiency
in the way get stores it you can take
the entire history of the 2.6 Linux
kernel in the git repo and it is 1/2 the
size of the current checkout so you've
got this entire history thousands and
thousands of changes all available to
you and only one hat and still only one
half the size of the are just checking
out the latest version so it's actually
faster to download a git repo of the
Linux kernel that is to download the
current check out that's the kind of
compression that's achievable here I
think the x11 people X 11 are 6 when
they did that they found that every
change x11 are 6 all the way back to the
beginning made the repo
only twice as big as the current
checkout so again very efficient way to
store history we'll take questions at
the end
Thanks okay easy branching and merging
like I said it's very very easy to start
off and try something new and put
creating your own branch and then
bringing that back together and figure
out where things are it's very very easy
to do that also because of the way that
git is tracking all the commits all the
changes to your system computing the
common ancestor a big problem when
you're dealing with CVS for example is
immediately computable you always know
all the way back to where the common
ancestors came for a particular
commitment particular merged and the
nice thing is that patches and repo
updates can be transported or mailed so
that means that we don't have to have a
live connection we can send it over you
know SMTP from hop two hop until it gets
to the destination binary patches are
also supported that means I can use a
git archive to track everything on my
website for example all my JPEGs images
things like that that are related to
building my particular site so it's
pretty cool now the universal identifier
is I mentioned a moment ago sha-1 it's a
king every object has a unique sha-1 to
identify it and objects in this sense is
that everything it's in the object
repository which consists of the
contents of a file so obviously we want
to track the contents that's the whole
point of a source code management
software subtract the content so we call
those blobs in the terminology of the
--get software a tree so a directory of
blobs or other trees recursively
so given a sha-1 I can drill down
through my object tree in my repository
and come up with the entire tree from
there down so the sha-1
points at a tree object which points at
other tree objects and points at the
blobs and he's one of those points of
more tree objects more blobs and so on
all the way down the nice thing about
the way this is done and the way it's
been laid out is if you move an entire
subtree from one place to another in
your working view it still will have the
same sha-1 for the top of the tree so we
don't have to store two different copies
of that in the repository because the
sha-1 remained the same because
everything below it was still the same
so this really allows for a fish
renaming reorganizing without having to
get a second and third and tenth copy of
that same JPEG or the same set of files
in this particular subdirectory it's
really a so that's a nice feature of
that
another thing that ends up in the object
tree are commits a commit is really the
ultimate product making changes to the
software so a commit consists of a tree
sha-1 so this uniquely identifies all
the stuff down below it as we just said
on the tree thing there plus zero more
parent commits typically a commit making
changes is going to be changes to
something that already had changes made
to it most the time it'll be linear so
lots of commits that have one parent but
there'll be some commits that have two
or more parents if it was emerge for
example so this gives us again a
complete tree backwards now the
interesting thing about this is that
that means if I know a particular sha-1
I don't only have the entire tree that
it represents so I know precisely all
the files that belong to it and all the
directories that those files are
contained in but I also know the commits
going back in time or multiple commits
if it was emerge this means that a given
sha-1 identifies not only what's
currently there but also the entire
history and it's cryptographically
strong so now we have an entire signed
history of the 2.6 kernel by knowing one
single number and using the object for
use to translate that back into both the
snapshots over time and the commits that
led us there and all the reasons for
that a commit will also have a message
about why the committed was actually
made the little standard text that you
would have in a commit message notice
that that's part of the commit and
because the commit is sha-1 signed the
text relating to a commit is signed so
we can't have somebody come in later and
change the text on us because it would
be an entirely different sha-1 we know
then something about tampered with so
this again is the power of having a you
nice a nice cryptographically strong
number to manage all this with a tag is
is just really a commit that has a
special purpose in life it's basically
an object that has some sort of subject
so we can keep track of it it's given a
name a nice identifier and an optional
payload when I say you know if I'm -
saying this is the release of the kernel
2.6 to 22 I commit
that to a commit and everybody will know
that that really was me saying that
optional gbg signature as well to cover
that so tags aren't really too special
just giving a unique name instead of
having the hex the 20 40 character hex
string to assign to a name so these
objects are all living in the repository
it efficiently creates those objects as
needed so as we change data update data
we're going to be adding things to the
repo and the objects are generally added
not destroyed this means that we can
have concurrent operations in our git
working tree that still work because
we're basically just adding objects to
it all the time there is a way to go
through and do garbage collection but
you the warning message by that says
your repo needs to be absolutely static
nothing else can be working on it when
we're doing the garbage collection
objects are actually placed very
efficiently immediately into their own
file in the repo but we can run cleanup
processes on those there's a tool called
git best GC that will go through and
pack them a packed object can is often
stored as a difference from some other
packed objects so there's a lot of
calculations made to really make the
repo be as small as possible and so we
go through from time to time repacking
things just to make sure that the repos
is consistent and yes I said packs are
often representing those objects then as
Delta's so that similar objects say a
large file with maybe three lines
changed in the middle can be represented
very efficiently in the repo so we don't
have lots and lots of different full
text files for different versions packs
are also used as the way we transfer
things between repositories so when my
get client is talking to a git server
they will exchange information about
what needs to be sent the server will
then create a pack so that the
transmission space is most efficiently
possible used as it can be
of course commits or what we're doing
we're making work we're changing things
it's the whole point of a change control
management system is to manage that so
commits with the rule so again one or
more commits form the head of all the
object chains so that's what we call the
these are the branches a branch is
basically a commit that's just a head of
an object chain and there's typically
one called master and that's really only
by convention there's nothing
nothing special about the name master it
just happens to be the one that gets
created when you first initialize a
database or initialize a git repository
but you don't ever have to have that
when you can delete that one and make it
something with your own name in it but
people just tend to leave the one called
master because it's easy that way and
you can make others it will I mean like
I could be for example trying to fix a
particular problem so I'll create a
branch called fixing problem X and I'll
start going off in that direction making
commits on that that are deviating now
further and further from my original
master and at some point I'm going to
say yes that commits that sequence of
commits does what I want it to do and
then I will merge that back into master
and that becomes when you master at that
point but there's really nothing special
about master so everything that's in the
repo that I'm going to be able to access
comes through these special top-level
commits so I'm always drilling down from
these top-level things if you want to
think of it as a giant tree these would
be the leaf nodes of the tree this is
the the tail-end over they had n
depending how you look at it so with
each one of these head commits as I said
before you've got the tree represented
as one sha-1 and you've got the parent
commits going back in time going the
other direction so again this commit
gives us the entire history and the
entire current state of what a
particular commit a particular working
tree looks like
so you chase down the parent objects to
get the earlier commits and their
respective trees so we can always get to
that when you first create a git repo
you're creating a commit on the very
first hit that has no parent commit
obviously because you're not dealt it
off of anything else so a brand new repo
will have a commit that doesn't have a
parent sorry about that it's orphan okay
so we need to have a place to do our
changes we have to have a working
directory a working tree what's one of
the nice features about get though is
that it there is a dot git directory at
the top level of your working tree and
nothing else there's no additional
pollution of every directory all the way
down as some of you that are familiar
with CBS and SVN and probably just what
every other change control system know
so there's no pollution of deeper
directories its grip - are friendly its
very nice all you have is this one
get up at the very top directory and
that get directory contains all the meta
information that's needed all this is
well your repository objects are and
things like that there's a plain text
file called config it's ini style that
you go in and edit and that controls the
behavior of all the other tools all the
other changes and things there are tools
actually to edit it from the command
line to if you really don't feel
comfortable running a text editor of
course then why would you be building
stuff but if you're not comfortable the
text editor you there's also a tool that
can allow you to add things and check
values and things like that in this file
there's the object repository it's done
like a two or three level directory
thing I I never need to look in there
the tool just manages for itself so it
just goes in there and then the heads
which are the things that you can make
commits on to are in ref slash head
slash whatever and they're again plain
text files I think I think Linus has an
aversion to anything it's like binaries
in here so almost everything is plain
text files when it candy and those heads
for the most part are just 41 byte
string the 40 character hex string with
a new line on the end so they're very
very lightweight a branch is nothing
more than a 41 character string which
means branches are incredibly
lightweight we just their new file gets
created in here in fact you could just
type in an arbitrary hex string as long
as it maps and your object tree
somewhere it would call that ahead
without having to do any other changes
in your database tags are similar same
sort of structure but again the
reference by slightly different commands
there's commands that know only about
tags versus references there are logs
being maintained if once they're enabled
you can then look at the history of a
particular tag or the history of a
particular commit this lets you do
things like I want this branch at 4:00
p.m. yesterday because the logs would
know exactly what happened otherwise we
have to do everything simply by
referring to the seventeenth parent
which isn't very exciting so there are
logs being maintained that have date
stamp relationships which are really
nice and most of the time on your repos
you're also going to be tracking other
people's work and so there under the
refs remotes area we create what's
called tracking branches these tracking
branches are just like the ones under
refs heads and refs
tags are going to
tane the 41 character sha sha Wan
representation but they're pointing at
stuff that you got from somewhere else
so it's not stuff that you're making
commits on it's stuff that you're
tracking that other people are doing so
commands can use all these
interchangeably but generally the
remotes or things you're going to be
tracking on and not committing on you're
committing on your local branches that
are in reps heads there's also the index
which is sort of interesting it's
probably the least understood part of
get I can't even say I've got my head
fully around it but it's a it is
essential to know about it for certain
operations and I'll get to that in a
second and then finally there's this one
file in there called head and all it is
is it contains a pointer to one of the
things in refs heads it's the current
branch whatever current branch means it
means the things that you're going to be
making commits on once you say commit it
goes through the head which then points
at one of the branches and then makes
the commit on that branch by adding a
new commit to that when making that the
parent so the interface between the
working tree and the object repo goes
through this intermediate thing called
the index and Linus has said a number of
times he could just as easily call it
the cache but then it would still be
just equally mysterious so he calls it
the index and most of the documentation
so I'll use that terminology here but he
says it's more really just a cache it's
just speed some things up we really
wouldn't ever need it but it's in there
and so on it's really a directory of
blobs the directory of file contents it
it's really where the next commit is
getting staged so when you actually say
commit what you're doing is turning the
index into the next commit now that
means that as you're editing files and
you're going back and forth editing for
this file editing that file and so on
git isn't tracking that it just simply
says oh you've got files that you've
changed now it isn't until you add it to
the index that get says oh okay now when
I commit this new contents of this file
will be part of the next commit and what
this lets you do is actually have sort
of a dirty working directory where you
have some files in there that you've
updated maybe there you've been able to
debug flag or something like that but
you don't really want to commit as part
of
your commit you simply change it and get
will tell you by the way you've change
this file that I'm normally tracking but
you haven't told me to take this version
and make that the new version so it lets
you know that but you can tell it no no
I want you to leave that file dirty I
don't want it to be part of this next
commit and so the index lets us do that
staging for that so we don't add it to
the index too we really want to make
that part of the next commit so of
course committing it then it's going to
take that index turn it into a real
commit object and then we're fine so the
difference is between head which is the
current commit that we have in the index
will be anything that I've changed and
told that it wants to be part of the
next commit but not yet committed the
difference between the index and my
working directory will be things I've
changed but I haven't yet told yet yeah
go ahead and take that version as the
next commit and also anything that's on
tracked so I can tell yet
this is nothing you're paying attention
to and that of course would be a
difference between the index and the
working dirt as well and the index is
also using particularly when you're
doing a merge when a merge fails the
index doesn't have anything in it that
is conflicting so it's up to you to then
go back and say edit the files that need
to be changed and add those the index
and finally make the final merge commit
when that happens a merge that is
successful by itself of course will go
ahead and just produce the new commit
and update the index to reflect that one
of the things that's interesting about
git there's lots of interesting things
about get but here's one of them is that
git doesn't record any explicit renaming
now this is an interesting debate that
comes up about every two or three months
on the git mailing list it's like why
isn't there some sort of track that I
really did rename this to that and going
back through the archives you'll see
over and over again Linus a and the key
developer saying exactly the same thing
which is that basically exact renaming
can already be determined by the sha-1
comparisons if I take this file and move
it over here it has the same contents so
therefore git can notice that that's
been a rename when it's doing merging
when it's doing logs if you ask it to it
can figure out that those two are
related but what's even better about
that is that if you copy a file to two
different places then all three of those
will have
same sha-1 and if you made a change in
one of them during a merge or probably
wanted to make the change on the other
ones as well so by not having explicit
copies and explicit renames recorded we
actually get to do better tracking
better merging easier merging than if we
recorded those explicitly so the thing
is because the computer can find these
far easier than you can you don't worry
about you leaving one of those out
it'll just find it for you and the
problem is if you make it explicit it's
going to be wrong sometimes you get you
know a rename to be an a rename to see
conflicts and so on those never show up
and get least not in the main sort of
way because when you're wrong of course
it's going to break merges bad idea
don't want to be breaking emerges and
even being right will break some merges
so the essence is that what git is doing
is tracking the snapshots of the result
of whatever you're doing I mean you
could take all the kinds of file away
type it all back in from scratch and as
long as it has the same sha-1 it goes up
same file it's not tracking the actual
container it's tracking the contents and
that makes get a lot more flexible than
some other systems that I've used in the
past yet of course is good at
transferring stuff between repositories
all the basic protocols there you can
just simply rsync a repository for one
place to another and in the new location
it works just fine HTTP and so on the
git protocol of course being really
efficient for transferring stuff from
server to a client SSH protocol SSH over
our git over SSH I should say and of
course local files it also has the
ability to speak well play well with
others there's full import and export
with CVS for example I use get to track
a number of projects that I are
published as a CVS archive and what's
great is that I can then at 30,000 feet
you know up in a plane not just by
myself there'd be a little hard but up
in a plane I could be sitting there
offline looking at the entire history of
this archive that's being maintained in
CBS's project being maintained and CVS
and I could even make commits and make
changes and test things and so on
whatever I can do in the you know in my
airplane chair they're probably not
everything but a lot of things there
and then when I get back on the ground I
could take that and push it back as a
CVS commit so the people on the main
part of the project have no idea I'm
using get have no idea I'm tracking the
project would get and this is tools that
are in the core that to handle the
import and export of that also SVN as
well import/export with SVN there's
import from arch in the core and as I
said I'm using CVS nsv and import to be
able to have access to all of the data
of a number of projects I'm tracking
available to me when I'm offline 30,000
feet or wherever it might be middle of
the backwoods somewhere and so on there
are a bunch of other third-party
solutions out there they're not part of
the git core I know that there's a very
very interesting project to make a
really fast perforce
importer forget I know that's important
to a lot of you guys here so I wanted to
bring that up so yes there's people
working on that solutions going in and
out like that this is also sort of
interesting suppose you're in charge of
the repo and you say okay great
our project is migrating to get now
we're going to get rid of CVS we're
going to use git from now on but then
you've got a couple people there on
there you know ancient laptops or
desktop machines and they don't want to
learn get all the one to do is keep
using their old GUI CVS tool that
they've been using for a long time
there's actually a CVS server in the get
distribution that sits on top of a git
repo and lets them make CVS commits and
checkouts just like they're using CVS
still so that's a great way to go back
the other direction for people their
legacy people that people that just
don't want to relearn anything don't
want to learn the five commands at the
lead with git and so it's great because
that means repository can act for legacy
clients or humans I like that legacy
humans I guess probably fits pretty well
for that I must use CVS it's what I've
been using for 22 years I can't learn
something new right so for people like
that would take care of that for them
you can get get from the get to
repository Kirsten you have a
chicken-and-egg problem if you don't
have get yet how to use the git protocol
to get get how many times can I say get
in the sentence there so you can get it
using just a standard tar.gz that you
can unbundle and compile and then you
will have git so you can download the
latest version of that there are
packages available for all the modern
standard archives and so on and once
you've bootstrap get you could actually
get cloned to get developer archive
that's a hosted on kernel.org and also
the git repository at repo repo dot org
that's easy something like that I get
that I track it every day actually I say
rebuild once a week or so there's a
there's a fairly stable branch of that
that I've never had problems with and
there was only one time an entire
two-year development when something
unstable actually was slightly dangerous
so it's really a fairly reasonable thing
to keep tracking and it's great because
you can give feedback then to new
features and things like that back to
the development team there's also a
maintenance branch that's like even
lagging that a bit where they have like
major announced releases on that one but
the stable branch is not bad that's like
it changes every day but again there's
only been one time in two years when it
was actually dangerous and and
immediately the flag was raised on the
mailing list to say well wait wait this
will break something so don't download
that yet okay so it's not too bad
main is Lisa very stable right and I
install mine and op get the way I can
get out of the way and I just add up get
up get B into my path there's about 40
commands that gets installed there so
you want to add that to your path to be
able to access all that stuff speaking
of the commands all the commands and get
start with git - so that's pretty easy
to kind of identify what's a git command
what's something else and but in order
to make it possible so you only have to
add one thing to your path there's just
a git command by itself and if you give
it arguments it will map itself into the
other command get mumble foo will
actually be the same as get - mumble -
foo you can type in either one and it
works exactly the same this makes it a
little confusing when you're reading
tutorials and online information about
git because some people prefer the git -
convention other people prefer the get
space convention but they're really
talking about the same set of tools
it's just that different people use
different conventions might as well so
the nice thing about this single get
tool is that you can put just that entry
and say use a local bin and everybody
has access to get through the single
entry point rather than having to have
an entire directory added to everybody's
path that wants to use it
and also works for all the internal
calls as well and the man pages of
course are still going to be under get -
mumble - screw so you'll have to know
the convention either way you'll have to
know that the real full command is named
with git - rather than get spaced but of
course you can always use get help
mumble foo so it still works so pretty
easy there of course the internet series
of tubes we know that and that's carried
forward into the get metaphors the
low-level get operations line is decided
to call plumbing and of course what does
that make the higher level operations or
porcelain so you'll see the terms
porcelain and plumbing a lot in the get
documentation the key difference between
porcelain and plumbing is that generally
you won't be invoking the plumbing
directly at the command line there are
basically tools that are there for other
tools to use some of the porcelain
actually uses some of the existing
plumbing shells out to call various
subtasks and so on more and more of the
porcel knows being rewritten as
monolithic processes using the library
that slowly being developed forget so
that they don't actually call the
plumbing anymore but the Plumbing's
still there and is reasonably designed
so that you can write your own custom
tools using the plumbing that's
available as shell calls back and forth
and be reasonably assured that say you
know spaces and strings don't get messed
up and stuff almost everything has like
zero padded values as an option and so
on so really good for writing layered
stuff on the plumbing that's available
so the distro includes both get plumbing
and get porcelain some really nice stuff
in there I don't get gooey is doing in
that slide okay so I'm going to be
showing the get porcelain in the rest
talk unless otherwise noted so we're
basically staying at the high level
there are some other porcelains that are
out there they're stacked to get which
lets you manage a set of changes and
rearrange them as necessary reapply them
to different branches
it's nothing you couldn't do by just
typing the actual commands but it lets
you manage it a little bit more
controlled way if you're used to the
stacked things that come from I guess
bitkeeper in a few other places there's
guilt I haven't used that so I don't
know what it is you notice the play on
the letters GI T they love adding things
to GI T to make other things out of
there there's a TIG which is a curses
based viewer so if you really like to
have stuff in
old-style curses windows that's fine
there there's Q get and I haven't played
with that one either up I'm not much for
gooeys I'm using my Mac here and it
doesn't like firing up x11 very often so
I basically I'm just using the
command-line stuff for most of what I'm
doing there are also some other poor
slits out there there's a certain
plugins for good new Emacs so you can do
VC mode correctly and so on so that's
all managed by git and that's mostly how
I'm interfacing we get these days so how
do we create a repo might as well get to
that don't have much time left so I'll
keep moving here you use get an it it's
going to create a dot get in the current
directory you probably want to edit at
everything at every level you can edit a
file called git ignore of course you
just have one at the very top level if
you want and have it referred all the
subdirectories down there or you can
keep closer to where it's actually being
used git add command sets up the files
and adds them to the index so staging it
ready for a commit and then get commits
it's going to generate that initial
commit so that's what's actually going
to take a repo or a working directory
from that I haven't been tracking and
turn it into now a get tracked directory
and that's all there was to it that's
going to create a branch called master
the current branch the head it's going
to point it master and I'm ready to
start making changes or publish it or
whatever I have to do from there mostly
though rather than starting your own
repo what you're going to be doing if
you're typically working in large groups
is going to be cloning somebody else's
get repository we use a remote spec
there it's going to create a repo from
an existing repo generally it's going to
create a subdirectory below the current
directory that you're in and again your
work files are going to be in there and
gets going to be in there and all the
branches that are in that remote repo by
default are also become tracking
branches locally what this means is that
later on I can issue get fetch and it
will try to bring my repo up-to-date in
parallel all of the remote branches that
I'm originally tracking and I can add
and delete those remote branches as I
need but basically I'm pulling down and
fetching the the remote repo now
tracking it automatically and the remote
head branch is going to be checked out
as your initial master branch as well so
generally what you're going to be
generating if you're using a git archive
is
or get repose you're going to generate
more commits these are always going to
be on a branch so a branch is just a
commit that has a name
so master or my experimental work or
whatever it's just going to be a name of
where I'm adding new commits with those
so when you make a commit the former
branch head will become the parent of
the new commit so that's how we create
essentially a linear tree from their
branch head moves to become the new
commit and so you're really creating to
use big fancy words directed acyclic
graphs rooted in the branch heads so
what you're doing is basically adding
commits on top of existing commits and
that gives everybody the history there
so merge as I said before is just to
commit it has multiple parents so your
typical workflow your day by day stuff
it edit write get add whatever you've
changed
this is going to add the files to the
index remember the index is the staging
area for the next commit get add will
add all the interesting files except the
ones you're ignoring and then you say
get status I do that just before I do a
commit to make sure I'm not committing
something that's weird or too many files
if it gives you a complete listing of
all the things that are being committed
all the things that aren't being tracked
that you haven't told it about all the
things that are changed but you haven't
didn't get add on in case or some of
those like that that's pretty good
there's the difference here when you're
ready to commit get commit you can get
into a pop Suunto text editor so you
type in your normal commit message at
that point you can also immediately pass
a message if you want similar to most
other tools the first line of the commit
message is used for some kinds of logs
so you want to make sure that that's
uniquely identified just you know that
the brief summary is the first line and
then the rest of the text is whatever
you want the details that you want
current branch therefore is move forward
and then you're back to more editing so
that's typical workflow just go through
this sequence here like most source code
managers now what matter what branch
though as I said earlier get encourages
branches a branch is just 40 text bytes
and a new line so very very cheap to do
so typical workflow would also involve
when you're starting on a new topic is
to think of something to do and you
create a brand new branch get checkout -
be topic name that's whatever you want
to pick saying you know my experimental
work on foo right
and you're saying embracing that on
master which is what that last parameter
is their work work work
commit to topic name so if we commit now
is going on topic name now instead of on
to master and when your work is done we
would want to merge that back into the
main line so get checkout master get
merged topic name is going to take all
those commits that we made in that
direction and place them now on top of
master and move master forward so that's
the typical workflow and then I delete
the branch because I'm no longer need it
throw it away doesn't need to be there
anymore the dash D is only permitted
when it's a subset of head like let's
say you wanted to skip that middle merge
step because it whatever you try didn't
work you could just type git branch dash
capital D topic name and it says okay
you don't have that branch anymore
throws away all those commits and
there's no record of it after that it's
completely gone not even to you once you
say get GC and get rid of that it's gone
it never existed my mistakes permanently
erased I love that all right each
individual commit is going to be shown
you can also take this entire branch
with your 17 commits and say no no that
really is just one thing I only want to
show the one one big commit that way I
would do a git merge that squash there's
no commit on this topic branch and then
get commit to actually make it one
commit so it's possible to bring them
all in so it's not like 17 separate
commits just one big fat commit the nice
thing about that get merged is it takes
all the individual texts of all the
commit messages and makes one big text
file out of it so you can pick and
choose from that what you want to
actually show in your final commit
message very nice for that stuff so of
course you can have multiple topics
active I could be working on topic one
trying to figure out how to make things
work work work work commit work or
commit right and then I go wait wait I
also want to be working on this I'm not
done with topic one yet but I also want
to be working now on something else boss
comes along says this is broke and fix
it right now so I will check out another
thing off of master called topic to work
with work commit then I may want to work
back on topic one for a while because
the boss isn't looking for a second I
want to get back to looking at the other
thing work of work commit and so on so
now I've got master and two deviated
directions off of that so I've got a
directed acyclic graph graph that's
pointing me out towards car topic one
another one's pointing me out towards
topic two okay so now I have to decide
how I want to bring them
together I could either merge them which
means if I look at a graph of it it'll
be too deviated lines that eventually
come back together in a giant loop or I
can also rebase which says I'm going to
take either topic 1 or topic 2 and make
it appear as if it was attached to the
head of the other one in other words
make it a linear history down both each
one of course has its pros and cons so
let's talk about those separately the
merge as we saw before we check out
master we pull in topic 1 we delete
topic ones branch and this should be
what they call a fast-forward merge what
that just means is that there's really
no work to do I just take these 8 more
commits and put them at the top ahead
and just goes forward nothing changed
there but now is where the work is going
to happen get merged topic 2 because
there are changes in topic 2 at this
point that are not in my current master
so now we have to figure out how to make
it fix so I could have made text changes
in two different ways there could be
overlapping that could be an issue
I could have renamed files two different
ways and so on so get merged topic
you'll either say yep done or it'll say
nope it's broken still you have to go in
and fix it tells you what's broken get
status will show that as well you need
to resolve then commit it then you add
anything fixed and/or get add dot well
so do it then get commit and then
there's where you describe how you had
to actually deal with the merge you can
also abort just to get reset it's going
to bring you back to the state before
the merge so that no point have I lost
any state lost any information I can
always almost always undo everything
that I start with rebase is different
it's going to rewrite the commits the
problem is if you recall though that the
sha-1 of a commit also contains
cryptographic information that defines
its parent commits so if I start moving
around the parents of various commits
the SHA ones are also going to change
too it really becomes a totally
different commit so I wouldn't do this
if I published it in some repo because
somebody already knows this particular
state of my world as this particular
number I wouldn't rebase then because it
would change the number even though it's
the same state so don't do this if you
published anything but for local repos
it's actually the best way to go a
rebase master on top of topic two and so
all the changes in topic two but
out of the master are going to get
rewritten as changes to the new master
oh this is rewriting topic 2 sorry may
result in merge conflicts because now
we're changing we're taking each one of
these changes in topic 2
and applying it as if they were on top
of the new master instead of the old
master and so some of them may conflict
because they were made changes were made
in two different ways so at that point
you'll get notified you didn't say go
ahead continue from here or abort this
entirely or just skip this particular
change we'll just leave this out and
we'll pick it up some other way and when
it's rebased then obviously the merge is
going to be a fast forward and rebase
has this wonderful interactive command
that's really cool you say get rebased -
i and the same parameters you would have
given otherwise and it pops you into a
text editor that says I take this commit
this commit this commit and ignore this
one squash these two together you can
edit the text file to do a lot of
different things you can even reorder
the commits you can completely skip them
out you can comment them out so it's
really sort of a nice interactive way to
do your rebasing ok and so the marriage
will be a fast-forward check out master
merge topic tattoo so that's the two
basic ways you're going to be merging
your work with your own work in another
topic or merging it with other people
bringing stuff in when you brought stuff
in from other repos we want to be able
to look and see what's happened there's
a nice log prints out the changes - P
prints it out as a patch so you can
actually see it as you know these lines
deleted these lines added - stat gives
us a dip stat which is really nice
summary you know these many this many
lines got changed to speed lines got
changed and so on very nice that way we
can also ask for just the logs that
affect certain files and directories
which really is nice what I want to see
what say when somebody's changed just
the documentation of a project I can do
a git log on the documentation directory
and it will track that down there's also
differ we give it two different file
positions two different trees I mean and
it will tell me what the differences are
get gift by itself was checking the
difference between the index the working
tree
me get commit - a make this empty
obviously get div head is going to be
the difference between what I'm about to
stage and the head so that's handy what
I want to see what I'm committing again
as well and then cash is the third
direction between head and index okay
just running out of time here so I want
to get a few more slides in here before
I start taking questions most of the
commands take an Arg that they call tree
ish and there's many different ways to
do that we can either give it a full
sha-1 we can give it any unique
abbreviation of a sha-1 and because the
first eight or nine hex characters are
often enough to completely identify at
most the time you'll just see people
using short versions of that like you'll
see a sha-1 on there that's really long
let's pick the first page nine
characters and type that in instead and
it'll still work because as long as it's
unique it's going to be it's going to be
available you can also type head for any
of those commands that we just saw a
branch name a tag name some remote
branch name any of those followed by up
arrow n to get the nth parent or tilde n
which is going to be how many parents
back we can also pick a particular file
or object out of a tree which is
interesting and for example we can say
give me the differences between the
previous commits and the current commits
that's kind of nice find these things
give me the three back to the current
commit and so on and what damage the
three last three edits did now for
graphical views at the very beginning of
the slide you may have saw this nice
tree of all the changes that been made
that's actually was a live dump of a
tool called get K get TK I don't know
how you pronounce that it's weird you
read things online you don't how to
pronounce and when you're actually
probably get to get K whatever that that
you say that followed by my topic origin
and it will draw a nice TK widget
display of all the history and it shows
the changes back to whatever common
ancestor those two had and it also is
live you can go in and look at anyone
commit and we'll show you all the
differences for that commit and so on
there's a lot of search tools built into
that this is really sort of your graphic
view of all your history it's very nice
to use - - all takes all your current
heads and does the same thing you can
also say from one to the
other just the changes of two that
aren't in from and so on keep going here
go go go there's also queue get which is
similar to get k again I haven't used
queue get but that's there when I do a
clone I'm creating these tracking
branches they're typically named origin
slash master and origin / foo for the
Foo branch and so on so to share your
work you first want to bring it up to
date you would use git fetch that's
going to go to the remote bring a repo
pull down everything that's changed and
update my your local repo with that and
then you would rebase your changes on
the upstream and the reason you're going
to rebase your changes is because it
looks weird if all the projects have all
these bushy branches sticking out to the
side so most commonly what people are
doing is they'll take the your current
master whatever your branch you want to
publish
they'll rebase it on the remotes master
which means all of my changes are now
sitting on top of the ridges that i've
just pulled down and it would create a
linear thing once I pushed it and that's
going to be really handy then I push it
upstream if I have access if I have
right access to the remote repository
then a get push will take care of that
if I don't have right access the remote
repository like I'm just somebody who
cloned it out of the blue and now have
something I want to contribute I would
send it in as patches get format patch
and then I would email those patches
that are that are now left in the
current directory so a little bit of
maintenance tools get GC as the garbage
collector goes through and takes all the
unreferenced objects and gets rid of
those validates the object repository
repacks it into larger packs almost
always when you get GC you end up with
one big file that has the entire
repository in it very very conveniently
packed up for it prune gets rid of the
unreferenced objects that's a dangerous
operation you can't do it while you're
doing other things and don't when
somebody else is looking there's always
ways to unwind your changes you make a
mistake you say no no I want to start
over
there's get reset with various options
I'm not going to go to the details here
but git reset basically forces the
working directory and forces the index
to look a certain way but and just
eliminate some of your changes and don't
do that unless you publish because
you'll lose things
every directory as I said before can
contain a GUID ignore it has very
flexible syntax for files you want to
get you want to ignore it's handled via
the shell glob if and match leading
/music current directory and so on
now the GUID ignore files are checked
into the repository and tracked by
default unless you get ignore the get
ignore file but that's kind of cool
you also have in your dot git directory
something called info slash exclude
which is just like a get ignored but
only applies to your repo and this is
handy because like on my editing of the
files I'm going to be creating tilde
files files into a tilde on the end
because that's what Emacs creates for me
but I may not necessarily want to you
know force that to be something nord for
you as well so I'll put that in my info
exclude file and then when I publish my
repo I don't have all these littered get
ignores and say ignore the ones with
tilde on the end for configuration many
commands have some sort of meta
information that they have get config is
editing the dot get slash config file
again if you're scared of editing a dot
ini file you can use a command to do it
instead yes you can edit it manually if
you prefer a gate config name is going
to get the correct value you can list
all the current values and the air print
sum out nicely there's also a global
configuration thing dot config file in
my home directory which will apply to
all of my git projects and I can stick
interesting things in there as well okay
so you want to set user that email and
username for your commits to make sure
they're good there's a lot of other
tools that come along with git you can
export the entire tree as a tar get
bisect is interesting you mark one
commits bad one commits good it figures
how to commit somewhere in the middle
that's got like an even number of
changes to both directions and then says
try this and then you say oh that one's
bad also so that it bisects the bad and
the good again and keeps giving you half
way down half way down half way down
because every time you do it you say
this one was bad or this one was good
and it keeps narrowing it down until it
finds the actual change that broke
things very very handy - created this
because obviously that happens from time
to time on the kernel that somebody will
do something wrong and so you has to do
that cherry-pick pick up specific
commits from another tree bring it into
your tree
get envy is just it's just a wrapper
around typing MB and add and delete so
it's a little bit easier to do that get
push as I said rights back up to an
upstream get revert adds a second commit
that undoes the previous commit if
you've made something and then you
realize this rom you've already pushed
it you add a revert which will add a
second commit that says not know if that
was broken and so you both commits end
up in the stream
that's better than if you just undid it
yourself get blame you know who wrote
this so you put that on a file shows you
all the different things there and just
on the last slide with about two minutes
to go for questions here I'll just put
the information up here get in Wikipedia
of course good pointer at that neither
so I think there's this tool called
Google I don't if you've heard of it
where you can like search for things on
get and it's probably the easiest way to
find things I'm feeling lucky today the
get home page is there get the door
that's easy there's a wiki there it's
got a lot of good information the FAQ is
in there a lot of great things pointers
to presentations that have been made
papers that have been published websites
to talk about it
there's also a great mailing list real
high signal-to-noise ratio find out who
else is using getting so on there's a
git IRC channel on freenode so check
that out there's people there all the
time
Junio and the other chief maintainer
czar on there 24 by 7 basically and that
is that I've got like two and a half
minutes for questions looks like so
let's start with the questions over here
let's take the mic so we'll go on the
audio Thanks okay so I'd like to hear
your thoughts about very large projects
like let's assume we have KDE so what
would you be your suggestion to how to
handle a bass API library a pace library
API change that affects lots of code in
the repository so as far as I understand
the whole kDa repository is too large to
be easily handle by a more in one single
git repository yeah what they're doing
with the KDE is they're breaking it up
into sub projects and there's sub module
support that's being added to get to
manage that I don't know a lot about
that because it's still
new and still just being added so I
don't have any advice on that like I
said I haven't personally done large
projects and that just sounds like a
nightmare to start with but I'm sure get
would handle it reasonably well or at
least no more poorly than anything else
handle stuff like that okay
yeah um so I'm just wondering if there's
some kind of way to take a bunch of
changes that you've done that you now
recognize looking back oh those are sort
of all part of the group part of you
know some larger you know change and
sort of make that um explicit so yeah
anyway Michael you could use get merged
as squash on two commits and say I want
to take this commit and this commit and
everything that's in between it and I
want to make that one big commit and
recommit that now the problem with doing
that of course is that you're changing
the sha-1 of everything forward from
there
so because the sha-1 controls the entire
history as long as you haven't published
that to anybody that's fine because
you're just saying now now it really is
this way so get merged as squash would
take care of that yeah hi suppose
developer my open source projectors
introvert only committed some code that
legally they shouldn't have done it's
still encumbered but by the time we
discover this it's too late it's already
been published there's any way that we
can have this code this particular
commit completely removed from the
repository yes there's a command called
git filter branch that was designed to
be specifically that because they that
did actually come up in one of their
repos now the problem is you can't
obviously if I've already cloned the
repo to my laptop it's it's it's here
you can't you can't force me to no
longer have this on my laptop but you
can make the public repo completely
remove traces of a given file or given
them text lines in a file and so on
basically it runs the equivalent of a
said command on every file name if you
wanted to or every text file if you
wanted to and rewrite all the commits
within a range with these rewrite rules
so it's really really good at that
yeah sorry this isn't really a question
but I just like everyone here to know
that we are some of us have written
scripts that let you use git on Google
code so if you want to use git today on
what you're working on now um Go Go -
get in your browser or join our mailing
list let's get at Google look on nice
nice cool alright hold it one last
question maybe yeah
hi there so in the open source world
typically a person who's running an open
source project will vet patches on a
patch by patch basis whereas in an
organization like this where there's a
strong authentication between the
company and individual developers it
makes more sense to divert a developer
rather than and so have the Machine act
as a gatekeeper for patches you know
having permissions or something like
that in other words the part of the
reason why companies tend to use a
central repository is that instead of
having a person to review every patch
you can instead have a policy as anybody
established a git repository with such
an automated policy yes yes in fact
there's a there's a open git repository
to repo or dot CZ that uses ssh keys to
allow to control who can publish to a
public repository so in other words i
can say that there are these five people
on this project and only those five
people have access to this repo that's
now publicly being published and there
are commits Hux that would let you
control that that's actually how that's
done though is that it looks at the
username that's being used to push to
the project and if the username is not
one of the ones on the authorized list
it doesn't it doesn't let the commit
tick to succeed there are hooks at just
about every level of adding a file
uploading to a repo and so on normally
they do nothing but you can enable them
and there's some very nice ones that
been written - they're part of the
contributory stuff so it's in there
alright I'm out of time thank you very
much for your attention thank you
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>