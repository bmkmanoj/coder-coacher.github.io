<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Kotlin: New Features and More | Coder Coacher - Coaching Coders</title><meta content="Advanced Kotlin: New Features and More - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Kotlin: New Features and More</b></h2><h5 class="post__date">2012-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rwsvbSve_BI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everybody thank you for
coming this is a cousin session and my
name is Andre breslov I'll be very happy
to tell you about my project this is a
modern programming language for JDM as
it was originally designed now it's not
only for JVM but for JavaScript as well
so we have two platforms we compile two
and this is like an advanced
introductory talk meaning that I will
adjust the material according to your
interest so if you ask no questions it
will be boring I'll just give you very
civil examples and so go ahead and ask
questions whenever you like I'll start
with very short motivational part and
we'll quickly proceed to code examples
in all the relevant stuff so the
greatest question for any programming
language designer would be why are you
doing this crazy thing nobody ever
designs programming languages from
scratch right so our context is JVM and
if you think about the Java platform as
a whole it was started in 1995 and since
then it's it has gained lots of
popularity primarily as a platform as an
ecosystem of many libraries many
frameworks great virtual machines so on
so forth so and all that progressed
pretty pretty good over time so now we
have a really up-to-date platform but
the language didn't progress that well
over time so if you remember 1990 90s my
minder looked something like this and
this may be not in 1995 designed by 1998
design and this is what I would call
Java which is a great language of its
time so if you consider state of the art
it is a little bit ahead of what we have
on the Java platform even of what we
will have in a year from now with the
great Java eight coming and resting in
the world so there is a
to be fixed erect reconsidered and we're
trying to do that so we're aiming at
something I like to formulate as a
modern language for industry meaning
that we want to be up to date in the
sense that we want to be smart enough to
to handle your code properly and I think
the main challenge there is to have in
your code enough information for the
human being to understand what it's
doing and not much more so if your
compiler is much more stupid than you
are it's bad and we're trying to fix
that problem the biggest thing there is
to have right abstractions provided by
your language so that you don't have to
repeat yourself over and over again
going over the same like coding pattern
or the same idiom because you just can't
extract it over and put it into the
library so the point there is to be able
to abstract such things put them into
the libraries and just call them instead
of recoding them by hand over and over
again and industry is our real-life
setting and our main constraint because
you can fantasize about so many
interesting things that you can automate
this and fully underlies this and have a
completely safe code and everything but
as soon as you consider like 30 people
working on the project of millions lines
of code for 10 years it's all a little
different because we would get to read
much more code than than we write and it
has to be maintainable by
yes not only by the discipline of the
coders because it's long history people
may you know vary their their attitudes
so this is they said our constraints so
if you take jetbrains
as as an interested party here or we
have our code base ten years old written
in Java having tens of thousands of
classes there and we would really like
to have a language to take this whole
code base without rewriting it just
adding new things in a much nicer way
does that make sense
any questions objections all right so
there definitely is a question or a set
of questions why not
these are that language I have some
names called out here but you may be
interested in some particular one so ask
me why not about whatever you like
why not ml very easy not Java compatible
why not Scour so we tried Scala we
actually tried a few languages before we
started our own my not my our two
biggest problems with Scala is one
philosophical relying on implicit so
much that you don't see so many things
in the code that are actually there and
working for you and this has lots of
implications of different sorts but I
think the most important is this
comprehensibility implication where you
have lots of things expressed in a very
powerful way but in such a way that you
don't see them so for a large project it
can be a real disaster also this has
implications on performance of the
compiler performance over the of the IDE
so and so forth but these are like
technical details and the biggest issue
there would be just the readability of
the code and then another thing is more
like more technical but still pretty
important there is no Scala IDE today
and it's been a long time since people
started doing those IDs Scalla people
are doing their
for eight years by now I think and we
are doing ours for like over for four
years already and nobody got anywhere
and this is a very alarming thing I mean
we may be very lazy and not doing the
scallop logging but scallop people are
doing their ID pretty well and it seems
to be an inherently complex problem to
develop an idea which suggests that you
can pretend the language is a very very
difficult task even for a computer yeah
so this is in short our problem with
scallop for for our setting having a
huge code base and main developers so on
so forth ah more questions like this
what do I groovy so groovy is actually a
whole different story because it's
mainly a dynamic language the groovy 2.0
has this nice feature of static
compilation which to me mostly turns it
into Java with a little bit of syntax
additions so groovy is ideologically a
dynamic language so if you want to use
it in a groovy way it will be dynamic
that's slow so you can't actually run
huge code base like and you can't
control anything like an IDE written
groovy just because by nature it can be
fast and also with dynamic language is
the there is another problem if you have
a huge project and you want to refactor
it you're just down there I mean you
can't do it by hand of course but this
is the only way you can do it and yeah
this is strongly against our culture to
refactor it anything by hand so yeah
groom is not our way yeah so cousin is
primarily a static language so we are
planning to maybe at some point add
dynamic types to handle some interesting
situations but this is not like the main
main focus of the language main focus is
statically typed type safe language more
questions
all right then just a short explanation
of where we are now cousin is not yet
released we have open sourced the
project in February of this year and
currently we're going through a couple
of milestones before we get to the beta
stage the current phase is m3 we have
most of the features prototyped and
working there are there many bugs to
effects and there are many performance
problems to fix but we're approaching
this better phase where it's going to be
a stable compiler usable for production
and we're going to use it at J brains at
that point but we're not going to commit
to of this design as like something
we're going to maintain backwards
compatibility for the word first rolling
it out of JetBrains for internal
valuation of course it's open source and
everybody can use it but the point is to
evaluate it in an industrial setting and
then specify anything and release
because before you actually try the
design you can't be really sure that
it's good for your setting questions
here all right good
what's the relation between carbon and
MPs MPs metaprogramming system is
another more research project by
JetBrains it's a language workbench
where you can create your languages
which are not actually textual textual
but look like textual and you can extend
them in a nice way and easily there is
no connection between these two projects
we learn from each other like more in
the requirements part not the
implementation approaches so these are
two parallel projects MPs is more like a
research thing although there are
production projects in production that
are written MPs and there are none in
custom yet so yeah these are two
parallel things okay more questions all
right then I proceed to the code yeah so
I'm using my IntelliJ with the Catlin
plug-in here and
here's the first example any questions
now questions okay
so here is one thing I would like to
point out about this program the code is
organized into packages and we have a
function which sits right under the
package so a function in gosselin
doesn't have to be inside a class it may
be just a free function like it is here
now I'll just quickly demo basic syntax
and we'll proceed to some interesting
examples so I'm creating a class here
class code reader with a function greet
and say hello Google this is what a
class looks like really straightforward
and here I create an instance of this
class and call this function and we have
code navigation and all the basic idea
stuff already another thing I would like
to do is to show how variables look like
so this is a local immutable variable if
you know Scala it looks familiar and
many other things look look familiar if
you know Scala groovy c-sharp Java or
many other languages so we learn from
our colleagues in different groups so
here is an immutable local and this is
now an immutable member and one one more
thing I'm adding is a constructor
parameter so here is my primary
constructor constructor declared right
right in the header of the class so this
variable here I can be used inside the
initialization code like I can put here
and it will be inside the value of this
s varible and renaming s to something
more reasonable does that make sense
any questions the question is can I call
this from Java yes I do
yes I can so if I just create a Java
class here just create a Java class here
can i okay
so here's my java clause and I say new
greeter here it is even in the
completion and I can say greet and I
have to pass something here
well see hello Java to me hopefully have
an air okay I had to put something here
- is there a default visibility to what
out okay all right yeah so let me
explain this first of all a visibility
of classes and everything else by
default its internal internal means it's
private to your Mario and Mario is this
entity here so cotton examples here is
my Mario there it's wider than a package
about return types so this field here
this it's actually property another
field actually has a type but it's
inferred so you can say string
explicitly or just omit the type because
it's inferred from the right hand side
for a function if you don't declare
anything here you just have unit by
default which is returning nothing
interesting it's like void but a little
better than void it's a proper type so
by default you just get unit if you want
something else you specify the type the
question is how do you call Carlin's
package level functions from Java let's
have a function here here's function foo
and from Java so this package actually
is compiled down to a class with static
members so if we have a look at the
bytecode this is what it looks like let
me just put it here and here's my foo
it's just a public final function public
static function in my package class and
the class has name hello sorry hello dot
namespace anyway so if I say here
below that namespace dot foo there it
goes
more questions if you name a class
namespace
you just don't Barse because it's a
keyword or do parse oh that's a shame
all right yeah yes you do
sorry it's yeah we used to call packages
namespaces and at that time it didn't
burst now it should be an error but it's
not there yet yeah I'm you know having
my times mixed up sorry my person's
print line is a function in our library
package which is imported by default so
here it's just implemented like this and
the package is calling IO which is just
5 volt here my questions the question is
are functions first-class objects that
it can pass around so yes Annelle so
currently we don't have syntax to just
refer to function name as a tell you it
will be there but it's not there yet and
you can't pass a function around if you
wrap it into a anonymous function and
pass it that is an element there's any
way to pass things like functions around
on the JVM you have to create an object
what the function types like it looked
like okay I'll get there in a minute you
don't got it yes there was an inline
keyword which I'm not sure is right on
that function but it's not a keyword
it's an annotation another not yet
implemented feature which will probably
be in cousin like one point something
the point here is that we want to
support inlining on the compiler as a
compiler capability to eliminate closure
annotation closure allocation sorry in
many situation that would be very
beneficial well when you align the whole
function together with its arguments
and the dude can't do that
so we want to do that ourselves JIT
can't inline the coal together with its
argument yeah all right so should I
proceed to the next thing okay so that
was a boring thing another boring thing
comes here so this is a class which is
analogous to something like this this is
a Java class because peculiar property
is that it does nothing even doesn't fit
on the screen and this is unfair because
you have to like to repeat yourself all
over again like first name first name
first name first name first name and
first name here inside parentheses not
bad
you really convince the compiler that
you want that first name so we're trying
to work around this problem somehow and
this is a very bad piece of Kotlin where
you say first name first name first name
three times you don't want to do that
you you simply declare your three
constructor parameters here and then you
have three bells in the class and you
just initialize them this way so you can
and get the same result by saying bells
by putting bells right here this way you
just get a data class basically
something that holds your data and does
nothing else and it doesn't say anything
else
which is probably good watch this
why would we make having a bell here 34
well I don't think that an average class
only handle only holds data so there is
an option of saying whatever you pass
through the constructor is stored there
but it would be making implicit the fact
of allocating a new field in your class
which is a little bit against our
beliefs they were trying to make all the
relevant things explicit if you want
some data to be storing an object you
have to say that it's stored there so
what this val tells you that it is
stored not just your initialization yes
okay so currently so for this exactly a
class equals and hashcode are just
inherited from from the base class but
if you say that this is a data class
data is just an annotation that tells
the compiler to generate a few
convenience methods it automatically
emits the correct equals hash code and
to string doesn't matter okay the
question is how do you specify whether
this first name has setter or getter or
whatever so by if you say well it means
that you have a field which nobody sees
its a private field you can't access it
and you have a getter so if you say well
you have a getter if you say var or a
mutable thing you have a getter and a
setter you can even customize those but
in the body of the class yeah so if you
want to change types of things and store
mutable references references to mutable
objects internally and expose them as
immutable things it would be necessary
to have to two names declared for that
so a private property all the immutable
version and a public thing for a
read-only version yes you can yeah but
one thing there is that the getter has
to have the same type as the property
you mean okay yeah it was a
misunderstanding so for me a read-only
think has a read-only type like a
read-only interface and you know you
want only to decorate the return value
yeah yeah sure sure you good yeah okay
this you can do
you can provide your own annotation so
we don't have a fixed API yet to program
the compiler plugin that handles the
annotation but the architecture overall
architecture is there so you can declare
your own annotations and put them there
it's just a class name so I think I can
even navigate to it so here is the data
annotation it's a class that we're yeah
any annotation that's applicable to this
kind of declaration what to me it looks
better this way and we are actually
going to make public also an annotation
just to get rid of these stupid keywords
so looks right yeah they can have
constructor parameters and you can just
put in there okay so I'll demo some
syntax here actually not syntax but use
cases for different kinds of functions
so this is how you create a list like a
list literal in Catalan this ArrayList
is just a function with a park parameter
and this is how you rate through a list
should be pretty straightforward okay
now let's do the same thing with the map
it's a little bit more fancy syntax so
we have a function hash map that takes
actually just takes a sequence of pairs
and this two function takes the left
thing and the right thing and makes a
pair of them and passes that to to the
hash map so you can construct a map just
by passing a bunch of pairs there then a
map can be accessed with square brackets
which are actually just calls to get and
set methods so this is these are just
conventional calls most operators in
Catalan are treated by convention so if
you say - it's actually a mess
that called - called from somewhere
declared somewhere and saving for square
brackets square brackets for reading
it's get and providing it's set so here
it's a call to set method on a map and
this is how you each rate over map you
can declare a pair key and value and say
for those pairs in your map you want to
process ever prepare and handle with
some help the question is if we have
overloading unfortunately yes
if you have multiple getters they would
have either different types of
parameters or different numbers of
parameters alright so in your square
brackets you can put many arguments so
it will just overload it will perform
the overload resolution on this cold
that's does it are the generic types
erased unfortunately yes the question is
can you confuse a map for an array
because it has numbers as keys yes you
can and I don't think it's bad yeah so
an array array access looks exactly like
a map access or whatever access like a
list access would look the same way
because you have a get method on the
array on lists on map on whatever and a
string access will look exactly the same
you have a string and you say string
square bracket I and it will be a
character with this number
good point yes yes currently any class
that declares a method called get can be
accessed with square brackets well we
are going to restrict this a little bit
with demanding an annotation on the get
that says
okay this is an operator not just
function to manage this somehow but yeah
generally the idea is that you can make
any class into supporting this get
convention - is a function that looks
like this
I'm not explaining this a right now it
will be a few seconds but basically it's
a function that takes a and B and
returns a pair okay
all right the question is if we have
primitive types yes and no so if we're
for the language itself it doesn't know
about any primitive types it thinks
everything is classes but when we
generate Java code we actually have
primitive integers there and primitive
doubles and stuff like that so it's
purely an implementation detail all over
JVM could you the question is could you
use a primitive where as a type of
argument yes yes you could and again on
the JVM it would be integer for int and
character for care and so on exactly
like Java yeah we box unfortunately we
can't avoid a little bit of boxing
sometimes but not much of that now this
is a platform specific thing we can do
much about it
okay a short explanation about the Rays
the arrays are quite quite an
unfortunate story on JVM so we have nine
array types in the language one is array
of T which is an array of whatever
object and other eight are int array
care array whatever other array so if
you want an array of int you say int
array instead of your array of int if
you say array of int it will be array of
integer so this is not very nicely
looking but I think arrays are actually
low level implementation optimization
tool so you don't really want them in
your API so anyway so if you want
something something nice and shiny it
better use collections anyway so this is
not a huge loss although I would like
them any for them but we can do that
great question thank you very much so
the question is is this a tuple I'm
going to answer it in a second so here
is my next example so that was not
actually a tuple we have dropped two
bulls like a few weeks ago because they
are not needed so this was something
else we call it a multi declaration
where you can assign something to a
number of variables so how it works is
by the way note that this is java.awt
point which is just an existing class
not a common class so the thing is that
if you say X &amp;amp; Y gets point of one and
two it gets compiled to X gets point of
1 &amp;amp; 2 dot component 1 and y gets point
component 2 and component 1 and
component 2 should be some functions
available on the point class the problem
is that point class doesn't have those
functions declared in in its class file
but we have something called extension
functions here is the illustration of
what they look like which lets you
extend your classes with static methods
like here
to make them those methods available
after God now I can say for this point
object I can say point of 1 &amp;amp; 2 dot
component 1 and this is all you need to
be able to say X comma Y gets point 1 of
1 &amp;amp; 2 this component 1 it's declared
here it's a special kind of functions
definitions index so you have a funky
word then you have the receiver type
point and then after a comma the
function name this means that this is an
extension function that takes its first
argument on the left of the comments
purely syntactical convention not
anything like very fancy it's basically
the same utility function you would put
in your point util class and it's
implemented as a static function there
is no like altering the class at runtime
or no dynamic dispatch or anything but
still it makes this kind of syntactic
convention possible where you say
whatever has a component one after a dot
will be able to use this multi
declaration syntax and the same holds
for many other language conventions like
fours and stuff I will show that in a
second questions here okay
so here we are declaring two variables x
and y these are okay yeah thank you that
that's great question the question is
where does this X come from it's
actually this dot X and this is as usual
the object you're called
at right so this is just the receiver of
your function all right yeah so we're
getting into a little bit of confusion
so this is implemented as a static
function it actually belongs to this
package it's not in the class but it's
declared to have this point receiver
type and this makes the compiler create
a variable called this inside this bank
function of this type and that's it so
it's not a member of the class it has
the same
syntax and you can pretend you are in
the class although you of course don't
have any access to private members for
example or anything like that but the
syntax is the same yes if you declare if
you have more component functions
it doesn't invalidate this - declaration
syntax you are able now to say z XY and
Z gets point or whatever but you're not
not prohibited to say x and y currently
we do not allow you to skip a component
so this wouldn't compile but we will do
that yes unfortunately yes this is it's
not only public it's mutable yeah you
could of course say it does not get X or
whatever yeah yeah so this is what a WT
looks like they have public mutable
fields can help it okay another concept
gets on stage the question is is this
like like aspect-oriented programming
well yes and no aspectj had this intro
type declarations where you could say
okay this method now belongs to that
class but the difference here is that in
a spec J that method actually got to
that class so you would alter the
bytecode of that class at runtime or
even statically and actually push the
method inside we don't do that we only
have the syntax that reminds you of that
one but it's not exactly the same thing
yeah good question
or why dropping tuples and why not using
general pattern matching instead of this
silly convention I'll answer it in a
second let's go over maybe easier
questions yeah okay I wouldn't say it's
compromising the language design so it
turns out well it may sound a little bit
hacky but it's not it turns out that we
want to extend existing api's by our own
functions because we we tend to operate
a lot on existing data types for example
yeah and the natural way of saying I
want to call this on that object is say
object dot this function it has a bunch
of advantages one of which is you can
say this object dot and get the whole
API in your completion list unless
you're using them or something but yeah
some people use IDs actually this is one
thing another thing I have a demo for
that I was planning to show it later but
you are predating my my demos so here is
a piece of guava just just to show the
difference between the two approaches so
Java collections don't have proper at
least today don't have proper methods
for transforming and filtering so what
the only thing we can do is to create
this collections to class and have
transform and filter there and so this
is how you transform and then filter a
collection this is the best we can do
without this extension mechanism but
with an extension mechanism we will get
something else we can say less dot
filter that map or transform whatever
you call that and the huge difference
between this and that is that here what
you say is transform a filter of a list
and the subject list is lost somewhere
in the middle and and your operations
are getting backwards as opposed to here
where you say a list transform it this
way and then that way so it gets you the
right understanding of how you actually
process the data and I think it's
important yeah did I answer the question
all right
thank you now we're getting back to okay
it is aesthetic function that takes a
point as an argument so it's a component
one of point
almost yeah yeah so it's basically like
a function of the class there are two
differences first of all you can import
it or choose not too important and then
you don't have it and second you can't
override it because it's static okay
it's all static so if you have component
one declared on object it has an
implementation that will be run whatever
does I don't know what's the component
one over the object but anyway yeah it's
all static all right so now back to the
tuples question let's have a look so
there are two huge usages for tuples one
is returning multiple things from a
function another is pattern matching
first things first
so here is an example of returning two
things from a function so I want to
parse file name and the line number from
a string here it is and I just assign it
to a pair of things here so this is what
my function looks like I say I returned
to the location and then I do some
regular expressions and say location of
whatever I returned in a location so
what would be the difference with
returning a tuple if I could say by the
way a pair of whatever string and int
here so what's the difference between
returning my location and a pair there
is a huge difference a pair is some
object with two properties there first
and second and have no idea what is
first about a second so when I call this
I have to navigate back to the
Declaration of this function and see
what is first and what a second to
figure out what to do with them and my
loop
nation has proper names for the
components so that I never get lost in
in those you know orderings and stuff
like that so it's documented by default
by by definition so I think this this is
a huge advantage of name things over to
poles we thought about having decent
tuples with labels which are mostly like
records already that actually store the
naming information in the type itself
but those are so much like classes that
it's it's funny to have this concept in
the language alongside classes yeah I
agree so if we could actually return
multiple things from a function
physically there would be great and
we'll probably struggle for something
else but underneath we anyway have those
classes but the point is different yeah
so the point is that if you have some
two unrelated things like your actual
return and an error code how do you
relate them with a decent name yeah
there is a problem there I agree but
this is the only problem and I think
it's having this problem is better than
having an extra concept in the language
which is totally separate from
everything else and duplicates much of
the functionality anyway
right okay yeah
yeah so there is an interesting argument
so okay all right so the point is what
if I really need a topple right like I
want to put my failures into map or like
a key Maps not to one value but to two
dollars for that you have a pair class
in the library and a triple class in the
library you don't have a quadruple class
because if you have four Drupal's in the
code you can't read that code yeah so
the performance argument you're making I
don't quite understand because to put
anything into the map you have to either
alter the map implementation or to have
an object there I don't know any other
way if you specialize yeah if you
specialize yeah if you tell me how to
specialize properly I will be very
grateful but let's take take at that
outline okay all right
so yeah and this the same trickery with
multiple multiple declarations is used
for say index iteration over strength
for example we can say that string about
indexed gives us an iterator that
returns those pairs of things and here
is a usage of a pair it's a proper class
not too harmful if you are not using it
as a standalone object list this should
be pretty straightforward I won't give
any details about this any more
conceptual questions or objections I'm
getting lots of objections here this is
great
the question is if you are going to have
carbon specific reflection that would
properly reflect our new concepts yes at
some point we will so currently we only
put annotations and those functions in
the Java sense so that you can actually
recover that information but we don't
have a library that would do that nicely
but the plan is to implement that yeah
okay yeah all right
what comes next I showed you the
collections already yeah so a little bit
more on the collection story so there is
there are many different approaches to
collections and it's customary for
different languages to say whatever
platform we run on collections are so
important that we redo the collections
and have our own incompatible with the
Java collections because those are you
know bad and mutable stuff like that so
we're trying to stick to Java
collections because transforming your
data all the time is costly and
inconvenient so we have those vanilla
Java collections would provide extension
functions to equip them with all the
needed functionality and we do something
else
on top of that something else looks like
this so here is a piece of funny code
please tell me what's wrong with it
actually it's nothing wrong but you
should suspect it it's wrong I have a
print function that takes a list of any
any object like the top class and then I
call it here on the list of hints is it
bad
yeah so Java wouldn't let me do that
because I could say list that end of one
you're not one but of string here the
trick is that my ad does not resolve
there is no ad the reason is that I'm
not running on a Javas list per se
although at runtime
it's just a jealous list
but on something else so covens
collections look like this can you see
this
okay so we have split the collection
interfaces into read-only and mutable
versions these are all erased so in the
bytecode it's actually Java dot util dot
list but for the Catalan compiler
it's a read on the interval read on the
collection read only set we down the
list and then we have mutable versions
derived from those so that in the
catalan type system you can't actually
distinguish between a read-only
interface enemy fully-fledged mutable
interface and java classes are seen as
extending those mutable versions and in
common you can derive your own classes
from immutable versions that makes sense
these are not the same thing things I
meant read-only so these interfaces do
not guarantee you any immutability they
just don't have mutation methods so
these are read-only interfaces these are
mutable interfaces and you can derive
your own immutable collections from the
read-only interface and we are planning
to provide you some easy way to reuse
the existing immutable code from Java to
declare that it's actually extending the
immutable literal read-only iterable
rather than a mutable interval okay so
this is pure compiler fiction nothing
nothing is actually happening at runtime
but you can have this properly covariant
list and the dream comes true finally
the user stops wondering why can't he
pass a list of ends where a list of any
is expected isn't it a list of any after
all yes it is if it's not mutable that's
okay it's good that was easy now let's
turn to something rather different here
is a piece of Java code
this is Java gatlin we don't say that
public static whatever and
this code is problematic because there
is a risk of runtime error this file dot
list files would throw a null pointer
exception if the file does not exist or
is not a directory and this is why lots
of enterprise code gets covered with
those null checks like oh well all over
the place we have checked full check
that for now and that for now and maybe
that also and it may be pointless maybe
not but it's definitely very very funny
thing to guard like because you don't
know what happens to guard against
everything so we're trying to manage
this somehow by making the compiler
actually watch your notes and telling
you when you have to do anything about
it so it's the same Java IO file here
and we call list files and the compiler
knows that it's nullable so if I say
files of size it will warn me actually
it won't let me compile anything it will
just tell me that I have to do something
about that null before I do reference
the files variable so actually this
files variable has this type with a
question mark at the end which is a
nullable array type and if you have a
nullable type it means that you're
either have an array or a null and if it
can be both you can just reference so
what you have to do is either check say
if files is not null but then you can or
you can do many other things actually
you could say if files equals null then
return or throw and so forth these s
questions here ok
we're explicitly doing analysis trying
to to try to figure out the nulls yeah
so this is actually very straightforward
data flow analysis that is built into
the pipe system basically
yeah and we're supported for for
nullable types to know where we can the
reference variables and where we where
it's risky yeah
all right let me let me show you a
little bit of it so if you if you want
to say if is now of X then do something
this won't work unless you inline that
function so if you inline it we can
actually run the analysis on his body
otherwise it's not safe to say it's
actually checking for none now one other
thing is that instead of saying return
here you could say say fail which is J
units fail and it still work but for a
different reason
fail says just throw in a legal argument
exception and it actually has a type and
I hope my ID can figure it out and the
tab is nothing but for this dairy only
for this type we know that it's a
special type it's an empty type if you
manage to compute a value of that type
you're probably not in the control flow
anymore now it's a clue equivalent to
explicitly explicitly throwing an
exception or returning from your scope
so you're guaranteed not to have a null
pointer under the reference here make
sense
let me repeat this so currently we're
not in lining anything so we're not
looking at byte codes anywhere for fail
we're looking at its type signature
because it returns to this special type
we know that it will exit when we do in
lining we will look at the
implementation whatever it is byte code
or just the code inside the function and
figure out the data flow with here oh
all right so this is a different story
by default everything from Java returns
null but there is a catch here because
this is not just a default by default
that would be an allowable array of
novel file so this function is currently
manually annotated so we have those
annotations for JDK and many other
libraries and you can add annotations
yourself but we're currently working on
a tool that infers them automatically so
there we are looking at the bytecode of
the JDK and we're thinking about
flipping that default after learning how
to infer proper annotations but
currently yes the default is that
everything is nullable unless you
annotate it explicitly so say a gel
branes we are using in Java we're using
annotations nullable and not now all
over the place so it will be easy for us
and I have seen lots of nullable not now
in guava tree so maybe Google uses that
as well okay my question
the question is if we can use nullable
non-null annotations for compiler
optimizations unfortunately I don't know
about many ways of using them at all
because it's again it's on JDM you just
have references there you're always
nullable by nature on the virtual
machine level you can optimize much
there ok another bit of this same static
analysis we're making yeah so this is a
school example of like a civil
interpreter of expressions you have an
expression class here with two cases of
number constant and the sum of two
expressions and I want an interpreter so
this is a very bad common code again we
have any valve that takes an expression
and returns an int and I check if E is a
numb so numb so is it just an instance
of check if E is number then we create a
new variable we cast and we call what we
want on that terrible oh this is really
annoying so I'm not doing this
McArdle and what I do is just this
compiler is smart enough to figure out
that we have checked for this num here
and we can now use the variable as if it
was of that type makes sense good now
questions here
that's great and the same of course can
be done for for some as well and if you
think about it it's very similar to like
pattern matching in a way so if we do
that your different syntax for like a
switch statement which we call when here
is another version of the same function
so what I'm saying here is when e is
number use it as a number if it is a sum
use it as a sum otherwise throw an
exception so this is our like poor-man's
pattern matching but don't do fully
flash pattern matching because we're not
convinced it's really necessary
probably 80 to 90 percent of the cases
are covered by this because if you look
at pattern matching in function
languages that have them that have this
feature you encounter so many patterns
like
num of e of V and then use V which is
absolutely equivalent to this where you
just don't have to capture the name
because you have the name here so we are
trying to get away without doing pattern
matching because it's a huge complex
feature and it would be nice not to have
it in the language and if it works will
be just fine like this
yeah type refinements not really
we propagate through the control flow if
it doesn't get too crazy so we actually
propagate less less than we could where
am i right
sorry no I take that back we used to
propagate less less than we could
because we used to declare variables
this way like somewhere in the control
flow but this is not there anymore so
now we propagate as much as we can so
it's inside the and signed a single unit
of data flow like inside a function or
inside a constructor things like that
and there yeah it would just take the
whole control flow graph and propagate
the data over it well I wouldn't say it
interacts in any way because function
overloading happens on declaration level
and this happens on expression level
these are pretty disconnected but I say
what do you mean yeah so if if you have
an ambiguity because of when you have a
function that is overloaded like you you
may be of a and of B and your static low
of a and you're checking for B and then
just saying f of X what would that be f
of a or F of B so since this is
confusing we just say ambiguity there we
just don't tell you don't do anything
and let you choose because otherwise
you'll be confused
either way yeah so we could take
whatever default but the user will be
confused yeah it's an explicit return
because here is an equal sign and this
is an expression that returns whatever
that evaluates to whatever is on the
right-hand side of this of the error it
can be any expression in case of parent
at first it will because we know that
it's it cannot be mutated in any way but
if it's same YouTube
properly it wouldn't be alert for a
new-type because it may change yeah so
if you are the customer practice here is
that if you want your your information
to be stored there even force a function
return value or mutable property return
value you just assign it to a local
variable and then check the variable
Oh bye as Fuyumi like sick wall like
declare a variable of this name ah no no
we are thinking about finally getting a
let expression into the language but
that's hard I'm a little bit out of time
already so I'm wrapping up the like the
official talk and we'll have Q&amp;amp;A so the
bottom line here is that we have a
powerful language with I think very good
set of abstractions that are
facilitating our job interpreter leti in
a nice way so if you're interested in
anything about cuddling you just go for
our homepage which is Calvin Bernie's
comm org sorry and there you have all
the documentation and online demos
things like that so please come and give
us your feedback maybe contribute if you
like we'll be just happy about that
thank you very much for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>