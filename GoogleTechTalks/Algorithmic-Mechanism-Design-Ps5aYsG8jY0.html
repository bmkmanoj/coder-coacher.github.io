<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Algorithmic Mechanism Design | Coder Coacher - Coaching Coders</title><meta content="Algorithmic Mechanism Design - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Algorithmic Mechanism Design</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ps5aYsG8jY0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to today's Tech Talk my
name is Jeff walls I have the pleasure
to introduce our speaker today Noam
Nisan Noam is going to be we're very
fortunate to have nominee son as a
visiting professor for this academic
year he's a professor at Hebrew
University in Jerusalem and will be
spending the Oh seven and Oh 8 academic
year at our Tel Aviv office Noam
received his PhD from UC Berkeley in
1988 studying under professor Richard
Karp he's a well known and leading
researcher in the area of electronic
marketplaces and auctions as well as
economic Mehcad mechanisms in
computation normal speak today about
algorithmic mechanism design so please
join me in welcoming normally son ok so
what I basically want to talk today is
about my research prior to Google so
this is all academic stuff a nothing
about what I'm doing here and basically
I'm trying to give basically an overview
of a field that a bunch of researcher is
not a very large group but there's still
a significant number of people have been
working on for maybe about 10 years I
will I will start actually by trying to
describe what we're trying to achieve
what is basically the problem that this
field tries to address once I try to lay
out the problem then I'll have to spend
a little time talking about what kinds
of solutions are we talking about what
is the language that will allow us
solutions because basically we're
actually going to use a ideas and
notations from macroeconomics to
actually solve computer science problems
so this is if you wish the opposite of
what we know companies like Google or
any company does any kind of electronic
commerce does which actually uses
computers to solve economic issues of
you know how to best match advertisers
let's say to publishers or any other
side kind of electronic commerce we're
actually going to use in this talk a the
economic point of view to actually solve
standard classic oit I would say
computer science problems but of course
in this new setting which I will
describe
so once I you know described the
language of the solutions the type of
solutions I'm looking at I will a I will
describe if you wish this a basic
solution so there is a basic positive
results from economic theory that is
going to be the starting point for any
further investigation in this field I'll
describe it and then I'll say okay so
what are the challenges when we actually
try to bring this economic theory into
the computer science PI point of view
and then that these areas will be where
the interesting progress within computer
science has been made about these issues
and of course where there is lots more
further you know research open problems
to be done and I will give a lot of
examples or a bunch of examples showing
the different type of issues that arise
when you want to do it
so let's you know take a high-level view
about the Internet so you know in the
Internet we have lots of computers there
interacting all the time and doing lots
of things so when I'm saying look
knowing doing lots of things I'm looking
at all levels if you wish of the power
of the communication protocol a
hierarchy you know from the lowest level
questions you know this computer is
sending a packet to this computer
through this router to the high level
issues of you know they're actually
trading you know this guy is buying
stuff and selling stuff over the
internet and all levels in between you
know and so if you look at the internet
at this point of view well you could say
it's just a very big distributed
computer system that computer science
researchers have been working on for a
very long time so that's nice but it
seems that the since the beginning the
early days of the you know Internet of
the splash of the internet which I'm so
talking about maybe 95 or so people
realized that there is a new ingredient
that's very very important in the
internet and was not really addressed by
computer scientists a significant
beforehand and this is the fact that the
different computers belong to different
people different organizations and these
computers will be basically probably do
not what any kind of protocol some
Engineer comes up with and tells and you
know do this protocol but rather what's
good for their company so I'm not
talking about issues like
you know faulty computers or malicious
computers like Indian cryptography or in
like in cryptography or various
Byzantine kind of things but just the
normal computers that belong to normal
corporations who want to do what's good
for them no they want to send their data
faster they want their access to be
better
they want to buy chav cheaper and sell
it more expensively and so on and this
is a standard way that things work on
the Internet you don't have to be
malicious in order to optimize your
computer to improve your own revenue
your own goals your own speed your own
but your own communication bandwidth
whatever you were trying to optimize and
no computer side and basically computer
science protocols were never designed to
work under this environment with when
you have actually selfish interesting
computers computers that do what they
want or what their owners want really
rather than some protocol so if you're
actually looking at all the you know
classical internet protocols IP TCP
let's look at TCP for example TCP does
not really work if you wish when the
different participants are a different
participants are selfish there is a very
easy thing that can be done to actually
let's say improve my computer's
bandwidth latency everything all the
communication a specific by tweaking
slightly the Caesar TCP you know code in
my operating system actually telling it
not to be considerate of other users as
the TCP protocol mandates it should be
and that would improve my own
communication noticeably I mean
significantly in fact of course hurting
all all others if all others do the same
then everyone is worse off but if I only
I tweak my own TCP algorithm inside the
operating system I can actually improve
significantly my own communication so
that's because TCP was designed for
computers that all execute what someone
told them to execute you know the right
protocol and the question is what do you
do how can you handle you know general
level higher level kind of things
further are the higher level kind of
issues when the different participants
are selfish doing what they want by the
way if there are any questions please do
stop me and
okay so the idea is if you're actually
trying to design mechanism type design
protocols for this environment with
selfish users we're trying to do we're
trying to design what's called incentive
compatible mechanisms what is incentive
compatible mechanisms mechanisms that
basically give incentives to the
different participants to act as
instructed rather than trying to
manipulate a different protocol to their
own advantage so a and we're not going
to assume that we have to somehow
somehow assume something about what they
want because if we don't know what they
want they may as well be malicious and
then we're back into the world of
cryptography where basically they can
kill anything I can't do have any
meaningful interaction with a malicious
computer but we're not looking talking
about malicious people but rather with
people that have their own goals so
we're going to have to you know
formalize or further or study it in some
sense and we're going to understand that
they are what's called rational so being
rational is a very is a very you know
technically narrow term here just means
that they have their own well-defined
goals and they are literally only trying
to optimize their own well-defined goal
okay so they have some kind of way we
usually talk about utility function a
function that specifies how happier they
are with what the outcome of you know
any protocol that they are involved in
and that they try to actually improve
their utility improve their happiness
and a mechanism basically is allowed to
do one other thing beyond just have
being a computer protocol the
distributed protocol it allows to charge
payments from the participants so it is
completely clear that if no money is
involved this is going to be very very
difficult to convince people basically
not to hurt others if they're only
trying to optimize their own goal so we
will actually have some kind of notion
of money so our each of our protocols
will be some kind of computation and
some kind of a load some kind it does
something and then it also specifies who
needs to poo to pay what and to whom and
our basic assumption is the value of the
following that what each one of the
participants is trying to optimize is
basically the value that he gets from
the outcome
if you know the protocol - the payment
any payments that he makes and if he
gets money that that's going to be
simple of course a positive term and the
key idea that we want to get - we all
want to have a mechanism we will call it
incentive compatible and technically
it's also sometimes called truthful or
strategy proof basically if rational
players can will not manipulate it so
basically if the payment together with
the outcome provides incentive to all
participants to always participate
correctly in the protocol so when we are
talking about participate correctly the
real issuer beyond everything we know
everything is really their private data
so if all the data was public then it's
completely obvious that we could just
say okay here's the data here is a
required output we don't ask anyone to
do anything the whole problem is that
information is private and really what's
important is that actually computers
behave according to their true private
information and not according to sub
made-up private information that would
improve their lot if they behave
completely in a way that's not
consistent with the protocol that kind
of course immediately may be caught so
what we're interested in in playing not
a not behaving in a way that's
consistent with a protocol but according
to some false wrong input so before I go
and talk about you know try to formalize
it let me give you a very classic
example that I suppose most of you
already know but look at it in these
terms
so here's there is a problem a we know
classic if you wish problem there are n
different a computers or bidders or
processors it doesn't really matter just
want to you the single communication
means so you can think of it you know
for a single packet and a single pikas
picosecond or you can think of it like
reserving enough bandwidth and a quality
of service kind of thing and only one of
them can get that link and the question
is who gets it now we don't want to just
arbitrary give it to one of them but
we're going to assume that there is some
kind of inherent value so it's not all
not that all of these are you know the
same importance but there is a different
value for each one of these bidders from
alcoholism now if you don't mind
an inherent value for the bidder for
actually getting his transmission and of
course what we would like to do is is
give it to the guy who values it most to
actually find the most valuable a most
valuable transmission to actually give
the link to so in the old world this is
a very simple protocol everyone tells to
let's say our a locator how much is it
worth to him a locator chooses the
highest value and then who he gets the
link very simple but of course a now
suppose with the different computers
belong to different participants if they
know that this is the protocol and no
payments are involved then it's very
same easy to know what will my computer
do instead of actually reporting my true
value for the link I will report a
million or extremely high value and of
course everyone else will do the same
and the result will be totally
meaningless so how do we deal with it
anyway the first thing you might think
is actually okay let them you know if
they declare value let them actually pay
the amount that I declared so now we
either are going to be dollar values and
if you say that this link is worse to
use three dollars then pay the $3 the
other guy says five dollars he will pay
five dollars and now at least it seems
that people will tell the correct thing
but you see again people won't really
the correct to tell the correct thing so
suppose it my value is five dollars if I
say five dollars and I have to pay what
I said
basically my resulting utility net
utility is zero I won't say five if my
real value is five because then I'll be
left with nothing I will say slightly
less than five how much less than five
really depends on the competition that I
have if I know that the next guy is
three then I will definitely stress a
three point one or three point zero one
but if the next guy is two I will say
two point zero one and if I don't know
what will I do I will have to try to
guess to do some kind of a statistical
analysis optimization but then of course
I may be wrong and because each of us is
doing all this you know all this kind of
analysis and these
these are connected in some kind of
weird game theoretic way it's going to
be pretty difficult to always know who
wins and to make sure that the guy who
wins it actually is the one with the
highest value which is definitely not
the case in general okay so what can you
do
so the really amazing idea that Vickery
had back in the 60s for which by the way
got a Nobel Prize it was to use the
second highest price the Vickrey auction
basically the highest guy wins but the
price that he pays is the second highest
price the second price of the second
highest a competitor so what is so good
about this well the really interesting
is this thing is that you can actually
prove it very easily prove formal
mathematical theorem that no bidder can
ever gain whatever the other bidders
values are or whatever the other bidders
report no better can ever gain by lying
you are always better off or at least as
as well off by telling the truth by
behaving according to the real value so
way so let's just look at the basic idea
so the form of proof is really easy you
can go and if you've never seen it you
should actually go and prove it to
yourself basically suppose my real value
is 5 how can I gain well suppose if
there really the second highest value is
3 well if I say more or less than 5
nothing is going to be changed because
the values the numbers the amount that I
pay is basically the second highest
bidder which is the VAT it all depends
on what I say but rather on what the
other guy says so the only way that our
difference can be made if I actually say
something that is below 3 below the
second highest in which case I will lose
but then I don't want to lose so I can
never gain basically by lying and this
can be this is a form of theorem so you
know so you know first of all you know
this is used all that lots of times and
but if you look at it from a computer
science point of view we've achieved
here something that's quite remarkable
we were able to correctly compute a
function the function is who has the
highest V where we didn't have any
access to the inputs the inputs were
simply distributed to the different
players the different bidders had no
interest in getting the right result but
just had their own go selfish goals and
yet we managed to get the right a
function to compute the correct function
and inputs that we didn't know so if you
look at it this is really a quite
amazing and if you look at it from
economic point of view this is already
if you wish the basics of Adams misses
the invisible hand by which you get the
right allocation in society even all the
different members with their private
information are totally selfish okay so
now let's try to generalize the thing
and let's put it this this idea
basically in the most general framework
and here is the general formalization of
this idea of incentive compatible
mechanisms for various problems so we're
going to have a set a after if you wish
so what we will call social alternatives
which is basically usually in computer
science we're talking about allocating
all the different resources that's a
protocol studies so we're looking at all
the different possible or locations of
all the resources all the possible
outcomes of the protocol of course this
may be exponential in whatever you want
it to be usually so the total number of
allocations can be totally huge but you
know first mathematical formalization
it's convenient to look at just a set
finite set a as possible outcomes now
each player looked at all this huge
outcome and has some kind of idea how
good is this for you and this is going
to be there we're gonna call that their
valuation function so it basically
assigns to each outcome and numbers it
says how good is this for the ice player
and now usually this value of this
function will not depend on the whole
outcome but just on the part if you wish
on their locations that the user gets or
maybe you know a few other neighbors in
some you know in meaning sense but still
there's going to be some kind of
function this way and now what does a
mechanism do it does two things given
the inputs of the players which are
completely a so the idea that the inputs
of the players are now completely
encapsulated by this valuation functions
so usually we won't actually send the
valuation function but only the
parameters the private parameters that
are actually specifying it but you know
mathematically speaking we get these
valuations we apply some kind of
function that says for
these are the different preferences of
the different members of society the
different bidders what if the output set
is going to happen
so this specified how do we actually
want to do the allocation now what do we
actually want to be the outcome of the
protocol a when the input input if you
wish when the private values are is
given and of course it also is allowed
to actually charge payments from the
players just a dollar amount where we
are I recall again that were assuming
that everything now is in same monetary
terms and the formal definition of
incentive compatibility is that you
never gain by lying so what does never
mean even if you knew all the
information in the system which is a
strong is but even under this assumption
you will never gain so this means really
mean that you never can gain so let me
actually look at this say let's try to
see what this means it means that if you
look at any player I whatever the true
inputs are whatever the current
situation whatever the values of the
players are the valuations of the
players are are if player eyes sinks
shall I maybe act according or report
some other valuation which is not my
true value but because my true value is
VI what will happen if I actually report
a VI prime will this improve my lot or
not improve my lot so if we reports a
write VI there is going to be some
outcome which is going to be a and he's
going to get a you to a value of VI of a
from this and he's going to have to pay
P where P is the amount that he pays a
when he reports the right thing so a is
defined simply as the outcome of the
mechanism when you actually report your
true value a and P is the eyes a payment
that's a mechanism specified if you
report your true value a now let me just
say this notation is standard in the
game theory and not all user so often in
computer science it's very very
convenient V IV - I simply means the
vector of ease so it's V 1 V 2 V 3 V 4 V
- I just means when you take out the ice
value ice component from it and then
when I have VI here I put it
so this is simply a way to focus and a
single component versus the rest of the
component so this just means the V with
uh all correct V and I try I'm going to
compare this to what happens if I lie if
I act according to some other valuation
so some other if I act according to some
other valuation the other players are
still going to say what they're saying I
will say this the outcome will be this
some kind of a allocation a prime and
some kind of price P Prime and what I
want is that if I compare my utility how
happy I am except while saying the truth
versus how happy I am when lying it's
better to say the truth thanks to a
mechanism that has this property
basically gives no motivation for any
player to ever say something other than
the truth other than acting according to
is a completely true private information
it's clear so let me just say say a few
comments about the definition so first
of all was very strict it was formally
it what's known the dominant strategies
it means that whatever the other players
have you can't gain one can also look at
a look at the watch weaker and more
natural if you wish assumption that's
saying well of course you don't know
what you know with the total situation
you just have some kind of you know you
have some kind of maybe probability
distribution that specifies your lack of
knowledge let's see can you actually
improve your lot even with this partial
information and of course the result so
of course definitions we have here is
much stronger if you can never improve
your lot by lying then of course you
can't improve your lot by not knowing
anything by not knowing everything as
well the second thing is that this is a
very clean definition meaning you can
never gain you can also think of various
weaker notion though you can't gain too
much or you can't gain computationally
efficiently or you can think of many
other you know weaker variants and this
is of course a very reasonable class
actually this is maybe the name of the
game to find the right notions here so
it's really interesting field for
research but for this talk I'm just
going to focus on the completely clean
definition never gain by lying
and the third the comment is that a this
idea of telling the truth so you know at
first sight it may seem a bit overrated
what do I care if they tell the truth or
act according to something else really
the only thing that interests me there's
going to be some kind of weird the weird
mechanism at the end there's going to be
an outcome if players are selfish
they're going to act according to
whatever optimizes their own goal so we
have like a game situation kind of
saying so let's find the Nash
equilibrium or some kind of equilibrium
notion and let's just require that the
outcome in this under this equilibrium
is what we want rather than forcing them
to tell the truth so this is the basic
idea and it turns out that this more
general definition basically is exactly
equivalent you gain nothing basically in
the parameters that I'm a studying today
if you allow these more general things
whatever can be reached at equilibria
when players are selfish can be reached
by the way if they're telling the truth
and this is as long as it's a
equilibrium condition is still under
this universal thing is that we defined
here so so ok so that's basically the
definition so far was basically a
classic definition from the economic
field of mechanism design and more or
less was a standard notions notations so
when does this become what's called
algorithmic mechanism design this new
fields actually combined computer
science together with AG microeconomics
theory well basically when you have a
mechanism design kind of challenge but
in an algorithmic context where there
are some algorithmic problems
algorithmic challenges in actually
finding the outcome and then you really
have to combine bolsa you know computer
science point of view are actually
finding the correct outcome social if
you wish social welfare and combine that
with all the economic issues of finding
the right pricing as to make the
incentives we have the way that you want
so here's of a bunch of classical
examples it's fall squarely into this
category one of them is connect
combinatorial auctions suppose you have
a bunch of things that you want to come
to allocate together so the classic
example is the FCC auction where they
have you know hundreds or thousands
usually of licenses and all of these
licenses are completely are related to
each other some complement each other
some are substitutes for each other
thousands of lights
in different frequency bands different
geographic area and they're selling them
together and the different bidders you
know are all interested in subsets of
these and the question is how do you
allocate all of them amongst all the
different bidders so if you look at it
as a computer science point a problem
it's already hopelessly difficult it's
of course np-complete any way you look
at it so that location is difficult even
specifying what you want is like a
language design issue which is not to
reveal it's very complicated and then
how you combine that with incentive
issues with what are the right prices
this is one example another example is
scheduling so usually in the scheduling
literature in computer science you know
we have a bunch of processor then we
just tell just this job run here this
job runs there and then of course we
still have our all all of our you know a
classic scheduling problems you know if
you want to optimize and may expand what
do you do if you want to optimize this
other thing what do you do in whose runs
what but what happened if the computers
now belong to people they're not just
willing to run your process you sort of
have to pay them for that because you
know they they are selfish entities you
know they're like servers commercial
servers running and willing to execute
other people's jobs how do you now do it
so you're left with the usual scheduling
problems but now you also have to pay
them in an appropriate way
another example is lots of times there
is something that's done collaboratively
in the internet for example a simple
example is you have some kind of
multicast so multicast is often better
than actually sending a same separate
message to each and every different
computer definitely when you're doing
like a video kind of sync if you're
actually doing the multicast how do you
actually split the cost of transmission
which is now can't be really specified
who is responsible to which part of the
transmission because there is a
multicast there is some kind of common
things there how do you split it between
the different different guys who want to
receive the transmission so again there
is an algorithmic challenge there you
know who gets it word you route things
and so on to use your computer science
kind of thing but also the question is
pricing how do you make sure that
actually the guys who really need the
transmission get it and not the others
and many other examples like this
exactly squarely fall into this category
almost any kind of thing you want to do
on the internet if you really think
about it you're left with a mess
the computer theoretic problem as well
as with the messy messy economic problem
and they are related to each other
interrelated you can solve one of each
one of them separately so in general in
oza you know the holy grail if you wish
what would you in general want to do
basically we'd have all the resources
over the internet so every single byte
of CP a bite of memory every single
cycle of cpu time this communication
link printer and the other hardware that
happens to be connected there that's all
belongs to the Internet
each piece belongs to someone else and
now we really want to somehow reallocate
all the resources in the world in the
optimal way among all the different uses
so there's no reason that I would have a
printer if your printer is just down you
know just the next house and you're
willing to let me use it like for
example for a fee of course so in
general these are the type of questions
you know whoa this is like the extreme
form of it of course but these are the
type of questions which we would want to
address in algorithmic mechanism design
so let me start by saying here is what
we learned from from the economists
which is a very neat trick and it is a
starting point of every investigation
along these lines so what we learned
from The Economist is what's called the
victory Clark groves mechanism and here
is a here is the various here's a simple
way to describe it okay so the first
thing is this is applicable when we want
to have to optimize what is probably the
most natural thing to optimize although
not the only one from our point of view
which is the sum of the values of all
players this is sometimes called the
social welfare so if I want to optimize
the sum over all participants of the
values that they get from their location
this is definitely makes a lot of sense
and what do you do if you want to do
that well from Elgar is from you know
economists don't worry about how do you
find our location they're actually
maximizing this you just find it so let
us just find it so you find the
allocation a the outcome that is best
from the total social welfare point of
view and now the only questions that we
have is what kind of payments do we
charge people as to make them tell the
truth about all the
and here is a basic idea and the basic
idea is following let us pay to each
player I the sum of the values of all
other players of the given outcome okay
so if for this outcome I say my value is
5 you say your value is 7 you say your
value is 2 I will get the 9 7 plus 2 so
the mechanism the centralized fictitious
entity will pay us will pay me 9 so
don't worry for a second the fact that
you know we're playing so as a mechanism
is paying so much money to the bidders
we're actually they should be paying to
it but let's just see why does this very
simple scheme actually ensure that we
get the correct result that no one ever
wants to lie well basically now let's
look at it from my point of view how
much do I get if some outcome a actually
results well first I get my own value of
that result which is via I of the result
but then I'm also going to get paid all
the values of the others so my total
value is going to be simply the sum of
the values of everyone including myself
and others each one of us cost one
counts as one once that's I'm going to
actually get exactly the sum of values
of every one of that result which means
it really what will optimize my own
welfare what is best for me simply
saying the truth which will result in
exactly the a that maximizes this being
chosen okay because now basically we've
completely aligned my own interest in
the society's interest which is
basically what the mechanism is trying
to achieve so there's no reason for me
to lie my interests are exactly to find
the most socially it should socially
optimal saying so I will never lie if
I'm rational so so this is the basic
idea
very simple idea and yet very powerful
so a one thing for those worrying about
you know we're paying all this money to
the players they should be paying us
that the actual thing is that there is
another another term that I'm going to
detail in a second that's going to have
no strategic justification so that other
term is not going to be important all
from my point of view when I consider my
own intent
but would sort of fix the direction of
payments so what is not going to make
any difference from my point of
incentives basically if the prices that
I get paid are increased for every
possible option or increased let's say
by five nothing has changed for me
because then I'm comparing two numbers
that I can get for do different
alternatives both of them is they have
increased by five
now this five can be an arbitrary
function as almost everything except
what I say because it can be an
arbitrary function let's say f what the
other guys said because again when I am
looking at my own incentives that's
going to be a constant and it's long and
whatever I say is not going to affect
that so it's just like it was a change
of five so what it basically mean is
that now I can choose any function that
I want any basically constant shift or
constant that depends on anything that I
want except for my own value and shift
it and a very reasonable constant would
be and let's look at the other guys and
see how much what would be their welfare
if I didn't interfere in the auction so
if I didn't interfere in the auctions
the outcome would probably optimize
their own goals
I do interfere I do participate in the
auction so maybe something else is done
the difference between so so this is
actually the difference that I'm going
to pay so basically I'm actually going
to make first pay to each one to each
player so the mechanism is paid to each
player as we've said the total some
evaluations of the others but then take
away the total some evaluations had we
only optimized for them okay so the
second term does not depend at all it
what I say it doesn't kill the
incentives but yet of course you can see
that of course had we optimized only for
the others they would get a higher
welfare in this case which optimizes for
me and the others together okay and one
nice way to look at it is that the way
the total payment this way is basically
counting what did I do to the others how
much did I harm the others okay without
me they would made so much with me they
make less because I make also something
this difference is basically what I need
to pay this is the harm that I cost
Society okay what's called income being
a phenomics basically I've internalized
his externalities
so let me just give an example for this
suppose that we have some kind of
network and this is like a shortest path
problem that we learn algorithms course
I want to send a single message from the
source to the destination and each link
has some kind of cost how much does it
really cost to actually send a message
on that link and the question is how
should I send the message from source to
destination so in computer science terms
this is simply I have to find the
shortest path between source and
destination what makes this an
algorithmic design problem well now the
links the links here are going to be
owned separately owned and with their
own goals so I will have to actually pay
them for actually using their link so of
course now they're going to have some
kind of incentives to report their true
cost or not according to the way I paid
them what was the VCG message say how
much do I need to pay the links so the
VCG mechanism in this case would say the
following thing first of all you do take
the shortest path and the shortest path
is what's here in green total cost 2
plus 3 plus 2 plus 6 which i think is 13
ok so this is the first side and now we
have to figure out what is the payment
that will actually ensure that I get all
these numbers to begin with and what it
said is following let's see how much do
we need to pay for this to guy and up
and the top when I get to actually
calculating the amount of payment that
he needs to get I basically have to look
what would happen without him what would
be the shortest path without this guy ok
so without this guy I think that the
shortest path turns out to be 15 so I
think it's something like actually I
don't know what maybe 3 and then 8 and
then 5 no that's more than that 16 well
so there is some other path here that
does not use the 2 link on the top that
of costs a 15 if the example is correct
and which means that the following thing
this guy we have something of length 13
which means that he pays the cost of two
really and the others all the others
together which basically means the other
guys on zan Inc pay 11 without them
everyone will pay 15 so his if you wish
the amount that he contributed to
society as for the difference between
this 15 and 11 which was what the other
is the cost of the others so he should
be fed for not two but rather four and
if you pay him for and do the same
calculation for everyone then you're
guaranteed will guarantee this everyone
is rational says they will tell the
truth okay so this is like an example
how you can take like a classic if you
wish you know very stylized but still
you can see that it comes up in many
places and try to apply the pricing to
it so this is very nice now we have this
amazing technique VCG from economic
theory we should be done and in fact I
would say that probably it's true that
the first few years of the field was
rather basically busy understanding what
this means VCG and now we can use it in
various a application computer science
applications but they for a long time
other issues have crept in and here are
the following example is the following
three top reasons where we need to do
other things and not just use you know
this great invention VCG pricing the
first problem is the price of air if you
wish revenue or prior or budget balance
if you try to use it exactly as stated
you basically get problems in terms of
sometimes people pay too much or too
little for things for example in the
previous example if you actually
calculate how much are the total who
payments then to the different lengths
they can be many times higher than the
cost of the shortest paths or even the
second shortest path or so on so there's
obviously something wrong here where we
do get the shortest path but we pay for
it our price that is much much higher
sometimes we have the mechanisms where
actually you have to subsidize you have
to pay to the bidders even though that
does not make sense
that's one reason the second kind of
reason is the fact that a
she only works when you're trying to
optimize what's called the social
welfare it's the sum of utilities of the
players many other times we want to
maximize other things not just a ton sum
of utilities usually some kind of
fairness condition in the sense that we
don't want any single person or bidder
to be really in a bad situation to have
a very low VI so of course this can be
also this also applies in economic
settings but in computer science
settings a lots of time when you're
doing scheduling we're not just trying
to optimize to minimize the average
completion time which is like the sum of
completion times but we're also usually
trying to minimize the completion time
of the last jobs and may expand so if
that is the case if that's what we want
to minimize then we can't use VCG
because it just doesn't work it can only
be applied to the very single
optimization goal of the sum of the VIS
so many times we want to optimize other
things that's the second major reason
and the third major reason is that we
can't always do this optimization so
actually optimizing the writer location
and most computationally interesting
problems is going to be a
computationally hard problem and we will
not be able to do it but only get some
kind of approximation or heuristic or
anything like that and the problem is
that we only have an approximation or
heuristic then we're not guaranteed that
the VCG will actually give us incentive
the correct incentives so to get the
corrected incentives we have to do the
exact optimization if we don't do that
we've lost we don't have these
guarantees so what I'm going to do here
in the rest of the time that I have is
give a few examples of you know the kind
of places where we have this new
challenge and they're the type of
results that you get there but before I
do that I would like to write try to put
in some perspective what are basically
the requirements that we get in order to
get incentive compatibility so I can
sort of try to persuade you why what you
get is incentive compatible and various
results so basically an easy proposition
actually can actually characterize what
requirement must surprising have passed
in order for the resulting mechanism to
be incentive compatible and if the
following torii
results needed the first thing is if you
look how much pain player I pays that
cannot depend in any way and what he
says beyond the fact that what he says
changes the outcome and so that's the
only way in which the payment can depend
on what he says if I say two different
things and the same outcome results the
same allocation results then it also
must be the case that I pay the same
amount in both cases otherwise as a
motivation for manipulation is
completely clear I will just say the
thing which makes me pay less okay so
this is the first thing that you must
have first condition of payment so for
example notice that the second price
exactly satisfy this what I pay does not
depend at all at what I say but only
what the other guys the second
requirement is that the mechanism must
optimize for each player so basically
once now we have prices that only
depends on the outcomes which is ensured
by the first condition now each player
basically has in front of himself some
kind of Tamizh ation problem how much
value do I get from it some comment are
out of allocation a versus how much
payment do I pay for a location a and of
course each player will optimize for
that so what we need to do is that the
optimum of this is exactly what the
mechanism does if he tells the truth so
the mechanism must optimize basically
for each player and the difficulty here
comes from the fact that you're
optimizing together for all the
different players who are participating
which may have clashing views and
somehow you hope that these payments
actually made all these clashing game a
clashing goals the same goal which you
must do so here's an example of the
budget issue here is a very simple multi
class problem I have a source that wants
to multicast
some kind of a message to the different
leaves in this tree and now each leaf
has some kind of value that he gets from
actually getting this broadcast message
which is written in the different
circles in the leaves but also we're
going to have some kind of cost on each
Veron each edge which describes the cost
for actually using that
what we really want to do is basically
send a message send some kind of decide
which part which subpart if you wish of
the different players of the different
Leafs will actually get the message and
then have a three rootage that only gets
to this subset of leaves and then do the
pricing in a way that makes them correct
that pace it's a reasonable okay so and
the idea is here that the edge cost are
going to be common knowledge that's not
going to be the secret part but really
the players here are going to be the
leaves of the tree so what happens if
you actually if you actually try to
optimize findings that you know the
basically the sub tree or the set of
leaves that gives you highest total
value and then you see how much they
need to pay you see that they pay too
little the amount that they pay cannot
cover the cost of transmission basically
if you look at let's say the nine guys
there how much is he going to pay so if
you try to put some kind of VCG pair
prices according to how much he has to
pay you see that he has to pay very
little because the amount because even
without him the other guys would get the
transmission so really he shouldn't have
to pay for anything but its own age but
of course if you do the same kind of
logic for each separate player that only
paid for his own age no one pays for the
common edges so you can't just do a VCG
kind of thing here you have a budget
deficit you don't raise enough money to
cover the real expenses so here's
another mechanism which is like a
Shepley cost sharing mechanism sometimes
called the idea is the following
you start by thinking okay everyone will
get sawed everyone will get the
transmission and then at that point you
say well let's see I'm going to put
tentative payment on each player and
what are the tentative payments
basically each link is going to be paid
by everyone that you visit so for
example let's look at the eight guy at
the beginning he has to pay for the for
the three edge leading to it completely
and then the two edge after that he has
to pay half of it because he shares it
with the eleven
player and then he has to pay a third of
the six and a quarter of the twelve so
his payment should be three plus half of
2 plus one-third of 6 plus 1/4 of 12 and
if you look at this number it's more
than 8 he's not willing to pay so much
so he drops from the auction okay and at
this point he drops now we're left with
three players and now we recalculate
this kind of saying for example if you
now undo the calculation for the 11th
guy he has to pay completely for the one
edge completely for the 2 edge
afterwards because now this guy is
already dropped and now he keeps on
sharing the next two edges with 2 and
with 3 other with 100 was two other
players at this point is happy so when
everyone is happy no one wants to no one
wants to retire we're done and this is
what the payments are okay this is a
different kind of payment sort of sphere
in some sense and if you look at the if
you look here this also becomes this
also is incentive compatible there is
never any reason to lie if you look what
happens
you know I'm basically presented with
numbers and if I'm willing to pay this
I'm stay in if I'm not willing to pay if
I go out and you of course you have to
make sure and see what happens different
orders and so on but this all works out
the prices only increase it's the order
of the of the order of considering the
different players does not matter and
this is one example of you know another
mechanism if you wish let me skip this
example let's learn it look at another a
scheduling example so this example is a
we have a bunch of processors that can
execute jobs and we have a bunch of jobs
that need to be executed over them and
let's say let me take the most general
scheduling problem in the literature
which is for every process and every
processor is going to be some cost of
executing that process on that processor
and these are in you know this can be
arbitrary numbers this is like a
completely general model of scheduling
and of course to make it interesting
we're assuming that the processors here
are basically strategic they want to get
paid and you know their capability
how good I am how much CPU or do I have
what is the moment in my mind my
communication bandwidth and so on hey
all this is the private for the
processor so the process is know exactly
how much time it will take for them or
what cost will it take for them to run
each and every pot job but now the
question is how do I get them to
actually report these times correctly
before I do their location and send
things okay and and then my goal would
be the classic gold okay no the most
standard goal in this whole field of
scheduling usually if you're a computer
scientist which is optimizing may expand
the last time of the last job the
finishing time of the last job and now
if you try to listen this is a problem
that's you know hard computationally but
you can approximate it well in various
situations and the question is can you
do this in an incentive compatible way
and the main result is and I won't so
there's a very simple proof but it will
take me five minutes that I don't have
here a that you cannot do it so there is
no way to assign prices in a way that
will make this incentive compatible with
the processors and even if you try to
approximate it as long as you lose a
factor of less than two the theorem says
that you cannot do it an incentive
compatible way and actually for a pretty
long time nothing was known can you do
get within a factor of two because the
only turn and normal upper bound is
actually losing totally an upper bound
of losing a factor of n basically which
means that you really are n is the
number of processors here so we
basically schedule everything on one
processor or something like that
and after a long time the lower bounds
are just slightly improved and in
general this and by the way it was you
know significantly hard work and and so
this is one open problem saying can you
get some kind of approximation I don't
know 2.42 approximation or any kind of
reasonable provably reasonable
approximation or even heuristic Blee
approximation for this kind of job if
you insist on incentive compatibility
this is another one of the a you know
open areas the third examples that I
want to show is a combinatorial auctions
so let me just say what they are so
chimera
so they have a bunch of mint a bunch of
items and different items and n bidders
are actually a you know wanting subsets
of these items and the whole point is
that the value of a subset of items is
not just given by the value of each item
separately because there are connections
maybe a bidder has like a common budget
that he can't just take everything but
they are related maybe he means you know
two adjacent spots in order for it to
make sense there are many kinds of
things so but in general the general
formalization is that the value each eye
has a value for every possible set of
items s and we're assuming that these
values are increasing as you get more
items which is very natural but nothing
beyond that and the basic goal would be
let's allocate how do we auction all
these items together okay so you may
speak you in general you may how do we
auction all these items together in a
way that maximizes the total value so if
si is a set of items that I get how do i
met optimize the total value that
everyone gets together and there are a
bunch of difficulties there if you're
trying to look first of all there are a
presentation kind of thing the number of
possible items is small usually
manageable the number of possible
subsets is going to be exponentially
large how can you even represent the
value of a bundle I mean there are
exponentially many numbers that you need
to give somehow you're going to have to
either succinctly Express it or have
some kind of iterative protocol by which
this information leaks out you're going
to have to do something the second
problem is that computation
computationally this is like a
hopelessly hard problem many heuristics
that can do pretty well but again if you
have only heuristics or approximations
you can't use VCG okay and then of
course the incentives once we have some
kind of a handle and the computation
using some kind of approximation then we
have the problem of incentives and of
course a classic example of that but
there are many other examples in
transportation and many other in
procurement and many other application
domains the classic example of the FCC
spectrum auctions where basically you
know this is what I took from
FCC site about a year or two ago when I
stole this slide this is what they were
selling at that time something like two
years ago so basically each of these you
know little areas is a license actually
each of these little areas is about
three or four different licenses one in
each one of these colors frequency bands
be specified by the colors here so you
can see they were selling something like
I think it's like 300 regions times five
licenses for each region over a thousand
items together and the different
basically cellular companies and in the
next time apparently even Google they
are going to actually bid are bidding on
these sets of licenses which you need in
order to operate any kind of wireless
service okay and the question is how do
we actually do that so this is a
practical problem it's actually raising
billions of dollars for the Treasury and
it actually has even larger implications
in terms of the whole economy not just
the amount of money that the government
gets how do you run these kind of things
okay so again as we said computationally
it's an np-hard problem you can do many
types of approximation there
optimizations here in terms of
computational settings so probably if
you just want to find a good location
there are many things that you can do
pretty pretty well but you can't just
plug in the usual VCG kind of pricing
ideas to make the whole thing incentive
compatible it doesn't work you need to
find the prices compute the prices and
at some kind of clever way if you're
only approximating and then there are a
bunch of the special cases so this is
again one of these things that I don't
get here there are basically two
strategies or two special cases by which
we actually know how to get something
that's incentive compatible heuristic
aliy but in the general case but these
are very limited cases and the most
general interesting cases are totally
open so I'm going to skip this a
description of this case which basically
P is the case that people understand
well how you can get incentive
compatibility and just leave basically a
basically that case says that if you
have a single parameter in your problem
single secret parameter in your problem
then you can do stuff and many cases do
have single parameter for example or the
example that I showed let's say with
cost sharing each participant has a
single parameter which is own value okay
or in a regular auction of one item each
participant has a single parameter which
is own value again so in this case you
can do
there are many mechanisms that are known
you can do actually in this case there
is a nice result of Roberts from the 70s
that says that in the totally general
case and I'm not going to formally
specify what a totally general case mean
there is nothing that you can do except
for this VCG idea so basically there is
nothing that's incentive compatible
beyond the tricks that I showed you the
VCG trick but the problem is it's almost
all interesting computationally
interesting problems lie somewhere in
the middle so all types of scheduling
all types of combinatorial auctions most
of the things that you would want to do
actually are in the middle in the sense
that it's not a single parameter that's
not known nor is it the case that you
have so many parameters is basically
everything is possible there are some
restrictions and basically almost all
computation interesting problems fall
within this intermediate range where
essentially nothing is known so nothing
is known in the sense that we don't know
how to get any incentive compatible
mechanism that's not VCG where many
times for various reasons that I
explained we can't use BCG and yet we
don't know whether this is possible even
or not possible
so a basically the main open problem of
this whole field is trying to understand
this intermediate area what can you do
in an incentive compatible way and thank
you I will take a question if there are
any
yes
so this condition in order to stay
incentive compatible your payment won't
depend on your own right
probation information right or the
revelation
I'm also seems to imply that if you are
a semi Byzantine agent who will tell the
truth if it's strictly better for you to
otherwise if there's no difference will
lie it seems like that's I hope this
problem right ok so actually you're
right so the definitions that I that I
took said basically that if you're
indifferent between the truth and not
the truth you won't lie one might also
consider asking there to be like a
strict inequality that the truth should
be really better for you and it's not
that different it just makes it things a
bit Messier but I don't think it changes
the quality
in any of the results basically as long
as sometimes you can be hurt doesn't
matter that you are always hurt but as
long as you never gain and you are
sometimes hurt friends that think that
everything that I showed a you know even
under the stricter condition carries
over okay it just makes you know
formally the presentation a bit Messier
but it doesn't matter okay so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>