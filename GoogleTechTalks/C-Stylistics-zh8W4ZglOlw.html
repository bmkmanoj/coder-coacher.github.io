<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C++ Stylistics | Coder Coacher - Coaching Coders</title><meta content="C++ Stylistics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C++ Stylistics</b></h2><h5 class="post__date">2008-03-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zh8W4ZglOlw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">our speaker today is Kaplan Henny Kaplan
is a consultant and an author if I won't
even try to list all of the different
places that he's been published if
you've been following C++ then yeren
you've undoubtedly read in several of
his articles already
he always has interesting things to say
and today he's going to be talking about
different styles for using C++ okay
thank you man okay it's quite a lot to
get through so I may well skip some
slides and we'll see how we go and play
this one by ear
although explore some of these questions
of programming styles of C++ that tend
to pop up there's a sort of growing
interest in programming styles and the
multiplicity of styles available to
developers and this seems to be reaching
out across languages there's also a
strong recognition that many languages
have thrived because they have pushed
themselves as supporting many styles in
the past it turns out that some of this
interest is not new and there but
there's also a certain amount of
confusion in this space not least of
which thanks to our friends the word
paradigm which is really messed things
up properly I'll have a quick look at
that and describe why I favor the word
style but also describe the notion why I
why most languages can claim to support
multiple styles so the focus here is on
C++ in the absence of a perfect language
we have a language that is used in
production a number of places and has a
very strong track record there are many
many styles that we could be looking at
i have constrained this to just three
broad groups two of which are properly
styles in terms of a way of thinking the
third which was just a bucket
placeholder for two quite different
styles which i've put under the language
mechanism that's the only one defined by
language mechanism as a word template
based styles there are many more styles
we could be approaching there are things
that I'm not going to cover and
particularly areas where the support is
not core in the language or the support
is not there in the language
at all you can sort of fake up a
functional programming style sort of
kind off but it's never going to be the
same as using scheme or Haskell that's
not a style that is supportive if we
talk about concurrency there are so many
overwhelmingly different styles of
concurrent programming and strictly
speaking none of them are supported in
standard C++ although we have ways of
wrapping things of doing things the most
pervasive style here is a sort of
standard free threading style which kind
of fits out as an offshoot of procedural
okay and I'm not going to talk about
that one because certainly it in itself
it's a talk I'm going to presume that
you've got some kind of idea of
programming for start I want to get a
sense of how many of you use C++ either
sort of yeah 20% or more of your time is
taken up ok so there's something ok
that's that's reasonable ok that's good
so that'll allow me to shoot past a lot
of slides just going yeah you know this
I want to first of all look at this
question of stars conveniently enough
there is a word that covers what I'm
interested in stylistics the study of
the literary styles or particular genres
or writers this captures probably a
little more closely the way that we look
at and work with different approaches to
programming than the common use of the
word paradigm trouble with paradigm
paradigm is a term from linguistics so
surely it should apply to programming
well not really
that's not how it's used the sense in
which people have kind of tried to use
it it was popularized by Thomas Kuhn in
his 1962 book I think related to the
structure of scientific revolutions a
book that I won't say is riveting
reading but I will actually claim to
have read it it's and you know I got
something from that many years ago the
and that was what it defines the modern
use of the term now what is interesting
is that even there you think well that
that's it there's a concrete solid
definition
but even then that doesn't work many
people when they look at it from the
kind of kuhnian sense of trying to say
that there's one way of doing things
that there's one kind of dominant and
overarching a way of doing things
now in programming this has never really
been the case the world of programming
is diverse and one one area where people
are programming may could be completely
disjoint to another area you had a COBOL
programmer talking to an APL programmer
going back a few decades no unlikely
they do not have a common language or
even a common way of speaking that has
not changed there has never been a
single overarching model there may be
something that we've we teach a lot
there may be something that is in the
press and is in vogue and is sexy but
there's never been one single way of
doing things the other way in which
people use it is they try and use it
based on the first point they try and
use it to make a marketing point and
it's it's related to the term paradigm
shift and that notion of shift happens
the idea is well we were all doing this
but now it's all going to be different
we're all going to be doing that that's
mostly for dramatic effect or to make
yourself just sound a little bit clever
you know there's another way of doing
something probably more usefully the
sometimes people try and relate it to
language features and again that's a
very mechanistic way of looking at I
don't enjoy looking at languages just
purely from a point of view of mechanism
it's how the mechanisms into play so for
example overload being able to overload
functions is not a paradigm although I
know that I've seen that claimed in a
book perhaps the most useful one and the
one where it was originally used with
great effect and so in 1978
cheering Award winner whose names just
escaped my mind just at the moment and
he wrote wrote the paper Oh Robert
Floyd notice he wrote a paper to where
he effectively used paradigm to mean
pattern or architectural style if we use
more modern vocabulary
and what is interesting is that he
related this to what many people try and
use the branding multi-paradigm for now
a paradigm makes you try and sound smart
the multi-paradigm is designed to make
you sound really smart again so we
already have confusion over the term
paradigm multi-paradigm just multiplies
the confusion sometimes it's a set of
language features there the challenge
here is that if you're saying that a
paradigm is related to a style or a
pattern then clearly a single paradigm
approach is a failure mode if you only
have one way of doing something then
that is a problem so by definition
anything that is multi-paradigm is
normal single paradigm is a lack of
imagination and ability a programming
language that is general-purpose is by
definition multi-paradigm I know a very
few general-purpose programming no
general-purpose programming languages
that could ever be said to fulfill only
one paradigm and part of the problem
with this is that the term paradigm is
not a normalized term it's not disjoint
you don't have this mutually exclusive
with that you you look at things you see
them at different levels overlap and all
the rest of it not useful term too much
confusion let's use something else
focusing on style from the dictionary we
can see that it talks about the notion
of style a manner in which something is
done a distinctive appearance and design
if we start looking at building
architecture and talk about building
styles or the sort of schools of design
that exist that gets us a little bit
closer to what we're talking about and
there is no notion we only have one way
of doing something these are all
complementary they can coexist and
indeed that's the normal state of being
there is nothing modern about it there
is certainly nothing postmodern about it
although that is a term that seems to be
gaining some popularity in certain
quarters so what we can say is that
individuals have styles lovely little
word that's not commonly used EDA lect
a problem is that eg electic style is
problematic I'm sure you will encounter
code that falls into this category oh
yeah that's the way he codes for a
particular way of doing it the school of
thought establishes an idiom so a group
kind of approach but even when we say
procedural style that doesn't tell you
that there is one way to do something
you get a C++ program and use
procedural style I ask you what that has
in common with the Fortran programmer
using a procedural style having been a
Fortran programmer I can tell I could
tell you these are worlds apart
having gone from Fortran to C I
recognize that all of my C code
initially looks like C Tran C was spoken
with a very heavy Fortran accent it was
unrecognizable as proper C it was
syntactically correct
when I did Fortran again a year later my
Fortran was unrecognizable to a Fortran
programmer and that was one of the first
things my colleague changed so to even
say procedural style doesn't nail it
down each language pretty much comes
with it sounds its own notion now of
course any real problem is going to
demand a little bit more imagination the
idea that if you only there's nothing
more dangerous than an idea if you have
only one idea so you are expecting in a
serious piece of software to mix styles
at different levels in some way some of
it may be individual preference but in
other cases we'd like to think that it's
anchored in the problem the challenge
here is that when people mix styles it
does take skill and taste these are two
things that are not necessarily easy to
teach but can be acquired over time and
obviously there's a certain sense of
subjectivity to taste but there is some
into subjective agreement and when
people often use this notion of mixing
styles and sometimes I've heard people
say yeah we're doing multi-paradigm
development what that actually means is
we haven't got a clue what we're doing
we're doing all kinds of different
things little kind of fits together the
other branding for this is postmodern
again I'm not interested in that what I
think a lot of these approaches are
missing is a focus on the problem domain
a crazy idea these are all solution
styles there's somehow hopefully a
relationship between the style that you
choose for your solution and the nature
of the problem you're solving if you are
solving a process control problem and
you are bickering over whether
procedural versus object-oriented is the
right way to look at it you're looking
in the wrong place neither of these
Styles is the dominant architecture of a
process control system okay
there are they has aspects of both both
of these Styles can be incorporated a
more tactical level in other words it's
the wrong discussion
was what is the problem and get a crazy
idea the notion that we would like to
relate the problem to the solution is
something that has a very strong
resonance with patterns which is
something that I'm very interested in
and have a reasonably long track record
with but also other ideas problem frames
that relate to the work of Michael
Jackson you're invited to guess which
Michael Jackson it is you have a number
of choices you can pick from a menu of
four there is Michael Jackson the beer
hunter who sadly died last year but go
to be a hunter calm author of some very
good books on beer and whisky from
around the world good Christmas presents
these books as well there is Sir Michael
Jackson who's head of the British Army
and head of the UN force in Kosovo it's
not him and there's Michael Jackson the
methodologist well that sounds promising
and then there's the other one we can
skip that one now
Michael Jackson the methodologist is and
requirements guy focuses extensively on
this idea that there are different kinds
of problem that require different kinds
of description okay and there are
characteristic things that tell you
about the kind of problem it is and that
will lend itself to suggesting a way of
solving the problem and an appropriate
style and robert floyd in his paper on
paradigms of programming which i want to
point out again goes back 30 years he
made the point that one of the
challenges that we have in programming
so we don't have enough paradigms using
his term we do not have a sufficient
stock to address the actual problems we
have we have a narrow limited vocabulary
that was his perspective so if we go and
look at something like C++ there are a
number of things that it's quite good at
and aligns very well with it we're going
to do this kind of idea of a lining
problem solution domains then when you
have to do what you have to talk to the
Machine and you care about things that
are machine level of abstractions then
you want that level of control there's a
kind of an essence of control freaky to
the language you know this is not a
language for people who like to drive
automatic you need a manual gearshift
okay but once you've got that boy you
can use it so if you like that then it
will fit so there's a personal fit as
well but in many other respects we're
talking about where it fits in the world
of the things we want to build embedded
systems there's a good fit there real
time systems you have that kind of level
of accuracy if you if you look at
languages that have been general purpose
but not designed for these and you for
example if you look at something like
real time uses of Java you've actually
have to gut the language and all of the
big selling points in order to get it to
work in that in that environment whereas
C++ requires relatively little
adaptation from that point of view
almost none it depends on the kind of
systems we're talking about
high-performance computing systems
programming in general algorithmically
focus code I find that if I have to
write algorithmically focus code certain
frameworks are pleasing and easy to use
in Java if I write algorithmic code in
Java I I don't know if I get and it's
difficult to describe but if the
experience is boring the experience is
one of of tedium I enjoy certain other
activities in Java but algorithmically
focus code is just tedious to write it
doesn't support the right level of
mechanisms although ostensibly that it
has a common heritage games programming
nice exciting one there and obviously
many other domains where C has been
favored in the past these are the core
areas although C++ has a certain
reputation as being a general-purpose
application language we're kind of
seeing that one drop off and I'm not
actually too sad about that to be honest
having been involved in training and
consultancy for a number of years I'm
quite happy that there are a bunch of
people out there not touching using C++
for that purpose it's making my life a
little bit easier so there are other
areas where C++ it doesn't really fit
and some of that's from its own design
some of it comes from its history some
of it comes from problems with library
design and cultures of library design
C++ has suffered our diversity and
enjoyed a diversity of different library
approaches but some areas just never
really took off the way they could have
done or indeed there are other ways of
solving these things and I'm thinking
particularly here it's not
you can't do any of these things it's
just that when you actually realize when
you work backwards from what you'd like
it doesn't look like the C++ code it's
doable of course it's doable ultimately
anything is doable given a computer
we're smart people it just might take a
bit longer to do it an assembler okay
but it's all achievable that's what
we're after its effectiveness so I'm
going to have a quick look at procedural
styles so it seems appropriate to pick
up a nice little algorithm to start off
with this is one of my favorite
algorithms it's not encapsulated in the
STL and it's actually it's quite a good
process for sort of software development
in the small though difficult to
replicate and normally unless you're a
Nobel laureate or yeah shirring Award
winner maybe you want to put a step four
in check it yeah so what do we mean by
procedural programming this notion of a
hierarchical decomposition of tasks okay
it's about the things that we do the
things that we do it with tend to be
slightly more subordinated they're more
passive entities we look at things
flowing through this in this sense where
the notion of the data structure is
considered more passive there's some
degree of commonality with functional
programming because the idea there is
your primary construct it's a thing that
does something or transform something
the data flows through the system and
this is reflected in the styles of
analysis thinking that grew out of this
school of thinking data flow based
approaches this is all very much at that
level it's the dominant element is the
thing that we are doing let us decompose
the thing that we are doing now we have
a number of choices the classic view of
procedural programming is very much the
top-down view the structured programming
of you little reserved about using the
term structured programming is anybody
actually looked at the book called the
structured programming it was written in
1974 by Dijkstra whore and Dahl because
in that you'll actually find that what
we call object orientation is quite
cheerfully listed as the third section
so because it is programming with
structure so structure programming as a
term of differentiation I'm not entirely
sure it's the right one but nonetheless
people are often
use it in this way there are differences
even within this basic space a notion
that is often overlooked is there is a
fundamentally different style between
more algorithmic and process based code
the there for example there is actually
a technical difference between a
procedure and an algorithm an algorithm
you wait for it to terminate because
it's supposed to terminate that is what
characterizes it a procedure is not
necessarily going to terminate and it
leads us into the world of processes and
indeed there's a whole different style
out there which we're not going to touch
today but nonetheless if you wait for an
interactive system that is written in a
procedural style or indeed any style if
you wait for an interactive system that
characterizes process and processing if
you wait for that to terminate you will
be disappointed you cannot say the post
condition of this action is because
there is no post condition post
condition is system shutdown so there's
a very different style of expressing
these there's the algorithmic view which
offers you one frame of thinking and
there is a process view that offers you
a different fit so even within
procedural style there is a reason that
this section is called procedural styles
plural because there is more than one
again when we look at things like
event-driven systems I'm trying to
characterize it by the the nature of the
problem the architecture we can use
procedural styles what we end up with is
an inversion of control flow function
pointers C++ support this well member
function pointers supported up to a
point little better off when we start
using some of the newer library features
it's not something that you get out of
the box in C++ in terms of the core
language but the notion of being able to
bind the context of execution together
with the target of execution and the
action then that's quite nice that's
very pleasant there's a number of
features in the tr1 library originating
from boost and making their way into the
c++ Xerox or 0x standard which may or
may not be hexadecimal we're not sure
that value of X
it's kind of touch-and-go as I
understand it but although we have used
this I mean if you think about a lot of
windowing code it's clearly event-driven
use of callbacks and these approaches
fits here I will say event-driven
systems also fit with our but I've got
other things to say on Io so I won't be
revisiting that topic but in truth there
is a there's good support here but there
is a very large hole from my point of
view having worked with a number of
other sort of languages and contexts the
lack of metadata and reflection means
you can't support what a style of
architecture known as implicit
invocation asserting we here ever used
orc okay a few hands go up there's a big
difference at the end of those any of
those people use Perl yeah okay yeah
Perl I haven't really kind of got on
with Perl I thought that all kind of
certain elegance to its design and it
has this kind of implicit invocation
approach Perl is kind of executable line
noise very very strongly kind of
top-down procedural in its approach what
was nice about per about walk is that
you would you would say right this is a
language that is structured for the
execution of matching regular
expressions on input on a sequence of
inputs a sequence of transformation it's
it fits within a particular
architectural model and it does so very
well and when does this piece of code
get executed well when it matches this
you have the notion of a rule or a
trigger and the implicitly matches
there's no if it matches this then do
this it just is the structure of the
program is character is to be defined
like this now this is a style that if
you have a language that supports
metadata reflection and indeed an
element of meta programming you can get
quite a lot out of and a lot of there's
a lot of Ruby frameworks out there that
demonstrate the power of this approach
and a lot of the modern Java
architectures that are perceived as
being lightweight and approach rely on
the use of annotations that are just
allow you to markup a class you can
actually do this it's a good exercise if
you're thinking of something interesting
to do create an orc like frameworks that
allows you to take a class and annotate
all the regular expressions you'd like a
particular method to execute on and it's
just it just is it's very very simple as
no
registration process there's no if else
if it's a very different star this is a
hole in C++ now what I'd like to do is
take that event-driven style or
event-driven problem and and do
something with it and I want to
demonstrate some different styles timer
on/off so you have heating well no you
don't you're in California but I'm from
the UK we have heating it gets cold you
need to turn the heating on you need to
turn the heating off and rather than
doing it manually you'd like to have
this on a timer that makes certain sense
so we have our heating class and we can
turn it on and turn it off if you favor
a flag driven approach to programming
it's you would have enable bull
true/false but let's actually use this
kind of sensible kind of style of
programming an intentional one where we
say turn it on turn it off we've got a
timer and we choose our time of day and
we initialize that and we have the
notion of being able to run it and
cancel it the one I'm interested in
though is this there is something I
would like to do I would like to turn
that on at one time of day and turn it
off at another time of day what goes in
the gap okay so here is a C style
approach the C style we is it has a
certain certain elegance to it in terms
of its brevity it is short it is very
sweet you have two functions that are
based on the task I would like to turn
this on I would like to turn this off
it's a very simple view of that level
and then we have yeah then it kind of
goes a little bit messy void pointers
okay so C++ is a statically typed
language and this works for an awful lot
of cases but when you really need to
sort of start getting general with
certain things start messing about with
the bytes then you need void pointers
the other reason that void pointers are
often used is generosity I don't confuse
that with generosity of template's but
it is that general-purpose this is that
how you get generics and see as it were
you tell the compiler in no uncertain
terms thanks for your help okay but I'll
take it from here trust me on this okay
that's what you're doing now obviously
it's a trust based game trust the
programmer is one of the the notions the
spirit of C that we we haven't C++ but
there is another aspect of this I mean
it is it's difficult to call that code
there and this code here pretty it's
quite ugly okay this is this is messy
you've got a lot of issues going on here
you've got a correlation as well and
this is one of the challenges is that
there is a as it were an unauthorized
correlation what I mean by that is that
the top the thing you pass in here or
the thing you pass in here are
correlated with one another but you've
just told the type system don't worry
about it the type of that depends on
what you'll serve when you're passing in
here you better agree now what is
missing here is this correlation now
when we look at this from an
object-oriented point of view we have a
name for a thing it's called an object
yeah the way these things are always
kind of together and we'd like them to
be together in a meaningful way that's a
thing so classic our solution is to use
the command pattern now this tends to be
so this will this will work as indeed
will the previous one but this has
required a certain expansion in the
amount of code we've introduced a
command we've got a pure virtual
function it effectively represents an
interface our timer is at least simple
so that so the we shifted the complexity
over to this stuff then you see the top
line represents a contract that's quite
straightforward it's this stuff where
we're getting the accidental complexity
the complexity we introduced to the
problem in solving it okay that's that
that's just the kind of the noise that's
the overhead you have to pay to get this
working and we've got things like the
heating pointer all kinds of other
things and then it'll do the right thing
so typesafe it is it is correct it it's
not as direct as it could be though so
if we return to procedural ISM but we
look at it from a modern C++ point of
view using either boost function or tr1
function or C++ CRX
there is a nice little function wrapper
it is the idea of saying well a function
we can use an object in a tactical sense
and it wraps it up it wraps it up it
contains the polymorphism and which we
talked about in the next section and now
I've actually got everything wrapped up
there it's it's quite nice because this
is the only bit of code I'm actually
showing where it's it actually shows you
how it executes or is set up so we've
got a timer I'm gonna turn it on here's
when it goes on we're gonna bind the
operation to turn it on against system
we're going to turn it off when it goes
off we're gonna buy in the off operation
with the system and then we're gonna say
run and that's it so there's a certain
directness this is still procedural code
okay that we have not introduced we are
using objects in a relatively tactical
sense but the the overriding style is
that of procedural ISM but it's done in
the style that fits what we're working
with now
object-oriented styles then again this
is where the plural really matters
there's quite a few procedural stars but
the plural really matters when it comes
to object orientation when people talk
about the object-oriented style versus
the procedural style or the
object-oriented paradigm versus the
procedural paradigm that glosses over a
remarkable number of differences of
perception with object-oriented
programming there are some elements that
are common to lots of different object
models you are partitioning the
development and indeed the runtime into
units and the development is partitioned
into classes characteristically that's
the typical one that's the paradigm of
object-oriented programming another use
of the word paradigm example yeah yeah
not a good word to use this is the
common example there are other object
models that don't use classes its
runtime logic so you have this notion of
characterizing objects in terms of
identity state and behavior for
different objects these way up in
different ways so some objects are
stateless some objects the identity is
irrelevant in other objects the behavior
is trivial but the state matters there's
this kind of shift and interplay between
these three aspects so you have this
kind of structure the what the kind of
formal way of characterizing it's not we
seen as the rule of
or that come the three things that three
columns of object-orientation
capsulation polymorphism inheritance but
if you want to be a little more precise
its runtime polymorphism and it's a form
polymorphism that is called inclusion
polymorphism there are three other types
of polymorphism parametric coercion and
overload based polymorphism C++ does
have the benefit of supporting all four
of these it's one of the few languages
to do so so if we're looking at paradigm
meaning programming features or
mechanisms then actually it's quite rich
in this respect but as I say this is
only scratching the surface here are
some sort of space of diversity you've
got the statically typed school and
you've got the dynamically typed school
when you try and get these people
talking to each other they have very
little to say except abuse okay there is
there are the experience of programming
in small talk the experience of
programming in Ruby is fundamentally
different to the experience of
programming in C++ these are very
different so people would struggle to
recognize these as being the same kind
of object-oriented thinking although
people push this a lot 15 years ago oh
yeah a small talk and C++ and object of
C and there are a number of other
languages that were popping around the
notion is that they are actually really
rather different they share some common
elements but it's like you know COBOL
and Fortran they're both procedural and
they're from the 1960s well they must
share a lot in common well yeah
IBM yeah that's about it they are very
different in their outlook so in
statically type models inheritance is
normally used in the main reason one of
the main reasons you use inheritance is
to introduce polymorphism in dynamically
typed languages you don't need it for
that the only reason use inheritance is
for sub classing as opposed to subtyping
it's a very strong distinction in
statically typed languages and there may
or may not be support for reflection
this is something that C++ misses it
eliminates a whole class of things that
you can do but of course we have support
for other things that we can do but it
does it does characterize that the fact
that this object orientation is kind of
different to that object orientation in
very
fundamental ways there's object based
programming object-based is often
referred to in terms of just being kind
of encapsulation or classic ADT the only
kind of polymorphism you're really
thinking about is a link time or compile
time polymorphism it's there's no
there's no real sense that you're
dealing with run time substitution of
anything that's that's not really the
game inheritance is not a player in this
space C++ has decent support for that
and then we have things like prototype
based approaches which I guess these
days characterized in it what can be
seen things like JavaScript there is no
real concept of class again that's an
object model but not one that is
supported out of the box in C++ and if
you do try and support it it looks a bit
strange people look at you funny for
doing it so we have a number of things
you have the data privacy concept that
C++ we have a private keyword but it's
not as private as you'd like it to be we
have to recognize that there are
techniques for decoupling C++ code
further but coupling is one of the
dominant forces that will shape or
hinder a large system in this style but
that that does have an influence we are
missing a number of dynamic facilities
in the language which is a pain in the
backside to be honest the fact that
there's no reflection and there's going
to be no reflection in a standard way
does limit certain options but again the
presence of virtual functions and
standardized function adaptors is very
useful for a number of other things an
object based program very well supported
indeed the non inheritance view why
would this be useful classically value
based programming is the area where this
takes off this is a sort of a this is
again in the object-oriented family well
it blends nicely into the generic
programming fetch family we'll look at
in a moment
now object lifecycle management tends to
be the challenge that people have and
sometimes people look at the world again
in black and white and this side versus
that side and it's all about GC versus
explicit many memory management that's
not necessarily the right way to look at
it there are four fundamental ways of
organizing lifetimes explicit management
you choose when you get rid of an object
and you do so explicitly I would like it
at this point in the code here and that
is decoupled from the point of which it
is created okay it just has to come
after it before doesn't work and twice
definitely doesn't work and Nevers a bad
idea as well
okay these are these are classic failure
modes scope bound this is the simplest
of all the models it is automatic so non
manual it is deterministic like explicit
but it is deterministic you scope the
life of an object within the life of
another thing that thing may be a
bounded scope of function scope or it
may be the scope as it were the life
time of another object my gut instinct
is if you can organize as much of your
code as possible using number two that
eliminates a large class of hassle that
people encounter but if you are used to
creating your objects dynamically and
then and that is your favored style then
you will find yourself dealing with the
problems of number one it's not that you
can't do it it's just sometimes a bit
challenging if you make everything a
pointer that needs to be managed with a
delete then we have reference counted
now why don't you are kind of supported
out of the box with C++ the third one is
a library edition this is something that
you have to do yourself or you get from
the box shared pointer so it's not
supported out of the box there are
limitations to it more becoming apparent
over time I think it is a very effective
technique for the problems that it
solves but I find people sometimes
trying to solve too much with it there
are performance costs to this there are
architectural cost to it it's a
relatively intrusive approach and the
there is a certain fear sometimes of
smart point of madness and they're not
always smart there's that there is a
kind of like yeah just use it because
you're not sure about something use a
smart pointer to do this however that is
something that we can support within the
language and it does have applicability
it can be effective and then we have
garbage collected now this one's outside
the realm of standard C++ and there's a
lot of discussion and debate about how
best to support it
garbage collection these days is not the
same as garbage collection was 20 years
ago 40 years ago as
we moved to increasingly concurrent
models of programming incremental as
opposed to stop the world garbage
collectors have a big win for certain
kinds of architecture and this is a be
ashamed we're not able to support this
in a standard way now let's have a look
at some of the styles within this broad
family of styles inheritance based
approaches inheritance based thinking
this is where many people are first
introduced to object orientation and
where they first get to grips with
having gone beyond the basic class their
object based approach in C++ they are
then introduced to inheritance now there
is a certain syntactic overhead to doing
this the default that you expect is not
the default that you get but the once
you've got you've got your head round :
public and here's the thing I'm
inheriting from the normal emphasis is
on being able to compose with respect to
code the idea of organizing
classification as being a way of
organizing the commonality of your code
to avoid duplication to avoid the joy of
copy and paste and maybe reduce your
macro count a little bit you know that's
that's that's these are all the ideas
that this supports so there is a case
here for inheritance based programming
you end up with kind of style and
approach kind of like this you end up
with a at least with discipline juice
you can end up with a kind of class
hierarchy where you support
infrastructure basic facilities you
build on its services then you have your
problem to main your application space
and you kind of compose it at this level
so it's a composition technique for
dealing with code primarily but I would
actually say that this whole approach
even though it's the one that people are
often taught it is the one that was
touted I'll reuse and all the rest of it
there's there really is no such thing as
reuse the way that people describe it
reuses an accidental property of
anything it's difficult to plan for it
what most people mean when they talk
about reuse is use so it's a far less
attractive and exciting term when you
when you use a library you are using it
for what it was intended for normally
you are not reusing it unless you're
doing something really crazy with it
so so in that sense reuse in the real
world is about repurposing things I can
reuse these seats here and rearrange
them to form a bed not a very
comfortable bed but I can do that that's
not their primary use I am reusing them
outside their original domain of
applicability what we have here is the
notion of what people are trying to do
when they talk about reuse is create
commodity which is a very different
thing so tomorrow I will fly back to the
UK I will not reuse the plane I will
just use it for the purpose it was
intended there's nothing fancy or
exciting about that so this is the kind
of the attraction that people have often
ended up with and if he's a very
intrusive approach it is sometimes based
on coincidental opportunities but it
does introduce a very strong form of
coupling and in C++ that coupling is
amplified through the fact that it
involves the source code structure so we
need to be keenly aware of that but
regardless of that there is this kind of
inheritance based approach or
inheritance first approach has fallen
strongly out of favor in terms of
interface based programming interface
based programming which we could look at
from the other side as being part and
parcel of component based programming is
where we focus and we make a strict
separation of the way you use something
the usage type the interface to it from
the way that it is built and implemented
the underlying concrete class or
creation type that we make a strict
separation not just a kind of a well we
put some of the implementation details
down in the hierarchy now a really
strict separation the we can do this
relatively easily in C++ this is not a
problem there has been a growing trend
towards using flatter class hierarchies
that are wholly abstract at the top
moving away from the style where we try
and accumulate implementation it turns
out that the challenge is not to write
code challenges to organize code and
this offers is a more meaningful way of
working with things you end up the
equivalent code and actually these two
these two diagrams are taken from a
couple of real projects
before and after we took inheritance
paste code that was tightly coupled that
was difficult to test and we teased it
apart retaining the broad layering
structure but making a strict separation
between the concept of the thing that we
were dealing with and the realization
possibilities the amount of executable
code remains the same it's conserved the
amount of declarative code does go up a
little bit you have more constructs but
the amount of stuff actually doing stuff
remains consistent this is far more
extensible it also emphasizes something
different if you go back to this one
there's an intentional as an in to
intentional points to the titles this is
infrastructure plus services plus domain
this is domain time services times
infrastructure this is domain centered
from the point of view of people who are
working with the application this is
what they see they are not they don't
have the weight of the infrastructure
pushing down on them and having seen
developers struggling with the fact that
getting all these arbitrary dependencies
through struggling to deal with those
from a testing point of view this makes
a difference they want to see
application concepts and to have their
code integrated more plug-in style
that's one of the things that interface
based approaches support very nicely the
other notion is the freedom of
combination the flexibility the degrees
of freedom this is a plug-in based
approach you're not hardwiring
assumptions inheritance is a very strong
relationship this is about composition
it's not that nobody thought the
composition would be a good idea it's
just that this style of program
naturally programming naturally
encourages it we can actually see
there's a spectrum I don't want to don't
want to suggest these are two mutually
exclusive approaches there is a spectrum
from the inheritance or sub classing
based approach to a more subtyping a
interface based approach general
thinking moves this way but we do have
some challenges these are these are the
benefits and peril development and
testing component deployment plug-in
style and so but it shouldn't make a
difference but does the lack of a
specific construct in C++ for doing this
means a lot of people miss it a lot of
people miss it as an opportunity
it requires more ritual and ceremony as
well as adherence to a an idiomatic
style if I'm working in c-sharp or Java
I just go interface whatever open curly
things like care about with semicolons I
don't have to worry about putting
abstract or anything like that in close
curly and we are done in C++ there was a
certain ritual and ceremony that I have
to go through it's still called class
then I have to argue with my colleagues
over whether or not I'm going to put an
eye in front of it I must admit I've
never been particularly fond of this
approach because it makes everything
bunch up in the wrong place of the
alphabet you know I came I saw I
conquered no this is not interesting to
us okay and that that I don't find a
particularly effective style even worse
is where you see companies where they've
got eye such-and-such and then you look
at it and say yeah but it's got
implementation code in it oh yeah it
started out an interface but we couldn't
change the name yeah this is a piece of
code that is lying to you it's a
convention that is not as useful as
people think it is
however once I've got past that argument
then I go open curly public virtual okay
I'm okay with the virtual better that
equals 0 so we curl on Oh what are we
gonna do with the destructor yeah we do
we make that that's that's gonna be pure
virtual or not or by start to provide a
definition I can make it protected if I
don't want people to there's lots of
little fascinating decisions we can go
through that means there's a little bit
of accidental complexity there I've not
found it to be a problem personally but
I do recognize that it is a problem for
many people a lot of people just don't
get it they don't adhere to the
convention they don't understand what
the implications are in the long term of
actually keeping to the style because
you're actually telling people to not
write code people are paid to write code
so they feel a little bit uncomfortable
maybe I could put a little helpful
default stuff in there you know I'll be
just helpful programs are terribly
helpful to people but this is actually a
disadvantage if you've got helpful stuff
put it the next layer down keep the top
clean there are very good reasons for
doing this and there are a number of
techniques that buffer and allow you to
change the elements of the hierarchy and
maintain that crisp idea of that is just
the way you're programmed to it what is
interesting is that in spite of the fact
that people do struggle with this in C++
when they do it returns out to be very
effective a team that I've consulted for
many years told me that this was one of
the most useful no this was the most
useful thing I ever told them the
possible implication of that is that
nothing else I told them was of any use
at all that's fine you know getting one
hit is good at least so but the notion
here is that there is a style that we
are potentially overlooking we also have
this notion of a lack of proper modules
the the other side of the interface the
actually having a formal unit of
composition for the implementation code
and making a very clear notion about
that naming it having a concept of
dynamic loading that is portable doesn't
mean we can't do it it does mean that we
have to be careful when we support
different platforms shared objects on
linux dll's or microsoft windows very
different semantics between these but
nonetheless there are possibilities here
but they are largely overlooked because
it doesn't look like you're doing much
that makes people feel uncomfortable
value based programming I indicated
before is one of these areas that C++
does have very good support for the idea
of now again this is not a single
all-encompassing idea this is just a
category of dealing with objects and
they are well represented in C++ the
idea of values is that they are
fine-grained objects that are strongly
informational their identity is of very
little interest and they typically
reflect odd objects in the real world
that have these properties money dates
and so on depending on your domain these
have these are either values or entities
of interest but there are particular
styles here you don't really worry about
dynamic memory these are things that you
can copy around quite freely and
therefore copying transparency can be
useful passing by constant reference all
of these things this is relatively well
understood even if people don't describe
it in these terms the next standard will
provide better opportunities for
optimizing this kind of code being able
to move values relevant when we're
dealing with value objects that do
internally manage their own memory
allocation it just gets rid of a little
bit of potential waste when you end up
with all of these spare copies floating
around
uh however some of the details appear to
be quite subtle and I am dreading I'm
dreading the prospect of actually having
to teach some of this stuff that's going
to come up in the next zone this is kind
of a little bit expert friendly it is
powerful if you know what you want from
it you can do an awful lot with it but I
am a little bit concerned at this point
we that what the accidental complexity
is I don't have enough experience with
it to really comment but it does seem
interesting that most people focusing on
our people are regard as C++ experts so
general object-oriented issues not
everything fits this worldview okay
that's acceptable some of that comes
about because C++ does not necessarily
have a unified type system that in some
some languages there is a unification of
the idea of an object and a function and
there is no contradiction seen between
these two we can do this through
adaptation and C++ but it requires
adaptation as opposed to being out of
the box but once you've got it up and
running and once it becomes a culture of
a particular project then it can be very
effective but the other aspect is to be
keenly aware that C++ is one of many
possible worlds this is the kind of the
many worlds theory of objects if you
like now final family of stars well
they're not really family it's two
different styles that I'm going to look
at that are actually unified just
because of the mechanism that we use to
express them in C++ it's more
coincidence than anything else there is
no such thing as a template paradigm
though there is no such thing it is a
language mechanism that can be used for
good for evil for obfuscation for
clarity whatever so let's have a look
generic programming is the one the the
name is unfortunate and this has been
recognized by Alex step and often others
that generic programming is not really
the right term because it makes it sound
like it's generics this is a style that
is focused on algorithms it is a style
that is general in the in its outlook
that is the emphasis in C++ we tend to
build on compile time polymorphism and
value based programming in other words
templates overloading and conversions
copying an encapsulated memory
management these are all the key
features here as a style well I'm going
to just get
like we're getting close to the end it's
got a lot going for it but I would say
that it seems to be one I've not seen
any applications that have this as their
dominant structuring principle and I'm
talking about significant large-scale
applications I'm happy to see some but
most of the time I see this it tends to
be a tactical approach the we have some
interesting stuff coming up in C++ as
Xerox concepts and I believe Doug Gregor
has already given a talk here at some
point in the past on that so again I'm
going to skip that let's just have a
little little look at a nice simple
fragment and then wrap up the this is an
example based on some code from tier one
random number generators certain
elements of style if you're using lots
of templates remember type def is your
friend often overlooked this notion of
loop free programming the idea of being
able to compose in one place something
as I said reminiscent of functional
programming here being able to compose
in one place something that is centered
around an algorithm of some kind and
uses objects at best in a tactical
fashion the dominant idea here is the
thing you want to do okay
now mixing styles I kind of skip that I
want to kind of briefly talk about
template metaprogramming anybody come
across that lots of angle brackets kind
of scary Wow look at that that's
fantastic okay the challenge here is
that C++ doesn't really support meta
programming in the general sense it only
supports a particular compile time
approach they can be used for some very
very useful things some really keen
observations so optimizations but what I
would like to emphasize here is that it
it's a domain of applicability is not
for every programmer it is not the kind
of thing you'd use like an if it's not
the kind of tool that you saw say yeah I
use that every day if you do you have to
be doing either really knowing what you
really know what you're doing or not in
this case you can spot the template
metaprogramming code can't you it's this
stuff over here I do urge you to look at
your code by doing this technique of
zooming right out and reducing the point
size to something little we people do it
with helicopters and they find the
lines of ancient fields still in the
ground from thousands of years ago you
can do this with code and see
characteristics from the air that's the
template metaprogramming this is a piece
of code that turned it to this piece of
code there's no template metaprogramming
here that's just overloading a couple of
objects that's it and the notion here is
that this was unnecessarily complex for
the problems it is easy to get blinded
by the light so I'm done from that point
of view I think we may have time for a
couple of quick questions
there are no questions it was all
entirely clear you understood everything
I said nothing was contentious all right
I believe that for a second okay let's
get back to this mixing Jericho now it
starts come on surely there must be
something here this shouldn't be
difficult because we're dealing with two
orthogonal forms of polymorphism that's
the theory the practice unfortunately is
they really don't get on in practice we
have to write layers of adaptation this
is annoying you cannot have virtual
template functions this is very annoying
so in theory although in principle they
are actually independent they do not mix
either they stay independent that is
quite a struggle people often write
articles and bits of libraries indeed
one of my contributions to the boost
library he's a type that messes around
with your idea of polymorphous of this
come well you know it's a value of any
kind but yes well let's move that around
there are a number of techniques there
that function wrapper I showed you
earlier on is another one I invite you
to look at the implementation and see
how you feel afterwards it's pretty
smart but again if that's what it takes
to mix you have to be very careful so it
can be challenging in practice I found
you can actually do this but you end up
with a layering and you reduce the
amount of adaptation but you end up with
the layering I have found that objects
in the large and generics and the small
that works very very nicely for me if I
use standard dependency management
techniques kind of like us and Robert
Martin type stuff then I find that I
have I create myself a useful space
where the generic programming just flows
very nicely but there's a strict
separation and there is this kind of
layering okay is that contentious or do
you agree with that as well
oh come on kill me give me a question
okay not here can I can I give an
example of where I think template
metaprogramming is a good idea it's
difficult to know whether I'm addressing
solution problems or not one of the
areas where we do find this to be useful
is in selecting types and organizing
types for what well for smart pointers
for example in other words if I want to
get a smart pointer and I would like it
to have re-exports and capabilities
based on its type the parameterised type
that I give it then there's no way to do
that without having a compile time if
and that compile time if is going to
come in the form of template
metaprogramming I found that when I have
used this actually I lied a little bit
actually there is a little bit of
template metaprogramming here I can't
remember exactly where it is but that's
the point it's very discreet I've used
it to select between two types basic
traits style selection so it's very
modest usage it's a light sprinkling the
other area but I don't have personal
experience in this one in a practical
project other than personal toy projects
is where you are using this too as it
were select an option that you don't
want to take at runtime but you'd rather
take a compile time and always generate
a constant of some kind and you'd rather
not have to either pull up windows
calculator and calculate manually and
hard code it or have the cost of running
it at compile time again some of these
features are actually being some of the
issues I've just described are actually
being addressed in the next C++ standard
so you won't necessarily need template
metaprogramming SCORM always like a
bridging a solution in that sense
okay right thank you very much for your
time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>