<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mercurial Project | Coder Coacher - Coaching Coders</title><meta content="Mercurial Project - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mercurial Project</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1sV8Z_Lmpt4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Curiel revision control systems Sam
slides for the moment but stainless
slides and by brian's iron mission he
builds large distributed stuff not large
by her standards not large by our
standards though and i just wanted to
let you know that this talk is gonna go
up on google video so if you have any
questions that you think might contain
information that's particularly googly
let's hold those until the end after the
cameras off okay okay thank you leslie
let me see what a good distance is here
alright so about 12 months ago I was
casting about for a revision control
system that I could use to write the
next late great desktop email system
that nobody was going to use and
unfortunately during my passing around
the place I found that there was nothing
entirely suitable to my needs so I found
a piece of software that was almost
suitable which had just gotten started
on by that guy that I happened to know
and this was a tool called mercurial and
the origins of mercurial are steeped in
the great bitkeeper debacle of 2005 when
Larry mcvoy took his marbles and left
the playground so at that time Lena
starballs was left without a revision
control system and started writing his
own at the same time Matt McCall started
working on a revision control system and
I converged on fairly similar designs
although in substantially different ways
and so now the world has to 14 month old
revision control systems instead of one
to join a field of a huge pile of free
revision control systems already so why
am I actually interested in this
particular one why am I am here to talk
to you about this well there's a couple
of different reasons that it's a
interesting to me here and one is that
mercurial kind of matches a few aspects
of the Google state religion as I
understand it from the outside and those
are that it's written in Python it is
distributed and it does things very fast
so these are kind of nice properties to
have now it's not completely Python it's
only ninety five percent Python there's
a couple of core routines that are
written in C but what we've gotten in
the in the 12 months or so since people
have started actually using this stuff
is a fair number of third-party people
both open source and commercial projects
have actually started using it which is
really kind of an interesting vote of
confidence right normally revision
control holds the crown jewels of
whatever it is that you're doing so it
had by God better work properly or else
you're going to have serious problems
but in that time we've had a couple of
interesting people start to use
mercurial we have the Zen source people
those are doing the open source Linux
hypervisor we have the One Laptop Per
child project the opensolaris project
the moin-moin wiki and a pile of other
people who are playing around to the to
various different accidents some of them
large some of them small but it's pretty
fun to be working on something that's
young and yet has interesting and active
users already so from a direct
developer's point of view right you're
you're sitting down in front of your
computer and you're about to start your
magnum opus you're going to work on the
next great novel or the next break huge
source base or whatever it's going to be
you're looking for criteria to choose
one of these rigid control systems
there's got to be at least 50 of them
extant at the moment thanks Chuck so
what're what are some criteria well I
can tell you what I used at least from
my own personal purposes which was I
wanted something that was
straightforward to understand so I was
going to be able to spend my time
thinking about my problem instead of my
revision control problem I wanted
something that was pretty quick so that
my tea would still be warm when I was
finished a particular revision control
operation and I wanted something that
would help me to work efficiently with
other people that being kind of a
motivating factor oh you want to get
this onto a windows box I think we're
going to exploit less it'll work yeah
it'll work ok so the mercurial revision
control system has a conceptual model
that's very simple I've had it described
to me as you can carry it around in your
head and I like to think of it that way
myself there are basically three
different things that you need to pay
attention to if you're thinking about
revision control in mercurial and in
many other distributed revision control
systems the first is that you have a
repository which is where your stuff
lives the second is you have a working
directory which is where the stuff
you're
working on lives and the last one is a
change set which is a snapshot of what's
going on so in mercurial terms a
repository is not a heavyweight thing it
does not have a database behind it it's
just a pile of files so these are things
that are easy to create they're easy to
administer you put put one together and
blow it away in a matter of moments and
that's how people prefer to work they
are as i mentioned lightweight and they
are pretty much everywhere everywhere
that you happen to be doing some work in
a working directory there's a repository
that happens to be wedded to it so
inside a repository there are only
really three different things there's a
change log which says I've done this
work there's a manifest that says I did
the work on these versions of these
files and then there's the file metadata
that's all you need to know to
understand the underpinnings of the
revision control software it's very very
straightforward now you contrast that
model with the internals of a more
traditional large-scale or revision
control system like clear case or
perforce or something like that and if
the internals are visible to you at all
there's typically not there going to be
a big pile of different things the
mercurial source code is I think it
might have grown to almost 12,000 lines
now but it's a fully functional system
and it's twelve thousand lines of Python
so you can keep all of it in your head
as a developer you can keep all that you
need to know in your head as a user it's
got a couple of very good properties in
that respect now a change set as I
mentioned a snapshot of your project as
it stands at a particular point in time
it corresponds to a revision and
perforce or subversion or any of these
other tools and the terminology that we
use for creating a change set is
committing it now unfortunately I have
some pretty graphics here that you're
not able to see at the moment about how
you go about creating these things and
what starts being interesting then is
how you go about merging and branching
with people so I'll have to hand wave
since i have no graphics to offer here
when two people work they will create
clones of each other as repositories yes
a whiteboard would actually help ya when
I start working I create a repository
and it's just a little directory called
hg someone and outside that repository
is the actual directory let's say I'm
working on a project called foo so I
have food / Don hg that's where all my
metadata lives I don't need to actually
care about anything that's in there the
working directory where I have my files
like copying and you know rhenium food
see lives around this dot HD directory
that's where I do all my actual work so
somebody else will make a clone of this
and they'll have an identical copy of
the working directory and they'll have
an identical copy of the hg directory
and they start working there and they
start creating a revision and let's say
they create a revision 1 and I create
something like all the revision 12
because I don't know about their changes
because this is a distributed system
right so we go on we create revision to
say as well now the next thing that we
need to do here is we need to be able to
communicate with each other to say we're
working on the same project and now we
have divergent views of the world how do
we caused them to reconvert what what I
do is I pull my changes from one
repository into the other and that
literally means I just take the directed
i set a cyclic graph that is all of my
revisions and I a lot of them in here
and after I do a pool I do emerge and
what the merge does is it just creates a
structure in the working directory
search that I have my revision 1 your
revision 1 my revision to your revision
2 and then in the working directory the
working directory has a notion of there
being parents so you can think of the
directory is a floating revision it's
the last stuff that I had the merger of
these two guys and the stuff that I'm
about to commit as the result of the
merge so the working directory gets all
these things i do my commit I'm done and
that's all there is to it so a branch in
mercurial is just a revision that has
two different parents now I haven't
actually drawn branch here okay look
here's a branch this is a this is a
revision that has two children and this
being emerged is a revision that has two
parents and that's all emerges so
there's no there's no special sauce
there if you if you think of a branch in
subversion as being something very
simple as just a copy the analog in
material is also it's very simple it's
just two revisions that happen to have
the same parent and of course you can
have an arbitrary number of branches we
only allow merge as one of the time
because nobody's really found a good way
to explain multi-leg merge two people on
their heads explode that's exploding
lots of good
so when people work in parallel and they
make these changes and they commit them
and then they merge after they change
that's kind of a nice property path
because if you think back to what you
used to have to do in the days of CBS
history was linear people will do a
change they do a change they do a change
and if you wondered commit race before I
managed to make a commit I had to merge
with your changes before I could do a
commit and that meant that there was no
permanent record of my changes now with
this model you don't end up having that
kind of risk with CBS it was very
straightforward to shoot yourself in the
foot by screwing up a marriage it
happened all the time you would see
changes that got checked in with
conflict markers badness ensued
subversion sort of avoids this but the
default policy is to work the same way
that CBS does in subversion you have to
explicitly choose to work on a separate
branches the same thing with perforce
the distributed tools necessarily don't
work that way and it's a slightly safer
way to do things um because if one
default policy is less safe than the
other in practice I don't know that it
makes a huge difference you don't hear
people saying but I you know threw away
three weeks of work in subversion or in
perforce or in any of these other tools
very frequently so with many of these
things what you get is a matter of
degree in terms of loss or gain of
functionality how are we okay a couple
of things that are that are interesting
to know about mercurial for getting
going and keeping going quickly if
you're working in a small lightweight
environment it's useful to have for
example a built-in web server which we
have so this is a web server that you
can both interact with as a person and
view revisions in your tree and annotate
things and download troubles but it's
also what mercurial uses to to fetch
data and to very soon now push data over
the network as well it also works over
ssh if you happen to prefer security in
addition mercurial has a essentially a
single way to stream bytes onto the disk
and to stream them off the disk we call
that abstraction a bundle so you can put
bundles onto USB drives or you can send
them around an email and you get a
complete set of change history that you
can transfer without having to be online
at the time this is kind of a useful
property to have four people doing
distributed development
so sharing is also a political
asymmetric operation in other words when
I make a clone of a repository and I
start making changes and I push my
changes back to the parent repository I
don't know where this buzzing is coming
from i end up with both repositories
being identical afterwards okay the buzz
has stopped I can step back and look at
my slides again so the final thing and
the thing that is sort of the special
sauce in mercurial is that mercurial is
i'll be at written in python an
extremely fast system and we've
benchmarked it in the various different
scenarios and there are only a few other
revision control systems that compare in
terms of performance now performance is
interesting in its own right because it
means that you don't get distracted
while you're waiting for the tool to do
things but it also enables you to do
certain kinds of operations that are not
necessarily otherwise possible so in
order to to give a little bit of an
apples-to-apples comparison the other
day I went to the the subversion
self-hosting repository where they've
had subversion developed for the past
four or five years and I just did a
subversion check out of the subversion
source tree and at the head of the
source tree has a working directories
about 72 megabytes in size so out of
curiosity I sucked all of the subversion
history into mercurial and created a
local mercurial repository that's an
identical copy of what's on the
subversion website and it turns out that
the mercurial repository plus working
directory is about the same size as the
subversion working copy so I have 15,000
revisions and a working director
in 76 megabytes versus just a working
copy in 72 megabytes which I thought was
kind of interesting it means that you
don't have to pay much in order to get a
complete history of everything onto your
machine where you're no longer talking
to the network one of the things that
you've probably noticed if you've been
dealing with the perforce servers here
is that things take an awfully long time
once your servers are busy central
servers don't scale terribly well you
prefer not to talk to them if you don't
have to in a distributed tool you tend
to not talk to them very often at all
maybe a couple of times a week and so
also out of curiosity I ran a couple of
very simple performance tests now the
subversion repository is very small it's
only about 1,200 files and it's only
about that the actual working copy when
you ignore all the svn directories and
so on it's only 25 megabytes in size and
pound for pound mercurial and subversion
worked out about the same there were a
few instances where one was faster in a
few instances where the other one was
faster but what's interesting about one
being faster or the other being faster
on a small test case is primarily that
you can write something in Python and
have it be as fast as something that's
written in pure see if you're clever
about how you do it and I assert without
immediate proof that in fact mercurial
will scale to large projects better than
many revision control systems that are
written in C because of the underlying
obstructions that we use and the
implementation techniques might I add so
there are a couple of different things
that we that we do in order to make the
implementation go fast the primary one
is that we've desperately tried at every
step to avoid seeks disk seeks are not
your friend disk seeks are things that
cause you to just sit around and wait
for good things to happen good things
that happen our string i/o linearly off
your disk that's what we really like so
in order to stream io linearly off your
disk there are a couple
that you would like to be able to do the
first is he don't want to write more
than you have to and the second is that
you don't want to read more than you
have to so what what are the necessary
properties for a revision control
systems not write more than you have to
well it's been dogma in revision control
for a while that what you really want to
do is you want to store the most recent
revision of your file as the very first
thing on the disk and then everything
wants to be reversed Delta is based on
that because that means that you get the
nice property of something that you
accessed recently you can just read with
a single read now mercurial sort of
turns out a little bit on its head we do
forward Delta's from the very first
revision but that sounds like it's
terrible implementation plan it's
actually what would you say it's it's
rather better than that because what we
do is we have all of one retrieval
properties so instead of having a very
first revision and ten million little
tiny Delta's on top of that that you
have to reconstruct the final revision
out of what we do is we have two
different techniques one is that every
so often when the accumulated quantity
of stuff that you've dealt it gets to be
too big we store a full text so you pay
something of an extra space cast on disk
but you end up with one retrieval
properties the other thing that we do is
rather than applying each Delta as we go
we compose our deltas and then we just
apply one single Union Delta at the end
and that gets rid of some of the nasty
properties that you have when you're
composing deltas and lunging springs in
Python so these are two things that make
it quite fast and quite efficient to get
nice linear accesses another thing that
you can do that gives you linear
accesses at something of a costume space
is you might paint them if you're doing
a delta you want to do a delta against
your parent so if I'm at revision3 and I
have a child that is a revision 7 that
is really based on revision3 I want to
do a delta against provision 3 not
necessarily because if you're doing a
delta against provision three and you're
a revision
there might be a Sikh involved so what
if I provision seven you do a delta
against provision six and you don't
actually care whether revision six was
related to you all well in that case you
pay something of a greater space penalty
but you end up with a linear space are
pardoning a linear disk access and a
guaranteed lower probability of Sikhs so
again it's another case of make the
seats go away do linear stuff instead
even if it costs me slightly more space
even if it looks like it ought to be a
less good choice many times these are
not the case when you subject them to a
little bit of inspection right back to
my hints as to where I am the file
formats that we use are very
straightforward there are binary files
but they're easy to parse in Python and
the reason that they're easy to parse in
python is that we use the struct unpack
and Pat methods allow and we use spring
splitting an done splitting a lot and
the reason that these are good things to
use is that they don't go through the
Python interpreter at all they go
straight from the Python interpreter in
to see fast things occur you get dropped
back into Python land which also try and
avoid things like conditionals inner
inner loops because those tend to cost
in performance as well so if you look at
the mercurial inner loops they tend to
be quite tight they're still written in
Python but um they do very very simple
things and then they deal in terms of
tuples or arrays or whatever happens to
come out the other side whereas of luck
I can open the file but it doesn't it
doesn't show me any content you know you
have OpenOffice one I have OpenOffice
too I'm sorry okay continues to be a
mime show for the rest of the
presentation i'm afraid the final thing
that's kind of interesting about
implementation techniques is that i
mentioned avoiding reads well why read
it all if you can start what if you were
to store instead of just spewing your
finals at home to disk you also stores
the information as to what the the staff
of each file was when you wrote the file
now what do I mean by that I mean you
store the modification time the size and
the access time of each file and the own
and then when you're looking through a
tree to see what was the last thing that
happened to my tree instead of reading
the file you do a started to file you
look at the last time you start file you
see if they're different in any way and
then you do a read to see if you really
need to say yes this file has been
modified or no so what this means is in
a 40,000 file tree mercurial does stop
40,000 times but it doesn't read and
reconstruct each file 40 type or it
doesn't read and reconstruct 40,000
files again this is a significant space
wim compared to doing things by hand so
I've mentioned that things are fast yes
yes I things are not as faster from the
first this is true so the obvious place
that you can make things fast
overemphasis by using an implementation
technique like perforce where you have
to tell a server everything that you're
doing right that's potentially less
friendly thing to do like I was able to
live with p for headed back on i had to
use perforce but having to not do it and
being able to do things on the local
disk happens to suit me pretty well so
we turned this around so I can see
so speed is it's an end in itself all
other things being equal it's nice to
have something fast instead of something
slow but what speed also lets you do is
it lets you do things that are not
straight forward using other tools so
mercurial was originally developed by
colonel hackers and the colonel is our
reasonably large tree it's not super
large it's like 20,000 flowers or so but
one of the things that kernel developers
tend to have to do a lot is deal with
patches because there are certain
gatekeepers for four pieces of
subsystems and you may be developing
something that isn't ready to go off to
somebody else yet so you maintain a
pilot patches that your software has to
work with and working with patches is
traditionally kind of a painful thing
because revision control tools don't
normally have a concept of patches but
what if you did of a concept of patches
well mercurial has an extension called
mercurial queues if you've been working
with open source tools then that you
have to patch in order to get working
you may have come across a tool called
quilt and quilt basically lets you
maintain a pad a stack of patches on top
of a source tree it doesn't care what
source tree is it has no notion of there
being an underlying revision control
system of any kind so quilt has the nice
property that it will sit on top of
anything it doesn't matter whether it's
perforce CVS or unexploded tarble and
what what lets you do is it lets you
push a patch on to your stack edit some
files refresh the patch push another
patch on top of your stack refresh the
files etc etc etc you can pop and push
and work on the top of stack arbitrarily
mercurial queues works the same way but
it's integrated into mercurial so what
this means is after you've pushed a pile
of stuff patches onto your stack you can
now use the regular log commands or the
annotate command to find out which
revision that has turned into a change
set in the tree made a particular change
when you pop your patches the change
sets go away and once you're done you
can push the change sets off to somebody
else as regular
revisions and they see them as regular
mercurial revisions and then they start
distributing your changes and goodness
occurs but the nice thing about this is
that is the integrated nature of it so
for example if you're doing a bug search
one of the things that people started
using the past year or two with with
tools like given mercurial is a diatomic
search of your revision graph now what
that means is you're essentially doing a
by sectional search i know i have a
revision that was bad i know i have a
revision that was good and i want to
narrow my way down to the revision that
was the thing that caused the state to
flip as quickly as i can so if you can
do this using your revision control
tools rather than having to worry about
to join the boundary between where my
patches start and where my revisions and
if everything is just seamless and you
don't have to worry that's kind of a
benefit as an example of how well
mercurial cubes works and Andrew Morgan
maintains a pilot patches against the
linux kernel that is I think it's about
1500 patches at the moment and that are
just a single quilt patch series I can
apply those on top of a linux kernel
repository in I think something on the
order of three minutes so I can create
seven change sets per second for three
minutes to get all of these patches into
my tree and then as far as a mercurial
is concerned it's just a regular old
tree that I'm working in that has 1500
new revisions in there that I can deal
with that I can serve up but I can
communicate with other people but that I
can also modify after the fact by
popping editing Andrey pushing and then
i can continue to share those changes
with the quilt user because mercurial
queues is quilt compatible this is a
fairly tremendous win not just for
dealing with upstream software projects
but also for prototyping and developing
your own code quite often if I'm working
on a feature what I'll do is I won't
actually start committing changes
because I'm kind of an idiot I don't
tend to know where I'm going a lot of
the time well i'll start off and i'll go
down
dolly and then I'll go down and other
two blind alleys along the way and after
a couple of days I'll have converged on
something that looks like a solution but
along the way while I'll have done was I
left thought in terms of here is the
underpinnings of my work one patch here
is another thing that I need to have in
place another patch and each point when
I'm refactoring my code or I'm moving
something between one layer and another
there I just move honks from one patch
into another patch and I push and pop my
context at various different times to be
working on a different patch at each
point so this is um it's not just for
working with other people it's full it's
for collaborating with yourself as your
clue evolves over time very good
property to have so finally there are a
couple of things that are that are
interesting to me about distributed
revision control that are not specific
to mercurial but that might be an
interest to people who do things with
free software and open source tools in
general I have this this idea that
choosing a particular revision control
tool is actually making a statement
about how you want your project to
evolve right so if you work in a large
company and everybody has essentially a
living play level playing field
everybody is more or less likely to have
commit access to much the same stuff and
everybody can pull the same changes
everybody can push the same changes or
you know integrate changes or whatever
the particular tools language lets you
do but as in the open source world
that's really not the case right if
you're using a tool like CVS where
you're using a tool like subversion
there's a world of haves and there's a
world of have-nots there are the people
who have commit access to the one
central repository that everybody has to
use and then there are the people who
can maybe read from that repository they
can check out a working copy but they
can't commit and they may not be able to
earn the right to commit until they've
proven themselves over the course of a
number of patches that they've submitted
and how to maintain now if you've been
in the position of having to maintain a
patch against an upstream source tree
it's kind of a painful thing to have to
do tools like quilt will make it more
straightforward but really what you
would like to be able to do is work
with other people speaking the same
language using the same tools with a
distributed tool you can do that with a
centralized tool unless they're willing
to create a little sandbox that people
can go to wild in which wiki's history
and the history of other collaborative
Commons on the net have proven is not
necessarily a very scalable thing and
they can't do so you could think of it
as being analogously ascent of man right
in the days of our CS and SCC s
everybody crawled on all fours and they
had to be on the same machine in order
to get any work done and then suddenly
everybody's tails fell off and they
started going around and hunchbacks and
they were able to talk to the central
repository over the network but they had
to be on the network in order to get any
work done right if i unplug your
workstation from the perforce server
there is nothing you can do if i unplug
your workstation from a subversion
server you can run diff and nothing else
with the distributed tool that's no
longer the case i can work on the train
i can work on a mountaintop so long as I
have history and I can access my hard
disk I'm set so I can work anywhere I
can contribute with to any project I can
work with anybody with a distributed
tool the tools don't make the boundary
it's the BB social norms of your project
that you explicitly choose that make the
boundary you choose to model yourself
with is true with a distributed tool you
don't have it imposed on you by the
technology so I would encourage you to
give this stuff a try mercurial as I
said it lets you work as a centralized
system if that's what you prefer if you
want to work in a distributed fashion
you can and one of the reasons that
people have cited to me a few times
we're using centralized tools is that
they're afraid of forks so Guido works
here for example and he does not like
status Python at all titles python is
this project that started about eight
years ago that went off in a direction
that was fundamentally different to the
way that he wanted to bring Python
itself and
for example the GCC people have had the
same problem right EGC has forked off
from GCC many years ago and they
eventually managed to reconcile their
differences and start working together
but what's interesting about using a
tool that has good support for merging
and good support for branching is that
everybody Forks all the time right
forking is is just what you do and
merging is what you do when you're done
forking so once somebody has decided
that they want to play nice again and
they want to cooperate with you you just
merge whereas in a central tool what
somebody has had to do is they've had to
suck all the history out of your central
repository they've had to shove it all
back into another central repository if
you want to reconcile your differences
you've got a serious problem on your
hands all of a sudden because there is
no way to make me to communicate that's
just not the case with a distributed
tool so what would you say it makes it
makes it easier to reconcile your
differences a final couple of comments
that I have before we finish off and
there's a number of people who work on
subversion here at Google and I've been
very conscious along the way as I've
been what would you say trying to
Shepherd people into sending patches
into mercurial and so on of the great
job that the subversion people have done
in terms of building a good community
around their tool if you're working on
open source software the only thing that
you have going for you is a technical
merit and be credibility and Carl Fogle
and Jim Landy and Brian Fitzpatrick and
Ben Collins Sussman and Garrett Rooney
and all those other people who have
worked on subversion over a year the
years they've done a very good job of
making themselves accessible and making
the subversion community being a place
that is a good place to contribute to
write you send a patch in somebody's
going to review it and say yeah could
you tweak this you how could you tweak
that it's a nice property to have and
I've been very explicit in trying to
emulate their example as we've as we've
been building mercurial um because it's
always nice to try and learn from
somebody else's good examples rather
than to try and blaze a trail of your
own and that's I think stood us in good
stead I actually run a sir
of our users a couple of months ago just
to get a sense of where people thought
we were you know it's very easy when
you're a developer to stay down in the
trenches and look at the next line of
code that you need to write or look at
the next patch that you need to issue or
the next bug that you need to fix but
it's nice to get a sense of what your
users think about you and people have
been pretty complimentary about us
people were also quite happy with the
software in terms of the fact that it's
easy to install easy to use not too
different from tools like CVS and
subversion and it's it's been very
rewarding to actually be able to talk to
people and say look here's this nice
shiny toy that we have that you can that
you can use for something be it small or
be at large it'll scale and work for you
across all of these different slices of
thing doc kinda comes to the end of my
prepared comments thanks very much for
bearing with me as I had to essentially
hand wave my way through and I'd be
helping to take any questions people
and I off from them and I met
changes
very hot yeah when I merge back to
what other cost of marking the same
scale
is it me
I've already had so the question is
what's the what's the sort of
computational cost of emerge climbing
one person does a large amount of work
and another person does a small amount
of work and the answer is that there is
not very much cost to it so bringing in
changes from the outside is essentially
a linear operation and a number of
changes that you've made so cloning a
repository all 20,000 provisions are
just pulling in to changes they have
approximately linear costs so one costs
about 10,000 times as much as the other
so if you've done 10,000 things and I've
done two and I pulling your 10,000
things it takes me about you know 10,000
units of time to process those changes
the actual merge afterwards is primarily
a matter of updating the working
directory most of your changes are not
going to conflict with most of my
changes and then what happens with the
few conflicts that there are is really
it's almost not a matter for mercurial
itself we have a couple of different
merge strategies that people can use
when there are conflicts
yes yes you can you tell the original
common ancestor yes you can sorry if I'm
repeating your questions but I'm just
trying to make sure it'll be on folks
back home can hear what we say yes thank
yourself why wouldn't you just call the
repository and actually use the real
material so the the question was about
using a set of patches for doing
development of your own stuff rather
than using regular mercurial tools in
order to capture all the history and
what would you say that's it's partly a
style thing and it's it's partly a in
wanting to not clutter the history thing
so you may have heard me allude to the
fact that I will go down blind alleys
well I don't necessarily want my idiocy
call them the permanent record if I can
necessarily avoid it right so it's it's
nice for example particularly if you're
dealing with an environment like the
Linux kernel where there is it quite a
high standard through your changes to
meet in order for them to get in you
really want things to be packaged
cleanly that's one environment where it
makes sense to think in terms of patches
because you want to submit the pristine
final thing not the 45 different idiot
things that use it along the way for my
own purposes as well it helps me to
think in terms of patches because then
I'm both I hope you say I'm putting
layers on my thought I'm linearizing my
fault in in space and in time right in
so each patch captures a layer that I'm
worrying about i can actually revision
control the patches themselves so i do
capture the history of the changes but
just not in the actual repository that
they're eventually going to end up in
but i also have the ability to go back
into erase history and make myself look
better which is very nice yeah
cavalry Packard's that involve me
what question is how well mercurial
handles refactoring that handles renames
and moving code around so there are
there are three answers to that one is
that it doesn't the second is that it
does it really well and the third is
that it will be really older soon and
these are all true at the same time so
right now mercurial has a shell script
the handles merging so it knows how to
figure out that the basis for doing a
three-way merge for example and it will
handles off to the shell script now we
have a couple of different shell scripts
in place one is a shell script that will
run a three way marriage tool what
three-way merge is not very satisfying
when you're doing distributed
development because some frequently have
cases where there are crisscrossed
merges right I pulled your changes at
the same time that you pulled my changes
and we both commit the results of our
mergers we end up at a state where we
have to merge again that can iterate a
few times in those kinds of cases you
would really like to have some sort of
more history sensitive merge that will
cause cause us to converge more quickly
there is a branch of mercurial that has
that facility available in terms of
handling renaming though right now we
track rename information and that McCall
who is the guy who wrote much of the
mercurial code originally started the
project is working on actually having
your changes follow across renamed and
by the way that the question that is
sort of implicit there is if I make an
edit to a file and you've renamed the
file to a different name you really want
the changes to show up under the
different name after we've resolved our
differences so that's not there yet but
the actual machinery underlying it
that's necessary is there and the future
will be present soon sorry I'll give
somebody else a chance for
what platforms are supported pretty much
anything the Python runs are and has a
file system behind it that looks vaguely
UNIX it so windows you name the brand of
UNIX and Max and so on yeah the shell
scripts work of windows by being want to
stop that class of course they're not
actual shell scripts there there dot bat
files but nevertheless they were yes yes
forgive the poor though Hartnell cloning
cacao bring over whatever Marshall
McGreevy do we support partially
bringing stuff over somebody is working
on that at the moment and there are two
different kinds of partially partially
bringing stuff over right one as you
want maybe only the last two thousand
revisions of your project history
because you don't want to be carrying
around the empty of gigabytes of earlier
stuff that was done ten years ago and
the other thing is that perhaps you're
only interested in working in a certain
portion of the tree so you don't want to
have to check out the other 10 gigabytes
of stuff you don't care about and by the
way when I say gigabyte some people are
actually using mercurial to work on
multi gigabytes or streets for example
via freebsd freebsd ports tree has a
port that sits in mercurial instead of
in perforce and it contains i think
something on the order of 150 thousand
files 150,000 change sets so that's you
know reasonably large amount of stuff
and you really want to be able to focus
on a certain aspect of it rather than do
all of it it's a it in progress yes
yeah a lot of my love tapes not
splitting it up yeah handle that as well
yes um so the question is if you split
they file up into multiple files will
mercurial handle that and I can't speak
for Matt because it turns out that I'm
now actually him but I believe that his
plan of record is too when a rename or
copy has been detected to a merge into
each of the children and the descendants
of the original file so if you copy one
file into three different files and then
you click off the first third middle
third and the final third in those three
different files somebody else makes them
edit in the original file the logically
appropriate thing ought to happen now
I'm not actually doing the
implementation so i can say yes it will
be a better world and everybody will be
happy I don't know how hard it's going
to be yes
corner by
centralized fashion
when they give you update every day a
pen on me up they say something like
they called database then give our
writing to it and keep on reading what
but it won't be a 45
sure so the question is can you can you
extend material so that it essentially
behaves like CVS so that when you do an
update it it does the logical equivalent
of a poll and so that you don't have to
worry about merging so that you have a a
straightforward simple way from people
to to get their feet wet and the answer
is yes mercurial is extensible in those
terms no nobody has explicitly done the
work to do that and I do know that there
is at least one other distributed
revision control system that does
exactly what you described because they
want to give people who have used CVS
essentially training wheels right so it
is possible to do that and it would be
quite straightforward you know
contributions of code to do things like
that are always welcome yes
kind of push a patch back into history
already
yeah push the thick of the back to
okay so the question here is let's say
I've i'm working on a revision 2 and a
revision 2 dot 1 and revision 2 i've
frozen because i've released it under or
cd-roms out in the wild or tar balls or
whatever the bits the kids use these
days are and I've found a bug in
revision 2 i've fixed it in my two dot
one branch and i want to backport that
fix this is something that revision
control weenies tend to call
cherry-picking i'm a self labeled
winning by the way this is not a
pejorative term the answer is you can do
it using a patch as as something that
you would support as a first-class
operation cherry-picking is a very
difficult thing to do there are maybe
two or three revision control systems to
handle it relatively well / forces one
another would be actually kind of
subversion almost handles it well
because subversion has no notion of
merging at all right another one would
be arch which is explicitly built in
those terms but I wouldn't recommend
that anybody use arch a final one would
be darks which is one of the
theoretically interesting but not
practical ones and that is written in
Haskell of all languages and dark says
this wonderful quantum mechanical I kid
you not theory of patches that it is
built up on so that you can talk in
terms of patches commuting with each
other and boundaries beyond which they
cannot go and so on and so forth and it
tends to 0 exponential in space and time
quite frequently so it's it's it's got
some fundamental theoretical problems
that are not addressable yes now it
seems with mercurial that first an
engineer do some work is local
tests about and you know in a corporate
setting or even in the you know projects
that you have to then publish your
changes out to the world but since it's
now it feels like it's a two stage
commit you know you don't be able to
make your changes then you have to
actually publish them it seems like it's
easier to accidentally forget to publish
them is they're so good way to make that
less painful the question the question
is is it is it is there an easy way to
publish your stuff with mercurial or
presumably by extension with other
distributed tools so that other people
can find them and the answer is that
right now you have to do stuff by hand
because we've been focusing on the core
of the software rather than on these
sort of larger usability questions that
sort of thing where you want to be able
to see oh I haven't actually published
this even though I wanted to or oh this
repository that I've made changes based
on it actually has diverged from me by
this much you want to be able to tell
those kinds of things without having to
explicitly do it by hand all the time
those are things that I would really
love to see but they're not quite there
yet because we've we've been clear cap
I'd with just getting the core
functionality into one dot o forum so
far do remember that we've only been
around for about 14 months and that the
set of core developers is quite small
yes more questions yeah
how you use material to supplement the
school system
the question is would it be possible to
supplement an existing revision control
system using mercurial and the answer is
there are various different ways that
you can do that so somebody has for
example written an incremental perforce
importer for mercurial so there there
exists a proof that it is possible to do
what you want today I don't know how
well it works I imagine that it is one
directional yes there is also tool
called Taylor written by a guy in Italy
whose name is Emmanuel guy shots and
Taylor is sort of the rosetta stone or
revision control tools it it will
convert between arbitrary revision
control tools up to a point and it
doesn't have a very good notion of
branching emerging so it tends to lose
information when talking between
distributed revision control tools but
if if what you're looking to do is an
incremental conversion and then stuff
some things back into a host Raeleen
control tool it is actually pretty nice
and it's relatively straightforward to
use
my question is for maintain couches and
submitting them whether it would be
suitable for that in that kind of a case
probably the easiest thing to do would
be to use a perforce importer to pull
your stuff into mercurial maintain
things as patches then commit them back
to the native revision control tool
perhaps by hand or perhaps by automating
it um I I don't speak perforce very much
of anymore so I can't say that with
whether whether it would be completely
trivial or not I imagine is that my
imagination tells me that it would be a
relatively small amount of scripting to
do more questions probably
but you may have your guests so
beautiful
if question is is the mercurial data
stream Python objects the answer is no
and the reason that it's not is that
python has been somewhat willing to
change the data stream format and that's
not a terribly good thing also it's not
a very efficient storage mechanism
instead what we do is we explicitly lay
out the bikes ourselves using tools like
struct pack and using string operations
and just plain little right so we know
exactly what the bites are supposed to
be yes how do we deal with authorization
is the question and there are there two
or three answers to that depending on
how you want to look at the first is
that we have no notion of authorization
at all because mercurial doesn't care
the second which is the more
satisfactory answer is that if you want
to be able to share changes with other
people you can push to a shared
repository which you can use you using
for example if you're all in the same
file system unix groups or NFR or
windows permissions you can also tunnel
over ssh so that you can do that over
the insecure Internet somebody is in the
process of adding support for pushing
changes over HTTP which will use I
presume some form of user authentication
whatever Apache happens to provide and
will be secured over SSL so mercurial
itself doesn't have to care but it has
various different transports that do
allow you to specify things in different
ways and for example there is an
extension to mercurial available that
will let you lock down individual user
accounts and put apples on the sub trees
that people are allowed to push to so if
you have changes that push stuff into a
tree that you're not allowed to push to
you will be forbidden from doing that
and other people won't be able to call
those changes because they won't get in
in the first
so there are various different ways that
you can lock things down yes question is
is a section we built in the answer is
yes and we used ssh colon slash slash
bloody bloody glad you are else any more
questions okay thank you all very much
for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>