<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Practical Common Lisp | Coder Coacher - Coaching Coders</title><meta content="Practical Common Lisp - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Practical Common Lisp</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VeAdryYZ7ak" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">scream of people has started with
suicide people coming in so we'll start
this is Peter Seibel who has written an
excellent book practical accomplice
listen and today it's talking about how
choice of programming language
influences the way you think about
writing your health or how your
architecture ends up looking
I guess we'll just start okay so this
mic is on yep okay so this is this is a
version of a talk that I gave to a sig
and the West Coast where I'm from the
ops software architecture and modeling
sig and they were all into the whole
pattern saying it's up it'll be a little
bit of stuff about that but I suspect
that then I got some feedback from even
those guys the thing they were really
interested in was actually hearing about
the sort of language differences common
lisp versus the world and so I'll talk a
little bit about sort of the theory of
architecture very briefly that's a bunch
of hand waving stuff and then we'll look
at a few features of what I think of as
the key features of common lisp and
compares them in some cases quite
specifically like here's how you how
something gets done in Java and
demonstrate how patterns are used so
I'll do a little compare language
comparison a couple key features
obviously I'm not going to cover all of
common lisp it took me two years to
write the books 500 pages long you want
to learn the whole deal read that
there's still stuff that's not covered
though part of the goal of this book is
if you are as I assume almost everybody
in this room is an expert programmer in
some other language and some of you may
be expert Lisp programmers as well but
if you're not an expert Lisp programmer
but you know how to program this book
should be the shortest path from here to
understanding what Common Lisp is about
that was really my goal I was you know
wrote it with all of my friends that I
used to work with that web logic in mind
you were all super smart programmers who
are all thought I was crazy to think
this was a great language and so I was
constantly trying to imagine what they
would be saying to me so that's the end
of the lip my plug for my book so as I
just mentioned I know working backwards
before I wrote the book I was hacking
Java at a little startup in San
Francisco called Kenna Maya where we
were building a big transactional
messaging system in Java that was
founded by one of the WebLogic founders
two had left WebLogic where i had worked
with him working on the WebLogic
application server i was the early
employee there prior to that I was a
hardcore Perl hacker at web shops like
organic online and before that I was a
would-be journalist and English major so
that was my circuitous road to Liz but I
actually started my dad was as I
mentioned in the introduction of my book
I'm one of the few second-generation
list programmers in the world my dad did
Lisp in the 80s you know when it was the
last time it was big right you know the
next time is coming up right now and you
know so I heard learn to my father's
need that Lisp was really the bee's
knees and I sort of spent my career
why need my way back so if I'm going to
talk about how language affects
architecture I talked a little bit about
what architecture is I'm going to you
know you all if you write software have
some notion of what it is I'm just going
to frame it very briefly you know
obviously the reason for doing
architecture is to keep our systems
intellectually manageable and to some
extent to coordinate group efforts one
of the ideas about what software
architecture really is I find really
interesting is from Peter narf
who's the N in BNF he wrote an essay
which was reprinted in one of the agile
programming books about how the way what
you do when you develop software is you
develop a theory which actually has a
special meaning a theory of how the
program works and if you have the theory
of how a program works then not only can
you well basically if you don't have a
theory of how the program works you
can't do things like modify it or find
bugs in it or whatever
explain how the parts of the program
relate to parts of the world that it's
supposed to be emulating or interacting
with or whatever
and he has a sort of interesting take on
what this is all about that the essence
of I'm getting the theory of a program
is sort of a IAI complete problem the
only way that you can really understand
how a piece of software works is
actually to have either written it or to
have worked very closely with people who
did write it and who passed the theory
on to you you can't take a piece of
programming a program the text of a
program and back out the theory without
it incredible you know amount of work
that's equivalent to just writing the
thing and the reason that that's
interesting to me as relates to Lisp is
because obviously well I think that's
probably true of all languages obviously
some languages as they get higher level
it's easier to encode more of your
knowledge about the theory that
underlies a program into the program
itself obviously if we have you know the
machine code that your assembler that
your compiler gave you it would be a lot
harder to back out what the heck the
program is doing that if you had the
source code in any high-level language
and from there we can extrapolate well
maybe even more expressive languages
would make the theory of a program more
accessible to either newcomers to the
program or to you yourself
you know a week later a month later a
year later
the other thing about or the other so
there's nothing here I know okay yeah
it's cute cards I'll talk about the
presentation software later I'm a
believer in the Tufte and PowerPoint is
the root of all evil theory but there
will actually be a few slides up here
later so another approach you probably
all familiar with - how the heck do we
do software architecture is the pattern
movement Christopher Alexander building
architect had this whole theory about
patterns other building architects
completely blew them off software people
said wow this is really cool we can
apply this this is exactly how we build
software and thus the pattern more
movement was born the thing that's
interesting about patterns again is
relates to choice of programming
language is to what extent do the pad
like the patterns and as and beyond
individual patterns the pattern language
which is sort of the sum total of
everything you know about how to put
stuff together whether it's buildings or
software how does that how's that
affected by your language you would you
use the same pattern language regardless
of your implementation language or does
your implementation language essentially
set the stage for what possible pattern
language you could be using so to
understand that we're to think about
well what are patterns really and the
way Alexander talks about them is
individual patterns are designed to
resolve specific forces and by forces he
means things that are I mean it's I
guess at the base case there's just sort
of this stuff from physics right you
build the building wrong it falls down
but he was particularly interested in
things the forces that are either
inherent in human beings like one of the
examples is people like light and
therefore people are more comfortable in
well-lit rooms and he has a pattern
which is light on two sides a room
that's got you know windows on two sides
is more likely to be well lit more of
the time and therefore what's the more
comfortable room to be and then people
might not identify that's why but they
will gravitate to rooms like that if you
actually you know look at the rooms in
your house that you like spending time
and you'll probably discover that
that pattern and many others are present
there's also cultural things he talks in
one of his books the timeless way of
building about building houses in Peru
where culturally women were expected to
stay in the home and weren't sort of
allowed to go out and participate in the
life on the street so they had to build
houses where there would be an alcove
sort of half in and half outside of the
house where women could stand and be in
the house yet see the street and that so
obviously that's not universal to all
human societies but in that culture it
solved the problem these forces that if
you didn't have that either women would
be forced to just hide in a house and be
completely disconnected from the world
or they would have to go out into the
street and sort of suffer the mental
anguish of breaking the mold of society
now whether that would be good for this
society as a whole is another question
but that's the kind of cultural forces
so in software we have different forces
to contend with the physics of software
are just math big'o complexity stuff
like that you build it wrong it will
either fall down or never finish or all
of it you know sort of basic stuff but
analogous to the inherent nature of
human beings and the nature of cultural
influences and software patterns are
designed for so building patterns are
designed for people who live in
buildings software patterns are for
people who live in software namely all
of us people who write software the fact
that software is then used by users the
patterns don't matter right the user is
just running a binary so the patterns
are long gone at that point but the
patterns refer the people who live in
the software a day in and day out and
have to deal with it have to modify it
have to you know are affected are
depressed when they're presented with a
big massive code that nobody can
understand it or feel good and happy
when you're working on code that you
wrote it's beautiful too elegant you
understand how it all fits together so
there's built-in limits you know the 7 +
2 rule you just can't remember that plus
or minus 2 you can't remember that many
things so if your software architecture
is predicated on
bring twenty things in your mind is
probably going to fall apart and also we
obviously have cultural biases you know
and this is where Lisp sometimes runs
into trouble
people are go through great pain in
grammar school and junior high learning
the stupid precedence rules for in fix
notation and are now convinced that in
fix notation is the one true way to
notate arithmetic expressions and then
list comes along with prefix notation
and they say that's just weird that
stupid in fixes the natural way to do
this so language wars are often fought
on the grounds of what's natural and
people have a hard time keeping track of
what's natural and what's just repressed
pain of they've already learned alright
so and then patterns again in building
or software are all put together into a
pattern language and that's really what
Alexander was looking for was sort of a
generative language where you have a
number of patterns where each pattern
you apply resolve certain forces but the
but the pattern itself causes new forces
to come into existence you then have to
resolve and so you need another pattern
in your language that can solve that and
if you have sort of a set of pattern
whose transitive closure can resolve all
of the forces and leave you with a
coherent whole that's a good pattern
language and then there's a whole nother
level for Alexander of you know you want
patterns and pattern languages and then
the buildings or software that you
create needs to have the quality without
a name which there's a whole
philosophical hand waving thing that
you've probably scratched your head
about if you've read any of the pattern
literature
so that's patterns so how do patterns
relate to languages well I would suggest
that if you think about it at all
it's the universe that we live in when
we write software is itself built out of
software right unless you're writing
micro code for a new CPU
there's many already many layers of
software in place before you come into
work and those that software creates the
universe in which you live and creates
the set of forces the base set of forces
which you have to contend with in which
and as you add software to the system
you're just changing those forces so you
could start from bare metal and build
all of your software up from machine
code and if you were smart what would
you do you would write a language and
that language would now create a new
universe in which to work so and then
most languages provide some facility for
then creating new languages or at least
new abstractions within the existing
language so it doesn't seem likely that
a single pattern language would apply
equally well whether you were starting
from bare metal or starting from pug
next you know any high level language
and then different high language
languages if they're different are going
to call for different patterns okay so
that's sort of how this all works and
the Gang of Four you know the design
patterns books they pretty much say this
they page four they say our patterns
assume small talk C++ level language
features and that choice determines what
can and cannot be implemented easily if
we assume procedural languages we might
have included design patterns called
inheritance encapsulation and
polymorphism similarly they sort of do
my work for me similarly some of our
patterns are supported directly by less
common object
Languages clause which is commonly
object system has multi methods for
example which lessen the need for a
pattern such as visitor and so that's
you know they sort of say right there
well okay and then one other little
grenade to toss in here who here has
heard of the sapir-whorf yeah okay
that's good
who here I should ask this at the
beginning so who here has used Lisp in
any kind of serious way they all the
same people know about separate Wharf
sapir-whorf is a hypothesis from
linguistics or anthropology or whatever
basically these folks notice that human
natural languages differ obviously and
theorized that how you understand the
world is constrained by the natural
native language that and they observed
that I mean the sort of famous example
which I think was later debunked was the
idea that the Inuit have you know twenty
eight billion words for snow and they
have the saw is much finer sense of
different kinds of snow so that
particular example turned out to not be
so true there were other examples that
are that are have actually been verified
like languages that don't have words for
certain shades of colors people can
recognize the colors perfectly fine but
when asked to remember later what color
certain objects they were shown are
their ability to remember that as it is
in fact infected by the colors that
their language supports is it still
believed to be true by all those
linguistics yeah I just well the answer
there's two two flavors of so
sapir-whorf is sometimes called
linguistic determinism and there's two
flavors are strong linguistic
determinism which is basically you can't
think anything that you can't say in
your language and then there's weak
linguistic determinism which is
basically your language affects how you
think strong linguistic determinism is
pretty like the optimist well obvious
and compelling argument against strong
linguistic determinism is we can
translate between languages if if it
were literally true that you couldn't
think anything that wasn't incredible in
your language you could never translate
from one language to another which is
actually interesting then when we go to
computer languages because of course
turing completeness tells us that all
languages are absolutely translatable
anything you can express in one
programming language can be expressed in
another so there is no you could you
could argue that in fact human languages
can't be translated you can only
approximate the meaning between you know
French and English and that there is a
difference but computer languages we
know it's you know it's math it's not
true
wankers
I don't throw my face
concepts as not
right and I right and I suppose it's
your right somebody wanted to defend the
defendant even the weak version of
linguistic impairments would say well
yeah but that man that maybe the
mechanism right you practiced thinking a
certain way by you that's right it's you
know I'm just going to buy the week II
they said it there said Wikipedia
there's some respect for the weak weak
version left so anyway and so computer
scientists have noted this analogy
between language a language and computer
language you know Alan Perlis professor
Yale said the language it doesn't affect
the way you think about programming is
not worth knowing you've probably all
heard about Eric Raymond sandwich ever
and Liz just because it will change the
way you think and that's why lispers
have always heard of this because Lisp
is always held up in as an example of
the language you should learn because it
will change the way you think the
interesting question to me is so that's
great it'll change the way you think but
do you have to use it right if if you
know Paul Graham you probably all heard
of Paul Graham I assume if you heard
about is the blub paradox
so blub is this notional intermediate
intermediately powerful programming
language and the his theory is that if
you only speak blub you look at less
powerful languages and you can see that
they're less powerful because they see
what they lack
relative to blub but if you look at more
powerful languages they just look weird
because you you can't think of the
features that those other languages
support and so it just looks like blub
plus a bunch of gunk that makes no sense
but if you sort of take the Eric the
Ramone daeun hypothesis that you should
learn list because it will change the
way you think that sort of implies that
you could learn to think in you know
Omega if you know if Omega is the
ultimately powerful language at the top
of the lattice of all you know where
languages are ordered by power you could
learn to think in Omega and then work in
blub and get you know all the benefits
or 99% of the benefits
and that may be the case and I'm going
to give a demonstration of why that's
probably not and that's basically the
reason knot is provided concisely by
another Alan Perlis quote which is be
aware of the Turing tarpit
where in which everything is possible
but nothing of interest is easy right
like yes you could take omega you could
take a raw CPU and you could write all
of the code you know you could just
start by writing the compiler for Omega
and then write the rest of your stuff in
Omega but that's really not how you're
going to get software done in this you
know millennium so it does
I think matter what languages you
actually use not just how you think
about coding so so this is my favorite
you know I don't think it's necessarily
Omega there's you know the Haskell errs
and the mlrs would say you know well
from where we sit common list looks like
blub and here you just don't understand
you know the brilliance of the strong
and furred typing and all that and you
know they may be right
of course Common Lisp look at Haskell
and say well Haskell is really a blub
because you guys don't have macros and
so it may be the case that you know
there is no Omega or that you know
Common Lisp and Haskell are you know on
different branches of the lattice and
someone's going to find a way to unify
them and a few other good ideas and
produce Omega so but you know smart
folks have noted this Dijkstra you know
sort of that this is sapir-whorf right
here Lisp has assisted a number of our
most gifted fellow humans and thinking
previously impossible thoughts and sort
of to echo the patterns notion alan kay
another turing award winner inventor of
small talk lisp is in a language it's a
building material and i'll sort of show
how that works okay so the first thing i
want to talk about is to compare i'm
gonna do a little comparison i assume
everyone here has at least a reading
knowledge of java you know whatever
it'll make sense java is that
because I'm going to show how a pattern
the visitor pattern which who hears
heard of the visitor pattern okay is
implemented in Java typically and what
problem it's aimed to solve and then
I'll show how that pattern sort of
doesn't exist
or is not needed and common list because
common list essentially has that those
forces pre resolved by virtue the
language feature and this sort of shows
the Turing tarpit yes you can implement
this in Java and I'll show you the reams
of code you have to do to do that or you
can just use the feature of multiple
dispatching and Common Lisp and it's
just there so we'll take a concrete look
and how that works out so before I start
I just want to point out to me the
essence of the visitor pattern is the
double dispatch right when the when the
visitor pattern is presented it's
usually in terms of walking a tree like
you have a tree of you know abstract
syntax tree the tree of nodes or you
have a tree of parts you know a car and
engine it's wheels so forth and the
visitor is often used in conjunction
with your traversing a tree of
heterogeneous objects and that's sort of
the point the objects are different so
you want to do different stuff with each
of them but you're going to traverse
this tree that's not really the
traversal itself isn't the point of the
pattern if it was you just needed to
traverse a tree we have another patterns
called recursion that all languages
support pretty much anymore but the key
is the double dispatch you have a tree
of nodes and they're heterogeneous and
then you have different operations that
you want to perform on that tree of
nodes for you know so the example of an
abstract syntax tree you have all that
you know the nodes representing all the
different constructs in your language
and then you have a visitor that wants
to pretty print them or compile them or
whatever
and the so the the operation you want to
perform on at each node is a function of
both what the node is and the thing
that's traversing the node so I'm going
to leave the traversal out in this
example and just focus on the double
dispatch someone review just a little
bit of Java just make sure we're all on
the same page so this is this is non
this is normal polymorphic dispatch in
Java right implement you have an
interface principal books CDs and DVDs
are all price of all which means that
they have this method price that
stupidly uses a double to represent
money and so now you can get a random
price of all all the compiler knows and
the runtime is that this thing is price
Abul and therefore we can call this
method so this would be the same in any
singly dispatched object-oriented
language Python you know we take out the
type declarations small talk whatever
but this the basic notion is the same so
that the polymorphism is the the poly
many more shape the many shapes are the
different these alighted bits of code
different depending on what kind of
thing this is this is non polymorphic
dispatching just to make sure that we're
clear this is just overloading write the
method happens to have the same name
because Java lets us do that and the
type determines it sort of is really
part of the name so if you get a random
object and the kampala compiler knows is
that it's a Java lying object and you
call display oh this will print object
and if you try and cast it to a book it
will either print book because you've
statically said this is I want this one
or the castle of course fail so this is
really the same as if we had just named
these methods differently they're just
different methods that Java lets us pun
and have the same name Objective C for
instance does not let you do that
okay so this is hand coded dispatching
and so that and you know the reason you
would want to do something like this is
because you know if you didn't like so
before price possible was part of the
objects but displaying for whatever you
know architectural reasons we don't want
to add a display method to the object
itself the objects may exist someone
else wrote them and we just need to
display them for our application so it's
not part of the class itself
interestingly in small talk you could
just add the methods to the object that
already exists and which end would
obviate even this use of the visitor
pattern so we're we're sort of adding
functionality to these objects from
outside so since this doesn't work
polymorphically or you know at runtime
you could right hand card to dispatching
where you just have one method display
object and then use runtime type
information to figure out is it a book
or a CD or dvd and then do the
appropriate thing of course that's like
that's that kind of code is exactly what
we were trying to avoid when we invented
object orientation in the first place
right you don't want all these stupid if
statements because if you add a new kind
of thing you got to add a new clause to
every switch statement like that in your
code so visitor is designed to solve
that problem by providing double
dispatch the display operation that gets
chosen will be a function of both what's
being displayed and how we're displaying
it so the way you implement this in job
is you define an interface that has a
separate method for each kind of thing
that you want to display and then also
you do have to touch the objects that
are going to be visited but only in one
way and you can support multiple
visitors with this
Adam method display on where the objects
are walkable seen a seg the displayable
will be like a book if you ask it to
display on a particular display it calls
back on the display well we'll see what
it does let's do that okay so here's
that well here's the two implements the
implementations of a display graphic
display in a text display they
presumably do different things you know
put pictures on the screen put text on
the webpage whatever and then here's the
things that are actually displayable so
they don't have to know anything about
the two kinds of display graphical or
textual but when they are asked to
display themselves on a particular
display they provide the information of
what they are they turn around and tell
the display I'm a book essentially write
this this display book could just be
called I'm a book and here's impasses
itself and the thing that's really
annoying well it's as shown here because
we use different names you have to
implement this method in every class you
can't inherit it because the whole point
is you're specifying three guys you guys
will get this so at last we can actually
use this we can get a random displayable
a random displayer and then use the
double dispatch to get you know a
graphical or textual display up a book a
CD or DVD oh no we want to add some new
classes so paperback book hardback book
the both kinds of book how should they
be displayed it
we could just use the existing display
book unfortunately now they're all going
to be displayed the same and if you have
some application where you need to
display paperbacks and hardbacks
differently you're either screwed or you
have to go into the implementation of in
all of your visitors and now put in
another stupid switch statement instance
of paperback book do this whatever so we
could also add these new methods paper
back in into the display interface or so
the visitor interface so we add them
there when you go back to our display
helper which I sort of skipped over
before add the new methods and then this
is an interesting point in the display
helper which is sort of an abstract base
class for the actual displays we can
imitate
Java's inheritance by saying the default
thing to do for either these subclasses
of book is just to call the book methods
of you are existing displays we need to
be recompiled but then they would pick
up this default behavior and if you had
a particular one in say the graphical
one you wanted to display paperback
especially in some way you could then
provide a new method for paperback but
leave the hardback book alone but the
thing that's a little goofy about this
is we're re-implementing inheritance
right when we just have single dispatch
it just works when we want double
dispatch we have to sort of roll our own
thing so then this cool java kids these
days oops yeah so the cool java kids say
all right well this is stupid let's use
reflection and now we really get into
rolling your own and the lispers and the
audience will appreciate compute
effective method this is essentially
what Lisp has built in but this happens
basically what happens when you say
dispatch on some object we use
reflection to fig look at all of the
methods that are available on the
display graphical or textual display
pick the one that's the most appropriate
and then and then invoke it again using
reflection as well the guts are in
compute effective method which is the
next step and this is a mess but that's
Java so we try all the super classes
walk up the tree thank God Java only has
single inheritance then of course then
we have interfaces and so then it's just
like what do we do we'll just take the
first one that matches I don't know if
that's right but whatever and so now
it's a little different than you know
how single dispatch might work I guess I
wouldn't matter they would just collapse
but we'll just pretend that doesn't
matter and then I'm sorry what's that
belong to classes so you should just get
to work no this is that what we're
looking for is we're looking for a I
guess we're looking for a method called
apply for Cruz and we're looking at the
type of the argument so if I'm a and
this is sort of more generic than the
display thing if you know it may be the
case that I have a a visit or that
implements a apply for foo where foo is
an interface and if I pass it an object
that implements foo I wanted to find
that method so I got to look with those
buttons
and so this now we can use this dispatch
helper which was pretty generic to
implement display so now we just have
one method called display that takes any
kind of object and uses that dispatch
method that we just looked at which uses
reflection to find one of these four
methods and display now the nice thing
actually about the reflection based
thing which is of course the nice thing
about Lisp or its built in is that you
can now add essentially add methods to
classes that you know final classes
right we can add we can say here's how
you display a string and you know
there's no way you can do that even if
you had the source code well I guess if
your son any other source code you could
add it but no one else can so now we can
say display foo so that's an advantage
over the non reflection based
implementation of the visitor a problem
is that we had to write all this stupid
reflection code so how does that so
that's Java intended to look like a
nightmare but I think I was pretty fair
to it so in common list one of common
list many fantastic features is the
notion of generic functions so the root
of all object orientation was similar
right well to that
alan kay took Simula and liz mixed well
produced small talk so that was the path
of goodness and light orange took small
talk
static bondage and discipline language
mixed with see another relatively static
language and produced c++ that was the
path of darkness and since then of
course since the tree of languages isn't
really a tree because you can cross back
the small talk branch has gone off and
then small talk begat Objective C right
which was acting up so you take small
talk and then C mix and you get
Objective C Java took a bunch of stuff
from Objective C and so we're moving but
obviously was syntactically and in other
ways tied to the c++ dark path but it's
sort of moving over here and then
languages like Python and Ruby and Perl
to the extent you consider sort of are
all pretty much in the you know the
dynamically typed small talk school of
you know the path of the light so
basically all of the good stuff in
object orientation actually came from
Lisp originally anyway plus Alan Kay and
Alan and what Alan Kay added was this
notion notion of message sending and the
list guys at the time that
his work or thinking okay where we
should be able to add this back into
list because list is the ultimate
programmable programming language and so
initially they and they were like
scrapping around trying to get copies of
Alan's papers early in the early date in
the 70s and so they started to invent a
bunch of the stuff themselves they could
get the papers they had a very message
sending single dispatch oriented there
was a special function send and you say
it send the name of the message method
name whatever and the arguments and the
object to send a message to it and any
arguments and it would be just like
small talk but then they said let's see
Lee we can generalize that and so by the
time Common Lisp came around there were
a few ideas that were combined into the
common lisp object system clause that
generalize from single dispatch into
multiple dispatch where you define a
function that takes any number of
arguments and you can dispatch on any of
the arguments that if any of the
required arguments that it takes now the
one weird thing about that for people
who are used to thinking in single
dispatch languages is that methods don't
really belong to classes anymore we've
sort of gotten away from the notion that
here's a class is some data and the
operations that operate on that data now
you define classes is essentially data
and you define generic functions which
are functions that could in theory be
applied to anything and then you define
methods that are attached to those
generic functions and provide specific
implementations sort of like that
reflection based dispatch that accepted
language you get true multiple dispatch
you get also a big advantage is that it
works there's only the one mechanism so
the way inheritance works for single
dispatch is exactly how it works for
double dispatch common lisp also has
multiple inheritance and how that is all
sorted out is the same and well-defined
really actually not that hard to
understand there's some other and then
what's that generalization was created
that allowed all kinds of other fancy
things like you can have sort of parts
of methods you can have a main method
for a particular class and then you can
define methods that run before the main
method and after the main method and
around the main method and when you
actually invoke a generic function all
of these applicable methods are taken
sorted out and combined to produce the
actual code that runs into much more
it's not just picking one thing to do
the waste a little bit specialized so
get all the details read the book
chapters 23 and 24
so just so back to here's how it looks
in Java here's how it looks in Liz so
this is now here's the classes I've lied
in the definitions slots and then we
define a generic function price we can
price anything book CD so this is you
know this is the actual argued parameter
name this is the class name and we're
just we're just specializing on one
argument we can also as we could with
reflection one we can special
specialized methods on numbers and
strings any type that exists in the
language they're all classes that double
dispatch instead of writing reams of
code we just write this now we have now
we add we have two ways we want to
displace time prep display text display
now display takes two arguments and we
specialize you know the things we want
to display and the things we want to
display them on you can organize the
methods in a different way and that's
another question everyone asks like okay
so methods don't belong to classes where
do they go and there's no good answer it
sort of depends if you're you know some
generic functions are really generic
could be applied to anything and but all
of the implementations are sort of
cohesive so put the generic function and
all the method definitions with it other
times the methods really do belong to
the classes conceptually intellectually
and you put
let's necessarily care so triple
dispatch quadruple whatever
so there are the question was went out
that is there's a canonical algorithm
for sorting the inheritance to like
basically well out there to their server
the first level of decision is by
default it's left to right so if you can
decide left to right you're done that
when you define the generic function you
can actually specify a different order
if you want which is very useful
one case where it is very usual and then
if there's actually what seems to be an
ambiguity then there's there is a
there's basically an algorithm that you
can understand which is you know take
the class hierarchy and sort the methods
according to this partial order aid and
pick and then there
standard algorithm
we're cashing this catchy tune it missed
like supposedly
a display for life anything for a method
you can write you can and in fact if you
don't specialize like if I just had you
know are here with no no parens and no
class name and that's implicitly
specialized on T which is the top of the
type lattice what if I wanted and really
want it
not statically you can either and you
can use the sort of reflective
capability
Madonn just purpose of buying them or
you can just put it in the fall with it
signals an air but there's no static
it's not a it's not a be any language
that
because you could define the method at
runtime
okay so that's generic dispatch the next
topic I want to talk about now something
clearly different is to look at how
different languages handle air handling
and again briefly set up what is air
handling I'm sure we all not because I
don't know but because I think we all
have our own slightly different idea
insults but you know mine is then we can
at least accept it over the next 16
minutes
this is the reason I want to talk about
this because it's an example of how the
trabecula dowry and notion of a theory
of the program well the theory of the
program can be more or less simple
hardly determined by the constructs we
have available to to shape our program
and error handling is a particular one
and you know it's hard to get right
people to confuse themselves in many
different ways about it in many
languages do a lot to not or to help you
get confused so where I like to look at
error handling is by starting from the
notion of invariance which which we are
all familiar with Dijkstra honest this
portrait Meier built it into Eiffel the
notion of preconditions post conditions
class invariance and whether you think
of them explicitly the way Dijkstra
encourages us to in the way I fold for
too much forces you to every function
that you write it and I'll focus on
functions rather than class of variants
every function has a precondition right
it's stuff that has to be true for this
function to possibly work and every
function has a post condition which is
the stuff that will be true of the
function succeeds and many people
program very informally but that's what
you're thinking about when you're
thinking about what does my could do I
further split that up the precondition
part into the actual precondition which
is everything that has to be true if you
have a function that opens a file reads
it and parses it one of the things that
has to be true is that file has to exist
you know that which does mean your
program going to crash if it doesn't
exist but the function will not succeed
if the file that it needs to open is not
on the disk
the formal precondition is what folks
like Meier and Dykstra like to focus on
which is the subset of the actual
precondition that we can prove by logic
or or that the caller can meaningfully
check but they exist sense of a file you
certainly can't prove by the logic of
you know static analysis of you the text
of your program that that file will
exist and you can't even really check it
in the caller because you can check that
the file exists going to call the
function and someone deletes the file
and it doesn't still doesn't like this
so there is this gap between the actual
and formal and that gap is where error
handling
so when I talk about air handling
I'm talking about Murphy's Law stuff you
have to deal with this stuff it's not
that there's a bug in your program and
it's not that there's nothing you can
fix in your program but if you don't
deal with it the guy who calls the
function that's supposed to open the
file and return some results based on
the contents of the file well the guy
who called it is strewed if the file
doesn't exist and that guy can't succeed
and if you just continue as if
everything was fine now your program has
a bug so if the breakdown if the formal
precondition isn't satisfied game over
like that's above if your
if the formal and the actual are
satisfied and the function doesn't
satisfy us closed condition that's above
and you can just fix that if there's no
excuse for that
but this interesting gap is when the
formal precondition is satisfied the
caller did everything right there's no
bug in the function but reality is the
actual precondition hasn't been
satisfied and so we can start on so
now you can be defensive and try and
make your preconditions looser and
define well this is what I'll do if
such-and-such bad case happens I'll deal
with these corner cases but ultimately
you cannot account for every possible
corner case and better this is just
handle errors properly which by which I
mean you should fail cleanly if your
formal precondition was satisfied and
you can't satisfy your post condition
which means something the actual
precondition wasn't satisfied and you
have to detect and deal appropriately
with the lower level failures call the
function and it fails we can't pretend
it that everything is a thing so how do
different languages deal with this well
we all know the C style right every
function
that could possibly fail return some
distinguished value that the caller is
responsible for tagging and that
everyone forgets to check and thus
underline failures are ignored and you
know 20 million CPU cycles later memory
is totally corrupted and we all wonder
probably wrong so Java and Python came
along and many other languages some of
us and said ok though that's just
insanity so what we need is exceptions
where at least the caller is now if they
don't do anything the exception will
continue propagating and you will sort
of satisfy the base requirement though
if you call something that fails and you
can't recover you have to fail
exceptions provide that right you either
catch the exception and catch up the
world or you don't and then you fail
because the exception continues to
propagate so that seems fine and when
you combine it with try final age that
you actually have a chance to clean up
as the stack of lines yeah life is
pretty ok but the reality is anyone
who's worked on big systems
which is nose as he almost never can
recover because down at the bottom
something goes wrong and by the time you
get to the level of the program that
would actually know what the right thing
to do in the context of this application
is too late because you've unwound the
stack and lost all of the state and you
know you have operations that were half
done then either too expensive to redo
or can't be a let me go like if you're
lucky you cleaned up with try finally on
the way up but now you've got to redo
the whole computation so common list
provides it what I think is a much nicer
method for dealing with errors which is
they split instead of a two part except
traditional exceptions are two part down
at the bottom you've signal the
exception up at the top somewhere above
you handle it so signal handle and
common list there's signal but don't
unwind the stack let the signal go up
the stack someone up here can say I know
how to handle that and then the way they
handle it is there's a third part which
is a restart which can be established
anywhere between where the condition was
signal and where the handler is set up
or actually in above that says you can
unwind to the restart and then the
restart will run and do some some
currents well look
example of how that actually works so
here's an example call chain imagine we
have an application that's a log
analyzer I can't really read into it
this says log analyzer so that's the top
level function you know this could be a
command-line utility that analyzes a
bunch of log files it uses a function
analyze log to analyze a single log file
so this guy's presumably going to take a
long file digest it in some way and
return some results this guy's going to
aggregate all the results analyze log
and in turn uses a lower-level function
parse log file that knows how to parse
some particular kind of file but one
file and parse log file uses the
function parts log entry to parse each
individual entry so this guy is going to
call this some handful of times this
guy's going to call this probably once
and then this guy's going to call this
however many times now
each line entry in the log file as
there's a lot of state right if we're
down here this is where things are going
to fail right you're going to get to one
line in the log file that's malformed
and this guy's going to say I know this
is now formed because my whole job is to
parse these things and but it's not this
guy's job to decide what to do maybe
that you know fatal error we need to
just quit the program page the system in
you know whatever or maybe we just skip
it it's okay
or maybe we apply some heuristic and
parse it you know a little bit sloppily
because this log maybe came from a
little spacing source but it's not his
job to decide so in Java this guy would
say well crap this is malformed I'll
throw a malformed blog exception log
entry exception and it'll go up here
this guy by the same token it's not
really his job to decide what to do so
he was like well I can catch it but I
would know what to do I did so I'll just
propagate it and then and - now this guy
was in the middle
my log file when he got this malformed
I'll get your exception he's passed it
out now we've lost where we were the log
file this guy doesn't know what to do
because he's still a helper function so
he passes and he was in the middle of
the you know 100 log files that were
passing and so he throws out to here and
his lost track of what file he was on
you might know and now this guy is the
top level application he knows what the
policy is for this particular
application but now it's too late
we've lost all the state so unless like
I said instead this guy's signals the
condition the stack doesn't unwind that
can conceptually the condition goes up
the stack really what happens is we kept
a little basket of who knows how to
handle what kinds of conditions as we
went down so we find the right guy and
but at the same time as he signals this
condition he can also say I have a
couple strategies that I could use I
could skip this entry
I could you could give me a new string
to parse in the place of the line that
that I found to be malformed but I
certainly don't know how to use that all
right or I had this other heuristic
parts and I could use that if you want
likewise actually so that actually the
skip entry really belongs here but so so
these two guys both set up some restarts
it here's how we could proceed it's okay
with you
and so then this guy so we're in Java he
would have the top level exception
handler that went in Javas you know
catch the exception say crap I don't
know what you know I lost all the states
that I'll just quit pages system in
anyway unless he would establish a
condition handler that says okay kids
you get the malformed log entry error
then look to see if there's a skip entry
restart any you node and basically these
are looking back up the stack and he'll
say oh parse log file is a skip entry
restart I'll take I'll invoke that
restart and then this guy will just
still have a little bit of code that
says for here's I you skip an entry and
move on to the next one and everything
just proceeds
so that's basically you know there's and
and that facility is typically used for
air handling but can also be used for
any kind of other you know communication
up and down the staffers you can signal
mornings and lists that the default
behavior is to print a message to
standard out but you can catch the
morning and muffle it shoot there's
always a muffle restart morning and you
just say I don't want to come back so
the question about this what what is the
benefit of this over for example heavy
log analyzer instantiate a lot log which
is data it's hard rock parts log file
each say this is what I would like to do
response whatever right
it's sort of it's
it's it's just a mechanism for doing
that easily like you could like you
basically could you can critically
immerse where your response functions
you could have all of these functions
take us an argument like up which is a
function which is here's what you do
when you can't parse entry the real
problem with that is that this guy so
this guy can know about this pummel
application probably knows who's going
to be doing the parsing problems this
guy doesn't really care about that
they basically miss with the same reason
is you use exception and you don't all
the intermediate guys don't want to have
to know and you may say this each lip I
mean essentially it's providing a back
channel for passage and special cameras
we're saying that we don't currently
program in companies with one things of
this
well you could but I mean I didn't even
draw you and you could implement a
mechanism for doing this a job right the
message is a if we don't we just no
boundaries we won't be able to use the
banner in there but if we actually do
programming companies we will be able
that's at least the strong implication I
mean I mean you know so like I you have
shut down the program or night you know
you can use thread-local variables and
the appropriate use of try finally and
catch and you know concepts and special
exceptions and throw them to basically
emulate this the same way I use the
visitor padding to emulate the double
dispatch of token accomplice the problem
is and this actually really gets me to
my next and final point which I might
have to
which is the real winner feature
economist is I'm sure you've heard
someone talk about
problems with macros
and these are not you're not your father
C preprocessor macros right these are
that the language parser parses into a
completely generic abstract syntax tree
and you can hook into the compiler your
own little code generator at any scale
you want from a tiny little C
that person
you know so enlist the if expression is
sort of primitive there's the you know
the condition and then there's a single
men and a single ounce expression which
means that if you want to do two things
in one branch you got to use this other
ugly thing called Prague and to say so
if some predicates do these two things
well that's not you know terrible but
sort of sucks
so we can write a wetback row except
that this one happens to be built in the
common list but this is a tiny little
compiler that says if you see an
expression of the form when a condition
and then any number of following
expressions transform this into the if
expression on the previous page
and and the reason that this is
important is because both the generic
functions and the condition handling
system that I just showed you if they
didn't exist in common list you could
add them yourself with exactly the same
syntax that they are provided that is
used to provide them in the Commons in
Java
you have all of the underlying machine
units a Turing complete language you
have ended even beyond that you know
it's got thread-local variables as got
exceptions you could duct-tape together
an equivalent of the condition system in
Java but you could never hide it because
you have no way of extracting the syntax
and so that's where macros really you
know in it and it is hard to explain
macros because trivial examples like
this you're like yeah whatever that's
trivial
by definition big examples are sort of
too hard to wrap your head around in the
22 seconds I have left but I'll try
so here's it a medium sized macro so
deaf cat and this is from my book more
or less so this is a def test this is
Def Con is defines a function so this
the idea here is I just wanted to find a
function that does like a unit test so
this and this is all I want to say right
this def test its name is foo I want to
check one thing which is that to you
know one was one is to test a unit test
for my addition function this is what
that macro expands to which is you know
a little hairy be cancer it's like you
could write this by hand every time it
would be terrible
a little gross but now you can imagine
that problem is that the check is also a
macro and so that's doing this and
there's one nice thing is it can use the
expression equals to plus one one has
both a thing to run when you run the
test and also as data a label that I'll
print out so when the unit test prints
and I don't have to I didn't have to
type it twice and risk you know typing
it wrong one place and getting is
completely confusing printouts for my
unit test framework the other thing is
that with test results here is doing
really a ton of bookkeeping for me so
this is the full expansion and this is
why I try to explain macros because as
soon as you show this slide ever was
like okay this is terrible I want to
think about this but this is what's you
know you know none of this is actually
really hard is using the condition
system to signal passes and fails and I
keep track of all the passes and fails
and I print them out you know it's all
the stuff you would do and you could
abstract it a little bit differently
obviously Java test frameworks don't
actually require you to write code like
this but the fact that I was able to go
from that def test form and I can write
you know a gazillion of those and get
loops
all that is powerful back just briefly
to though if when example you know so
you can add these little tiny control
constructs well how long would it take
to do that in another language
oops well Java added a little for each
statement in 1.5 the jsr for that ballot
started in december 2002 final release
was September 2004 22 months plus
however many years you have to wait
before you're allowed to drop support
for 1 1 1 2 1 3 1 4 words Java whatsit
screen of macro stuff on
and then the real difference is that
macros run at compile time which is
unfortunately due to other
characteristics of less
to say but you can take you know what I
this one is really actually let me say
this doesn't slide doesn't really things
real quick so here's a macro language
that the Possible's customer for
generating and the macro which run
pilot program turns an expression like
this
what doesn't actually
but it turns into code that just says
print this right
I could function could take this data at
runtime and figure out that it's
supposed to print you know a P tag and
that this string that another we type
that would be the actual code that would
run a runtime would be doing all of that
thinking about okay what tag is it what
the compiler version is just you know
the equivalent of print Lin this X so
macros mostly its performance no well
the any other difference is that you can
use arbitrary syntax which this well
which actually the earlier example shows
pretty well here's a here's a better so
this is a little these are uses of a
macro to define a parchments or like a
gap don't worry about the exact language
of this grammar but this def prod is a
macro and this this plus is not
the other difference is that you get
which is substantial is that you can you
can use arbitrary syntax that doesn't
have to be I mean I guess in the end you
could have any function you want it and
pass it quoted data and let it
essentially interpret it at runtime but
then your code the code that does that
invokes those that special syntax does
it look like it condenses yes it's too
too long it's going to get interpreted
at runtime which to be very expensive is
absolutely big scale inaccurately this
thing actually this doesn't do anything
except force were away a bunch of
information about the grammar that this
reduction rule defines until I get down
here it's a def parser arithmetic
expression and it looks up the
transitive closure of expressions that
are using the piles that all down to a
single function that implements the
parcel and then I can turn around and
use that parser def parser or anything
to find among the written now parse the
string and I can use that so
the super functional programming guys
have stolen $10 to sup will say yeah
like I can do all this with higher-order
functions and the ax so they can but
sometimes what you want to abstract is
this in tax it's not it's not a
functionality function
tracking functionality
to be able to write very concisely one
last thing
there's another one this is also from my
book
I write a parser in my book
three tags and this is essentially an S
expression version of text straight out
of the id3 spec and this turns into
class definition and method definitions
of how to read and write
the 93 tag not an ox and defines
the same way but essentially I just took
the speck put parentheses around it and
it gets compiled into code that that
knows how to parse these binary files
and you could enter the point I want to
just be able to write now I don't want
to have to write entire functions or
think about the world in those terms I
just want to say this is what I want to
say and then macros let me have what I
say between what I want
so I guess that's the end should we take
one one more question
it's looking like the syntactic and
semantic expressive power of common list
but a single program could create a lot
of functionality lot of power in
vertical code
can you talk to replay like the kind of
the flip side that double-edged sword
which is readability to have lots of
programmers a large code base I mean any
symbol in the program can be just about
anything and change the functionality of
the program behavior the program pretty
fundamental ways and local level city
are there look very large-scale projects
written in Common Lisp across like a
large number of aalverson sure so answer
segment and it's a common question that
in some ways the simplest answer is look
macros are just closing macarons our way
of creating extra actions functions our
way of grading on track
we don't look at see and look at lib see
and say okay well here's all these
standard functions but way to say see
lets us to find new functions what
happens and everyone writes their own
version of store Cod or
then the reason we don't worry about
that because that would be insane right
you're supposed to use function the
ability to write functions and C to
create new abstractions not to create
your own little private weird language
likewise macros people tend to get beat
up pretty badly when they use macros I
mean just the way you know like well
seeing the preprocessor
C preprocessor macros that let you write
Pascal and see if you do that in Lisp or
the same bad idea so it's just a way of
creating abstract they don't let you
change the global meaning of a file so
there are a program it's contained so
when you it may be the case that when
you see you know defined binary class
you don't know what that means just from
looking at it but when you see and see
you know foo open paren stuff you don't
know what that means either
either there's documentation or you look
at the source code or you or it's
well-named that's pretty apparent more
or less what it does so it's all it's
really the same problem how do you how
do you write and then and I think it's
actually a better solution in the sense
that it is the macro encapsulate some
pattern like the alternative is
you have you know so to implement 93
parser there's you know a dozen
different constructs in the spec we have
to implement so I haven't defined by in
our class for each of them I if I didn't
have macros I would there's a bunch of
code I have to write out to define a
class I've been trying to read math
imagine to find a right method and that
code all follows very particular pattern
but if I wrote them all by hand I'd
probably there'd be some there'd be one
that would be a little different and
someone comes along and looks at my code
it's like oh that one doesn't follow up
you first of all they have to recognize
the pattern so having recognized the
pattern and put that into their theory
of the program then they look at what
the one that's different they say okay
is that different because some subtle
reason that's totally escaping me or is
that different because that's the right
way all the other ones are wrong you
wouldn't you have no way of knowing
whereas if you have a back row you're
basically putting the stake in the
ground and saying this is the pattern
I've implemented the pattern I'm a 'td
how the pattern should be done
cohdon Alexander and now it's possible
there's a bug in the macro or it's also
possible that someone this understands
how the macro is to be used and there's
a bug in the use of the macro but at
least there's not this sort of slippage
of code you know it's different but who
knows why so it actually makes it more
expressive but we are intent and
therefore it easier to understand when
use well right like you know it is a
powerful tool and people you know if
you're going to be stupid about it like
there's no help for that but you know I
worked at WebLogic in the early days we
had exceedingly good Java developers for
the most part and Java is a very bondage
and discipline language it's supposed to
make it easy for big teams to work
together and we still had code that was
terrible that nobody could understand
and there was no help for it like I said
you know I think your defense on
incomprehensible code is you know
exactly Google's policy of hiring good
developers and
time for this so so yes this is really I
should probably wear I should have
started a little bit
other than what you've executed well so
I don't at the notice okay so the big
success story at the moment and some of
them are getting old agent but so we all
are Paul Graham wrote via web and Thomas
told it to Yahoo for 40 million and of
course that was in the boom time so but
you know he beat out his competitors not
a dog software used common lisp to
basically implement a compiler for the
ps2 and implemented Jack's Baxter and
that like that lisby language
that's sort of probably the laughs I
mean two big projects were done sadly in
the 80s where you know the smallest
machine which list from the chips up so
they were a whole operation stuff
many developers they had working on it
but you know it's ordered and part of
the thing with Lisp is we tend to get
more done fewer developers so there are
a lot of 200 developer projects out
there but
20:18 person team of eligible operating
system from the chips out these inlets
including a sequin could write a secant
line this machine then it's Itamar that
they had in emacs have had networking
stacks to talk to pretty much everything
file system they can interact with every
file system on the planet at the time
those are none
one big one is idea software right orbit
orbits right the website for fair
matching is is largely written
accomplice to pattern matching
algorithms but the question so why does
everyone use it so there's there's three
approaches to that or four there's
there's three wrong wins in one right
one so some people like to go along say
well there must be something
intrinsically wrong with the language so
you can just fix some technical thing
get rid of the parentheses or do this do
that somehow that will fix the
popularity problem I think that's that's
not the answer particularly because this
is the ultimately valuable language
there's almost nothing that you could
want from the language that you couldn't
implement and user land if you want so
the fact that things are the way they
are is do too large for the most part
that's how they ought to be they're
little rough edges and then what's
standardized no one wants to reopen the
ANSI standard so it's not a technical
problem I don't play
it helped me popularity of Java is
helped by the fact that Sun pouring
money into Java and Java is limitation
technology and you know but Python and
Ruby didn't have that kind of money and
they managed to sort of pick up steam
and they're still you know Python is
slow but people use it because chips are
fast now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>