<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Byzantine Agreement | Coder Coacher - Coaching Coders</title><meta content="Byzantine Agreement - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Byzantine Agreement</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xXhnJl4AVg0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello I'd like to thank professor for
the King for visiting us from the
University of Victoria today her
research interest involved randomized
algorithms and data structures
most recently she's interested in
distributed computing and today she will
talk about about consensus problems how
to elect leaders and in a malicious
environment this is a recent recent work
from a stock policy and and other top
conferences and with that Valerie hi
it's really a pleasure really
interesting to be here I have to say in
the lunch is great and thanks for coming
ok so it happened
it happens to be the silver anniversary
of the Byzantine agreement problem and
as I came to this area relatively
recently I I'm gearing this talk to
someone like me who doesn't know very
much about distributed computing so if
you don't know much about the topic
that's fine I'll try to sort of catch
you up a little bit so it's a silver
anniversary of this problem and here's a
famous quote or that sort of started it
all we imagine that several divisions of
the Byzantine army how is the clarity
can you hear me all right see several
divisions of the Byzantine army are
camped outside an enemy city each
division commanded by its own general
the generals can communicate with one
another only by messenger after
observing the enemy they must decide on
a common plan of action however some of
the generals may be traitors trying to
prevent the loyal generals from reaching
agreement strangely enough I read that
it wasn't originally the Byzantine
agreement problem it was the albanian
agreement problem but they decided that
they were real people still people
living in Albania so they didn't want to
offend anyone so they changed it to the
Byzantine agreement so there's nothing
important about the word Byzantine then
doesn't
have to be complicated and that's mostly
Lampert I was working at Microsoft a few
blocks away from here Leslie Lamport is
in the Microsoft Research Lab where I
was so I put his picture up so each
processor starts with a bit and the goal
is that at the end of the protocol will
be some protocol and at the end of the
protocol each each processor must output
a bit the same bit and that bit has to
agree with at least one of the input
bits that one of the good processors
have and now there are also we also
assume that there are corrupted
processors she is always going to stand
for the number of bad processors and
they're controlled by a malicious
adversary meaning that the adversary can
the adversary can control all of the
processor at the same time knowing and
they share information and it's like
having a single centralized mind
controlling the actions of the corrupted
processors and resiliency is the word
they mean to - - it's the T that can be
that the protocol can tolerate and still
succeed so it's the number of bad
processors that the protocol can
tolerate
and it also happens to be the year 2007
the year that Nancy Lynch
when's the Knuth prize for her work on
this problem so two years after the
problem was posed Nancy Lynch and Fisher
and Patterson showed that even if there
is one faulty processor it's impossible
to to have a Byzantine agreement in the
asynchronous model if you all if you
have no randomization if it's a
deterministic so in other words a
deterministic protocol is impossible for
this problem and that her result is
celebrated and I put that in quotes
because every time someone result refers
to this result they always call it the
celebrated result so it's the celebrated
result and it is fundamental in all of
computer science so they say and it
launched a whole field and we'll whole
field of distributed computing came from
this I think ok ok so I Google turned up
Google Scholar turned up 1,200 sites to
this paper or to Byzantine Agreement and
probably it's more by now and there are
millions of many many problems with
models in which this problem has been
addressed and it's really you know for
someone who's new to the field it's kind
of scary to think of all these different
models but I guess you don't need to
know that much to work in it as I
managed okay so for this talk we're
going to be talking about these terms
synchronous asynchronous synchronous
means that you assume all the processors
send their messages in one time step and
then in the next time step they all
receive their messages asynchronous
means that the adversary can arbitrarily
delay or schedule the delivery of
messages and then there are things in
between which we're not going to worry
about in between would say that there's
some time delay but it's a fixed time
delay and
knows an advance in the general case in
the asynchronous case the processors
have no idea how long they have to wait
to get a message they can't afford to
wait for all the messages because it
could be that there's some bad processor
that they're waiting for and he may
never send so you can't they have no
idea there's no time limit there's also
a question of what kind of faults they
all stop Byzantine tell stop just means
that the processor dies Byzantine is
really bad it means that not only does
the processor keep going when it's
corrupted but it sends out bad messages
messages designed to make you think the
wrong thing they make the good
processors think the wrong thing
sometimes they they assume either
computationally bounded adversary which
means that if you have cryptography
there are cryptographic primitives such
that the the adversary can't be assumed
to do that the kind of computation
needed to break the primitives so you're
safe
cryptography works by assumption another
possibility is that you have private
channels meaning that the adversary
can't see what's passed between the
processors and the third possibility and
there's probably stuff in between but
there are a third possibility is called
the full information model which means
that the adversary can see everything
everything that's passed between
processors in the full information model
the only thing that can't be seen is the
private random bits that a processor
might toss a coin and see a private
random bit that causes it to send
something so that the private random
bits can't be seen ahead of time just
the messages and of course the adversary
knows the protocol okay and we're going
to be working in the full information
model so we're gonna assume no
cryptography okay now there's different
coins there's something called static
and dynamic adversary and that has meant
different things for the purpose of this
talk it's gonna mean that the adversary
has to pick
an adversary is static if it has to pick
which processors are corrupted before it
sees any other randomness in other words
at the start of the protocol it has to
decide which processors are going to be
corrupt okay that's as opposed to a
dynamic adversary which can somewhere
later as the program is running it can
pick which ones are corrupt now if
you're going to do leader election pick
a one good processor to be the leader
you better have a static adversary
because otherwise the adversary will see
who's going to be the leader and once
you know it it picks that one to corrupt
okay so you can't have leader election
without some kind of assumption about a
static address or ok message passing
we're going to sue a message passing
model which means that each processor
sends a message to one other processor
that means that the bad guy a bad
processor well it might be expected to
send send the same I protocol might call
for a bad processor to send a message to
the same message to everybody it can
decide to send different messages to
different processes and nobody will know
the difference I mean unless you can
somehow figure out this ok so there are
other things there are other there in
between there are other notions of
dynamic our adversary will be dynamic it
can react it can decide what messages
are going to be sent as the protocol is
going so it's not totally static what it
does is dependent on the messages that
it sees as the protocol is being
executed the only thing that is static
is the choice of the processes to
corrupt it so here I can't hear myself
talk but you guys it's like muffled but
it's clear great oh great this is some
kind of bad thing for the speaker it's a
handicap I guess ok now the other thing
we're going to consider is whether the
network is completely connected or
whether it's a sparse network and we're
going to talk about both coins and
networks we're actually going to show a
result for a sparse network meaning that
each processor only has to talk to in
our case a poly log number of other
processors if there are n processors a
poly log in the number of
okay resiliency I explained we're going
to time in big complexity you could ask
how many bits of information need to be
communicated now believe it or not we're
gonna be talking about randomized
protocols but people actually talk about
quantum protocols now for Byzantine
Agreement but that's beyond us we don't
worry about that
and we're gonna talk about these three
three problems are really focusing on
Byzantine Agreement leader election and
from leader election you also get global
coin tossing if you have a leader that
leader can could toss a coin so you have
a global coin tossing all right so for
all you people who haven't seen this
stuff before like me before a couple
years ago we'll start with an old
protocol in 1983 it's designed to do
asynchronous Byzantine agreement and it
works like this essentially every
processor sends its bit to every other
processor if you have a large enough if
you see a large enough majority of one
value versus another about value then
you send that majority to the other
processors so you have a second round so
over here there's like a second I mean
it's asynchronous the protocol is
asynchronous but there's a you can put a
number in your message to indicate that
you're sort of in a second round so if
you get after you proceed for enough
messages from n minus T processors then
you sort of enter a second round where
you send out the majority if you've seen
a large enough majority you send out the
majority value okay now you'll notice
that you hang you can never wait to hear
from every processor because you don't
know what the adversary has done in
terms of the schedule it could have it
could be that the bad processors the T
bad processors are not sending messages
so you can't wait for everyone to write
back to you you can at most you can wait
for n minus T processors to write back
to you
and when you do that you don't know if
you really got all the good processors
or you're missing t good processors the
adversary could be for you the bad guys
can be writing back to you and the good
guys might be delayed so you're always
missing T responses okay then if you get
a lot of these majorities if you get
enough of these majorities writing to
you so if you get enough of these
second-stage messages so that you know
you're at least getting one from one
good processor then you set up at your
bit to the value of that bit the one
that the majority picked finally if the
majority if you get enough of those
majorities then you're actually going to
decide on that bit and this thing keeps
going and going oh sorry and if none of
this if this doesn't occur you flip a
coin to determine your bit and then you
keeps going and this protocol keeps
executing you keep executing and
executing until you decide that's what a
processor does okay so there's a lot I
want to tell you in this talk so this is
like a 1 minute 1 second explanation of
this protocol I just want to give you a
flavor for what was out there before our
protocols ok so what happens in this
protocol is that there's there's two
points there's a deciding point when
enough people are in agreement enough
processors have this a share of the same
bit and then there's sort of a
maintaining point when when enough
processor is when you sort of set your
bit if you hear from enough processors
that they're in agreement then you set
your bit if you hear from a lot of
processors that they are in agreement
then you decide your bit and in all
these protocols because of the way the
adversary works you you always have to
cat you have you can't be sure if you're
the algorithm the protocol is either is
in two states at the same time some
processors are above this line and some
processors are below this line because
the adversary can arrange this by
sending different things to different
people so if one what you can show in
that protocol the reason it works is
that if one processor decides
to stick to a bit it means that the next
round everybody's going to decide on the
same bit and another bit the other thing
I want to say is that if you've sent
your bit then there's some small
probability that everybody when they
flip their coin is going to pick the bit
you set so all the processors who end up
flipping their coin might might agree on
the same day with probably like one over
two to the whatever however many there
are they might agree on the same bit and
that's when the protocol stops okay so
it takes that kind of exponential you
know exponentially low probability for
all the processes to pick the same bit
and it happens to be the bet that some
of the processors had previously set
their bits to for this protocol to
decide this protocol is an exponential
time protocol okay that was the only
protocol they had for asynchronous
Byzantine agreement in the full
information model now if the number of
bad processors is square root n then the
protocol actually takes constant time
because you know the bad guy can only
enter the adversary can only introduce
square root and deviation so it's likely
that you're going to have a majority
which is off by which which is maybe a
majority by square root n so it doesn't
matter what the adversary does so if so
if there are very few bad fault
corrupted processors this thing will
work pretty quickly all right now in
1985 Branka Branka by the way improved
by Nora's algorithm by increasing the
resiliency he also came up with a way to
to make the whole thing much faster like
log and time and what he did is he
grouped the processors in these cook
what he called committees and they were
small
the only problem so they were small and
they can very feel and the
he designed it he is a method of
designing actually was a random method
of picking these committees so that
almost all of them would contain a
majority of good processors and only a
couple of them would be bad so he sort
of ran it from from a higher-level each
of these would produce a bit and they'd
only be like square root and badguys
square root of the number of these
committees would be bad so now he
reduced it to the case we only have
square root and faulty that process bits
that were faulty that the process of the
adversary would control so that then it
would take constant time from there so
each of these would produce a bit and
then with these fault with only a small
number of faulty ones in the next
another constant number of rounds and
they'd come to agreement the problem is
that in order to do this the bits that
these produced had to be secret the
adversary couldn't know what the bits
were okay so this introduced the notion
of using cryptography or private
channels to do this problem to do this
problem quickly yeah well
each the pets age committee pretty the
messages had to be secret the messages
that they sent to each other had to be
secret okay so this is why I said so
square root end of the total committees
for good and then it would only take all
one time to bring it to agreement an
alternative perspective was Rabin who
assumed that there was the existence of
a global coin toss if you could assume
the existence of a global coin toss and
you could sort of randomly pick a
threshold when you when you didn't come
to agreement and that defeats yeah that
defeats the adversary because the
adversary could play around a threshold
could assign bit so that they're around
a threshold but if you could randomly
choose your threshold and the adversary
didn't know what those random bits
weren't in advance that would defeat the
adversary but that assumed the existence
of a global coin flip which in other
words that everybody would agree on the
same random bit and that there's no way
that's an additional assumption from the
model okay so after this there were two
directions that the research took one
direction was we're going to continue in
the message passing model both going to
use either assumed private channels
we're going to use cryptographic
protocols and we're going to assume that
the adversary can't break these
cryptographic protocols namely it has
bounded it can't do more than polynomial
time computation something like this and
they were able to get an old one
expected time protocol using N squared
messages of communication now on the
other hand there were people who said
okay let's just assume we have atomic
broadcast so in fact we assume away the
Byzantine agreement problem altogether
we assume that every processor when it
writes it has to send the same thing to
everybody so the bad processor can't
tell some people something and some
people another and when you have this
Byzantine agreement is simple I mean
everybody just comes to agreement but
let's try some harder problems let's see
if we can do leader election
let's see if we could do global coin
toss in that kind of context so the
other thing that they assumed is that
the adversary was not adaptive in the
sense that I described earlier that is
it had to pick the bad processors at the
very beginning and now let's see if we
could do leader election okay so these
two went off
this stuff was around 2000 this stuff
actually ended up I guess around 2000 or
so people came up with these or earlier
people came up with these protocols okay
so it for later election the best
there's a tight upper lower bound the
best is log star n with these atomic
broadcasts and that gives you a constant
probability of success okay now I just
want to say one thing I discovered this
lower bound that wasn't so widely known
if you have a randomized protocol to do
Byzantine agreement even if you have
private channels even if you have a non
adaptive adversary even if your
adversary can't even use the messages
that are being sent can't do anything
doesn't know anything has to decide its
strategy ahead of time even if you have
cryptography you always get a
probability of failure which is at least
this the number of rounds raised to the
number of rounds even in a synchronous
protocol okay so if you have a
synchronous protocol you know you have
everything you want you get this
probability of failure so for example
you're going to have a probably
probability of failure of 1 over n a
bigger than 1 over n if you have less
than log n over log log n rounds and
that applies to all the cryptographic
protocols any of the protocols okay so
they have expected time of one these
cryptographic protocols but if you're
looking at the probably of failure it
can get significant and it's given by
this so in other words it's a constant
if you only have a constant number of
rounds all right so
I hope you're all on because I hole up
and tell you sir this is a very neat
method if you don't remember this would
be the thing you take away from this
talk and it's not mine but it's very
neat okay this is fieger's method it's
for picking leader doing leader election
in the broadcast model okay so maybe you
want maybe this would be a good question
for asking people when you interview
them or something you have this
notorious method of interviewing people
so okay suppose you you want to you have
a set of processors and you want to
elect a subcommittee how can you do this
if the adversary can listen to
everybody's what everybody says before
the bit the bad processors can listen to
it everybody says before they say
anything so like you're in the
playground and you say who wants to be
on this team and the adversary the bad
guys can wait until all the kids the
good kids talk and then the bad kids can
then raise their hand and say whatever
they want to say after they heard that
the good kids talk okay that's what's
going on what kind of protocol could you
design well here is a really simple
protocol everybody picks around the
number from one to the number of Bin's
you have to pick one to K now you pick
the group so you have K buckets you look
at the bucket which the fewest people
have picked and that becomes your
subcommittee okay now that's it that's
the protocol why is this so good the
good guys will randomly pick a bucket
the bad guys all they'll do whatever
they can to get into the lightest bucket
but what can they do how many bad guys
will fit into the lightest bucket if
they all pick the lightest bucket it
won't be the lightest bucket anymore so
what happens is the good guys spread
themselves out relatively evenly and the
bad guys can't put too many in the
lightest bucket or it won't be the
lightest bucket anymore so you maybe get
a few more bad guys and you would have
had in the general population but it
will still be relatively balanced
similar in proportion to the number the
fraction that you find in the whole
population okay so that's by Gaslight
it's been protocol if you repeat this
over and over again you you can
eventually get down to one guy and
that's your leader and with with some
constant probability that leader is a
good processor okay so that's pretty
much the protocol his protocol okay and
we're going to be using that protocol
all right so in our work what we're
gonna do is we're gonna take we're gonna
stain the full information model
non-adaptive okay we're going to have to
assume that the adversary picks the bad
guys at the start we're going to solve
these problems and however we're gonna
use them the message passing model we're
not going to assume atomic broadcast and
we're going to show how we can do this
into an agreement okay well we were
aiming for in our research is to get
something that doesn't use too many
messages we didn't we want to get below
N squared messages we want to use poly
log messages pile of bits per processor
of communication and so that we called
scalable maybe I misuse of the word but
scalable meant that each processor was
always sending out a high log number of
bits and we wanted this to take power
long time not exponential time but poly
log time okay so a huge drop in the
amount of time in the full information
model no cryptography everything is
known to the adversary okay so what was
previously known well in the distinct
remodel there was a whole of end time n
rounds there was a T over log n so if n
was to you know n over 3 so it's n over
log n in the asynchronous model nothing
was better than the one I just showed
you
exponential time
all right now the way our protocol works
is simple we just our goal is to get a
small set of a committee just to get a
small set of processors that are
representative of the whole population
that contain good we want everyone took
all the processors to agree on a small
representative set of processors that is
a set of processors which contain a
substantial number of good processors
okay so how can we get all the processes
to agree on this small set that's our
goal once we have a small set this
representative set they can run
Byzantine agreement they can run leader
election you know they can run whatever
they want to run because they're so
small it doesn't take them very much
time even if they use the exponential
time algorithm if they're a log-log in
you know whatever they they're small
enough so that they can spend that time
getting the result so the the main goal
then is to get the number of processors
down to a small representative set okay
so specific results that we have we
found synchronous scalable protocol
which constructs poly log sized
committees with some probability and
then therefore we can do business in
agreement leader election and it the
only thing is that we didn't quite have
Byzantine agreement we could sorry we
got the committee we were able to get a
small committee but we couldn't get
everybody agreeing to it we had to leave
out a small fraction of processors who
didn't know this committee namely about
one over law again at a good fraction of
good processes will left out of the
process so we caught there's something
there's a term for that it was called
almost everywhere agreement we got
almost everywhere agreement and we got
that on a sparse network as well now if
we allow a broadcast if we allowed it
everybody is send and bits to everybody
we would get complete
we just need to tell everybody about it
and then everybody be in complete
agreement but if we restrict ourselves
to only poly log number of messages we
couldn't get beyond the almost
everywhere agreement and that remains an
open problem we don't know if
restricting the communication to poly
log number of bits per processor means
that you can't get everywhere visiting
agreement that's an open problem it's a
fundamental open problem than visiting
agreement no one has ever done Byzantine
agreement was less everywhere with less
than N squared bits ok so we got this
sort of sparse network as well not just
any sparse network we design the sports
Network and we were able to recently get
it for asynchronous the asynchronous
month okay and probably the asynchronous
model is scalable we just never bother
to check that out probably you could I
would guess that you can take our
protocol and make it scalable as well so
not too many bits but then you leave out
a small fraction of processors and
there's also a lower bound but I won't
go into this it's not a great lower
bound it's not what we would have wanted
ok so let me just go to how this
protocol works ok so the idea is that
you reduce the number of eligible
processors until you end up with a small
representative group at the top ok so
there's different stages will you
gradually reduce the number of good for
number of potential members of this
committee and it gets smaller and
smaller ok so key to what we're doing is
the notion of an extractor which is also
called an averaging sampler which is
also called a dispersor so it's a comma
trial object which has many meanings and
as used for many things and it started I
guess it they were invented in order to
do they were invented partly bracha
invented them for distributed computing
and they're also invented to use
randomness extraction ok so what's an
extractor it's a bipartite graph
and you can construct one by randomly
construct by constructing a random
bipartite graph and there's also
deterministic methods of constructing
these things okay and it has the
property that if you have any subset of
bad processors red processors then
almost every node on the top if you look
at the set that's determined by their
neighbors in the fraction of red
processors in it in their neighbor set
is similar to the fraction in the whole
population so in other words you get a
bunch of subsets who which are sort of
representative of the whole population
except sometimes you get some bad
subsets okay so this just happens if you
take a random bipartite graph this will
happen you'll get this kind of thing
okay so you have a little fudge factor
you don't quite have the same fraction
of bad processors you might have a
little bit more alright so now filling
in what our protocol is gonna look like
sorry this is you know I actually used
to do all my slide by hand so this was
like the first slot this I did this
about I know half a year ago or
something and it's kind of messy because
I'm not very good at this I'm getting
better though by the end of the talk the
slides get better anyhow the here you
see an extractor and then what will
happen say these will be the initial
processors
they'll be formed into committees these
each each of these committees will elect
a subcommittee using the fiber
essentially using the Fagor protocol
that will read easily then they'll
output the processors in the
subcommittee the number of subcommittee
the number of processors on this level
will be reduced by a factor of log N and
then the process continues until
eventually at the very top you have a
small committee
okay so for the remainder of the talk
I'm going to talk about what it takes to
do this in an asynchronous environment
and I'm also going to talk about how you
can do it on a sparse Network okay so
we're going to you as I said we're going
to use fighters subcommittee election
protocol to elect a subcommittee but
that was in a broadcast model this is an
asynchronous massive message passing
model okay so if you remember this is
the picture of fieger's algorithm right
every processor picks a pin and you pick
the processors and the lightest pin all
right but there's serious problems to
contend with problem one
first of all we don't have the broadcast
model anymore we have message passing so
you have to wait to hear from processors
but you may hear from one set of
processes someone else might hear from a
different member the adversary can delay
for messages so and you can't wait
because it's asynchronous you can't wait
to hear from everybody so somebody will
hear from one subset of processors
somebody will hear from a different
subset of process and you all have to
agree so you have to run Byzantine
Agreement within this to figure out who
you're actually hearing from and what
they sent problem to you could have the
adversary could be really mean he could
prevent or she or it could prevent
someone from hearing from some prior all
the processes from hearing from some
processor you may never find out the
choice of some processors so in that
case I mean eventually you will but you
can't afford to wait you don't know how
long you have to wait you can't afford
to wait for everybody so you have to
kind of content yourself with actually
not knowing everyone's choices you might
just everybody might just agree that
this processors choice is star
undetermined okay so in fact what we did
is we we said okay let's say you don't
hear from most of the processors still
we can show that you can you will hear
from some constant fraction of
processors so weird we're not going to
know everyone spend choices we're not
going to know most processors been
choices but we are going to agree on
some constant fraction of the processors
bin choices and here this seems to be
the worst possible problem why doesn't
the adversary just decide okay I'm gonna
put my processors in bin 1 and anyone
who chose bin 1 I'm gonna delay okay
what happens then well everyone has to
come to a decision they don't see any
good processors picking bin 1
now then one the adversary arranges it
so that you know just the right amount
go into bin one so that that becomes the
lightest bin and your subcommittee
contains all bad processors okay you see
that's a problem right if you're awake
if you're following my talk which
doesn't sound comprehensible from this
angle so the adversary could arrange
that only bad processors are in the
lightest bin just by delaying all the
other guys so we have a fix to this
problem and I think I think it's
interesting and I'm trying to see I
think it will Fick I think it has a
general application but I'm trying to I
haven't quite figured out what that
general applications okay so what we're
going to do if they're a kay process so
the idea is to prevent the adversary
from using delay to selectively from
picking from from being able to pick to
delay processors based on their bin
choice okay now it can hear all the
messages so how can we prevent this they
say here's what we're going to do we're
going to let's say there are K
processors we're going to run the bin
selection protocol K times and every
time that if you're in round I each
processor is not only going to say what
their choices for round I but it's going
to say what their choices for round I'm
Kate I minus 1 I minus 2 back to the
start so if it ever gets heard the the
all the processors that hear it are
going to learn its choices for all the
previous rounds ok now I claim that
there must be some round J such that the
entire set of prophecies who's those
choices were known for that round is
their choices are also going to be known
for the following round and those
choices are going to be random ok now I
I kind of have to explain why this is
true
all right so here's a table so imagine
that each processor is listening to what
all the messages and it's kind of
putting together this table and it's
saying okay in the first round I didn't
hear from this processor I didn't hear
from this processor as soon as Byzantine
agreements so we all hear the same thing
this processor didn't we don't have a
message for this one we'd all have a
message for this one but we heard this
one picked bin three and we heard this
one pick bin - okay and maybe a couple
more rounds go by I still in here from
this but you know I know this this guy I
now know these and so on so if you
notice the set of these if there's if
there's a store it has to be in the top
it has to be stored from then on right
so the number of star the set of stars
has to be increasing if you have K
rounds the set of stars can only
increase K times so if you have well k
plus one rounds say if you're starting
from nothing then you're going to have
one that's repeated you're going to have
a row you're going to have a row where
the set of stars remains unchanged okay
that's the one we picked we picked the
second time that you have a row where
the set of stars remains unchanged why
do we pick that one there has to be such
a one and although the adversary can
force us to pick one these have to be
independent or somewhat independent
there's if this set is fixed the other
side picked this these can't be these
around somewhat random so they're random
subject to the adversary it's deciding
which we're always going to pick okay so
on this level these bin choices are
going to spread out so the adversary
can't decide that it's not going to it's
going to star all the ones that pick one
because of it did that it would have to
start this one but if it started this
one then this would not be the row we'd
pick because the star would have to be
here too okay so we've restricted what
the iris or you can pick we're kind of
defeated the adversary from from
deciding who to delay based on the
content of the message
yeah because because if the rounds are
not stable then the number of stars are
increasing it's it's a monotone function
so you're going to have stability equal
to at least you know the number of
prosit you there's only K columns if the
number of columns with stars is
increasing then after K time it's got to
stabilize now K in this case is around
could be as little as Polly law a log
log n it's a it depends on how big these
committees are okay so K is not large K
is just the set of the size of the
committee or login depending on how we
well login yeah
choosing that row like makin such that
you don't work so that the legend say
however you can't force you to choose
that
oh poor she to pick her up all we have
to do is delay the same set of
processors if the first time he delays
the same set of processors you are
forced to pick that roll yes then that's
a good row because he can't have picked
those stars by what the message was okay
now to fix the second problem so he
fixed the third problem which seemed to
be the worst problem the second problem
said that we really don't know a lot of
been choices by a lot of processors so
it could be that we actually have more
bad processors than good processors
whose choices we know still if we only
have a small number of good processors
we're able to use extractors to take a
small amount of randomness to pick
something that's good we turn the
extractor on its side and I figure out
how to rotate the image so I have to
write it again with it but it's still as
sloppy as it was the last time and now
we use the random bits that are
generated by the processors in the
lightest bin most of those bits are bad
most of those bits were generated by bad
processors however there's a small
number of those bits a small constant
fraction which were generated by good
processors which means that's enough
entropy so that if I use those bits to
pick one of these sets since so many of
them are good it's enough entropy to
pick a good one
it will likely pick a good one which
means that it will pick a subset of the
original Committee which has the right
proportion of good processors so even
though in the bin I didn't have the
right proportion I can reestablish the
right proportions okay oops that's it I
just put it all together and that that
tower and I'm I mean it's not it there's
one more complication which is that
because
it's asynchronous every processor does
not have the same view of what's going
on is every other process because it's
getting different messages but we can
show that it has enough of the same view
that they will agree on enough of the
same processors in the top committee
that a majority will be good and they'll
get to see and if all those good
processors agree they'll all get the
same information from those good
processors alright and to speed this up
we had a recurse so remember I told you
that the within the FICA Committee
protocol we had a run Byzantine
agreement in order to get agreement as
to what the values of the pin been
choices were so we recursively use our
protocol to do that to speed it up
however this causes the probability of
success to go down alright so that
concludes part 1 and I'm sure I'm
talking a long time how am i any buddy
anxious to run I don't know how I don't
have a I have like nine minutes or some
power when do I start I don't know
there I'll talk for another few minutes
you can chase me often you have a hook
or something okay what happens in a
sparse Network no we don't want to send
messages to everybody we want to be we
just want to send poly log number of
messages to to each processor so this
has never been done before and so we
want to do this what can we do the
problem is that when you get elected up
there and someone else gets elected up
here they don't know they have to know
who each other is to do this election
protocol right they'll have to exchange
pin numbers but they have to know who
they are right okay so all right
so what we do is believe it or not this
is the same diagram you saw but it's
with it it's implemented differently so
for each node that I showed you remember
those bracha committee notes they're
replaced by sets of new processors
and if sets are getting bigger and
bigger so you construct an overlay
Network where you you start off at the
bottom and now to run an election up up
on some level you send messages up
through the network and back down to the
processors that are involved in the same
election okay so if you are involved in
the same Committee election you have to
communicate through a sparse network by
sending messages up and then back down
okay all right so in a single election
you'll have to send messages up and back
through the node that represents the
election this gets a little complicated
and I don't really have time for the
details the problem is that there's a
denial of service attack possible we
consider the possibility that the
adversary will swamp a processor with a
lot of requests or a lot of messages and
the adversary the processor has to know
which one to relay and which one not and
since it can only send poly log number
of bits it has to make a decision so we
have to deal with that problem how to
deal with this denial of service and the
way we deal with it is we construct a
protocol so that you know exactly who
should be sending to you so you only
relay the messages of the people we
should be sending to you and ok so ok
let me just switch to open problems and
conclusions ok there's a lot of open
problems and every day I think of more
of them ok so first of all we don't know
for an adaptive adversary if you could
corrupt processors on the fly there's
nothing better than exponential time in
the asynchronous model but we do know
you can't do better than square root n
there's a lower bound even for
synchronous protocols we don't know if
it's possible to do business in
agreement even with cryptography even
with private channels in less than all
of N squared messages
the rest as I mentioned I think there
might be some general technique for
simulating asynchronous synchronous with
asynchronous but I haven't quite figured
it out
and I also think that the idea of
picking a represent agreeing on a
representative sample might have some
interesting applications but I don't
know what they are an interesting thing
about the full information model is that
you don't need the same kind of
randomness that you need to do
cryptography it's been proved that in
order to do cryptography certain
functions in cryptography you need to
have perfect randomness and you don't
need that for this kind of thing you can
actually take less or less random
sources and pull them together to get
randomness in this model okay and
finally I just want to tell you that the
theory conference stock stock Oh eight
is going to be in Victoria on Vancouver
Island in the spring I'm one of the
local hosts I hope you all come I'd be
happy to see you there and it's really
beautiful and we're all gonna stay at
this hotel
unless you want bail out and stay at a
cheap hotel but that's the conference
hotel so so I hope you'll come and
finally one last thing thank you any
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>