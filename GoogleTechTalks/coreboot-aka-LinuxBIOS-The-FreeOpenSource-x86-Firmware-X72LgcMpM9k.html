<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>coreboot (aka LinuxBIOS): The Free/Open-Source x86 Firmware | Coder Coacher - Coaching Coders</title><meta content="coreboot (aka LinuxBIOS): The Free/Open-Source x86 Firmware - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>coreboot (aka LinuxBIOS): The Free/Open-Source x86 Firmware</b></h2><h5 class="post__date">2008-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/X72LgcMpM9k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone and everyone on
videoconferencing thanks for coming and
for those joining us on YouTube you can
uh or you should hit the continuous loop
button it should be down there on your
screen somewhere it'll be like techno
but it'll make you smarter it is my
privilege to bring to Google today three
guys who've been working on coreboot
ever since it is known as Linux BIOS
several years ago and they're all good
friends and mentors of mine and so we're
going to talk about pretty much
everything up starting with motivation a
little bit of history we're going to
move on to some details we're gonna talk
about testing and it's all gonna be
sprinkled with demos and so without
further ado um mr. Ron Minich Stefan
Reiner and Peter Stuka Thanks thank you
is this working it's good to be here
we're going to give you a real variety
of things and I'm going to start with
sort of the origins and then the
high-performance computing perspective
which initially drove the development we
were lucky enough to go to Pete's this
morning and the first thing that
happened is all the windows-based cash
registers crashed and we're standing
here and he said please wait a second
while they reboot and we all stood there
thinking yes if only I knowing that the
BIOS would wait about three minutes
while it said I think there might be
hardware I can find so you know so what
where did this thing start it started in
1999 I've been building clusters for
about eight years to that point and I
was pretty sick of watching the various
biases do things wrong especially after
power failures so the goal was that
Linux would boot out of flash and we
would kill the PC BIOS because everybody
hates the PC BIOS that's ever had
anything to do with it and at the time
and you know even back then actually if
I existed so if you kind of looked at it
your choice you know what choices you
had there is the nascent efi which is a
proprietary closed operating system it
was extensible it was written in C but
you know the driver thing is always the
killer with this sort of stuff so we
looked at open firmware and you know the
answer to the other three questions is
well fourth fourth and forth and I don't
want to write drivers and forth so that
was kind of flat out and then of course
the ancient and honorable PC BIOS and to
this day the extent
in language for that is 8086 binaries
which is exciting and I don't want to do
that so finally we thought well let's
put Linux in the flash and save
ourselves some work and you know simple
questions do your right leg do you like
writing non Linux drivers when you've
got drivers that already work or drivers
that fail in the BIOS but work in Linux
it's just easier and we talk to a lot of
large outfits now that are kind of
hanging on to this if you've got an OS
that works put it in a BIOS and then it
works now this is this is the we at this
time as Los Alamos National Labs got
about eight thousand nodes worth of
clusters that do this we use Linux as
the bootloader since Linux can mount use
all the Linux file systems without the
bugs that come with other boot loaders
and again the question is do you want to
reset write a whole new set of file
systems in EFI environment or in Forth
and the answer for me was always no so
all those custom entries apply to the
file systems and network protocols and
everything else so it's an endless list
and it's growing
although endless things can't grow but
Linux has the drivers file systems the
command-line interface you understand to
make things get better when the biles
when things have gone south so we use
Linux as the BIOS and Linux as the
bootloader at lanolin and on some
machines we have it Sandia because
there's a you know measured over a
period of about eight years they proven
to be the most reliable and flexible and
fastest way to boot the Machine I mean
it's fun to watch a PC iterate over
three Ethernet interfaces with G pixie
and spend about five minutes doing it in
the amount of time that you can boot a
thousand node cluster because you have
Linux in there and it actually does
things in parallel unlike most of these
biases that come with the machines so in
our in our experience Linux is the BIOS
and Linux is the bootloader always win
and again partly it's the parallelism
you get but also the improved
performance of the drivers
so here's an it here's actually a
real-life example that that I had right
before I gave this talk so cash
registers crashing machines crash so I
had a brand-new oil PC and I had a USB
stick but I just loaded and I connect
the stick to the OLPC and turn it on and
it says oh I can't boot the USB disk and
it says okay and the part I always liked
about that is that everytime anything
goes wrong on these open firmware
machines the first thing they tell me is
that everything's ok and I don't
understand why all right but they claim
it's okay so so the interesting thing is
most of the time the only time you
really want to talk to the BIOS is when
things have gone extremely wrong
Farra thousand ode machine at sandia
once all the notes came up in that
cluster and said no keyboard hit f12
continue so 20 people this is the
keyboard each fanned out to a couple
dozen machines and had to plug in the
keyboard hit f1 and move on right so you
know it's not something you want to
really deal with and usually people
don't really know or want to know how to
deal with it and they probably lost the
manual so in the case that things go
wrong I want a Linux prompt right on the
one a linux shell I want to talk to that
and I want a full set of busybox
binaries while I'm at it and people have
done that we're still doing it today so
the answer other interesting thing and
I've actually used this from time to
time I need to extend the BIOS for some
reason it doesn't really matter why
right I need to extend what it can do
that's actually fairly straightforward
right you in smite this or you mount
that and you're done so you know try and
do that with EFI our open firmware it's
just simply not that easy and with Linux
anything you're used to doing a normal
maintenance works when things have gone
south and you need to you need to get at
the machine and fix it so you know for
our purposes in the HPC world every time
we've looked at this problem the way we
want to do this is put Linux in flash
we've got the drivers and file systems
we at sandia we had a a company well
okay I'll just say it was Apple they
really really wanted us to look at using
Apple servers for clustering we said
that's fine but we want infinite band
and immediate issue was there were no
EFI drivers for InfiniBand now anyone
who's seen Infini man knows that drivers
for that are quite a huge piece of work
and you know not having an infinitive
and driver free if I that is a
showstopper for buying a server is a
real issue if you have Linux in this as
your BIOS it's not an issue at all it
just works so the question is I've got
I've got it I've got a dead PC or you
know a board like this board sitting
here I'm not going to hold it up because
I might break it and and the issue is
how do I get it ready to run Linux right
it's a dead piece of iron there's
there's nothing set up and I've got to
discover configure and enable Hardware
well before PCI that was actually just a
nightmare I mean anyone who remembers
the dip switches on the boards knows
what I'm talking about you couldn't
actually find out how anything was said
but post PCI the theory is you can
configure all the hardware with nothing
having been set up from firmware so
let's think about what boot firmware has
to do it's got a pic a boot device it's
got to do a little more configuration if
configure whatever it's got to find a
boot file DHCP ESF disk whatever mount
it validated and booted every single one
of those steps are easily done with
Linux today it all works fine so you
know again Linux can be your bootloader
and hot-plug was fairly coming we felt
in 99 so that we really felt that we
could just do a few changes to Linux and
make it work as our as our BIOS and
bootloader and so our theory was in fall
of 99 that this is Linux files ok so you
know there's where the kernel goes and
here's where the kernel is up there in
high memory you doing mem copy and jump
ok done
that's the BIOS well there was a little
bit of a tiny problem which I had lost
track of because I hadn't done hardware
for a few years when I got to this point
and that was synchronous DRAM and what I
even now a lot of people well more
people know than used to but when you
turn the machine on the DRAM actually
isn't functional and it isn't functional
for a very long time and what you
actually have to do is find out how to
program it and how do you do that while
you talk to the DRAM but we just said
that none of the hardware is functional
and and actually if you look at the very
very rough and extraordinarily
simplified view of these platforms you
can see up there we've got the CPU and
then
dey's is what we call the Northbridge
and there's the bus to the DRAM but
notice that DRAM modules got two little
blue interfaces and the blue interface
on the right is a serial key prom and to
get to that you go through the CPU the
North Bridge the South Bridge and super
i/o over a two-hour bus called i2c that
was developed by Philips for consumer
audio applications hence another way to
interpret that is not terribly noise
immune in all cases and you asked the SE
EEPROM to tell you about the thirty
parameters that relate the timing of
this DRAM those parameters include
loading nowadays you tune the timing to
100 picoseconds you know this is kind of
a complicated problem you don't have a
stack so but you know to do the most
basic thing you know normally you've got
to get a stack so you can have functions
except you don't have memory so you
don't have a stack you've got to
configure PCI you've got to do I over
i2c thank God it's not USB right we've
never get this done
you've got to read those 30 parameters
you've got to do some computation in the
eight or so registers you've got
available and you know do some minimal
turn-on and set up DRAM and code Linux
so we did all this we did all this in a
couple of months we learned a lot of
things that people had forgotten about
hardware because bios's had been doing
it so long which was one of the most the
most interesting thing about this
project is actually essentially re
educating people about what happens in
hardware and we were actually surprised
to find out how how many things people
including ourselves had forgotten so we
called Linux and it was great got serial
i/o from Linux and it didn't work at all
once we started a do i/o and what we
found then is well Linux has a little
trick it does with PCI devices if they
are not turned on they are soon to have
been disabled so we thought this would
kind of work because the SGI visual
workstation but we were wrong so we had
to do a little bit more and that you
know gets a little more complicated at
this point so we do display in it you
pick the PCI configuration method you do
things with the super i/o because super
i/o is still aren't really enumerable or
discoverable in a straightforward manner
then you enumerate PCI turn on the frame
buffer if you want to enable PCI blah
blah blah you know at some point you've
got DRAM up
so notice we had to set up all PCI
because of just this interpretation that
Linux applies which is very reasonable
right and until we started doing this
Linux had never hit a none configured
platform literally and I it you know I
talked to the Linux guys at the time and
they said we're pretty sure we can
configure a none configured PCI bus but
why don't you try it and let us know and
the answer is no you can't so the next
good fun was with SMP and the first
theory there was yeah BIOS has been
doing it but maybe it's not doing it as
well as Linux might like so we had a
summer student right basically go from
the Intel spec for SMP bring up and
write C code which we plugged into Linux
to do the SMP bring up so you know that
was kind of interesting it was the first
open source C based sort of bring up for
SMPS there is an issue though the Intel
Pentium set the time used the voting
algorithm at power on to pick which one
of them got to run case Evans didn't
work that way the case Evans all came up
running it was your job to stop them in
software so this idea that you would do
it all the way to Linux then figure out
which guys to turn on is kind of flat
out right you can't do that because
they're all on and in the BIOS they're
all busy interfering with each other as
they try and turn on DRM so we actually
had to push that SMP start up back down
into core boot and that actually turned
out to be a good thing a very smart guy
at AMD young high Lew has actually made
the memory in it in the k-8 parallel so
the you know the k-8 there's the
Northbridge in every CPU and he's done
some very interesting stuff and
basically we bring the machines up SMP
and and every once in a while or run
into somebody who says boy wouldn't it
be great if the BIOS were were SMP safe
and we say yes it is great because we do
it you know and we've you you've got 128
gigabytes in a machine and you do a mem
set it's nice to have eight CPUs doing
that rather than one it noticeably chops
down the boot time so you know our
initial model with this was Linux is
going to do everything right we're going
to do a mem copy and jump to the start
of the kernel and we're done and you
know part of that was there used to be a
comment in Linux we don't need those
stinking BIOS which
I think his is or should be gone because
it does now Linux is evolve we've all
evolved and gotten older and Linux
really does actually need that BIOS
there it really depends on it more than
ever for services but at the time it
worked pretty well and part of this was
well what what can Linux not do and then
we got back to well let's let Linux do a
lot of it and certainly a lot more than
Gauss does so where we are today whore
boot proper is a simple payload loader
which is hence part of the reason we
changed the name because it isn't
dependent or doesn't require Linux
kernel in there anymore and then we've
got all these targets we put plan nine
kernel and plan nine loader in firmware
I mean in the flash part and booted that
directly there's a really neat
bootloader project called Philo Philo
can boot your machine whether there's a
BIOS in it or not so it's got drivers
notice though you know we we find
ourselves writing drivers again for for
boot loaders because people don't always
want Linux in there
sometimes the you've only got a quarter
megabyte of flash and in these days a
quarter megabyte is far too little room
for even a compressed kernel mem test 86
is pretty popular payload it's good way
to really ring your memory programming
out then there really are still a lot of
cases where there's a Linux kernel and
flasher or ether boot and we've got a
demo of almost half of those
configurations up here today so the key
thing is we finally own a platform right
I mean anything you buy today that looks
like a PC a lot of things happen you
don't know what most of them are a lot
of people don't know this but a lot of
the BIOS is still actually operational
and can run once you boot at your OS
that should actually scare people who
really care about security right there's
a binary thing in there you don't know
where it came from who wrote it or what
it does and it's running while you're
running and by the way that binary thing
is happy ly able to read any piece of
memory any block on disk and do anything
it wants with the network so you know I
actually started kind of pushing this
message around inside theory and people
are starting to worry about what that
really means the other thing is you know
I try and tell people this all the time
there's a global community of people who
support this code so
when a company said comes to me and says
well boy we don't know how to support a
BIOS that's why we get our huge ball of
assembly code from Phoenix and and hack
on it and say well you know you guys use
Linux don't you you've obviously come to
terms with the fact that there's a
global community of people who support
that same thing applies to coreboot same
same flaw as that applies to any open
source project so we actually have one
one or two vendors pretty heavily
engaged Andy has two guys who do this
stuff full-time so we get support from
them via is contributing code now for
their newer processors so we really have
sort of this growing collection of
people some adventures summit mainboard
vendors and then of course the usual
volunteers like us people who make money
from it in some cases but you really
want complete control and you want it
for purposes of speedy booting security
and control the platform the other thing
that that has changed in coreboot
remember I probably hinted I don't much
like a CPI you can't get along nowadays
without a CPI so Stefan has been
developing open source implementations
of a CPI and system management interrupt
type support code so that is about all I
want to talk about because we have a lot
of actually material to cover I thought
I would do a demo of a core boot base
cluster we built this thing seven years
ago and let me quick switch the demo one
this thing has actually been through the
wars this has been involved in more
airport baggage incidents than I can
name it's got a frequent flyer number
that's not working demo one right oh
well that's okay okay they're getting it
set up basically this has a node at the
top of the disk and then three nodes
that are coreboot nodes that they
quickly boot Linux and I'll be able to
show you how quickly in a minute
well while they're setting that up I'll
show you okay this is running a software
developed by Erik Hendricks who now
works at Google Seattle Phil beep Rock
and you can kind of see we've got two
nodes up and
it actually won't oh I'm sorry it
actually won't well I'm gonna have to
switch it and switch it back I just
reset node zero okay
and it'll actually be a second before it
realizes I've just blown that node away
and I'll mention while I'm doing this
that this is the identical oh yeah
so node zeros down no zeros booting node
zeros up so this is actually the same
software we run on the you know a
thousand node and fifteen hundred node
and two thousand cluster Atlanta land
and other places and you know
observation on the thousand node when we
first built it at boot all thousand
nodes from power on in two and a half
minutes while the you know nodes was
conventional BIOS were busy trying to
tell you that they might be coming up so
what that looks like from the sort of
view point of view of the cluster node
itself this is the serial bus let's see
if this will go so this is kind of you
know this is what our cluster knows
Atlanta look like when they booted okay
and they see the longest step is just
getting that kernel in but the thing is
pretty much up at this point so that's
that's booting the kind of cluster and
as we build Atlanta the thing that would
typically take a little longer is if you
had a mirror net in there because mirror
net discovery and setup takes a little
bit of time but anyway that that's kind
of of how we do these things and where
am I on time I'll do one should I do the
build demo real quick okay so I'll do
one more thing because we do need to we
have a lot of stuff to do
this is kind of a build you know a build
sort of showing you what it likes to
build this thing so I'm going to build
it for qmu and I'm taking a chance here
because of the Dark Angel of demos but
anyway Russ is going to chuckle because
plan nine still builds faster but um you
know so I just oh and I got a near dark
paint oh that's because I've been
hacking on and I put it in a note to
myself anyway um normally that would be
done and then I go upstairs and I would
run it and you know that's a splash
screen because everybody's got to have a
splash screen so you know sort of build
in Bude cycles for this thing are pretty
short unless you had purposely inserted
a comment to make it not build anyway
that so that's sort of the HTC
perspective there's there's been a lot
of use of this in HPC there was a
company that sold only coreboot because
it lowered their maintenance costs they
give you a price discount if you didn't
order a phoenix ram i buy us on your
cluster nodes because they discovered
that it was cheaper to maintain and
support them that way anyway i'm going
to move on Peter's going to talk next do
I disconnect from the laptop and get
moving
and we by the way we are here for a
while if you have questions and you want
to talk to us about things and I'm
actually going to pass around a version
of the mini cluster for you to look at
yes
all right
let me get that be sure to hold it from
the bottom right please please please
grab it on the on the base yes so short
outline Who am I
coreboot competition or review
motivation a bit of technical detail
about coreboot some of this has been
covered by ron already pay loads
important part of the coreboot ecosystem
auxiliary tools that we've encountered
we need when working on coreboot demo
time
some security comments conclusion and
thanks and links I work in Sweden I'm
self-employed consultant I do software
hardware security prefer open-source
embedded stuff I found coreboot back in
2001 when I was working on developing a
set-top box for a broadband provider in
in Sweden we didn't end up using Linux
BIOS as these boots was called at the
time unfortunately but I stuck with the
project and in 2006 there was a
developer meeting in Hamburg where I met
Steven and Ron and a lot of other cool
guys and got involved these days I do
work on flash rom MSR tool Philo a bit
of k-8 in the version 3 bring up support
done some marketing so core boot is the
BIOS replacement as we heard the BIOS
really does only two things today it
does hardware in it and then it starts
up the operating system and provides
these interrupt services for really old
operating systems but all other
operating systems they have their own
drivers ACPI part as Ron mentioned is
still important but not not something we
we can't do so why why do we want to
change this bike or boot the BIOS used
to be a library always called by the
operating system but some stuff happened
and laptops came along since the
management mode was introduced to handle
the suspend or the hibernate how many of
you know what system management mode is
hand-up
ok cool for those who don't then maybe a
short recap here it's a new execution
mode in the 386 mobile CPUs basically
when system management mode enters or
your trigger system management mode
execution comes to a complete stop the
CPU switches to a predefined
state sort of an isolated state run
is this configured handle handler that
you've set up and this can be triggered
by a new electrical signal of course so
that you want to when you close the lid
code runs and saves up your state can
also be triggered by software though so
from Ram axis or io axis and this is
used quite a lot you'd be surprised
after APM came a CPI from our friends at
hewlett-packard Intel Microsoft Phoenix
technologies and Toshiba the version 3
document that I have is 600 pages and
inside is among other things a virtual
machine specified it has its own
bytecode and it runs stuff in the BIOS
so outside the operating system really
outside the operating system yeah at
first they did that but the this virtual
machine and the BIOS was such a
performance hit I've seen the number 5
percent performance lost because of this
that they decided to move the virtual
machine into the operating system and
then Linux this happened around 2001
I've seen the number ninety thousand
lines of code to do this the the fun
part is that it still runs completely
outside the operating system security
model because that's the way it designed
it's designed to work so that's the only
way it can work kind of scary and what
are the the others doing the BIOS is
started out in 78 as a tape drive IO
abstraction layer and in 2008 it's still
there abstracting hardware but it also
does a lot of other things 100 plus
function calls mostly real mode code I
listened to a vendor talk they told me
how they have a really good code base
that's it's 4300 assembly files but it's
modular so it's really easy to work with
I don't know maybe they they yeah I
don't know EFI pretty much an operating
system of its own it has networking
drivers it has various services it's
open they claim because you can get the
specifications and you can write plugins
or applications in this application in
this operating system sorry but you
don't get to see what's going on inside
EFI if you do get access to to that code
you have to
sign a lot of documents saying we're
promising that you will never tell
anyone what's what's really happening
Tianna core the Intel EFI implementation
the code base there is about half a
gigabyte so 250 megabytes compared Linux
kernel which is 50 megabytes there's a
lot of other stuff in this this area
grub and lie low or boot loaders loading
kernel from from disk we we don't really
work with them we have other options
I'll tell you in a minute
red boot is sort of similar to EFI it's
based on the eCos better operating
system it's really common for mostly
smaller systems whereas as you heard
core boot is has a sort of a focus on
large and but it it works really well in
small systems as well as we'll see in
the demo you boot is another boot loader
popular with other architectures maybe
power or MIPS etc so bias replacement
how do we do this coreboot only does the
first part the hardware in it as Ron tol
you and we have a concept of a payload a
separate program that takes over starts
the operating system or runs your
application or does whatever you want
your system to do core boot and the
payload goes into the flash chip and we
have a whole bunch of them of course we
have boot loaders philo boots from local
storage cd-rom hard drives if the boot
GP XE boots from network storage see
BIOS is an open source bias
implementation so you can boot legacy
systems BSD Mac OS X recently Stephan
doing some work dos works fine even
Windows there's open firmware if you
like that if you want the ok message all
the time you can use Linux as a boot
loader also as Ron was talking about
grub 2 will work hopefully someday with
coreboot there's been a lot of work put
into it but it's not yet in the official
grub 2 code it's in a separate repo we
also have utilities that can run as
parallels mem test 36 core info utility
we developed Linux again if you want
that bash prompt or Ash prompt in in
your BIOS so to say then put a Linux
kernel there and in a gram FS and you're
done but what I think is really cool
also is the applications you can you can
make applications into payloads
so we put it in which is a nice game
I'll show you in a bit but U is worth a
special mention also because coreboot
can only start one payload and the
payload can never return to coreboot so
maybe you want a couple of these and
then you need by you by you is a
combined several payloads into one and
you can either get a menu interface
where you choose which one you want to
start interactively or you can script it
so tin 10 by you and Corinne foo they're
all built using late payload which is a
simple small C library that we put
together and a compiler wrapper so
instead of running GC C on your C app
you just run LP GCC and out comes a
payload binary this of course only works
if your application doesn't need
operating system services but if you
have a really simple app this is a nice
way to to get it into a payload and
there's even cursus a small curses
implementation in this package so some
of our accelerator tools we have build
rom good because core boot and payloads
and kernel versions and configuration
and there's a lot of stuff to to keep
track of here build rom is excellent
because you just choose I want I have
this main board I have this big flash
chip I want this version of core boot
and I want this payload go and build rom
goes does everything you need and out
comes this rom file that you can put
into your flash chip make elf image
needed because the Linux kernel can't be
started as a payload just directly it
needs this this small piece of glue so
that's what we use so far NVRAM tool
flips bits in NVRAM it's really neat
because we have a an options file which
describes the NVRAM layout and you can
use this also with factory biases super
i/o to lintel tool MSR tool are all good
for looking at the the state the
registers in super i/o
chips and the Intel chipsets and MSR
tool is a generic tool for any chip with
an MSR
so there's also flash rom which deserves
a special mention it does bios upgrades
for bsd linux solaris and pretty soon
mac OSX - you can do cross flashing a
normal vendor bios tool so okay normally
you have to create this boot floppy
drive if the boot floppy disk and put it
into your system and start up and run
this dos thingy it will check ok you're
running on this mainboard you're trying
to flash this image they don't seem to
match i'm not going to let you do this
because you might wreck your board and
sometimes you want to do that and you
maybe not always want to flash the image
from the vendor so flash rom will check
if your if you're doing this and it will
warn you will let you know that this
doesn't seem to be appropriate for this
mainboard but go ahead if you want to
flash format moment supports more than
hundred flash chips 66 chipsets last
time I looked and twenty-something main
boards which can actually be even more
because mainboard vendors often tend to
just use a reference design make a few
small changes that are unique to them
and the stuff that matters for flash ROM
can be the same across a whole bunch of
main boards and finally pushpin flash if
you're if you're starting to do this a
bit and you want to swap flash chips
around a bit I this is a great invention
that I wish I could trade take credit
for so you take this this cork board tax
and cut off the the metal pin glue it on
there and you have a nice knob or a
handle that you can can move them around
with plus you can color code so demo
time I'm going to show you an Alex board
this is a gol X CPU board 500 megahertz
CPU it's running coreboot version 3 and
it's running Linux from the flash chip
on the screen you can see the serial
console and let's see how it works
so we see coreboot starting up ok the
kernel is is starting up and now we have
some init scripts that are running that
takes a second or two you can trim this
down of course but it's still still
pretty neat and we're done so that's the
first demo and let me switch over to
demo number two
so we should get a signal here anytime
soon yeah here we go okay I I was told
that this might not come across
correctly for the video conference but I
hope you can see it anyway this is
showing the BU payload where I've built
into I've built in three different
payloads I built in the core info system
information payload looks like this we
get some information about the CPU and
about which PCI devices we have in the
config space we have a nvram dump and we
can also look at some coreboot
information we see that this is a PC
engines Alex one seaboard running
coreboot version two I built this in
September so we're done with that we see
that everything looks good we we go to
plate int that was good work so let's
let's have some fun with that and when
we won this game we start Philo
and yeah again the init scripts whoo
yeah
so there we go pretty pretty slick I
think some attack ideas you may have
heard about Jake Applebaum's cold boot
paper which describes how RAM doesn't
really lose all the data after you power
off immediately
so Ramkin or data can remain in RAM for
up to 30 seconds or maybe even longer
depending on on the RAM chip and if you
cool it of course with the core boot if
you have could inject core boot into the
system after a reset you can just dump
out all the data immediately we because
we we control everything that's going on
after RAM in it and RAM in it itself
once remedied and it is done let's read
out what's in there TPM emulation
because we can't wrap Hardware access
you could be running on a system and
your operating system or your app is
trying to do some kind of TPM
verification this is trapped by the SMI
handler in system management mode off it
goes on the network to that other box in
the corner from some big fruit company
and when the response comes back hey
you're running on this fruit box so
let's let's go ahead and run your app as
a member of Kitts of course you can
intercept whatever do movemove hard
drives over to another another system
over the network or do some some fun
stuff with the CPU fans by changing the
speed of the revolutions you can play
play sound or you can force the user to
play tint until they win it and only
then do they get to boot so defense is
pretty much the other way around just
the mirror image you can make sure that
Ram is scrubbed whenever the machine is
started before the machine is shutdown
you can do it in case someone opens the
computer case intrusion detection you
can filter ACPI stuff what what a CPI is
allowed to do and not you can implement
some simple ACLs this device with that
and that serial number has to be
connected before boot is allowed and
virtualization means you that you could
just make sure all your data is
encrypted
so that if anyone comes along and asking
questions hi I don't know have a look at
the machine I don't know
flash lock bits flash chips and chipsets
can be set up so that flash rights
aren't enabled it's it's impossible to
enable them again without resetting the
system and if you do this you're you're
pretty safe and you can of course also
hide Flash content so that anyone who's
trying to access the contents of the
flash chip they get what you hand them
and no offline analysis is possible so
what's the conclusion here there's a lot
of good stuff we have a quick start up
time as you see we have open source code
corbett is GPL the payload is BSD so
that it can be used for all sorts of
applications open source means
auditability of course which is nice
it's written in C as opposed to that
vendor with thousands and thousands of
assembly files we have one source tree
whereas most commercial vendors they
they take pride in having one source
tree per mainboard they they it's not
about gets a feature because you have
this bios out in the field and you want
to make some small change but you don't
want to include all the new stuff that
was done on Susi desktop main boards so
you just take the old tree make this
small change and release a new version
of course that's possible to do with
some some clever version control as well
but I don't know they might not have
caught on to that so the one source tree
we're it's easy to reuse code it's easy
to extend also see is yeah it's so much
nicer to work with in many ways we do
need more testing and for desktop users
I think we have really only one main
board that's that's perfect so far but
many more boards aren't very far behind
they only lack small small things that
no one just has has stepped up to to fix
so ACPI is one of the problem areas
because vendor biases they have a these
ACPI blobs and they are needed for
suspend and resume for example and we
can't use them because there
code and they're the property of the
bias vendor but we're getting some help
writing good to ACPI code of our own
fortunately so there's a lot a lot of
fun stuff going on please please come
talk to us I want to say to thanks to to
David for inviting us here and this is
just a web web biography if if there are
something you want if there's something
you want to check out
so I guess Stefan is up yep
so hi my name is Stephanie Noah I work
for car systems the company I founded in
2005 mainly working on car boot support
and trying to get in contact with
vendors and supporting other commercial
applications of coreboot will be the
second worst VGA here so I used to work
for Sousa a while back during the
initial amd64 part of Linux BIOS back
then and I switched over to due to some
embedded work after that writing
software for the IC trains in Germany
but since that was a very high safety
high security kind of thing
I thought I love to go open source so I
switched completely to coreboot and by
now we're up
it's coming great okay
look
doesn't work
but I can even sit on back
Oh would students
so any questions so far
okay thank you
so the topic I'm talking about this
quality assurance and testing because I
figured if we have something like 100
birds in our tree testing of those
targets becomes more and more important
and this work was actually done two
years ago and was funded by Google thank
you very much for that so why do we need
Quality Assurance
I guess Quality Assurance is very
important for Google as well so you guys
might know even better than I we have an
asynchronous development model we have
something like 100 different main boards
in our tree these days and obviously
since we're an open source project
no developer can test all these
supported systems before making a
check-in so this is crying for breakage
in the tree right and so the system is
also we do code reviews but the system
is also quite complex especially when it
comes to ramp controllers so you can
find all regressions through code
reviews only and like there's a
butterfly effect you change one line of
code in the remanent and a whole number
of members just breaks we've been having
this a couple of years back when one guy
was checking in some stuff overnight the
three o'clock and the next morning we
all got to work like exactly one main
board was still working so we thought
about trying to improve on that a little
bit and this is what we came up with so
we're doing system tests and I think
testing is quite essential in any
engineered product anything were
especially several people work on and
you want to use it in the end and we
want to check whether the software
actually does what it's supposed to do
what it's expected to do but also
testing is considered a burden for
developers for all developers I don't
know
it forces to to have a clear concept of
software development so it's not
actually a burden but we we decided to
go with the first step and do system
tests that look at the whole system at
once as opposed to doing component
testing and we came up with a way we
need to test against formal requirements
so we write the stuff down that we want
to test and we do blackbox testing so
that's the simplest thing to do we just
put a system there and operate what it's
doing and if it does the right thing
we're fine so we wanted to automate all
this stuff because as I said before no
developer can test all these systems
manually look whether something broke
and so to automate we needed to enforce
for enough test conditions where because
we wanted to reproduce able tests and we
also wanted to do regression testing so
new commits don't break old stuff and
yeah we kind of require instant test
results for single revisions so we
immediately went 70 checks in something
in the tree we want like to see the
culprit see what's going wrong so we can
fix it in time and of course we are
trying to reduce the time developers
were would have to put into it
so yeah this was like in 2006 when we
started we kind of had an automatic
build system that was running on each
check in and reports were generated the
URL is actually wrong back then it was
snapshots at Linux files at work by now
it's QA dot Kobudo dork and we used to
ask people before they check in
something please manually test your
changes please run our auto build system
but guess what nobody actually did that
so um yeah our our automated system we
had back then only check configuration
and compilation so this was kind of the
venerable it compiles let's ship it
approach and we really don't want to do
that so this was the old stuff we've
been having you see the locks and so
then we came up thought how do we do
tests so we first built the images
that's a blue box on the top on every
check-in then we generate check-in
reports build reports then we pass those
images into our test system we generate
test reports and those tested firmware
images become good former images so we
offer them for people to download if
they succeeded on a given system yeah
every revision gets tested and single
developers can also put in their
intermediate versions of trees so if
they don't have a hardware at hand they
can sit anywhere in the world submit
their BIOS image say please test this
code based on a couple of notes so that
would work fine and they would get back
an extensive test report with timestamps
and everything of the boot up and yeah
so in the beginning when we made this
concept we actually thought well if we
do this test system we should really
block commits that would break the tree
but imagine that in an open source
project and we been like back then when
we initially did that we had a pretty
slow machine and compiling all targets
like back then 50 main birds would take
almost an hour by now we have a faster
machine which is a dual Opteron and it's
like it compiles 100 main birds in 20
minutes so but still 20 minutes you can
block the repository for 20 minutes and
chicken and so the compilation and tests
are actually running a synchronously and
if you have like a dozen check-ins
everyday or even more blocking the
repository for several hours that's not
an option we can do that also because
the test environment is supposed to help
and not enforce people and not block
people but um we came up with a solution
that it would at least help if we try to
write bleh mails so if someone actually
breaks the tree we would post to the
mailing list and say look at this guy's
code he actually messed up and if he
doesn't fix it please someone back it
out again that's what we're still using
today it works pretty well actually so
here's our test setup works we have
central automatic build system that's
the blue box on the right which compiles
all the images enhance them out then on
the side we have something we call the
test server which is a little box that
controls the actual mainboard we want to
test then we have the the system under
test the sut that's basically the main
work and we talk to the main work with
as simple interfaces as possible so well
we have the serial console e we have
Ethernet and we control the power of the
machine versus a number of other things
that we could potentially do but there
were going for these things for now and
when we really needed one thing for that
that's a reliable firmware update so you
could not log into the machine and just
flash it by us and it would not come up
so you block the test system for another
couple of days until someone manually
fixes it so um yeah the hardware is an
issue if you do BIOS testing so I had to
approve create reproducible results by
actually one way of doing that one
factor is so you have to you
phylla start conditions so all
components are actually controlled by a
USB or Ethernet and we use Paris which
is to really power off the systems so
they come from a code start and don't
have leftovers from former BIOS versions
in there and also the system is supposed
to scale so a single test supervision
server which is actually just a box like
this big it can control many different
systems because everything is controlled
by a USB so you just add a USB hub to it
and it's all low traffic you can I don't
know maybe put 16 main words to one
search box for the remote BIOS updates
there was back when we started doing
this there was a one solution that was
pretty neat actually that's a promise
memory controller sorry um so um yeah it
used to be I don't know how much they
are now but back then they used to be
like $2,000 per device and we planned on
like just at least supporting 100 main
board so that's 200k right there that's
a pretty much way with a beyond our
scope of setting up such a test system
so we came up with alternatives and I
started with micro triggers building a
small custom hardware controlling the
power of the system and attaching this
to a BIOS Savior so the BIOS Savior
would actually that plucks it has two
BIOS chips and there are one on top and
one in the bottom which you can see and
so we control that BIOS Savior via the
small custom hardware and we could also
soft power on and power off the machine
so we with this thing we could also do
in system firmware updates so we could
test our flash ROM utility with that but
time is passed and then our tech group
came along a company in Estonia
producing this very nice device which is
also a memory controller
memory emulator it has an the flash chip
and it contains an FPGA talking to an
LPC bus or to a foam wrap device and
Peter sugar actually built these very
nice adapters so I've been using them a
lot and the with this thing you can use
during development or testing you can
just plug the device on the one end to a
USB connection on the other end right
into a BIOS socket and you can
automatically update your systems at any
time and the nice thing is though like
it's going to hard to produce hardware
and sell them if you're a small company
so this is off-the-shelf hardware we can
just grab it and give it to people
pretty good for power control we
initially used we're looking for a
device that would work in the US and in
you so a lot more people could actually
use that I found the IPS 400 remote
power switch which you see on the
picture as well but that's quite
expensive so we were looking for
alternatives here it's like a calendar
box I don't know 19 inch component so we
found x10 and we found some remote power
strips which you get for like 10 bucks
and of course we can still do the soft
power control so we attach a little
switch electronic switch to like the
reset line and to the soft power of
switch of the Machine ATX power of and
we control it like that so how we
distribute our images
there's the repository on top which is
one of the central built components
there is the auto build system and on
the same machine there's living the
software to manage the testing to
protect process the results that get
sent back and then there are social
distributed components like the systems
under test and the test supervision
servers which you see in the bottom and
they're all connected over the Internet
we try to keep this as simple as
possible because we knew maybe we won't
have internet access to people server
rooms whatever so all that is needed is
an outgoing HTTP connection to coreboot
the door and this is what our test
infrastructure looks like so the core
board images are generated by our
audible tool which is part of the source
tree I actually even use it for
development because it's really simple
to use and you can either build a single
image or images for all main boards and
so so the centralized part of the system
actually can be looked at at QA dot
coreboot or dork I think the test system
is not really running very well at the
moment because I disconnected the last
note a couple of weeks ago as soon as I
come back I'll I'll put some more
systems in there and there you actually
get detailed information on each test
run so that's basically what it looks
like you see like the number of failed
tests the number of succeeded tests
number of failed builds and it tells you
whether its newly broken or if at this
if it has been broken for a while so
these test reports can be used from
monitoring the progress of coreboot so
you see configuration errors build
errors test errors but they can also be
used for debugging which is actually a
pretty interesting thing so the serial
locks I mentioned them before include
time stamps so if we have bottlenecks if
we have suddenly like need five seconds
to boot instead of two we can check the
lock and see okay there's something
weird going on there and we gotta check
that and of course there's the test
results so attached to the help system
so with each test result of a test fails
you get a number of
suggestions what might be wrong so if
you can't copy stuff to ram it will tell
you to check the RAM controller
configuration if interrupts is are not
working it will find that out and tell
you please check your interrupts setup
and it tells you probably this might be
an a CPI problem or it might be a
problem with the MP table or our cue
table those test reports are all XML
files so it's easy to post process them
and I wrote a little theming around that
so they integrate nicely into the Cawood
website or any other website and yeah I
already mentioned that too
we now have non-working BIOS images so
nobody has to create expensive bricks
out of the hardware the image deployment
I think I'll go this real quick so the
the the payload we have a payload
repository which actually allows it to
build different kinds of images with
different payloads so we could build the
images with kernel or with for example a
BIOS emulation or with an EFI interface
whatever and so all this stuff in the
back end this XML also and so yes that's
about it
the stuff that happens on site you need
one supervision server per site or maybe
more if you want to test a lot of main
words and the good thing is all these
systems on our tests they're all powered
on only during tests so if somebody
checks in something new like several
main boards suddenly power on will run
the tests power off again and the tests
will be submitted back to the tests are
running at code or so I've been like
having this in my office for a while
because it's really not running very
like several times a day so in the
middle of the night at three o'clock it
suddenly powers on runs a couple of
tests switches off again and works fine
and yeah one thing to make it simple is
that the test supervision server so the
thing on site is actually pulling for
new code revisions so you don't have to
open the firewall to actually let
something outside go in there and it's
all written in shell scripts and so easy
to maintain that's what it looks like a
small box low power consumption no
moving parts and though when you run
tests the tests are always checked out
together with the actual cord release so
you can add a new component and also add
the test with it with that component to
keep testing up to date the test
framework it's actually written in
Beijing new which is kind of nice but
it's also kind of old back then a couple
of months later I think I found out
about the nice Google framework I will
look into using that for another release
but so far Derek knew is actually
working pretty good and we we use small
hyper programs that we plug into it for
firmware updates power control zero
pencil and we have a well not so
comprehensive amount of 26 tests in the
test system at the moment but now we're
improving on that so we test a boot up
machine State is everything set up
correctly and this the machine actually
usable and we also have an interface to
in Los Lunas ready from a developer kit
so well we can plug in those like ACPI
tests and different machine tests that
intel invented to make our stuff
together with that we started writing I
probably you know compliant test
documentation because some
our customers actually want that so
that's like the interesting stuff versus
all going of course we want to test all
main boards in the tree maybe we will
not reach that state but at least
improve on the number of main boards
that it's really right as we speak it's
zero so it will increase pretty well as
soon as I return and we also want better
integration with the upcoming corporate
version 3 we want to test VGA
initialization on our notes on some of
the notes where VGA actually plays a
role and one interesting topic is also
of course code coverage testing so we
want to see which code is actually run
and which code is actually not run and
we don't do that the only for the stuff
that is running out of RAM but we also
want to do that for the code that
actually initializes the RAM so we
really get a better understanding of the
the quality of our code dinner at this
point again I really want to thank
Google for their support for funding
development of this test system and of
course also for funding our Summer of
Code students this year and last year
thank you guys
before we move on to questions I'd like
to do one real quick demo here it's a
building payload
I always wanted this
on
okay so I want to demonstrate real fast
how easy it is to uh well get your
firmware on so I have here a a checked
out copy of build ROM if you're just
Google for build ROM you'll get straight
to the the source and you can just check
it out through SVN use make menu config
we hijack the Linux kernel build system
do our core boot configuration here I'm
going to use version three I'm gonna
choose my platform I had it set up for
PC engines at Alex 1 dot C and of course
there are a couple more options you know
we got some reference platforms we got
some other main boards etc and for my
payload I'm going to use core info which
you saw earlier it's a utility from AMD
that dumps a whole bunch of cool
information about your machine going to
make it oops huh
make my other window here I'm going to
actually configure core boot itself
rather than the payload oh and I should
probably fullscreen this I'm sorry about
that I don't need to worry about most of
this you know it's kind of like Linux
kernel configuration you go through you
kind of select the options for your
hardware um let's see debugging oops
all this good stuff I'm not gonna worry
about power management I'm gonna select
core info is my payload here so let's
just pretend I spend some time thinking
about that save it and let's see here ok
my payload here was built two different
ways
yeah yeah there are several ways to do
it this is the easiest in my opinion so
I'm just kind of hit make right there
no no funky you know Microsoft compilers
no ancient tools this is all the
standard canoe toolkit and I'm done
my firmware image is right here and
build BIOS and so right here I'm going
to demo it running in QEMU actually I'm
going to demo a something that you can
look up on your own so coreboot QEMU hit
the first link I should hit I'm feeling
lucky and the Dark Angel of demos is
breathing down my neck I hope I am
feeling lucky and we have ready-made
QEMU images here you can get started
right away and we tell you how to
download and configure QEMU and i've
done that here so here we go and we're
up hmm any questions
thank you all for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>