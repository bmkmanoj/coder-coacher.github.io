<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Flow Of Change | Coder Coacher - Coaching Coders</title><meta content="The Flow Of Change - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Flow Of Change</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ouEHuTr4k6s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning thanks everybody for coming
I'm very pleased to introduce Laura
Wingard the vp of product technology
technology at perforce and also the
author of the o'reilly book practical
perforce and she's gonna give us a talk
on branch in emerging and apparently
it's can be as easy as driving the car
so over to Laura thank you thanks very
much Rob soundcheck okay so so one day I
should mention this this talk will
appear on the Google video sites so if
you have any questions that relate
directly to Google technology if you
could keep them until after the talk is
finished thank you um this stock is
gonna go about 45 50 minutes then why we
can have questions for those of you at
home this is about branching emerging
having to do with software development
large software development projects and
how to manage the huge amount of source
code that comes with it and what we're
going to cover here is the difference
between the ideal world in the real
world and the reason I bring up the
ideal world is because often in the real
world we have so many procedures and
methodologies that we apply to software
development processes that we forget
what the original intent was in the
ideal world is an excellent illustration
of what we're really trying to do the
scope of our our discussion here will be
branches of source code we'll see what
those are and modules within branches
and I'll clarify my terminology as we go
along you'll also learn about the tofu
scale the bass line protocol on the
golden rule of collaboration so little
catch words you can take home with you
we'll discuss the myth of merging and
we'll talk about why we don't drive
through hedges and what I'm hoping is
for those of you that are listening and
watching this talk is that you'll come
out of this
with an idea of how to plant plan for
branching and merging in software
development projects and with ideas of
how to simplify existing branching and
merging processes so starting with the
ideal world in the ideal world there are
no bugs everything completes on time
schedules never slip first release is
perfect customers always upgrade when
you asked him to if there were an ideal
world we would have a source code
repository that we could diagram this
way it would start with nothing it would
end with perfect release and in between
would be some kind of development well
in the ideal world where we might make
one release and it's the perfect release
and that's all we'd ever have to do in
the real world the first thing we learn
is one release is never enough because
of the constraints of the eye of the
real world for instance we're not
exactly sure what the target
requirements are or technology changes
while we're doing development what we do
to accommodate the real world is we make
periodic releases so now our diagram
gets slightly more complicated that we
start with nothing we develop develop
develop we make a release but then we
continue developing and we make another
release to get closer and closer to our
ideal world goal of coming out with that
perfect release and whereas in the ideal
world there are no bugs in the real
world of course there are bugs so what
the way we accommodate this real world
constraint is we branch the source code
we're working on and in this diagram
we're showing and we develop a little
bit we have some code that is worthy of
release we branch it so that we can
stabilize it and stabilization is a
euphemism for fixing bugs and now we
have with two branches we can have two
things going on at once development can
continue in a development main line
while stabilization can occur in a
release branch
this allows us to simulate the ideal
world because for the people working in
the release branch it looks to them like
the ideal world of no developers
destabilizing code while they're doing
the stabilization while they're doing
the last-minute bug fixing there's
nobody putting in brand new untested
features and for those people working in
the development branch it also looks
like the ideal world that nobody is
telling them hey you can't touch this
code because I'm trying to stabilize it
for release so branching is a mechanism
whereby we can simulate the ideal world
now they're in the in these release
branches this little diagram shows to
release branches and the ideal and the
release branches we can still make
periodic releases and that too simulates
the ideal world of every branch every
release is perfect
and whereas in the ideal world we have
all the time we need in the real world
we have release cycles that have a
certain duration and sometimes are very
very short and what we can do about it
in the real world to accommodate
extremely short release cycles is to
have what we call staging branches these
are also known as promotion streams and
that is you take your development code
develop develop develop you have
something worthy of release you branch
it into a first branch here for the
first stage of the release cycle you do
something to it in this example what's
happening is some QA is happening some
test testing is happening when that code
has undergone and passed that this
series of tests for example then you
branch it into another branch where a
next stage of release happens in this
example it's the beta release and then
from there of it you know it passes the
beta release you branch it into a into a
live branch and that actually mirrors
what's what's available to the customers
and this is a this is a paradigm that's
often in use for web content development
now what's nice about these staging
branches is that they themselves create
a situation that looks like only three
branches in fact physically it's only
three or four branches here but for each
releasable chunk of product it looks
like there's a new release branch being
created every week or every day been
depending on the frequency of release so
what I'm showing here is here's some
work worthy of release and it goes
through three branches but if you squint
your eyes this is actually just like the
release branch we saw in the previous
slides so we can have a huge number of
these and with only one development
branch and three additional staging
branches it can look like we're having a
branch every week or a branch every day
and the end result of that is you still
have your frequent releases here these
can be coming out every day and you're
doing this with just three branches and
a main branch of main development branch
so again this this simulates this this
this creates the illusion of the ideal
world for the people having to do this
work
and whereas in the ideal world all
development finishes on time as we know
development is subject to the vagaries
of the real world where schedules can
strip slip research resources can
disappear or be constrained so when we
do that in the real world again we
branch our code so that we can decouple
the development projects that have
certain dependencies on each other if we
did all our development in one branch a
development mainline any one project
that got held up could hold up the
release of all the other projects
because all our code is in the same
repository or in the same branch so to
get around that we branch into different
development branches one for each
development project so if one
development project for example we
branched here to do the project X
development that was a very short amount
of development we got finished with it
quickly we delivered the completed
result back into the into the
development mainline project why took a
little longer we didn't complete it
until this point but at which point we
delivered it back into the mainline
projects the still ongoing we we don't
even know when that's going to finish
but it allows us in the development
mainline to still do periodic releases
we're not waiting for the the slowest of
the projects to get done in order to do
a release we can do a release as
frequently as anything is done and again
this creates the illusion of the ideal
world for the point of view for anybody
working in any of these branches if
you're working in the project decks
development branch it looks to you like
the ideal world where you're not being
held up by the slow work in project Z or
in project why because as soon as you're
done your stuff is ready to release goes
into this development main line from the
main line it the illusion is that
everything that's checked in is right
the first time that in the main line
what happens is code gets promoted or
delivered from these development
projects into the main line when they're
complete so you don't see points of
instability in the main line so there is
another
simulating the ideal world where there's
no instability and then for project Z
development branch the illusion there
for the project Z developers is they
have all the time in the world that all
the other projects are not held up by
them and are not emailing them and not
having panicky status meetings saying
you know when are you guys going to be
done and to them they have this nice
illusion of you know their world has a
long release date so when we put all
these together you get this the picture
of what we call the main line model
where we have a development main line
that that is it is a that creates the
illusion of the ideal world where we
would all develop in the same in the
same repository using the same files the
files are only updated when we have
completed work and once once we once we
come up with releasable code that's all
we need to do with it because from from
the perspective of mainline we don't see
what's going on in the release lines
that stuff is is removed from the main
line and we don't see what's going on in
the project line we only see completed
development as it comes into the main
line now changes do happen in all these
branches in the project branches of
course major turning development changes
happen in the release branches bug
fixing happens and somehow all those bug
fixes and all that development has to
get into the main line the certainly the
project work has to get the mail on
because it we're making all releases
from the main line or we're branching
release branches from the main line and
we would like all the bug fixes to get
from the release branches into the main
line so we don't have to fix the same
bugs in many different places or that is
so we don't have to duplicate bug fixing
efforts so this is this is an extremely
simple little simplified diagram of the
main line model and the real world it
doesn't usually look like this it's
usually much more complex here's the
same the same diagram showing these
promotions dreams still changes are
flowing throughout the system
and this leads to the question is in the
question in the real world is this
anything but chaos and if changes are
flowing from branch to branch when you
have hundreds of hundreds of developers
working in each branch release the
schedules scheduled at varying
frequencies and projects galore and
deadlines galore how can this be
anything but chaos and as an example
this is a revision diagram of a single
file in a fairly small system with about
20 branches and 30 revision so this is
just one file in a system of say ten
thousand files so imagine if you had a
system 100 thousand files and you know
300 branches how can this be anything
other than chaos well it's not
necessarily chaos in the same way that
driving is not necessarily chaos and
what we often don't realize is that
driving is an extremely complicated
thing and I'd like to point out that if
any one of you was was called upon to
rush to a customer site or a you know a
development site in another city you
could get on a plane get off the plane
rent a rent-a-car rent-a-car you've
never driven before in a city you've
never been before get in the car get on
the freeway drive at 70 miles an hour
get to a customer site make a bug fix
and you will not have gotten a new
accident you you know haven't really
even put your self in danger doing that
but you make the bug fix and then you're
at a loss to how to merge it into the
main line you have to start looking up
in procedure manuals you know what is
our procedure here get authorizations so
there's this there's this perception
that that merging and everything having
to do with branching emerging is
extremely complicated but it's not
really complicated what's complicated is
that we have to make those decisions
anew because we don't really make use of
protocols and maps and add
as we do with driving so what I'm going
to do in these slides is show some of
the the protocols and maps and
etiquettes attica that I've learned from
customers I've worked with and I'm going
to continue to harp on the the driving
analogy to show that what looks like a
very complicated thing is actually a
simple matter of just following the
protocol at each decision point and it's
it can be as easy as driving so the
first thing that helps is the same way
you orient yourself with a map of roads
and you know that North is on top and
South is on the bottom in managing
branches it's good to think of the tofu
scale fern is on top soft is on the
bottom and so what is this tofu scale
it's a way of assessing the relative
firmness of every branch relative to the
other branches and firmness is a matter
of how much the code has been tested how
much its how big the changes are that
are occurring in it and how close it is
to release and and ultimately the risk
of making a change so each of these
branches has a has a relative rank on
the tofu scale at the very furthest end
we see these release branches and then
there's a little patch branch off of the
release branch in the release branches
code is very much already tested for the
most part this is code that's you know
it's either about to be heavily tested
or it has been heavily tested it's also
either about to be released or it just
has been it has already been released at
the opposite end as you as you go down
the tofu scale at the opposite end you
get development projects where code is
just the opposite much of what gets
checked into development branches it
hasn't been tested it's not even known
to work might not even build it'll be
months maybe even years before customers
see this the results of this code and
somewhere in the middle is your
development mainline neither too soft
nor too firm now one thing you can get
from this is you can see it at a glance
the risk of making a change
so just as you can you can look at a map
of roads and find out you know you can
tell by looking at the map where you can
drive the fastest because you can see
the freeways and you can see the the
surface roads and you can you make a
mental assumption that this is the
difference the same way you can look
here and you can say whoa if I change
something high on the scale high on this
diagram it's going to hit customers
soonest and if i change it look if i
make check that change into a branch
that's low on the scale it'll be a long
time before customers see it but the
inverse of that is if i make a change to
a branch that is high on this diagram
the risk of making that change is
extremely high as well and the inverse
is also true i make a change to any of
the branches at the bottom of the
diagram the risk of making a change
there is not as high and that's because
for these branches on the bottom of the
diagram all of their testing is pretty
much ahead of them whereas for the code
and the software that's in the firmest
branches they've already been testing it
tested and if you make a change you have
to make a choice between two things
starting the test clock all over again
or going out without adequate testing so
that's the tofu scale and that's one way
we we orient ourselves 22 how branches
relate to each other in a in a system
this you can use the tofu scale also to
look at these staging branches you
notice that each branch through the the
development cycle is firmer and firmer
and firmer and then you have your your
live branch from which perhaps maybe
your website is is mirrored and that's
the firmest of all if you make a change
in the live branch that's where your
greatest risk is
um now another another thing we can use
and have to shift around on these slides
don't look at this rate this is what I
want no go back here now a protocol that
helps us that helps us simplify the
whole process of branching and merging
is what we call the baseline protocol
and actually let me go back to this
slide for a moment that this what you
see here is is basically a timeline each
of these branches like the project Z one
branch has a parent which is the project
Z branch but from now on I'm going to
refer to a parent as a baseline because
parentage implies some sort of
superiority and you tend to picture the
parent above and the child below but as
you see once you apply the tofu scale
some parents are below and some children
are above so what we say is release to X
was branched from the main line its
baseline is the main line so it's
baseline is below it the project
branches their base lines are above them
and the reason I want to use the word
baseline is because I want to talk about
the baseline protocol which is an
analogous to driving when you drive up
to an intersection and there's a stop
sign all there is is one little sign and
it says stop but that expresses this
huge protocol depending on you know you
look around you see how many other stop
signs there are you see how many lanes
you are you see whether or not you're in
a one-way or two-way street you see
whether or not there are other cars and
the protocol for stop also includes you
know you put your pedal on the brake you
watch your spit on their me it'll go
down to zero one little sign that says
stop tells you all this it would be nice
if there were something in branching and
merging that we could just see one
little thing and we would know what you
know what we need to do when it comes to
merging a change well there is a
protocol that we can follow the can
simplify things to that level and that's
the baseline protocol
and here's how it plays out so when a
branch is firmer than its baseline if
you make a change to the brook that
branch oh actually let me back up the
baseline protocol first of all change
flows between a branch and its baseline
change never flows between two branches
not connected by the baseline branch
relationship so how and when change
flows is this little table here so if a
branch is firmer than its baseline for
instance a release branch we saw in the
previous slide tends to be firmer than
its baseline change flows from a branch
to its softer baseline continually when
a branch is softer than its baseline is
in a project branch a project
development branch when does change flow
up to its baseline at points of
completion change flows from the
baseline to the branch that is in the
other direction if the branch is firmer
than its baseline release branches are
firmer than their base lines there on
top on the on the toe freescale when
does change flow from the baseline up to
the release branch but we say never
because the whole point of making a
release branch was to create this
illusion that you're coding is done and
now it's time to stabilize this release
so if you're pulling stuff in from the
baseline for instance the main line
you're pulling in new development and
you're defying your goal of having a
release you can stabilize we say never
in quotes because this is a part of the
protocol that's most often violated and
if a branch is softer than the baseline
for instance a project branch is softer
than their their base lines which are
either other project branches are the
main line when does change flow from the
prop from the baseline to the project
branch continually and I will show a
diagram and that brings me to
the baseline map which is a different
way of looking at the at the diagram now
whereas this is a timeline you see all
the branches and their relationship to
their base lines this is a timeline it
shows you pretty much when the branched
happened doesn't show you what's going
to happen in the future this is the same
branch that's shown in a different
different type of diagram which I'm
calling the baseline map this is a
schematic showing which branches relate
to which baselines so project z1 is a
branch whose baseline is project Z
project Z's baseline is the main line
release One X's baseline is the main
line still pain you can use the baseline
map still plot it on the tofu scale and
again remember change flows only between
a branch and its baseline so these
orange lines here are where change can
flow now what you can see is when you
apply the baseline protocol change flows
down continually so for every release
branch here if you make a change in
release 1x that change gets merged into
the main line pretty much as soon as
possible if you make a change in project
why that change goes into the main line
when project why is it at a point of
completion that is when the code in that
branch can be built and tested and
passed all the tests that the main line
requires it to pass then change can flow
from project line into the main line
project z1 that ranch when does that
code flow into the main line never
because you can't jump over that
intervening branch we have to follow the
the branch to baseline routes
but project Z is a little offshoot of
pride project Z 1 is a little option you
to project Z its changes get merged into
a delivered to project see when that
when the work in the offshoot is
completed and so on and so forth an
example an advantage of using a baseline
map over a timeline is that you can you
can actually change the relationships of
branches and I mentioned that you know
the direction of the flow of change
change flowing from a main line up to a
release never happens well sometimes it
does happen and you should actually we
consider that that's the case where you
know you're on the road you need an
ambulance it's not it's not a normal
thing well here's an example of when
that's most likely to occur at one point
the main line was ready to release some
code we branched off release 1 X then
the main line continued to evolve
because a lot more development was
occurring there then we branched off
released 2 X and then the main line
continued to evolve now what's the
relationship now between the code and
release 1 X and the main line there the
code is very different the lot has
happened in between there so what
happens when you have a bug that was
found in release 1x and you fix it there
which is closer to the one xcode the
main line or the release to xcode it's
the release to xcode because this was
branched some time ago before the
mainline had evolved even further but
the problem is if we have to follow
these these routes to get bug fixes you
know to get changes propagated from one
branch to another that's going to be
very difficult trying to branch trying
to merge a change from release 1 X into
the main line and then up to 2x because
of the name because the main line is so
much more evolved but with a baseline
map you can look at it as a guide to the
future so once all this of evolution has
happened you simply rearrange your
baseline is say okay from now on all our
changes in one
we're going to rebase 1x on the to Xcode
line so that as bug fixes come into 1x
its baseline is released to X so all bug
fixes flow from release one to release
to those two two branches are much
closer to each other in content and then
they flow from there into the main line
so this is actually for development this
is great because you've had likely had
to make a slight modification to bring a
1x bug fix up to the 2x code level and
then the amount of work you have to do
to get it from 2x and the main line is
even less if you've already done that
work ok so one thing about this base
line protocol is that if you are in
charge of branches and you have
developers working in branches
developers will come to you and say
that's not fair because there's a bug
fix in a development branch that I need
and I need to get it in that release
right now and why do we have to follow
the baseline protocol and so I I say the
answer is for the same reason that you
have to drive between the lanes and not
drive through the hedges so the driving
through the hedges analogy is your
you're driving along the freeway it's
you know there's a beautiful hedge on
each side and just on the other side of
the hedge is your destination may be a
target store or something it's just a
hundred yards away the freeway exit is
you know three quarters of a mile down
the road in order to get to the target
or you have to drive for three quarters
in my own to the exit drive back on the
frontage road to get into your
destination nevertheless you don't see a
lot of people standing at the side of
the road arguing with high repulsing I
don't see why I can't just drive the
hedges to get to the target store so we
remind developers that a repository
works the same way your source code
repository works the same way you can
branch and merge changes you can merge
changes between arbitrary branches but
in so doing you create a dangerous
situation in your repository
so now I want to look at how the flow of
change relates between release branches
and their base lines and compare that to
how it relates to development branches
and their base lines so here's an
example we saw this before a branch
we're calling release 1x change flows as
we know continually from release 1 X 2
its baseline which happens to be the
main line in this example this helps
with our with our goal of creating an
ideal world because every change we make
to release 1x which is a bug fix of
course trickles into the main line so it
has an improving effect on the main line
so we are achieving our ideal world goal
of having a you know a and a product
with no bugs so every every bit of
progress we make in the release branch
is has an effect on the on its baseline
in this case the main line and as I said
what we what we would like is to have a
well-ordered enough system so that
change does not flow from a a baseline
into a release branch that's because the
whole reason we made the release ranch
was to take a snapshot in time and say
this this is our release this is what
we're going to perfect if we were
letting changes come up from a baseline
into a release branch we would be
defying our ideal world goal but in some
case it's it's it's unavoidable and we
discussed one example of where change
might have to hop over branches another
is we may have branched too early that
we have a body of code we think it's
ready for release we wrench it into a
release branch so we can stabilize it
and then we realize we have actually
more significant development to do and
we might have to pull code from the
front of main line but we again that
should be an ambulance situation so when
you're when you find you've made a
release and you're still pulling code
from the development mainline into a
release branch
it's it's like a stretch of freeway
where there are always ambulances so you
have to wonder what's wrong with that
stretch of freeway that may be a little
redesign would be useful now the
relationship of a development branch to
its baseline shown here is that as we
saw a change flows continually to a
development branch from its baseline and
so any changes in the baseline which are
stabilizing changes will tend to have a
feck taan the development line because
remember changes are coming into a
baseline from their firm or branches so
you've got you've got changes that are
creating even more firmness coming into
firmer branches and notes changes are
trickling down to softer branches so
this has a stabilizing effect on the
whole killed line so all the
stabilization you do in release branch
is actually eventually has a stabilizing
effect on the lowest of the branches the
project branches because of this
protocol that change continually flows
in the downward direction in the
opposite direction when you're going
from a development branch to its
baseline as we said change only flows
when the development branch is at a
point of completion so it's a gated flow
and it's open only when when the code in
the development branch can pass the test
basically that can be applied to its its
baseline and here in our small system we
see the project
the project x branch was whose baseline
is the main line this is a very small
system that there could be more layers
in there so and that brings us to the
golden rule of collaboration if if you
are a branch the golden rule of
collaboration is that you always accept
stabilizing changes and you never impose
destabilizing changes
now when they say change flows from
branch to branch actually change flows
between files and branches as we know in
software development the the the tools
we use operate on files that's the this
is fairly the smallest unit of
granularity for compilers and debuggers
and so on and so forth we can't we can't
put all our attention on an individual
files so we organize them into directory
trees and we put those directory trees
into what i'm calling modules here
sometimes they're called components
sometimes we've got subsystems but
basically what it is is a tree of files
that any tool you use has enough of a
scope to be useful so if you're you know
you're using a compiler the module that
you're compiling is the module that
contains all of the files of the
compiler needs to reference to put
together a you know fully linked
executable or whatever it is you're
building and modules we what we what we
like to do is when we when we take all
of the files in our software system is
divided up into modules this that are
small enough to be as small as possible
that a developer can work on it without
needing any external files and yet still
have all the dependencies to use all of
the tools on that tree sometimes modules
can be nested by the way I mean you
might have some tools if you're just
doing you know if you're working on
documentation you might just have the
actual text of the document module on
disk while you work on that but then
whoever builds the product has that and
combines it with the you know binary
images and whatever go into the product
but the point is that when you branch a
branch you're actually branching a
collection of modules
and when you branch a branch not all
modules are needed in every branch so
here's a main line that might have the
the large collection of you know there's
some total modules that comprise our
software system when we branch a project
a development branch to work on a
project we might only need a subset of
that so what we branch is the the bare
minimum of modules needed to get the
development work done same goes to sub
for sub branches of that we may or may
not need you know the entire subset or
we might even need fewer brand fewer
modules when we branch from our main
line into a release we pick the the
modules that are going to be the target
of the release I mean that the software
that we're releasing so every branch has
some number of modules that live in it
yes sir
so the question is when if you go from X
to X 1 and you need more modules that
are in this project so this would be the
case where you're creating modules is
that correct okay you're mixing and
matching can we talk about this in the
question and answer and we'll go through
a couple other things first I love your
question but it will take it it'll take
a side track and the reason I bring up
modules is because when you look at how
change flows between branches you can
actually narrow it down to how change
flows between individual modules and
then you realize that there's actually
some simplifying rules you can apply so
change flows between any two
corresponding modules you know a module
in one branch change will flow to the
corresponding module and the in the
baseline back and forth we can think of
a few kinds of modules one kind is
private modules and change never flows
between private modules although the
same modules can exist in in a branch
and its baseline and a perfect example
of a private module is a module or a
directory of files that is created by
nightly builds are created by builds
those files are used in the context of
working on the files in that branch if
you're working on the in the project X
development branch there may be Knightly
or periodic builds that create you know
some tree of binaries all your tools
reference that you pull those on to disk
but we never emerge changes back and
forth between the binaries army and the
module and the bin directory and project
X with the bin directory and mainline
what we do is we rebuild them in the
main line these source files may be
merged into the main line the main line
we build our own bin directories so
here's a class of modules that we don't
have to worry about for merging they
exist in all our branches but they are
never the subject of merging they're
also modules that we consider virtual
and these are modules that you bring
along into a branch so that anybody
doing development in that branch can
pull the entire set of modules from the
branch onto disk and have everything
they need to use certain tools like
compilers and
cetera not all of those modules will be
subject to development in that branch so
in the project X branch for example we
may have branched several modules from
the mainline just so we have a complete
reference set of the modules we need but
we're really only working on the X
module for example so here's where our
development occurs but we have this
complete set of modules so that our
tools will work and so that we can
compile and Link product these modules
that we're not working on I'm calling
the virtual modules we could also call
them inactive modules these virtual
modules are essentially mirrors so what
we would like is as we work on these
modules that these modules are
constantly mirroring what's in the
baseline branch and then the modules
were working on are the active modules
these are the modules that were also
that we were submitting changes to
actually the point I wanted to make on
the previous slide is these virtual
modules they are mirroring changes in
the baseline but we're never emerging
changes back and forth because their
virtual we're not making changes here
their changes may be made there that are
just appearing here by one way or
another but we are never having to merge
because we're not doing any changes here
well as well but then when you get to
active module changes are occurring in
both places so a release branch is
typically a situation where you take a
bunch of modules from the main line you
put him in a release branch and then
where were bugs hit you fix that bug in
the release branch and also in the main
line since that's constantly being
updated with new veldt new development
you have a situation where you will need
merges so remember that the in the
release branch change is always flowing
down continually but no change actually
flows up from the main line because
that's part of our protocol no no change
flows from the main line to the release
line so merging only happens in the main
line things come down from the release
branch to the main line things are
changing in the main line because
they're also coming from development
branches so that's where merging happens
now we're project wrenches are involved
we have to weigh change flows in two
directions in in the active module so
now we're getting to the crux of the
situation here this is these are the
things that we're going to have to put
all our work into when it comes to
branching and merging so active modules
in project branches because change is
flowing in both ways in those modules
and they eventually will need merging so
there's a fear of merging or there's a
myth that merging is dangerous and a lot
of times software software projects try
to avoid any kind of merging but the
truth is that merging isn't really any
more dangerous than coding it has the
same it has the same risk as coding you
still need you know merging can can
result in incorrect code you still have
to test it you still have to have a way
to assess whether or not it's correct so
emerging itself isn't any more dangerous
than coding but one of the things we can
say about it in in as much as it is
probably at least as dangerous as coding
is that it should occur in the softer
code lines just as coding should you
wouldn't do any feature development up
in a release code line for the same
reason you probably shouldn't do any
merging up in the release code line and
so in the next few slides we'll see how
how the flow of change keeps us from
having to do any of that risky merging
up in the release code lines so the
protocol that that keeps all this safe
is the merge down and copy up protocol
and that is that as long as changes
flowing down it's okay to merge so if
change is coming from one a firmer
branch into a softer branch having to do
the merge and a softer branch is okay
because the softer branch being the
softer of the two is is more commodious
of the change and there's less risk
involved with doing the merge there when
change needs to go in and out in the
opposite direction for example when
you're delivering completed development
from a project development branch to its
baseline
we copy the files so we never have a
situation where we have to merge in the
firm or branch but of course the only
way we can do that is to make sure that
the project branch is completely up to
date with the baseline so all the
changes have been merged down from its
baseline first then we've done whatever
testing or validation we need then we
simply copy the files back and here is
where an etiquette of branching emerging
comes into play and that is that during
that time when between the time that
wave merge down and we're doing the
testing before we prepare to copy back
the people who are making doing their
work in the baseline which in this
example is the main line have to stop so
that we have time to deliver our
completed code that is copy our code up
into the baseline and how much time is
that it's not very much because remember
changes are merging are trickling
continually from the baseline so any
development project is it's fairly close
you know it's never far from being
completely up to date with the baseline
because the protocol is that changes get
merged down continually from a firmer
baseline into a softer branch so the
amount of time that we need to freeze
basically freeze the baseline in order
to copy these up is very small basically
just enough to do the final testing for
the last increment that we've merged
down so when you apply that those
protocols and the maps the orientation
of the maps and a little bit of
etiquette you see that in fact it's not
chaos it's no more chaos than than
driving on a road because every time you
come to an intersection you know exactly
what to do so every change you make you
know exactly where to make it when you
apply this these rules and you know
exactly how the change has to flow for
one branch to another and you can also
one of the things about this is you
realize it you can look at a diagram
either this the space line map diagram
or you can look at the time line diagram
and you realize that any branch you look
at you can tell what its situation is
relative to the other branches for
instance you know what's what's the
state of project see well I know project
Z has everything that every change
that's been in the main line is in
project see at least for the scope of
the modules that are in project see that
there's no bug fix in the release one
branch or the patch 202 branch that are
not also in project Z if they are
relevant of course because as you know
sometimes you merge and there's no
target file to receive the merge because
so much change has happened another
thing about this system is this this is
a diagram of a whole system of a very
very tiny system but even in the largest
system it's a very regular relationship
between any two any two objects here
that you have a branch and its base line
space line nudity is either softer or
firmer than it the relationship of a
branch to its base line is exactly the
same as the relationship of its base
line to its base line so that the
relationship is very regular and is is
uniform throughout the system
and enough said and I will just
summarize here that to follow on you
know that uniform system one of the
things that we do is is we think in our
minds that we have roughly three kinds
of branches we have the main line we
have released branches and we have
development branches now of course there
are a lot of variations of those but
it's like looking at a map you know we
understand it you know basically two
kinds of roads i would say we understand
freeways and we understand you know
surface roads and we know that there are
different rules that apply to them so
when you look at branches i mean you
know every branch has a rough categories
at a release branch that is is it firmer
than its baseline or is it a development
branch that is it's softer than its
baseline we do our diagrams we use the
tofu scale for diagramming which gives
us an instant recognition of where the
risk is we know that change flows
between a branch and its baseline we
know that when change flows we merge
down and copy up and we know that only
the active modules need merging so that
the amount of merging we're doing is not
as much as it looked like when you look
at the number of branches that we're
working with we know that from the
perspective of any branch we always
accept stabilizing change and we never
impose destabilizing change we know a
bit of etiquette and that is that if
we're working in a branch that we must
yield to delivery of completed
development that if any of the any
branches have our branches the baseline
and they are going to deliver some
completed development we give them a
moment to get their tests in order and
do their copy and we also know that we
don't drive through hedges that's what
we've learned here and so there you have
it the flow of change and I will take
questions now and I want to start with
your question remind me again what your
question was
okay we've main line project x and
project x 1 let's see if we can oops
okay really z and z and z 1 that's right
so when we branch the project Z from the
main line we took a subset of the main
lines modules and then we print c1 maybe
we even just took one module this was
for one little citetrack project here
okay one moment please technical
adjustment here so in order to to assess
the correctness of the work we're doing
in z1 you say there's a module in the
main line we actually need but that's
not an active module correct we're not
changing that module say it is an active
module well in that case what you
probably need to do is branch that from
the main line into project c or rebase
project z1 to the main line so that you
can branch that module into z1 because
if it's an active if it's an active
module it's an active module now there
are the cases where you have shared
modules and this is these are active
modules that are that are mirrored in
each of your development branches but
they are the same module and they're
active so I didn't discuss those on the
previous slides but that those are the
same crime situation now the advantage
of those modules are you never need to
merge them because it's the same module
so this would be a module that exists in
the main line when you're working in
project Z you might have you know maybe
the way your directories are laid out
you might have the illusion that that
branch it that module is in project in
the project Z 1 branch but when you make
changes to it you're actually directly
changing the main line that is one way
to implement a shared module but the
nice thing about shared miles modules is
they don't require merging does that
answer your question ok anything else
yes and then blue blue t-shirt in the
back
changes baseline
22 from the base just a softer project
okay for merging changes from the
baseline to softer projects development
in the stable which and well our project
managers as well your front end result
so are you making it ok so the scenario
is you have a release it's turned at
it's not such a good release thumbs down
and now you need to do development in it
is that your question all right yes so
no new development occurring yes yes
then we these boxes on the baseline to
our 12 yeah I when junior say where our
all the bug fixes and all these boxes
will interfere with our alcohol changes
and where our our content is actually
not working out a lot of change
yeah okay okay I think I get your
question and it has to do with say the
team working on on this project the
impact of change is trickling down from
the firm or branches can be annoying and
and there's there's two factors there is
one is while you're working in your
project development branch you can have
such destabilization that you can't
really merge anything and it's just it's
just extra overhead you can't compile it
anyway why should you merge in other
changes it's only going to break it even
worse I mean it's already broken it's
going to be worse the other is if the
merging is difficult that is you know
you're tearing your hair out saying
please we're trying to develop and now
you're asking us to merge these changes
that's too much work the second thing
this if merging is difficult that's a
symptom of change is not flowing
continually enough because ideally two
kinds of change flow down here bug fixes
that are stabilizing and can only be to
your advantage to absorb into here and
new development that comes up here it's
complete it's tested and now it comes
down here but if not in the modules it's
it's not in your active modules these
were hopefully on separate modules so
these should coexist with yours now
sometimes the actual act of doing the
merges is difficult but that's usually a
symptom of changes getting backed up
analogous to you know traffic jam
sometimes driving on the bridge you know
I'm trying to get across the bridge you
sit in a huge amount of traffic that's
not that's not a symptom of the fact
that the bridge shouldn't be there it's
a symptom of fact that you know the flow
of traffic isn't as regular and isn't it
the load is not distributed as much as
you'd like so is that answer your
question
yes
okay so the case where the reason you're
branching to begin is because the
changes are going to be so significant
here but you can't possibly do them in a
branch where you're sharing with other
developers so once these changes are so
significant why emerge other changes to
it to code that no longer is relevant
and that's it that's a decision you have
to make at merge time so all of your
changes this is actually one thing I
didn't talk about in this talk but you
know merging merging changes from one
branch to another basically can have
three dispositions one is you can
actually do a merge but corresponding
files can be merged another is it might
end up being a copy because the target
files didn't change the third is you
might want to ignore those changes
because they're no longer relevant
you're never going to want to merge them
is that correct is that what you're
getting at yeah so that that's a case
you have to take into account and which
is one of the I mean you know it's one
of the advantages of using a system like
perforce which can actually keep track
of the changes that you evaluate it and
said we don't want these that these are
these are the ignore integrations that
you see in perforce I hope I've answered
your question I'm gonna get a Dan you
had your hand up
James next
you use
right now so so what dan has just said
is that that sometimes an implementation
doesn't necessarily match what you've
seen here but if your implementation has
a regular flow it may be that what
you're doing is you're doing development
in release branches or you're releasing
from development ranches are you you're
you're somehow slightly misusing the
protocol but if you read it you could
normalize what you use your branches for
achieve this same result which is you
know a constant flow small amounts of
changes high quality without actually
making a lot of changes changes to your
system itself you just need to change
the the way you approach merging the
changes anyway according to my clock our
time is pretty much up I'm real happy to
take your questions afterwards and talk
about specifics and thank you very much
for being here and we'll talk afterwards
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>