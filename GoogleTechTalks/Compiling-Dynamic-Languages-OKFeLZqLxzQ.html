<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Compiling Dynamic Languages | Coder Coacher - Coaching Coders</title><meta content="Compiling Dynamic Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Compiling Dynamic Languages</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OKFeLZqLxzQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am Chris Munson I
wiley taaha and his student at Rice
University and I'm pleased to to host
them here today Raj bandopadhyay a is
one of Wylie's students and works on
compiling dynamic languages specifically
in this case Python which is of course
near and dear to everybody's heart and
I'll just leave the rest of the
introduction to him hi everybody I'm Raj
and I'm a graduate student at Rice
University I work with dr. Walley taaha
who's also here and gave a talk earlier
in the this afternoon and with dr. ken
kennedy who's a at rice in the
department of computer science so I'm
here to talk about compiling Python in
particular but also let me tell you
something about the work that our group
does it rise our group is part of work
on what is known as telescoping
languages which is a larger effort to
compile scripting languages like MATLAB
Python are into compiled code and
improve my performance so we all know
the scripting languages nowadays are
pretty big adjust everyone's using them
particularly in scientific computing but
also for you know all kinds of uses and
Python in particular is being used I've
found whenever I turn Python conference
is being used everywhere for things as
diverse as nuclear physics to financial
modeling to everything else so I've been
looking at trying to compile Python for
a for a while and recently in
collaboration with dr. Walley taha we
came up with an interesting approach
which I'm going to talk about today so
we all know the pros of compiling with
our programming with scripting languages
it's easier to do it's quicker it's more
productive and it takes a lot less time
than C C++ and lot less bugs and you
know all those good things however the
conf poor performance compared to see or
Fortran so you always have to implement
your hard difficult code in C C++
Fortran and then use it as a connected
up with as a library or glue it with
Python or the other all these scripting
languages so our goal
our research in general of our group at
Rice is to combine these two we want to
combine the productivity of scripting
languages in my case Python with the
performance of C and Fortran for that
purpose we we try to use a compile
technology available in compilers so
traditionally we try we want to compile
these down to native code now why is
this a problem it's usually a long and
tedious process to write a compiler we
have a lot of language specific
optimizations architecture specific
optimizations so anytime the you know
you want a programmer for a different
platform you to write a compiler for a
different platform your whole compiler
has to change your optimizations have to
change everything explore two errors
bugs requires a lot of testing and yeah
so it's very very platform specific we
propose an alternative way of
programming or writing or compiler so my
talk is not only going to focus on the
specific work for Python the time doing
but also this the methodology that we
are proposing which is to to compile to
write a compiler by partly stealing
their fourth of the functional
programming world so basically we are
going to translate Python to a typed
functional language as an intermediate
and in our case we are going to use o
camel as an intermediate language why
and what are we doing here so you might
think for people who are used to
programming in C C++ Fortran as I was
for a long time functional programming
was kind of this you know interesting
thing but it wasn't really practical we
thought it was too slow and and it was
never going to be used in context where
performance was needed however it's not
not really the case anymore first of all
functional programming languages have
very good memory management runtimes
they have good garbage collection and
automatic memory management systems so
that in fact is perhaps the best reason
to use functional languages as an
intermediate for compiling a dynamic or
scripting language like Python which
relies a lot on garbage collection and
does not expect the programmer to manage
their own memory they have highly
expressive type systems which can
distinguish between boxed and unbox
values can also handle that both
untapped or range of computations
ranging from untyped to statically typed
computations and as well II talked
earlier in his talk about resource aware
programming there are extensions 20
camel and functional probe in the pre
functional programming world which can
help in reasoning and verifying
properties of a language as also for
compiler which can help us in checking
the correct correctness of the compiler
as also the correctness of the generated
code so here these are some of only some
of the reasons we pick a camel as a
specific functional programming language
to which we compile or we want to
compile Python why first of all it's a
widely used language in the functional
programming world it's open-source it's
available on all UNIX distributions it
already has a pretty good native code
compiler and which works on multiple
platforms in the in in the functional
programming world is a strict language
as opposed to lazy which means it's a
call-by-value which come which kind of
corresponds to most of our dynamic
languages such as Python in addition to
being a function language the mode an
important thing is Oh camel also
supports imperative features such as
sequencing so you can put statements in
a sequence side effects by like
assignment you can have a reference type
in o'carroll which allows you to me to
modify values in place which can which q
which can be used to simulate assignment
in part in Python or any of the
imperative language it has exceptions
which allow non local control flow such
as it allows you to break control flow
in the middle of a loop and other allows
you to return from arbitrarily from a
function which traditionally which more
many other functional languages don't
allow also camel has a very standard
extensive standard library which has a
lot of data structures very well
implemented such as lists arrays hash
tables string manipulation it provides
type inference own only we don't have a
need to generate or specify explicit
typing annotations like you know we
don't have to specify like this is an
end we could we can specify specific
types
variables but we don't have to because
the type inference will take care of it
and it's definitely a very easy easy
language to program in that in is that
in itself is a motivation for instance
I've been working for on this compilers
since about three months now and you'll
see how far I've gotten and I can I can
attest that even coming from the C C++
world that this is a great language to
program in just because of its static
typing and easier you know it's very
easy to debug and you know the product
it's very high productivity also another
has very important feature that python
has which people use Python for are the
foreign function interfaces so we use
Python a lot to interface with libraries
and see Fortran and so on and no camel
actually has those features we can okay
it has very well integrated ability or
ability to integrate well with other
languages and libraries so that that is
also a great correspondence with Python
this is not completely new the idea of
using a typed functional language as an
intermediate has been proposed before in
particular there are two projects that
are ongoing work one is the Fox project
at Carnegie Mellon and the Flint project
at Yale University both of these
projects are trying to develop a
standard intermediate language a
standard intermediate type functional
language for a general compiler so what
they try to do is to in addition to
developing a language they also try to
develop type systems which will allow
one to express almost or basically
anything that you might want to compile
so they want type systems that are very
extensive and also focused on safety so
type systems that are very extensive
allow you to express all kinds of
features and also in a very safe manner
however we are we are since we are
compiling dynamic languages like Python
which do not have a lot of static type
which should not have almost any static
type information actually we can do with
a simpler type system so in fact the
types of sim of a language like oh camel
is very sufficient for our purposes let
me talk a little bit about the
challenges that we have in compiling
languages like Python
this will apply to a lot of other
dynamic languages even like MATLAB or r
or whatever a lot of other popular
dynamic languages out there why why a
dynamic language is good because
obviously as we all know languages like
Python are very flexible they are very
easy to use however the variable types
are naked neighbor declared they are
created by binding so in Python you
create a variable basically by assigning
to it so if you want to compile
something completely down to native code
usually you need some sort of type
inference so you'll have to figure out
some at least some information about
whether something is an integer or a
float or all kinds of other types with
Python being object-oriented this
becomes more interesting scoping rules
in Python are kinda interesting it's
largely statically scoped however in
thia in theory statically scoped however
the dynamic features allow a lot of
access so you can change a lot of things
within a cloud for instance within a
class you can change your parents and
base classes a lot of other things and
you can do a lot of stuff within an
environment by bike wearing it and
modifying it which can lead to a lot of
dynamic nature which for which the FedEx
coping may not be complete to define
completely defined also it has nested
scopes you can have nested functions
which and you know scopes like you know
global and local scopes which makes
scoping interesting other other other
problems with dynamic languages object
sizes can change so if you want to infer
say something about a matrix or an array
you not only have to info its ty but
also the size or what kind of elements
it contains and the size of that array
the length of that earlier besides my
matrix let's matrices may have elements
appended dynamically they are the cheap
roll up chief problem in dynamic
languages its memory management so you
have to have garbage collection which is
necessary for ensuring runtime safety
you could write garbage collectors and
see of course and but however a lot of
the times garbage collectors written in
C have to be conservative because they
might have to change pointers and when
you have pointers you can't make a lot
of assumptions
and which is why many existing languages
like Java scheme and the ml family has
killed so functional programming
languages like that or weld statically
typed languages like Java have a lot of
efficient memory management systems
there are some challenges which are
specific to Python for anybody who's
trying to compile Python first of all
there's reflection which means we can
add and delete methods and attributes to
objects very dynamically two in
particular classes then objects may be
queried for type by using a type
function and using the dr function you
can query an object for its contents you
can all in some cases you can also
modify the type and the contents then
function calls it an interesting
challenge because function calls are
very flexible in python there are
positional arguments there are keyword
arguments there are the star and starts
two arguments which gyal off a variable
number of parameters to be passed around
and processing all these can make
function calls quite expensive compared
to a simpler function colum mccann
mechanism exception handling is it's
fast and kind of a standard feature
available in a lot of languages but in
Python you also have a stack trace which
you need which you supply when there is
an exception deletion and I'm
finalization methods so you can
dynamically delete stuff around from the
module or a class and you can also
pickle and Marshall objects using the
representation of an object you see
there is a representation function which
allows you to load and save objects and
pickle them so let me just now that we
have talked about the challenge is in
compiling Python let me talk a little
bit about my implementation of a
compiler this is a work in progress as I
said so there are still a lot of things
that are not a lot of things to be done
and a few things that we have done so
I'll talk kind of given overview of that
so right I'm implementing the compiler
in a camel so I have a compiler that I'm
writing in a camel and I'm translating
Python to a cabin to maintain the Python
semantics which can be pretty
complicated first of all we are basing
my design on the python reference manual
and loosely structuring my compiler on
designing marca texture or based on the
current python implementation which is C
Python which is a standard Python
interpreter so what I the word the way I
do it is I define a base object type
which I will come to in a bit and all
objects which are which is like you know
integer less classes etc and it
instances there instances are copies of
this base object type this object is
implemented this base object is
implemented as a no camel record for the
dictionary which is a very critical feat
component in Python I use a no camel
hash table now for anyone who's used
python you have an idea of how critical
dictionaries are dictionaries are
basically what gives Python its dynamic
nature which allows you to delete and
add attributes to classes and in all the
dynamics stuff that you do so it's very
critical that we have a good dictionary
implementation actually a camel hash
tables that are we have found are quite
efficient for the purpose and they
actually perform quite well for lists
and tuples I use or camel arrays so
these are some of the data structures
that i use for instance i can show how i
implement a typical object your typical
Python object here here for example is a
list object in in my o camel
implementation it is kind of based on
this the C Python implementation of the
type structure and I've chosen to keep
and eliminate some field from that based
on what I think is needed but of course
this will change as my
mendation grows so first of all there is
an object ID which is object identity
now in Python every object has an
identity a type and a value as per the
python reference manual now the identity
can be I mean usually it's supposed to
be the memory location however in our
case so we don't really know if you can
stick to that right now because having a
mem having the memory location as
identity leads to memory management
issues with the garbage collectors so we
decided to for now to just allocate all
have a counter with and every object is
given a unique integer identity every
object that we generate in the system is
given a unique integer identity the
value is basically a no camel data
structure representing whatever the
internal representation of our structure
of our object is so for instance this is
a list so when I create a new list
object and basically creating an array
of in this case of size 0 and this is
basically in a camel constructor is a
defining the type that this is an array
of objects and here is I have a null
object in the system which is basically
a dummy object so I'm creating an array
of size 0 of dummy objects here then
type is also a similar object with a
similar data structure and it represents
the type of this object the list which
will which there is a list type object
representing this type the dictionary is
basically in a camel hash table this is
a list of these classes or base objects
in case of a class this will be the list
of base classes and in case of classes
with multiple inheritance this is this
list is created by using the method
resolution order in Python the c3 method
resolution then it impairs this function
this object is a function it would it
would be a callable object and we
actually have the code for the function
here in this object called field but
this is not a callable so so this is the
is callable here is fall this is a
sequence objects this sequence is true
and this is a sequence this represents a
sequence of length 0 there are some
other fields which apply to specific
very specific objects and represent
particular properties
and this is mostly based on the C Python
description of the type structure so
it's kinda took it kind of follows more
or less the same things so here's the
general architecture of my of my
translator on the compiler as as it is
now so there is a Python code which gets
translated by a pipe Arthur to the pile
a representation of a Python AST now
this representation is basically a no
camel data type and which represents all
the nodes of the Python AST in case of
the parser i currently you know I
general I have an intermediate step
where I use the Pythons see see pythons
parcel to create an intermediate
representation of the st and then go to
my own representation of the AST this is
just so that i started writing a parser
and let's serve completely from scratch
but i found that job it might be
difficult to stick or make sure that I
have the semantics down correctly so
this scientistic with the Python parcel
for now then from the Python AST i have
a transfer my translator convert it to
no camel I know camel EST which is a an
abstract representation of a no camel
program again defined by no camel data
type and this is a step where there are
this is a pretty phallic this is a
pretty complex step where a lot of the
actual work is done then there is a code
generation step which basically just
states though camel AST conversatio
camel coat now this is a runtime
environment that I had to write in a
camel this is this basically is the
Python runtime environment we had to
define all the python-based types and
all the various basic objects like lists
and tuples and all the functions for
Python so this is again a very pretty
large piece of code and which basically
describes all of python it's currently
not of course start of not not complete
but it has more a lot of the Python
basic object hierarchy in there and then
and when I have a camera code I
basically use the existing a camel
native code compiler and linker and
create the final native o camel final
native code for a given platform which I
can run
so during the translation I first have
created a symbol table and scope and
Alice and scope and it buyer and do some
scope analysis to figure out all the
nested scopes and and what are the
variables in different scopes so this is
a complicit kind this is based on the
compiler dot symbols module which is
currently in the sea poisson
distribution and while translating it to
a camel it's pretty straightforward just
work over the st and you have to create
as per the python semantics have to
create new scopes for modules classes
functions and lambda lambda now lambdas
in Python as we know us are basically
shortcuts for function definitions I
don't perform too many optimizations
right now we did not perform any serious
compiler optimization mainly pretty
simple things which again we some of
these some of which are done in the
Python distribution already for instance
a simple optimization is to store the
first hundred integers as objects so if
you will so whenever you refer to the
for any of the first hundred integers
you do not create a new object you just
refer to the existing object in the
runtime then if you have constants in a
program so this is a run that I do just
before generating code if I look I walk
over the asta to find out all the
constants in the program without strings
integers floats and create one object
for / constant which I have in the at
the beginning of the generated code so
in that again in that case we're not
creating multiple objects however there
is enormous scope for serious
optimizations in edible at both the
Python level and the camel level for
instance a simple intuitive optimization
which might which would seem to give a
lot of benefits as constant propagation
because account the semantics of Python
if you're adding two constants even then
save in two integers you'd have to
create integer objects for each of them
I then add them and create a new object
now any cause of memory operations
obviously would be expensive so it would
be great if we could remove some of
those extra memory operations and Jan
derive results at compile time and
substitute and have fewer object
creation at
time of course this optimization in
Python compiler optimizations are much
harder than in languages like C or
Fortran or Java because of the very
dynamic nature of the language which can
strike at pretty much any time in any
way of course we are looking at
currently looking at optimizations that
might be enabled by SSA form and type
inference and we think that these would
be necessary step sort of to do and
before performing any serious
optimizations however this is again you
know kind of where we are at all right
now and we are looking for ideas on how
to do actually implement those so
current status of this compiler most of
the basic object hierarchy has been
implemented by me so I have on all the
basic object I inflow do list tuple
dicks class and most of their properties
implemented language features like loops
ranges sliced web scripts attributes
class attributes operators nesta scopes
Global's exceptions again yeah most of
them have been implemented I believe I
mean for you know I've run it on a lot
of benchmarks a lot of test cases but
you know this definitely i do not i
cannot say for sure that is this has
been exhaustively implemented because
then you know python has a lot of tricky
features which i'll keep discovering and
sorting out as time goes by hopefully
you know get it done as quick as
possible there are some important
features that i still have to implement
for instance right now for functions i
handle positional arguments and keyword
arguments but do not handle star and
star star arguments yet again the way i
do functions is in order to optimize or
speed up function execution whenever a
function is called i check for special
cases the first check if there is only
ok where check for the case where there
are only positional arguments and
positional parameters that it makes a
lot of difference because you do not do
not have to do all the massaging for the
keywords then check for the case where
they're only positional and keywords and
no none of these star and star star so i
do not think that when i implement these
the star star star arguments it will
affect the performance a lot but again
that's just my prediction i do not
implement list comprehensions than
generators so far I have not done
but I do intend to do it then modules
and import is something I'm working on
deletion methods and the one of the most
important things interfacing with C and
other languages slide or the previous
life I beg a pun exact an eval yes I am
this one thank you okay heroes question
was that features in Python called eggs
egg and evil which evaluates allow
eating in power X acute foreign
functions so yes this is on this side
this slide is not yet implemented I
should have covered written that or
consider sorry here are some preliminary
results again I would not put too much
weight on them because I benchmarks are
not that significant tunnel until you
have a complete compiler but still as a
preliminary result it's kinda
encouraging the first all the backside
all the benchmarks except for the last
one are taken from the pie bench suet
which basically has for each benchmark
for instance if you look at identical
random or integer operations it's
basically a bunch of addition
subtraction multiplication stuff on
integers done in a loop and a big loop
and executed multiple lots of times and
so for each of these benchmarks when I
compiled and ran them I found certain
things which helped in speeding it up
which is what the comments indicates for
instance i found that in storing the
first 800 integers helped a lot in this
benchmark for lists the way i'm
implementing list is again similar to
the n optimization done in C Python
where the list is stored as an array of
fixed size but when you need more space
or when you need to set or a store and
element at an atom at an index which is
higher than what you have you just
duplicate that array create a new array
with double the size and use that so
that is something which I the idea which
basically is done in C Python and I kind
of just use that idea tuples I did not
get a lot of speed up because the tuple
benchmark tests a lot of slicing and
slicing is quite an expensive operation
of at least a way of implemented it
loops and if statements do pretty well
but this was only after I too I
implemented the range and X range
function in Python which gives you a
range of intex range gives you a range
of integers which you can iterate over
whereas range gives you a list of
integers which you can iterate over and
function calls speak you get the speed
up only after you consider special cases
dictionary operations something that may
it made a big difference was using a
smaller key size so I'm supposed at
first I was using the entire an entire
object as so if I wanted to look up an
attribute i was looking using so the
entire object as a key for the
dictionary which i change that to use
the object identity as the key and that
made a lot of difference in the speed
the final benchmark is something called
pi stolen so this is a this is a much
more realistic bank or in a complex
benchmark outside where it has a suite
of functions which do different things
some of those functions perform
arithmetic operations on integers and
floats some of those functions perform
copies of classes and assignments and
and deletions assignments to attributes
and retrieval of attributes here I still
do not I have not got as good a speed
speed up as I would like and after
profiling and a lot of study I found
that I do still have some bottlenecks in
accessing accessing attributes and
particularly in setting attributes and
when I also when I create a lot of
objects I am running into some problems
with garbage collection and because a
garbage collection is getting very
enthusiastic in oakham L so I we know
that there are there are some issues
that need to be resolved at this stage
so I'll just give a summary in
conclusion of the ongoing work so far
there are some preliminary results that
are encouraging but but a lot of work
needs to be done I still need to
implement a lot of language feel like
more of the complicated language
features like meta classes and things
like support for modules importing
modules for in function interfaces and
all that need to work on memory usage by
minimizing unnecessary copying and
lookups which is a problem in a lot of
Amick languages but where where objects
are copied many far more expensively
than they should in fact there is a
there is a group at rice who's working
specifically on in place algorithms for
minimizing copying of objects in dynamic
languages and need to look at I need to
look at more compiler optimization
techniques so currently the roadmap for
the next period of time that I'll be
working on this is basically trying to
complete all the field complete the
implementation of all my life or the
language features in Python look at
optimizations for high-performance
translate all that standard library or
path once I have those things I can
translate all the standard library of
Python to native code and I'd be able to
compile more realistic programs in
Python after that and then an external
function in language interfaces so this
is kind of my talk for now and this is
kind of just some ideas and just give
give an overview of the current state of
my work at Rice University so I'd be
glad to take any questions and also any
feedback and ideas that you may have
because I know all the guys are a lot of
you guys use Python seriously so it'd be
great to hear what you guys think of
this work and what you what do you think
I should do yes yes
page say the unity afternoon tea the
optimization a response to the results
you're getting in the first benchmark
right well again it depends on how
programs are used but of course you know
if you're storing I kinda experimented
with us a little bit if you are storing
you know the first hundred integers now
you have to assume make an assumption
that your program kind of uses the first
hundred integers only and doesn't use
anything else of course if you have a
program like that it would help a lot
because then you for every new integer
that you create that you use you
wouldn't have to create a new object so
yeah it will help for some programs it
won't help for Alfred I can't say that
in speed up every Python program in
general because it would depend on the
specific usage I tried again I think the
number 100 is kind of arbitrary I tried
you know thousand and ten thousand but
what happens is that when you start up
the runtime you it there is some
overhead in creating the first you know
this array so again if you're running a
very large program in Python it would
probably have to create even it any even
store an even larger number of integers
but if not yeah yes it's actually yeah
offer one data point you may want to
play with in my pocket GP which is leave
now available for thoughts
you actually get to play with those kind
of how many you want to cash it start
and so on I've experimented pretty
extensively essentially in the field of
computational circle memorial or Italy
because that's what I originally made it
before it's I it's my hobby I believe
our arithmetic computations it so
happens so that's somewhere between 50
and 200 seems to be a pretty sweet spot
for that you don't really gain all that
much further they don't say no that much
getting further solely hundred which I
assume it Greedo I assume you just put
it out of a hat right you didn't do
benchmarking right here made it seem to
give any lucky George this for like that
kind of put a program for you do out a
lot of millions activation sure you'd
like many more but then you're
overwhelming your caches retention tools
Thank You GP you get to play with that
very extensively thank you that
particular optimization yeah let me
repeat what I was just went on so the
gentleman here just said that he has
experimented a lot with his package on
optimizations and he finds a number
between fifty and two hundred is
probably a sweet spot if you want to
store a set of integers in advance 50
and 200 so 100 is a good choice and also
what will he just said reminded us was
that this is not an optimization that I
picked out myself but I kind of got it
from the Python interpreter so C Python
already does at optimization any more
questions feedback yes please project i
started working on this whole thing in
late august and I've been basically
working on this since then except for
Christmas break so it's actually very
considered would be considered a very
good time line for for a compiler writer
so
I do think that writing a compiler and
this methodology is pretty pretty
productive yes seem like a lot of
pythons dynamic features require a lot
of hash table lookup yes that's how it's
what degree is that a bottleneck in the
efficiency you get and to what degree
can you know statically tell that ok
these variables these field that won't
have to do any hash table look-up on the
director excellent question so I'll
repeat the question for the benefit of
all insert of the audience a lot of
pythons dynamic nature comes because for
from I'll due to its hash table because
everything in Python has based on hash
table it's a very important structure so
the question is that to what extent can
we look can we reduce the number of
lookups by statically predicting or
inferring that certain variables are
accessed in certain ways now as I we're
actually talking with hito over lunch
and this and it is this is an extremely
hard problem in particular fault in case
of Python because it is just such a
dynamic language and things can be
modified at any part of a program by
anything else practically so the only
way we can confidently say or do
something like this is performing a
whole program analysis it's very
difficult to analyze things at a class
by class or function by function and say
okay this function will never be
affected by anything else or this class
will never be affected by anything else
unless you perform a whole program
analysis however if by performing whole
program analysis you can deduce that
certain classes of functions are not
touched by external entities then it
would be far more possible to focus on
those individually and then perform some
sort of analysis to say okay this
variable is not modified in this class
or modified at this point and not after
that so we can you know every time it's
looked up after this point we can just
you know we cannot do Ashley will look
up but use a stored value so it will
take a lot of compiler analysis for this
yes
switching compilers like that you
noticed that that the programmer is
using those features to switch to a more
conservative
interesting a point again the question
is have I considered not supporting some
features and making a more connect a
more more restricted compiler which I
use in some cases and using the
full-blown compiler where I know that a
programmer is using certain features
like exec and eval that's definitely
something to look at so far our goal is
to support all the entire Python
language because you know we want to do
that and we want to be partly one we
also want to justify this methodology of
translating it to a functional language
but that's definitely something to
consider in case of performance I'm not
aware of that the question is does a
camel have concurrency primitives I
think well it might be a better beef
exporter do you know about that has some
support for lightweight threats but
there are some limitations with
concurrency in the built in with built
in libraries can't hear
well I learned this repeater Oh camera
some support for concurrent threads but
it's not that completa guess that's in
that's again interesting again the
suggestion is to you know have
multi-threaded emotional is that what
you're talking about having different
threads ok ok I have not looked at the
idea of runtime threads yeah I'm not
considered it but it's definitely
something that I can look at anything
else yes ok that's working I'll take
advantage my microphone holding status
so I noticed you have an optimization
and dictionaries where you use the
object ID I want to use short keys now
in general dictionaries are not keyed on
the idea of the object but rather on a
double under hash function or something
like that and so I was wondering if you
could explain a little more about what
that meant because that seems a little
alarming I guess on the surface well as
far as I mean my understanding of Python
semantics goes that an object once
created does not really change its
identity so the problem that I run into
is when I use when I started hashing or
you know started using dictionaries and
benchmarking the my phone that they were
too slow and the reason for that was
that using an entire object as my
dictionary key was slowing it down
because it was slowing down the hash
function and this may be something
specific to the way of camel implements
it as much as per hash function it is I
can change that I can use that
it looks like what lead one say so yeah
it's so if I understand correctly you're
saying that having the dictionary
lookups being based on the object ID
which ever way it's defined is not
exactly how Python doesn't okay and that
seems to be you know a really
interesting semantic issue that I wasn't
aware of before and it's very likely
actually that Raj also wasn't aware of
it that is probably something that you
know will will make our semantics more
correct I don't think that we were able
to find this in the documentation
probably we could have been able to
discern it from the implementation of C
Python but it's not something that we
knew how it's done exactly until you set
it down so this is very useful
information thank you any more questions
feedback yes
you can have two of them which I'm
supposed to have the same but do you
have different ideas
yes
so what the question is that if I have
if I have two objects with the same
value or representing say they're both
representing the same integer and since
they have been created at different
times how do I make sure that I asked
them to the same place so if if it's a
if there is a constant that is in the
program like you know that if I say X
equal to 3 at some point I have created
one object representing the number three
at the beginning of the program and I'd
refer to that throughout the program had
any any assignments refer to the same
object so but back upon right yeah yeah
I haven't run into that a problem with
that yet but I might that's something I
look at thank you anything else
questions comments yes well right now
I'm the only person implementing this
and Wally there's a bullied and Ken are
my advisors right there and but in terms
of implementation I'm the one doing it I
know it's all me sure you want it that
would be great are you interested in
trying out my stuff that would be really
good that would be really awesome yeah i
mean i I'd be glad to release a version
of my thing on the way it's still pretty
you know incomplete but it works for
what did follow the features that it
works for and I'd be glad to release it
and have it have people tested and try
it out and get feedback that would be
really awesome how could you come to me
and after the talk and talk man you love
to take hey emailed up yes
yet for women in generators no question
Oh question do I have a strategy for
implementing generators yet no that's
right answer you I'll gam it's on my
list of course alright I guess that's it
thank you very much for your feedback if
you want to come talk to me afterwards
if you're interested in trying out the
stuff then please give me your email
address and I'll be glad to send you
whatever I have right now and thank you
very much for coming to talk and call
your feedback</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>