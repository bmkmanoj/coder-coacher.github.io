<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Seattle Conference on Scalability: High Performance Computin | Coder Coacher - Coaching Coders</title><meta content="Seattle Conference on Scalability: High Performance Computin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Seattle Conference on Scalability: High Performance Computin</b></h2><h5 class="post__date">2008-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BRaUbTs_3Gw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and talk to you a little bit about how
we can paralyze a common statistical
tool that's quite popular it's an open
source package called our it's a
derivative of the S language developed
by John Chambers at bell labs it's a
functional language the developers the
original developers of our raw seahawk
and Robert gentlemen drew from scheme
and Lisp for a lot of their inspiration
and creating our it's a functional
language for performing basic
statistical analyses and calculations I
can do things like mean standard
deviation variances and can also do very
complex analyses such as linear models
linear mixed models machine learning
neural nets and other types of
operations most of the complex
functionality is actually provided
through these things called add-on
packages that users develop so there is
a very small core net of individuals
that actually work on our itself there's
roughly 20 or so of these distributed
around the world and then there are
several thousand users who actually
develop additional more complex
functionalities on top of the our
language one of the things about our
that really hurts its performance is the
fact that it operates and serial it
doesn't really take advantage of
multiple threads or multiple computers
if you have advantage have access to
that so revolution can computing the
place where I work we actually create a
product called parallel our and it
allows you to run our in parallel on a
multi-core system or a cluster or
anything else or a grid type system
where a commercial open source company
meaning that we use the open source
version of our and try and sell support
and services on top of that as well as
this parallel computing environment
called network spaces now we're not the
only game in town there are some other
tools you can use there's our mpi this
is a package that's built on top of MPI
it works with your favorite flavor of
MPI openmpi lamb or in pitch provides
most of the functionality in each of
these distributions at the same level of
service meaning that as we saw in Brad's
talk early
this morning you want to use MPI you end
up with code that started out with what
was about six or seven lines of code and
turn it up turn into about 30 or 40
lines of code same thing in our if you
want to run your code in parallel using
MPI are mpi it's going to be much longer
much more difficult to parse and
maintain but at the same time you're
going to have a lot of very coarse
control over your parallel application
and it does require a working MPI
installation there is another package
called our PDM it does pretty much the
same thing as our MPI except it uses pvm
as the communications mechanism the
problem with those is that you really do
have to know a lot about parallel
computing we want most of the people
using our are not necessarily computer
scientists these are statisticians and
most these people just want to run their
analysis faster they don't really want
to become hardcore programmers there is
a subset of them that do but for the
most part these are people that just
want to be able to if they have a quad
core machine at their desktop they want
to be able to run their analysis on all
four cores and have the benefit of the
time benefit of that so we created a
tool and we were thinking about what we
wanted to in a tool we wanted a pipe I'm
assembly something that you could
actually kind of build up the
architecture and then deploy it
something that was very simple to use
self-interaction over time we didn't
necessarily want the user to have to
worry about all the communication
process as we wanted it to take care of
it itself we want to be able to inspect
the state of the system at various times
it mean these are statisticians or
writing code that may or may not work
and they want to inspect what is the
state of various variables within their
analysis over time and it had to run on
mixed environments because sometimes
people have access to a whole grid could
be a heterogeneous type system we want
to be able to allow people to use that
some people also wanted to be able to
call tools and other programs so we want
to be able to allow them that access as
well so we created something called
network spaces it's written in Python
it uses twisted and zope for its
communication it's based on the tuple
spaces concept of Linda so if you use
Linda spaces or Ginny or Java spaces
it's going to use that very same concept
of Communications provides zone
coordination semantics for self
synchronization so it handles all that
itself we can actually inspect the state
of variables using the babelfish tools
that come in soap and it works on
essentially any system that you can
install Python and twisted on so if you
install those two systems you can run
parallel are so to start out the concept
of a workspace this is something that's
very intuitive most people it's a
namespace or binding set it's a process
to coordinate the data and how you
actually access it a network space is
just that same concept except we've
distributed it out over a network but it
requires this communication coordination
system okay these systems the way we've
designed this it doesn't necessarily
have to be heterogeneous and the data
could be remote or it could be local on
the system using a multi-core system so
let's take an example so we think about
just a simple workspace let's define
variable a and let's assign values 1 2 &amp;amp;
3 to it this is going to create a in the
workspace with one two and three we can
retrieve a and so the syntax that I've
used down here is just common our syntax
so I just fit a and it returns the
values 1 2 &amp;amp; 3 hmm requires the data is
local and we can only do this serially
so if I wanted to do something like a
and then to find be it's going to do a
and then be sequentially now if we
expand this to a workspace so we had a
whole network of computers we want to
share this this data / workspace we can
just define a workspace WS and then
store a on that workspace okay so now we
have a its associated with values 1 2 &amp;amp;
3 but now it lives somewhere out on the
net and if we want to retrieve it we can
just say WSDOT fine so we r WS is that
workspace find a and it's
return the value 1 2 &amp;amp; 3 so if we were
to type out a local we would get one two
and three okay and this allows us to be
able to encapsulate our implementation
and again we chose to do this via
twisted ends open Python you can use any
internet based server to be able to use
this its client agnostic so the beauty
of this is we don't necessarily have to
limit ourselves to just are we can write
parallel applications in Python using
network spaces we can write parallel
applications in MATLAB we have clients
for both of those or any other language
that can communicate over the net now if
I had remembered to bring my my dongle
you would have actually seen in a really
neat little video here essentially all
this says is that if we had a client up
here they wanted to store the values
want a value 1 2 &amp;amp; 3 associated with a
it would go into this workspace and then
any other client that can connect to the
workspace could then retrieve those
values by just doing a find what we
would have seen here is that if all
three of these clients had wanted to
request a find of a on this on the from
the workspace but the value a had not
yet been defined they would just wait
and then once we had to find a using the
store mechanism they would have been
retrieved those values and then here we
could have actually stored a whole
series of value sleep we started with
the value 1 2 and 3 and assigned it to a
and then we wanted to sign the value 4 5
&amp;amp; 6 2 a and then 789 to a we could then
fetch them in sequentially and then they
would depopulate a so we can actually
have some kind of blocking mechanism in
here as well okay
so shared access via communication we
actually have some blocking allowing you
to have synchronization of states and
it's all working within this familiar
concept of a workspace which allows a
statistician to write their code in a
way that they actually can understand
they don't have to get down to low
levels of writing a communication
mechanism and coordinating the data is
independent of the code that they write
it's all done by this network spaces
server we have two different types
within network spaces we have a server
type which is where the data lives and
it actually handles all the
communications and then we have an
object which is what's handled by all of
the remote clients and they actually
have a handle on the object it describes
what the server contains what where it's
located and how to communicate with it
so if we wanted to create a network
space outer space this would do it and
then we can actually provide additional
arguments to that Network space allowing
you to change the port for the server
other attributes for the network space
that you may require we have a couple
basic actions these actions could could
be storing fetching or finding so with
storing name can be any arbitrary string
just need to be something that is
appropriate that you can understand
value anything that the host environment
is able of serializing so we can pass
data you can pass functions you can pass
handles to applications as long as the
the host environment is able of
serializing that that object you can
pass it we can remove that value from
the workspace by doing a fetch this is a
blocking operation we can return the
value this is also blocking operation
using find and then we have non blocking
variants of those operations using a try
so you can do a fetch find try and then
the name of the value and those are non
blocking and they just return an empty
value or some other optional argument if
the
the value doesn't exist let's it is
implemented in Python via twisted it is
open source so you can go off to
sourceforge and you can find network
spaces on sourceforge just uses a
general general internet framework the
TCP this is kind of a problem in that
all the wire traffic is is a ski it
allows us to have no Indian issues
allows us to be able to easily debug the
system but what it doesn't do is provide
for security and that is something that
is on our radar it does make things very
simple so we have a very simple syntax
it's easy to implement and because it's
simple we can use any TCP paste TCP
based or enabled system to be able to
communicate so as I said we have matlab
r and python clients right now if
there's something else you would like we
could easily add that into network
spaces i mentioned earlier that you
could view the state of variables so
we're using a babelfish view of our
network space so let's suppose we had
some some values in here we've got a
python and an R babelfish so we've
actually got two different clients
connecting on to our our network space
you're not restricted to just one client
connecting on to it and then we've got
an our place and something we called
snake pit now if we wanted to look at
our place we can see that there are two
values in there so I go back one hour
place you can see it says there are two
variables in there and indeed there are
two variables in our place I can then go
and look at the values of one of the
variables LT there is something called
foo with values 1 2 and 3 and something
called bar with values three two and one
and you can see down here and the our
client I've actually created those
things and it was very simple call to do
that I just said at NWS store network
space a store I gave it the value of the
workspace WS and then the value that I
wanted to be able to store where LT up
here had been defined as that so it's
very easy to monitor the state of your
values
we could also look at more complex
things like as values of rats and snake
bit so we can see other types of data
it's a slot a variable from Python so
that's just network spaces itself but
how do you access this within our we
created a package called network spaces
client for our uses something called a
sleigh this was inspired by the snow
package and are written by Luke tyranny
Michael Lee and Tony Rossini snow stands
for a simple network of workstations
it's just a a way of creating a parallel
computing environment in our using
various transport mechanisms such as MP
eye sockets pvm and you can actually now
create a network spaces client using
snow but we created something called
sleigh it was inspired by snow it
supports something called a parallel
apply as well as other types of parallel
functions apply in in the our languages
is something like a vector operation
it's not really a true vector operation
in a way but it's a way of passing in a
vector argument and then whatever
operation you want to operate on top of
that vector is then and push down into a
much lower level code for speed
performance so you're not having to loop
over that that object within the our
language we've actually created parallel
versions of that so that whenever you
want to use the supply function on say a
vector the process gets distributed out
across the sleigh cluster and then the
results aggregated back and crew push
back into a single object much like you
would get from a regular apply it's
implemented on top of network spaces and
the primary vehicle that we see
statisticians using for accessing the
network spaces and it has very few
assumptions the first is that you have a
correctly configured SSH because it can
use that to communicate with the
different Arno's we are providing some
kind of encryption there but that's only
via the way that we've accessed our and
then we have a utility script that we
with the the distribution so that you
can actually start up this sleigh
service and you don't have the the user
doesn't have to do that itself again if
I had my dongle you would see that there
is a this would have been a nice
animation you would have typed in this
command up here and it would have been
started an ssh F dash X connection to
the different nodes we could have add
each one of these knows request a task
from this the network spaces object
itself and they would have returned the
appropriate values okay so using sleigh
we we have different ways of performing
parallel calculations we can actually
ask each work or to perform some
operation and it may be this we want to
perform the same operation on each one
of the workers we use this each worker
where f is going to be some function
that we want to apply and then the rest
of the values that we pass into that
function follow after it and so this is
going to actually form a single function
operation on top of an entire data
object if we want something to operate
on each element of some object we then
use the each LM function this would form
in parallel then whatever F was on each
element of V we can stop the slave
workers we can also start them back up
again using a similar state start
function and we can have many different
kinds of arguments so we can have a
mixed of decomposed vector and fixed
arguments we can permute we might be
able to permute them to be able to fit
the calling conventions of the existing
functions that they're calling and what
it does is it eliminates the need for
the user to write rapper functions
around various operations within our so
now they can use this each worker in
each LM pass the function name and then
that function name that base function
name and ours and automatically run in
parallel
so why use network spaces it allows you
to have a flow control mode so it allows
statisticians to write code very quickly
very easily we have a asynchronous
non-blocking modes that you don't have
to wait on various applications to
finish we can build up our state using
the sleigh model so we can actually with
sleigh we can actually add nodes into
the sleigh at runtime so you can
actually build up your cluster
sequentially it's ideal for
embarrassingly parallel problems such as
bootstrapping Monte Carlo simulations
Bayesian analysis and we can mix lay and
networks basis to harvest you know the
hard-to-reach fruit so we can actually
mix in many other types of clients into
our and actually run those in parallel
we're not restricted to running only our
applications we can actually run python
and matlab applications from our
consoles and actually with that i'm
ready for questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>