<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Church-Turing Thesis: Story and Recent Progress | Coder Coacher - Coaching Coders</title><meta content="The Church-Turing Thesis: Story and Recent Progress - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Church-Turing Thesis: Story and Recent Progress</b></h2><h5 class="post__date">2009-06-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7XfA5EhH7Bc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody so today we were very
honored to have this thing we should
visit there you agree with Yuri has a
distinguished academic career serving on
the Faculty of universities of
Sverdlovsk Tbilisi Alberta and more
recently Michigan at Ann Arbor he's
currently a principal researcher at
Microsoft Research in Redmond Washington
and understand that his current area is
access authorization languages which is
something relevant to like Public Health
Systems Iran searches about URI on Gugu
which during 21700 results on Yahoo
ninety four thousand four hundred
results and on bing
thirty thousand four hundred results
which is any number you take is
impressive
Yuri published more than 200 papers the
reason I know two hundred because and
here's a home page there are at least
two hundred reference it with free
access to the PDF papers today he's
going to be speaking not about access
authorization but about the
church-turing thesis story and recent
progress
thank you very much thank you for the
invitation so that's the agenda
prehistory of the thesis a story itself
critique and then at the end hopefully
have time recent developments the main
point of which is that we were able to
derive thesis from first principles okay
now to prehistory so I could have
beginning could have start from you know
ancient Greece but let's start from
George Boole who formalized
propositional logic he was speaking
about the laws of thought then a German
logician Frigga try to do a similar task
but much more challenging
a much more challenging task to
formalize predicate logic and he
published keyboard very hard published
books and then one day this particular
day June 16 of 1902 here is Bertrand
Russell sent him a letter a very short
letter it starts
dear professor friggin I'm like you know
your work a couple of pleasantries and
then he says well there is this a little
bit of a problem and here is the problem
so let's define a collection of set I
call it R in honor of Russell an
arbitrary set s belongs to R if and only
if s does not contain itself okay this
is logic and this second are syntaxes
are what semantics is s in any case s
belongs to R if and only if s does not
belong to s now you may say no set
contains itself that's fine now we
substitute R for s and we get our
belongs to R if and only if R does not
belong to R it is common to call it
politely paradox but it is a blatant
contradiction within the formal system
of friggin as far as I know friggin
never published another line
now Russell himself together with Alfred
Whitehead proceeded with a similar
attempt in in 1910 1913 they published
three volumes of one of the most famous
and most boring books in of 20th century
so the idea was you take particular pure
logic axioms and rule of inference and
the ambition is to derive all
mathematical truths from from in that
system and it was enormous work they
wanted to publish yet another volume but
but or just exhausted
and it takes just a lot a lot of work
just to keep the machine going so the
theorem that one plus one equals two
appears in the second volume formulated
and proved in the third one nevertheless
for experts seemed obvious that what
they're doing is doable
so they formalized much of arithmetic
and some other parts of math they wanted
to do more but it was clear to experts
that you can go on and formalize more
and more they avoided paradoxes like the
one I showed you Russell's paradox there
is a number of other paradoxes of that
sort unknown they avoided them using
type theory it is that same type theory
that today used in programming theory
in programming languages that's the
origin of it so in the bottom there was
first-order logic where you speak about
elements which by themselves and not
sets you know people in this room on the
second level was like second-order logic
where he could speak about sets of
elements on a third level was third
order logic where I could speak about
sets of sets of elements and so on even
though people were more or less
convinced that mathematics can be
derived there the question remains can
it can you derive all mathematical
proofs within principia and then Kurt
gödel burst births into into the scene
the greatest logician of 20th century in
twenty nineteen twenty nine paper
he showed that as far as first-order
logic is concerned whatever mathematical
truth can be expressed it can be proven
so any statement in further logic which
is true is also probable
a couple of years later he published his
most famous result that this is not true
for Principia and in fact for any other
sufficiently rich logic system for any
such logic system there are sentences
which are obviously true and yet
unprovable so this this second result is
the most famous and one can speak about
a long time but it would be a different
lecture the first result is more
relevant to our story earlier in 1928
David Hilbert speaking on internet on
one of the congresses of mathematicians
posed the following problem he says okay
take a formal system like Principia or
first-order logic every statement is
presumably true or false can you find an
algorithm or so not find an algorithm
which establishes which is it is the
given sentence true or false the girdle
girdles 19th 31st result showed that
certainly you cannot do it for principio
or in your other Lodge reach system
because the truths are not even provable
there but for the first order logic the
question sounds very meaningful you know
all through things are provable and so
the question becomes very well posed I
give you a sentence in first order logic
is it provable or not and it is that
question that caught the attention of
along the church and Alan Turing and
that's the end of prehistory in the
beginning of our story
Church was fascinated fascinated by
lambda notation I think you all know
what lambda notation is here is a simple
example so suppose you write a plus X
square the intention is that X is
variable and a is a constant but you
know when you deal with mathematicians
you never know a seems to be a constant
next thing he will take the table will
take a derivative over a so how to
indicate that yes a is constant and X is
variable and that's what is lambda for
you say lambda X and that shows that
lambda is considered to be variable so
in this case a plus X lambda X a plus X
square is a function of X if you
substitute to 2 you get a plus 4 so
church's ambition was to develop
foundations of mathematics on on that
lambda notation so by that by that time
the most standard foundational system
was set theory and he wanted that notion
of a function rather than a set would be
the basis for foundations so he
developed a formal system and he had two
very good students Stephen Kleene and
Berkeley Rosser who became quite
well-known with logicians in their own
right and there was a bit of a danger of
having such a good students he asked him
to work on his system and they
demolished it they proved that the
system is contradictory but contrary to
Frager church took it in stride and
and proceeded to define a fragment of
that system which became known as lambda
calculus and probably many of you who
came from or theoretical background well
familiar with it so church is considered
to be a kind of the father of lambda
calculus and in this lambda calculus he
restricted attention to natural numbers
non-negative integers and this lambda
calculus can be seen as a kind of
high-level programming language for
programming numerical functions by
numerical function I will mean a
function from natural numbers to natural
numbers by 1934 church arrives to a
conjecture that any func
numerical function that it's computable
so as they used to say the time
mechanically without using your
creativity in other words if there is an
algorithm for computing this function
for any such function there is a it can
be programmed in lambda calculus could
girdle who is Austrian happens to visit
Princeton Princeton Institute for
Advanced Studies during 1933-34 academic
year and he didn't like the idea at all
he found it thoroughly unsatisfactory
flashback earlier Hubert was interested
in functions which at the time were
called recursive now they call primitive
recursive so here's an example you can
quickly guess what function is it and so
that kind of recursion and Hilbert was
interested whether this is the most
general recursion or not he had good
students of his own Wilhelm Ackerman and
Rosa Petter and many others but this
particular two students work on that
problem and they both showed the answer
is no there are more sophisticated
recursions which are not primitive
recursion so in spring of 1934 Yoder
gave a series of lectures at the
Institute for Advanced Study in
Princeton and he mentions that it seems
to be the case that an arbitrary
computable numerical function can be
given by some kind of recursion not
necessary primitive recursion more
general now the question arose
can you define the most general
recursion and he made an attempt he
presented a recursive calculus for that
purpose
and he said the fact that every such
function can be expressed in this
calculus cannot possibly be proven
because the notion of computability is
informal no you can proof equivalence
between two mathematical notions but you
can because all the proofs belong to the
mathematical world you cannot prove
equivalence of a mathematical notion to
something informal I just want to say
also a word that sometimes visiting
researchers are useful we have some
number of them at Microsoft Research and
certainly I always argue that visiting
researches is a good thing church and
cleani
establish that lambda calculus in
girdles recursive calculus or recursion
calculus I in a sense equivalent so any
program take any program of a numerical
function in one of the calculi and you
can translate it systematically in the
systematic translation which will
translate any such problem to a program
in the other calculi church conjectures
that every computable numerical function
is expressible in girdles recursion
calculus which equivalent to his
previous conjecture is ik is expressible
in his lambda calculus girdled is
unconvinced churches go on and publishes
his conjecture and coming back to
Hilbert's problem derives now using this
conjecture now the notion of computable
becomes formalized because instead of
just vaguely vague notion of being
computable by some mechanical means
there is a very precise notion big
having a program in girdle's recursion
calculus or in lambda or in lambda
calculus
and from this conjecture which
eventually became known as the thesis
church's thesis he derives negative
answer to Hilbert question there is no
algorithm which given arbiter
first-order sentence would check is it
provable or not it's a good thing for
mathematicians because a lot of
mathematical statements very meaningful
like Riemann conjecture can be expressed
in first order logic and then there was
during he was sitting quietly in England
and working on his idea
so what Turing did he analyzed
computation so the time the computer was
a steering said a man the man computes
and Turing said okay suppose we have a
numerical function which is computable
so let's have a look how does the
computer compute it
so he writes on paper without loss of
generality the paper is like children's
arithmetical paper in squares without
loss of generality he writes one
character per square without loss of
generality there are only so many
characters because otherwise he says he
will be confused and after so many
junior after without loss of generality
such clauses he arrives to a machine
which is now known as the Turing machine
and that is a very very convincing
argument he also has conjecture which is
now called Turing thesis that every
numerical functions can be programmable
in Turing machines and he also derives
from this conjecture the negative answer
to Hilbert question as he going to
publish his paper he learns the church
already published churches do this a bit
earlier so he quickly proves in the
appendix that the two theses are
equivalent so if you accept one you can
prove the other
George was a gentleman he published a
review of Turing's paper in Journal of
symbolic logic and it starts from clear
statement this is an independent work
because he was there first then he
compares and he acknowledges that
Turing's argument is more convincing in
fact it was so convincing that the great
skeptic the most skeptical of them all
could yodel accepted
Turing's argument
nobody was as skeptical as Goethe in
fact later on he changed his mind but
that's again a different story on he
being girdle now a bit of a critique
so the meantime church-turing thesis
since they're equivalent
for our purposes it's sort of one thesis
became so well accepted not many people
doubt it but why people believe it so of
course most people believe because other
people believe nothing wrong with it you
know you can't require everybody to
start to rethink all the Foundation's in
fact it's it's good it means that people
do trust foundations but if you do dig
into it what arguments are there so one
argument which is often given that there
are so many different computation models
that are equivalent so I mentioned
lambda calculus and yodels recursion
calculus and Turing machines but very
quickly there are many many models and
they all have proven to be equivalent
another argument is that you know
there's so many years of experience from
1936 and then there was a knowledge of
Turing and one other novice so let me
examine these arguments one by one so
many different computation models are
equivalent there is a problem with this
argument and people saw it right away
the problem is that what does it prove
what it really proves that the notion is
robust it does not necessarily prove
that it is right
think of Newtonian physics which for
centuries thought to be right and turns
out to be it's not exactly right besides
even though there are so many
computation models which are equivalent
only those initial models were
independent no it was almost immediate
but he saw churches paper yes post
actually came with a very beautiful
model and what today it's often taught
us called Turing machines it's much
closer to post machines but it was not
independent so many years of experience
let's see how strong this argument is
imagine you live in a flat country like
Holland or whatever one go - you know
what what other flat countries are there
and you measure you know temperate
bowling temperature of the water you
know day after day year after year and
it's always 100 degrees Celsius and then
you happen to visit California and go to
Mount Shasta and you discover that wait
it's not quite 100 degrees so just a lot
of experience shows nothing you have to
actively and creatively challenge there
have not been many challenges to the
thesis finally the analysis so what we
really have the most the single on
almost exclusive argument for the thesis
is Turing's initial and argumentation so
if you haven't read nvu it's a very
beautiful piece of a kind of speculative
philosophy it's extremely convincing
I know only one attempt somewhat
implicit in 1950s Kolmogorov with a
student of his Vladimir Penske published
in a model which is called Kolmogorov
machines actually have here one fellow
who worked on these machines for a while
and it seems one of Kolmogorov students
who is friend of mine Leonid Levin his
professor at Boston University tells me
not on this paper but from his personal
conversations with Kolmogorov that it
seems that Tamil war of had in mind
an alternative analysis of computation
instead of analyzing a man computing or
a woman person computing something he
analyzed computation as a physical
process proceeding in time and space and
you know if you have some bit in its
immediate vicinity can be only so many
other bits but there is none of that in
in the paper itself also it easy to
check that Kolmogorov machine does not
reflect three dimensional or four
dimensional or any finite dimensional
geometry so as a practical matter it
should work in sum if you believe in
many dimensions and bring theory of
brains of modern physics so maybe he is
right
in any case one interesting question
arises which goddess pointed out and it
is this that if you look at Turing's
analysis and if you try to imagine kama
Goro's analysis
one problem that arises can you pin sort
of squeeze it too few simple principles
from which you can derive diseases and
many people tried it is hard for example
Turing writes about the computer this
man having only finite number states of
mind the idea is that you have only
finite number state of mind as a
computer because as you compute you may
stop and go for a lunch you can leave
some notes and some other person can
come back and proceed with your
computation okay so that for those of
you who remember Turing machines that
gave rise to the finite number of state
of control of a Turing machine but it's
hard to to formulate this as a month as
a mathematical statement in any case the
other had said this that it might be
possible to state a set of axioms which
would embody the generally accepted
properties of computability and to do
something on this basis in other word
maybe you can come up with a relatively
simple sort of first principles and to
derive the thesis from those first
principles it's impossible to prove the
thesis from scratch because the thesis
equates a formal and informal notion but
what we can do we can minimize this the
gap and we can formulate what we want to
say about the informal part as a as few
as possible as simple as possible
principles and then to derive the thesis
from those principles
okay now I'm coming to recent
developments and there will be two parts
in the first part will be the analysis
of sequential algorithms and in the
second part will be our attempt to to
perform what that girdle's program
analysis that's not charged not curing
not girdle but yours truly
so some serious books define algorithmic
Turing machines so Turing succeeded
wildly now that is incorrect there is
much more to an algorithm that a
function it computes so it is true sorry
what's the thesis says take any
computable numerical function there is a
Turing machine which computes that same
function but Turing never said that if
you have an algorithm that the Turing
machine will be just just like that AK
algorithm because you know there's a lot
in the algorithm which Turing machine
will will not capture ideal levels of
ask a level of abstraction data
structures complexity and and so on and
so forth so in fact Turing machine is a
very very low-level language so let me
give you a very trivial example when you
see how things just lose any individual
reach even when they compile the Turing
machine so so recall
Euclidean algorithm for computing the
greatest common divisor and there are
two versions which are popular in one
version you use difference in another
version you use division
now they are different so typically
people consider different algorithms but
suppose you compile them both the Turing
machines so in particularly have some
how to implement division how will
implement division probably as differ by
differences and so the distinction
between the algorithm will be raised
besides typical algorithms is presumed
to you know to finish to terminating
produce the result there are very good
algorithms which don't produce don't
terminate in say an operating system if
I expected this at that point well
rarely terminates these days okay and
but the principle point it's one of
useful algorithms that you don't want to
terminate and surely the Turing machine
implementation of such algorithm is it's
inadequate now at the time that Church
and Turing worked children
by the way this is Vaughn Pratt author
of many famous algorithms not the
occlusion algorri he is not that young
okay so at the time that church in
Turing worked or Kolmogorov for that
matter in nineteen fifties the notion of
algorithms was much simpler later on
came you know parallel and concurrent
all the returns in real time algorithms
whatnot so here we restrict attention to
those algorithms which I'll call them
sequential so in in his analysis
Kolmogorov said that quite succinctly
what those algorithms are an algorithm
he said computes in steps of bounded
complexity steps of it's not the number
of steps which typical in time
complexity it's the this single step has
bounded complexity
so here here will be our running example
so you have a continuous function f on a
fixed interval between a and b and f of
a is less than f of b and there is some
zero in between and so we want to find
the value of the argument with which we
want to find the zero of that function
of the say with precision Epsilon
to find the point x such that f of X is
less than epsilon by absolute value and
this is quite an obvious algorithm so
you just have you dice bisect take 1/2
the interval a B and see what happens in
this point if so in this picture you do
one step and at the division point
step one at the division point we have F
is positive so we redefine B we have new
B prime then we do another step this
time in the midpoint it's negative we
define a and so on you go until you
become close enough to zero so here's
the program
a program I'll say I did I'll say in
which language it is a bit later so when
I came from mathematics to computer
science in 1980s so I wasn't I wasn't 18
already then and I was thinking what is
computer science about and and they came
to conclusion that it's all about
algorithms
you know operating systems compilers
databases they all are algorithms so the
interesting question what's an algorithm
you know if you go to physics physicists
study all kind of stuff in the world but
if you look at mathematically it's
partial differential equations so
mathematically the language of physics
is P DS so in that sense what would be
told sort of the PDE is of computer
science now Turing machines naturally
come to mind but they are with all
respect to great Alan Turing to clumsy
to low level and so the one possible
thought can man came up with sort of
generalization of Turing machine with a
machine model which is so versatile that
for any other sequential algorithm there
exists a machine in our class which will
simulate the algorithm step for step and
the first impression list of mind was
surely not but suppose you have such a
machine how would it look like
by the way the the pictures from Spain
taken taken but the lady which is happen
to be my wife sitting there okay the
wrong way
so this analysis led to the notion of
abstract state machines and there was a
use for such machines such versatile
machines namely for writing high-level
specifications that was attracted
attention of Microsoft Research and
that's how we moved from academia to to
Microsoft later over it at Microsoft
without too much teaching I think some
more time on my hands I was able to
write down three axioms which attempt to
formalize the notion of sequential
algorithms one of them is sequential
time another is abstract state and the
third one bounded exploration shall
quickly describe them the first one is
completely obvious you have a sequential
algorithms its compute step after step
so so an algorithm or sequential
algorithm is a transition system which
is completely determined by the states
and the transition functions so there
are only two questions remain just two
little questions what are the states and
what what are the transition functions
which reminds me a saying of news here
he said that there are two great
problems in the eye what is a and what
is I
States what are the states so sometimes
in programming textbooks they would tell
you that state is given by the values of
the variables and this is not true
so imagine you have say C program and
save three variables X Y Z and you know
the values of XYZ do you know the state
not necessarily because you have to know
where you are in the program and if
program has no recursive functions then
now recursive in the sense of
programming then you have stack with
various unfinished computations there so
the programming language creates an
illusion of simplicity you just deal
with variables but the true state is
much more complicated so at least if you
if you define if you agree with my
definition of state so by state I mean
information which completely determines
the future computation or computations
given the program
so the second postulate probably the
most critical says the states are what
logicians called structures or algebra
is called algebras so it's a set with
functions and relations over it
the most technical is the third
postulate and this was my attempt to
solve question implicitly posed by
Kolmogorov he spoke he said algorithms
compute by staying by steps of bounded
complexity so what what does it mean so
here's an attempt to answer what bounded
complexity is so imagine you have a
program and you work with such States as
as I defined where everything is
explicit so where everything is truly
given by with the values of the
variables now those variables may may be
fun could be functions or relations now
imagine you want to say show me that
element now the important part of the
abstract state that the state is the
structure determined up to isomorphism
so the only information you have about
States you know what are the constants
what are the functions what are the
relations nothing else you know if you
know Lisp they they started very cleanly
and then they have this quote and they
say okay this atom is you know
represented by number 17
now we don't allow this so the only way
to indicate element is just to give an
expression that evaluates to that
element so that's the motivation for
this postulate so there are expressions
which depends on the program but not on
the state or input in those programs
those expressions or terms
are called critical terms they determine
the state change in the following sense
that if I have two states where these
critical terms if I'll give the same
values
otherwise the the states made vastly
different then the Delta will be the
same in both cases the state change will
be the same now I cannot dwell on it too
long and I have to move but now given
this three postulate we can give a
definition our definition an algorithm
is an abstract state bounded exploration
transition system so the bounded
exploration that the name reflects this
idea that all what the algorithm
explores during the state are this
critical terms so it's a bounded thing
now these are three of the four eventual
first principles from which we do derive
the ceases so you know this is not
religion we put those principles on the
table and they can be argued but one
also can cannot say for the
formalization of sequential algorithms
you have three postulate maybe need
seven more I know that I don't need more
but because I have a representation
theory so if I take any algorithm in the
sense of this definition I can find an
abstract state machine which will
simulate it step for step in particular
Alex I asked in my running example the
program in which languages was written
it was a little abstract state machine
back to church
so the first paper was written published
in year 2000 and was there quite for a
while and then now from there trivets
who teaches at Tel Aviv University
visited me and it was him who was
interested in proving church's thesis
his University I'm in in industry I'm
supposed to speak more practical things
not about such a theoretical fees and as
we discussed we realize that this
formulation of sequential algorithm is
actually very helpful so let us first
recall what church's thesis is so we
chose from the two versions churches in
Turin to work formally with church's
thesis because arithmetic church's
thesis is about in terms of arithmetic
and it's much more standard what are the
what are the basic operations
arithmetical operations it's much more
standard thing than basic string
operations so that the reminder of
girdle statements so the only thing that
was missing with absolute state machines
the was
let's see if you always say only so what
is the obvious problem with those three
postulates an abstract state machine or
an algorithm any algorithm satisfying
those three postulates compute functions
which are not necessarily computable for
example my running example you deal with
continuous functions now continuous
functions some of them may be
approximated but in general it's not
something can compute with now there's
no miracle side done by our algorithm so
by abstract state machines the miracles
were built-in in the initial state so
what is missing was to restrict the
initial state properly and our postulate
says something like that that only
undeniably computable arithmetical
operations are available in the initial
State
now we don't say it in this form you can
say in the initial state you have
multiplication addition multiplication
difference and division and that's it
and zero so the algorithm satisfying all
four postulates will be called
arithmetic 'el and now from this four
postulates we can derive church's thesis
now if this four postulate would be in
terms of strings rather than arithmetic
then would be in a similar way we would
be able to derive Turing stages or we
can use Turing's additional proof and
derive during stages from church's
thesis that's it
Thank You Yuri for the excellent
presentation so before we start the
question I wanted to acknowledge
presence of respected guests and we're
honored to have people from all other
Silicon Valley companies including the
Leland Stanford junior University and
Yahoo and so if you have any questions
you have the first shot you didn't
actually say theorem when you were
concluding those last couple of slides
but how long are the proofs yes it says
theorem yes but you didn't so this is
your theorem or there's some cases there
is gravity theorem yeah okay and how
long are the proofs the proof had some
little sophistication take some some
model theory it's not particularly deep
the paper is very long because it is a
very classical subject and one of us not
me
he is very very scholarly so that paper
sides so many articles and books that
probably probably more than in the rest
of my papers and now home has the
incredible gift I think he read them all
maybe some of them his scheme but got in
necessary information so the paper is
you know as I said foundations you
arguing argue subtle points now the the
pure mathematical proof is in the first
part in those three proving in this
representation theorem but let me come
back
so they're sort of the meat of the of
the proof is this representation theorem
okay and Helen I mean how hard is that
to prove that is to say is it one page
ten pages for five P professor okay and
then theorems one and two are they into
reducible or do you have to prove them
separately you can prove them you can
reduce them one to another okay so you
really only have to prove one and then
how long is the reduction from one to
the other
ah it depends
in in in night in the early times each
such equivalence it was almost a PhD
today it's all becomes you know for
those let me see
for those of you who know no Sigma zero
you know if if consider if metric all
Turing machine all this all these models
really formulated a real existential
statements in there is meeting in pretty
obvious way so with with the develop
development of logic the equivalence
between all this models become became
trivial so much for my complexity
question fruit complex right any other
questions
so you started by saying that you can't
prove church's thesis because it's
starts with an informal notion and you
can only prove equivalence of
mathematical notions so you say here you
prove church's thesis but what you've
proved is the equivalence of two
mathematical notions algorithms that
proceed by abstract state machines and
algorithms in the sense of girdles
recursion calculus okay so the question
is how convincing the postulates are the
determine abstract state machines as as
an explication of the informal concept
of computability okay so first of all
this is true theorem because the notion
of the notion of algorithm here is the
one which for which we gave a definition
so an algorithm is any entity satisfying
three postulates now how convincing
Cardos four postulates so the first
three I think nobody agrees with the
first one nobody argues with one number
one in fact many logicians argued with
me but I don't know not as there is no
any single paper where somebody somebody
found it unconvincing and argued that
it's not convincing it sounds convincing
to me but it but of course it is a
matter of
challenging they have not been
sufficient challenged and I would love
them to be challenged but in fact I
think this this idea that states are
first-order structures is getting
getting acceptance so in certainly in
our group where we're abstract state
machines popular people think in these
germs and there is absolute base
abstract state machines ASM so there is
an ASM community there is an ASM annual
conference and there was international
community and there's people try to
formalize all kind of algorithm only
sequential because there are extensions
of this postulates to parallel and other
other items and they have been
succeeding there was not a single case
that we came across an algorithm and we
cannot formalize it there's enough
circuit machine but this is not a
religion as they said there they are
there on the table to be challenged in
to be argued against with the donors
reformulation of the cg thesis something
you said made me think of it I didn't
sorry I didn't get repeat the question
yes I say are you familiar with dolis
Hofstadter 's reformulation of the CT
thesis oh yes which is yes yes yes it's
it's not sufficiently formal for us - of
course relate to min formalism to an
informal notion which is why I like it
mathematics done by mathematics problems
can only be solved by doing mathematics
that's his thesis yes
church-turing thesis well it reminds me
that kind of thesis reminds me some
high-level specification software
specifications which look more poetic
than mathematical yeah when you spoke of
it being very fortunate that that first
order logic is not first order logic is
not it's not mechanized of all it's it's
fortunate for mathematicians because
they means they always have a job -
agreed
I want to ask a very short question if I
may so there was a large body of work
related to I think it was called
comparative schema to ology in the 70s
like the world by Patterson and healed
and some other people basically also
defining computation and you can say in
the abstract algebraic models for us to
do so how how does the three way to the
abstract state machines at the time I
was pure mathematician and paid zero
attention to them when it came to
computer science it was intention
history so I don't know that well but
from what I remember it would be an apse
abstract sitting it would be abstract
state and machine is much much more
specialized I would say as far as I
remember
I live there any other any critical
critical critical so is do you regard
abstract state machines as a topic in
its own right within computer science
yes so does it have fundamental theorems
and does it have open problems this is I
would say it's not a mathematical issue
it is more specific a methodology for
high-level specification models based
testing so it so there's no guidance
from mathematics within the subject you
take your draw your mathematics from
outside the subject let me see let me
let me say a little bit more carefully
consider computer science it uses a lot
of mathematics in mathematics and there
was a lot of theorems proved within
computer science and yet computer
science is not mathematics so it was a
similar picture so most people who work
with absolute state machines just use
them there are few theorists who prove
theorems and there are a lot of theorems
to be proven so let me give an example
if you are interested in polynomial time
Turing machines are just fine polynomial
time and Turing machines is as as as
good as polynomial time on random access
machines or whatever however imagine
you're interested in linear time now we
have think now things split you know
Turing linear time is very very modest
now random access machine is much richer
now if you go to computational geometry
they have yet in yet other linear time
model so in absurd state machines you
may have linear time with a parameter
and the parameter will give all these
models and more so there are theoretical
results like the
there are some initial beginning to
develop lower bounds so there's some
mathematics done but most applications
when I was thinking of you know in
computer science we have the equivalence
of bullies np-complete problems as fun
as a fundamental part of computer
science and then we have as an open
problem whether that's also the same as
P so there anything remotely like that
concerning is a SMS yes there was
actually there was a contribution of
SN's to that field yeah it's okay if I
continue a couple of minutes let me
answer this question so the standard
notion of polynomial time is somewhat
deficient why and it's interesting that
mathematicians find it quite useful and
abstract but in database theory they
discover that this notion is not
sufficiently abstract why imagine you
work with databases say for simplicity
your database is a graph a graph in in
graph vertices are not linearly ordered
so expression like take the first vertex
makes no sense now graph algorithms
typically use things like that take the
first vertex such that now initially
such queries were allowed and then I
would implement query algorithm on my
machine you know send you the database
and you try in your implementation you
get different results so to ensure that
kind of invariance SQL was developed and
before that relational calculus so when
you take a database as an input it is
not a string
so inputs may have symmetries and the
general form of I think the right form
of polynomial time is when the input is
a structure and currently the most
versatile model for for that notion of
polynomial time is a same based I think
running out of time slightly right I
wanted to say thank you to you again and
also to the people who made this talk
possible Dartmouth's specifically to
Amanda ball and Manik with filming this
for YouTube so the video is going to be
presently available</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>