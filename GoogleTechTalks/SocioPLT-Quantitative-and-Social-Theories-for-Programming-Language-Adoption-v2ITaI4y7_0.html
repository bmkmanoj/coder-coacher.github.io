<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Socio-PLT: Quantitative and Social Theories for Programming Language Adoption | Coder Coacher - Coaching Coders</title><meta content="Socio-PLT: Quantitative and Social Theories for Programming Language Adoption - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Socio-PLT: Quantitative and Social Theories for Programming Language Adoption</b></h2><h5 class="post__date">2012-11-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v2ITaI4y7_0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you everyone for coming my name is
Phillip on the software engineer here
and I am very happy that leo is coming
to speak so Leo and I were kind of
around or in grad school around the same
time and we're actually office mates one
summer at a added another unknown
company and we just had a really good
time that summer I mean leo has really
impressed me by both the the breadth of
stuff that he's really interested in
terms of research engineering and also
the depth in which he goes into stuff so
he's one of these rare individuals that
has has a lot of diversity and breadth
and also go this is one of his several
projects that he goes in with a good
amount of depth so I'm really excited
for this talk I hope everyone else is as
well so go for it I Phil didn't say he's
also like that but uh okay yeah so hi
I'm Leo I'm from over east bay UC
Berkeley and this is a workout been
doing with re Rabkin who was at Berkeley
now at Princeton and we've been looking
at programming language adoption I'm
going to be talking about two different
ways we've been looking at it one is
about quantitative analysis and the
others actually looking at kind of what
the sociologist might say to us and
seeing if we can sort of cherry-pick
theories that apply to our domain so
before I get into what that really means
I want to kind of ask like why do we why
do we care like how's this interesting
to us and so for that um there's a
really cool paper by Eric Meyer where he
found this this principle called the the
change function this is by PIP Coburn
and sociologists they actually call it
something called a switching costs but
uh neither of them appear to have known
that at the time but basically what it
says is if you're if you're looking at
some sort of new technology it's going
to have some benefit and when that
benefit is greater than the cost and
kind of that pain of going through that
adoption process then it's a rational
choice to go forward and you might not
have known the guys talking about Eric
Meyer but you probably know the language
that he's on one of the key designers of
which is Haskell and when he looked at
this change function you realize ok
Haskell has all this functional
programming goodness but you know you
also have to pick this new language and
there's a lot of pain involved there
and what he decided after that is that
from now on my goal and life would be to
also drive the denominator down to zero
and what he meant here is that instead
of doing all this cool functional
programming stuff in designing these new
features for Haskell he actually joined
the visual basic team do all this cool
new functional programming research
there but do it in that same language
that is sort of easy for developers to
already use and kind of lower that kind
of cost of adoption so what I want to
talk about today is kind of two
different ways we've been looking at how
adoption goes and how we should think
about adoption and we by we I mean
language designers language researchers
so and we've been looking into ways one
is doing kind of large-scale data
analysis of actually going out into the
wild and seeing how the stuff actually
happens and instead of just doing kind
of this like random Safari of just
looking at random facts we've been
trying to keep all of our work informed
by how actual associate I'll just look
at adoption in general and in particular
fields that are somewhat related to
languages so let's first talk about kind
of the fun numbers and then we can get
involved get to the the models behind it
in a bit so what I'm talking about
adoption I'm interested in actually two
things one is a language like Haskell
but also the other thing is like a
features like functional programming and
then throughout this talk I'm going to
kind of switch in and out of those two
different types of adoptions and we've
done a lot of cool quantitative analysis
on here I just want to talk about three
particular types one was we want to look
at how people pick domain-specific
languages over general-purpose languages
which matters when we're trying to
decide pick what type of language to
design another thing is kind of in the
small when your programmer makes one
small decision how did they actually
make it and then finally as an educator
or somebody who wants people to know
languages we're interested in what
actually influences of people's ability
to do so and what's important there so
let's talk about domain-specific
languages first so when when I say the
main specific language I mean something
like Excel which is good for maybe doing
accounting formulas and then there's a
sort of the spectrum that you can make
it more and more general which is
something called general-purpose
languages and often times we might say
this is something like a touring
complete language where you can compete
anything you want so maybe there's like
a library for everything in Perl but you
just have to look for Sipan and find it
and then they're kind of and this is
like a spectrum and maybe it's something
between is like mapreduce here at Google
where you can plug in whatever function
you want into your map and reduce and
it'll just run it on the cluster but
this is sort of might not be actually a
good way to think about this stuff so
what you're seeing here is one of those
experiences that scarred me as a youth I
went to a soap factory to see how they
make soap and apparently they run the
soap machines by excel macros so this
very domain specific thing right so
maybe this is not like maybe we don't
actually even know what we mean when we
say domain-specific and so I we took a
look at about 200,000 projects and
sourceforge and try to understand what
does it mean to be domain-specific and
for each project we got had a few pieces
of information so here we're looking at
the I guess it's the squirrel SQL client
on the bottom left we're seeing that
this is a it's a client it's a front end
so it's the category of front ends and
then on the bottom right we're seeing
the lip programming language is Java so
you're going to write this type of
front-end and Java and so we are gonna
see what else do people use Java for in
sourceforge and so what the chart you're
seeing here is on the x-axis different
categories so one one of those dots
means blogging and another one of those
dots means you're doing your writing
some sort of search programming in Java
and what the I AXI means is that wire
means it's more popular for that
particular category so if somebody's
going to write a search clients it's
actually about forty percent chance
it'll be in Java but if they're doing
blogging and only be like I don't know
ten percent chance that it's in Java and
so this is in just the source for tree
pose so I'm going to say if you're one
of those 200,000 programmers this is
specific to that what's cool is actually
started life as a schemer and there it's
fun to look at the adoption how the
hitch is work there and there we see
okay so apparently build tools is
something people relatively if you're
going to use scheme it's going to be for
a build tool and if you notice that the
y-axis is actually a little different
like it's smaller and what the really
interesting thing here is that you don't
have this nice spread of scheme across
different languages right it's like a
few things pop out and so what I did
next is
or re and I we we actually ordered the
languages by popularity so Java is there
on your left and no that's the popular
one and then scheme is on the right and
maybe it's not maybe not unpopular but
underappreciated and so so so here we're
seeing just general popularity and then
what we added it in was the standard
deviation across different categories
and notice that the the y-axis here is
actually on a log plot and so what that
means is even though they all kind of
look that same size because the the
standard deviation is kind of at a lower
point on the bottom right that means
it's actually it's much smaller than the
ones on the other side and so for
example if i divide standard deviation
by the the average you actually see like
if you get or maybe another way look and
if you look at those two slopes they're
kind of changing at a different rate and
so what that means is standard deviation
oh let me all right so the
interpretation here is basically as you
get more unpopular you're popular you're
you're only going to be kind of showing
up in certain niches it's sort of what
we saw for skiing versus in Java and
Java and so that kind of leads to
certain type of thinking for example
when you're going to talk about language
adoption you're not going to say that
it's getting generally more popular it's
getting more popular niche by niche like
you're going to see more of those
popping up and like all of them are
going to go up but also the cool
phenomena there as you start seeing this
pup and I'll get it back into that later
but like now this is already starts
leads into a whole new line of reasoning
about how languages work so this was all
very high level so let's actually zoom
in a bit so we can ask well how do
programmers actually pick languages and
here we see a picture of a bunch of dogs
or say matter what it is we want it I I
think better of programmers and so I'm
curious what they actually do so here
again we're looking at source for to the
same 200,000 projects and what we're
seeing on the what you're seeing on the
right is just a kind of a project that
you the most recent or a second most
recent project they wrote and then what
you're seeing on the bottom acci is now
given that project what's the what's
likelihood of them picking a language
some next language so
use one language for project what's the
likelihood that you some other ones so
um so kind of as an example of what's
going on here is no matter what language
you picked on that on that right aksi
and the y-axis you see these vertical
strips that good chances are you're
going to pick any one of those like one
of those six languages so probability
that is sort of independent what
language you use you're going to
probably use one of those six bars and
so that means programmers or creature of
habit you're going to use a popular
language what's also cool if you notice
is there's another phenomenon going on
here which is we have this very strong
diagonal and in this in this matrix what
that means is you're going to use that
same language like you use one language
you're going to the next time good
chance the next language uses can be the
same exact language so now actually even
more strongly instilling that
programmers are Pete and creature of
habit in two different ways now and this
actually characterizes most of the
projects on sourceforge is programmers
use the same language either that's a
popular one or that they used before so
kind of this led us to a question of why
explain this in a second but why are
they a creature of habit what actually
led to those decisions is it just they
like shut in like popular things or is
there something else going on and so we
launched a bunch of visualizations of
this stuff of and we realize that oh
this might be nice opportunity to get
our work in the in the eyes of lots of
other people in this case you see we got
/ dotted and as soon as we put up those
visualizations like we're talking to the
press and it's all really fun but what
is really going on here is something
different it was much more insidious was
actually we wanted to run a survey and
so the reason we we did this viral
campaign is we wanted to see if we can
see ask programmers about how they
actually pick projects for the most
recent projects and so in about a period
of two days after this campaign we had
about 1,600 responses from people on
websites like slash dot and wired and so
what we're seeing on this graph is what
they set
so this is a little noisy graph but
basically what we're seeing here on the
on the bottom bar is different types of
reasons people pick their the language
for the last project for example the
very strong influences are though those
bars under under the green arrows so for
example on the on the leftmost actually
open source libraries were from a strong
to medium influence so everything up
above that block horizontal black bar
and then also something like group
legacy which is sort of what we're
seeing the source for which case is that
you you the group was already writing
code in this language so the next
project will leaves that same language
it was really cool is that as we go
through all these green light green bars
for example cell phone familiar
similarity team familiarity open source
libraries these are all about social
properties of language this is how other
people use the language it's not just
it's not just about how fast the
languages and intrinsically and as a
language designer then I started asking
ok well what about the other what had
slight influence on what languages were
picked so on the left most you see
something like correctness that be like
type safety or some one of those like
very common properties or and more to
dear to my heart is something like
developer speed or productivity that
would like inherit productivity to
language that actually was not a strong
influence for picking a language like
when you actually get down to a concrete
decision so the the programmers is an
interim or is an interesting social
Beast so this is just like me asking all
the programmers and showing that so the
question is like what happens when we a
start picking what programmer we looked
at and so one if social properties are
very important and we can start asking
what happens when we look at different
types of programmers and from different
types of social organizations and so
what this chart is showing is this those
same axes on the bottom like the same
properties but now I'm slicing the
programmer data based on what's that
what size company does that program or
work at and so the leftmost like that
dark blue will be like you're working
for yourself it's a one-man team and the
rightmost will be you're working for
five hundred organization with 500
programmers or more and just as kind of
like a quick surface representation I
asked what's what's the slope of the
love of the
curve across these so for example if we
look at correctness on the left I wrote
a green plus and that means that the
bigger the organization except for one
of those bars it basically means that
the bigger the organization the more
that correctness is a concern well if we
look at something like open source
libraries the first red- that's kind of
a negative slope and what you see is the
bigger the organization the less that
open source matters and presumably
they're building their own software and
these are actually significant these are
significant changes in adoption habits
because this is essentially going from
median influence to add to a slight
influence this is a full one point drop
so that um so this is so just kind of in
summary larger companies care about a
more social properties about their
language or how the language is used so
the size of the company is just one one
way of looking have kind of bucketing
programmers and so there there are lots
of different types of programmers out
there and lots of different ways of
looking and so one thing that actually
that we were looking at actually was
partially inspired by Philip was
actually education and so we're
wondering how how does how does
education in age and things like that
plane to have the languages you know so
it's one example we we did actually
another survey this time on something
called a MOOC a massive open online
course and this is um this is
essentially you can think of it as a
programmer who's in the job force but
wants to take an online course and so
this is kind of an educated program or
somebody interested in languages and we
were able to get about 11 or 2,000
programmers this way and ask them about
how how they learned languages and 11
interesting phenomena found out is that
the number of languages of programmer
nose like once you're 20 or older is
sort of stagnates like you kind of
you'll say that oh I know this the what
those red bars are seeing as back so the
x-axes age so as we look from left to
right like the red bar is kind of
constant right we have this nice line in
the middle you know the number of
languages we've used actually stays kind
of dormant in the end of your age and
the number of languages use you know
well is the green bars and that actually
also stays fair
early in variant and again these are
educated people who are working working
programmers so if we are going to do
something about language education it
sounds like what's going on after you're
in the workforce today is rather
stagnant so we took a look at what
happens in school it's like what we do
there matters at all and so what we
asked is if you look at the the left
labels on the left column there we asked
for different categories of programming
like functional programming like Lisp
and scheme or dynamic programming like
Perl and Python or maybe specialized
systems like assembly or like MATLAB in
Mathematica for each one of those
categories we wanted to see how you
acted in school influenced how you what
languages you know today and what
they're we the first thing we looked at
is whether your CS major or not is yes
education actually doing anything at
large and their way we found is when we
when you ask CS majors versus non CS
majors about the languages they know in
these different categories that actually
doesn't really matter for example
non-majors twenty nineteen percent of
the time will know about functional
programming and CS majors will know
twenty four percent of the time so
there's like a small five percent jump
so as somebody interested in education
this is a small jump however if we look
at whether a particular language was
taught in an individual course like in
one of these families now we see
significant changes in the statistics
for example for functional programming
that top row if you were taught it at
one of these languages you'll say that
you know it you know forty percent of
the time but if you weren't taught it
you you'll only have picked it up after
school about fifteen percent of the time
so kind of the kind of takeaway here is
like it actually doesn't matter to a
large extent whether like if you don't
know anything else about a person
whether they're they were a CS major or
not but if you actually ask those taught
in those particular courses that's
actually now that becomes significant
and when you're when we're different
when you find a CS curriculum this
actually meant the languages we teach
actually matters because otherwise
apparently people won't learn them so i
actually have lots of lots of statistics
if you go to my website like the the URL
is here we actually have a few
interactive visualizations and this is
the thing that launched our viral
campaign and I'm also our raw data is up
if you anybody knows statistics much
better than me I would be curious to see
what you have to say and with that
actually I'm wanting to move on to the
the kind of the Prince of social
principles the kind of more theoretical
stuff but before then I think this might
be a good point if the stopping point if
anybody wants to ask questions about
this more quantitative analysis yes so
we have that data but I suggest you come
up to me after and I can pull it up this
is just like ass it's not a bit also I
think for those like people use those in
practice so I don't think it's as
surprising I'm work yes yes I think so
our first guest here was that we had
some sample bias going on um actually
the first graph the time we did it was
actually for the slash survey so we
figured we're just asking a bunch of
nerds about nerdy things and that's
actually why we went back to the online
course because there we actually had
much wider demographics and so here like
I actually think this really is what's
going on but maybe what's going on is
somehow maybe for example how we ask the
question that maybe somebody is in
remembering languages but one of the
ones we asked was we actually gave
reminders of different types of
languages and then we actually asked
them to we both we tried different ways
of asking the question like can you
enumerate other your answers and can you
actually just give a number in both
cases we kind of saw the same stagnant
so I'm actually this seems close
yes so may be a good thing to do would
be to do some more of the demographic
slicing for example we had a lot of
international students in this
particular survey so that'd be
interesting to guess so there could be
the computing industry could change and
that will so maybe these are statistics
of the day on these are cross-sectional
not longitudinal I've actually found
indicators that that's actually not the
case but I think we should talk offline
about that but basically essentially as
soon as personal computing happens then
ages became invariant but i'll talk
about we can talk about that offline
thinking the mech
so this is cross-sectional meaning we
took it out of snapshot in time so i
really don't know but what I will say is
that we actually looked at different age
groups to see what languages they know
then for example if you're in college
and you haven't left yet this is the
time to learn Ruby like you're you're
like a Ruby programmer but if you've
already left you've missed you've missed
the curb and you probably won't know
Ruby even if you're just like you know
two years older so like there definitely
are cool like age-specific phenomenon
John
yes so the question is our kind of
language is somehow generational that
like you know when Java came out like
you have the job of generation
programmers I that uh I don't know we we
it sounds like that's what the kind of
the Ruby comment is that like there are
kind of these generational blips
especially for the less popular
languages something like Java is a
little tricky where it's an old language
like relatively speaking yet it's still
the number one language open for a lot
of statistics that's a good question all
right unless there's like another really
burning question I do want to move on to
the really really crazy stuff okay so
yeah so now we have a bit of idea of the
numbers but they didn't we didn't where
we weren't actually doing like a random
number hunt a lot of this was actually
informed by ways that we were sad that
sociologists might think about these
things and it was opportunistic but
there was some picking here and so the
kind of the other side of our research
we've actually kind of started thinking
about adoption in a little bit of
different way where we realized that
it's not just about getting our language
out there it's that we have the kind of
these long-standing challenges and
questions in programming language
research and so the question is could we
start by looking at them differently by
in terms of social theories can we have
alternate explanations for what's going
on or actually in some cases
explanations for the first time and I
want to talk about three particular
cases the first one is I think what a
lot of people would expect me to talk
about um and it's kind of very practical
which is if you do if you are building a
language or actually just any tool how
do we kind of market it so people will
adopt it and so there's something called
diffusion of innovation that kind of
gives us a nice recipe the next thing is
this is kind of a that's sort of like a
bit of a narrow-minded view of how
adoption works and for example one thing
I've come to appreciate is through
theories like reinvention what it
basically means is the more people use
your system actually the better your
system becomes you know i'll talk about
one particular case of how we might try
to harness that and then finally i'm
going to argue that i'm kind of pulling
on again arguments from sociology that
um we shouldn't just be looking at the
technical side of what's inside your
language that basically a lot of the
knowledge about what it means to be
language is actually coming from how
people use it and when I say people i
mean groups of people so all right let's
let's kick this off um so I'm going to
say something really bizarre here so
that to a sociologist if I told them oh
yeah I think safe sex is kind of like
this thing called a type system I don't
think they laughed and laughed me out
and before I get there before we get to
safe sex let's talk about corn that's
like a little little easier and so
basically what happened in 1943 was sort
of the beginning of this near the
beginning of this revolution in
sociology and what happened in one
particular case study was this guy named
Brian went out from farm to farm and he
looked at how people were adopting corn
and the reason he's doing this is what
the corn you're seeing here is actually
genetically modified and more in the
tame nineteen forty cents not the way we
were doing it today and the reason
they're doing this is because they're
concerned about things like say world
hunger and what they found what Ryan
found was it took about 12 years from a
farmer to hear about corn that will
increases kind of yield to them the
farmer actually using this on the farm
and all the farmers actually eventually
did this so the question is why did it
take 12 years so over the next about 20
years under a lot of other studies some
about corn other things about like five
children by toys and how companies by
microscopes about 500 one of the 500
quantitative studies later so many named
Everett Roger came into the picture and
said wait there are lots of patterns
going on I could build a model of how
adoption works and then for the next
about 50 years this became like a really
big wide study field and cited more than
actually than any computer science of
paper I know if so I was impressed so
this is very general thing so I think
you guys will enjoy hearing about this
so how'd option works is Everett found
was that it kind of goes through
pipeline the first step somebody has to
hear about your your your your
innovation this is in the case of corn
that's very easy it's just like a
door-to-door salesman went around trying
to sell corn
that doesn't really work like salesman
aren't very compelling and so what
happened is it progressed to the next
step which is something called
persuasion and this is more like an
information seeking thing you can
imagine going to your social network you
know talk to your friends about it go
onto the internet and try to learn more
this is more of an active process and
eventually you're gonna have to go
through this coin flip you're gonna have
to make a decision and this is a very
short process like because eventually
you got guess I'm going to do this
however you're not just going to guess
I'm going to do this and you know
replant your entire farm you're actually
going to go through a trial period so
here I'm showing that you'll maybe plant
one one piece of corn see how that works
if that if it works for you maybe you'll
try to deploy it on your entire farm if
you're in Alaska obviously this won't
work so that has to be compatible with
how you know how things worked and so
this is the basically what Roger found
for all these innovations he's actually
very easily able to characterize the
processes they went through now at the
same time what that on the person is
going through this adoption process
their catalyst that sort of influence
how it goes so for example is the
innovation simple like oh this is Magic
corn that will like have the higher
that's resistant to bugs is spread to be
resistant from bugs I understand what
that does and well away that there's a
relative advantage to this so because
it's resistant to the bugs like no bugs
will eat my corn and I can sell more
corn at the same time you might not
believe that this is actually the case
like this is a Salesman trying to sell
you something so you actually want to
try it out and see that may be for
example does my soil type work with this
type of corn and see if it really works
and then for the final step on that is
actually i just described the final step
of compatibility does this innovation
actually work for your for your
particular domain now the the reason i
kind of want to walk through this is
first of all i think this is actually
one of the most important things in this
talk so i didn't even come up with it
but it's still really cool but the thing
is now we can start analyzing on
innovations and technologies using the
those processes and catalysts so for
example let's let's look at safe sex and
how that relates the type systems so if
we look at the process actually let me
back cuddle one bit so the reason
talking about safe sex I'm actually mean
a very particular time period about
early 90s safe sex which is essentially
when you have this whole HIV the HIV
academic was really epic because it was
really concerning and so if we look at
terms of the process of why safe sex was
kind of going on becoming an issue of
the time most people knew that safe sex
would kind of prevent problems and they
might actually talk to the friends to
say yes do you really believe this is
going on but somehow they you know
somewhere between the decision or trying
to see if it works for them and decided
to go forward it kind of fell down an
interesting thing is we look at type
systems most people know about type
systems most may a lot of people might
have even like tried to read up a blog
entry or something about it but somehow
it falls down and so if we take a look
at the catalyst that actually is
actually seem very similar as well what
the challenge is Carrie so the relative
advantage of both safe sex and type
systems oh we prevent bad things like
you will not die your space shuttle mate
might not explode that sounds really
good and it's pretty simple how they
both work right like we've you but I
think I don't think I need to belabor
the point out somewhere like Google I'm
not even talking about crazy type
systems it's just like simple things
however they also fell down like you
know if when something like
observability did you actually did it
actually prevent the problem as
advertised to prevent I don't know if
something didn't happen why didn't it
happen like it's hard to see causality
right and the same time for trial
ability these are you can't just use a
type system in isolation you have to
work with your your coworker right the
same thing for safe sex takes two to
tango and so kind of as you go through
these things you actually see that this
actually is the same type of technology
that ad is at essence and so the
question is we learn from a kind of
studies done in other domains for
similar things so apparently in two
weekends you can save a lot of lives so
I'm going to teach you how to do that so
the sociologist took a look at how could
we spread safe sex how do we how do we
get this innovation into people's hands
and make it active and so if we can
number one they actually just hung out
of gay bars and three different cities
and they isolated kind of at local
opinion leaders in the community they
said here are the people that people out
the bar is apparently listen to what
that means i don't know but apparently
like why that is these are the people of
interest and once they found those
opinion leaders that came back the next
weekend and said come to our workshop
let us teach you about what this thing
is and let us teach you how to explain
it to other people and then finally kind
of a cute thing they did it also was
actually gave them a little token so
they actually gave him the badge with
the traffic light so what basically
would happen is somebody would say ho
why do you have a traffic light on your
head or on your lapel and says well let
me tell you about safe sex and that was
actually very simple but it got the
conversation rolling and I could claim
that it worked well but I can also just
show you that it worked well and so I
don't want get into the methodology of
how they measured this but it's actually
much more rigorous than what we normally
see in computer science so I was weighed
but what essentially what it comes down
to is when we when they came back three
months later and also three years later
that's alright if you had sex maybe
several times whatever did you have safe
sex and more people would say yes I did
in this after the interventions and then
I likewise if they ask did you have
unsafe sex which is the thing that we're
really interested in and that's that's
where we see it went down so we have
this nice kind of gap so this was I
think a very successful case study so
now the question is could we go back to
two languages and see do does the
diffusion process sort of mesh with how
how things work here so we actually have
some cool success stories in art in the
kind of language community and I think I
could describe them in terms of this
diffusion process so as to very simple
examples one is observability do you see
a benefit of this technology so type
systems are supposed to be kind of a
program analysis defines bugs right we
can't even get people to do this for
free right but that's the kind of the
Haskell world now there's a Stanford
startup called Coverity that runs
program analysis not only again it's
sort of in a sense the same similar
technology but in this case not only
they get people to use it they get
people to pay them to use it and
basically what's going on is you the
gnosis runs and then you see that this
long-standing bug
or this really scary-looking bug
actually gets characterized so that's an
observable of result of your tool that's
something you want so question is can we
do this for type systems how would you
do that can you give some accountability
another case here and actually probably
really big up Google is something like
relative advantage if I use this tool do
I really see like what do I expect to
see in terms of a substantial change to
myself or my organization so something
like Hadoop or ec2 all of a sudden oh
I'm going to scale out can be able to
handle more users things like that and
so this targets a particular need it's a
very quantifiable need and so relative
advantage is something you should be
thinking about when you're trying to
design your technology like if you want
people to actually use it so I can go
through lots of other all the other
catalysts all other processes and do the
same thing for all four other you know
popular technologies of the day I
suggest you think about it and then if
you really are stumped then maybe look
at the slides but I think you should
just think about it okay I just
described very technical solutions but
was kind of really cool to me about the
safe sex advocacy was very non-technical
they just went to a bar for a weekend
right we actually have that in the
computer world for example I don't know
this that luckily is no longer true we
drop the URLs now but you actually could
look at a website and see what
technology they use and this is a
ringing endorsement for technology
people know about it there get persuaded
so I think a lot of simple solutions
will work just you have to think about
them and know how to think about them
okay so this was a very this is about
how to get people to use your
technologies and ways of thinking about
it I as a language designer I'm like I
over as an academic like that sounds fun
but that's not the only thing I'm
interested in I just want to make better
in cooler things and so actually I'm
going to argue that adoption lets you
make better and cooler things so I'm
going to look at one particular case and
something called reinvention and I'm
going to look at something in context of
something called living will law this is
a very politically charged topic so but
what I instead of getting into that what
I do want to say is that both
Republicans and Democrats in the u.s.
think this is an important thing and so
both do lots of legislation on this
and there are a lot of points where they
agree that essentially you need to have
laws about what happens when somebody is
in a coma like what are their legal
rights and what's really so as a
Californian I was very excited
California wrote one of the first living
will laws that's good and then very soon
after Nevada wrote another living will
law and they actually especially said
the goal of this legislation is to
become in accordance with the recent
California legislation a living will a
lot so actually they have no innovation
in this law is just like the same thing
as just copy and paste but the real the
really surprised thing is like about ten
years later Arkansas which is not you
know liberal hippie California had made
its own living well a lot of legislation
and what's more is actually better than
that legislation that California had in
1976 so question is what happened and is
in kind of cool is this actually isn't a
singular event if you look at something
like school policy or maybe if you if
you don't like welfare but you want
people to go off welfare and get jobs
that's something called welfare reform
this is actually the same curve that
happened for how as policy spread
throughout the country that it got
better and so it's very law specific on
the case of living will law on the
questions does it handle more scenarios
that come up and how easy it is to
actually an independent of whether like
you know you can or cannot do something
how easy is it to exercise so think of
this like a flexible type system like
maybe does what you want it or not but
it's flexible like it gets you there
really quickly I'm gonna stop making fun
of type systems I've written a paper
about them so don't think I'm against
them so what's really going on here is
actually two very cool phenomenas but I
think we should be looking at one is
something called social learning where
basically this is kind of Arkansas
looking at somebody who did the did a
full deployment of the idea before and
you can just see how that worked for
them we copy the good things change the
change and fix the bad and kind of
related to that is something called
adaptation where you don't want to
you're going to be in a different
context than the person using the the
innovation before so in this case for
example if the legislation was made for
urban area now that it's because you're
in a rural area you're going to need
different legislation and so that's so
then you have to adapt it based on your
context so both of these phenomena you
can you can learn from them and see how
people work in those scenarios this is
very hard to do in a lab lab room
environment so if you're designing a
language I think it's actually very good
questions how can we harness kind of
this reinvention in the community to be
part of the language design process or
the future process and it more in
general if you're making technology you
know you could pretend you can invent it
all but i'm i'm going to say histories
against you so to be very concrete how
this shows up like as me leo has leo the
language designer i'll come up with an
idea i'll maybe prototype something
three to nine months maybe i'll send it
for 36 months the people the feedback
see if they like this language feature
then maybe i'll have to iterate again
and so now we're kind of entering this
year-long period and then heaven forbid
i decide to publish a paper about this
thing like that sounds like an extra
year long lead on i'm working on this
feature this is kind of where we are in
the language design community today even
in kind of an industrial setting like
it's a little faster but it's actually
not significantly faster and so the kind
of question is how do we streamline
language evolution so you actually could
involve the community involve the
community to actually improve your
technology so this is a experiment I
wanna be clear that I'm not doing this
but this pulls onto a lot of ideas
people are doing so again let's say we
start at the top with an idea now then
you're going to you're going to want
design your language feature but you're
not really interested in all that like
heavy gunky low-level details so notions
like language as a library where you can
do kind of a interpreter level or very
high level implementation and feature
that actually streamlines the process
and then from there you can actually go
and get out to the community right away
but however today you can't just you
know you can put it on a blog but who's
going to use it so the question is if
you're actually working within language
community how do you actually engage
with the language community and so for
example we have mechanical torque which
will give you you know people who I
don't know work at a call center that's
not very interesting but you can ask is
there kind of a mechanical turk
equivalent for trying out language
features and as far as I can tell there
is not so if you want to build one
please
let me know about it and that that's not
enough then you have to actually get the
data back from from these experiments
right if you actually want to learn from
how the community works and so there you
need is to get analytics from your
compiler maybe you actually have to as
you saw in the beginning of the talk you
actually I survey people see what's
going on like not everything is just in
the numbers like there's explanations
for the numbers and then finally you
realize that we're iterating and so you
actually want to put this all into the
central place you know state save that
data for somebody else fork and on the
next pipeline and so I'm not saying this
is necessarily the way to do it but
hopefully by principle of social
learning you you kind of appreciate you
oh there is this untapped resource that
we don't know how to take advantage of
today and for a lot of other people
works for us mark is making eyes up
yeah so um that's actually very
excellent question which is basically we
already have involved communities how to
like do we want to involve them in a
different way is that type of
involvement I'm talking about and so
through there actually want to draw an
example I was talking to one of the
Scala developers and particular concern
that they've been having which is
Scala's this language that's going under
rapid a kind of evolution as we speak
what basically happens is somebody like
Martin odorous ki will have an idea and
they'll kind of they'll put out a patch
or talk about on a mailing list but what
they realized pretty quickly on was that
essentially is an echo chamber that
you're talking to this kind of this like
very special demographic that this nut
does not necessarily relate it's unclear
how this demographic relates to the
demographic you actually care about and
so when I'm talking about social
learning I'm really saying get this out
to people the community or
representative the community who
actually really are working there and so
I think for example akma script we're
doing a really good job of for example
I'm getting high level developers at
Google and Microsoft to say what they
want in the language but unfortunately
those aren't the only people using the
language and I'd say those are the
minority and so I don't actually have
the solution for you but I do have a
problem for you where I have a proposal
for a solution I this is totally
untested so yeah that's a great question
okay so I'm going to go even now when I
want to go super high level um so I
talked about different ways of using
adoption for some particular tasks now
I'm gonna actually argue that this
should actually be shouldn't just be Leo
coming here and talking to you about it
so I think other people should be
looking at it and I want to give two
examples of why this was found this
interesting so here we have something
called an ecological theory and somebody
named mark about think 15 years ago and
asked an interesting question where I've
made an interesting observation that
discussing music with your friends is
on that and and so what kind of blood
from that is well is this does this
somehow drive how we how we pick music
and have music genres emerge and what he
kind of observed is that individuals
have time constraints you can't just
listen to all the music or talk to
everybody about your particular music
and seek them out and what what he
realized is it somehow it moves along
sort of demikhov's along demographic
lines and pretty interesting way and so
what you're seeing on that chart on the
left is on the x-axis people's age and
on that why axi people's education level
and so for example if you look at person
a on the top there's somewhere in that
middle age group but they're very very
educated and what's kind of cool is it
you can actually start drawing kind of
niches around which people listen to
what music so even if you don't know
anything about person a there's a good
chance they like or at least according
to this graphic they like new age music
if you look at somebody kind of older
somebody person be on the right they're
part of a much bigger demographic of a
big age demographic and that actually
country music I sort of surprised why
this is actually very popular in the US
even before the recent bluegrass stuff
and this isn't part of the appeal is
that it's actually for a lot of people
according to this reasoning is actually
a lot of people can talk to about each
other to country music and know what
they're talking about and so with the
the realization behind this chart i'm
showing you here is that when some sort
of innovation whether music technology
whatever is kind of competing out there
in the in the market it's actually not
competing for individuals but competing
for social networks so the case country
music has won the demographic of people
who are older while heavy metal has this
nice niche of younger people and so when
we're the interesting thing is if i go
back to this early graphic i showed in
the beginning of how language is spread
throughout sourceforge i kind of said
that Oh dsl's are going niche by niche
I'm actually going to make a much
stronger claim that according at least
to the ecological theory if your
language designer you're actually not
targeting the technology constraints of
the niche you're more generally
targeting your actual
community builder that you might
actually not necessarily have even fixed
any technical problems in that niche
according to a Catholic without like a
logical theory you've just somehow
spread into that particular social
network of the domain so when I say
domain-specific language I mean
community specific building or something
like that so this is kind of changes
exactly how we like evaluate or
understand languages right and so now I
want to finish on kind of one one last
example I don't know if like I grew up
in New England and we would like to make
snowmen there and I don't know if you
ever made one but you kind of roll the
snow and every time you roll the ball it
gets bigger and bigger right and
technologies actually kind of like that
in particular let's say you make some
you make one roll and you add in some
technology on top of the existing
technology but this is going to do is
enable new types of social interactions
for example oh we added a like a Twitter
wall or something or Facebook wall now
the sudden people standing in line at
the market can you know tweet on it and
this changes that means they have new
social interactions driven by the
technology but at the same time if we
turned about the snowball again now we
actually have based on those social
interactions new types of Technology
emerging and for their i might say for
example we actually before we had
twitter we had facebook and so because
people were using facebook then we were
able to advance the twitter and the kind
of relevance here is that if you want to
talk about designing a language building
some new technology that's only half of
the kind of the ball roll the other half
the ball roll is actually understand how
people are using it and that actually
tells you how the next iteration of the
technology works and this is kind of
good news bad news good news is that oh
we have this understanding where i claim
there's this relationship kind of the
bad news is twofold one is this
relationships and moving target because
the kind of codependent each it's kind
of human specific its society says
Pethick specific and the really bad news
here is I don't think sociologists are
going to do the work of understanding
the other side of the ball roll for us
so if you really want to understand this
i think you know i have to keep doing
this other people have to keep doing
this and we actually have to be a little
more i would claim scientific about it
but at least just looking at it somehow
so kind of in conclusion I kind of
showed you two things I don't think this
is actually conclusion I think there's
actually start of a lot of cool stuff
the first thing is I think we are in a
data era of language research by
it's not just software engineering or
analytics like I think it's actually how
we get data to understand how languages
work it will hopefully be no not as much
of an art going forward and the second
thing is i think when i talk about
program principles of programming
languages or language foundations my
argument here is that social theories
are actually one of the big foundations
that for a lot of the things we actually
care about and languages the social
theories actually inform whether they
work or not and how they should work and
actually give explanatory explanations
so with that I want to say if you
thought this is cool go to my website I
have data papers and an email link
probably somewhere there if you want to
talk more John
uh well I okay then let's let's harken
back to the safe sex example apparently
you know people on their own aren't
going to get push to do safe sex or but
somehow if you actually kind of hijack
the social process and interject on it
you can change it so there's actually
really bad news here which is one of the
kind of early results from kind of like
the modern school of sociology was that
a lot of these kind of social processes
are not automatically self-sustaining
that even if you do an intervention it's
actually designing it's a design an
intervention that keeps working it's
actually very hard so kind of good news
bad news good news is interventions work
those bad news is it's hard to actually
do them actually one last thing here I
was actually very impressed by the the
age and variant result because actually
what it told me is that kind of older
programmers are like there they actually
have a very long shelf life like you
know 60 year old what's new all the
popular language like this statistically
it was fun maybe there's some sample
bias here but I actually thought that to
be a very promising thing that they were
there on it oh
yes so the question is like how clear
was how do we at discern languages from
before from vs languages they are using
actively today there we actually we had
two different questions about that and
we put them in a particular order to
help them first question was what
language have you ever used and like
even if before and weird question but
careful of the phrasing to get at that
and then the second question is how what
languages you know well now um so I'm
totally with you on that I think there's
still problems with the phrasing but
actually mark and John like
yeah so I think that's a very good
observation which is that basically
languages may not necessarily be an
entirely technical innovation that like
there's still some perceptions and
beliefs involved and they're actually I
found two very very compelling areas of
research that helps kind of align my
thinking there the first one was a
historical linguistics which is I asking
questions like well why was Italian so
popular after the Romans and it's not
because Italian is a better language but
it's because well you know if you work
in the Roman army and learn whatever
though you'll become a citizen so
there's very there's kind of that's like
a issue of prestige and other things the
other community which actually is a
smaller body of research but also very
interesting is something called the
economics of religion where it's where
you get a statistician to actually ask
how religion works and there you get
funny results like for example if you
don't care if your language is adopted
in wide scale but you are interested in
if people keep using it so for example
you can do horrible experiments on them
which actually i think is a great model
for for academia you actually could be
very strict and very polarizing religion
or language and if you make it hard for
like hard for people to get in but then
once they're in is hard for them to
leave because like all your libraries
don't interoperate with anything else
people will stay and then you can try
things on them so they I totally agree
with you that there's like a lot like
not like non-technical going on or non
utilitarian middle
or
right um yeah so that I think that's
kind of what motivated a lot of this
work was that I feel like I think it's
sort of like not quite the same problem
that physics has today like but we're
getting there where our ideas are way
past what people could actually do and
like or what people will use but on the
other hand I actually don't think it's
when I look at numbers like actually
that the programmer today use many more
languages than they used before whether
those languages are actually very
different from the ones they use before
that's that's a good question and it's
definitely for example the research i do
for the language features i do like
those aren't going to show up your
language in a very long time that's also
kind of why I'm I think we should
understand this like I don't want that
to keep happening mark
try focusing the types of music scene I
would have attacked it focus would have
right purpose that you're imagining when
product events is to promote type
systems programming languages that that
gradual typing approach is optional
typing approach admit things that things
that allow types incremental II contexts
not having completely change program yes
so kind of question is something like
gradual typing which lets you mix in
static types into your dynamic language
let's make this the last question
actually yes so the question is like how
does gradual types which is supposed to
be kind of adoption oriented approach to
static types and mixing those into
popular dynamic languages does that work
or not I think in many cases does it
address a lot of issues but for example
can you imagine working with you know
three people one of them doesn't know
anything about static types and the
other to do use the gradual types could
the person who doesn't understand static
types very well actually write programs
that interrupt with them my claim is
actually with modern gradual type
systems the answer's no that's my
experience with doing something similar
at Adobe
yeah so that's like a slightly
definition that is what is the quote
what's the purpose of these types and
there I actually I agree with you that
actually yeah and are actually our
statistics agree with that where we
found that we asked actually people why
they thought static types are good
actually didn't think static types were
good for bug finding um they thought
unit tests generally we're better but
they did think static types were good
for explaining things so maybe that's
what the static type community should
look at a bit more strongly</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>