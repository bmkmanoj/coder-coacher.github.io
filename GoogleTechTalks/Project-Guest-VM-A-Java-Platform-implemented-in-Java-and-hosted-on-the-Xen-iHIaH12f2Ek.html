<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Project Guest VM - A Java Platform implemented in Java and hosted on the Xen... | Coder Coacher - Coaching Coders</title><meta content="Project Guest VM - A Java Platform implemented in Java and hosted on the Xen... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Project Guest VM - A Java Platform implemented in Java and hosted on the Xen...</b></h2><h5 class="post__date">2009-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iHIaH12f2Ek" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'd like to introduce Mick Jordan from
sun labs he's a he received his PhD at
Cambridge and worked on modulo 3 and is
now ready to bless us with a talk about
his current project which is project
guest VM which is a java platform
implemented in Java and and hosted on on
Zen something which is which is very
interesting to Googlers in general I
think and so here he is mcgeorge thank
you so hope you can hear me ok I'm not
used to sitting down while talking so it
could be interesting I will stay my
scene because I will prevent me from
trying to walk across the screen and
lose the mic so project guest VM an
extraordinary genetic name it might be
project guest JVM but we're not allowed
to do that in Sun unless we passed the
tck test so it's it used to be called
Java guess which I really liked but I
can't use that either ok so here's the
outline of the talk talk about the
context in which this work takes place
why it makes sense to do it and some of
the issues that we're trying to address
the opportunity that we have at the
moment and with various pieces coming
together and actual goals of the project
their little bit of related work i'll
talk about Zen and Maxine Maxine is a
new JVM at sun labs that i'm making
extensive use of then quite a bit about
the details about the guest VM itself
future work and then conclusions to date
now you will notice in there there are
no performance measurements and how can
you give a research talk without
performance measurements and I agree
that's bad basically it's this talks a
little premature i would have preferred
to have done this say in six months time
but i don't know where the world will be
in six months time i decided sort of
last fall when sun announced its big
layoffs and when things were going down
the tubes that I would get out early in
2009 and talk about this work regardless
of the actual state so that's why I'm
here today sir context so things that
job has been around for 14 years I
believe and over that time it's evolved
and
god knows how many directions and just
about every direction and it's pretty
much a complete platform now for
server-side applications certainly there
really isn't anything that you can't do
in the platform either with the platform
itself or with libraries from third
parties modern java applications don't
tend to contain native code now and they
used to have native code partly to
performance reasons and partly to plug
holes in the platform and both of those
have essentially gone away so most
server-side apps are actually now pure
Java the third bullets kind of a little
bit more straps contentious but I think
that generally speaking the later you do
your compilation more analysis you have
about what's really happening in your
application is about what you think
might happen in your application when
you compile astatically you're going to
get better results so we would like to
use that runtime compiler as much as we
possibly can and the final bullet is
hypervisors are really becoming
ubiquitous I think perhaps there's
they're not now but within a few years I
think every single server machine
possibly every desktop possibly even
every cell phone will be running a
hypervisor it's not clear which
hypervisor it'll be that's certainly
there's competition there but they will
be there and they will be just you can
just assume they are there so some of
the issues with the Java platform as it
is implemented today may typically a
Java platform is implemented with JVM
it's written in C code or C++ and a
mixture of Java code for the libraries
and native code some of which is
necessary in order to just deal with
that fact that that API layer in the OS
is written in C and you have to have
some way to connect to it the end result
of this is a fairly complicated
development and debugging environment
for platform developers but that's more
what I'm more interested in is the
crossing the layers that you have to do
as you go from Java into C code into the
OS can be expensive and if that's what
you're spending almost all your time
doing then that's an issue and certainly
serve raps spend the vast majority of
time traversing up and down the network
stack because they're either talking
HTTP input from somebody from a client
or they're talking JDBC output to a
database on the back side so they just
it's all layer crossing constantly down
into the this layer that was not
designed with Java in mind furthermore
the dynamic compiler that I just made
good things said good things about
doesn't see any of these layers it sits
above that doesn't just doesn't look
into them essentially the code you've
got from the c compiler is what you get
and as we as you know the java platform
it also has some special needs it has
automatic storage management or garbage
collection it has threading as part of
the language and those things are not
well served by existing OSAP is that
were designed in what the 70s for the
most part and you know really not we're
really trying to support see and not not
a language like Java our various people
who try to address this with Java
operating systems java on the bare metal
the real bare metal the problem with
that is it's really a lot of work and
it's a lot of ongoing work in the sense
that dry the network cards keep changing
the amount of work you have to do just
it's just it's prohibited essentially
you just can't really approach it so the
opportunity that we have with
particularly with Zen Zen has a power of
virtualization API which means that it
provides the somewhat higher level API
than the bare metal in particular in
respect to iOS a bit more about that
later but what it does is it
dramatically reduces the barrier to
entry for a bet for a quote spare metal
JVM just a lot less work to do and you
only you get to do it once sort of if
you really want to do a lazy approach
this in fact you can even sort of
delegate almost all the i/o
that you want to do because a hypervisor
environment you have a sibling operating
system potentially running by your side
which has full I ok capabilities so you
can just simply delegate network or or
file i/o after that sibling guest and
don't do any of that and that's how I
got started and that's how a number of
other projects have done that the final
piece in the opportunity is that we have
this new research vm being developed in
sun labs the research JVM it's written
in java 5 or these days we sit on six
but it's written in java so we have the
potential here the fundamental basis the
core of the system is to now written in
java so we have you know what we need to
get towards an old java stack so this
the main research question of this of
the project really is can an old java
software stack outperform this
traditional layered approach and there
are some metrics that we can use for
this in first and foremost is always
runtime performance people always want
things to go fast and that's certainly
in the Java world has been a constant
Achilles heel a lot of people I talk to
them or can perhaps more concerned about
ease of management it's it's actually
easier to manage an application that is
running on this platform than it is
that's one that's running on an OS
because everything you could possibly
configure is now configured through java
properties essentially through the
standard java mechanisms so if you want
to mess with the network stack
properties you do it in that way you
don't have to have two different
mechanisms two different things to talk
to i'm putting together an application
is simpler because you don't have to
configure an operating system first and
then the applications on top of it shell
scripts to run the thing all that stuff
just goes away finally as I alluded to
platform developer productivity we can
hopefully improve the lot of the typical
platform developer the mail gets to use
integrated development environments like
NetBeans or eclipse
and perhaps can say goodbye to make and
bi once and for all ok so the goals of
the project really first and foremost I
want to enable optimize possibly
specialized server-side applications
when all Java software stack it is an
application play I'm really not making
an operating system i'm not interested
in an operating system I've been there
done that we did think about doing that
the previous project I worked on
actually with Greg Tchaikovsky who I see
is probably in the maternity ward not
here was actually virtualizing the
virtual machine where we could run
multiple applications on a single VM and
we did think about putting that on top
of Zen and going further down that road
but in the in the end backed off to a
single application play so we're looking
at applications like application servers
game servers and so on and not trying to
boil the ocean we want to exploit access
to the low-level mechanisms we get with
with with the hypervisor in particularly
for thread scheduling and memory
management we get much lower level
access in the hypervisor environment
that we do in the OS environment to
those features the last who I alluded to
before really simplifying development
and increasing productivity there these
are essentially i would say in or in
order with priority starting at all so
here's what a stack looks like in the
conventional world on the left and in
the gas vmworld on the right everything
in shades of yellow is c code or c++
code set the hypervisor which is also
see or assembler right at the bottom and
you notice I assume that we have the
hypervisor is ubiquitous so everything's
running on the hypervisor and that's the
base of everything so on the left hand
side we have the JVM written in C or C++
some part of the platform library is
written in C we have a/c library we have
an operating system layer and in terms
of footprint of course this the size of
those boxes is is
is wrong I mean the OS is a much bigger
piece of than it appears in the picture
but then I couldn't fit the name in if I
do it that way on the right we have the
gas vmworld the only piece of C code we
have is a small micro kernel which it's
more of a Zen layer or a hypervisor
interface layer than a microkernel per
se but it has facilities like the base
of threading and so on is done at that
layer so it is really a microkernel in
that sense and then we have a network
stack and file system access above that
and then we have the platform libraries
that were previously written in in in NC
the parts of the platform libraries that
are in CR now in Java and we have the
maxine JVM which is also in Java so we
have as all Java a stack as we can we
can get so I'm on slide 9 now for those
who might be listening somewhere else so
the related work there is other work in
this space and this is just two of the
most well-known ones ba or now Oracle
have had something called liquid vm for
a couple of years now it's actually a
product and it's their j rocket jbm as
they call it on the bare metal i believe
this started in on zen back in in 2006
but now i think their production version
runs on vmware and you know so it's out
there what's what's different about both
of these projects and what I'm doing is
this is these both of these are
traditional C code so J ROC is written
in C they have a/c library that
implements network stack and so on that
Java is in you know as in that left hand
picture is still only up at the top
layer IBM have a thing called library
stands for library operating system
that's their j9 JVM very similar except
live or at least at the last count does
this trick of offloading everything to
do with network and disk i/o to a
sibling gets domain so it really doesn't
do very much in domain domain being
zens word for an active active guest
operating system ba actually have now
got all of that stuff in domain so they
have an endo main Network stack and and
violet system access NFS client and so
on so let's tell you a bit if I don't
know how much you guys know about zen
it's an open source hypervisor
originally from Cambridge University now
kind of owned by Citrix although still
is still quite a lot of open source
activity Oracle use it as the base of
their vm work it's distinguished and
things like VMware and virtual box and
the hyper-v from having this high level
paravirtualization api api which
requires the OS to be ported to the two
rather than hosted native initially this
was done because it was the easiest way
to deal with the fact that the Intel
processes of those early days wouldn't
couldn't be virtualized fully because
some of the instructions didn't cause
traps and they would just silently fail
so you had you had to do something in
order to get out to work and VMware
rewrites the OS sort of transparently
and that's too hard will will make
people port the code but will take
advantage of that and then we'll provide
a much better interface and they
certainly did that for i 0 they really
have a very convenient and high level io
model which is based on rings that
communicate through shared memory and
they have a split device driver model so
in the in the guest OS you have a simple
front-end driver that typically sends
packets or sends disk blocks through to
the back end via the ring and on the
back end you have something that
receives that and manages the real
device now what is the back end well in
Zen world they have something called the
control domain that not only is the
place in which from which you can create
new guests
and is essentially that so the
management point but it also manages
real hardware so that's how you create
new domains from within the control
domain the control domain is a fully
fledged operating system either a Linux
domain or in our case of Solaris domain
there is a trend towards disaggregating
and using domains more there are now
hardware device driver domains that are
separate from the control remains
they're trying to minimize the amount of
software actually in the control domain
because it is a security concern how
much stuff lives in there so let's move
on to maxine this new JVM this is
written in Java therefore it's it's meta
circular in the sense that it it uses
its own facilities to implement itself
everything in the vm is represented as a
java object so all the data structures
that you access or all representatives
are objects but there is low level
system programming support now what does
that mean and how is that implemented
jikes which is a similar vm from IBM
that has been around has an interface
called vm magic where special method
names are unknown to the compiler and
are compiled specially by the compiler
maxine uses annotations which are a
feature that came along in java 5 to
annotate methods as being special and as
you can essentially that's an extensible
mechanism you can have all kinds of
different annotations to indicate
different things fundamentally in
vaccine you can look at an object in a
variety of different ways you can see it
as an object and use the normal language
features for getting at it you can also
look at it as a reference which is
somewhat like an object reference but
you can't say x dot y you actually have
to access fields using symbolic offsets
references however might invoke the use
of right barriers for garbage collection
if necessary below that is something
called a grip which is actually a way
of seeing below that right barrier so
that when you write the garbage
collector in Java you tend to work with
grips so you look you're accessing those
objects at a different way and you're
and you're bypassing some sets and
critical operations that would happen in
user land finally if you really have to
you can you can look at an object as a
pointer as a natural machine address and
there are AP is it all looks when you
look see the code for this it all looks
like quite a lot of code is being
executed but because the compiler is
aware that these are special methods
through the annotations essentially
everything compiles down to the machine
code that you would write by hand so it
ends up being efficient it's just you
write it at a high level of abstraction
a big focus of Maxine is to try and use
the tools particularly the Ides that
application programmers in Java have the
benefit of and bring that to JVM
development so typically we use eclipse
or netbeans do the vm development and
there is you know there is that's how
you build the system it's very
configurable you can change the way
objects are laid out when you build a VM
image you can change the GC algorithms
you can change the way synchronization
is implemented how the system starts up
all these are done through things called
schemes and you register a scheme which
implements an API with the system and
then you provide an implementation of
that scheme and that gets folded into
the VM image when it's built it has a
very flexible and extensible optimizing
compiler and unlike most JVM is it
doesn't actually have an interpreter so
rather than starting from an interpreter
and then having moving to a just-in-time
compiler and then finally to an
optimizing compiler Maxine starts with
the view that will have an optimizing
compiler from the beginning and we'll
use a just-in-time compiler to compile
additional code and we won't have an
interpreter unless we really need it we
do actually have an interpreter now that
was just done by an intern but it isn't
a fundamental part of the system the
system is fundamentally based around the
optimizing compiler and the justic time
compiler shares a lot of a great deal of
code
optimizing compiler so 11 feature of
existing jvms is that the typical
bytecode will be implemented in three
different ways once in the interpreter
once in the just-in-time compiler and
once again in the optimizing compiler
and they don't really share anything
whereas in Maxine we try to write
everything just once so for example the
way that the jet implements a byte code
is it's the method for a bike is written
in pseudo Java well it's actually real
Java it just doesn't execute quite that
way so it has something like pushing up
around push another one ad and pop the
operand those method calls are actually
annotated as being special that gets fed
through the compiler to produce byte
codes which then gets fed through the
optimizing compiler to produce Machine
Co for whatever target you're working
for and that produces a template
instruction sequence but when you
compile the application class file each
byte code use go and look up in a table
and find that template and plug it all
together into a single instruction
stream so essentially the jet is machine
independent which is unusual the
question yes I can I defer that because
when I talk about how the images are
built you understand that ok yes right
ok this portable in terms its
instruction set architecture
independence OS dependency well factored
a a key thing is it's fully gd6
compatible one of the goals is that you
can take hotspot including the jdk and
drop maxine right in on top of the hot
spot and the applications will still run
so that's where they use canoe class
path and a bunch of other things
typically you can't run fully production
applications Maxine is designed to run
production apps and I can verify that so
how do you build one of these images
since this is a somewhat different
environment essentially you feed the
system through itself and you compile
the entire vm
and most of the platform with the
optimizing compiler what you get out of
that is a disk file which is essentially
an image of the vm with lots of machine
code and the and also lots of what's
called a bootstrap heat which is a lot
of pre-allocated objects that get
relocated together that gets memory
mapped at runtime and then relocated by
little sea startup program and then
you're up and running and once you've
got started what the vm does is actually
as delegates to the qantas runtime
scheme to see what we're going to do
typically we're just going to load a
main class and X and run but we might
use this for say running test programs
so instead of having a special some
special testing framework we have a
testing run scheme that runs tests that
have been compiled into the image and
then after that any additional classes
are loaded in the normal way and they
get compiled initially with the
just-in-time compiler and then possibly
eventually by the optimizing compiler if
they used enough so that's how the you
know the bytecode thing works though it
all right right so it runs on itself but
it runs on itself initially in some
other vm like hot spot to build one of
these images so guess VM images are
similar but a little bit different there
are a bunch of additional classes that
you need for example file system support
they have to be there up front you can't
dynamically load these because where are
you going to dynamically load them from
where you're going to load them from a
file system well how do you run your
file system when you haven't included it
in the image so there's a bootstrap
problem and we have to have some
additional stuff so I exploited the run
scheme mechanism of Maxine to come up
with an extension mechanism to add new
classes in fact a variety of different
things to be able to reinitialize things
if necessary to be able to include files
in the image a bunch of things like that
it's a very general mechanism is not
limited to guest VM and it actually part
of the standard Maxine distribution and
I use it in a special way my images get
converted to elf files and then they get
statically linked with the mic
colonel and then when the microkernel
starts up after Zen fires it up we pass
into the normal Maxine startup code and
from then on it's very much the same so
I said that it we wanted Maxine to be a
drop-in replacement and the question is
how does this work because the hotspot
JDK native code is dependent on on hot
spot there is a connection between those
two there anything in the in the native
side of a standard Java platform that
needs to depend on vm basics has is
specific to that vm we use us something
called the substitute annotation and i
use this extensively to essentially
replace all of the native code for say
the network api classes with java code
so if you look at the bottom here we
have a method from java.net which gets
all the network interfaces on your
platform and the way this is implemented
in maxine in general and guess p.m. in
specific is in a one of my packages i
import Java dot staff and I also
implementing classes and I say this
class is going to be substituting some
methods in the network interface class
and the user it's now private final
class because I don't want anyone to
actually access this thing it's going to
be accessed through the normal public
API of Java net but I named it in this
curious way to remind myself of what
it's actually is and then this method is
now a substitute method and say ok it's
the same syntax except it's not native
anymore and I implement it using those
com some guest VM net API classes the
way that the optimizing compiler handles
us at image build time is whenever it's
going to fill in a virtual method slot
or a static slot for this particular
classes instead of putting in
something that will eventually jump to
the need normal native code it actually
patches in the call to this class this
method which it discovers it a better
discover that it's in the image build
all right find it it's going to complain
so it's a kind of overloading mechanism
but it's trickier than that but it turns
out to be crucial to be able to have
this drop in trick okay so let's move on
to the components of guest VM so it's
talk about the microkernel with about
the network stack the file system and
the thread scheduler for the most
interesting components so the
microkernel if you download the Zen
distribution you and you look in extras
you'll find a thing called mini OS which
is an exemplar guest operating system it
doesn't do very much but it's supposed
to be sort of a hint as to what you
might need to to do to implement a new
guest this turns out to be very
important because the API for Zen is not
very well documented so there's actually
useful to go and read this and it's
quite a good starting point it's being
used more actually within the Zen world
now for small domains so we took it and
added a lot of new features because it
was pretty primitive it didn't support
more than one cpu it didn't have
preempted threading didn't have any
debugging support didn't have a disk
handler so we added all those things and
we've recently messed with this thread
scheduler to go to a two-level system so
this is now essentially a parallel
implementation of this that will of
course get put back into the
distribution because here it's GPL and
derived from that so the network stack
this is so clean fully integrated tcp/ip
Network stack written in Java really
developed for sun's java station I don't
know whether you any of you remember
this remarkable device that Sun in and
one of its some flights of fancy and
alert in the mid-90s society we should
all
these on our desks or some people should
it was a total believe a totally
interpreted system wasn't terribly
successful but the network stack was
just fine and got used for a bunch of
other things and it works very well i
reworked it with a bunch of one dot five
features because this was written in 96
I mean this very very basic code in here
didn't you know just a lot of stuff
wasn't available when it was written so
it wasn't multi-threaded in particular
there was a bit of a problem so that's
been changed a little bit you know and
the network device driver in some sense
is written in Java because they said
that the interface does n is
sufficiently high level that it's not
like a typical device driver we're
talking really about Ethernet packets
that flow across that ring from the
driver domain so I either I'm writing an
Ethernet packet or I'm receiving it in
an Ethernet packet but when the an
incoming packet comes in it it comes in
asynchronously on whatever thread
happens to be running and up calls into
Java to to deal with the packet we're
actually you know we really are an
interrupt contacts at that point and so
we can't run fully fledged Java we can't
do synchronized methods we can't do
things that might block we may need to
use spin locks and things like that in
order to do synchronization but we hand
the packet off essentially wake up a
thread that is waiting for incoming
packets and that's a fully fledged Java
threat that does use once it's picked up
the packets does use can use in fact the
packets at that point become garbage
collected objects and everything there
that flows up the stack is one hundred
percent java nothing special so that
that works fine so we just write at the
lowest level we have to be a little bit
careful about what we do so file system
so as i said everything's network based
in the server apps pretty much but you
still need a file system I mean
application servers have you know they
do put some configuration information
and files and so on and they're not
doing massive amounts of it but you need
it it's also in a development
environment
pretty important to be I have access to
files so what we do though is we just
implement what the platform needs so in
particular if you go and look at java
dot io star you go and grep for all the
native methods you essentially find an
interface that is specific to that
implementation of Java Rio of all the
things that you need to do to get io to
work so the obvious thing to do is just
define effectively a virtual file system
interface that mimics those native
methods then implement it in Java for
various different file systems and I
ended up with five the one of the bottom
is the one I started with which is one
that delegates off to the sibling domain
it goes off and and talks to a Linux
domain that's running in parallel what's
interesting about it that's nice about
this n high level API is you can you can
essentially define your own protocol for
communicating across the ring to do
these kind of inter domain calls so you
know it's like inventing something on
top of UDP except you're inventing it on
top of of the Zen pack ring layer so we
have an API essentially is of the form
open file read bytes seek and so are all
the things that you actually need to do
they don't get broken down into
something more low level we just send
them off at the highest level it turned
out to be convenient to have a file
system that was actually in the image
it's just a hash table effectively but
it's nice to have stuff there that's
right there after you built the image of
course we have a temp file system it's
just in the heat it's different from the
way this one because it's mutable
whereas the one that's in the image is
immutable once we got the disk driver
which only happened last summer we
needed a real file system and so I
looked around that I found one of these
operating systems that's written by the
guys who really are on the bare metals
called J node comes from the University
of Manchester and they have an ext2
implementation which is one of Linux I
think early Linux file system and so we
just took that and tweaked it a little
bit
basically dropped right in and
implemented the VFS interface to it and
now we have dis files and the final
piece is the NFS client this is actually
a piece of open-source son code that was
done again several years ago in some fit
of enthusiasm by somebody called web NFS
originally it's now called yet another
NFS but again it works dropped right in
and so now we have NF accent fess access
from the domain to so a lot of a lot of
different file systems so nurse gets bit
more interesting in some ways thread
scheduling so as this is where we can
exploit the fact that we can do Java
specific thread scheduling so there are
two kinds of threads in the system and
there are two schedulers now but there
aren't two threads systems so everything
is a kernel thread just who gets to
schedule which thread is what is
different so we're not multiplexing you
know em java threads onto n kernel
threads and those kind of games are used
to play with green threads when the
microkernel they're a bunch of threads
that most of which actually are to do is
start up a bootstrap handling network
set up and think there are some of the
rings that up communicating through Zen
store which I didn't mention but Zen
store is a tree structured information
communication mechanism that is the way
you can sort of pass certain things back
and forth between domains such as what's
your network device really most of the
actually terminate after bootstrap so we
don't really need to worry about
scheduling but we do need to worry about
scheduling them initially and this
bootstrapped startup is a little complex
and so it was impractical to kind of
totally replace it so what we decided to
do instead was go to a two-level
scheduler so the microkernel thread
scheduler which is what's called a mini
else stays much the same when it can't
find anything to do it up calls into
java the java thread scheduler it's a
little bit more
actually works both ways you can have
the microkernel thread scheduler
schedule all the Java straight as if you
want to see is just an option to say i
want up calls active and then at that
point it will start firing things up and
so in java we've got two kinds of
threads we've got vm threads things like
the garbage threads the compiler thread
and so on and we've got applications
threads that actually turns out to be
important to know those that there's a
distinction so the goals we have for
this is we want to enable custom
scheduling applications algorithms my
belief is that the server applications
each one is different and that there may
not be a generic scheduler that is
optimal for each of them and that if
it's easy enough you can just customize
or write a new scheduler for that
particular application and there's a
fair amount of research going on in in
the community and trying to do this
people who are trying to do things like
instead of having a time slice through a
thread you have a memory allocation
slice right and you schedule it after
you preempted after its allocated a
megabyte and some people people have
shown that you can get with certain
applications improve performance that
way so that's what we're trying to do
here same way that Maxine is trying to
encourage JVM research we're trying to
encourage lower level systems research
in Java but currently of people are
doing by first hacking hotspot to to do
this and then coming up with interface
to Linux so that they can send new more
information down to Linux scheduler and
then hacking the Linux schedule to
implement this new algorithm it's not
fun guys you know in this in this world
this is all a lot easier we're all in
you do all this in Eclipse one thing and
you run it and it that's the idea so
obviously we want to keep the policy in
the mechanism separate as always and
keep the tricky code constant because
you certainly can't shoot yourself in
the foot here if you don't get certain
key things right I mean then nothing
works and that's that's kind of bad so
basically the control flow is really
this up call model at certain key times
the microkernel up calls to say you know
I'm scheduling a Java thread or this
thread is blocking or this thread is
waking up and
and so on so the advantages we get from
this well first thing is it's a simpler
problem I mean we're trying to you know
we're essentially scheduling one
cooperative thread application whereas
the OS scheduler has to deal with the
fact that it's got many uncooperative
processes and so the algorithm doesn't
need to be although it might be
specialized it doesn't necessarily need
to be as sophisticated as say the Linux
scheduler because has got some sense a
simple problem we also know which
threads are which so we know something
is a GC thread it probably isn't worth
pre-empting a GC thread in certain
circumstances if it's doing something
that really needs to complete if you're
doing a stopping world GC there's no
point in crafting that's right you just
want to run it to this complete because
everyone's blocked until the GC is done
anyway it's nice and easy to add new
functions you know changing the time
slice making a thread specific time
slice that's trivial straightforward in
this world disabling preemption for
threads is easy but this meta
circularity can certainly be tricky you
enter the schedule in the middle of the
GC who knows what state your object
references are in they may be partially
copied so you're going to be careful the
traditional careful there's don't write
in Java right in some lower level which
means perhaps use the low-level features
like the grips and don't use object
references so yes it's not entirely you
certainly can't be just blind and write
as if you're an application program at
this level but a little bit on debugging
so there's basically nothing in the
stairs n world for doing into guess
debugging until very recently actually a
guy or Oracle's we seen develop some gdb
support and some stuff but when I
started this there was nothing what are
the really nice features of Maxine is it
has a gui-based debugger that
understands Maxine JVM data structures
so you can first it's gooey and so you
see everything in that nice way and you
could click on things and if they're
objects it'll show you their BM state
and so on and it was this was all
motivated by a lot of the work that was
done in say the self environment
originally
it uses ptrace or lib proc towards the
target vm in the Zen world again we
created another of these pseudo device
drivers another custom protocol to
communicate between the debugger and the
target domain and that turned out to be
a very fairly simple thing to do we have
to put a little bit sport in the
microkernel for it but not much here's a
picture which I don't expect you to be
able to read but this is what your
typical d sort of developer is looking
at when they're debugging the vm up here
we've got the threads and their state
names we've got registers so this is
low-level here we've got the stacks we
can see the call stack we can see
various vm notions here's the code this
is actually in jetted code you can tell
that by the fact that there are these
colors each of these bands of color
corresponds to a template which is a
sequence of machine instructions that
corresponds to one byte code and over
here we've got breakpoints and this is
actually a little object but I clicked
on one of these registers happen to be
if it's in green then the inspector
knows it's an object and when you click
on it it'll tell you what kind of object
it is and this is a string even though
you can't read that so this is is how I
debug most of the vm now how the vm
developers work and this is unique to
Maxine there is nothing equivalent to
there since they jikes ok so so what is
the status and availability of this work
well I'm running on solaris XP n which
is sons version of Zen on amd64 we made
a decision to be 64 bit only because we
don't think that in three years time
when this might be a product say that
32-bit will be interesting on the server
side even if it is now and that you know
they just simplifies things a little bit
but the inspectors fully functional we
got non-trivial programs executing the
network stack supports all the java net
api's big apps jealously more on next
page are in sort of test and debug mode
plan to open source it by Java 1 2009
and Maxine already open sourced in 2008
so that's that's important so future
work so big apps so I'm really a person
whose interests
in I've done a lot of work with
application servers and in the previous
projects I worked on and I'm much more
interested in big apps than I am in
micro benchmarks so here's three son has
an application server called glassfish
which is open source I've also worked
with jboss that works fine too and
that's that's what I consider something
worth trying to to benchmark son also
has a game server now written entirely
in Java called Dark Star which is pretty
interesting and that pretty interesting
because it has some interesting
scheduling behaviors because of the way
it's written and the API a present to
the game developers and that course is
due which I don't need to tell any of
you about since it's a ripoff of
Google's stuff but it's written in Java
and you know it's another big app so all
of those things I've experimented with
some of they've run to a certain degree
ultimately and first off I'm going to
compare performance that's the
performance light I would have if I was
further along would be how does
glassfish running on Maxine on solaris
or Linux compare against Maxine money on
gas p.m. I'm not going to compare hot
spot against Maxine because the
difference in the compiler quality would
dwarf anything else so it is going to be
an apples-to-apples comparison in the
longer term specialization and
optimization once we've got the thing
essentially working we can start doing
the interesting stuff I mentioned custom
thread scheduling already memory
management there's potentially some
interesting stuff to do there in the
hypervisor environment you're
essentially leveraging over commitment
of everything and there are people
interested in over-committing memory
it's a little more challenging but the
JVM has some interesting potential I
mean although you probably wouldn't run
a semi space collector as your
production GC it is the case that when
you are half your memory is unused for
that period and so you could give it
back to the hypervisor as long as you
get it back when you want to do the copy
and you know a typical Java app does
have fairly aggressive memory
requirements and maybe
there is a way once you know the
internals to to be more intelligent
about how you manage that ultimately
though we really want to exploit the
ability that we now have a stack that
goes all the way down essentially to the
network driver and that we can optimize
the application the JVM and the quote OS
unquote together with the runtime
compiler do even more analysis than
we're doing today with with hot spot and
those kinds of VMS and really make this
stack sing so conclusion today obviously
they're not complete because they don't
have performance numbers but I like tens
paravirtualization API I think the
device driver model is very convenient
and easy to use unfortunately API is
poorly documented I mean that's being
generous and I think the reason for this
it's not much new guest development
going on there are people doing what I'm
doing essentially it's all Linux right
one flavor of linux or another and so
you know they just take what's already
there and and run with it you haven't
got a lot of people doing brand new
guests so who cares if the API is not
documented right Maxine has been very
powerful easy to work with and very
flexible but no doubt it takes a long
time to get a vm to competitive
performance levels and you know that's
just just takes time as far as guest VM
itself is concerned I think the fact
that I can run things like glassfish to
a certain degree until it falls over
with GC bug I think the proof of concept
has been demonstrated that you can sit
the platform on top of the hypervisor
and it does perform but what the
performance improvement actually is and
we hope it's a positive one it could
turn out to be negative could turn out
there further the OS is so good and
those layers don't really matter but I'm
optimistic the be but in the end they
will but that's to be measured so we're
not quite there and with that I will
throw it open to questions or not
to be fair those so the question is what
the people working in the thread
scheduling area what other conclusions
they may have reached already to inspire
me to do this work to be fair right
those the papers around that work came
out after I started the work so it's
gratifying to see the people are working
in that and they are interested in a
platform like this considering the pain
they have today to go through the other
stuff so there was nothing specific
there were just general sense that we
can improve the world platform developer
if we do more of it in Java than we do
today right so the question is how is
this actually controlled is it the
application developer who's in charge of
the say that which thread scheduling out
and they run and so on well
traditionally they're in there are
options that directed at the vm to
control this behavior that are separate
although the application developer or
runner ends up setting those so so the
extent to which things can be boiled
down to an option that you can control
then that you would continue to follow
that putting together the application
with they say a completely custom thread
scheduler would be perhaps something
that your average application developer
isn't going to want to do but on the
other hand the people developing these
these big apps like like application
servers in game servers then on average
application developers I don't think
they would be
too concerned about that in in this
world it would be essentially when you
build the image you would specify a
particular thread scheduling scheme and
there would be as a parameter at that
level to the image build and then that's
it so your elude so you lured into the
fact that people have suggested will be
nice to have multiple concurrent GC
algorithms active in the same vm and how
nurse do you control that from a
management perspective arts and how
would you do it for thread scheduling to
there are people have done that people
have suggested that and have done some
implementations where you can have have
the vm switch GC algorithms on the fly
i'm not aware of it being available any
production VMS one of the people
actually who works on this is Tony print
ases who's actually at Sun but he did
some research work on this you know
ideally your vm is just just figures it
out given it if you give it enough tools
and enough power and enough alba and you
throw all the algorithms in and the
final analysis it just gets it right but
of course we're million miles away from
that and so oh and I've certainly
experienced the pain of trying to
configure the GC algorithms they exist
today because it's complicated
you know you make one slight misstep and
your performance is you know nonlinear
effects happen in your performance so I
think this is it remains a challenge
once you've got the power to actually to
control it in the right way you know
dials you know you'd ideally like some
dial that you can you know rotate and it
just gets it right but in a sense that's
separate from having the ability to put
the mechanisms it so I'm addressing that
first and then how you manage it is in
some sense a separable question the
thing I said alluded to at the beginning
is that one thing that's happening here
is we're managing we're all going to be
managing all this at the BN layer
whereas today we might have to manage
the scheduler of the OS layer we might
have to manage the GC of the Java layer
so we're at least putting it into a
single management framework which is a
small step but it's not obviously the
final answer yes no they're not they're
actually well actually they are only
that's good it should be sun labs door
research door son calm thank you for
picking that up Troy Java guest instead
that means that the request i put into
our webmaster to alias that has not
actually happened yeah and you won't
find too much there yet because
externally it's yeah we have to be
careful and yeah we're still working
through the open source stuff so more
will come yeah bro she was you yeah okay
about the
oh well footprint will be one you know
you are in a smaller footprint they run
weblogic on top of liquid vm and so they
have a smaller footprint in principle
they could get a lot of value out of
doing custom thread scheduling they
could also get memory management
advantages so so if they have actually
done the work inside their secret sea
layer to take advantage of those
features then they ought to be getting
improvements when I heard them talk
about it last they hadn't done any of
that they'd simply got it working I'm
sure since it's a product now they've
been beavering away on this and have
actually gone somewhere in that
direction but there's no public
information about it so I don't know but
the potential is there and son could get
the same with hot spot we could put hot
spot on Zen and get the same thing in
principle so what differs this work is
the old Java stack so the question is
how much code did I have to write before
I had the bare-minimum thing running on
top of sin well seem INEOS is a great
starting point because many oz runs so
it actually will run it what it does is
tell you what the time is and they just
keep doing that so it's all thread that
tells you the time so you sort of you
get there the first thing I did actually
was put the weather you've heard about
p.m. called dumb squawk it's the vm that
son puts in it sunspots the very very
small devices and as in order as a way
of keeping that the M simple and the Zen
part whereas where I was focusing I
really ported that so the very first
thing i got running was a scorpion we
know which ran hello world but you know
that this hypervisor layer is is thin in
particular the little piece that sits on
top of mini oz that talks you know that
cooks into the maxine startup is very
very small so i had things running
pretty quickly actually yeah okay
one more question how does the image
files footprint compared to class files
there the image file is quite large for
two reasons one is it's got a lot of not
particularly well optimized code in it
and a lot of data structures that
probably don't really strictly need to
be there we we've got some work to do to
try and cut the footprint down but so
since we're not imagining that we're
going to be downloading one of these
things we don't really care about the
footprint of the image file to be honest
it certainly is less than the footprint
of the OS plus a hotspot image so the
question is how much time do we spend
relocating the pointers in the image in
the booty when we start up I think is
probably vanishingly small compared to
almost anything else I mean I don't know
you know it's a linear function of how
many pointers there are in the in the
heap it's not it's it's really pretty
quick yeah so startup time you know this
is something I thought it wasn't really
expecting but startup time in this in
the Zen environment is really
interesting I sit there at a shell in
the control domain and I run the program
with a script that you know does one of
these XM create things which is the way
that Zen creates creates guest and it's
very easy to just forget that you're
running on a hypervisor you're actually
forking what is potentially entire
operating system because it's as fast
almost as fast as running a process in
Unix so it's it's it's spiffy and so
yeah its startup time is great in not a
problem and here's the good thing about
big apps that have a long startup time
and all the hassles about how long it
takes to compile it you get
checkpointing for free and then and we
support check pointing at guess p.m. so
you run your application up you load it
up you load all the classes you get
everything and then you check point it
and then
run it from there and it starts in zero
time essentially so you can forget about
that as a problem and you can migrate it
to another machine if you want so a lot
of nice things that come along with then
essentially for free yeah okay all right
all right we're done okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>