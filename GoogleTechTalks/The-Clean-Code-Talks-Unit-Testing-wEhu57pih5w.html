<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;The Clean Code Talks  -- Unit Testing&quot; | Coder Coacher - Coaching Coders</title><meta content="&quot;The Clean Code Talks  -- Unit Testing&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;The Clean Code Talks  -- Unit Testing&quot;</b></h2><h5 class="post__date">2008-11-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wEhu57pih5w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today we're going to talk about how
to write untestable code because we're
also good at it
how do you write hard to test code
it's monolithic okay
non-deterministic exactly okay that's
good
so here's something interesting right we
when asked us questions on an interview
most people have a really hard time
answering me what how exactly they would
go about writing hard to test code even
though the code they've read is really
hard to test so we are intrinsically
good at this even though we don't
ourselves are not we don't know how
exactly we're good at this thing it's
kind of like a spider weaving a web you
know it just knows how to weave the web
and you can ask him how did you do it
and in spiders I don't know it just kind
of works so this is what people normally
say like make things private use the
final keyboard have long methods and you
pointed out doing stuff monolithically
that kind of goes with long methods etc
non-determinism that's a good one too
that I don't have but here's the thing
that the real issues of unit testing and
that is mixing the new operator with
your business logic and we're going to
get to why exactly that's a problem in a
second looking for things and we do this
in our code all the time you know doing
work in the constructor that makes it so
that it's really hard to instantiate
things inside of your test having a
global state which is essentially where
all of the uncertainty comes from
Singleton's which is just another name
for global state and static methods
which is essentially procedural
programming and one thing that you can
really think about is suppose somebody
gives you a purely procedural code how
would you test it and it turns out that
I have no idea how to test really
procedural code because in order to test
something I need to isolate something
you know to isolate something I need to
have some kind of a seam and seam in in
the object-oriented world is my
polymorphism coming to play something
that I don't have in procedural code yes
these static methods are just because
you don't have a seam um so here's the
kind of the problem I don't want to get
into too much because there's a couple
of slides later that we're going to
cover this but the basic issue is this
if you have a leaf method such as a math
that absolute value piece of cake the
test right because it's a leaf it
doesn't call anybody else but if you
have a method that is way up in the coal
hierarchy and you trying to invoke that
method and you want to prevent that
method from calling I don't know a
database or something like that there is
no way for me to prevent that call from
happening because all the methods are
static there's nothing for me to
overwrite so yes in a simplest case when
you have a simple leaf method like an
absolute value or such such a thing
piece of cake but when it has to be a
more complicated program the answer is
no so the worst thing is trying to test
a main method if you try to test your
application from the main method
good luck chances are you cannot do it
so we don't really know how to do the
other thing is deep inheritance
hierarchies because it's essentially the
same problem I cannot divorce myself
from the inheritance in in at run time
right at at run time I would like to
build instantiate a small portion of my
application and if the test I want to if
the class I want to test is X and X
inherits from abcdefg then whether I
like it or not I'm testing all the other
classes as well and so inheritance deep
inheritance hierarchies is something
that makes it really hard so notice this
two lists most people actually cannot
answer the question of what makes code
hard to test even though we do this all
the time so we kind of want to talk
about this a little further
oh yeah and last one I forgot our good
old favor too many conditionals which is
the if statement but it is let's get
down this into further on oh wow this is
a really long list so uh here's the
thing
what can I tell you about writing tests
turns out nothing
like I cannot teach you anything there's
no magic to writing test absolutely not
it's a couple of framework I mean it's a
couple of tools like easy mocking
framework and stuff like that but for
the most part there is no secret
knowledge I have about testing none
whatsoever
what I do know a lot about is how to
read testable code and that kind of is
the core of the problem which is most
people assume that I'll write code and
I'll throw it over the wall and here
comes my test engineer and he'll write
some tests except that that point is too
late because the code is already written
in such a way that the test engineer
cannot write a good test it's too late
and it makes it kind of worse because
the the place where the mistake is made
which is writing the code and a person
who feels the pain of hard to test code
are not the same people and as a result
it's really hard to kind of affect
change in an organization like that and
so we're all kind of guilty of this
so don't yes but for unit tests it
should be ideally the same people right
so the people yes yeah exactly so you're
talking about other tests as well or um
no we this is kind of introduction so
absolutely we want to get everybody to
unit testing level and in the unit
testing it has to be the same person I'm
just trying to point out how the other
constant tests don't really work so
we're going to talk about another unit
test in a second so just hold on one
second so glad to know that you're out
of the curve though it's good so what
can I tell you about writing testable
code well there's that I can we can talk
about what good ol' is and how it helps
testing and we're gonna devolve into
this thing a little bit and we can also
talk about something we call dependency
injection sometimes I feel like the
dependency injection I'm selling a snake
oil because it fixes so many things but
it does actually work of course there's
the test-driven development which as you
point out if you want to take the unit
testing folks together you want to make
sure that the person who writes the
tests and the person writes the code is
Italy the same person and you want to go
definitely into the unit testing route
which we'll get to in a second
so here's the thing there is absolutely
no secret to writing tests now however
the only secrets there are as to writing
testable code and that's kind of what we
want to talk about and it sounds like
you're already ahead of the game and you
already know that the answer is unit
testing but for most people aren't there
aren't actually that far along and they
always the most people are still stuck
on the on the premise that there is just
some secret sauce to testing which there
isn't so how do we I like to think about
unit testing imagine you want to test
the car and somebody says to you please
test the car for me to make sure the car
works everybody who's new to testing but
immediately says oh I know
I'm gonna build a framework in a context
of a car I'm gonna build something where
the car can sit on top of and I'm gonna
build some machine that will pretend to
be a driver and we'll turn the steering
wheel and push the brake and the gas and
play with the knobs and that's how I'm
going to test that the car works and
this tool basically scenario test is in
a test like that is actually pretty cool
because it does actually prove that the
car works the problem with it is the
execution and that is these tests are
horribly slow because let's say you want
to prove that the car all-wheel-drive
system works correctly well now you have
to get the car into where there is ice
so now we're gonna do to drive it into a
refrigerator and then you want to make
sure that the car can start doesn't
overheat at you know really hot
temperatures in a desert now we're gonna
do drive it in the oven right even if
you can do that in if you can build all
these frameworks uh these things are
going to be really really slow and
they're gonna be flaky there's so many
things that could possibly go wrong
you're testing the whole system into and
like maybe the oven is broken maybe it's
not the fault of the car so the problem
with scenario or large-scale test is
that they're flaky they're slow and
they're flaky and it's not uncommon for
you to have to take several hours to
execute all of your scenario based tests
not very useful so then you say well
maybe we can do something better so we
can
you discover basically your tests are
slow and you discover the tests are
flaky right we kind of covered this so
this is the kind of the first stage of
unit testing the people discover hey
test good so we can automate this thing
here's the good thing you have a really
high confidence when things work that
the thing actually worked but the car
actually work right
whereas if something goes wrong you're
not really sure if the problem with the
car or is it because the designer has
moved the knob you know and one inch to
the left and all of a sudden the the
framework can't grab anything you're
just really not sure of what exactly
went wrong and a lot of times things are
just flaky and you don't really know why
because there's so many variables coming
to play so it's really hard to reproduce
trailers so suppose if it's flaky and it
fails and you're like okay let's do it
again
and all sudden works this time and you
really have no idea how and why and so
on so I'm just pointing out how how
troublesome that is so then you got to
think about and you say well maybe
instead of testing the whole car I can
break the car down into parts and test
them individually so maybe instead of
pretending to be a driver where I turn
on and off the radio
maybe I can take the radio out in
isolation and hook it up to maybe an
oscilloscope for the output of the of
the radio and remove the knobs and
instead of the knobs put some kind of a
analog to digital converter that
directly controls the knobs and now I
can test the radio in isolation
independent of the car and I can bake it
cook it and do all kinds of things with
it to make sure that the radio works
just as as we planned we can do the same
exact thing for the engine for the
transmission and for any other component
in the car that's large scale component
and so what you discover is things get a
lot better again when you when the
things are green you're pretty sure that
the thing works when it's red you're
also pretty sure that things aren't
something went wrong because you took so
many variables out and you only have
these large scale systems and you're
pretty sure that things are just
something's broken right the thing the
problem with that is suppose the radio
doesn't come on like good luck figuring
out which part of the radio is broken
the engine doesn't start good luck
figuring out what
exactly is wrong with the engine like
it's much better than having the whole
car and pretending to be testing that
but it's not quite what we want all
right so we call this medium level tests
or functional tests because you take the
single functionality and try to test it
in isolations from a software point of
view this is kind of like taking your
app and instead of replacing the the
outside service like the authentication
server you're going to replace with an
in-memory fake LDAP or something like
that which authenticates and so on so
you basically focus down on individual
pieces and you test them in isolation so
then you say to yourself wait a minute
if going from large-scale testing to
medium scale testing we got better at
this maybe we can go in further and go
down to individual components and in the
world of software that's that's
individual classes so instead of testing
that the engine works as a whole maybe I
can basically have individual tests that
that that verify that the piston is the
correct shape that the oil is present
that the spark plug it has the correct
clearance and so on and so forth and I'm
just individually testing all these
pieces and I know that if all those
pieces are correct then I am very very
confident that the engine will actually
start and if I discover a case where the
engine doesn't start I can always go
back and figure out what was the root
cause and add a test for that root cause
so it turns out that these kinds of
tests are great because they're super
faster this is our unit test from a
software point of view this is where
you're testing individual classes
they're really good because you have
really high confidence the tests are
really fast we went down from several
hours to run and verify the product
works down to seconds literally seconds
and now you can do crazy stuff you can
say to yourself hmm maybe I can hook up
my Save button so every time I save the
code it just runs all the tests because
they're a couple of seconds what's the
problem
so imagine writing writing code where
you just code along and say oh yeah okay
I think I'm ready to save ctrl s and wha
and you know immediately if you broke
something or not it's a nice hole to be
in right and
really the other nice thing about it is
if the test fails it directly points the
cause right if if the sparkplug
clearance is not good you know exactly
what needs to be replaced like there's
no question about this right so if a
function that is supposed to be doing
sorting fails and doesn't sort properly
like you know exactly where to go look
for the error like in most of the cases
you don't even need a debugger to figure
this out so this is the promised land of
of unit testing so ah as I said most
people when you first tell them ratney a
automated framework for testing they'll
immediately think oh I got to pretend to
be a user and I got to write some kind
of a framework and we call it a scenario
based testing and there is so many
problems with that that I think your
your effort is better spent on unit
testing if you have unit testing and you
have nothing else you're way better off
than if you have just scenario testing
now of course you're better off if you
have unit testing and functional testing
a little bit of scenario testing but for
the most part you want to have unit
testing now when they build a car in the
factory here's the something fun that
happens they put the card together they
have individual tests to prove the
pieces work and they have one final test
and a final test is they take a key that
shove it in the ignition they turn and
they drive it to the parking lot if that
works that means a lot of things that
means that the battery got hooked up and
it's charged right it means that the
steering wheel is hooked up there's gas
in the engine and so on and so far
there's all the long list of things that
kind of means that kind of works now
notice we didn't prove that all these
things working on their old condition
all are proving to ourselves is that you
got hooked up properly together and
that's the purpose of a scenario test
you just want to kind of make sure that
things got hooked up properly together
and you have separate unit tests to
prove that all the pieces work and you
kind of have functional tests to kind of
prove that individual related pieces
work like the radio works in isolation
the engines work in isolation the
transmission works in isolation so
therefore I just want to make sure it's
hooked up together now I'm pretty
confident the whole system is going to
work as well
so all these these different levels as I
said are important because you have all
different probabilities that you're
going to find a bug but they're
different kinds it's a unit testing is
all about does it do the right thing
whereas in the other extreme is is it
hooked up properly and then everything
in the middle is kind of you know the
medium says add the kind of test a
little bit of both but again we just
want to have these kind of extremes we
don't want to this everything at once
because it becomes hard to test turns
out that if you us there's a way to code
so that you separate out the hooking up
problem from the functional problem and
that way of coding is actually called
dependency injection we'll look at it in
a second why that is important we can
already touched on this but I'm just
going to cover this again and that is
you really want to have large number of
unit tests typically the number of unit
tests is going to be semi equivalent to
or the number of lines of code of test
JUnit test code is going to be
approximately equivalent to the number
of lines of code and production code
that pretty much you know give or take
you know in the same ballpark which also
pretty much translates to about the
roughly same number of test cases two
function methods you have but that does
not imply that you actually want to have
one test case per function you just have
approximately same number of test cases
you want to have a slot smaller set of
functional tests the kind of test that
the sub individual subcomponents gonna
work together properly there you're
starting to get more in the business of
is it hooked up properly when I pass
this object to this object as the other
object expect to get it in the correct
State that's gonna watch your testing
over there and then the scenario tester
is testing the form of these the pieces
kind of talk to each other how we expect
to get a server come up in isolation
kind of thing we really don't go into
the details of of replicating things um
I'm gonna skipped over this I'm gonna
come down to here so unit testing we
decided in here that unit testing is a
good idea ah so you have a test driver
the J unit and you have class under test
and you apply some stimulus to the class
on the testicle some methods write on it
and then you assert that something
expected happened he's okay easy so why
are we having this discussion why's it
so hard
what's the problem with this model right
here yes things often have dependencies
exactly so the really reality of it is
that the class under test usually has
those other classes it depends on and
guess what those things depend on other
classes so I do something benign like I
say you class X and in the constructor
of it it goes off and starts
constructing other classes and those
classes and medic instructors go off and
construct other classes and so on and on
and on now so we have the same problem
as we had with procedural programming as
you pointed out at the beginning if it's
a leaf class yeah it's a piece of cake
to test nobody really has to explain to
me how exactly I test the array dot sort
and piece of cake it's a leaf but how do
I test oh I don't know the login page
totally different of all the things so
in order to test this thing um really
really need something we call the seam
we basically need to be able to take a
knife and then kind of cut all the
dependencies and the seam is important
because it allows us to divert the
execution of the code this is why
procedural programming is problematic or
rather static methods are problematic
right because if you call another static
method there's nothing I can do in a
test to prevent that hack a call from
happening now I'm sure you can come up
with a simple case like oh but I'm just
going math that absolute value therefore
it's okay but usually when you have some
static utility method people keep adding
stuff to it and so what started off as a
benign
method call which was not intense and
not in to intercept able ends up to be
this complicated beast that a little
sudden is not intercepted by land all of
a sudden it's not so good so I take the
extreme point of view and I simply say
in my code I don't have on have any kind
of statics whatsoever it turns out that
in most cases when I see static calls I
usually look at them and I say yeah this
actually belongs on this class over here
and you know there's something wrong
about the old decomposition of the
project for example as you take the
extreme example of math that absolute
value I firmly believe that the the five
should be able to say five dot absolute
value why do I have to say absolute
value and passing the five it should be
just a compiler sugar that does all the
magic underneath it and I believe in
languages like Ruby you can do that that
doesn't imply that the pipe has to be an
object it just means that the compiler
knows how to convert all these things so
we need to have a seam so great so we
have a scene and what seam allows us to
do is to replace these dependencies with
Friendly's now when I say a friendly I
don't necessarily mean a mock it could
be a the real class that I'm already
tested somewhere else and I already know
that it's gonna do the right thing
therefore I'm perfectly happy to
instantiate the real thing but I trusted
I know when the test fails the problem
isn't over there because I have other
tests to prove that that stuff works it
could be the real thing
it could be a stub such as that it does
nothing like for example in a logging
framework I'll just throw in a stub so
that you don't bother logging anything
cuz it's not relevant for the purpose of
the test it could be a mock which
returns you need um some collaboration
it could be a simulator kind of a thing
that kind of simulates the thing which
is kind of like a smarter mock the point
here is not what you put over there the
point here that from a testing point of
view I have a choice to place anything I
want over there and that requires a
special ray of writing code if you and
your coach is simply called a new
operator on a class well there's nothing
I can do right even if you'd say even if
you
if there is anything create an interface
for these times but if you instantiate
the implementation of the interface
there is nothing I can do from a testing
point of view so it is really really
important to have these seems and how
exactly we place scenes in insert inside
of our code that is something that is
that most of us are not experts at it's
not something we have learned in school
it's not something that we have learned
through hacking it's not something you
even needed because unless you were
writing tests already why would you be
placing seams everywhere so how exactly
do we need the seam so let's back up and
keep the seam in a back of mine our mine
and let's talk about something else
in most of our classes that we have we
have object graph construction and
lookup with business logic business
logic is the if statements and the loops
and the stuff that actually does work
and the object graph construction lookup
is basically your new operators when
you're constructing the object graph and
it's also your let me go and find what I
need code usually in terms of let me go
talk to the context objects so that I
can find my property so that I can use
the property to open a file and read the
parameters that I need which makes it
impossible for me to ever give you the
fake parameter in a test or at least
makes it really really miserably hard so
that's what I mean that object
construction and lookup and then the
really good stuff happens where most of
our bugs are which is in the if
statements and loops and etc in most
code I have seen those two pieces are
together and it's probably the code that
you write as well but it turns out that
those two responsibilities need to be
separated you are either in the business
of constructing things building object
graphs is constructing the application
with all the instances of the classes or
you're in the business of being those
things that got constructed at doing the
actual work if you separate these two
things out it turns out testing is
trivial not trivial but really really
easy so let's look at how that works out
the little bubble on the arrow
represents where the new operator is
located if that little bubble started
off inside of the blue
class under the test I could have never
ever controlled the construction of that
class but because I have migrated the
new operator into my test now the test
has the responsibility of constructing
the object graph and then I take those
objects and I pass them through the
constructor of the class under test and
then the class under test then
collaborates with the things that I've
passed in now this gives me a choice in
a testing world because now I am free to
instantiate a subset of the application
that I want to test and I only have to
instantiate the whole thing I simply
instantiate the stuff that I really
really care about and I have a choice
in terms of how I set things up if I
choose to think she ate the real thing
then maybe I can you know configure it
in the correct way so if I'm testing a
cache I'm going to think she ate a cache
that has a cache size of 1 so that I'll
get misses all the time right whereas in
production I know I'm going to have
cache size of 10,000 but I don't want to
do that in testing purposes because my
gosh it's going to take forever to cause
misses to happen right so the point is
you want to make sure that your code is
kind of devoid of the new operator
because new operator is static and it
causes direct binding and you want to
basically say I need these objects to
collaborate a new constructor you say
hey I need the file cache please provide
it to me it is not my responsibility to
go and read some property file on the
hard disk and I want to figure out how
to instantiate a file cache and then
configure it in some specific way or it
is not my responsibility to do cache
that get instance and look into a global
state variable which is the instance
variable of the cache and get ahold of
the cache that way either I simply say I
need a cache in my constructor and one
will be provided for me in a testing
world in a test world we'll provide you
with a some kind of a small size cache
which we can go and test in production
you'll be provided with the real thing
so the new operator separation is
important because that allows us to do
sub classing when we can do sub classing
we can take advantage of polymorphism
and polymorphism is what the seam is
does that make sense now show of hands
how many of you guys actually do this in
your code you do this excellent
so you know all about dependency
injection so let me ask the question
again how do you write hard to test code
the real crux of the problem is if you
want my code hard to test you're going
to mix your object creation code with
business logic the moment you do that
you mix those two pieces together you
cannot instantiate anything in isolation
and when you cannot instantiate anything
in isolation the only thing you can
possibly instantiate is these humungous
chunks of application which pretty much
cause you to instantiate the whole thing
and now we're back to square one which
is scenario based testing and we kind of
already decided it's not a good idea Wow
I went through this really fast today so
the takeaways are this that unit we
really really want to be able to test in
the form of a unit test not as a
scenario based test and in order for us
to be able to take unit tests we need to
separate the object instantiation
responsibility from the actual
responsibility of doing work you are
either a factory which is responsible
for creating some object graph or you
are the part of the objects that are
doing some work you don't want to mix
the two all right I kind of rushed these
slides I'm not sure why so we have
covered them all in mazing half an hour
so I'm going to turn it to you guys for
questions
and if you being so kind and grab the
microphone I'd be awesome and maybe even
come closer so you're not so far away I
was thinking I should mention something
which is that some of the dependency
injection is better you need it depends
on what language you program in okay if
you program in Perl or Ruby you can
often find a seem druid language being
dynamic yes you I'm probably referring
to monkey patching right yeah okay um we
haven't talked about the the idea of
global variables but basically global
variables make it called really really
really hard to test because things are
unpredictable the order of the test
matters and so on and so forth and it
turns out that doing monkey patching
code is in global space and you monkey
patching the code often time results in
you changing global State which means if
you go in monkey patch a class and then
another class runs and you didn't
properly clean up after yourself then
the new test will fail so even though
many languages like Ruby JavaScript etc
allow you to the monkey patching whether
if you do monkey patching and a class
instance you can probably get away with
it if you do it on a class level it
usually is a bad idea and it's no
different than having global State and
there's a separate talk we do just all
the evils of global State so even if you
have that I think the dependency
injection is still good idea and I think
what a baby you're going to say
something you disagree you think monkey
patching is great idea okay
you want to give you a point of view
yeah what you said is exactly right the
problem is if you don't clean up
properly after yourself in the next test
runs in an unknown state right so if you
have a good framework that will ensure
that things are cleaned up then you
don't have that problem okay
and generally it's a lot less intrusive
of framework than a DI framework
different opinions of course Dave is the
Ruby guy who's the highly dynamic
language guy I'm the static typing guy
yeah so I respect my framework does
exactly that it cleans up after itself
if you step up methods to return
instances and so forth how does it know
which things you modified because you
modify it through the framework uh he
keeps track the track go to my query
stores everything when it's done other
questions
so in Java you have dependency injection
and you have nice fancy tools like juice
for what we call automatic dependency
injection frameworks people oftentimes
confuse and they say oh I'm in C++ C++
doesn't have juice therefore I
dependency injection is not for me it
turns out that dependency injection the
practice which is asking for things in
the constructor in dependency injection
the automatic frameworks just Jews are
two independent things and so you can
have one without the other and you can
perfectly well use dependency injection
in C++ with manual where you have to
break the factories yourself great well
thank you guys for coming see you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>