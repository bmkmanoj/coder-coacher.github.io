<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Topics in Programming Languages Series:... | Coder Coacher - Coaching Coders</title><meta content="Advanced Topics in Programming Languages Series:... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Topics in Programming Languages Series:...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EJXebaPx1mU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes my voice is not very powerful today
so I apologize short Alex's voice will
be absolutely fine hello and welcome to
yet another in our series ongoing series
of programming languages talks today
we're very lucky to have a guest speaker
talking to us about something that is of
increasing interest at Google static
analysis and specifically static
analysis in the context of concurrency
his name is Alex akin and he's been
doing a lot of work in this he's a
professor at Stanford University and
here he is thank you very much Jeremy
and it's great to be here thanks very
much for inviting me to give a talk so
today I'm going to talk about well you
can see the title the slide effective
static race detection for java and my
name is listed first but this is really
my urine IX PhD thesis work and I'm just
here to be the talking head and all the
hard questions I will just defer them
over to my you're so so this is a slide
that probably everybody here is more or
less aware of but there's a big change
going on today and has been actually as
a change it started some time ago but
very recently has really taken hold that
you know the clock speed is a peaked so
hardware is not going to get a lot
faster in terms of number of
instructions that can be issued in a
single processor per second in the
future and but the number of transistors
have continued to grow the number so
just because we can't make we can't
clock the chips faster doesn't mean we
can't continue to pack more and more
transistors under the chip and so with
vendors are doing about this is their
shipping multi-core processors okay and
what does that mean it means that
concurrency is going to be a lot more
important in the future than it has been
in the past all right so until now
increasing clock speeds mean meant that
if you just did absolutely nothing your
program ran faster every year so for no
effort you got a fifty percent on
average increase in performance assuming
you were completely cpu-bound not I see
no
not memory that's all right it's all
right we'll see I'm not quite sure what
well I'll figure out how to talk to this
as we go along so presumably the slides
will cycle back when there's something
interesting on them and somebody back
there is making a decision about whether
to show this light or not no content
switch to a graphic of the audience okay
so sorry a flax piece kept getting
faster that even the sequential programs
ran faster but in the future the fact
that we're only increasing number cpu
cores means that only concurrent
programs are going to run faster all
right now this is actually the fact that
concurrency it affected me to do more
concurrent programming or the fact that
concurrent programming is interesting
topic this is not something new but you
know people in this audience probably
well aware this for a long time and
here's the standard baby example of why
reasoning about concurrent programs is
not so easy so here's a place we're
doing an update it's just review for
anybody doesn't know this stuff and what
we do well if we want to increment X by
one we have to do a load we do the
increment then we have to do a store ok
so the temporary here is supposed to
suggest that this is something that
lives in some kind of local storage like
a register and this is something that's
out in some kind of share storage like
main memory and so we do you know one
possible execution of this are the only
possible execution of this we do the
load the increment in the store and if
we have another thread that's the same
thing using a different temporary but
using the same shared variable then
here's one possible ordering there's
another possible execution sequence and
these are the two that we would like to
have but then of course there's all
kinds of other execution sequences if
the unit of atomicity here of single
instruction executes is single
instruction execution we get in you're
leaving like this and the problem is
that I in the first case first two cases
we get the expected result where X has
been committed by two but in the last
case and and and many of the other cases
if not all of them I we get the wrong
answer ok so we actually lose one of the
updates and X comes back as the wrong
value all right so I got a position
myself here a little better with respect
to this wireless
alright so a race then is when we have
the same location access by different
threads simultaneously so you have some
shared location excess by two threads
and at least one of those locations is a
right okay and the simultaneous here
means that there's no ordering
constraint imposed by the program it's
actually possible for these things to
happen at the same time okay and so race
conditions are particularly insidious
kind of concurrency bug and the is
triggered under non-deterministic
circumstances you don't because this
depends on the thread scheduler you
don't know just because you just because
the program works once it doesn't mean
that if you run it again it will work
the second time and the second problem
is that there's no fail stop behavior so
meaning that in a lot of cases when you
can counter about something like a null
pointer dereference the program just
stops okay so even if they even if the
bug itself might be triggered
non-deterministic alimi doesn't happen
in every execution not repeatedly at
least when it does happen the program
actually stops running that doesn't
happen with race conditions so the
program will just keep happily executing
along and who knows what will you know
what will be the the final result so you
won't discover the air if you discovered
at all until far into the far after the
time at which the air actually occurred
and of course race conditions have been
something that I've been studied for a
long time in concurrency theory and
practice all right and it's actually not
just race conditions that that where
this problem comes up so actually the
notion of a race occurs in the
formulation of many other properties you
would like to talk about with respect to
concurrency so for example if you want
to check atomicity if you have atomicity
declarations in a program checking
whether the dynamics the decorations
actually make sense boils down to a race
detection problem similarly for deadlock
detection to do deadlock detection you
actually need a race checker all right
and I think it's pretty well known that
current concurrent programs today are
just riddled with races all right so
it's a pretty much in pick of any
concurrent java program and you're going
to find race conditions in it okay at
least any concurrent java program of
significant size all right okay so let's
come back to our example and as we said
before the same location what was the
what was the condition in which we
actually had the race the same location
has to be accessed by different threads
simultaneously and at least one of those
accesses is a right okay so in this case
the right to the shared variable X all
right and then there's the other one is
the read of X so here we have it you
know we have a race between this right
and this right and between this read and
this right and also between that read in
that right okay those are all the
potential races in this little fragment
okay all right now upsetting so so let's
let's refine this condition a little bit
so we say the same location has to be
accessed by different threads
simultaneously without holding a common
lock okay so instead of just talking
about you know sort of general accesses
let's focus on the lock based
synchronization I discipline so in most
common way of controlling access to
shared locations is through locks and
the the talk i'm going to talk about the
something I talk about today is all
about doing this only in the presence of
locks okay so we're not gonna look at
other synchronization idioms okay so now
we've talked about some previous work so
this is not a new problem and what I
would really like to do by see I can't
do it because there's tape on the floor
indicating this thing has to stay in its
current position all right so I will
stand here and do my best to focus my
focus on the slides were also facing you
so maybe I should actually use the
lecturing like a lectern and stand here
how's this look okay that's good alright
so it's a fair about our previous work
on this going way back okay and this is
all about race detection and they feel
back in fields 1980s was a fair amount
of work 1990s all that kind of work
picked up since 2000 there's been even
more okay it just goes on and on and on
alright so I hope that most of what i
said here so far has been stuff it's all
relatively familiar to you with over
half sore one or two small things that
they hadn't seen before and the bottom
line observation if you were to
summarize all this work from the point
of view of tools is that none of these
tools none of the tools that have been
is to actually do very much in practice
so if you actually turn them loose on
real code they will find some races but
very few actually and far fewer than we
expect to actually see in these programs
all right and here's some here's a brief
overview of our results so this is
looking at relatively mature Java
programs as all open source stuffs of
large open source java programs and i'll
tell you which ones we looked at
specifically in a little while but if
you think that you know all the work
published in the last decade and you add
up all the bugs reported in in those
papers and then these are the ones from
the work that we've done in the last
year so and we have a quantum change in
the effectiveness of the tool so that's
why the title of the stock is effective
static race detection now there are some
new ideas and I will tell you what those
are there also a lot of old ideas in
court so you know all the stuff that
went before we certainly built upon it
and used a lot of the concepts of people
had previously discovered we've put them
together in a new way and we've also
filled in some holes and I'll tell you
exactly what those were any other some
key things that at the previous
approaches weren't doing it turned out
to be important all right okay so what's
our approach to race detection so we're
going to see how go ahead sorry hey yeah
demars site
commit PS work dynamic
it would go a little bit tired and not a
lot okay you went yeah so this is this
this bar here is supposed to include
both static and dynamic mayoral says I
wasn't quite sure if we had the dynamic
techniques in there there are also the
answer is no would move at all and and
the reason for that is that the dynamic
techniques well so why don't the static
technique so I'll just for shadow things
a little bit so the problem with most of
the static techniques besides being
incomplete mean they're not they're not
sound and guaranteed to find all the
races which we are all right in addition
Muslim don't work on large programs so
there's this a scalability issue and if
you can only push a small amount of code
through the tools they might really
limits the number of issues you can find
okay the dynamic tools don't suffer from
that problem okay they can you know
dynamic tool you can run it on you can
do the instrumentation and in some sense
you've succeeded at that point but in
order actually find the races you have
to run the thing okay so you have to
have workloads and you have to run it
for a long time and yet be able to run
it under lots of different thread
schedules in many cases some of the
tools in order to find it and that's
just a huge amount of work to find those
workloads to actually you know drive the
tool well enough to find the bugs even
the case where their sound and complete
which a lot of them are not okay well
they're not going to find all the bugs
just the amount of data you have to run
the programs you're only going to get
limited coverage and so they didn't
practice they don't find very many bugs
either okay alright so our approach is
to take first of all all the potential
races in the program okay and what that
means is all the pairs of reads and
writes in the program that could
potentially race and so you know say
take all the reads and writes to the
same field of a given type and we want
to narrow that down to the set just of
racing pairs meaning the actual set of
races in the program okay and this
diagram it's meant to suggest that
there's a big gap in between I mean it
was a huge number of possible potential
races in the program and only a very
small set of things that actually would
race okay so what are the challenges in
doing this so one challenge is that the
same location can be accessed was so we
let's our criteria again so our criteria
is that the same location is accessed by
different threads simultaneously without
holding a common lock okay so that's the
specification what we want
check I'll repeat it one more time same
location accessed by different threads
simultaneously without holding a common
luck okay and so we have to handle
multiple aspects that specification
actually turns out to be a complicated
thing to check so and we're actually
going to break it up into several
different analyses and what I think is
about race detection that makes it
complicated you know compared to other
kinds of static analysis or bug finding
tools is actually the specification of
races itself a very complex notion okay
it isn't just a single property it's
actually the composition of several
properties here are three of them it
comes straight out of this formulation
of the specification so we need to
detect whether two things are accessing
the weather two threads are accessing
the same location we need to detect
whether they're actually different
threads okay not you know it doesn't
matter if you access the same location
within a single thread and we need to
know what this can actually happen
without ordering constraints we know
that it's simultaneous okay so all these
things relate to the precision of the
analysis or play at least the way that's
we the way we would cast it okay we will
view these things with all precision
issues essentially whatever kind of
static analysis you have it needs to do
a good job and all three of these things
or you're going to have lots of
false-positive slipping through lots of
things that are potentially look like
races but in fact are not you know we'll
we'll get by and that will you know
water down your results and what we
showed and now a year ago is a very
precise may alias analysis so
essentially an alias analysis that tells
you when to when two expressions might
refer to the same memory location is
really central to solving these three
problems okay and people they tried this
before actually using may alias analysis
to solve these three problems but their
notion of precision wasn't quite the
notion that turned out to work really
well for us okay and I'll tell you a
little bit more about that in a little
while and the false positive rate in
this work was about twenty percent so
when it would report a race was a four
and five chance it was actually a race
okay and yeah
so the question is whether we're using
abstract interpretation is that okay and
and the answer is wheezing static
analysis term I prefer to use at so so
abstract interpretation it has just two
interpretations of that term okay one is
it's a general theory of static analysis
that covers pretty much everything ok so
in that sense yes we're doing abstract
interpretation all right i'll show you a
little bit more about how exactly we
solve these three problems as i go along
in the talk there's another
interpretation of static analysis of
abstract interpretation excuse me which
is as a specific collection of
algorithms there's there's a specific
cookbook recipe for constructing program
analyses that people often use often
associate with the term abstract
interpretation and we're not doing
anything like that okay so it's a very
different form way of yeah we're not
doing a kind of glorified dataflow
analysis here we're doing something and
so you know quite a bit more
sophisticated than that alright okay
alright so then the second thing that we
did or the second big thing we did was
so I try to figure out how to correlate
locks with the locations they guard okay
how to figure out which locks guard
which memory locations and this is key
to the last bit here you know figuring
out whether there's a common lock held
when you are checking a pair of accesses
to see if they might race okay and this
is much more of a sign this issue all
right so this is so for this you need to
do this well in order to get in order to
guarantee that you're going to find all
the races okay and this is actually was
a big stumbling block in previous work
and the big idea here which I'll spend
quite a bit of time talking about today
was something called or is something
called conditional must not Ilyas
analysis which was published just
earlier this year and this is the idea
that allows us to to analyze the locks
precisely okay and the the problem that
it solved for those who are familiar
with it and I'll actually say a bit more
about this but not a lot is that it
circumvents the apparent need for what's
called a must alias analysis all right
so now back to our
picture so we have the set of all pairs
and we want to whittle that down to the
set of just racing pairs just identify
exactly the set of races okay yeah it's
our question I thought so somebody
else's off somewhere okay so we're going
to do this in a series of phases
corresponding to each of those little
pieces i showed you on the previous
slide so we have one analysis is going
to figure out what the set of aliasing
pairs is okay so using an alias analysis
and then the things that could be shared
across threads and then things that
could actually execute simultaneously
call those the parallel pairs and
finally analysis of the locks to find
out what what locks guard which
locations we call that the unlocked
bears and that unlocked set of pairs the
last stage of this analysis and
whittling away at the total set of
possible racing pairs notice that this
is a gap still a gap between the racing
pairs an unlocked pairs there is a false
positive rate and the state remains
about twenty percent in this work okay
so in the final version which is which
is guaranteed to find all the races and
you know we about four and five of those
will be actual races empirically and and
what if I will be something that's not a
race but the tool was just confused okay
alright so now let me tell you a little
about each of these phases and I'm not
going to go into any kind of detail
about most of these alright if you want
to stop and ask me questions be happy to
talk about more giving more information
but this is a very very high level just
because there's not gonna be time to
give you all the details alright so now
we have two generic threads here thread
one and thread to all right and we're
using Java style locking okay where
there's a synchronized construct that
acquires the lock and it's also so
locking in Java is done by acquire every
every object can be a lock and so in
this case we acquire the lock on object
kill one and then we have some kind of
access here to a field similarly in
thread to we acquire a lock on some
object del 2 and we have an access to
the same field but possibly of a
different structure okay now so when is
when is this going to this particular
pair going to be race free
okay well one possibility is that e 1
and E 2 never refer to the same value
okay if you want to need to never refer
to the same value then there's no race I
mean it are two independent threads are
accessing different parts of memory and
so there's no there's no race condition
and that is we can write that in
standard kind of program analysis
terminology is saying that you 1 e 2
must not Ilyas alright so an alias just
means that two expressions may
potentially refer to the same memory
location if they cannot alias then they
can't be race now must not alias is
actually not quite the standard term
that people use the way people actually
usually compute that is they compute am
a alias analysis to figure out first
which pairs of things might refer to the
same location ok and then the complement
of that set are the things that can't
possibly refer to the same location so
if two things cannot make Elias then
they must not alias all right all right
ok so now let's talk a little bit about
may alias analysis all right so this is
a huge topic all right so anybody who's
done any work in static analysis has
come across this and if I were to do
another slide comparable to race
checking that like the one I showed you
before of all the previous later Park it
would look very similar ok it would
start a little later all right what
started about the early 90s ok instead
of in the late 80s but then there would
be it would be a very crowded from about
1997 on ok with multiple papers and all
the major conferences each year right up
to the present day ok so it's still
still a hot topic ok and seems to be a
very very difficult problem now so what
are the big ideas in May alias analysis
well big idea number one is context
insensitive analysis all right and know
this so what would we do in a context
insensitive analysis we would do the
following thing first of all we would
you can't reason about all the possible
memory locations that our program
allocates all right this is one of the
fundamental barriers in static analysis
when the program actually runs there's
awful lot of locations okay but the
thing is the San canals isn't even
reasoning about
executions reading about all possible
executions so even though in a
particular to run the number of
locations might be bounded over all
possible runs the set of locations is
truly infinite for you know for
arbitrarily large inputs for example all
right so we had to have some kind of
abstraction we're going to go on
together multiple program locations into
a single abstract location and the
standard context insensitive way of
doing this is to say the abstract value
is going to be the set of allocation
site so i will just identify every value
with the site where it was allocated and
there's only a finite number of
allocation sites in the program and so i
can identify you know some classes of
values by their allocation sites all
right so in this case what would i be
able to say i would be able to say that
e 1 and E 2 don't alias ok they don't a
lease if the possible sites where e 1
was allocated intersected with this
possible sites where e 2 is allocated is
empty all right so I have to do some
kind of global analysis to figure out
what the possible allocation sites are B
1 and E 2 so I have to stare at the
program to compute flow relationships to
figure out you know where stuff that's
allocated a given site might go all
right in all possible ways throughout
the program and then mentioned i get an
estimate for every expression in the
program of where each of those
expressions might have originally been
allocated where the new state new
expression was that that allocated them
after the site if the intersection of
those two sets happen to be empty well
then i know these things can never alias
because they're talking about things
were allocated at different syntactic
sites in the program all right now it
turns out that idea number one is just a
terrible idea okay I mean it actually
it's a good starting point but it's not
nearly accurate enough for almost
anything you want to do in in in
software quality okay actually it's a
it's not a bad idea for program
optimization so for program optimization
purposes context and sensitivity is
sometimes enough to give you enough
distinctions that you can do more
compiler optimizations and you could
otherwise do all right but for almost
any kind of non-trivial property that
you want to prove in terms of the
semantics of the program and whether it
has a bug of a certain kind context and
sense of analysis is very rarely enough
all right so big idea number two is to
do well the clock of me context
insensitive it must be contact sensitive
whatever that is okay so and
standard technical term here is called
que si FA all right for various levels
of K and the battery in this thing must
be going and so what we're going to say
here now is that for context k equals 1
we're going to distinguish values based
on the call site all right so will
distinguish values based on where they
are where functions are called from so
in this case i have e 1 is calling baz
and i have e to a dispatch also tube as
but they're being called from within
different functions all right and i can
make a distinction saying okay well i
know now a little bit about the call
stack in which this function was
executed and i can use that to make more
distinctions in the analysis than just
the allocation site alright so in this
case we would add we would analyze the
function bass in two different contexts
right and we would be able to keep track
you know we would be doubling the number
of program points that we could talk
about so we would keep track you know
we'd be able to analyze Baz completely
seized two instances of bad is
completely separately from each other
all right now that turns out to be a
pretty good idea okay and this has
actually been shown to be useful I in a
lot of settings for various kinds of
properties but generally speaking I mean
it certainly better than context
insensitive that's why what I should say
so people realize pretty early on this
is way better than just being completely
context and sensitive but generally
speaking the next prime you run into is
that you either have too few still
contexts meaning that somehow the number
of distinctions you're making is not
enough too many things are still being
glommed together to make useful
distinctions okay so all the infinite
sets of objects and the heap too many of
them wind up in the same Puckett you
just can't distinguish two things you
really need to distinguish or you get
too many too many in the sense that your
tool doesn't terminate okay that you
just start you start to build up the
number of contexts very rapidly
especially if you go to K equals 2 3 4
you know keeping larger and larger
portions of the call stack in which you
analyze all these different procedures
okay all right so there's a another idea
which is object sensitive may Elias
analysis which is analogous
to context-sensitive analysis but focus
is not on the condom on this on the call
stack so much as on the allocation
history of objects and this is a recent
meta-analysis that was introduced by
melonova and writer a few years ago okay
and what we're going to do here is we're
going to change our abstract values now
to be strings of allocation sites so
instead of just keeping track of a
single allocation site we're going to
keep track of a string of allocation
sites and what's the particular string
we're going to keep track of it's going
to be the and image well I got to tell
you it for k equals 1 so for k equals 1
the allocation site the brain keep track
of the string is going to be just a
single allocation site is going to be
the site of the dispar ammeter all right
so where was that this parameter
allocated okay and soups Rebecca and so
now here we will still analyze baths
here in two different context because we
have two different this parameters here
assuming these are actually distinct
this parameters will actually get two
distinct context for baths based on what
the this what they based on where they
were allocated all right and and that
will allow us to you know to associate
different information for bass for
objects that were allocated one site
went and and different with a distinct
from information for baths associated
with objects are allocated at a
different call site passes of this
parameter and the intuition behind
objects insensitive analysis is that
it's going to do a good job of
separating out data structures for us
that are allocated in different parts of
the program so think about a hash table
okay so a typical hash table will have
multiple levels in it and you'll be
allocated by some hash table package
right so at the root you'll have some
something that's a handle a container on
the entire hash table and then below
that say will be the buckets and below
that'll be the individual elements so
they'll be three levels of objects
saying a typical hash table now if i use
hash tables on multiple places in the
program same hash table okay same hash
table package being used in different
instances and i create new hash tables
all over the place i would really like
those hash tables to be separated
because i'm probably not using those
hash tables for anything remotely the
same i might have
hashtable that's holding user
information another hash table that's
keeping track say in a search engine of
you know various words and I'm searching
for some sort of index structure like
that okay and these happen to be
allocated by the same hash table
structure but they're just completely
different purposes right so if I had if
I had a track of object sensitivity to K
equals 3 then I would actually
distinguish those three okay intuitively
because the levels the three levels of
objects that are being allocated they're
all allocated by each I call the first I
call the first I call the new up the new
function on the on the root of the
create a new hashtable then it creates
these other level these other levels two
levels deep and that will distinguish
and it happens with the way object
sensitivity is set up at this string and
I will keep track of it exactly that's
that string of three okay the root the
buckets and the leaves all right and
then the two sites the two hash tables
into different parts of program will be
will be kept separate all right so so
object sensitivity turns out to do its
do a very good job of key of capturing
exactly the notion of you know different
data structures allocated in different
say sorry same type of data structure
allocated in different parts of the
program it keeps track of that more
economically than KCF a dust and the
float the context sensitivity does so no
Cael scalable implementations for our
extensive analysis for even k equals one
prior to our work and the basic insights
into making this work out well is to
have a symbolic representation of the
relations okay so we use BDDs to
represent the alias relations and then
we added to that a demand-driven race
detection algorithm so actually we
refine this the sense of nuance
sensitivity we use based on where we see
races so we start out with k equals one
for the entire program okay analyze a
program that way see what races the tool
reports that if it turns out that we
have races in certain places we try
refining those allocation sites to K
equals two all right that gives us more
precision some of the races go away now
there's fewer races left in the program
we keep repeating that until it
converges until by increasing the
sensitivity we don't get we don't
eliminate any more races and that's
where we stop okay so some parts of the
program are modelled more precisely than
others based on where the races
pier to be and this allows us to go much
deeper with the alias analysis than we
normally would alright so we see in our
experiments that we need sensitivity up
to k equals five that's actually useful
to have object sensitivity up to depth k
equals five we don't and yeah I assume
if we look at even larger programs we
would probably need more than that but
you know this is still tractable if
we're doing it for only a few sites in
the program that's right question yeah
I'm sorry right yeah we do an adaptive
learn just like so the question was do
we do it adaptively do we actually alter
the you know the sensitivity adaptively
in response to what I assume in 12 you
see that's exactly what we do so we
start with k equals 1 and if we if
that's sufficient to prove there's no
race on a given field then we just leave
that at K equals 1 but if there are
still races being report in other fields
and we increase the sensitivity there
and rerun the analysis with with it with
a higher sensitivity just for those for
those fields okay alright so back to our
picture okay so here's where we are
alright so now how can we use this alias
analysis for race detection so field F
is going to be race free we said if e1
e2 never refer to the same value so if
they so if the may Elias relation
between e 1 and E 2 however you compute
that if they can't if if it turns out
they can't alias then you know that
those to locate those two expressions
can never race but there's another
possibility okay this is only half the
story this is one way that things might
be proven race free right the other way
that they might be proven raise free is
if the locks are always guaranteed to be
the same okay so let me just repeat this
since so at this level you know if you
have a main Elias analysis however you
got one okay we have one that you know
it's good in certain ways and it works
well for this application then you can
discharge some number of the races just
by proving that those expressions can
never access the same location now if it
turns out that your mail analysis
doesn't succeed in proving that if in
fact the malleus analysis says that well
they might access the same location then
it could still be race free provided
that these locks that are acquired here
but in the synchronized blocks are
always the same and cuz I guarantee is
mutual exclusion because now they're
accessing the same location it doesn't
matter because there's guaranteed to be
some kind of ordering on the constraint
okay so one of these two things if
either of these two things is true then
you can prove that that particular pair
of accesses can't race
all right now that however is a must
alias analysis okay because here it's
always refer to the same value all right
so that means that l1 and l2 must alias
that means in every execution they must
be the same location not just might be
okay because if they might be the same
location well then they might be
different and then you might have a race
okay so make sure you have to be able to
guarantee that they're always going to
be the same all right so must alias
analysis if you go back and drew a slide
of all the work on must alias analysis
and they can be like three papers on it
or something like that because it turned
out to be a much much harder problem
nobody's had a really good idea about
how to do it in in a very general way
and it's not really clear how it would
be useful because it kind of even if you
could solve the problem well it's not
clear that the musty like that things
must alias very often okay so it doesn't
that isn't that common that thing's
actually must alias at all and so this
has been an impediment to many previous
race detectors and this is probably the
reason that there's some folk wisdom
around the static race detection is
intractable in fact most of the activity
in static race in race detection over
the last few years has been in dynamic
race detectors okay and our insight here
the main idea and this is the thing is
probably the most new is that must alias
analysis isn't even needed for this
problem in fact that that formulation I
showed you on the previous slide you
don't need that formulation it's a
different way to formulate the problem
that gets around the whole need for
talking about must alias analysis all
right so let me show you that okay so
the new idea is something we call
conditional must not Ilyas analysis it
would be nice if we had a sexier name
for it but at least says what it
actually is so here's the here's the
statement so field F is going to be
raised free the condition it's going to
be that whenever l1 and l2 refer to
different values e 1 and E 2 also refer
to different values ok so what does this
say it says that if l1 l2 are different
locks all right when you enter these two
blocks then it has to be the case that
II one e to refer to different pieces of
memory
okay and if that's true if that
condition is true then your program is
race free all right or at least this
pair is raised free i should say now if
I formalize that we can see that it
doesn't involve must alias analysis at
all it says that if l1 and l2 must not
alias that should imply that e1 and e2
must not alias okay so under the
assumption so notice what's way out here
this is just much not alias analysis I
mean it's only only building block i'm
using but now there's an implication
here meaning that in the proof of must
not aliasing over here i'm allowed to
assume that these two don't alias all
right so i can get some assumptions for
free that i can add to my knowledge of
facts about things that don't Ilyas and
I can use that to prove more things
don't alias all right and there's no
must alias information required so
here's an example okay and we'll spend a
fair amount of time on this is a real
first and probably only a really
concrete code example other than the
trivial one at the beginning and so what
does this piece of code do well we
allocate a new array all right we'll
just name it by this way we're just
going to you name things here by
allocation sites so I'm going to you
know be able to be a little abusive hear
about syntax and say we're going to name
things you know h0 h1 and h2 that just
points to those three allocation sites
so we allocate an array and then we fill
in the elements of the array with new
objects in a loop ok and all the
elements of the array are getting filled
in there are of type h1 and then the G
field of type h2 sorry the G field of
type h of each one of those h1 objects
gets a new h2 object right and then we
will go around the loop and do that a
bunch of times and so we get a bunch
more things like that so we get some
sort of structure it looks like this ok
all right this is similar this is the
three level structure I was trying to
describe before by waving my hands in
the air here it is concretely on a slide
ok
so now let's take a look at a generic
way of accessing these two then you know
various ways of accessing these this
data structure that might lead to races
okay so let's say I have a thread that's
executing the same piece of code here
all right I'll say you know but I'm
going to just so I can name the two
different things differently this piece
of code you know calls the element of
the array it grabs a x1 this one calls
it x2 and then they have they
synchronize on something and we'll look
at different possibilities for that in
just a moment and then they go off and
do some kind of right and what they're
writing to is a field of these h2 object
all right but they're accessing the h2
object from the roots are taking X you
know they're going from it going from
dereferencing a and then a field G of
one of these objects in the container
and then a field F of that object at the
leaf h2 all right ok so now let's look
at three different cases so the easy
here's an easy case coarse-grained
locking all right this is the standard
pattern where you just acquire a lock on
the entire data structure so basically
lock the whole world do your operation
and then you unlock the world all right
so if you have a database or something
like that you'll like the whole database
go and write one record ok and then
unlock the whole thing all right so
here's our condition so field F is going
to be race free and then I've just
copied out the condition so now let's
instantiate that condition with the
particular situation we're in here all
right what this would say is that if a
must not Elias a implies that x 1g
doesn't alias x2 dodgy then this thing
is race free ok and so this is actually
really easy case because this is false
right they always aliases itself and so
false implies anything right so clearly
if you lock the whole world there can't
be any races all right so there's
nothing so remember what the condition
said before you said if these two locks
were different then we have to prove
something about the memory axis if the
blocks are always the same there's
nothing to prove we don't have to we
don't have to do anything don't jump to
any work ok so that's true so of course
grain locking is really easy to prove as
it should be all right
okay well so that was easy let's try a
different one so let's look at fine
grain locking so the other extreme is
every time you want to access something
in this structure you lock at the finest
granularity possible so if you want to
lock the you know instead of locking the
entire database you lock the individual
record you update that record then you
release your lock okay so what would
that correspond to hear well you're
going to lock you're going to lock the
h2 object so you're going to sink on the
h two objects alright and if we look at
our condition again what's going to
happen to it so it would say that if X 1
G does not Elias X 2 dot G can we
approve from that that x 1g does not
Elias X 2 G and that seems like
something that's very likely to be true
don't have to very complicated reasoning
to figure that out ok so that also is
trivially true so the core screen
locking and the fine grain locking cases
both fall out as really easy cases from
this definition and that makes sense i
mean it just to go over the fine grain
locking again so here's the mathematical
formulation but intuitively what it's
saying is that if i lock an object and
they modify that object well nobody can
race with me ok if I'm if I'm just
locking the object that I'm modifying
nobody can get in there and do anything
with it while I'm doing the modification
all right ok so where does it get
interesting so the inch hard case is the
medium grain locking case all right so
what are we going to do in this case
we're going to lock well actually let me
review why would we ever want to do
anything other than coarse grain locking
or fine grain locking well of course
great locking obviously doesn't allow a
whole lotta concurrency a lot of systems
start out that way and then they run
into a problem because you can't get
very many concurrent things going and so
they they switch to some other locking
style so the Linux kernel for example
started out with only one lock the
so-called bkl the big Colonel Locke all
right and as soon as that the project
got you know to any as soon as the
project got to a certain stage they had
to you know to have more locks and and
and block and a finer granularity the
problem with the very fine grain locking
is that it's very expensive to acquire
and release all these locks okay so you
sure you get a lot concurrency but you
have a lot of overhead to per unit of
concurrency and that so you see there's
diminishing returns and locking a to
finer granularity so everybody wants to
lock at some kind of sweet spot in the
middle alright so the medium grain
locking case would be instead of locking
the whole structure you just lock one of
the buckets okay and then you can go off
and modify the things underneath that so
you can get concurrency at this level
between multiple accesses coming at the
different H ones but you have exclusive
access to all the h2s underneath all
right okay so what happens in this case
so here we would have to in order to
prove that this field is raised free
we'd have to show what so there's the
generic condition here it is
instantiated so we have to show that if
x1 and x2 are different okay meaning
that if x1 and x2 refer to different h1
objects then in fact x 1 z and x 2 g are
different that they will guaranteed to
be accessing here different h two
objects okay now so there it is an
english field g of distinct h1 values so
this will be true if field g of distinct
h1 values are linked two distinct h 2
values and for this particular data
structure that happens to be true
because of the way we built it okay so
in fact it's okay now but this is a heap
property okay or a shape property of the
data structures all right and this is
actually something that static analysis
tools and compilers all kinds of other
language based tools are usually
typically terrible at reasoning about so
anytime you want to reason about
something that's in local variables you
can do a lot okay as soon as you start
talking about stuff that's in the heap
it gets much much harder but it turns
out that this particular shape property
are you know we need this kind of single
access property that everything from one
kind of data structure one kind of value
to link to another kind of value is
uniquely reachable this kind of thing it
turns out that actually in practice we
can reason about this okay it's not it's
too
it's a very limited property actually
and the way we set it up it turns out in
practice we can actually do this kind of
calculations let me show you how we do
that now okay so we call this disjoint
reachability and the thing we want to
prove that from distinct h1 values we
can reach via one or more field accesses
just only distinct h two values alright
so the generic picture looks like that
okay over on the right that's the kind
of shape we're looking at trying to
prove exists in a program and we're just
going to do a little bit of notation
here we're going to say that the set H
to the allocation site h2 is in the
disjoint reachability set of h1 if this
holds so if I pick distinct values out
of the distinct values allocated h1 out
of a bag then from those two values i
can only reach distinct h two values
those two distinct h1 values can never
share nh2 value via one or more accesses
either immediately or transitively ok
we'll just notate if that's true we're
just going to write it like this so we
talk about the disjoint reachability set
of a given allocation site ok what other
kinds of types are going to be just
jointly reachable from that place ok all
right now here's the picture so I'm not
going to show you how we calculated that
but i'll show you how we use it if we
can if we can calculate disjoint
reachability ok which is a completely
separate problem and i'm not going to
tell you how we do that although you're
welcome to ask questions that I can't
answer about it if you wish but i'll
show you how we use it so given that we
can compute disjoint reachability how
would we use that in this in this
conditional must not Ilyas analysis all
right so if i take the definition here
at must audience analysis and i plug in
now what I need to do it looks like this
ok so we have a diagram it looks like
that alright so we're computing here
these are the allocation sites of e1 the
allocation sites of e to the allocation
sites of the lock the two locks l1 and
l2 all right
so now what I'm saying is where can we
potentially have a race well the only
place where we can have a race is on the
intersection of these two sets okay
because that's the only things they
share in common so wherever you want
Annie to might be the same object that's
what we might have a race okay so that's
why we have sites of e1 intersected with
the sites of e2 okay those are the
potential races so everything in here is
potentially dangerous thing that we have
to be sure is is protected properly by
locks okay so these things ought to be
in a disjoint reachability set of
something okay so if all stuff that's in
the intersection of these two things is
disjoint a reachable from anything that
could be in one of the two locks so the
union of those two sets okay then this
is guaranteed to be race free right okay
yeah
yes we are yeah so there's a question
whether we're actually assuming that you
can reach the object that we're
accessing from the lock alright and we
are definitely assuming that that
doesn't seem to be a big assumption in
practice this is the standard pattern
this is actually the standard pattern
yeah so here it is right here you one's
reachable from ll 1 and E 2 is reachable
from l2 yeah and so so we are we are
assuming this we could relax this so we
actually know how to relax in that
condition okay we actually could do a
better job it hasn't been necessary so
far at least in the benchmarks we've
looked at that hasn't been an issue
alright but yes I mean so in particular
we're assuming that the the object that
you're accessing is under the object
that you're locking because you're not
locking something below and then
accessing a parent say ok
so invention
yeah yeah alright so the hard case then
coming back to the medium grain locking
case let's look at this particular
example so i say field F is raised free
we have this situation okay and if we
plug in to the definition the sites of X
the sites I sites where X 1 g + x2 IG
are allocated it's a subset of the sites
in the disjoint reachability set of the
sites where x1 and x2 are allocated and
that's is saying that X 1 dot G you know
is h2 in a disjoint reachability sign of
h1 ok which we already said before all
right and so we haven't as I said I'm
not showing you how the analysis of
disjoint reachability works but we have
a separate analysis that computes these
disjoint reachability relationships and
this one is true as I'll be able to
prove that this is race free okay all
right so let me tell you a little bit
about our experience so far with the
tool so we've we looked at 12
multi-threaded java programs and
including some very large ones and some
very very small ones and the small ones
we picked because they were used in
previous work you know just to validate
our results against previously reported
results and one thing that's good about
cord one of the one of the advantages of
a static tool of our dynamic tool is
that you can actually do checking on
libraries so before you have a complete
program if you just have a client in
with it sorry if you just have a library
in the client then you can still look
for races there so the tool works with
open programs doesn't need to have a
whole program analysis okay so there's
all the tool outputs and the threads of
discussions with the developers are on
the website on my oars website it
actually is all work that he did so all
the conversations with developers and
and you know answering their questions
it's all part of the record and it's all
due to him I and let's go on look at the
actual numbers
so here are some of the benchmarks that
we are here on the benchmarks that we
used the ones above the line here are
the ones that were used in previous work
is the smaller ones the ones below on
the line are the ones that we added just
because we they were they were available
to us and they were and they were bigger
with Apache Derby being by far the
largest so this is an open source
relational database management system
written in Java it's actually just the
library it's not a sign a full
application and here's the time to do
the analysis over here and these numbers
are fairly old aren't they my orc so
what's the current times like by the
same yeah so the times haven't changed
significantly but this is a minutes not
hours and this is not seconds okay but
it's minutes and it's not ours is the
scale of the analysis okay here's a
little chart showing the effectiveness
of the various phases and how many pairs
are retained after each stage so you can
see that aliasing in particular cuts
down a huge number this is I should
point out this is a log scale chart okay
so big drops here really astronomical
drops in terms of actual numbers and
then the other phase it does an awful
lot is the last space the analysis of
the locking generally there's a big gap
there ok now the racing pairs these are
the actual races in the program that's
done by hand ok so we take the red bar
we look at all my your looks at every
one of those by hand decides whether
it's a real race or not and so then
anything so the difference between the
red bar and the white bar the false
positives okay and the other phases you
know some of them there is some program
where every one of those phases makes a
big difference okay so they're all
necessary there are there are plenty of
examples like over here where none of
those other phases makes a huge
difference until you get to the last one
yeah
thousand
yes
so the question was how long it take to
analyze the thousand races in Derby and
answers about a week all right here's
the classification of the unlock pairs
and what what we learned from them so
one thing about races I did mention the
beginning is that not all races are bad
just this the vast majority are bad but
but races by itself or usually so it's a
little bit of a low level property and
there are places where programmers use
races on purpose so some small number of
these races are benign meaning that they
are races that were probably there
intentionally or that nobody would care
about them so you can see here's a
column with the analysis of the nine
races and then there's analysis over
here the ones with the false positives
okay and then finally over here as
analysis the number of bugs and the
number of bugs is always less the number
of races because usually a race will
exhibit itself in many different ways
there'll be lots of different ways to
reach the two expressions and actually
raisuli many different call paths along
which you could come and because of the
context-sensitive analysis each one of
those so i started the object sense of
analysis each one of those possible
different ways can get reported as a
separate race okay if I take this
particular chain of calls you know this
particular allocation pattern then I'll
get a race here and in the same thing
can be exhibited someplace else oh just
like at the beginning we had that one
probably easier way to think about it at
the very beginning we had that one
example which is with the lost update
okay even within that lost update there
were four different possible races
really we correspond to one bug
logically in the program but the reads
and writes could race in multiple
different ways all right those will all
get reported a separate races 33 in that
case right cuz the Reed Reed is not a
race right right sorry
well this is a huge program this is this
a very very big program you know so so
in this case it would sue me on average
for each synchronization bug there was
like three different ways that could be
exhibited which was found not
unreasonable right yeah okay all right
so developer feedback so in JD TS before
we started this we contacted them and
they said as far as we know there are no
concurrency issues in this library and
then afterwards they decided that they
would overhaul how they did they would
overhaul I they did synchronization
because they assign you know there were
lines there were 16 bugs but those are
actually fairly painful to fix and was
just they took it as a simple of a
deeper deeper problems just what the
organization of the whole approach the
synchronization in that library huh yeah
I know I'm out with a close to the end
here and if I bunch of bugs and apache
and 319 bugs in Derby okay and they come
all right okay so I already set up quite
a bit about the related work and the
main thing about static is icing on so
again it's at emphasizing on rates neck
is actually a complicated property
analysis of concurrency and generals a
complicated property made up of Alice's
of many small pieces and breaks down to
know several different analysis problems
dynamic grace detection is still the
current state of the art I think I think
our tool when we hope that it will
become the current state of the art
actually is it as it gets out and one
form another for people to use and and
you know the advantages I think over
dynamic race detection is that it's
going to be sound is going to find all
the races for you it's also going to
work with libraries so in the fact that
you can you don't have to have wait to
have a full program before you can start
finding races and you're finding
concurrency issues in your code all
right and then it's just mentioned shape
analysis is another general area of
related work generally what shape people
when people talk about analyzing shape
they're talking about much more
expensive properties to compute about
the heap than disjoint reachability all
right so here's some of the
contributions and I already think I
emphasize this enough and since we're
trying to wrap up
my aura has great plans to go off and
apply this to you know this basic idea
to other things and we're looking at
things like transactions and atomicity
and here's just one this other places
where races are involved you know but
these are higher level properties that
where you want to race checker as part
as one of the building blocks and
finally thinking about if you can do
affect your brace jacking has this
changed the way you would design a
language concurrent you know how would
you how would you change the way design
concurrent programming language to make
it easier to write programs that are
correct concurrent programs that are
correct in the first place right and
that's it thank you very much for your
attention and if we have time for a
couple questions I'd be happy to take
them yeah so that's a good question and
I think I will end my or take that one
do you want to answer that
maybe
because once you set is out there
right so they
right so the question what are the false
positives look like and since wire since
our tool focuses on object level
reasoning things that aren't objects
sometimes confuse it like integers and
bullying who's actually simply and
coming in right into okay stop that's
high guy don't have a sticker have
reviews answer questions thank you much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>