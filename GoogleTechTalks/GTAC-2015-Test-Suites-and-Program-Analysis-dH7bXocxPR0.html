<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2015: Test Suites and Program Analysis | Coder Coacher - Coaching Coders</title><meta content="GTAC 2015: Test Suites and Program Analysis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GTAC 2015: Test Suites and Program Analysis</b></h2><h5 class="post__date">2015-11-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dH7bXocxPR0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">next up we have Patrick lamb about test
suites and program analysis thanks event
so I'm Patrick lamb from the University
of Waterloo I'm a faculty member there
although this year i'm in zurich on
sabbatical which is probably the best
part of being a faculty member so I'm
doing research in zurich and it's great
what i want to do today is I want to
talk about another use of test Suites
and I want to convince you that test
cases can help you with program analysis
so there's going to be three parts to
this talk the first part is going to be
a brief introduction to what forum
analysis is and what it can do the
second part is going to be one
particular thing that we use program
analysis to do on test Suites and a
third thing is looking forward what I
hope to do research on in the future
about using program analysis and test
Suites together traditionally program
analysis came from optimizing compilers
where we get programs and we had slow
computers and we wanted to use the
compilers to make the program faster to
that we really have to understand how
the program would work and so initially
it enabled program transformation and
optimization to make it go faster
program analysis these days can also
enable program understanding and other
types of transformations like
refactoring can help to eliminate bugs
and it can help with ensuring software
quality all these things of course are
similar to things that you might do
using tests as well the observation that
I'd like to propose is that programs
today come with gobs of tests and people
here have written you know tons and tons
of tests this is a slide that the one
slide I recycled from last year so
programs come with lots of tests we have
no programs at one hundred thousands of
lines of code they also come with
hundreds of thousands of lines of code
usually smaller one hundred thousand
thousands are smaller but still lots of
lines of code and another observation
i'm going to use is that usually it's
easy to understand tests are well
structured and there's extensive library
support for tests so
examples of frameworks that people use
very tests are j unit and you and other
unit testing frameworks i'm not going to
talk about things like william test i'm
just going to talk about tests that are
code these are the easiest for me to
work with as a program analysis person
so let's think a bit about what a test
does a test is going to encode two
useful things that are very useful to me
as someone doing program analysis
they're going to encode how tests invoke
how it assists how to invoke the system
under test and they also involve they
also encode what these systems should do
we say you know you observe the system
behavior you see if it's what you expect
if it is and you're happy if it's not
then you complain about it and so
because we get these two bits of
information we can leverage this in
program analysis so my research internet
agenda for the future is the leverage
test suites in program analysis and let
me talk a bit about program analysis
first because I keep on saying program
analysis program analysis but let's say
static analysis is when you look at a
program at compile time and you say what
it does so compilers do static analysis
traditionally and they look at just the
program text and they try to understand
what they can from the program text
unfortunately that's very difficult for
instance because of the halting problem
and also because of things that are
unknown at compile time you load
information from the configure of
configuration files and you can't tell
what it is unless you have access to
configuration files so you have to make
all sorts of our proxima shins about
what the program is going to do for for
your analysis to work and so people in
the program analysis a field say their
analysis a sound is not really sounded
sound d which is like truthiness
sounding this so it's like it kind of
tells you everything that's going on the
program if you accept the assumptions
that it's going to make so that's static
analysis where you look at the program
ahead of time like compilers the other
type of analysis that you can have is
dynamic analysis and the reason I have
this picture is that dynamic analysis
really drives a program on one
particular path or a limited number of
vertical of paths through the program so
it gives some input it runs a program it
looks at what the program does on these
particular inputs and you get very good
information about
what the program is doing exactly on
those paths but you can't generalize
that information to other behaviors of a
program right that's the usual problems
testing you know that it works on this
test case what does it do on the other
test case well who knows could do
anything there have been some works that
try to combine these analyses so this is
one particular thing it tries to find
crashes in programs by combining dynamic
and static analysis she run tests you in
for some sort of specification for the
program then you do a static analysis it
searches for a bug and it's like I think
that if you run the program with is this
input it's going to crash and then it
runs the program again and it crashes so
there are things that combine static and
dynamic analysis approaches as well I
talked about static analysis talked
about dynamic analysis you can of course
use both of them together other
approaches are kampala canales asst
where you run the program of some inputs
but you say I'm going to leave some of
these inputs symbolic so instead of
saying 5 i'm going to say x and i'm
going to run the program with that X
through through the program and then you
can use a solver to find new paths
through the program okay so that was the
first part where I talked about
different program analyses the second
part of my talk I'm going to talk about
one particular analyses that I used that
I did using test information as a source
this particular work is done with Felix
Fang do from jen is right in the front
row and he did an earlier version of
this work the idea here is that you find
similar test methods test methods that
you can then apply refactoring to this
work was presented at principles and
programming principles and practices of
programming in Java earlier this year
and so let's tell a story i typed some
like thing into google saying writing
unit tests or something like that and
let's say this is Alice and Alice is
writing some code so alice is writing a
widget class ok and let's say that there
are classes footage it and there are
classes bar widget because alice is
programming in a sane way there's also
tests so there's food jutt test and then
there's bar which tests ok so that's
great now alice's task is to add a new
baz widget right so class badge of it
baz widget extends widget now because
alice is
working in a same development
environment there's also going to be
test switch alice is responsible for
writing ok so now there's no tests and
we want to go to this world where there
are tests and we'll remember that there
are tests for food jutt and there's test
for Barbra jutt and all these things are
similar so how are we going to get these
tests for Baz widget what's going to
happen copy paste right ctrl-c ctrl-v
right we all we have all been there it's
it's a thing that happens and you can
kind of rag about it but it's it's not
actually that bad developers often copy
paste test or results show that they
often do and you know I kind of enjoy
doing it too I'll speak for myself here
right this worked quite well in sit for
instance j unit and other unit testing
frameworks they are often quite
self-contained and so you can get away
of doing this and you change just the
thing that you want to change and it
works fine there it kind of leads to
some technical debt and this can cause
we can call it test phones they can
become difficult to comprehend and
maintain later especially when you have
three is kind of okay but when you have
20 things that are all the same that is
not so good and there's been work on
refactoring test so there's this big
800-page book by gerald mészáros about
refactoring tests and if you do that
then you can reduce long-term meet in
this cost you can reduce brittleness and
improve ease of understanding of tests
and if you para motorized your test then
it's easy to add on new tests just by
changing parameters at a new parameters
to it as well and how do we do this at
the language level this is not the work
I'm talking about today this is
something you could do in the future you
could use inheritance you can use medic
method calls new huge new york's i will
show an example of how we might do this
there's also extensions to testing
frameworks where you can parameter is
the test as well and so let's let's look
at an example of refactoring a test so
here we have some methods i believe that
they're pulled from the Weka machine
learning framework and so there's two
tests they look really similar one of
the test says test nominal filtering and
what it says what it does is the call
this method get' filter attribute to
allah na middle
this other method is called test string
filtering and it's going to call get
filter with attribute string and the
assertion then is that the result is not
normal nominal or the result is not
string and so what you do if you want to
refactor this is you can say look i'm
going to set up this array of types
that's one way you can do it there are
other ways of course and in fact in the
original code there's four different
things and we can put them all there and
then you can have one test that iterates
through all the tests and see test so
you can argue that this is a better
design for your test it's certainly
easier to add new new test you don't
have to use ctrl-c ctrl-v as much the
contributions in this part of the talk
are the technique for detecting test
refactoring candidates right now we
detect them it's your responsibility to
use this information to refactor the
tests and we have a analysis of results
on some Java benchmarks so let's think a
bit about what test cases are made of
and so if you have a test case usually
what you have is you have four phases
you have a setup phase a phase where you
run the system under test then you check
that you got what you wanted to from the
system and then you tear down the dirty
testing structure that you created in
the setup phase in this take in this
work we are going to focus on the verify
stage so we're just going to identify
similar test methods by looking at the
verify stage and saying that test
methods are similar if they have similar
verify parts or phases and the inside
here is that if a test is similar to
another test then is probably also going
to have similar research and so the
verify phases are going to give you a
good idea of when tests are similar and
as an example I put up two tests and
they have similar sets of asserts
because we have three asserts here the
first two asserts are a cert equal one
on Intendant one on the float float and
a simple asserttrue and so this is going
to be the basis of our assertion
fingerprints so in particular we're
going to collect the order set of
assertion so you take a test method and
you look at all of the assertions in the
test method based on the order of
statements in that method
and we're going to collect the
assertions along with the parameter
types so we had int int and float float
that they were equal and we're also
going to collect some control flow
information so we don't just want the
straight order of the assertions in the
method we also want to know how they
interact with the control flow how they
are with branches how they are loops and
things like that and I'll talk about
that in the next few minutes and so what
we do with that information is we've
categorized these methods and collected
their assertion fingerprints and then we
group together methods that have the
same assertion fingerprints and I've
schematically represented us here with
these colored boxes and we can see that
we have some boxes with four assertions
and we have some circles of three
assertions we say that the three circles
are in one set of similar methods and
the two boxes are in another set and the
the diamond is all by itself so we're
going to say these are going to be
similar test methods you should probably
look at them to see if they're be
factorable we also collect some control
flow components so there's a bunch of
different information that we use to
look at the assertions and further
classify them so I'm going to briefly
show some tests go so this is just some
contrived code which is going to
illustrate how these assertions are in
the in the control flow and this is a
control flow graph where you have the
nodes being the statements in the method
you have the edges being the control
flow of the method and we can look at
how these do so what we have is we have
these assertions and we want to talk
about how these assertions relate to the
control flow of the method and so I'm
going to tell you some intuition about
our method and so there's five
properties that we use to look at each
of the assertions and we want to
differentiate statements assertions that
kind of behaved differently so if you
have one statement that executes
unconditionally it excuse all the time
in a method and you have another
statement that excuse if some condition
is true these are probably different
assertions and you probably don't want
to say that the test methods that have
these two
oceans are the same so an assertion
that's inside an if statement is likely
to be different from insertion that's
not in a different estate and here on
this picture we can see that we have
some branches and so you can identify
for instance the blue box at line 5 is
an example of a statement that has a
branch count of 1 and we keep that
information with Easter assertion to
classify it in the india certain
fingerprint there's a definition of it
which I'm not going to go into dually to
the branch condition we also keep track
of the merges so we care not only about
how many times the control so branches
before each is an assertion but how many
times the control flow comes back
together before it reaches each
particular each particular assertion and
that's another property that we just use
we count these four eva assertion and
then we use that to classify the
assertions as well what it ends up being
is that for each assertion we have this
52 poll that says you know we keep the
branch cap which merge count and we keep
these three other things and then to
method assertion fingerprints are the
same if they have the same assertions
and the same assertion fingerprints for
each assertion there's a definition of
merge count which I also will not go
into so branches merges and the other
important control flow information is
loops right so we saw some some test
methods that have loops and some tested
methods do have loops so we want to
treat definitely the assertions that are
inside loops from the assertions that
are not inside loops so that's another
thing we track we just keep track of it
at the level of a simple flag whether an
assertion is in a loop or if it's not in
a loop and so we did have an example
here so we have a loop that's going from
the top up and around and so we would we
would mark all the assertions inside the
loop as being in the loop in catch block
so we also track whether an assertion is
part of exceptional catch flow
exceptional control flow with try catch
and so if it's inside a catch ball it's
probably it's probably different from
well that's not so that's another piece
of information and so here we put a try
block as well and so
you would notice that the purple one in
line 10 is going to be in a try block
we're going to mark that as being
different from the other assertions
because it's in a try and the other
piece we keep is whether or not an
assertion is within a cache block and
that turned out to be useful for some of
our mystery as well ok so we compute
these assertion fingerprints for all
these methods and we group together all
of the methods that have the same
assertion fingerprints now for any
analysis any program analysis you're
going to have the problem of potentially
having false positives and so if you if
you return too much stuff people are
going to be like there's too much stuff
I can't deal with this i'm just going to
throw the tool free at it right so what
we want to do is we want to get rid of
things that are likely to be false
positives and so we have some heuristic
filtering criteria we have to say we say
that we only report methods that contain
some control flow that contain more than
four assertions or have different
assertion types so these are things that
we found work well in practice if you do
that then the results that I'll show you
the next few minutes end up being pretty
good and you can use them to identify
potential refactor ball test methods and
so we implemented this using the super
Graham analysis framework and so here's
how it works so you have this some tests
test a B and C and then you get the
control flow graphs and then you get
fingerprints and here you can see that
the fingerprint for a is the same as a
fingerprint for C so we're going to say
these two are similar test methods you
should consider refactoring them B is
all by itself in this example and so
there's nothing that you have to do with
it we had some benchmarks these are the
same benchmarks as last year I really
mean to get new benchmarks and I will do
it after this paper so this is some
results and what you can see here is
that we have refactoring candidates
between sixteen percent of bent of the
of the assertion of the test methods for
geograph t and fifty five percent for
Jota time that was Julie that i really
had a lot of methods that are quite
similar and you really should consider
if you're the developer of dota time
refactoring that method
we also wondered about what our
assertion set or sets of similar methods
looked like whether we would have a lot
of sets that were huge which would be
really hard to refactor you're not going
to refactor 50 methods that are all the
same that's just really hard it would be
kind of interesting but what we found
was that we had some sets that are
really large and we had some sets that
have a lot of a search but no sets that
are both large and have a lot of of
methods so either you have the set which
has like you know three asserts and it
has a lot of methods or you have this
set that has like 40 asserts and it has
a couple of methods in it we also wanted
to know how good our results are so we
did some sampling here what we're trying
to find out is would it actually be
reasonable to think about refactoring
these and so what there were a lot of
results there's like hundreds of results
but what we did was we sampled 20 of the
other results randomly from each of our
benchmarks and so the blue part the
first part of the bar is what we call
true positives so in our opinion all of
the methods there could actually
conceivably factor it would not be
stupid to factor them the the orange
part is where you have some methods some
subset of this set of methods which
would make sense three factor perhaps
you have two different sets of methods
that would make sense to refactor in
this innocence so there's a lot of
methods that we return that are actually
refactor able and some of them the
complete set you all want to refactor
into one test some of them there's
multiple different things that you would
want to refactor into different tests
there we did some qualitative analysis
to know how our work would work and so
we found for jrf T we had these small
and heterogeneous tests which were
unlikely to be false positive so we had
these small tests so they're small so
they're not super worth refactoring but
if you do refactor them then they're
probably good to refactor dota 2 i've
had this wide hierarchy of tests so the
thing about Joe two-time is that it's a
library for for time keeping track of
time and what you have is you have for
instance like the Gorean calendar and
then the coptic calendar and you've all
these things that are pretty similar
so you can imagine it might make sense
to refactor these tests as well and they
have identical structures and they have
straight line assertion so there's no
control flow going on here you just have
a certain assert desert desert desert
and that makes a lot of sense to
refactor so this was actually in some
sense the easiest thing that you could
imagine refactoring um some other tests
had textually identical clones of
methods so it really did look like
someone did ctrl-c ctrl-v it this was a
thing and similar data types but they
ran in different environments so that's
a thing that you'd have to consider when
you're refactoring these tests um this
one didn't work so well Google
visualization it's an old visualization
library what it had here was it built up
a query and then it did a query it build
up the query and then it did it said go
ahead and execute that query and that
was pretty hard to to refactor i also
had helper methods which reduce the role
of assertions in these methods so what
we found was that there were test
methods that had structural similarities
and we think those are really amenable
through factoring and there are also
some nonparametric source mall methods
that were difficult to refactor so the
next step that we'd like to do in this
particular work is guided test
refactoring so now we've identified
things that are likely to be refactor
able so now we'd like to present them to
developer and say look we think that you
can do this transformation is this
really a good idea or it's just not a
good idea what do you think if if you
think it's a good idea we can go ahead
and do the refactoring for you and here
you have this better test suite I think
that would be pretty good for pretty
useful as a tool for developers okay the
final part of my talk is more
speculative or forward-looking and I
want to talk about future perspectives
about doing static analysis and dynamic
analysis using tests as information
because I think we have this great
source of information and really we
should use it right because we need all
the information we can get to do program
analysis and so let's step back here and
let's think well what do we usually do
with tests and usually okay so you go
through a lot of effort to write the
tests and then when you run the tests
and then you get a yes/no answer we had
that great talk a stable flaky tests
where sometimes you get this no answer
and you shouldn't ignore it but in any
case you get the answer you
lies the answer and then you see what
you you see if you have to fix a code or
not you can also combine this with other
analyses as well so let me put this in
some pictures so if we're talking about
static analysis then the usual
interaction with tests is you don't
interact with them so you have your
program you have some analysis tool and
you run the analysis tool on the program
you don't look at a test at all you're
like oh forget about it and well you get
some results about the program maybe
you're going to generate some tests but
the thing that seems like a shame is
that you just generate the tests and
they're just there you don't look at
them at all afterwards they're just open
so the idea here is that a lot of static
analysis work just ignores the tests
flat out and it's like there's this
source of information why are we not
using it what's going on here the usual
interaction with tests for dynamic
analysis is not quite as grim so because
it's a dynamic analysis because you're
actually running the program you have to
do something to get the program to run
and so you do use the tests as input and
then you run the test through the
program through the analysis tool and
then you get generated tests so tests
are right only in some sense you still
generate these tests but we don't really
do anything with them so what I'd like
to look at in the future is that there's
got to be some sort of better wait look
we gotta we have these tests and the
analysis tool really should be using
these tests as as part of the input as
part of the information that it uses to
understand what the program does so
should use both the program and the
analysis tool together to better
understand the program and do all these
wonderful things with the program some
other insights are well why is it hard
to write tests well there's a lot of
challenges of writing tests two of them
that identified here are that you need
to get the system under test into an
appropriate state that's that's hard and
you also need to decide what the right
answer is that's also hard and we had
some talks for instance you get the
image talk okay so that that's just hard
but you need to do you need to have both
of these informations to understand what
the 10 22 right to test and these this
information is also useful for static
analysis we should just use this
information and do better static
analysis with it they also illustrate
interesting points in the execution
space so you know you random executions
you just don't usually get things very
interesting but you have these human
written tests
they say look somebody thought that we
should look at this this execution
program it's probably interesting and
they also provide complete execution
environments for program fragments it
also a couple other challenges as well
so you have multiple test runs you have
zillions of tests again as I said and
how do we combine its information the
other thing is what can we learn from
failing tests what can we learn from the
flaky tests there is certainly signal
there how can we better incorporate this
into our program analysis tools as well
and so what I think is that there's this
great opportunity for using all this
information that's provided by
developers and testers when creating
when developing and testing the program
and all we do is this test now we just
throw that information out we just
generate maybe some more tests but if we
were smart about this and we can be we
can use these tests as a valuable source
of information about the programs that
they are so serious Thanks Thank You
Patrick so could you elaborate on the
background for choosing fours the cutoff
number for assertions for sounds like a
lot for scope test seems to work well in
practice that's what I got what is the
name of the tool you use for program
analysis okay so that's the suit
framework the suit framework is this is
an open source libraries that you can
use to do program analysis on java
bytecode and source code and if you do
search for like suit java that should
pull pull it up how do you measure the
maintenance impact of such refactorings
that would be future work yeah I you'd
have to do it and then you'd have to see
if it's a good idea it might it might be
a bad idea that's possible too in your
experience our developers generally on
board with using program analysis tool
doesn't it create more work for
developers when the tool identifies
completed test cases that are candidates
to be refactored would you say program
analysis is more or less critical than
having a
coverage of tests there's a lot of
issues with using program analysis tools
is hard right and um it's it's also hard
for me to have a blanket answer for that
question I think that if you design your
Coverity is an example of analysis tool
that was heavily engineered to to really
be useful to developers even then it's
not always used but if you really
engineer your tool so that everything it
tells you is useful then then it is
giving you signal that you would want to
use whether it creates more work for
developers yes and no it helps you
eliminate technical debt right and so
that that costs you time to eliminate
technical depth but maybe it's going to
be worth it that's going to be a
judgment call on the on the developers
for the developer to make is it more or
less critical than having a wider range
of tests I think these are complementary
and you actually want both of course we
live in a world with finite resources so
you can't actually say both but you
can't just ignore one you can't just
ignore the other it would you know crazy
languages like JavaScript don't actually
have any program bonuses at all like by
default and so that's one end of the
spectrum but I think most people
actually like to get compiler errors as
opposed to deploying and getting
compiler errors so you know we have this
spectrum and you can be at different
points in the spectrum depending on the
type of project that you're working on
do you suppose that some of the tests
detected as we're factorable were
originally generated by an algorithm we
did look at the tests and in our
particular test Suites we didn't have
any generated tests in in general that
could will happen in that case you would
probably want to black lace this test
and you say look you know don't don't
look at these tests they're obviously
not useful to look at and ken
refactoring tests reduce readability and
understanding of what the test is doing
that is definitely fair it is a judgment
call so I'm going to head here sometimes
you want sometimes refactoring the tests
can be
better design sometimes refactoring test
leads worse design and yes it obscures
where the error is coming from it's not
nothing is always a good idea right so
look at your particular situation if it
makes sense to refactor then go ahead
and do it if it doesn't make sense don't
do it and that seems to be all so thank
you alright thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>