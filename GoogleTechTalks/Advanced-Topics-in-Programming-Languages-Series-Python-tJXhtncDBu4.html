<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Topics in Programming Languages Series: Python... | Coder Coacher - Coaching Coders</title><meta content="Advanced Topics in Programming Languages Series: Python... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Topics in Programming Languages Series: Python...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tJXhtncDBu4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to the second part of the
token Python design patterns just as a
reminder like in part one were mostly
talking about a lower to middle level of
mastery of design cutters themselves in
a middling to good level of mastery of
Python they this talk in particular the
second part will cover behavioral
patterns so it's about 35 slides and
going over essentially template state
and strategy which means we have to skip
all the first part because it's a single
presentation thanks for your patience
we're closed okay so as this short
summary may have reminded you in the
first part we went not in too much depth
more in breadth over a lot of structural
and creational patterns in this part we
will drill more in depth in just a few
behavioral pattern most pattern our
behavior all that is they have to do
with the way objects behave and of
course we would always want to have good
behavior when possible so we're going to
be talking about template method which I
prefer to call self delegation which is
the heart of the essence of
object-oriented programming and then
we'll take a slightly original view at
stage then strategy as factored out
version of template method as we'll see
so as I mentioned your template method
is a great pattern with a lousy name cuz
template means very different things to
different people and a better name is
self navigation because it's directly
descriptive the classic template method
situation is an abstract class of the
base class that offers an organizing
method that organizing method calls what
we de nominate who cthis in the base
class hook methods remain abstract in
the concrete subclasses all the hook
methods are implemented client code
calls the organizing method typically
through a reference to the abstract base
class which in practice indicates of
course a concrete subclass so this would
be the skeleton we have some organizing
method which in this particular abstract
base class is rather silly just calls
the two hooks method one after the other
do this and then do that but then the
job of the concrete subclass is to
instantiate do this and do that to
actually do whatever is appropriate for
this case and the client would call Org
method
and get the two steps the two concrete
steps let's give a slightly more fleshed
out example suppose we want to abstract
the general task of paginating some text
some text meaning a sequence of lines
needs to be presented in chunks which we
call pages and the task has to do with
remembering how many lines are supposed
to make up each page output the lines
one after the other tracking how many we
have placed on the current page enter
our omit a page header just before each
page and a page footer just after each
page this is sufficiently generic but
sufficiently substantial that there is
actually some work to do we can factor
out the structure that we just presented
in words into actual executable code in
an abstract pager so the abscess pager
has to know about a maximum number of
line per page in X so it will have to
get it in the initialization init method
and record it as a class since our in
instance variable and it also will need
to track how many pages it has emitted
so far and what's a current line numbers
so it will start at zero variable
stained self curve and self BG and then
the organizing method is the one that
emits a line writes line given a line of
text presumably if we are at the very
beginning of a page so the current line
within the page is zero first of all
there will be the header the header we
assume can take the page number as as an
argument so it may print a page number
or something then we'll write the line
increment the current number of the line
on the page if we've reached or exceeded
should never happen but who knows
the maximum number then we'll do the
footer again passing the page number in
case the footer method wants to play to
print the page number instead
and then we'll reset the current number
of line on the page to zero and the page
number will increment so basically this
doesn't tell us anything about what does
it mean to do a header what does it mean
to do the actual right of the line what
does it mean to do the actual footer but
it'll trucks everything else all of the
organization all of the logic about
keeping the pagination together goes in
this method and none of the concrete
details about header single lines and
footers so once we have this absurd
pager we can subclass it to make
concrete pages for example this is a
pager that goes to standard output
presumably to be piped into a some kind
of printer in this case since we're
dealing the standard output doing the
write of a line is just a print of it
doing a header maybe page number
something in a couple of white lines and
the future maybe a form field of course
this is like kind of arbitrary but this
would give you somewhat reasonably
paginating text if you pipe it to a line
printer that does the right thing but it
gets a form feed that is goes to the
next page and this is a completely
different implementation that uses
cursors
I assume we have the normal Python
curses but it's very similar if you only
know they see version it's very similar
to paginate text on on screen kind of
like more of course without all the
fancy stuff in this case we start with a
different default maximum 24 because
that's the traditional
depth of a terminal and we make sure it
gets recorded properly by calling the
initialization of our superclass
we also need to record the window the
interning cursors terms the window
object on which we're actually doing the
output so now in this case the emitting
of a line is the STR method
off the window with a line number and
exhausted a header means going to the
top left corner and clearing the page
and the footer in this case is actually
waiting for a key press by a Getty agent
this is apparently different semantics
were not omitting any decoration for
headers and footers but it basically
shows how the concept of pagination
generalizes to one screen after the
other posing for a keystroke at the end
of each no matter how different the task
may look from just getting onto a
printer so why do we want to do that
because all the structural logic goes
into the organizational method in all
the actual elementary actions the
concrete staff goes in the hook methods
implemented by the concrete subclasses
and this separation of concerns is very
often appropriate the abstract logic
that organizes the sequence of action
goes in one place where it can then be
reused by a very different set of actual
concrete actions so this is a great way
to focus on the responsibilities and
collaborations of the different classes
and therefore of the objects of those
classes the base class job is to call
the hooks the concrete trans jobs is to
supply them and this is the template
method concept is also behind the
typical framework approach of
object-oriented programming it's not the
code that I write that coal's functions
from a library as much as its code
provided by the framework that calls
specific and creat methods in my own
objects there's a choice about what to
do in the base class regarding hook
methods so the traditional approach
would would be the second one here force
the subclass
to implement that particular and the way
to do that in Python is to raise not
implemented error that means that if
this isn't overridden and gets called
then the program terminates with a not
implemented error which is a pretty
clear indication of what was wrong or
you could simply avoid writing that at
all in which case you'd die with an
attribute error which isn't quite as
precise but it's much handier on the
other hand it's often the case that hook
methods are provided but in many
concrete subclasses they won't really
need to do anything so the body of
passed meaning do nothing is going to be
in most of the concrete subclasses you
actually write in this case it's much
more practical to actually provide a no
operation default it a default of
whatever is needed most often but that's
very often a no operation that is a pass
in Python terms and then subclasses that
don't actually care about this
particular hook don't need to do
anything which if you particularly if
you have many subclasses is extremely
handy the only real reason to do this in
some cases is that they're good
documentation instead of having to pick
up what are they hook methods by
deducing their hooks from the no
operation implementation you get it
pretty strongly I wouldn't admit of a
strong bias toward practicality in this
case the reasonable default hooks are so
much were often appropriate in Python
another thing that Python offers that
most other object-oriented languages
don't most of in most object-oriented
languages you can only override the code
methods in Python you can also overwrite
data and sometimes that's much handier
because it completely does obviate the
need for boilerplate accessor get this
cannot get the other you simply
says say soft of MX and record MX at
class level and the one in the subclass
of arrives the one in the superclass for
instances of that self plus that's very
practical okay here's a more challenging
example from real life
you remember my general stance patterns
are not invented they're discovered you
abstract what is in common between a lot
of independently developed real cases so
known users for a pattern or an
absolutely crucial part of the
presentation of the pattern and they
have picked the some of the known users
of template method from the Python
standard library so the cue method
containing the cue class of Q dot Q is
essentially at the heart of Python
multi-threaded programming it's a thread
safe first in first out queue and the
typical architecture of a Python
multi-threaded program that's
well-written is some threads generate
units of work and put them on queues
other worker threads peel unit of work
off the work queue and generate results
and push them back on to result queues
any other structure means 90% 99% the
other of the problem hasn't really
understood threading in Python you can
do in other ways but this is so often
appropriate so it should be one of the
most widely used classes if you're good
Python programmers and need to do
multi-threaded codes what makes it so
good
besides it's the evident practicality is
a very nice very clean separation of
concern which boils down to a template
method design pattern between what does
it mean to make the footing of one item
onto the cue thread safe versus what
does it mean to actually do they putting
in question so they the public method
put is essentially concerned with
acquiring a lock waiting on the clock if
needed that's because you made this
declare a maximum dimension of the queue
so every thread trying to put stuff on
an already full queue will wait until
some worker thread feels things off then
once you're really in the right spot
where you're fully
thread safe and everything called
underlined put the private version of
the method and then notifying the
condition not empty because similarly
anybody who's trying to pull items from
a few that's empty is going to be in a
wait state on self not empty and
guaranteeing of course they release no
matter what even in in cases of
exception and so on by a typical try
finally construct underline put if you
look at it is trivially does self queue
append self queue being a double-ended
queue but the interesting point here is
that all the delicate error-prone hard
to test stuff having to do with making
things fully thread safe is abstracted
in the organizing method and the hook
method is the one that of the simple job
in a fully in it doesn't have to worry
about threading at all the queue is not
an abstract class 90 plus percent of the
users will be as a concrete class
particularly because it does first-in
first-out which is what you must
normally want from a queue of tasks or
queue of results so maybe in one case in
ten do you actually need to do
anything more sophisticated since it's
not abstract it fully implements all of
the hook methods that is not a violation
of any sacred principle of the template
method design pattern just a very
practical choice they subclasses if you
want to write their classes will be for
the purpose of changing the queueing
discipline you may want a priority you
are last in first out queue or any sort
of fancy stuff
and you will not have to worry about
locking and race conditions and so on
you can choose to override the hook
methods in a subclass there's a few in
it which does whatever initialization
you need queue size return what is how
many items are in the queue is the Hugh
empties if you fool
put one I can get one item and there's a
Python special you can also override the
data I already mentioned that but here's
an example the simplest example suppose
we want to use a thread safe last in
first out queue those two perfectly
valid approaches one of them is well we
have a double-ended queue we may use it
as a last in first out instead of first
in first out simply when we put instead
of a pend which goes to the right we use
a pen left which goes to the left so
things get appended and taken off from
the same extremity you might notice that
a double ended queue is always a
slightly heavier data structure than a
list a list doesn't offer a one access
at both ends but on the other hand as
long as you only need to add and remove
stuff from one and it's still a one but
it's much faster so if you have if you
are going to have a lot of data and a
lot of activity in your life of queue
you may want to implement it by in the
initialization
make self your list instead of a
double-ended queue and in the then the
pop which does the append can keep
working like that and the get simply
needs to do the pop so in this is a bit
more code but you're using a normal list
instead of a double-ended queue so
probably each get and put apart from the
threading overhead of course if any can
be easily twice as fast so it may be
worth through some cases
here's another known use of template
method which is much more typical it's
the CMV module of the standard library
so CMD basically organizes a console
session of commands you have to define
the commands and the key organizing
method is called CMD loop and it
encapsulates all the structure of let's
do a session of interactive commands so
self pre loop the default hook
implementation is a pass is there
something you need to do to prepare
before they interactive loop starts and
then forever until further notice
do input the default is reading put from
the terminal pre command pre-process the
command break it into whatever kind of
things you need the default does nothing
do command will actually go to that
later that is actually obey the command
do some post-processing based on the
flag written by du command to see if the
whole session is over
if the result of that is actually true
then break and then post loop which
again by default is nothing so basically
this is oversimplified there's actually
if you if you actually look at the
sources of the CMD module does prompting
there's
automatic help for commands you supply
and so on but this is the essence it's a
series of concrete things most of which
can very well be no operations like the
pre-processing and post-processing in
most cases or the pre looping and post
looping what you need to do is
essentially supply the actual concrete
step and then you can launch an
interactive session of commands another
typical example a sink or is a pretty
old component in the Python standard
library which does a synchronous network
programming and it's most of the methods
see you end up calling on us on asking
for objects are organizing method for
example somebody calls a write that goes
to handle write event which is an
organizing method supplied which first
of all section okay are we connected
well up sorry this is a scene or not
annexes handle connect if we're not yet
connected then handle the connection and
remember it for the future and then do
the actual right so basically if you
want to be able to write to a socket
that isn't yet connected or you don't
have to worry about how to do that you
can just accept the organizing method
and you have to basically only write
this loop to actually to this hook
method to actually do the writing when
the socket is connected don't have to
worry about buffering or anything a
interesting variant of template method
is the mixing class so it's not
presented that way in the in the
classical Gang of Four book and it's
probably very alien to most people who
do object-oriented programming today
because they use languages that don't
supply multiple inheritance and so
mixing class just can't exist
but for people with background in
object-oriented programming in Lisp but
for example or C++ for that matter it
should be pretty familiar so the concept
of a mixing class is essentially the
class level equivalent of what template
method an object level it's an a mixin
is an answer class which is meant to be
multiple inherited from it supplies
organizing methods only so to speak does
not supply the hook methods it's the job
of the concrete classes which pull
together various make sense to actually
succeed hook method in my example from
the Python standard library of a very
useful mix in is dict mixin so a depth
map if you want is very rich interface
in Python you can do all sort of things
which is great when you're using a
dictionary but when you're trying to
implement a mapping it can be a lot of
code you have to write which is kind of
repetitive well you don't have to
because you can multiplanar it from
dicta mix in and you only have to supply
a few hook methods at the very least to
get item the special method which lets
your objects the index set and keys to
return all the valid keys in your
mapping initial readwrite also be
methods to set and delete items from
your mapping normally you will have
somewhere to do in initialization and
copy and that's it everything else has
semantics defined in terms of these
elementary methods everything else in
the huge dictionary interface and so you
don't have to supply it you may supply
it for example the default
implementation of under under contains
under under for membership checking is
okay generate all the keys and one by
one check if is it equal to this it is
equal to that is it equal to the other
so basically your default implementation
of contains is or
Renne while depending on how your
mapping is actually implemented it's
typical to be able to do it in or one or
all again so you should override
contains for performance reason but
performance is one issue the point of is
in terms of functionality you only need
a handful of methods and everything else
as semantics defined in terms of it by
the code in mixing so for example this
is the equivalent of contains is house
key so this is very obsolete but you
it's still supported for backward
compatibility this is the real thing but
it's basically the same semantics so
what the one way the way dict mixin
implements this is it tries indexing the
object itself and this implicitly called
get item so this is a self delegation
although it's not immediately obvious
and if the attempts to index fails
because index isn't there here then
Huskie is false otherwise husky is true
so this is a one but it can have any
overhead because of the expected
exception when an exception actually
happens it cost and a substantial amount
of time so you may still want to
override this if your mapping affords a
very fast way to check how do you use
dick Nixon here here is an example I
read only mapping that takes a list of
mappings and when you try to get and
index the chain it tries in sequence
indexing each mapping in the key in the
chain so this would typically be the
case for example for next nested lexical
blocks you are in a nested chain of
blocks and you're looking for name foo
well you
have to look first in the innermost and
then one out and then one out and then
went out and so on so a typical case of
chains although in that case you would
also want method to add one to the chain
remove the last from the chain which I
haven't shown here so it's read-only
because it only deals with looking
things up so it only needs to record the
sequence of mappings when you try to get
an item it will in sequence try every
mapping in the in the sequence trying to
return the key lookup in it ignoring
hearers if it gets to the end of the
loop means the thing is nowhere to be
seen and therefore it raises a key error
itself and to get all keys I'm using set
because it's easy to to accumulate it
but in the end I have to turn it into a
list because that's what the keys must
return a list of keys okay so this is
template method with a essentially a
classic approach and very minor Python
related variation but let's move one
step further is this organization always
appropriate to have the self delegation
the strict sense the organizing method
in the base class and the hoop methods
in subclasses of it sub classing has
advantages but we always already
mentioned there are some issues with it
as well why can't we have the organizing
method in one class and the hoop methods
in another the answer is we can
perfectly without and although this
pattern might be worth another name I'm
still considering it a pythonic case of
template method so for example in HTML
the formatter is essentially the
organizing class and it does who calls
not unto itself but into the writer
instance that is
so to make a concrete writer you
essentially implement only the hook
methods but then the court but you don't
have to subclass from formatter
you can implement it in anywhere you
wish so you still get essentially all
the advantages of often plate method
without the sub classing an example
which could be more familiar to people
familiar with other languages is sax the
simple approach to simple was
synchronous XML parsing there a parser
object essentially calls hooks method on
a handler object and the concrete
handler object needs to implement the
method that they organising methods come
from parser essentially this adds one
axis of variability and therefore
flexibility any starting to share to all
the strategy design pattern as we'll see
later essentially in strategy you want
to have one abstract class for each
decision point you have in some
algorithm or complex of algorithms and
then concrete classes at each decision
point which supplies the appropriate
answer class and are otherwise
independent from each other and that's
fine when what you do at the different
decision points is kind of totally
decoupled but sometimes you don't want
that you want bunches of decisions to be
made for example you don't want a writer
the decision of what do I do when I
write a non space character versus what
do I do when I write a space character
they're not it's not appropriate totally
and couple then what is no oh sorry this
is interesting
we
okay
you can you group that is the decision
point into one thing because you don't
want complete orthogonality and
independence of what is the concrete
step two I'm sorry I have no clue what
is going on here something taking over
my machine okay
so Python offers strong introspection
and template method works very well with
introspection the organizing class
whether it's an abstract base class or a
separate one can snoop into the class
that supplies the hook which could be a
descendant or could be a separate one as
I already mentioned at runtime find out
which hooks are actually supplied and
behave accordingly
dispatch things including catch-all
error handling whatever depending on
what hooks are actually being supplied
so I did mention CMD earlier well he
says here it what it means to do one
command the do CMD hook this is the
default implementation of do CMD hook it
basically checks okay so this is a CMD
and it's argument it's been parsed say
see media is foo string foo well does
self have an attribute do underscore foo
well then we call it otherwise we move
to the other hook method known as to
default so basically by simply writing
do this to underscore this this is the
mandated naming convention do underscore
that to underscore the other you're
supplying hook method form commands this
that the other another variant
you may have multiple kind of template
methods they plane kind or classic kind
they one factored in two separate
classes which have mentioned and the
introspective one so there's multiple
axes they allow you to separate very
carefully very abilities that are
distinct from each other I consider this
a advanced subject in that trying to
follow three harmonies at the same time
unless you're really into Baroque music
is can be pretty hard on the other hand
all art aspires to the condition of
music and this must include the art of
programming incidentally finding out who
said all art aspires to the condition of
music meet me I found Peter pound and
Santa Anna or widely credited with the
same wonderful quote this is the unit
test module in the standard Python
library a simplified version of what it
means to call a unit test it interleaves
the introspective classic and factored
out kind often played method so to find
out what method should I call it does a
get after on cells of age and
dynamically constructed string and then
later it calls it within a try clause so
these are pieces of a introspective
template method implementation to in the
organizing terms executing one method in
a unit test means doing the setup doing
the method doing that here down this is
the simplest kind traditional template
method design pattern and each is done
in a try except because all of the
exceptions my
to be diagnosed in a carefully
controlled way and not just propagating
to a meaningful test and then finally
when there are errors or successes they
go on to the separate object result
which is essentially the implementation
of that essentially they instead of
having they they test case itself have
the concept of accumulation it's
separated into the test result abstract
class so this is our fuga trestle jetty
so I did already mention that state and
strategy have some similarities to
factored out template method so
structured out meaning the organizing
method is in one class and the hooks are
in other class so the organizing method
doesn't call self dot do heuk it calls
self dot some delegate do hoop this is
wifes factored out so in the classic
vision the strategy is one abstract
class per decision point the object
behavior is factored out to the strategy
concrete classes while state would be
the fully encapsulated and strongly
coupled variant of that Python further
complicates the distinction because if
you want you can switch out dynamically
the class of the object you can change
the class of the object as you go which
isn't exactly the cleanest way to
proceed but it does work and you can do
the same for a single method or two
which is more likely to make sense so
here's an example of strategy and trying
to boil things down to the simplest case
where I can actually give an example of
both approaches so we are we have our
calculator and our decision point and
carefully chosen one only is how do we
show results
so we do computations and then what do
we do with the result how do we show
them so they self stop strat is the
strategy reference and it starts with a
show class which presumably does the
showing after each computation self dot
structure gets a nice string which it
shows if it wants to because the
decision of whether to show or not
depends on our strategy class and to
change strategy we have a set verbosity
method on the calculator itself which
depending on a flag whether to be quiet
or not sets strategy objects in class
show or trance quiet presumably as the
name indicates plus quiet just has a no
operation show method so there is no
output while verbose it is false and the
other one does some showing this is how
you could implement them kind of
triggering in they showcase the show
actually does a print in the quiet case
the shoulders long so how would an
implementation of the state design
pattern for exactly the same purpose
discern well we would have to presumably
call the thing self stake instead of
self strat but basically it would be all
the same except the verbosity
the setting of the verbosity that is the
state transition in this framing of the
problem would have to be delegate also
delegated to the state itself so the
state itself should know what to set its
own verbosity means depending on whether
it's being asked to be quiet I have
added to look for kind of stretched out
examples of strategy and state to show
how are these really two different
patterns because I don't think they are
but
normal range of application isn't quite
that close as I've shown here and this
would be the state classes basically
they I've chosen to implement them with
generic and simple because I this way I
could fit them on the on the screen but
essentially the set velocity is is right
here as you see it's very closely
coupled I've added the close coupling
only because it's a traditional feature
of of the state design pattern
essentially the state design pattern in
this case changes the state of its
context in this way this is an example
of stay class which can be implemented
in a particularly different way in
Python consider a ring buffer it's
essentially a first-in first-out class
with a finite memory you only want to
store the up to max items no more for
example you want to keep track of the
last hundred log lines but when you have
more than the older ones need to be
overwritten so it's got to macrostate
intrinsically early state you don't have
max items yet then new items as they
come in just get appended late state
then the new items are overwriting old
ones and the switch from the early to
the late macro state is massive and
irreversible you never need in this
simplified case to go back and it's
massive because they details of the
behavior are totally different so this
is a good example of switching class
there aren't all that many but this is
one is basically we're switching
implementation class if you were at the
beginning Southie is a list and
transforming ourselves into a list just
means making a copy and appending just
means appending to the list but if we've
reached the maximum then we need to
change our class to the different
implementation class which is a full
buffer of course you could do this in
other languages with like one more level
of indirection by switching the class of
the implementation and in having the
envelope stable and this is how the a
full buffer behaves a pending means of
writing a certain item in incrementing
the index of the next item to be
overwritten and to get back into a list
needs some slicing and splicing nothing
really complicated or another pythonic
alternative you could do it by just
switching a method note the similarity
to the previous case the only issue is
when append the normal and notices the
length has reached the max then it
switches its own implementation to a pen
for the addition of the method without
needing to change the whole class and
this is a pen fool which I've
implemented in a simpler way this time
because I just didn't have time on the
slide to put in all the code this also
allows us to keep two lists the same but
this isn't very fast this is our end
which isn't thousand waitresses okay and
this concludes the second part in second
and last part of our Python design
patterns question and answers are
welcome thank you
the delay I may have kind of rushed over
some point or other so anything unclear
well then thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>