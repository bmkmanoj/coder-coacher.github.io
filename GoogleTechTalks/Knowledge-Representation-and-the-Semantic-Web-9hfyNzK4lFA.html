<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Knowledge Representation and the Semantic Web | Coder Coacher - Coaching Coders</title><meta content="Knowledge Representation and the Semantic Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Knowledge Representation and the Semantic Web</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9hfyNzK4lFA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">oh you ever fool me realize there's only
one fear outsider the universal customs
the beginning of time far as I know
unfortunately we'll have to use this
alright we'll try this way although I
don't like bowling legs but anyway so
I'm here to tell you a fairy story no
not exactly
cautionary tale maybe maybe cautionary
tale is about right it has to do with
the work I've been doing for part of my
efforts last longer than I actually care
to think of item and half years now
having to do with that guy described it
best this morning sweetness and light
and representation for the Semantic Web
and should understand this is a very
personal idiomatic view of what the
Semantic Web is how it should be and
what role representation is supposed to
play in it and I'm going to try and tie
together a bunch of different activities
that I have done the last while and tell
you why people who care about the
Semantic Web took care so recently I've
been doing a number of things my
background isn't a branch of formal
representation called description logics
and have actually built reasoner's or
inference engines or whatever and you've
actually build pretty fast ones more
fairly expressive logics I've been
involved with us in a sort of a ad hoc
group of people that are trying to build
different reasoner's that act the same
so you have interoperable reasoner's for
the same language and I've also been
involved in the Semantic Web the number
of things in the Semantic Web starting
with parts of things having to do with
Malaysian have already up which mostly
was lots of sniping from the sidelines
in other words complaining when people
got it wrong and trying to tell them how
to do it right I'm happy to say I won
I've been involved in the demo plus oil
language and the owl web ontology
language just now a w3c recommendation
I've been involved with an extension of
that two rules an extension of that to
first order logic essentially our
proposals of how you might extend the
Semantic Web to add more expressive
power and I've been involved in this new
sparkle thing mostly gained sniping from
the sidelines
so this talk tries to tie together some
of these activities into a fairly
provocative whole and prevent a present
vision oops
a potential future for the Semantic Web
that that future is not something I've
had much chance to look at because I've
been too involved in doing other things
but it is some ideas of how this Manik
web might go okay and I'm gonna have to
sort of abstract and give an overview of
things I've got pointers to various
papers interspersed throughout this
presentation which you can actually look
at and if you if you care ok so here's
an underlying thesis formal symbolic
representation of information has use
why do I claim this well in a word
databases databases are formal symbolic
representations of information that I
claim has had fairly decent use in the
last well since the relational database
systems came along anyway ok evidence
against actually quite a bit of evidence
against as well mostly here right Google
doesn't do this Google does information
retrieval by and large information
retrieval is not formal symbolic
representation of information ok
similarly most modern machine learning
methods don't really do a very good job
of formal symbolic representation I
claim
in a certain sense okay so so this is
actually a thesis that's involved you
know it's behind my my formal work
actually ever since I started my
graduate school career and I've tried to
stay stay pure to it shall we say okay
thesis - is the Semantic Web not just
the Semantic Web but say the web in
general is actually a good place to do
formal symbolic representation why well
because that's what the Semantic Web is
supposed to be for certain sense ah
there we go I knew I had a quote for
that this is from the Semantic Web from
Scientific American Semantic Web is an
extension of the current web which
information is given well-defined
meaning okay so but let's let's not
believe Tim berners-lee not because he
doesn't say good things but we would
like to validate them ourselves why
would we like to work in the Semantic
Web if we believe in formal
representation
well because it's there and to tell you
the truth a lot of the old formal
representation methods were academic toy
things that had very little connection
to applications with outside world the
Semantic Web certainly has that this
many web's big lots of sources of
information the other interesting thing
about the Semantic Web or the web in
general is it really has it's a robot in
a certain sense but it's a really nice
row but you'll have to worry about
vision and motion the roots panic web
has effectors and sensors in the form of
services services are much nicer to deal
with if you don't care about vision and
motion than vision of motion for say you
just care about representation it's just
nice to have a service that you can call
on something will happen you don't need
to worry too much about it okay so
here's a question what's wrong with the
Semantic Web why what would it take to
make the Semantic Web a good place for
formal symbolic representation cuz I
claim that right now it's not a
particularly good place for formal
symbolic representation of the kinds
that I want to do which I'll get to in a
minute and I think I'd have to qualify
that statement a little bit because the
Semantic Web is changing in ways I think
are
changes in the right direction okay so
perhaps a slight digression what is the
semantic web well here is one Tim
berners-lee's slides from a talk I think
it was from one of the XML conferences
about 2000 where he has this view of the
Semantic Web where you have already up
an ontology and rules and all sorts of
things built on top of what we might
describe as the regular web all right so
the Semantic Web is built on top of the
World Wide Web and uses XML XML and and
I arise now instead of you our eyes
International is more Universal than
universal in the in the web parlance but
Semantic Web is built on top of these
underlying things yes the Semantic Web
has several languages represented
representing information namely RDF and
it's extension rdf schema and more
recently owl representing ontology so
these these parts of the Semantic Web
exist these parts are sort of being
worked on more coming this this part
here this role interchange format is
being worked on as we as we as I speak
and you listen so the Semantic Web is
the vision of course is that there's a
lot of what we call representation
logics all the way up to logic
frameworks and somehow proof and Trust
on top hello I'm not quite sure what
they're doing in this same stack and
part of it exists nowadays with some
tools to implement pieces of it okay and
people are actually using it in a
limited way it's certainly astonishingly
much smaller than the web in general but
it is out there and people actually use
it for limited amounts of things so
let's take a closer look at some of
these semantic web languages so RDF is
this underlying language of the Semantic
Web it's really a language for
representing very simple information and
this is as distinguished from XML
we're XML you might say represents data
ie something tied to a particular
document that is sent from a transmitter
to a receiver and doesn't have much use
outside of those two parties the RDF is
designed to be a place where you
represent information that anybody can
use okay and one might if one was
feeling charitable call this information
knowledge in some sense knowledge is a
pretty loaded term I try not to inject
many loaded terms into my talks so I
will try and cut down on the number of
times I use knowledge okay our dia is
transported as XML however okay and all
of it is transmitted in what we would
call these subject property object
triples and some of these properties
have built-in meanings okay and we'll
actually see some examples of this to
make this much more concrete in a minute
okay and it has a few other things has
some sort of existential variables it
uses IRL references for names it's this
very very simple language that one can
use to send information not to send
information but to publish information
on the web our EFS extends this with a
little tiny ontology language by the way
what's an ontology an ontology is
roughly a way of describing the
categories of things that are in the
world
okay nothing more than that we would I
would prefer to be a formal language
some people use pre theoretic notions to
describe ontology x' but that's all that
I'm talking about here
RDS uses the same syntax as RDF nearly
triples but it gives some of the
properties like this subclass property
special meaning so that it is this
property is the relationship between a
specializing specialization and a
generalization that's all that it is
okay and there's actually a formal
account for that now howl and the other
is ax is a much more powerful extension
of our DFS
and can we represent a lot more
oncology's it uses the same syntax as
RDF sort of and a lot of this talk is
going to be about why I put this little
caveat in there and that has to do with
why in my opinion this account of
building languages in the Semantic Web
is broken and more Adso said more
languages are coming and there's by the
way there's lots of other pieces of the
Semantic Web that are not blessed by the
w3c like rule languages and all sorts of
other things that people some people use
as part of the Semantic Web I'm talking
here about the Semantic Web that's
really shall we say the core that w3c
believes in okay so so so we can see
here we can see here this idea of
several languages that fit together in a
particular way okay
and this vision came from the mid 1990s
or late 1990s were the idea that you
would extend it it's the web with
information okay
and give it a well-defined meaning in
these two languages written in XML
I was names and everything here's where
we get to the interesting part of this
vision not only will we have several
languages that extended use XML and I
our eyes but everything in the Semantic
Web will be transferred as what we'll
call these subject subject property
object triples and these triples will be
extracted from the XML okay in a
particular way which is called RDF XML
or maybe it's XML RDF I always forget
which way around it is but anyway and so
when we send a bit of XML around we will
parse it and extract these triples and
these triples will carry the meaning
that they were trying to track trying to
transmit or publish and so here are some
triples okay these are not how they're
written in RDF XML
rdf/xml in a very very ugly syntax I
don't know anybody likes uh syntax
anybody here like the syntax anybody
here know the syntax is I have trouble
with the syntax I had to use it much
more than I could ever have imagined but
what counts for the syntax is extracting
these triples so we so we have this
vision where we're transferring
information around or publishing
information and the information is in
code is carried in these triples and so
what are these triples mean in a certain
sense you know well there's some object
in the world John he stands in this
relationship called loves to this other
object in the world called Mary the same
object in the world stands in the age
relationship to this other object which
is well good question
25 okay there is some object this this
Mary object who john loves loves and
this is this is essentially an
existential variable someone we're not
sure who that is
but there is someone that Mary loves
okay loves has a domain of person and a
range of person okay this is more of our
DFS and john is a type of person and
person is a subclass of agent
generalization now I've used some of
these beep by the way if you don't
understand this syntax these things here
are shorthand notions for IR eyes
which an XML you would call cue names
but they're not exactly XML cue names
just think of them as shorthand for much
longer
ir eyes that usually start HTTP colon
slash slash something slash something
and then a hash sign and in this case it
would say agent that's all you really
need to know about them their names they
fit into this IR this addressing scheme
that's used in the world wide web
alright so
I've now told you everything that was
known about RDF and RDFS in the mid-90s
right in oh is that one minute two
minutes okay on this slide cuz that's it
that's essentially what RDF and our DFS
burned them in 1990s now notice I didn't
give you any formal account of their
meaning okay so what is the meaning of
these pieces of RDF well good question
because there wasn't any document that
told you okay there was a data structure
that they were supposed to evoke but
that didn't talk about meaning okay so
what's the meaning of John I don't know
it's a piece of syntax right what's the
meaning of 25 in particulars at a string
or an integer no okay it's something
okay of this thing here I said it was an
existential variable but even that
wasn't very well defined of this loves
relationship who knows right what's the
meaning of this triple well who knows
right it was a data structure and the
meaning was essentially the meaning that
you should have gotten from reading
these in these these non formal
documents okay
now having been through a long bitter
and drawn-out debate in the
representation a community of whether
this is a good thing let me tell you
it's not a good thing if you want to
write things down in computers computers
are dumb so you should have a good idea
of what the things are supposed to mean
at least formally so the computers might
do the wrong thing but at least I mean
from the outside looking and looking at
them as sort of artifacts doing whatever
they're supposed to do that thing that
they're doing might be completely
incorrect in the world but at least
they're operating as they are supposed
to right it's not like you feed it into
the program like the program does
something and you can't even tell
whether it's doing the right thing or
not okay and that's a situation here we
don't know what how these things are
supposed to be processed is we don't
have a formal meaning for and so this
was actually noticed around 1999 or
thereabouts anyway and there was an
attempt to clean it
okay and give a formal model theoretic
semantics if you don't know what model
theoretic semantics is I can
characterize or get for you in one
phrase model theoretic semantics is
essentially formally stating which
should be blindingly obvious to any fool
well any mathematical fool but but
essentially and if and if it's not
lining Lee obvious then there's
something wrong okay I mean you should
be just essentially stating blindingly
obvious ways true blindingly obvious
truths in ways that are very very formal
that you can then prove what should be
happening and this was done in this w3c
working group you know a few years ago
mostly by Pat Hayes and I whenever he
made a mistake I would complain to him
and he would fix it and when he made new
mistakes I would complain and this point
oh this went on for you know a couple of
years or so now immediately Pat was in
this horrible situation because he was
trying to write down the things that
everybody else in the working group that
was blindingly obvious but they had
different ideas of what should have been
blindingly obvious and this of course is
part of the problem so he had a pick one
and he had to convince them to say ah
this is what it meant artists as opposed
to that but eventually it all worked we
got a formal meaning for confiding
constructs and the usual model theoretic
notions you have a set of objects okay
and didn't turn out too well this is
this is actually boldface
not only are there objects like John in
the world but there actually are objects
like loves loves is not a relationship
it's also an object in the world it's
like there's this you know platonic
notion of loving or something like that
is an object in the world that's a bit
unusual but there's nothing particularly
wrong with it okay
names map and elements at the main blank
nodes not you know the usual things okay
and properties turn into relations which
is a mathematical notion for they relate
to things together to place relations
okay and some of the properties have
built-in meaning hiyee
there's formal definitions of how they
work they're not just arbitrary things
they are they have some ideas for
example subclass
and mainly this type relationship is the
relationship between a class or a
category or a set and the instances of
that you have to be careful because
they're not really sets that you've
learned from naive set theory because
they gonna they don't obey the principle
of foundation in other words a set
convene instance of itself in this case
but anyway it's it's it's it's a
reasonable way of describing things and
subclass reports enforces the subset
relationship between a generalization
and specialization as you would expect
we're essentially blindingly obvious to
any mathematical fool and the main
research insider said oh and we can
define inference in terms of this
entailment relationship was as usual way
it's done and here's the formal thing
that you don't have to understand now
okay so this gives you an idea that now
at least you can write a program that
does the right thing okay
except of course we still haven't told
you what John means all we can tell you
is that John means something okay right
and the computer will then manipulate
stuff and as long as and John will mean
the same thing wherever it sees John but
we have no idea that John means him
right or not as the case may be okay
that's not formal properties that's
something outside of our formalist okay
and something that we have learned
however we have learned it I have no
idea I don't know if anybody else has
any idea how we learn the relationship
between names and our language and
objects or perceptions or whatever you
want to call them in the world right I
mean there is this view of the world
that there's nothing out there at all I
mean it's not that it's a figment of my
imagination I don't even have an
imagination right now the world is just
not there right but we'll we'll assume
that it is for the purposes of getting a
paycheck at least okay so so you still
have to have this idea of grounding
things in the world okay and and that's
that's the job of applications or you
know something outside the formal
machine okay so so now we're in at least
in a better situation where at least we
have this formal notion of how the
Semantic Web should be built up should
we build up from this
I mean not that I've given you exactly
the the formal stuff there but I've
alluded to it at least and now we can
build new languages on top of that and
we can give them formal meaning the same
way that rdf schema is built on top of
this okay we can do this for other
languages okay and in particular every
language in this manic web is supposed
to be done this way there's one language
to rule over them okay all information
the Semantic Web is written in RDF XML
all information the Semantic Web has
carried is the authority of triples and
all these triples carry their meaning as
facts john loves Mary means there's a
love relationship between John and Mary
whatever
John is whatever Mary is whatever loves
is there's a relationship between them
okay yeah why would it do that
well single language means a single
parser right that's useful except I can
write a bad parser in a day and I write
a good parser in a week so I might say
so what right write multiple parsers who
cares right okay another thing is I can
write a tool that extracts meaning from
any semantic web document right well at
least part of the meaning except of
course if one of my relationships is not
like negation so now you know it's a dir
problem right
what kind of pages do you not want to
get when you when you when you look for
you know a term just not X right well I
are some I are does that nowadays but
you know in general I or ISM do that
right very well right okay so it does no
good if we extract the negation of
what's there and claim it's the truth
because we just didn't understand what
the negation predicate was okay all
right so so this vision of course works
for already a because we started in an
RDF right
it works for already a facet because you
can do everything in RDF triples um and
you had this extra meaning etc etc etc
and now we get to this our language I
haven't said much about our yet but you
can actually do this for our and you're
gonna force it to work at least partly
now the question is it's like the
dancing bear you know the question is
not whether how well the variance is but
whether that the whether the bear can
dance at all
and so doing this for owl have we come
up with a dancing bear that we've
produced this wonderful artifact that is
wonderful only because we actually could
do it as opposed to whether it actually
does anything useful I'll talk about
that later and unfortunately this thing
breaks down very very badly when we try
to go to more expressive logics like
first art a lot more expressive
languages like first art illogic and
more on this later this was just this
both of these were surprised okay this
one turns out was known from 1930s work
of tarski and I'll trying to lewd to how
it is it doesn't say here it turns out
that we get the liars paradox so in a
formal semantics account of reasoning
what is the meaning of I am lying is it
true or is it false the answer is you
can't give it a meaning unless you break
the mold somehow and this moles is not
made to be broken or maybe it is made to
be broken
so owl to start on an owl is this
extension for an ontology okay and
allows you to say things like you know
parents of parents of people our parents
right we could say every parent is a
person right but we couldn't say
relative things we could say every
parent is an animal right for example
parent is a relationship being animal
and other animals right well we couldn't
then say that the parents of people are
people as well as being a model animals
whew not aminals okay you can't even say
conjunction certain kind of conjunction
an RDF you can't say person with at
least one child you can say person okay
but you can't make the implicit
conjunction of in here okay you can't
make definitions in the RDFS you can't
say father is precisely a male person
with the least one child okay we would
like to be able to do that if we're
going to describe on this case familiar
relationships but describe all sorts of
relationships between objects and their
categories in the world an owl does that
okay um so we're building this language
that adds ontology Lang ontology
capabilities would like to do we wanted
to fit in the semantic web the same way
as already F does RDFS does ie
you know it's written in XML etc etc etc
we would like to have a well-defined
meaning
we like to provide useful capabilities
we help so and we would like it to be
effectively implemented all and
therefore you could build things that
actually we do in build program that
actually be interesting things for it
with it and have them finished before
the heat death of the universe okay well
it turns out that that many of these
problems are horrendously hard in the
worst case there's there's a related
language not owl but there's a related
language whose worst case complexity is
he have even forgotten the phrase of it
is non Elementary okay non elementary
function grows faster than in Ackerman's
that write something like I forget
exactly but if you rose incredibly fast
so repeat death the universe comes very
quickly and with this function but even
owl is is non-deterministic special
non-deterministic exponential time
complete that's a pretty bad complexity
class for somebody who was grown up they
don't to believe that you know N squared
was a bad complexity class and log in
was barely acceptable non-deterministic
exponential e to bad um the the moral of
a story is it's not as bad as I had
imagined and and this seems to be very
common team these days whoops yes okay
so here's a bit of owl this doesn't look
very much like Rd I am L or even triples
this is actually a syntax for for
description logics that was chosen by a
bunch of logicians who write papers and
double column format and therefore watch
short lines and so therefore that's why
all these math logical things this says
something like wine is a particular kind
of pot of the liquid it has exactly one
maker and every maker is a winery and it
has at least one it's made from at least
one grape and has exactly one color etc
etc etc so that's what this first thing
means and a bunch of stuff which I
didn't how they say here a white wine is
a wine that has color white and Corben's
dry right Riesling is a Riesling that's
made by Corbin's and some other stuff
this is actually extracted from an
existing wine ontology it's been around
for quite a while okay
so so this is the kind of things we can
say an owl we can describe wines and
makers and and food and various kinds of
things and produce definitions about
some of them we can prove complete
definitions where we know them like
white wine and for natural kinds we can
give partial definitions or maybe it's
not really an actual kind maybe we just
don't know enough maybe there is a
complete definition and we don't know
enough to get the complete definition
but as far as this thing wine is a
natural kind it's something that we do
not have a complete definition of we
never could recognize something as a
wine without being told it wasn't wine
or as a white wine is easy if it's wine
and its colors white it's a white wine
gain is the the mate form of what should
be blindingly obvious ok now turns out
even in this wine ontology which is
pretty simple
you feed it in and the system comes up
with some inferences and you're going
huh and it turns out that it has made
something it has determined something
interesting and it's hard to figure out
exactly why I made some of the
inferences is made which means
explanation is a difficult problem for
these things but anything that's not
this talk ok no so there's a syntax
prowl how many a syntax is for owl are
there let me count the ways
hmm 3 and 1/2 shall we say ok there's
this short one which I like ok there's a
functional style one which is actually
nice to type ok and then there's these
ok these all say the same thing by the
way ok this is rdf/xml and I said it was
ugly didn't I I think I understated the
case and this is essentially the triples
that come from this RDF XML turns out in
this case the triples look perhaps even
uglier because to represent conjunctions
you have to make lists and this is how
you make lists in RDF
this is how you make lists and RDF
triples so it looks a bit uglier than it
could be essentially this says this l1
is a list whose first element is wine
and a second element is this restriction
down here and you're forming the
intersection of that list it's it's an
awful way of doing things but it's
required to fit in the RDF vision of the
Semantic Web
all right so you know what are we gonna
do what you know it's okay so we've
leave in this vision of RDF overall we
have this ugliness okay
ugliness isn't so bad we managed to make
it work we have the syntax or do we well
we've got some things okay it's we've
done all the nice things okay it works
all these things we know for sure
I claim out was useful because it
encompasses this particular description
logic which actually has shown to be
have uses usages in the past okay and I
claim it can be effectively implemented
used even though reasoning is
non-deterministic exponential time
complete because ah
turns out I lied a little bit for the
language I just showed you inference is
actually undecidable and we'll get into
that in a minute but for a rational
cut-down version it's it's not it is
decidable okay and you can restrict it
this way okay nevertheless you can
actually build reasoner's that work
effectively now that doesn't mean that
you can feed the entire world wide web
into an olive reasoner it would croak
before you fed in the first hundred
pages most likely reasonable i mean a
compact set of definitions about a
cohesive piece of information and you
know let's say a hundred thousand facts
in that thing then it would work
reasonably by and large no guarantees of
course because the worst case is
horrendous okay so there's a big caveat
that's we had there okay so
unfortunately there are these three
problems with fitting out one if it's
managed better we can characterize them
as triples triples and triples okay why
do we say this three times
well triples are the only syntax there's
three facts of what triples that cause
problems triples are the only syntax
were allowed triples are always facts
and triples don't distinguish between
names in other words and when you look
at things as triples names of properties
objects and individuals all of the same
and even worse names of individuals like
john and names of syntactic connectives
like conjunction also look the same okay
so solutions to this problem took a long
time
okay so so what do we have the problem
is to put everything into triples we
need to have these lists kind of things
which I've showed you before okay and
this because this is a fact we have to
have this kind of fact in the domain
well what is there about the world that
forces there to be a list of this kind
okay
nothing right right it's a list you know
in computer science the lists don't
always exist in the world you have to
build them right okay well we can fix
that by essentially saying by Fiat
lists always exist okay this is called
the comprehension principle okay and we
need it to otherwise otherwise I won't
work out correctly because when we ask
you know is a white-wine belong to this
category it will say no why because the
syntax doesn't even exist you know you
can't say it belongs to the syntax
because the syntax isn't known to be in
the world and it has to be in the world
for it to work out
so here's an example if John is a person
we can't infer that if he's either a
person or Iraq because to belong to this
we need a list corresponding to list and
the list might not be there okay unless
we have a comprehension principle that
essentially provides the fact that all
these lists are floating around now you
should be your alarm bells if you're a
philosopher of mathematics your alarm
bells should be going off what now
because then you would say Russell's
paradox Russell's paradox what does
Russell's paradox say that essentially
for any predicate you can form the set
of objects that belong to that predicate
and if you say that the predicate the
credited says that I'm not a member of
me that there's a set of element there
just there's a set whose elements are
the things that are not members of it
and that question is it did a member of
itself
hey this is Russell's paradox or you can
do liars paradox or whatever you want
you have to be very careful okay and the
solution is to forbid self reference in
the syntax right so the liars paradox
and a lot of these things have this idea
that you can have self reference the
liars paradox says I am not lying
refers to myself or this statement is
false whatever Russell's paradox has
self-reference because you feed the
predicate into itself so we only allow
tree-like syntax which is reasonable
non-tree like syntax you like it
sometimes but not too much we haven't
cut off too much of our nose to spite
our face yet okay but we have introduced
and all these comprehension principles
and writing them as tricky stuff okay
you need to have enough syntax living
around in the world but all your
inferences work but not too much that
you have you have paradoxes so this
solution this problem was fixed okay
problem two RDF doesn't distinguish
between classes and objects or concepts
and individuals or whatever you want to
call it okay so classes long are in the
world they can belong to themselves and
so particular we can have something like
John is a is a person okay and person is
itself an instance of this meta class
the class of all classes well okay that
sounds semi-reasonable doesn't you know
it's not too bad
it causes certain problems if you do it
the wrong way because it could be higher
word or a higher order logic is very
hard to reason with but this this is not
really higher order it's just looks
higher order ish okay um
however it's not the usual way that we
do things in in effectively computable
logics like description logics okay and
it produces certain computational issues
largely because you could say the two
classes are the same because of some
some relationship between the
individuals that correspond to them and
that has consequences that could be very
far-reaching so we could say you know
Eagles and porpoises are this are equal
to each other and that would be a
statement about objects and it would
then make all the Eagles you know the
classic egos in the class of porpoises
be the same and you can do that
contingently and it causes reasoning
problems it's still a decidable logic
but nobody has a good algorithm for
reasoning in it
Boris more text showed this just last
year okay so problem 2 we can sort of
get around
problem three talks about the idea that
we can have things like conjunction we
can make statements about the
conjunction operation with conjunction
so we can say things that you know like
intersection is a sub property of Union
so whenever you have an intersection you
also have a union hmm
that sounds very strange and it turns
out it is exceedingly strange
it causes undecidability and and so so
this is why we have this idea of our
loops I will full okay which is which
allows us and is undecidable and owl DL
which I would characterize as a safe and
sane version of owl okay which forbids
all these unusual things okay and
results in a version of owlets
description logic in disguise and in
Horace and myself have actually proved
that it really is a description logic in
disguise well it doesn't look exactly
like one okay and it retains just about
all the useful parts vowel and it has
effective reasoner's with this big
caveat certainly not database speeds but
fast enough for interactive usage by and
large um so the thing is in LDL we can
use this nice syntax because that's all
we get is the nice index so why in the
world did we go to the gleason tax right
it's for most ugly and confusing triples
are very verbose as well um the worst of
it all is we have these all these
triples and we're trying to find out the
you know conjunctions and disjunctions
turns out the parsing triples into
conjunctions and disjunctions and all
the other bits of vowel syntax is harder
than parsing a decent XML syntax for owl
VL right so we claim that we were doing
this because it wouldn't have to write
parsers but in the end we have to where
the parcel is harder than the usual
parsers well hmm well that's just
annoying in a certain sense right okay
so maybe we could use a nicer syntax but
you know we haven't really done anything
too bad we've managed to shoehorn owl
into the Semantic Web vision okay and
then it's just an aside which I'm gonna
skip over things you can't do in a yell
okay but now we want to go beyond Dowell
there's things you can't say in our we
like to go to full first-order logic you
can't fit it into the Semantic Web the
same way we did with owl we're gonna
have to use comprehension principles
because we need to syntax to exist okay
however first-order logic has things
like disjunctions and negations and we
have to worry how to do them and that
the neat thing about disjunctions and
negations is the disjunct for the
negated part are not asserted right you
have an A or B it's not you're saying
that a is true you're not saying that B
is true you're saying that one or the
other of them is true but in RDF if you
just made them be triples they would be
true so what would the disjunction mean
wouldn't mean anything you couldn't do
it right so you have to be very careful
here okay you need some sort of truth
predicate to say which bits of syntax
are true so you have to say that that
the true thing is a or B and by the fact
you didn't say that a was true then it's
it's not necessarily true okay and you
have to encode it you can't just write
it down as a triple you have to encode
it using some piece of stuff syntax but
the most important thing is you need to
have this truth predicate and now we're
sunk it turns out that in any
sufficiently powerful logical formalism
you can have a version of the liars
paradox and what does it take it takes a
truth predicate and some way of
constructing syntax and that's all as
soon as you have a truth predicate and
you know conjunction negation actually
quantification is important too and some
way of constructing the syntax then you
have a version of a liars paradox not
this self referential one but a
diagonalization kind of thing which is
kind of hard to wrap your heads around
head around um for any property P we can
say S is true if and only if this
property of the encoding of s is true
okay and then we make key B not true
so S is true even if and only if the
encoding of s is not true okay and
because the encoding of S is not true is
true precisely when S is false this
statement cannot be true but it exists
of our syntax it exists and we have we
end up with the Conner of the paradox so
we have done this is the only way we
could go right it turns out that this
proof of this is very annoying because
we don't really have all the machinery
were used to in first order logic but it
comes from an old why very old work from
tar skate and I didn't put the reference
I should have put the reference we can't
escape using some normal ways of
escaping because this truth predicate is
not an arbor tis not something we've
added on to the language it's defining
the first order logic extension so if we
change the truth predicate and make it
weaker which is one of the ways of
getting around it then we then we have
not captured first order logic so so
this vision of this managed web fails if
we try and go this high right so what
can we do is this man you have a failure
can we have we have you hit the limit of
the semantic web without and the answer
is well if we come up with the same
vision we have but my claim is that the
vision is broken okay if you need to
change it somehow so what should remain
well the semantic web should be in the
web okay yes names should be our eyes
that seems reasonable should it to be
some sort of common semantic basis
between the semantic web languages well
do that seems reasonable because of I
say coming a now when you say something
in RDF we'd like them to be able to be
semantically compatible somehow yes now
is this as this is problematic though
you may think that regular logics work
this way but that's not really quite
true that's only something looking in
hindsight that it's true okay I know it
took a long time to achieve and there
are still some problems in this unified
account of all of the sort of regular
logics okay but it's it's pretty close
to being true and we can make you know
we some of these problems are fairly
philosophical having to do with whether
objects exist forever or whether they
can sort of exist at particular times
and when if an object starts to exist
can it then cease to exist
right so we can pick one of those and
fly and go with it okay if possible is
it or not come can we the minimum
semantic requirement I claim for this
vision this modified vision work is that
when we introduce a new
language we can come up with a new
semantic account which relates its
meaning to the meanings of the other
languages we may have to change the
meanings of the other languages but as
long as that's compatible with their old
meaning we're still okay because they
will still work the same way the proof
of that can be very obnoxious in some
cases okay in and it may be that if we
have like 10 Semantic Web languages that
some of them are just incompatible there
may be one for time that's in you know
like that has it has non divisible time
so time is infinitely grenaded right and
there may be another one where time that
goes in uniform time steps the uniform
time steps is much easier to work with
the infinitely grenaded one is probably
closer to reality hello the physicists
have the last word on that as far as I
know and I don't think they've decided
yet okay right although of course we can
guess that their their solution will be
completely incomprehensible because it
will be again you know there will be all
these craziness is of it have that they
didn't in fact quantum theory will
infect a quantum theory of time
matter of fact I'm willing to bet money
on that okay and so of course what part
of the vision we don't want is
information as triples I claim there's
no real benefit lots of problems and
always a ok so to conclude more or less
ok my vision of the Semantic Web then is
multiple languages you know various
things told you real language and one
for services by the way we'd haven't had
anything about how services should fit
in here ok by the way the weight if
you've been following this work I would
claim ALS is not the way to go you want
a special language etc ok and let a few
languages bloom
hopefully not a few thousand ok ooh bad
bad type of oh well languages have
compatible semantics that work together
at least you can come up with a
reasonable way of doing it so for
example the service language talks about
you know the inputs and outputs of
services and those are described using
the ontology language and the semantic
account for that works very nicely ok
and that's how you can actually you can
think of then decomposing the inference
process the service language talks about
what happened
inside the services the intelligent
language talks about how you do mappings
between the inputs and the outputs of
things and actually how you maybe maybe
to be ghoulish how you can actually find
services that actually match the kind of
information you're willing to feed it
and services that produce the kind of
outputs you're going to do and then you
then you actually figure out how it
happens inside okay
you may have to do some reasoning in
that but maybe just enough to do the
input-output magic okay and to allow for
different syntaxes when reading they're
needed so turns out there actually is
some machinery in the web not the
Semantic Web part of the web but the
other part of the web to make this work
namely mime types right okay I am you
know if I am a an owl processor I want
to look for versions of information that
are written in our or RDF I can hack
that and I can do content negotiation to
find the kinds that I really want if I
can accept multiple kinds and I can
import documents I can point to
documents have references to documents
in various ways okay and moreover if I
have a name that I don't understand I
can actually look at that name and say
AHA this name probably refers to this
particular document I can then get that
document and say here's information that
I probably should believe about this
referent of this name now I have another
harangue about the other part of this
manual vision which says you have to
believe that document but that's for
another day okay so that's my vision and
I'm sticking by it what comes next
mm-hmm how can we make this vision a
reality well first there's this ugly
thing called politics right one has to
convince certain certain luminaries to
buy onto this right because and
particularly the Semantic Web part of
the web is is owned by the w3c and you
know to make it have a really uptake you
have to make it be at least well blessed
by w3c would that would be best but at
least not incompatible with the vision
from the w3c another part there's no
services language yet that's it a whole
bunch of services language is around let
me make characterize
situation as I say the popular ones are
no good and the good ones are not
popular that's a bit prejudicial but not
too far off okay
so not a us build better tools there is
a there's a lack of tools here okay
tools are hard to build okay especially
things they're used by users right it's
hard to author ontology
it's hard to author information and do
it right okay now ideally one would like
to have this happen automatically but I
believe there will be at least a fair
bit of human authoring of ontology and
human authoring of information on the
web
okay in this Manek web okay but building
these tools is very difficult because
you're trying to get semi sophisticated
users to write down formal stuff in a
way that's compatible with other
people's formal stuff humans are very
bad at this and and then getting a tool
that works well is very difficult it's a
very tough user interface problem and I
don't have much to say about that
because I'm not a user interface guy
although I'd love to be in a place where
there actually we're good user interface
people anyway I'll heal anybody out
there a good user interface person and
willing to admit it the other thing is
there's lots of data must have a lot of
junk out in the web sure would be nice
if we could build semi automatic tools
for extracting the knowledge out of this
okay well sorry that was a different
different bullet maybe it's not going
together there's lots of let me say that
right now there's lots of information on
the web would be nice to be able to
extract some of it semi automatically
but there are it would be nice to have a
tool that would look around for services
on the web and semi automatically figure
out whether it's a service that you can
use I say semi automatically because if
you ever talk to this if you ever drop
out the semi part here you talk to a
business they'll scream the runway
screaming because they don't believe me
part of doing business with another
business is sending a guy over there to
look the guy in the face and see whether
he's lying I mean put it bluntly um but
at least you can do some of the vetting
and sort of say you don't want it you'll
want to send somebody out
Oh to this place because they're not
doing the right thing so lots of work
there some medium term some long term
some infinite term maybe okay
oops alright and that's the end here's a
few references of papers that that I've
done in this area haven't mentioned so
far and
that therapy
parties
interesting beeping parts in here
- here's the business model of places
like amazon.com this was not in the
business of selling services particular
spinning that you can interact with
automatic students not do anything
is there something else designed to sell
you another
another something
so
a theory of everything right
what's Hitchhiker's Guide to the galaxy
I psyche is the attempt to do what the
people of Earth did right find the
answers everything but they did it a
different way so such idea was to build
up in a particular logic lots of
information lots of common sense
information right I'm not saying there
will be any common sense information
here except incidentally but I don't
care to know a theory of liquid soap
okay I care to know as theory of
familiar million relationships because
people right down the motorway
relationships on the web and therefore
there should be a theory oh I care no a
theory of different kinds of books
because booksellers sell different songs
so begins the both are different I'm
much more also going to have disparate
information I'm not saying it's like
this the weapon is many but I'm not
saying that all the sources and
equipment will be neutrally coherent as
they won't okay and Sykes initial goal
was everything should be mutually
coherent Wow now they change that
because they realize they couldn't do it
what they have this idea of microglia
research but in some sense is telling
something similar
yes in a certain sense the trouble with
site is that a lot of its representation
is intimately tied with its inference
engine which is to put it bluntly
peculiar and it's big but it's peculiar
because it's an engineering artifact
okay and if your inference of
engineering is the process of making
possible by tricks
what would not be possible to poke the
tricks and the trouble is if you're
building a big artifact it'd be very
careful what how many tricks you put in
because eventually the breach falls down
it's like in transition is there so many
tricks in there designed to get
particular these work because they had
demo or customers that they had to get
any prints
and the trick was footing to make it
work better there which is good okay but
if you're not careful you do it in a way
that's not pure and that impurity starts
to affect other things that either quite
an attitude that if they were to
disclose but even worse but it would
have worked normally without distress
but with the trick will work even faster
and so your attempted to use the trick
game</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>