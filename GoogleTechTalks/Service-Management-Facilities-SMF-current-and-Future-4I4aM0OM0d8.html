<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Service Management Facilities, SMF, current and Future | Coder Coacher - Coaching Coders</title><meta content="Service Management Facilities, SMF, current and Future - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Service Management Facilities, SMF, current and Future</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4I4aM0OM0d8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Lee impreza I'm with sun
microsystems and I'm the technical lead
and lead engineer for solaris service
management facility and generally system
sir and service management and solaris
so the goal today we've got a small
audience but I wanted to be able to
speak for the video records so that
people could watch this later and so we
might go in a little different pacing
but please feel free to browse through
the slides online when when you're
looking through but the goal today is to
basically look through solaris SMF both
current what we've done in solaris 10
what's there today with solaris awesome
app as well as what we're looking to do
in the future in order to make service
management more but easier on solaris
and more well integrated so i first
wanted to talk about why the heck did we
do this SMF thing why did we spend all
this time replacing what's essentially a
pretty well-known infrastructure of
system 5 init scripts and inet decom
talk about the basics of SMF finally go
into some service development details
and then talk about the now's that is to
say what what my team's up to and what
we're doing today as well as the future
things that we're thinking about and I'm
obviously interested in questions along
the way or afterwards so why did we do
this I mean what what is SMF why did we
actually start thinking about this
problem well as we were kind of looking
at solaris over the past few years we
realize that there's a difference
between a service and just a mere
program running around on the system it
used to be in UNIX that you had demons
and these demons were important but they
basically had one process they'd ran
around and did a job and then when the
system rebooted the demon went away or
if the if the demon crashed you got to
restart it as an administrator but
things have been getting more
sophisticated over the years services
are no longer just a single process on
the system but they're actually
comprised of a whole pile of processes
an application server your web server
your mail server none of these things
are just a single process anymore the
operating system on the other hand all
operating systems traffic and processes
that's their abstraction for dealing
with user land things so we realize that
there's this difference between the
service and the program
and that you actually want to be able to
look at the system and figure out what
services are running not just what
processes obviously we want to still
maintain that that view into the
processes as well because that's an
important debugging and performance
analysis tool the next thing is because
there were no service abstractions
there's actually a little support for
little OS support service based
management you got the init scripts
which you could start and stop but it
was hard to actually figure out what
services are running on your system what
services are no longer running on your
system before because they're broken and
what it actually looks like to be a
service the next thing is that
parallelism which is more and more
important in computers today as we get
more multi-threaded more multi-core
chips even small systems can take
advantage of parallelize and more
programs are being written in order to
take advantage of this but our boot
process in UNIX actually didn't take
advantage of this parallelism see they
basically watch our your nips scripts
start one at a time at a time at a time
and on a system that had some
parallelism that is to say larger than
you know my laptop of two years ago that
is to say on a modern laptop or most any
machine that most with that that you'll
run Solaris on parallelism could be
exploited during the system boot time
the next thing is that not just managing
services was you know was there lack of
support for but we actually didn't know
what the services boundaries were and
their relationships with each other so
we could really not do much fault
management of these services we didn't
know for example that if a single
process within sendmail die does that
mean that send mail is dead does that
mean that that parts of it are still
running I mean what what is the full
boundary of a service at what point in
time should the operating system should
the administrator know what to do this
used to all need to be plugged into an
administrators brain you would have to
pee grip for the send mail service and
you would you would pee grip for Sam
Elliott PS daf grep send mail whatever
your your invocation was and you would
basically say ah send mail it should
have two processes running there's one
the ticky no connects there that there's
one that accepts connections
one that sends the mail out and there
should always be too and if there aren't
two running there's something wrong well
why'd that knowledge have to be built
into the administrators brain why can't
it actually being coded along with the
service we've got a lot of text files at
least selfishly as an operating system
vendor we actually have a whole lot of
different text file configurations and
each one has their own parser this of
course means problems to us in
maintaining all these text files because
well it's a pain to have to write all
these parsers each one has different
bugs they all look different and it's
generally a pain but it's also a pain
because when you have to look at all
these text files you have to figure out
well what's the syntax our tabs or space
is important what's the comment
character how do I actually you know
manage these eats each individual
operating system service using these
text files and it's actually you know it
was very difficult to make into to to
figure out what was going on with the
system and furthermore be able to
preemptively look for problems in
configuration because each individual
little subsystem had its own a text file
finally we figured with all of this the
lack of understanding about the services
from the operating system point of view
all the different parsers that in order
to be able to recover from errors we're
basically we're missing a ton of
opportunities in order to recover from
errors on the system automatically to
preemptively notify administrators about
errors and basically just make the
system run better so we wanted to start
taking advantage of our opportunities to
recover from these errors so what we did
in solaris 10 is we introduced this
thing called the service management
facility in order to start resolving
some of the infrastructure to allow us
to do better error recovery to do better
service management so first of all we
elevated the service to a first-class
operating system object we help we
essentially allow the operating system
understand and since the operating
system can understand we can write
commands around this to say you know
what is a service how do we start and
stop it what processes are
in the service right now does the
administrator want it running or do they
not run it want it running the ways that
you got to do this before is you got to
do things like move aside your init
script well then you can't then you get
to figure out well okay so if i wanted
to re-enable that thing where do I find
the old Annette script and how do I
actually get it running again second of
all we developed some consistent
configuration and Status handling for
all services so we basically looked at
the class of services across the
operating system and said what sort of
metadata do we need about services well
we don't need to know how to start and
stop them we need to know what their
name is we need to know whether they're
running or not we need to know whether
the admin wanted them enabled so some
consistent configuration and stand as
status handling along with an epi to
handle all this and store it
consistently persistently across volts
next we wanted to be able to generally
monitor and restart services across
vault there's a lot of lore and shell
scripts and all sorts of sophisticated
handling that people have had to do over
the years because the operating system
didn't help them recover the services
from fault essentially your service
would crash you'd have to write some you
know some some shell scripts around it
some programs around it to moderate
monitor whether you're important
services were running around or not
these r all service specific and you
basically had to figure these out on a
case-by-case basis who wanted the
operating system to help not just to
monitor things but also to be able to
restart them when things fit after we
did all these general things we said
okay well we need to use our stuff so we
converted all the operating system
services or at least you know almost all
of them I think we're up to 156 services
bundled with solaris and Counting and
the reason we did this was a couple of
different things first of all we wanted
to take advantage of these capabilities
that we wrote into the operating system
that was actually really important to us
but second of all we needed to validate
what we've done is to say okay we need
to be able to use this in order to
figure out if it's useful enough for
other people as well so we're our own
primary consumer but that's actually a
good thing not just a bad thing and the
last part is well unix has a
and sorted and wonderful history along
with a lot of different existing
mechanisms to solve some of these
problems we have the NIP dot d scripts
which start things during startup and
shut things down bring shut down in it
tabs kind of cool because it tries to do
some process restarting but well you
know it only works if you've got a
single process not if you've got one of
these actual complicated services inet
dr conf is actually you know I net these
cool as well because it handles
networking connections a little bit
better but you know we basically we
wanted to be able to have a more
sophisticated mechanism which combined
all the good parts of those old
mechanisms but still we've got a lot of
things a lot of is V software that
sticks around and uses those old things
so we need to keep those around in order
to make sure that all the software that
ran on solaris before still continues to
work so that's sort of the overview
moving into the basics I wanted to talk
about how we plumb this thing together
how it actually works probably the most
important part of SMF is a demon that we
call service start date it's taken over
most of what an it did is in so far as
it takes it starts up system services it
shuts them down to the white like I said
compatibility for all the old stuff and
it's still using the knit tab if you
shove something into their actually we
start up start day with a knit tab today
so you know we still take advantage of
these of these old pieces of
infrastructure and also we still run the
RC script so again things that used to
work continue to work in newer versions
of Sawyer's what start d does in
addition to starting up services is it
can automatically restart services so
what we actually looked at is making
service is a little more intent based is
instead of saying I want to stop the
service or I want to start the service
what you actually give if your intent to
the system you say I want to enable the
service I want to disable the service I
want to enable it temporarily I wanted
those sorts of things what that means is
then the operating system cannot can
tell the difference between the case
where you just went off and killed off
the demon
and whether that happened to be you
killing it off or core dumped or
something else the operating system
didn't used to know whether this was a
desired state or not now that we have an
intent based command line we can
actually say based on your intent your
intent is that send mails enable that
means the system should try as hard as
humanly possible system ly possible
computer ly possible in order to we try
as hard as humanly possible to make sure
that those things that are enabled stay
running so we started up at boot and
then we restart it if it dies so even if
you accidentally went off and killed it
because well kill dash nine isn't
actually an intent based you know it
isn't actually an intent based a command
line is basically you could have typed
the wrong pit and accidentally killed
off the thing that was most critical to
your business the next thing is that we
can you know again intent-based command
lines we can disable this the service
with a single command so we will stop it
right away will not start it at boot and
most importantly for us this is actually
a really kind of annoying and subtle
thing that used to exist so when OS is
so so so it used to be that the way that
you could disable a service would be to
remove its link from the RC scripts
right you would move it aside or remove
it but what happens when you patch your
upgrade and the system actually delivers
a new version of that our C script guess
what it gets enabled again the only
thing that you could do is try to remove
the packages and hope that it stays gone
or put you know put things into your
deployment infrastructure the like our
goal is to basically again now that we
know the administrators intent the
administrators intent was to disable the
service we actually want to preserve
that administrators intent across patch
and upgrade operations as well so the
system actually does some restart of
services and that what I kind of wanted
to do is give a picture of how this
looks today i'll talk about inet d in a
little bit and i'll stop pumping on my
microphone too so basically the way that
this looks we start up the system is we
start up the colonel the colonel knows
to start a net
and basically the very first thing than
it does it starts up service dog start
date and then service and what's
important here is these little
containers that are what we call process
contracts this is the cool thing about
as far as I'm concerned about working on
solaris and open solaris when we say
this looks like a user land process
project to me right it's like mine its
start the ftp send mail fmd okay all
these things are usual and processes but
the cool thing as far as I'm concerned
as we said well we need this
infrastructure in order to monitor
processes on the system well we could do
this through some hacky you know attach
the debugger to the processes and boom
that's boring what's actually cool is we
can actually put that infrastructure
into the kernel and create these things
that we call process contracts which are
grouping of processes that something in
user land in this case start key can't
express interest in and say I care you
know so we create a process contract
when we start up a service let's say
send mail for this case and send mill
starts up to processes and those are
both put into the process contract and
then start do you can basically just
monitor on the process contract and get
events when bad things happen or even
when good things happen when a new
process joins what a process exits when
all processes in the contract exit when
one of the processes in the contract was
actually killed by the kernel because we
had an unrecoverable memory error in it
we actually can't know these things
because we have some kernel
infrastructure around understanding
these process groupings that that that a
restart needs to create I also note also
note here that um that that we have
process contracts for an it and start d
as well and the reason that we do this
is because the kernel monitors in it in
it monitor start d and the goal is for
entire system to be restartable from
first principles so we actually had an
intern work on this last summer which
was pretty fun we did something we
called soft reboots and it was fairly
successful as we could basically just
tear down all of user land and bring it
back up and without actually restarting
the kernel which
you know it's it's kind of a fun toy and
the reason why it's a fun toy is when
things go wrong and user land maybe you
just want to say shut it all down
restart it and and basically you know
start with the new new user lab it's
even though the colonel hasn't changed
so it was kind of a fun little prototype
that showed that what we are is really
resilient to these sorts of failures as
far as we can tear down the whole system
the kernel and start it back up again
because we actually have knowledge about
what constitutes the system finally the
goal is that if there are faults in any
part of this and we test this all the
time if an it dies if start d dies of
config dies if I net D dies of sendmail
dies if any of these components fail we
restart them they pick up their state
where they left off and and basically
start running again so the so a fun demo
that that I always like to try and I
always hope works is that and we do test
this from time to time is basically you
can kill dash nine dash one your system
and you can watch most of it come back
up there are a couple of services that
are a little less friendly to their
restart things like the auto mounter
right now but we're working on those and
that's basically the goal of a solar
system is that death of any process can
be recovered from so when we look at the
sort of amalgamation of what a services
the processes that are running whether
you know whether it started successfully
or not in like we keep a simple set of
states for each service now the set of
states is actually simple and limited
for a good reason and that's because we
want to be able to base a lot off of
this but it doesn't provide the richness
of administrative knowledge that we can
offer through other interfaces this is
just a simple way of saying okay
uninitialized obviously all finite state
machines you need your first state depth
that's what it is um disabled means it's
disabled and not running we've actually
transitioned to disable offline means
it's enabled and waiting for
dependencies get to dependencies in a
second online means it's enabled and
running
degraded is is our way of saying that a
service is running below full
performance we don't use this
extensively today in Solaris but we'll
be using it more and more in the future
but that's basically to say and its
operational but it may not be running up
to what you spected at me yes
so basically it could go either way yes
I'm sorry good point so the question was
whether the you know whether degraded is
something that a human puts the service
into or whether the machine can put it
into that as well as that are correct
okay so basically the answer is both so
you may want to be able to have a human
say as far as the other point to a task
map the route thing we wanted it to be
friendly to is systems with multiple
operators where it's not just a single
operator on the system but actually
multiple operators touching the computer
and so we wanted to be able to have an
admin put things into a degraded to say
to mark it as well there's something not
quite right here but I don't want to
restart it because maybe it's you know
Oracle and it takes 30 minutes to start
up again or whatever but I so I don't
want to interrupt that service now but I
want to mark it that way we've also we
use it in some cases and things like I
netd in order to say you know well we're
not actually accepting connections as
rapidly as we go to the like and then we
expect in future projects to use it more
extensively Ian's dirty by having some
service specific monitoring capabilities
so that you could actually do things
like actively probe the service to say
whether it's running up to spec or not
and obviously that's going to be
serviced specific the last one is a
service is a state that we hope things
never go into but they inevitably do and
that's maintenance and that's basically
a state that is and could that the
framework can put a service into but it
will not be left without administrator
intervention because maintenance means
we've tried as hard as we could to
restart this thing and it's not getting
better or something field and we don't
know what went wrong or there were some
sort of framework error and restarting
it and this thing might be in a bad
state and we went down and we need some
administrator event intervention to get
things resolved so while we put ball
well SMF will put things into the
maintenance SMF does not take things out
of maintenance automatically
um let's see service dependencies so we
we declared services can declare
dependencies on each other and so why
did we actually do this again parking
back to the old knit script days the
knit tab those sorts of things basically
we used to start things up in lex
agraphia sorted order this is kind of
insane if you think about it's like well
it was that thing at s29 because it was
supposed to be after when networking
started or was it a test when t9 because
it was supposed to be there after local
file systems were mounted it's like why
why did we pick that and there was no
actual way of telling so we really
wanted to put tighter dependencies and
actually declare what a service depends
on and the other reason that you want to
do that is in order to so what do we get
we get parallel startup it just kind of
falls out is we can sudden languages do
some graph sorting and we start things
up and paralyzed so the other thing that
we get out of that is we can
understanding of if something fails if
something that a service depends upon
fails whether we actually um whether we
actually want to be able to restart the
service so we also have sophistication
are in our dependencies so we can say
whether they're resilient to the failure
of the you know of the weather or
services resilient to the failure of the
dependency or the like so that kind of
goes into the next point which is that
if we get a hardware error we can we can
then basically say well maybe I don't
just need to restart the service but I
need to restart the things that are
dependent on it that are actually
tightly coupled with the service as well
so that that is to say if a memory error
that happened that we could that the
colonel couldn't recover from because
essentially we on cash parity error that
we earn an uncorrectable error rather
than just knee crash parity error by ue
then we can basically say well anything
which is tightly coupled with this
service probably needs to be restarted
too because you know it's got a bunch of
shared memory segments you know it they
basically are too intertwined and we
should restart them all together
and then finally on because of
dependencies we a service kind of hangs
out in the offline state until its
dependencies are satisfied and and
that's kind of can be a little annoying
and confusing the first time because
it's like I told the service to start
why won't it start and the answer is
well because it's dependencies aren't
satisfied yet and the service author you
know which could have been you or could
have been somebody at saw nor could have
been somebody a blast wave or whatever
said this service shouldn't started to
all of its dependencies are satisfied so
a new command services dash X allows us
to answer questions about well what's
going on what's the service waiting for
this is an eye chart at best but
basically when we did I don't remember
how current this is probably six months
old or something there's been some new
services at it since but this is what
our dependency graph looks like on the
Solaris that we ship it's actually
incredibly complex but was really easy
to generate by basically just saying
okay so somewhere down here is you know
I require the loop back to be mounted
and then you know I right then I can
mount some file systems and because I
net booted I and then eventually I can
start up things like usually file system
local somewhere in here it's a pretty
strongly connected node you know and
then eventually we get to inet d and you
know somewhere back here is the login
and the like but we can generate this
without with without a human having to
kind of look at the whole complexity
from the start as a human can drill down
and say I actually care about this
service here and I can look at who he
depends on and who depends upon him oh
and we have on opensolaris org so
basically when I talk about SMF and
Solaris I'm actually talking about SMF
and opensolaris because we do all of our
work in the open we have a community on
opensolaris or where we're asking where
we where we answer questions and kind of
take contributions and all that and the
program which generated this is called
SCF dot and it's actually sitting on
opensolaris org if you want to generate
one for your own system to
here's where I'm going to start going a
little bit faster because I have too
many slides from my time and so what I'm
going to do is I'm going to skip through
a bunch of this slides should be
available online i'll probably also post
them on my blog or something but so that
so that you can kind of go through the
details later but um we want methods on
the other way we can say that you know
so i talked about how to an admin
communicates with the service method is
a way that the that SMF communicates
with the service itself so basically we
use methods to manipulate a service they
can be scripts they can binaries they
can actually be automatic actions as
well that we've coded into the framework
so you can either keep your old and it's
scripts around and the goal is that you
can basically just reuse in a nit script
as a method or you can actually you know
or you can just invoke binaries directly
and get rid of the middleman get rid of
that and its script along the way
because we oh yeah and you can use
things like you know use perl use python
use you know your favorite shell
interpreter whatever so no longer do we
have some of the restrictions that we
used to have through init.d scripts the
next reason you know the one of the
other reasons that we did SMF and the
actual one of the cool things that a
service object on the system gives us is
it actually gives us a handle with which
to manage the service so we can we can
start talking about things that we've
put into solaris okay simple things that
we didn't put into solaris like users
and groups what user does the service
run as you no longer have to you know
you no longer have to essentially deck
the service you can you can put it as
meta configuration furthermore other
things that we put into solaris like
privileges so basically insularis time
we also put in something called least
privileges these privileges i love least
privileges they're pretty cool they
allow you to basically give fine-grained
privileges to an application as you can
basically say well I want this I want
this application to run not as root but
I want to give him the privileges to
bind to reserved ports right but
he shouldn't have any other any other
elevated privileges other than that
should be a normal user so you can do
the same thing like or you could say
I've got this hyper privileged demon but
in order to avoid buffer overflow
attacks how do you usually exploit a
buffer overflow attack you do so by
basically getting it to exact something
else right so you make it you say a
service can run as superuser you know
with all the privileges that he needs
but take away the exact privilege lease
privileges in general they used to have
to modify the the binary itself in order
to take advantage of this but with SMF
we have a service handle and we can
actually have our restart errs exact the
exact services with the new privileged
set that you specified and the resource
management actually the SMF team came
out of the resource management team
insularis and one of the reasons why is
because it was actually kind of hard to
say oh I want my NFS server to be
running in this project with these sorts
of fun you know with these sorts of
resource controls on it you can actually
now tie things together much more
closely inciting the NFS server should
run as you know the NFS server project
and and we want to give it you know a
CPU cap of a certain amount because NFS
isn't important on the system let's see
configuration we like I said we want to
unify configuration and when I say
configuration we wanted to unify both
configuration and service status
reporting those are both important to us
so we store all of this in something
called config d or the repository
underneath the covers it's a little
sequel light database but basically at
that's that's fairly
implementation-specific we could change
that out at some point in time sequel
light just happened to you know fill our
requirements for what we needed it from
a repository and it's all all access
goes through this demon called config D
and that's also important because that's
where we do all of our privilege
management and we do authentication and
all those pieces so we have this you
know demon which which mitigates access
to the repository
we both have so when I talk about
services I'm kind of using this
convenient shorthand we actually went
and we implemented a two-level scheme
with those services and instances and
the reason that we did this is because
we wanted to do some amount of
configurator configuration sharing
amongst like implementations of the same
thing so if you have your web server we
wanted to be able to say share all this
configuration amongst my web servers
except for the you know except for the
port that it runs on and its home to in
it and its home directory okay fine but
you shouldn't have to duplicate that
configuration across all of them
especially as you change defaults so
that's so both services can have
properties and instances can have
properties and it's a pretty simple
composition that if you look up a
property on an instance you we first
look on the instance if it exists there
we we say we we basically give you back
that property on the instance if it
doesn't exist there we'll go look it up
on the surface fMRIs are our names for
services basically we have a namespace
that we share with the FMA team and
we're expanding this namespace with with
different things over with different
things over time but SVC is the
namespace that we've carved out for our
services they have a big long name
including a category just like system
system cron is the service name and the
thing after the colon is the instance
name so you could have default and
doesn't make much sense with cron to
have multiple kranj riding around but
you know you could let's see the other
thing is that our commands all except
abbreviations and globbing well this
fmri is the formal name it's the unique
name on the system you don't have to
actually type this big ugly thing in for
all of our admin commands because who
the heck would want to so you can do
things like for this example you can you
can use all our commands with cron
we've split things up in the repository
into both properties as well as property
groups property groups are basically
just a grouping for properties
properties have a well-defined set of
types that they can take on and these
are things like strings and Easter you
know so and a strings and binary blobs
and integers and you know the stand
boolean the standard stuff property
groups are groupings for properties so
it's not an entirely flat namespace and
the really nice thing is you can define
your own types on property groups and we
kind of use this extensively in order to
so that you can do things like make
searching easier um for your if you have
an application putting configuration
into the repository we take snapshots I
won't go into the details here but
snapshots are basically a way so that we
can actually roll back to previous
configurations as well as we can do
transactional updates to services
themselves so you can basically with the
service Adam refresh command say I want
to take all these you know
configurations that I've been working on
for a while and commit it to the running
snapshot which is where we read all the
properties from we've got a library the
libraries okay we're adding some more
simple interfaces to that over time as
well as there is a truly simple to use
command called service prop which has
committed output and we're not going to
change over time and all that so that
you can actually look at configuration
in the repository grab it from shell
scripts or whatever and we're using
these more and more extensively lately
one of the one of the things that's come
in since early solaris 10 is something
called secure by default secure by
default is it was about time for us to
ship Solaris with all insecure remote
protocols turned off turn off telnet by
default turn turn off you know basically
RPC binds remote connections by default
all those sorts of things this actually
all uses SMF today so we so SPD is
implemented by something we call an SMF
profile profile which enables and
disables all the appropriate services to
put
you into secure by default mode as well
as twiddles properties like RPC bind has
a config / local only property which
says whether it should accept
connections from the you know the big
bad outside network or whether it's only
accept them internally all users today
all users can read all repository
properties but we had a request for some
secret data to be able to be stored in
the repository and so we're adding
capabilities for sort of private or
secret repository data in the future
that's mentioned on SMF discuss and and
and was talked about pretty extensively
there finally the way that we do one of
the things we wanted to do with SMF is
allowed delegated administration so that
you could essentially have you could
give away in your operation say I want
to be rude but I've got you know I've
got a web server admin I've got an
Oracle admin I've got you know I've I've
got to send mail admin they should be
able to you know reconfigure start and
stop all those things play with their
service but you know so how do we do
that we actually give this give we allow
you to delegate right privileges to the
repository and because all our
communication happens through the
repository we basically it's all done
through that point of control rather
than having us requiring us to put a
bunch of you know checking authorization
checking into each individual command
manifests our delivery system that it's
basically a bunch of XML goo which
describes the service of the system I
must have actually removed the may be
funny okay they're relatively short and
basically are fairly simple to create
usually by copying an existing one
because who wants to write xml from
scratch I don't so basically that you
deliver a manifest in order to describe
your service to the system
okay we have a bunch of commands I'm not
going to go through all the details of
these but basically services is the
status query it's like give me
information about the system dash X is
pretty cool it'll tell you what's wrong
with the system basically if its service
is an unusual state it will tell you
about it the service is enabled but it's
offline and then it'll start trying to
tell you why it's offline or why it's
and maintenance service Adam is how you
actually administer the service common
actions that you have for the service
enabled disabled you can restart the
service refresh I talked about a little
bit and then clear is how you say that
the service has been basically it wasn't
maintenance I've repaired it time to try
to try to restart again service config
is our Swiss Army tool for the Swiss
Army tool for the repository it
basically gives you pretty raw and
unfettered access to the repository a
nice thing is you know you actually have
a couple of different access patterns on
it's also kind of an interactive shell
and can be used in shell scripting as
well and then service prop is just a you
know attempt to be a simpler way of just
getting property information so if you
want to query the repository from your
scripts service prop is a much simpler
way of doing it usually the service
config because it's just meant to be you
know a query or it doesn't have an
extended syntax to try to do a whole
bunch so you can basically just say
things like service p property right get
the enabled property out of apache to
so talked a lot about service start d
which is sort of our master it's the
master graph engine another master
restart ur so basically it manages all
the service dependencies across a system
as well as restarts things that used to
be started by an it but not everything
fits into start these model I mean a
clear example as inot di net D does some
plumbing for the service it sets up the
port and all that it candles incoming
connections before the service is is
actually started so what we also wanted
to do is we kind of split start d in
half as we said well this half is the
graph inch and it handles states it
handles dependencies it handles all
those things the other half is a restart
now restart ur basically takes care of
doing exactly what you might expect it
starts stops do those all those sorts of
things for the services so we allow
other things to be delegated researchers
as well and right now we have I NAT D as
our bundled restart er but in the future
we expect to have more so service
development I'm again I'm not going to
I'm going to cruise through both of
these slides because they don't need to
go into the detail now but I did want to
go through the benefits is why does why
would you actually want to integrate
your stuff with SMF so first of all the
services go ahead and they appear with
sm FF MRIs you know you can you can use
the solaris tools to see them enable
them disable them and then the other
thing is we're developing a suite of
tools on top of SMF and they just
basically look at the repository they
look at existing services on the system
so if your service appears there then
our tools will manage it no extra work
from you next is the built-in restart so
that you don't actually have to go off
and implement your own monitoring and
own restart of all the services um so
and then also it participates in in in
handling for our software faults and
that's kind of important so insular
we've also introduced a partner
technology to SMF that we call the fault
management architecture and the fault
management architecture its job is to
basically be both reacted
and proactive about Hardware faults on
the system so first it can react to
spurious and known hardware fault so if
a CPU just fails if we if we get an
uncorrectable memory error back from the
CPUs cash or from a piece of memory
those sorts of things we can it actually
reacts to those things by taking the CPU
offline or in the case of a ue killing
the process that had the uncorrectable
memory error in it if you use SMF
process is killed because long correct
memory or SMF will restart it again
that's basically all integrated if you
don't use SMF if you're starting up
within our C script or whatever we
basically say we don't know how your
processes relate to other processes on
the system so we have to basically kill
it and leave it dead and then finally we
are working on or looking to work on
future software more software diagnosis
capabilities now that we've got all
these cool things with knowing about
when a you know knowing that a service
dies and be able to recover from it we
can actually start doing some
interesting metrics around us and say
huh your service is always dying at you
know your peak hour of tuesday at 7pm we
started we restarted it for you your
service wasn't interrupted for your
customers but maybe you want to tell
your developers that this service always
dies when the load is at this amount I'd
like we wanted service development to be
really incremental a manifest is usually
all that's required and is doesn't take
too terribly much to get working like I
said we created about 150 of these
insularis with a team of about three
engineers so it's it's not that hard and
you certainly once you've learned your
first one there they're pretty easy from
there on out you can actually then get
more involved you can handle error cases
much more you know gracefully you can
say things like I know this error is a
configuration error you can tell SMF you
accident error the NASA bufkin tell the
admin it exited due to a configuration
error things like full restart ability
so that you could say oh these are
components of my service they can fail
separately put them into different
services
and then you know finally you can kind
of go whole hog and say well some of
these processes in my service their
worker processes I know more about them
than SMF could possibly so I can
indicate desk mouth their worker
processes you don't need to restart the
service if these guys can if these guys
cord up all the time for example we saw
this a lot with send mail people like to
have procmail and filters on the like
which court up all the time so we
basically get to tell a serviceman well
so that maybe that's not so important to
you you don't need to restart just
because something poor Dumpty in you
know in a procmail script I'm going to
skip over these pieces but this is
basically what a manifest looks like
like I said it's a wad of xml goo but
it's not you know it's not terribly
complex you've got you know do I want to
default instance do I want that instance
enabled or can there be more than one
instance of this service running at a
time what are my dependencies I'm you
temp so I actually rely on the system
being configured for the first time
before I run what depends on me
multi-user I want to start you temp as
part of you know RC 2 and then finally
okay so I've got dependencies I've got
what depends on me and then finally I
get to say okay my methods have you
started right and and how do I stop the
cool thing here is we didn't have to
write a special stop script we basically
can say kill everything in that contract
and like we talked about before contra
because we know what processes are all
part of that service we can just go
ahead and kill them off for you and you
don't have to worry about tracking what
the name was who p kill it and then you
know getting it wrong and having a peak
hill similar service last stuff is
basically gravy it's basically so that
we can give a common name that localized
about the service itself as well as
references to the man pages or any other
external documentation that might be
useful to somebody who is debugging a
problem with that demon
there are some things you can do like I
said to be to be more more friendly to
SMF and more friendly to people looking
at at failures of your service so you
can say things like it's a configuration
error in the service or it's a fatal
error don't bother to restart me because
I'm not going to get any better and many
services actually know that when they're
starting up that the things that some
errors are fatal let's see we've got a
DTD for the manifest it's actually
fairly well documented on its own it's
got lots of comments and the like and
then the other thing is like I said it's
been a long time since i wrote a service
from scratch basically i tend to take
one of these examples and go ahead and
start from it and just modify and there
are usually about four things to
modifying you're done you temp for a
standalone demon core atom for something
that blacks a bunch of configuration in
the kernel but never has to run again
and then telnet for a 9 @ d managed
demon services dash X I think I should
repeat that a few more time services
deck services dash X so basically
services now X is how we want to explore
errors on the system and to be able to
say here's what's you know this sort of
global view of what might be wrong with
your system so that's that's where we're
starting and that's where we're adding
to as we diagnose more and more failures
on system let's say we try to log for
our services that's actually pretty
important to us is it used to be that
what would happen is people would just
dump their their init script output to
the console and this was great if you
had a console logger and something went
wrong but terrible if you didn't have a
console water and something went wrong
so we actually saved all those sort of
things that scripts like to send to
standard out in standard air along with
you know a log of what SMF is trying to
do I decided to you know you told me to
enable the service so i enabled that you
told me to disable it something a
dependency failed to I had to restart it
those
it's of things we put into the log we
also have things like you inset
environment variables in the service and
we're looking actually to increase the
debugging capabilities in the future and
we've been having that discussion on SMF
discuss and please give me feedback on
debugging capabilities you might want
added or come join us on SMF disgusted
opensolaris org and talk to us about it
because we're actually we know that we
could be providing more to people who
have to basically put a demon into
debugging mode and sort of up level that
in the same way that we thought level
service administration in general so you
can basically say well I want to make
sure that this demon you know logs
everything it's doing and then SMF can
tell me about where it's putting the log
file and everything services dash X so I
can say it again but basically we try to
give as much information as possible in
the services that rocks pointer about
how to recover and you can revert to a
previous snapshot if you've been mucking
with the configuration a lot and we'll
make that easier in the future but it's
it it's kind of a nice safety blanket um
I'm going to skip over packaging there
are references to yeah and I probably
should have referred to the opensolaris
aight i'll refer to it i'll have a link
to the opensolaris site at the end but
lots of developers are coming to
opensolaris and talking to us about
problems they're having and the
important thing is it's not just a
matter of well yes we answer the
question immediately but that feedback
is what we're using through design the
next um the next things in SMF so let me
talk about finally um I'm going to end
close to on time even though we started
a little bit late but I want to talk
about what we're doing now what what
basically what the SMF team is is busy
coding today as well as sort of where we
want to go in the future so the current
things that we were looking at is we
spent a lot of time initially with us
enough trying to make things easy for
the administrator okay make it really
easy to do the common
enable disable restart those sorts of
things we put configuration we put this
meta configuration to SMF but as more
and more stuff is actually using the
configuration capabilities we realize
that there are probably some gaps first
of all repeatable customization was one
we actually wanted to wanted to make it
really just truly simple to pick up your
customizations not things that the cysts
necessarily well that too but let's
start with the things that are your
customizations the system shipped to you
with a set of defaults and then you went
off and customized you basically said
well okay but I don't want sendmail
running on this server for for NFS I
want to run you know more threads on the
server those sorts of things what are my
customizations on the system so we
wanted what was really important to us
is a way to extract first of all to know
what the administrator has customized
extract that information and then repeat
it on another system so that it's really
easy to deploy things along with that is
the ability to basically pick up the
entire configuration of a system and go
redeploy it but the differences were
actually really interesting to be able
to say what have I configured on the
system we wanted to do more
configuration validation during input I
mean we've got some simple typing
capabilities so we can start by saying
are you in putting thing of the right
type but we also wanted to do a little
bit a little bit more individual
validation let's say auditing as well we
basically got the code done and just
have to finish putting it back but base
what we can do auditing for all
administrative events with an SMF as
well as configuration changes and the
security teams really excited about this
because it used to be that when you did
auditing of a file change a
configuration file change all our audit
trail could tell you is the file changed
hmm what to do the file change what was
the old version what was the new version
who the heck knows but now in the audit
payload actually we can we can put
together and the information of you've
added this property you deleted this
property you change this property it's
all value was this its new
you is this and actually say something
really interesting about what's going on
on your system over time we're using vsm
auditing which is our basic security
module auditing because well it's the
audit trail we have in the system it's
secure all those things so that's why
we're using it today and I'm hoping that
as soon as we have it out that a little
bit at a time because I'm excited about
actually creating something that kind of
shows you what's going on in your system
over time and it should be really easy
to do with this our manifest the
importance performance on first boot is
a little marginal so we're looking to
improve that we actually have some ideas
on how to do that at the same point in
time simplifying delivery of early boots
sort of services that actually need to
start before the root file system is
mounted read/write things are pretty
cool for application services because
you know they start relatively late in
the boot process and just kind of you
know they think they don't need to do
anything special but it actually turns
out that in the operating system because
we're the framework that plums up the
rest of the infrastructure we're the
ones who mount root read/write were the
runs who mount all the other file
systems that we actually you know need
it to be a little bit easier than it is
today to deliver early boot services
finally we're doing some unification
around our interfaces for service
administration Oh solaris doesn't have a
ton of gooeys today but we realized that
with SMF we have a lot of metadata about
you about services on the system and we
can do some generation of gooeys a lot
simpler than it would be to write gooeys
individually for each individual piece
we're doing that part too but we're
actually pretty excited about the idea
that you can on that that you can kind
of just look at the services on the
system and give a relatively pretty view
of what are what's their status and you
know what can you configure on this
service with a little bit of metadata
about it so what sort of projects are
we're working on all these are open on
open solaris we take comments quite
happily so the enhanced profiles project
is
sounds small but is actually much bigger
and implementation that it sounds like
so the general goal is to be able to
customize and easily deploy
configuration like I was just talking
about so you can essentially you know
take take this wad of configuration you
want to apply to a new system and you
know generate it pretty simply and then
just go through it at machines as many
machines as you want so what we realized
is we sort of had these profiles in SMF
today but they were relatively simple
and they had no representation in the
repository itself so it was hard for us
to tell where configuration came from
did it come from you know did it come
from the regional service author did it
come from like I was just talking about
secure by default that it come from the
secure by default team saying or the
admin saying I want the system to be you
know open to the world or close to the
world and then the the last thing is we
wanted to be able to make it easy to
drop this profile into place during
system deployment
okay so so there's another talk starting
so I'm going to have to close this one
up but you know we do have a couple I'll
put these slides up and you know we've
got a couple of other things going on
sort of just a few of the system
administration stuff that we're doing
and then you know futures are to work on
our fault model in more detail come up
with a public restart or API as well as
do some more configuration sharing and
deployment across the system so i'm
going to entertain questions probably
off to the side in a bit so that the
next talk can come online but thanks to
everybody for watching you can always
reach me directly Liam Prasad suncom or
I'm active as well as the rest of the
SMF team is incredibly active on our
community on opensolaris so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>