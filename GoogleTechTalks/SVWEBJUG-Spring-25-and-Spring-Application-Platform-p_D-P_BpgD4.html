<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>SV-WEB-JUG: Spring 2.5 and Spring Application Platform | Coder Coacher - Coaching Coders</title><meta content="SV-WEB-JUG: Spring 2.5 and Spring Application Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>SV-WEB-JUG: Spring 2.5 and Spring Application Platform</b></h2><h5 class="post__date">2008-09-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/p_D-P_BpgD4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright we had a full house so thanks
everybody for coming out as you know you
know we got rod Johnson we're very
thankful that he came out and he's going
to come and talk about spring 2.5 so in
some of the stuff with the application
platform I've got a few announcements
kind of before we get started we got the
kind of q con in san francisco is going
to be november seventeenth through 21st
and there's some flyers in the back that
have some discount he's 100 on off and
this is a conference has been around a
while but it's just started in san
francisco a lot of big-name speakers
martin fowler rods going to be there and
maybe he'll tell you a little bit about
it before his talk starts we have any
other kind of announcements turn off
your cell phone that's kind of a nice
thing to do use a mic for your questions
because we are recording and you will be
able to find this on on youtube later
next month sep tember 16th we have mark
hansen restful web services so that
should be a good talk and special thanks
to google for allowing us right so
that's that's all great well Brad's
gotta know thanks Kevin well I'm think
actually I've been living in the bay
area for about a year now and I think
this is probably one of the first public
forums that I've spoken out here so this
is quite pleasing before I start I'd
like to just say a little bit more about
q con if you're unaware of it q con is
now I think in its second or third year
its conference that is in San Francisco
there's also a cuke on conference in
London and it really is a very good show
from a technology perspective it's
actually put together by timid people
led by Floyd marinescu who of course was
the founder of server side and I mean
fluid is obviously a guy who really does
know his stuff technically so you know i
would say that in terms of conferences
for interesting technical content it's
definitely up there and of course it is
in
the Bay Area we will be presenting i'll
be presenting at q con also my colleague
Rob Harrop is the lead of the spring
source application platform will be
presenting so it'll be a good
opportunity to learn more about that so
what I'm going to talk about this
evening is some of the new stuff in
spring 2.5 and also give a brief
introduction to the spring source
application platform I was originally
trying to do a spring 2.5 update
presentation in one presentation and
unfortunately it really doesn't work
because there's just too much stuff that
is new in spring 2.5 so it ends up being
a bit rushed so what I've decided to do
is to pick out one feature in particular
and go into somewhat more detail about
that I'm very happy to take questions
towards the end so you know please if
you have a question about other things
in spring 2.5 will be very happy to talk
about it so the features specifically
that I'm going to talk about today is
the annotation support in spring 2.5
this is the biggest or the farthest
reaching single new capability in spring
2.5 but as I mentioned there's quite a
range of new features annotations of
course should be familiar to everyone in
the audience they were introduced in
Java 5 and they provide an ability to
add metadata to source code we started
adding annotations to spring in spring
1.2 those annotations were for
enterprise services so for example we
introduced the at transactional
annotation which was an alternative to
external XML configuration for
transaction delimitation and we also
introduced some annotations to drive jmx
exposure of spring managed objects
in spring 2.0 we added further
annotation such as that required for to
specify required semantics for injected
values and also of course in spring 2.0
we merge the spring Opie model with the
aspectj model which meant that we got
the aspectj syntax that was introduced
in aspect j5 where aspects could be
could be defined in a very elegant
annotation semantics within the Java
language in spring 2.5 we go a step
further and we provide comprehensive
annotation support for dependency
injection as well as Enterprise Services
it's probably worth talking a little
about versions here spring has
traditionally run on Java 13 and above
so obviously spring first appeared
before Java 5 was final we then started
in spring 1.2 and 2 point 0 taking more
and more advantage of Java 5 features so
in spring to Plato it still ran on 13
and above but frankly most of the new
stuff was only really relevant if you
were using Java 5 in spring 2.5 we've
dropped support for Java 13 we still
have support for Java 14 bit again if
you want the full range of capabilities
you really need to be on Java 5 and
we've started adding explicit support
for java 6 so there are a number of
areas in spring 2.5 where we take
advantage of Java 6 spring 2.5 will be
the last version of spring that runs on
any version of Java prior prior to java
5 so spring 30 will be Java 5 only and
that of course means that you know
certain of the core api's we can modify
and simplify to be purely java 5 so why
would you use annotations for di well
there's a number of possibilities you
would apply annotations to classes
method
or fields if you would apply annotations
to classes you're probably indicating to
the ioc container that this is an
interesting type a candidate for
dependency injection and management if
you annotate a method of field or a
constructor you're indicating that that
is a specific injection point and you
could optionally indicate something
about how you should resolve that
injected object so the pros and cons
about annotations for dependency
injection obviously this is a matter of
some religious debate we have taken a
fairly cautious approach with
annotations in spring so for example
it's pretty clear in our view that
annotations is the sole approach for
dependency injection are not viable in
the majority of enterprise applications
I mean as I said this is a point of
religious difference so for example I
know that Google's own bobbly disagrees
vehemently with this all I can say is
that Bob must have seen a different
subset of enterprise application
requirements and what I've said because
there are a lot of situations where you
need to externalise configuration from
Java code certainly that's what I've
seen and what we've consistently seen
across our services practice at spring
sauce annotations are obviously
attractive in that they can reduce or
eliminate external configuration
annotations are inherently more concise
they're more concise because you're just
defining what should happen you're not
defining where it should happen right if
you're using external configuration
you've got to have some kind of cross
referencing mechanism that ties that
back to points in the source code where
the annotations you don't need to do
that you just you're at the point in the
source code where something should
happen so all you need to do is indicate
what it is that should happen some of
the downsides are that annotations are /
type not
instance that's a point that often seems
to be missed for example in the
framework itself in spring there are
many generic classes like some of the
factory beans that can be reused in many
scenarios and clearly it's not
appropriate to use annotations on those
types because they can be reconfigured
in different ways with different
external parameters similarly it may be
a problem if you have existing code for
example somebody else's library that you
don't have the source for so it's very
valuable to have a strong method of
being able to configure that without
getting hold of the source code
obviously you may not want to recompile
it and there are scenarios where you can
for example externalize not just into
XML files but into property values so
people who are not java developers can
modify the behavior of your application
and that can be really quite useful also
annotations don't tend to be a good
technique or approach for externalizing
simple types we have two choices for
annotation driven dependency injection
in spring 2.5 the first is the at auto
wide annotation which spring introduced
itself the second is the at resource
annotation which was introduced in Java
EE 5 and is associated with ejb3 of the
two we recommend at auto wired the
reason that we recommend that auto Wyatt
is I think it's fair to say this is a
third-generation approach to annotations
for injection so for example if you look
at the at resource mechanism it was the
first attempt to apply annotations for
dependency injection then juice came
along juice really had some pretty nice
ideas and we had the benefits of both
those inputs into the design of at auto
white as the name implies at auto wired
builds on spring concepts auto wiring is
a term that Spring has had since spring
10 and it's an approach in which the
container has always been able to
the necessary injection behavior through
introspection an auto wired can be
applied at constructor field or method
level like juice injection it supports
multi argument methods which also helps
to make it very concise the default
behavior is Springs traditional autowire
by type annotations make auto wiring
much more useful so traditionally with
spring you could have a beam definition
in XML or otherwise externally defined
and you could apply auto wiring to that
beam definition the problem with that
was that it was an all-or-nothing
approach so the container would then
look at your constructors or and look at
your set of methods and it would try to
resolve everything that was injectable
by other managed objects in the current
ioc container instance the that was
useful especially in prototyping but
when you got into complex scenarios it
could be a problem that essentially it
was going to try to process all your set
of methods rather than be strictly
targeted with the ad auto wired
annotation in the simplest form you just
annotate the fields methods or
constructors that you're interested in
and the auto wiring behavior will only
apply to those methods so you can have
other methods other setters that won't
be processed through auto wiring this is
the simplest form of usage and this
corresponds to Springs auto wired by
type how many people are using spring
how many people are using auto wire by
type interesting how many people know
what this will do so if this is the same
behaviors or tow wiring by type what
will it do it will inject it yes I would
hope so but
injected how will it resolve the
injection so clearly we've got two
problems here and actually that's a
valuable point because what you've
identified is one of the two problems
which is injection so we're identifying
something that will be injected the
second part of the problem that we need
to solve is yes it will be injected but
where do the values that we need come
from so there are two distinct problems
the problem of where do you inject and
the problem of okay how do you resolve
what it is that you need to inject so
with respect to the second problem how
is the container going to try to figure
out where to get those references from
from the spring context yes and how is
it specifically going to work out by
type exactly so this will work if we
have exactly one data source and exactly
one connection factory in our spring
context it doesn't matter what they're
called for auto wiring by type be naming
is irrelevant so in other words it's
exactly the same behavior that spring is
all red the difference is now we can
apply it selectively so it's a good
simple approach however what happens if
there are too many candidates so for
example what happens if we don't have
just one data source for one database we
have multiple well in that case
resolution by type isn't going to work
so we need to provide hints and spring
provides a mechanism of doing this
called qualifiers so qualifiers can be
used on fields or parameters to narrow
down the resolution so here we see a
slightly more advanced example where we
have an auto wired identifying that this
massive method is an injection point and
now we have three parameters so firstly
note that the number of parameters and
the name of the method are irrelevant so
you can have any number of methods any
number of parameters that you want and
the method can be called anything at
what you like
the interesting thing here is that we've
got ambiguity and how we're resolving
that ambiguity in this case is through
resolution by name so what we're doing
is we're using an additional annotation
on the parameters to say that this
should be resolved to a particular named
Dean in the current spring application
context the third value will be resolved
using the default autowire by type you
can mix and match so you can have as
many different modes of resolutions you
want they're all processed independently
so this is exactly the same as Springs
traditional autowire by name we can also
resolve dependencies by annotation so
clearly that approach involves putting
the knowledge of the names of your
spring managed objects in your code
which you may or may not want to do if
you don't want to do that another
approach to do it is to resolve
dependencies by annotation and this is
the approach that was pioneered by juice
so here what we're doing is pretty much
the same as what juice does this is
analogous to our inject and here we're
having annotations that are user-defined
annotations and not spring annotations
that define how you resolve those values
it's a bit different to juice in that
you're not tied to specific annotations
that actually I think a guy called
Solomon disqus a consultant in New York
blogged about how you can get spring
just without changing any code to
process juice annotations because you
can just configure the kind of
annotations it scans for so here what
we're going to say is that we've got to
order services we're going to resolve
the potential ambiguity by saying that
this order service is injected by as
resolved to the order service instance
that's associated with the
aamir annotation and the other one is
resolved to the service what a service
implementation with associated with the
apec annotation how do we associate it
well the easiest well there were two
ways one is to imitate the the reference
the type that you want to be resolved to
with the annotation that it should be
associated with so for example here we
could define the addameer annotation and
we could annotate that the order service
type that we want to resolve to here
with that annotation so it's exactly the
same as the juice model basically it
also has the same down side which is
that defining annotations in Java is
pretty verbose so you know you do need a
separate artifact for each Association
that you wish to create the alternative
approach is to do the Association in a
beam definition so here you can specify
a qualifier it's a new sub element of
the beam element and you just specify
the fully qualified name of your
annotation this works nicely if you want
to use annotations but you don't want to
win annotate the target the beam
definition by the way with the
annotation model as you will see shortly
is optional so you can define beans
without any annotations so let's go back
over this again we use annotations to
identify injection points the at auto
wired annotation we can have the default
behavior of autowire by type or
alternatively we can resolve by name
with the Act qualifier annotation or we
can resolve by annotation on the week
and I associate the injection target
with the annotation in one of two ways
we can annotate it with the annotation
or we can create the Association
in a being definition all this of course
is additional to everything else that
spring does so you don't lose any
capabilities these are entirely new
capabilities auto wired at auto wide
pros and cons it's a very capable model
it is simple and concise works with
arbitrary method names you can have any
number of parameters you can mix and
match resolution approaches really the
only negative is that it's a spring
specific mechanism you can if you're
really bothered by that you can
configure spring pretty easily to use
your own annotation instead of at auto
wired but you know frankly that's
probably a slightly puritanical
objection to using something that's
useful the alternative approach that we
ship out of the box is at resource at
resource is a java ee 5 annotation and
it identifies an injection point that
can resolve to a single component in
java ee 5 any top level component like a
servlet or an ejb can have at resource
used on it interestingly in weblogic 10
the implementation of that resource has
always been based on spring using the
pitchfork project but in spring 2.5
pitchfork is not required on top of
spring to do at resource injection what
it gives you is essentially a superset
of what you get in java ee 5 because
spring removes the restriction that the
component should come from jndi if
you're using a tree source for injection
in a servlet or an heb the injection
target must come from jndi which kind of
makes it not so useful for injecting
fine-grained objects we remove that
objection it looks in that restriction
looks exactly like what you would say in
ejb three examples spring does that out
of the
box you don't need anything additional
to spring pros and cons it supports Java
EE five behavior so you know it does
help theoretically with portability you
could write this and you could
potentially run it in a Java EE five
environment but bear in mind you could
actually run your spring in Java
reinvite five environment anyway so you
know that again is largely theoretical
the problem with it is that frankly you
know it is a first generation attempt at
annotation injection and it really does
show so you can only inject one
reference at a time there's no
sophisticated support for qualifiers and
bear in mind that if you really want it
to be portable you have to be committed
to making every single object that
you're going to inject exposed in jndi
presumably as an heb so we don't really
recommend that it's a nice check box
feature to have it's also something that
will probably be very useful when a
little further down the track we expect
to make the spring source application
platform implement ejb 3.1 light so it
can get profile a and B certification
for java ee 6 so then when we are
implementing ejb3 point one light
clearly having quite a bit of it already
in spring framework will be very useful
there is however something in java ee 5
that we think is very useful in
component management and that is the at
post construct than at pre destroy life
cycle annotations these are really
analogous to springs and knit methods
and destroy methods and also the
initializing bean and disposable bean
interface we think this is a best
practice annotations are an elegant
approach to doing this this is supported
in java ee 5 environment as well so we
really recommend the
it you use these annotations rather than
the spring specific techniques if you
can to achieve that kind of life cycle
behavior again supported out of the box
in spring 2.5 you just that you do need
to enable the support eat all the code
you need for it ships out of the box but
you do need to use a specific flag in
your configuration to enable it the
reason for that is otherwise it would
break backward compatibility because if
you had some classes that happen to have
those annotations but you didn't expect
them to be used in spring clearly it
would be a problem if suddenly spring
started started calling methods you
didn't expect so that's the only reason
in case you're wondering why are clearly
desirable behavior is only an option
rather than the default it's because it
would break backward compatibility
because otherwise you know it's probably
a pretty weird scenario but one thing
that we've seen is that if you have
millions of downloads and hundreds of
thousands of years it doesn't matter how
weird the case is somebody is going to
run into it and potentially this could
clearly be quite a hard puzzling problem
for someone to track down so we
recommend that this is a best practice
and you adopt it right I talked about
the way in which you could apply
annotations at type level at method
level field level and constructor level
I haven't shown you any examples of
annotations at type level why would you
have annotations on classes or
interfaces the reason that you would do
that is twofold you could annotate types
to indicate their purpose in an
architecture so I'll form the
documentation that's available at
runtime through introspection you
also annotate classes to indicate that
they should be picked up by the
container so here we come back to
something that we introduced in spring
2.0 which is the notion of stereotypes
in spring 2.0 we introduced the org
spring framework dot stereotype package
these identified classes that had a
particular purpose in your architecture
really there's nothing there that's
particularly spring specific command
it's meant to be at a conceptual level
rather than a specific implementation
level but there wasn't anything else out
there that it actually defined what we
want wanted so we put them in spring why
would you want to do this well firstly
it might make your code easier to
understand it's a form of documentation
and documentation is a good thing
documentation is a particularly good
thing when it's amenable to tooling and
when it's accessible at runtime so
that's one reason you might want to do
it another reason is that it's a very
good target for aspectj pointcuts in
aspectj 5 there was introduced the
ability to select join points using in
pointcuts based on annotation so this is
a form of documentation which actually
enables you at runtime to pick that out
using an aspect J point cut so for
example think about you could write a
Java dot that says something like this
is a spring MVC controller or this is a
class that runs inside the something or
other engine and that would all be fine
but it's not useful to you at runtime if
you use an annotation for it you can now
easily write pointcuts that you can use
in spring aop or aspectj that will pick
it up
we ship a number of annotations out of
the box in the org spring framework dot
stereotype package we ship at service
which identifies as stateless service at
repository which uses domain-driven
design terminology it's essentially what
we often call the dao or do depending on
your religious preference there's a lot
of religious preferences in programming
at aspect which is of course not an
annotation that we introduced but an
annotation that aspect j5 introduced and
we adopted an act controller which is a
spring MVC controller so all of those
ship out of the box however now i'm
going to introduce the concept of meta
annotations meta annotations or
annotations that annotate other
annotations I love saying that sentence
I never get tired of it it's a kind of
thing you know late at night in a bar
having a contest to repeat that we'd
really be very entertaining what is a
meta annotation well annotations are
basically pretty messed up in Java I've
referred to the idea of you know first
second and third generation annotation
driven injection models in Java in the
assumption that each generation is
probably going to improve on the last
annotations in Java were really second
generation in that they'd already been
in traduced into dotnet so it's kind of
a bit disappointing that they're
probably not as good as dotnet had
already done one thing that really is a
bit weird is that annotations can't
participate in inheritance hierarchies
given that the things are only dynamic
proxies at runtime I doubt there's any
really strong implementation argument
against that but it certainly causes a
significant number of problems in
practice how many people have bought it
annotations okay we're already down to a
pretty small subset so I'm not so
confident about the answer to the next
question which is when you author
annotations you pretty rapidly hit the
point where you actually realize that
you have three or four annotations that
share some properties and it's like oh I
need to duplicate end I need now to
duplicate the code that populates those
properties so because annotations can't
participate in inheritance hierarchies
there is no way to express an easy
relationship so for example a spring MVC
controller is a type of component a
service is a type of component so at the
top level we've got this the only way to
express that notional inheritance
relationship is through annotations
annotating other annotations that is
possible and that really is a nice
feature of annotations so with the app
component meta annotation you can go and
create any other annotations that you
want that are annotated with that
component now that is very interesting
because that means that you can actually
tell spring to go and scan the classpath
to find any annotations that are
annotated by the app component
annotation and that enables it to pick
up classes that should be spring managed
objects or spring beans without a
requirement for any xml or external
configuration so let's suppose you have
an act service on a class this is an app
component because it's annotated with
that component all you need to do is
configure annotation scanning and it
would be equivalent to this so if you
turn on annotations scanning as soon as
spring
looks at the classpath it will hit this
and even if there isn't this beam
definition this is what it will
implicitly create remember that Springs
internal metadata is not tied to XML or
any other representation so there's no
need for XML or a particular format of
external metadata for spring to manage
objects how do you set it up well again
this is something that isn't switched on
by default again if we switched it on by
default you would get some pretty
strange potential behaviors in existing
applications so you use a new name space
called context that is used to configure
things like annotation scanning for both
component level and injection and you
just specify which package or packages
that you want spring to scan on the
classpath obviously it's a good idea to
be reasonably specific about that
because annotation scanning if you're
scanning the user-supplied types of a
particular application is going to
happen pretty fast but for example if
your base package was calm that could be
a problem because it could try to scan
some of your third-party libraries so
use common sense and if you use common
sense you really will not notice the
performance impact of the annotation
scanning obviously a naive approach to
annotation scanning would be to go and
look at the dot class files that you
could get hold of and actually do a
class for name to look at the
annotations that they might contain why
would that not be a good idea
okay you guys are application developers
rather than infrastructure developers
you are normal people you are not the
weird twisted arm disillusioned people
that right infrastructure it would be
the ideal an obvious way to do it
unfortunately if you did that you would
be loading classes eagerly which can
cause all kinds of nasty problems good
example of this is instrumentation so
for example if you're using the java
persistence api your implementation may
need to instrument entity classes so add
entities it may need to instrument to do
lazy loading if you load them too early
so for example of spring which probably
bootstraps your JPA implementation also
goes and eagerly scans every class in
your application that's it you can't
take a class out of a class loader so
once it's loaded it's impossible for
anything else to instrument it there are
mean there's also things like the
initialization of statics there are a
bunch of reasons that you can't do that
so what we do is we actually use azum we
have our own abstraction for metadata so
we have our own abstraction for you know
java class definitions and we load it
using azum so it does not cause any
class loading problems it also means
that in the remote event that any of you
do become warped and twisted
infrastructure developers it's a pretty
useful library for getting information
without being tied to as a more
particular implementation so that's the
simple way to turn it on this is
probably what you will use it will of
course look in jar files it's it or it's
not just going to look at dock classes
and you can this being spring you can
configure it to your heart's content so
let's suppose you want to suppress the
default filtering by default when we go
back here we're saying
where are we going to look we're going
to look in the my app package it will
look in jar files it'll look in doc
class files so it'll look all the places
you were expected to look but implicitly
what it's going to do is look for at
component annotated classes or for ant
aspects it's what it's going to look for
by default if you want you can turn off
the use default filters you can filter
by your own annotation you can filter by
regular express express ins and you can
filter by a sign ability so for example
you can find all implementations of a
particular interface and automatically
pick them up so for example if you want
to give a between test and production
you can pretty easily set something up
so that everything that ends with stub
is picked up in the test environment but
is not picked up in a production
environment doesn't have to be purely on
annotation similarly the ability to
include or exclude based on a sign
ability can be very very useful I think
this is a feature that people probably
don't realize the power of you can do
some very interesting stuff like when I
was first playing around with this and
one of the milestones of spring 2.5 i
was looking at how you could do
production and test auto selection and I
mean it was just amazing how easy it was
to use the includes and excludes to get
that working pros and cons you can
wholly get rid of XML if you want if you
want to write a spring application
without a single line of XML you can do
it quite easily changes are picked up
automatically that's particularly nice
during development so you know you add a
new a
type that you want picked up it just
automatically gets picked up it works
particularly well with the annotation
driven injection so if you didn't have
at auto wired it would be something of a
scattergun approach we're at auto why it
works extremely well and as you've seen
it is highly configurable so you know it
doesn't just work in the easy cases it
works in corner cases as well obviously
as I said no annotation based approach
is a hundred percent solution you do
need to use common sense so that you
don't scan an excessive number of
classes and one one downside is that
external configuration can give you a
valuable blueprint of your application
structure and you don't get that if
things are being picked up and linked by
annotation you don't get a single place
or single set of places where you find a
blueprint for your application
fortunately there is a solution for this
as I said metal spring metadata in the
end so the spring component model
internally in the container does not
know anything about XML or annotations
or any other representation so this
means that one approach doesn't exclude
others essentially what happens is the
container starts up it reads whatever
configuration it should read it reads
whatever properties files it should read
it scans for whatever parts of the class
path that should scan for and then it
merges it all together as contributions
to a single spring application context
this means that it's perfectly possible
to mix and match XML and annotation
configuration so you never hit a wall if
you have a problem where you want a
particular behavior you can't get with
annotations you just write an XML been
definition for that particular beam
there is a pretty simple naming
convention which is the d capitalized
short name of the class alternatively if
you want any of the app component
annotations you can supply
a name for as well that's something to
bear in mind if you're defining your own
annotations that you're going to
annotate with that component be sure to
provide a name property again
inheritance does not work for annotation
so the fact you're annotating it with an
annotation that has a name won't do you
any good you need to supply a name
property and then you can get that
resolution by name working as well so
you can provide the best combine the
best of both worlds if you want that
application map you can actually even
get it where the mixture of annotations
and anything else you like if you're
using eclipse and spring I da how many
people are using eclipse how many people
are using IntelliJ yep oh no it's not
everyone else how many people are using
something else what does it NetBeans
jdeveloper NetBeans jdeveloper VI wow I
used to use VI so if you're using spring
I da an eclipse plugin you will get a
unified view of configuration also i do
know that there's been a lot of
improvements recently that the jet
brands guys have done in IntelliJ I
don't know what the status is of
NetBeans or jdeveloper okay now let's
move on to spring web nvc firstly any
questions about that is everything that
I said clear yes the XML will override
annotations which makes sense because
obviously you can change it more easily
however in general I would say if you if
you need to use the XML to override
annotation
you'd want to ask why are you putting
the annotations in you know it's
probably a bad place to use annotations
because obviously it becomes confusing
then some people might look at the
source code and be very surprised to see
a different behavior okay on the theme
of annotations Nets now turn to spring
MVC spring MVC was is basically a very
powerful MVC framework it has always
offered a flexible model it's always had
a host of extension points like handler
mappings handler adapters view resolvers
every part of it is customizable it
really had two problems one was that it
required excessive configuration to set
up we started to ameliorate that
inversion spring two point oh but I mean
still it required a little bit too much
configuration and also the hierarchy of
form controllers never quite felt right
never quite felt right because it was
based on concrete inheritance and
concrete inheritance sucks so I mean I
actually was responsible originally for
designing that night must admit I never
felt that it felt right was certainly a
great improvement from struts on struts
but you know then as most things in life
so with the inheritance hierarchy you
had simple form controller and all the
others and it got complex you have to
understand quite a bit about what order
particular template methods were going
to be called in and fortunately this is
something to which annotations are a
natural solution annotations are a
really really really big deal for MVC in
fact interestingly annotations seem to
have given spring MVC a new lease of
life so the take-up of spring MVC in the
last year has actually been very very
substantial
and what it meant was that we could get
these kind of effectively call back
behaviors without being tied into a
concrete inheritance hierarchy this has
a number of benefits firstly it means
that you get your inheritance hierarchy
back so you get away from one of the
problems that you know plagued a lot of
frameworks in the past you've only got
one shot at concrete inheritance in Java
and you better make good use of it so
that's a benefit for you as developers
there's another benefit for us as
infrastructure developers which is that
if you're not tied into concrete
inheritance hierarchy your code is much
more decoupled from our code we actually
want your code decoupled from our code
because that means the we can modify our
code without breaking your code so we
can modify our code and potentially make
you happy rather than unhappy if we
modify our code to make it better so if
you use spring MVC you might have been
familiar with moldy action controller
how many people have used spring MVC
multi-action controller was similar to
struts dispatch action so it enabled you
to have multiple methods in a controller
that could handle different request
mappings the problem is without
annotations you needed to have external
configuration to resolve which methods
get mapped and also it didn't really
work at all for complex form processing
without annotations in 2.5 you simply
enter tate pojos with a number of
annotations like at controller which is
an app component annotation that
identifies a controller at request
mapping at request per am and various
other annotations let's look at a simple
example so here we have at controller
there
can cause auto scanning component
scanning to pick up this is a controller
without any XML in spring 2.5 you should
not be defining XML beans for your web
MVC controllers why should you not be
doing that you should not be doing that
because you only need been definitions
for more complex things if there is
something so complex about your MVC
controller that annotation based
dependency injection is insufficient you
really need to think about your design
because if your web tier is that complex
you should be trying to push down
responsibility to the middle tier where
it's more reusable so we're specifying
here the at request mapping so it's
going to map to order the virtual
subdirectory for order at auto wired
here we're injecting the field we're
injecting a private field in general I'm
not a fan of field injection because
it's untestable in MVC controllers it's
it depends on whether you want to unit
test them if you want to unit test them
you probably should use a method or a
constructor if you feel it's acceptable
not to unit test controllers then field
injection would be fine here we're
specifying a particular request mapping
and this actually ties into some
behaviors for particular well known
values that can be passed into these
methods so here we're returning void
avoid return type means that you're
going to work directly with the request
and response objects so if you pass in
the request a request parameter it will
obviously populate it with the current
request if you pass an output stream it
will get hold of the servlet output
stream so you don't have to unwrap it
yourself so what it will expect is that
you write directly to the output strip
in general what you will want to do is
return either a string which will be the
name of
view or a model and view object which is
the kind of you know model and view
abstraction that spring MVC has always
provided so if you're returning a view
name here this is a bit like web work
where you're returning the logical view
name and you can of course if you want
add values into your model you can use
annotation matching to populate your
parameters and these include at request
per am so obviously this just gives you
a taste of it there are a whole bunch of
rules around exception handling and the
like but as you can see this is way way
more concise than was possible with
spring MVC in the past you literally
don't need any XML in a case like this
for your web tier because you're
specifying the request mappings you're
specifying the URLs you're doing all of
this with annotations and you don't need
beam definitions either there are also
annotations for session attributes data
binder initialization have a look at the
pet clinic sample application that ships
with spring this comes to an interesting
question we sometimes hear sometimes
people say well you know as spring gets
more and more complex and does more and
more things isn't it going to go the way
of Java EE and the answer is no just
because other people have made
engineering mistakes in the past doesn't
mean that everyone has to make the same
mistakes in fact you would rather hope
that people learn from the mistakes so
if you compare the examples that ship
with spring 2.5 have a look for example
at the pet clinic the ships with spring
2.5 versus the version with spring one
daughter I think it's something like
seventy percent of the code and probably
twenty percent of the configuration so
the reality is that with each version of
spring it does become more capable but
it also becomes
easier to use the world of spring is not
purely about the spring framework
obviously the spring framework is the
thing that everyone is familiar with but
beyond the spring framework there's what
we call the spring portfolio of open
source projects this extends beyond the
spring framework to a variety of the
important problems that you meet in
enterprise Java development these
include spring security which used to be
known as a CG security Spring batch
spring web flow which is a higher level
framework for web development spring web
services spring integration and spring
dynamic modules for osgi we had a major
release back in April where we had a
number of releases across the portfolio
including the first release of spring
batch spring web flow two point oh and
spring dynamic modules one point oh good
example of the kind of things that we're
trying to do thematically is a CG
security for spring someone I think it
was nothing was dandy pass wrote a
marvelous blog it was a very short blog
I think the entire blog was every time
you use the CD security at ferry dies
but it's still the best there is there's
a very short very depressing blog so
fortunately when Dan wrote that blog Ben
Alex the lead of spring security was
already busily at work on a solution
this solution also by the way solved
another problem about ECG security the
other problem was how to pronounce it
many people ask how to pronounce it in
fact I didn't know the derivation of the
name for quite a long time it
I mean being Australian and knowing the
bends Australian I thought it sounds
kind of a little bit like a native word
but it's actually not doesn't mean
anything at all it's the first third
fifth seventh and ninth letter of the
alphabet so a CG configuration was
undoubtedly somewhat toxic so to
configure a simple web application you
would write that XML this XML and this
XML is about 140 lines obviously a CG
security exhibited the majority of the
characteristics that are good about
spring was extremely powerful extremely
good quality very well tested very
robust incredibly flexible you you know
there really aren't that many things
that you can think of that you want to
plug into for credential stores or the
like that it couldn't work with but it
didn't really quite make it on ease of
use in spring security 2 point 0 which
is the spring branded successor to a CG
security it introduces a new namespace
this namespace came from the namespace
extension capability that was introduced
in spring to pie dough and it means that
configuration now can use far more
aggressive defaulting and this is now
the minimum configuration for acetic
security or spring security so very very
much easier to adopt another interesting
feature about this is that you'll see
that the default namespace here is not
the beans namespace using XML scheme you
can make the default namespace whatever
you want so you could put beans in it if
you wanted to but we've made the default
namespace to be the security namespace
everyone understand that so if you write
your own namespace extensions or you use
some of the ones that ship out of the
box you can actually if you want reduce
clutter by making them the default
namespace so spring security had a very
major advance into dodo and this is the
kind of thing that we're trying to do
across the spring portfolio is not just
add additional capabilities but try to
make everything is easy to use as we can
now I'm going to move on to giving you a
brief taste of the spring source
application platform which is a product
that we announced fairly recently this
is an application server it is
completely module-based it builds on
spring tomcat and osgi specifically the
equinoxes implementation of the osgi
specification but on top of that we have
a middleware Colonel what we call DM
kernel or dynamic module colonel I can
see that there's one spring source
application server or application
platform t-shirt and the audience thank
you very thoughtful we gave away quite a
lot of those t-shirts at javaone so why
do spring source application platform
matter to developers well firstly it
matters because choice is good spring is
inherently portable and that's great
that's one of the reasons that it has
become so popular however it's always a
good thing to have additional choices in
where you can host your spring based
applications but it's also beneficial in
that there are a number of problems that
really have not been addressed very well
in enterprise Java today for example
shared library conflicts class loading
these really are areas of great pain in
traditional application service for
example running hibernate three in
weblogic eight point
or weblogic 9 could actually take the
server down it didn't actually take the
server down when you started up the
application took the server down when
you ran the first query why was this
well first thing to note is it really
wasn't a problem you know the weblogic
or having it I mean weblogic is a pretty
good product weblogic is pretty hard to
take down the problem was that weblogic
internally used antler and hibernate
three years Dantley hibernate 3 upgraded
to a version of the antler that was
completely incompatible with what
weblogic was using internally with the
result that it made weblogic actually
exit the exit message was quite amusing
it said system system chart system error
char scanner panic so the reality is
that these kind of problems are firstly
not necessarily anyone's fault so you
can get the fairly scary situation where
you've got two vendors neither of them
is really doing anything wrong but the
end result being problematic and they're
becoming more and more frequent because
every application server now has open
source used in it pretty much all
applications have open source used in it
so there are really only two ways to go
to resolve it one is to do various kind
of hacky solution so you can invert your
class loading with so that a web XML for
example loaded its version of antler in
preference to the weblogic version but
you know that in complex scenarios they
don't always work or alternatively you
can adopt happy solutions like jaja
where for example if you have a look at
the use of spring and in weblogic 10
it's actually repackaged as combi a dot
spring and the reason they did that was
if they didn't do it potentially the
spring version could conflict with
people using spring in their own
application
so there are a bunch of problems around
class loading and versioning that are
really only getting worse with time in
the spring source application platform
we actually applied the power of osgi
for a strategic rather than hacky
solution to those problems so that's a
very important benefit but we also allow
the modularization not just of the
server but the modularization of your
applications so you can divide
applications large applications up into
different modules and you can replace
parts of your application at runtime
without taking the whole application
down the long term vision of the spring
source application platform is not just
to play in the space of the j2ee server
but to provide a middleware underpinning
for a variety of infrastructure contexts
so for example the ability to have say
an ESB to have a batch server as well as
the traditional web oriented application
server scenario essentially this is
completely consistent with the vision
that we've had for a number of years so
for example if you look at j2ee without
ejb which was written back in 2003 one
of the things that I argued for that in
that was a kind of server ellicott where
you just take the pieces of the server
that you wanted well the combination of
osgi and the DM kernel that we built on
osgi makes that possible some of the
benefits you can get is that you can
avoid conflicts so if you have
dependencies on incompatible libraries
you can actually make that work because
of the isolation that you can get with
the osgi model because the server is
modular itself it has a very small
memory footprint the memory footprint of
the core DM kernel is about twelve
megabyte
this compares I think there's something
like 700 megabytes for weblogic and
something like 90 for jboss so it's a
dramatically smaller colonel learn
existing solutions and where we think
there's a lot of potential for this kind
of small footprint very flexible product
in tomorrow's environment virtualization
and increased interest in solar the
spring source application platform is
about to go version 1 dot 0 final the
present version is 1 dot 0 RC 1
development on that products pretty much
well it ed is actually finished for one
daughter it supports at this time three
deployment units one is standard war
deployment which we all know and love
well we all know it we may or may not
love it the second is well they're
essentially it takes three kinds of war
a native web module and what it calls a
par a power is a platform archive so
this is a particular kind of deployment
unit that Creek contains one or more
osgi bundles a web module is a kind of
osgi bundle whose metadata will tell the
application platform to process as for
web artifacts the easiest way to get
started is probably to look at the war
support so this gives you an interesting
migration path where you can examine
whether or not the spring source
application platform is for you so you
can start off by taking a standard war
which should run then you can if you
want say the biggest problem with my war
is the shared library health so imagine
you've got these days in your war files
it's not unusual to see some of our
customers with war files that have got
like 60 70 megabytes of third
party dependencies in the lib directory
there's a number of problems with this
one is that the deployment after the
fact is simply too big let's suppose you
want to update 10 servers well that's
like pushing out six hundred megabytes
secondly what happens if you want to
make an update across numerous
applications there's no clean way to do
it if you try to move some of those
third party dependencies to your server
like for example in the Tomcat Lib
directory you can actually run into some
class loading problems and you can also
run into conflicts because now they're
accessible across all applications and
some applications may depending on
different versions so the first step
down that track to resolve that is what
we call a shared library war so you keep
the structure of your war deployment
unit you keep webbing for classes
webbing for web dot XML you just get rid
of everything in the lib directory
instead you actually write a matter int
manifest file that specifies the
dependencies which can be resolved by
the server let's have a look at an
example of this it's a very easy option
we get rid of all the crud in the
webbing flip directory and we write
something like this in meta in manifesto
MF by the way I'm not sure that everyone
knows that a web module so a war
deployment unit can have a manifest
there are actually things that you can
put in a standard war that you specify
in the manifest so here what we're doing
is replacing the web in lib by import
library and import package statements
import package is pure osgi so this is
an osgi bundle concept however import
package can be actually pretty fine
grained obviously you could go crazy
trying to express the dependencies for
say spring or hibernate
using import package so in the
application platform we provide a higher
level of directive called import library
so here you can say that I depend on
spring and I depend on hibernate and the
ejb jpa support in hibernate so note
what we can do is we can specify the
version so if we have two applications
or three applications running in our
server that need different versions
that's fine they can specify different
versions we also take care of the
transitive dependency problem as you
know if you use hibernate hibernate has
many friends that it requires friends
like CJ live like Commons collections
and even some of the more obscure ones
like JTA so the import library directive
takes care of that where do the
dependencies go to be resolved well the
platform will look in the repository the
provisioning repository of the spring
source application platform the
provisioning repository you can populate
through the spring sauce bundle
repository so that's a free online
resource where you can go and you can
search for for example the spring or
hibernate or loads of other libraries
that you might want to import so if you
apply this you can get a pretty big
saving in the size of your war files
without changing anything else so for
example when I tried it with one of my
own sample applications recently which
is a very simple application I think it
went down from something like 20
megabytes to 500k so that can be a
benefit and obviously the benefits of
the robust versioning and the transitive
dependency management can be very
significant
okay so the question is why do i specify
this version range for ejb it basically
I think would be equivalent to just
three point three point one I don't
think that a range that actually has the
same value actually means anything
however you can actually use Rangers if
you want so for example if you know that
it will work with say spring two point
five point three or two point five point
four you can put a range in that and
that could be useful because you don't
want your provisioning repository to
have versions of something that you
don't need sorry yeah it's bring a the
platform can actually look at the
versions and it can work out by the
conventions you know which is the most
recent version so the provisioning
repository therefore becomes part of the
server clearly it makes sense to move
libraries into the server rather than
the application right do you think about
j2ee j2ee was meant to provide common
infrastructure it was meant to be
everything you need but it didn't
actually work like that because what
happened was we started to put you know
20 megabytes the patchy staff spring
staff hibernate stuff etc to actually
make it usable and then we deployed that
with every application we couldn't
actually move it to be part of the
server because then you've got version
conflicts from hell so when you have
versioning moving it to be part of the
server makes obvious sense and therefore
you get sharing between applications so
it's a very easy way to try the platform
the next step is shared
services war so that's a shared
libraries what shared services war
enables you to share osgi services and
you can share them between applications
so for example if you want something
like a data source if you want a shared
service that is accessed by many
applications you can actually do that
between bundles and now you get the
ability that if you redeploy your
library with application with the shared
service the dependencies are honored you
don't need to restart all the other
applications so there's some pretty nice
benefits there then there are the native
deployment units which are themselves
bundles so there's a very interesting
migration path the present deployment
units are web-centric so presently what
happens when you start up the spring
source application platform is you get
the DM Colonel booting which boots
equinox works with its provisioning
repository and then for the
administration console and the default
web deployment unit it starts up our
version of tomcat within the application
platform however tomcat is just a part
of the platform so it's not tomcat the
boots it's the application platform that
boots and it uses tomcat to do much of
the war deployment we actually replace
some parts of Tom cut so we have a more
robust threading model and tomcat
provides out of the box but the fact
that you know tom cat is a subsidiary
rather than the bootstrap is very
important because future deployment
units will offer things like batch
deployment with spring batch integration
deployment with spring integration and
we also see a possibility for partner
deployment units so this means that
literally you can have just the server
that you need to run a particular
scenario you can access in the server
you can see what bundles are currently
in use etc in terms of this
this administration console okay I'll
think we'll try to get to the rest of
the presentation then I'll take
questions I'd like to say a little bit
about spring sauce obviously everyone's
familiar with spring not everyone is
familiar with spring sauce is a company
we are the company behind spring pretty
much every significant spring committer
is either an employee or in fact in many
cases a founder of the company our
customers worldwide include over half of
the fortune 500 and we have well over a
hundred people worldwide we acquired in
January 2008 we acquired covalent
technology this interestingly means that
we're the leading provider of support
for Apache technologies such as the
Apache web server and apache tomcat so
we have hundreds of customers that we
support on tomcat in particular so this
of course is very important in terms of
the application platform offering that
we you know have some of the core
committees on tomcat actually an
interesting metric of Tomcat in the last
12 months eighty-three percent of
committee activity on tomcat came from
springsource employers so you know it
isn't just about spring we are really
extending ourselves to provide a very
strong overall offering around
enterprise Java we provide strong
technical leadership and we're very
committed to our vision of simplifying
development and operations it isn't just
about spring and it isn't just about the
spring source application platform if
you looked at a legacy production
environment typically you had an
application that was very tied in to the
platform with spring spring not only
provides a development framework but it
actually provides significant parts of
runtime functionality so spring is
typically managing thing
like security transaction management
many things besides configuration and
this makes applications increasingly
portable so when we talk about the
spring sauce application platform it's
important to note that this is an
additional choice it's not something
that you know if you're using spring you
need to use obviously we would like to
make the spring source application
platform the place you would want to run
spring applications but we're absolutely
committed to ensuring that whatever
server people are on spring will be the
best way for them to develop and run
their component model springsource sells
a number of products and services
including as i mentioned support for
apache technologies including tomcat the
HTTP webserver and activemq we also
provide a product called spring sauce
enterprise I'll just say a little bit
about that spring sauce enterprise has
three elements based around spring
framework in the spring portfolio the
spring Enterprise Edition gives you a
version of spring where you're
guaranteed to get bug fixes and you're
also guaranteed to get instrumentation
for better application management so
obviously with open-source software and
spring like everything else the focus of
the committee's is normally on the
latest and greatest so for example now
the current version of spring it was two
point five point five I think and that's
the current focus of activity of course
for smaller companies that's just fine
there's they don't particularly care
about anything they can't get in terms
of just the community releases for the
enterprise very often people will find
that they're doing for example 12 to 18
months cycles a very large projects
based on on a version
spring or other open source software
particular point in time by the time
they roll it out into production that is
no longer the latest major version and
it really is not an attractive option to
have to update in case they want any bug
fixes so in spring sauce Enterprise we
guaranteed to provide bug fixes to our
customers even if they're using old
versions that are not really supported
anymore by the community the spring
sauce performance suite contains a
number of pieces of software that
enhance the spring experience of course
our support on spring is unrivaled it is
backed by the people like every
significant spring committer and we
provide a variety of SL a's that you
know go down to the kind of things very
large enterprises require spring sauce
performance suite offers three areas of
functionality that build on spring that
make it easier to use and easier to
manage firstly the spring source tool
suite this is an eclipse distribution
that includes spring idea it includes
milan which is a very interested task
oriented extension to eclipse it bundles
a bunch of other plugins and it also
includes fairly significant amounts of
code that are not available from us or
anyone else in open source so you know
this provides some of the value of
something like my eclipse but it's kind
of different in that it isn't actually
taking things that other people develop
putting them together and putting a
price tag on it it's actually taking
things that we and other people
developed adding very significant value
and then providing it under subscription
there are a bunch of features that are
specifically oriented at spring
developers so for example there's
wizards or cheap sheets as they're
called in Eclipse there's ability to
connect to our online services to find
out potentially more information that we
have may have in
knowledgebase about particular errors
and there is essentially an integrated
environment for everything you need for
spring development this is available for
commercial use to our subscription
customers but it is also available for
free for personal use for developers so
for example you know if you're using it
for big bank we would rather like big
bank to pay but if you're using it for
your own personal use to improve your
skills or do a hobby project or whatever
that's fun springsource application
management suite this is more aimed at
big bank than it's aimed at you
personally this involves the provides
ability to monitor production
deployments you get a bunch of metrics
those metrics are exposed at a very deep
level by instrumentation of the core
spring framework and other spring
portfolio projects we do that
instrumentation using aspectj as I
mentioned we are now the leading
commuters in terms of tomcat we are also
the leading committees in terms of
aspect chase spring sources accompany is
really extended quite a bit beyond
spring thirdly if you're a advanced
oracle user you may find the advanced
pack for oracle database of interest
this provides value-added integration to
oracle RAC clustering and also Oracle
XML type handling and Oracle IQ advanced
queuing one thing that we often say is
that Oracle is pretty much the de-facto
standard in the enterprise we see a lot
of enterprises where Java developers are
not taking advantage of the features of
Oracle there are a number of reasons for
that some of them are cultural very
often Java developers really don't want
to work
in a deep level with database features
another is ideological Java developers
are kind of steeped in this idea that
whatever you do must be portable between
databases and the third is ignorance
that very often Java developers simply
don't have the skills to make effective
use of the database if you look at the
second and third they're actually pretty
much the same thing anyone who thinks
that a non-trivial application is
portable between databases is the less
than my view mistaken if you look at the
locking behaviour if you look at stored
procedure support there are so many
things that mean if you have a complex
application it is not going to be
portable I mean I'm not talking about
simpler applications like you know you
can write a shopping cart application
that's probably totally portable but if
you have worked for a company that
actually has spent its money wisely with
seven million dollars on Oracle licenses
your applications are not going to be
portable if they're portable they
shouldn't have spent that much money on
Oracle is they didn't need it so if
you're looking at oracle RAC for example
there are a bunch of things that you can
get in terms of failover so if a
particular node fails you can
potentially retry an operation on
another note if it's idempotent you need
to do that by looking at the oracle
exception and seeing whether or not you
can retry we provide that for you
transparently with the case of oracle
xml processing it's not going to be
completely transparent because you know
you are going to be doing things that
are oracle specific they'll be very much
easier with the Oracle integration that
we provide so our aim is a company is to
provide a complete set of infrastructure
offerings springsource enterprise spans
development and production as does the
application platform and on the
production side we have two Apache
oriented products so we have support for
apache tomcat
and HTTP and we bundle at into something
called spring sauce enterprise-ready
server which is a subscription product
that are covalent division has supported
over many years we also of course
provide training and consulting
worldwide but we are fundamentally a
software company we're a software
company that's obviously making very
very large investments both in spring
development and also in development of
new products like the spring source
application platform okay that's all the
slides I'm going to subject you to so
I'm very happy to take questions I had
some questions about the spring a te and
the dynamic modules do add any support
one problem I mean I've run into is has
to do with provisioning when you're
developing you're saying you know in
your manifest some things you want on
the server you're going to load but when
you're developing you using I don't know
maven or something else like that you
guys got I don't know how do you handle
that do you um yes the duplication
between osgi at development in kind of
build time and runtime is pretty
annoying there are some things that we
do in the platform with that so the
spring source application platform
actually can be provision from maven or
IV reaper in spring IDE I think it may
be supported in spring source tool suite
spring idea itself doesn't have that
much osgi integration we are also
looking at providing additional things
in future versions of the application
platform that you know will make it even
easier I have a question about debugging
so if there's an error in my annotations
or my context files what tooling is
available to help me debug faster if
there's an error in your context files
generally spring is fail fast so
it's pretty specific it will typically
provide you information about the line
number at which the error occurred in
annotations it's there are probably
trying to think about annotation
matching if you had semantically invalid
annotations you would probably get a
message when the container started up
I'm not sure whether or not spring IDE
would give you like gutter errors I
think spring source tool suite probably
does the best way really to validate
your spring configuration is to use the
spring integration testing support this
was introduced in spring framework 1.1
point 1 it gives you the ability to
start up your spring context and test
things like data access and
configuration processing without
deployment to any other environment we
very very strongly recommend that as a
best practice again if you look at the
pet clinic sample application you will
see that in action and that effectively
as a byproduct very very quickly checks
your configuration and you don't need to
deploy to you know weblogic or whatever
you might be deploying on so I strongly
recommend you read the testing chapter
in the reference manual and you know
really that's one of the most effective
tools for debugging your context on the
spring application platform what kind of
services or infrastructure does it
provide to achieve say horizontal
scalability like the clustering that
really do currently the clustering
capabilities of the spring source
application platform are equivalent to
those in tomcat we don't provide
anything in the platform beyond what
Tomcat provides however in future
versions of the platform including
probably the version released towards
the end of the year will be providing
more and more hof fetches
I mean certainly the intention our
intention is to make this a platform
that is highly scalable what's the steep
of rust support in spring respite for
spring will be included as a major
priority in spring framework 30 it's
going to build on spring MVC rather than
spring web services it will be probably
the major feature in spring 30 0 m1
which we should see in probably about
two months time yeah we'll do a raffle
after the fork yukon and we'll also have
an idea intelligent license i had
another question for you um you've got a
lot of good advice about best practices
you know I Creeft resources versus
autowire knows where you get a suggested
book or suggested site that's like the
good parts and the suggested practices
kind of resource ah that's that's a good
question ultimately we're doing quite a
lot of work on the spring community web
properties so we're going to try to
carrying more and more of that
information on the dot org site we're in
fact doing a relaunch of the dot org and
at the end of this week so hopefully
will gradually get more and more up on
the dot org website in terms of books
I'm probably haven't quite kept up with
the books that are out there I think
Craig I mean Craig walls this book is
pretty good and I think his latest
addition is updated for 2.5 when you
found the online documentation of the
excellent so you guys provide so it's
really good if you're building a spring
powered application under plug to spring
source platform I mean you talked about
a virgin conflict will be the project
had two deep
I did so if I'm using a version of
spring will it run on any version of
spring application platform how does
that if you're using as i'm building a
spring powered application like i'm
using a version of spring today yeah and
i want to deploy it to staying
application platform so will it be any
conflict kind of things mom if you're
using spring on the spring application
platform using the shared walk sheds
library war there will be no conflict
with any version of spring so you can
specify for example that you're using
spring two point five point four and run
it on a version of this spring source
application platform that's based on
spring three at although the spring
source application platforms GPL license
GPL licensing of course does not hurt
end-users I think there's a lot of fear
abroad in the java community about GPL
the it's interesting that i think it's a
surprise to a lot of java developers
that seventy percent of open source
software overall is GPL so the reason
that it's GPL is fundamentally we think
it's great that spring framework is used
inside the weblogic application server
for example but frankly we cannot afford
to spend many millions of dollars
building a application server that
oracle can just take I mean Larry
Ellison is on record and as saying that
we're not going to you know pay for
open-source things when we could just
take the code and you know Larry doesn't
actually need more money so you know I
don't see why we should spend millions
more dollars to give Larry Ellison more
money I mean obviously I'm just using
Larry Ellison is as an example it
applies to a number of companies it's
not aimed at a specific company but you
know the fact is that we are providing a
huge amount of code under the apache
license which is available to the IBM's
andorra
of this world and they're using it and
that's great but you know frankly the
spring source application platform
solves a lot of problems that IBM and
Oracle have been struggling with
unsuccessfully for some time and they
can have the solution but they can't
have it for nothing so you know we we're
delighted to partner with them will love
to license it to them in fact Richard
works in business development sir yep
yeah the important thing to note is that
if you are developing applications that
run on the platform you are fine even
Google is fine if Google are running
applications on it doesn't it's not a
problem for them the only problem is
that if you are a software company that
is redistributing a product that you
don't want to open source if you want to
open source it that's absolutely fine
but if you want to profit by
redistributing something that's closed
above the application platform you can't
do it can you expand it a bit more under
task best ruthless aren't you offer
anything more than what Milan offers or
we are using the Milan infrastructure as
a basis to build on so essentially what
we're shipping is based on Milan rather
than extending the capabilities of Milan
itself but we're tying it into for
example providing cheat sheets for
authoring particular spring artifacts
and different Milan tasks that we ship
out of the box to provide spring
oriented benefits the spring source tool
suite is something that we are
developing in a Vancouver office we're
also doing a development on aspectj we
are working with task top the company
behind Milan and in fact we've
contracted them to do quite a lot of
work around the spring source tool suite
so it's very much a collaborative effort
between
selves in the developers of Milan that
product is available free for you know
personal yes you know it certainly
encourage you to get hold of it and
evaluate it great I think maybe we
should wrap things up now and we got a
drawing like we said for q con and also
an idea intelligent license and I'd like
to thank rod from the front of the talk
and we've also got a new representative
back in the back here Jeremy Mason he's
helping us out with the room and going
to make sure we have pizza next time and
the tapings and all that so but he just
started like a couple days ago so don't
blame them this time but next time it'll
all be there so yeah there's a link
again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>