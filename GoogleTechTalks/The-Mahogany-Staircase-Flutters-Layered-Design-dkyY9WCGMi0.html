<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Mahogany Staircase - Flutter's Layered Design | Coder Coacher - Coaching Coders</title><meta content="The Mahogany Staircase - Flutter's Layered Design - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Mahogany Staircase - Flutter's Layered Design</b></h2><h5 class="post__date">2016-05-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dkyY9WCGMi0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you all for coming I'm Ian Hickson
I'm one of the cofounders of flutter
along with Adam and Eric I designed and
implemented a big part of flutters
framework before that I was the editor
of the HTML specification for about 10
years and I worked on other web
suspicions for about seven years before
that and HTML rather the web is arguably
the world's biggest platform today so
working on Ishmael taught me a lot about
what approaches work and what approaches
don't work when it comes to designing
scalable platforms which we're trying to
use now in building flutter so what is
flutter well the high level flutter is a
high-performance cross-platform mobile
application runtime and it's
corresponding framework when I say
cross-platform
I mean that it's designed to enable code
reuse across platforms like Android and
iOS while also allowing applications to
interface directly with native services
so this is distinct from write runs
right once run it anywhere which often
leads to a lowest-common-denominator
problem where new features are only on
one platform can't be used until they're
implemented everywhere in this talk I
hope to cover four topics first I want
to give an overview of flutters main
layers then I want to examine a couple
of issues specifically in the widgets
layer and finally I'll quickly cover a
few reasons why we believe flutter is a
high performance platform so flutters
layers we've explicitly designed flutter
to be a very extensible layered system
what I mean by layered is that there are
several libraries and each one in turn
depends on the previous one so a
framework does not have a privileged
position in this system and anything the
framework does your code can do too for
example we've initially target material
design as our design language but
there's no real reason you couldn't
build another widget set on top of
flutter while still benefiting from much
of the work we've done to make the
material layer fast our lowest layer is
dart UI which is the library exposed by
the flutter engine itself but this layer
you have a raw canvas you have our raw
text layout API you have mojo and IPC
system which we used to talk to the
online platforms
and you have the dart Cory P is like
timers and lists and so forth the
rendering layer which is built on top of
dart UI is a layout abstraction with
this layout but with this layer you can
build a pre of boxes and then manipulate
them dynamically and the tree will
automatically update the layout to
reflect your changes the widgets layer
is a component composition abstraction a
composition abstraction each class in
the rendering layer has a corresponding
class in the widgets layer but in
addition it allows you to define
combinations of classes that you can
reuse finally the material layer uses
the widgets layers composition
primitives to implement the material
design controls so let's visit each of
these layers in turn since I'm a big fan
of trains I'm going to use as a demo
application a wish list of model trains
I want to get here's what I want to
build it has material design check boxes
a material design toolbar it has an
animated material design Inc splashes
when you tap on the roads this would be
pretty easy to write using the material
library it's a lot more tricky to build
from scratch so to keep things simple a
minute set my sights a little lower it's
the same basic layout it doesn't have
the material widgets so to do this in
role dart UI without defining an
abstraction layer we have to manually
calculate each coordinate of this table
it's not pretty cooked so for example we
have to first calculate how wide the
first column should be and then how Y
the second column should be and then how
high each individual row should be where
to put the images where to lay out the
text this is just a tiny snippet of the
code that paints the application the
whole rendering function there's about a
hundred lines of code and it's all dense
math just like this maintaining this
code is a nightmare when I first wrote
this application I didn't have the green
dot checkbox control when I tried to add
it I had to carefully work out exactly
which calculations have to be updated
and which didn't if you were to decide
that each row should have different
padding on the left and right then the
top and bottom you have to go in and
individually tweak every line of code to
make sure you got it right it would take
forever to debug and it just doesn't
scale another disadvantage of this
approach is that without a layout
abstraction you have to recalculate all
these coordinates every frame
this is a lot of calculations that we
really should cache but doing that
without an abstraction layer is even
more fiddly than the math the overall
architecture of the application of this
layer though it's very simple there's
just one function render which gets
called by flutters engine we draw the
application on the screen that's what
the window dot on begin frame called us
and whenever something changes for
example when we get an image back from
the network or when they use the taps of
row we just tell flutter that we'd like
to redraw it and it calls the render
function again you wouldn't want to use
the dart UI layer directly but you might
build your own abstractions on top of
dart UI if your needs were very
different from a typical application for
example if you're writing a game you
might make yourself a game library that
targets dart UI directly instead of
going through our framework that's
actually all that the flood of framework
is it's a set of abstractions on top of
these lower-level api's the drawing API
from this layer is actually exposed at
the higher level ayres as well so for
example some of our widgets like the
check box the material check box and the
material radio button they just draw
themselves directly to the canvas they
don't have any complicated layout to
worry about it draws circle and a dot or
Square and on so forth the next level up
is the rendering layer so the rendering
layer tries to solve the problem of
having to manually compute all the
coordinates of the layout it's a layout
abstraction rebuilding that demo
application using the rendering layer
results in very different code
there's no fiddly arithmetic for one
that's all handled by the rendering
layer the application ends up split into
two parts if you do it at this layer you
end up first with a description of the
applications layout using a giant nested
tree of constructor calls which creates
a tree of render object nodes these are
the objects to have a well defined
protocol for layout painting hit testing
accessibility and so forth and then
whenever something changes for example
when we get an image back from the
network or whenever the user types of
row we go and you take the objects that
were created in the original setup so
for example here is a tiny part of the
tree construction the rendered decorated
box you can see here is what sets the
background of the screen
I haven't shown how it's actually
configured but you would just have a
constructor argument sets the color and
then deeper in the tree we would have
say a render image to draw the little
images of the trains again I haven't
sure so you would pass fit but it would
be an image object that has the pixels
you can see that we keep a reference to
the render image object here we need one
for each train this allows us to update
the render image object when we actually
get the pixels back from the network oh
so this is what the updating code looks
like for the image when we get the image
info object back from the network we
just set a property on the render object
to update it this triggers a repaint
automatically in the background so that
the application gets update the
properties we used for updating the
render objects typically match the
arguments that you would pass to the
constructor the advantage of this
approach is that you can cache the
layout computations and indeed we
aggressively cache the layout
computations in the render layer so in
in our demo application here all of the
coordinates for each row have been
stored so that when we repaint the row
we don't need to recalculate them
whenever you tap a row in this
application the green dot in the first
cell either appears or disappears the
way I implemented this is just to make
the dot invisible without removing it
from the layout this means that when it
appears or disappears we do nothing but
repaint the application we don't have to
redo any of the calculations the
disadvantage of this approach is like I
mentioned there are two code paths so
here's the code that changes the opacity
that I just mentioned the top part is
the initial build and the bottom part is
when you tap a row it's really easy for
this to get out of sync
maybe you update the build function to
have two different parts for the
checkbox well if you forget to add the
second part to the updating code as well
then what might look right when you
launch the application will look wrong
once you interact with it and so forth
this can be really hard to debug it can
be very subtle to figure out why some
things are not working other things are
it's not as bad as
the arithmetic that you have to do when
you're laying this out manually at the
dart UI layer but it's still a problem
one reason you might use the rendering
object layer directly is if you like
this style of programming it's very
familiar to a lot of authors because
it's how things have been built for
years
the web for example has a persistent Dom
Android has a persistent view hierarchy
iOS has AB system object as well you
could also use the rendering layer as a
primitive for another layer written on
top of it for example you could write a
templating language that reads a file
layout and then builds the render object
tree out of it moving up one more layer
we get to the widgets layer which is in
fact built using the rendering layer so
the widgets layer solves the problem of
having to build the tree and maintain
the tree with two different code class
instead of explicitly building a tree
and then dynamically mutating the tree
you just create a new tree of immutable
widgets each time you have an update and
then you hand it to the widget layers
run a function the first time you call
run app it takes the tree of widgets and
create a corresponding element object
for each one and those elements then
each create a render object instance the
corresponds to the widget when you call
dry up the second time it reuse it the
elements whenever possible and if the
elements were used then rather than
creating new render object widgets that
objects we merely update them now that
was probably quite confusing so I'm
gonna go through this in more slow
detail here so here's an example using
some fictional widgets to keep things
simple suppose we have two widgets one
is a rectangle which in this case as if
color to green and one is a circle which
has its color set to blue the types of
the widgets are their shape in this case
and they have properties which give the
color the rectangle widget would have a
corresponding render rectangle render
object and the circle widget would have
a corresponding render circle render
object the render object being from the
layer below now the difference between
the render objects and the widgets is
that the widgets are immutable you can
think of them like literals they
describe the configuration of the render
object but they themselves have noticed
behavior once you create one it never
changes you could create them with a
Const constructor and doc for example if
you wanted a yellow rectangle you'd have
to create a new rectangle with that
configuration you couldn't change the
green rectangle widget into a yellow
rectangle widget this also means that
the widgets are relatively cheap memory
wise they have only their configuration
whereas the render objects are quite
heavy waiting in comparison they have
all their current size their current
position and so forth the render objects
on the other hand are mutable so for
example if you had a render rectangle
with a color you could set its color in
multiple times and change each time you
can think again of widgets as a
description of the configuration that a
render object would have so when you
call run app with this widget tree it
creates a parallel tree of element
objects element objects have a reference
to their current widget which we also
call their current configuration but
they don't really know much about
anything except how to compare widgets
so they also hold a reference to the
render object the corresponds to the
current widget to get that object they
call a method on the widget that creates
an instance of the appropriate render
object class for example our
hypothetical rectangle widgets would
create render rectangle render objects
like this notice that when the render
object is created it's created with the
settings of the widget in this case
green as I mentioned earlier when you
use render objects you have to have two
code paths one to create the tree and
want to configure it well in the widgets
library these two code bars do still
exist they're in method called create
render object and update render object
but they're buried deep in the framework
and you'd only see these if you were
building a widget for a new render
object of your own creation which you
can do next the element looks at its
widget to see if it has a child in this
case it does it has a blue child circle
child rather and then it creates an
element child to handle that child
widget so it creates the element and zit
widget the element the child element now
the second one in the same way as the
first one asks its widget to create its
render object
then the element cooks up the render
object to the parent elements render
object and thus we get our three
parallel trees the widget or
configuration tree the element tree and
the Rena tree the render tree then gets
laid out and painted just like if you
weren't using widgets just using the
renderer layer directly in practice when
you're dealing with the framework you
don't see the elementary it's kind of
abstracted away for those of you who
have played with flutter before the
build context that you see all the time
those are actually the elements just
under the hood now the interesting part
of the widgets framework is what happens
when you create a new set of widgets and
called run app again so let's move our
first tree of widgets up we create a new
tree a new configuration so same types
of widgets rectangle and circle but they
have different values yellow and red
again these are new instances we
couldn't have changed the earlier
widgets to have these new colors because
they're immutable this is what lets us
have just one code path for updating
objects rather than two if we made the
widgets mutable which you might think is
a good idea you know I just want to
change the widget if you made the
widgets mutable it would be no different
than the render object layer so if you
like that strategy you can just use
render objects directly that's what that
is
so let's put this yellow rectangular to
run at first it looks at the yellow
rectangle and the green rectangle and
it's like ah they're both rectangles so
they're the same type of object it
decides they are compatible it asks the
rectangle to the rectangle widget to
update the render object rectangle and
therefore that one is now yellow and
then it drops its connection to the old
widget now that old widget might now be
garbage collected you could also reuse
it you could call run app again with
that green widget it would just mean
that the tree should once again be
updated to show a green rectangle and a
blue circle since the widgets are
immutable by the way that children are
part of the description you couldn't
take that green rectangle and give it
the red circle as a child because the
child is immutable the child connection
is immutable it will and always it is
and always will be the blue sir
the parent-child relationship in widgets
is one way so the same blue circle
widget could be a child of various
different parent widgets this is not
true in the element tree all the render
object rhe okay so continuing now we
have a yellow rectangle is all updated
but we now need to look at the child so
the root element looks at the child of
the widget sees as a same type circle as
they had last time
so it asks the circle to update the
render object and then cuts its ties to
the old widgets and they go away and
then we have our new tree so let's do
one one more of these see what happens
when the types don't match because
that's an important case suppose you
were to create a new widget tree that
had a rectangle which was the same color
as the old one but it had a different
child so a different widget the fact
that has the same color doesn't matter
it'll still update the render object
when asked to I just didn't want to have
to change the colors on all my slides so
the first part goes off exactly like
before we connect the new rectangle
widget to the element we can see that
the same type we asked them to update
the render object and that all happens
we use the connection to the initial
render object next we look at the child
and we see aha we have a new child it's
not the same as the old trial it's not
even the same type in fact so we cannot
use that widget with this element it
also means we can't use that element at
all so we're going to disconnect that
element you have to deactivate it
and then when you deactivate an element
you also detach the render object that
it was managing so all of those bits get
torn out of their trees loop and they're
no longer referenced so they go it but
we could actually reuse those in fact
we have some logic to reuse them in
certain cases but we won't go into that
in this talk so we now create a new
child um
we hook it up to the new widget the new
widget create a new render element
render triangle in this case and the
render triangle gets hooked up to the
render rectangle and now we have a new
trick a new render object
okay so this is what it looks like when
you invoke run app it's a similar to in
the render object level it's a tree of
constructors these objects are all
widgets the configure render objects so
each one takes a child or list of
children or in some cases has no
children like drawimage is a leaf so it
doesn't have a child the main difference
between this and the render object level
is that we just create a new widget each
time instead of having to maintain
references to the previously created
widgets so you'll notice there's no
thing taking a reference to the raw
image so we can update it we just call
the run app again when we have a new
image the problem with this approach is
we have to explicitly call this render
method to call run app whenever our
current description of the app changes
this doesn't escape say you have
hundreds of these objects you don't want
to update the entire tree every time one
image changes so instead we have a
widget we call stateful builder in a
state from from the widgets we've seen
so far in two ways first it doesn't have
a corresponding render object and second
it doesn't have a child it has a builder
callback when it comes time to obtain
its chuckit to obtain its child instead
of just returning it the element calls
the callback and then uses the return
value from the callback as if that was
the child this lets you build your
entire app with one call to run app and
then never have to called run up again
and anything that changes will just
cause the relevant part of the subtree
to rebuild a new set of widgets to
extend our earlier example this is what
the diagram would look like notice
there's no render object connected to
that element in the middle I've also
renamed the elements here to be more
close to their real name so you have
render object elements the ones that
manage render objects and stateful
elements are the ones that manage this
take for builder
the callback which I've drawn here is an
oval with the last return value inside
it is what the state will build a house
it doesn't actually have a pointed
straight to the triangle child child
Richard the rectangle yellow has a
reference to the stateful builder child
so the interesting part of the builder
callback is actually the set state
callback which the Builder callback gets
given as an argument when you call this
sets a callback it causes the tree to
spontaneously rebuild from the stateful
builder whose sets that you caught so
let's do that with this diagram say you
call set state and then the next time it
calls your builder callback you return a
square instead of a triangle well from
that point on it does exactly the same
as it did before you drop the old
widgets because they're not the same
type you create a new element child and
then you create a new render object from
that from that square widget and then
you connect it up to the render object
notice that the rectangle to the top
were not visited in this walk we only
just started at the stateful builder and
we went down we didn't do anything at
the with the rectangles at the top so
I've been throwing this words state out
a lot and probably the time to clarify
exactly what this means state is
anything that impacts how the
application renders there are lots of
things that a state some things might
not obviously be state so for example
user data in the application is showing
a state in our little demo app that'd be
the state of the checkboxes each row can
be checked or unchecked that is a state
that's the most obvious kind of state
there's another kind of state in that
application which I've mentioned before
in this talk which is the images when
you need to fetch an image from the
network you don't have the image
immediately when you first draw the app
and then later you get it the fact that
you have the image
the dimensions of the image the pixels
for the image that is all state as well
so when you get the numerator you didn't
have to update your tree with a new
state in our demo application though
there's actually one more piece of state
that might not be obvious which is the
orientation of the screen actually more
precisely the dimensions of the screen
so when you rotate the phone now the app
has to rebuild and the reason it
rebuilds is some piece of states namely
the orientation changed there's lots of
other examples you could have an
animation current position of the
animation mystic you could have
something that Scrolls its scroll
position is a state the operating system
has tons of state the file system in
fact could be in a way state the other
question is where should you hold where
should you put the state where she'd
hold it well again there's many
different answers to that question so
far in this demo app I've mostly used
the system environment for the screen
dimensions and global variables for
everything else I'll get back to that in
a second but just a recap state if you
want a precise definition is something
that can be synchronously read while the
trees being built and for which we will
be promptly informed whenever it changes
so we can schedule an update over the
rendering once you have that definition
you realize a lot of stuff is state that
you might not previously have thought of
the state okay so if we look back at the
stateful builder it solved the problem
of how to limit how much of the trees
updated when something changes but it
didn't help us with where to put this
state like I said I have it willing
global variables in the demo that
doesn't scale if you have an application
with you know millions of rows of data
and it's all state you can't just have
that all in a global in the global space
so instead of a callback let's make a
separate object to maintain the state
and then we can put the state as a
property of that object so this would be
an object that would be reused as is
when the trees rebuilt in the same way
that a render object is reused something
like this stateful element would have an
object just like it has the render
objects in a render object hadn't stay
clément have a state object now we
could make this even more
if instead of a callback on stateful
builder we had steak for builder just
call a method on this state object that
we provided that way we don't you have
to provide one object not an object and
a callback that would be somewhat more
convenient and that's actually exactly
what stateful widget it's a widget with
an element that holds onto a state
object and much the same way that a
render object widget has an element that
holds onto a render object a lot of our
widgets subclass stateful widget for
example the network image widget
subclass a stateful widget to track the
current state of an image download when
the image comes in a calls set State on
itself in the same way that we had a set
state call back before in stateful
builder and this causes just that little
part of the tree to rebuild in the case
of network image that is literally just
the leaf because network image has no
children so this is the skeleton of a
network image it it will be the state
object the network image state will be
kept for as long as the network images
is able to be synced with the stateful
element so anytime we can reuse a
stateful element we continue reusing the
same Network image state when the armen
goes away so does the state just like
before with the render objects within
the network image stay class you refer
to the config property which is a
pointer to the current network image
widget this is how the network image
State would find the URL of the image to
show for example as you might expect
once you have a stateful widget state
list widget sort of falls out almost by
default so suppose you have a some set
of widgets which you always kept
together for example so you have text
and you won't always put padding around
it in the demo app that actually happens
a lot every time you see a cell with
text in it there's like a 4 pixel
padding all the way around so you might
imagine you want to factor that out so
that anytime you put text in your app
you can just say I want text with
padding padding the text say and then it
would automatically put in the padding
around it so you could use a stateful
widget to do
right you could build a padded tech
state which has a build which returns
this padding and this test and it would
get the text from the padded text widget
this is kind of awkward though because
we have two classes and a bunch of
boilerplate to do what really could be
done with a single function so we need
the widget class since that's what we
put in the tree but if we make our
state's build method simply defer to
another build method on the widget we'd
end up with a state class that looks
pretty much the same any time we do this
we could call it stateless State and
then we could reuse this any time we
make a one of these little templates
just like here and that is in fact
exactly what state lists widget is doing
it is just a widget that has a bill
function on it and then its element
knows it just call its build function
directly so once you have stateful
widget and stateless widget you can make
lots and lots of reusable components
that are composed out of one another for
example if we can have a we can have a
container class that uses padding
decorated box constraining box or so
forth and then you can get all these
effects with a simple order container
and then we can have an animated
container class that combines a timer
and course of set state to continuously
rebuild a container class with slightly
different values so that for example you
can fade a box decoration from one color
to another now when you want to fade a
box room from green to red you just say
animated container you say what colors
you want to say to and from and it just
does it without having to worry about
calling so to take yourself now you
could use the widgets layer directly or
you could build a set of predefined
controls on top of it and that's
actually what the material layer is it's
a set of controls that implements the
material design specification built
using the widgets layer which itself is
built using the rendering layer which
itself is built on top of the tart UI
primitives for example in my little demo
app in the material layer version of it
it has an app bar widget which is called
as you see here and this is just making
the toolbar at the top of the top of the
screen and with just this one call I'm
able to get the
the right shadow effects and the right
fonts and the right alignment and so on
and to do that the app bar class itself
has a hundred line also build function
that uses a lot of other widgets like
size box and container and padding and
column and so on to obtain the effect of
material design app bar with the right
height and the right shadows and the
right scrolling behavior and so forth
the reason you use the material layer is
obviously it's a high-performance high
fidelity implementation of the material
design spec which works on Android and
iOS so if you want to write an
application for Android or iOS or both
and use material design then it's the
perfect fit okay given everything I've
described so far you might be concerned
that flood is going to be really slow
especially with big applications the
three trees I've talked about or
non-trivial we're talking hundreds and
hundreds of nodes and walking trees is
an especially fast creating new object
every frame sounds sounded to me when I
first saw this design horrifyingly
expensive so to close out this talk I'm
gonna quickly mention some reasons why
flutter is actually fast
despite this the trick is that we've
used a lot of tricks there's not just
one answer first we don't actually walk
the entire tree except the first time
it's built all the trees are carefully
designed so that they can be updated
with surgical precision so for example
when the wrong render object tree needs
to be relayed out we actually only
layout the parts of the tree that
changed so if this was just the the
render image at the bottom getting a new
image and it didn't change size we would
only read relay out that one object in
fact we wouldn't even need to real it
out we just repainted I haven't talked
about painting much in this talk but we
have similar tricks on that side we only
repaint the part that we need to rethink
on the elementary side when we're
walking a tree doing update we abort the
walk as soon as we see a widget we've
seen before
so I mentioned before that the blue
circle could have different parents well
say you had say you updated the
rectangle and then gave it a the same
circle we would update the rectangle do
a logic there look at the circle see
yeah it's the exact same circles before
and we would just abort the walk of the
tree at that point since we know nothing
below it can change because of the
immutability of the trees we also make
good use of our knowledge of the
underlying VM
example in dart allocating many objects
in a row is not that expensive doesn't
involve a malloc for example the framix
designs also intended to limit the
number of polymorphic call sites to a
very few well understood places that we
can micro optimize we've worked closely
with the dart VM team and continue to
work with them to improve performance
and to better understand what we can do
to make it even faster we also regularly
measure our performance and if we find
new bottlenecks we work to get rid of
them we're trying now to make this
automated so we can catch regressions as
soon as they happen which will help a
lot and another reason we're fast is
that we try to prevent you from doing
slow things there's a number of features
in our engine that we simply haven't
exposed for example we don't have an
immediate mode text API drawing text is
expensive so we strongly encourage even
at the dark UI layer using primitives
that allow you to cache the text layout
computations and finally one of the
benefits of the design of describe here
is that we can split out the
functionality into tiny little classes
we we don't have one render object that
knows about padding and sizing and flex
layout and stack positioning and so
forth instead we have one tiny class
that knows about padding and one us
knows about sizing children and one
small class that knows about flex when a
small class that knows about stack
positioning this helps make it very
obvious when the code is going to be
slow because there just isn't that much
code in any one place and the ways of
the various classes interact is limited
to well-defined protocols that we can
examine carefully in in the demo app
there was a table tables are actually
very expensive because you have to
remeasure each column and walk all the
different cells and figure out how wide
each column should be every time but if
you don't use a table you don't pay that
cost and that's one of the advantages of
having this very composable approach and
this brings me to the end of my talk
thank you very much for coming I hope it
was there ezel shorten more
informational flutter please do look at
these links in particular the second
link is our dart Docs and we've been
adding a lot of documentation there
recently and I shall now take your
questions and may be answered
if you like also for people who are
remote I'm gonna attempt this slides Q&amp;amp;A
feature that work did work I don't know
what this does but maybe your questions
will appear on my screen I don't know
yes so the question is can we detect
when the Rena tree is being laid out
more than it should
that's a good question it's hard to do
that completely automatically because we
think it needs to be laid out that's why
we're laying it out but we can probably
dump metrics about who is being laid out
which could be up we haven't done it yet
we should definitely fall above them all
look at that yes in the back so the
question is does animation use this
mechanism the set state mechanism for
its animation yes it actually does but
it actually turns out that it's very
fast because the way that you would say
you say you have an animated container
or transitional something you would
create it and you would give it the
children it should have below it and
then inside the animated container it
would say okay you know call me every
time every tick say and then I'm gonna
call set state and in its bill function
it will do whatever it is it's animating
say changing in opacity or changing a
background color and then it would
include as its children the children
that you gave it and so when we update
the tree this ends up being really fast
because we we just start at the animated
container we look at it the the value it
returned in its built function and
that's a new opacity say and so we
update the render opacity and then we
look at it
child and that's the exact same widget
you had last night the one you passed in
to the animated container and so we
abort the walk and so we actually only
walked two belts we walked the the top
element which is the one lips Si and we
walk the one that it build and then we
aborted the walk and so this ends up
being really fast so the question is the
render objects layer when you make a
change to one of the render objects do
we batch these changes and recover yes
very much though we we actually do
nothing at all for say 16 milliseconds
or however long it is until the next
frame is due and then when the engine if
you remember right at the very start of
the talk I showed what it looks like at
the lowest layer you have a a on begin
frame call back when the render when the
engine says okay it's time for our next
frame then we go through a very phased
approach the first we look at the
widgets layer and we rebuild every one
that needs to rebuild and update the
render objects but the render objects
just store the new data they don't do
anything with it yet
then we enter layout mode and we walk
all the render objects that are dirty
and we tell them okay figure out your
new positions your new sizes and so
forth then once we've done that we enter
paint face and we tell everyone who need
who needed to repaint
okay now you repaint you repaint your
paint and then if you have accessibility
turned on we do the same thing with
accessibility but yes it is very much
one of the other separate faces
so the question is is there a
synchronous basically a synchronous way
of reading layer somewhat similar
similar to say in a width in HTML yes
and no so no there is no intentionally
no API to do this at the render object
layer in in the tree that is being
displayed on the screen and that's very
intentional because doing layout is
expensive and you only want to put once
per frame you also actually in practice
end of not needing it very much because
because it's all little composed bits
you can just build a new bit that does
the layout you want so for example the
the material applications have a
scaffold which displays the toolbar at
the top with all the scrolling crazy
stuff that material does like crazy I
mean awesome and puts the button of the
bit of fab that the floating action
button at the bottom right and puts the
drawer there and so forth we just have a
function that knows how to lay that out
and so it measures the children and it
figures out you know how big they are
and it just puts them in the right place
given their sizes and so you don't
actually need to to set something and
then read it and then set it again in
the view however if you did want to do
that you actually could do that as of
relatively recently see Chris here but
Chris just changed our our system to
support off-screen essentially render
object trees that have their own
pipelines and so you could build a
separate tree for sit to layout and then
measure it and then use that to work out
what's going on if you want we have a
question from the audience here and see
if I have this work ah awesome Seth
right here you have advice for when to
use stateful versus stateless widget yes
use a stateful widget when you have
state and a state list widget when you
don't
I don't know that I came in under the
hood they're basically the same thing
the up they're actually not in the
presentation I explained that you can
build a state as we did out of a
stateful widget in practice we have a
slight optimization so that we don't
actually ever even half of the state for
a stateless widget but I mean that
optimization really is neither here nor
there ready yeah the question of where
to put the state I kind of touched on
that briefly in the presentation is it's
a question that I don't yet have a fully
good answer for I have an answer for any
specific case but I don't haven't quite
worked out the way to phrase a general
answer this is I'm just basically said
for the people out of the room that it's
just a question of how you design your
app this actually is a similar question
you have to answer when you're doing
more traditional you know if you were
targeting the render object layer
directly you still have this question
like where do you put your state you
could put it in a render object you
could put it in a global you could put
it in your own model of the app and then
keep hustling around like that there are
various options
with that right so the question is if if
in one of your frames you have some much
more expensive work to do at the same
times you have a running animation will
you be able to notice in the running
animation yes you will be able to notice
in the right image
we haven't actually saw those several
ways you can avoid that one of them is
not doing any expensive which sounds
flippant but actually is basically what
we've done so far we we often find that
you don't have to build the app with
something expensive so in the example
the demo app I could have put in the
green ball and then entirely removed it
and relay out the entire table as if the
ball was in there and then put it back
in when you tap the road and put it back
in and that would be very expensive
because you'd have to remesh every cell
to work out the new table thai mentions
but in practice you don't do that you
just always have the ball there and just
switches opacity from 1.0 to zero point
which is a really efficient change so
yeah like I said flippant answer but you
know that in practice is actually much
more effective than you might imagine
the other answer is so again we can use
the the fact that you can build a second
tree separate from the main one that's
being rendered this is completely
hypothetical at this point cuz this
little code literally only landed like
less than a week ago and hasn't been
used by anyone yet but in theory you
could imagine putting the new tree in a
separate isolate and then somehow
transferring that information over we
haven't built that yet but that is
something we looked at very very early
on in the project back when we were
still using javascript is the language
is how can we make layout by the time we
looked at you make layout entirely
asynchronous so that it's interruptible
so you're halfway through relay I'd you
like it's time to draw the frame okay
well we haven't laid out as part of the
table yet but whatever we'll just paint
what we have the design we had at the
time doesn't work in practice because
you the overhead of having everything be
asynchronous is so high
that end up missing every frame but in
principle you could do something more
coarse-grained than that it's something
we need to explore yes oh yeah you asked
about reaping boundary and reaping river
so we haven't I didn't talk about
painting much earnest in this talk but
yes so repaint better I described the
three trees the render object tree the
elm tree and the widget tree we actually
have even more trees than that on the
right I guess of the render object tree
you have a paint tree and on the right
of that have a layer free like if you
already have a paint tree you have the
render object where you can generate a
layer tree the repaint boundaries are a
way of saying okay I want this subtree
of render object nodes to get painted to
one canvas and make that canvas separate
from the the canvas views for the parent
I guess I should take picture in the
canvas and so if you have something that
is animating very fast then you could
like say you have a strong list you have
a complicated application and then in
the middle of the application you have a
list that Scrolls when you repaint your
scroll list you really don't have to
repaint the application on the outside
so you can put a repaint boundary around
the list and now when the list says I'm
dirty I need to repaint we only repaint
the list and then we reconstruct the
scene using the previously painted
picture for the outside and that's much
more efficient and in fact that is what
our list widgets do they have a repaint
boundary around their outside and they
have a rethink battery around their
inside and so when you move the list up
and down we actually don't repaint
anything all we do is shift the picture
of the inside a little and maybe repaint
and you row the bottom if you want the
new ones a label sounds here but I'm not
sure
I don't know how much detail good all
right yeah so we have a bunch of
debugging tools if you go to flooded or
IO there's a link to a debugging page
which talks about a lot of them although
we've added even more since then I
haven't been documented yet
and one of them is this tree Bank
rainbow and the repaint rainbow will
draw a color mask essentially over every
be a layer that is painted and any time
it is painted it changes the color
slightly and so if something gets
repainted a lot you'll see that color
cycle through really quickly and so if
you have a part of the application you
know should never change like say the
tool bar and you don't load your app and
you see its color cycling a lot like I
know I should put a repaint boundary
around this we also haven't I don't
think anyone's ever used this to figure
out anything useful out of it but you I
would love you to look at it we have
metrics now that get dumped in the in
the render tree dump there's a function
called dump render tree debug dump
render tree which dumps the entire
description of the tree the render
object tree and included in that for
every render repaint boundary is metrics
regarding how often how often the
boundary was useful so how often its
parent was painted and it wasn't or its
child was painted in its parent wasn't
versus how many times both the parent
and the child painted at the same time
and so in theory I can help you
determine like is this repaint boundary
useful or is it just wasting memory I'm
just going to do some of these online
questions since we have more here are
there any language features the dart
could add to make our rendering layer
animation code faster probably that's
probably a question we should take off
flight I don't know if any wouldn't be
up say yeah or Adam Adams been working
on this
yep so the question is how have we what
are the experience being with garbage
collection this is something of a moving
target is my understanding the dart team
is moving to a concurrent garbage
collection models all right yeah
Adams nodding don't think that is a yes
right now garbage collection can
sometimes be a problem you will if you
have a long-running animation you'll
sometimes see it stutter as a garbage
collection to happen but we're we're
looking at various changes so we're
looking at like I said concurrent
correlation we're looking at making
smaller garbage collect these sweeps
more often right now the VM apparently
is being more optimized towards server
type applications where it doesn't
matter is not yes so we're very much
looking at we're very aware of that
problem and we're we have plans to deal
with it we haven't finished dealing with
it yet one more question here is in
flutter animation and gesture detection
they're both treated as widgets the same
way as concepts like layout and rendered
views why are all these different
concepts grouped together in the same
category why not I guess yes sir we once
you once you build the once you have
this this stateless widget and stateful
widget concept it ends up being very
easy to describe anything that affects
the tree geometrically in the same way
so accessibility so gestures and so
forth animation they will affect the
tree in the same way so this is it's
more a matter of convenience I think as
a way to describe it
yes
yes so the right I didn't talk about all
the layers in the layer diagram we
actually have more layers than I show
between the dart UI layer and the
rendering layer we have an animation
layer and a painting layer the animation
layer is just about how to manage your
timers essentially and how to convert a
ticking clock
into a varying value of any type it's
very in color or variable double and
then the painting layer on top of that
actually might not be on top anymore
might be next to it now
it's about convenient primitives for
painting boxes and pictures and so forth
and then the rendering layer is built on
top of those and the widget layer also
reuses both of those so the widgets
layer really the way to think about it
is a way of combining features that are
below so it combines the animation logic
and the render object logic and the
painting logic into reusable components
that's really the way to think about
right so the question is how would you
approach integrating 2d physics say into
layout based on 2d physics into this so
there's actually several ways to do this
we have a library called photo sprites
that actually immigrates with box 2d and
the way it does it is it basically has
an adapter from the render object layer
to its own cuz its own world if you like
and then within its own world it can do
whatever it likes you could also
approach this by the the render objects
light is very flexible in terms of how
it configures things for example it
doesn't actually have intrinsically an
opinion about what coordinate system you
use so all of our render boxes our
render boxes and they have an opinion
that your using Cartesian coordinates
but render box is actually just a
subclass of render object and render
object could do other things and so you
could subclass render object a friend of
physics and then
things based on on physics in that way I
wouldn't want to pontificate on exactly
what approach is the best from a podium
one last question from the back here so
the question is do we in contrast to
Android do we have built-in support to
avoid overdraw it's built into some
level you have to opt into it you have
to explicitly say this is the part of
the tree I want to avoid repainting
separately from this other part of the
tree or together with the other part of
the tree some of our built-in widgets
like scroll rules take care of that for
you for the obvious cases but if you
create your own new widget then you have
to worry about that yourself but
hopefully we have tools that let you
detect when that happens like the
repaint remote we mentioned earlier and
the metrics are now in the tree okay one
last question you noticed the gap in my
talk so the question is how do we handle
child lists essentially at the widget
you'll notice all of my examples
carefully only had one child we have yes
essentially we try and do something
slightly clever there we only do it at
one well we have two separate answers to
this the first answer we only do one
level at a time so we look at a single
child list and we compare it to the old
child list and within those child lists
we try reasonably hard to keep things to
find matching widgets and reuse them
where possible because yeah there's a
huge game to be ad from if you remove
one thing from
everything else is the same you don't
want to have to pay the cost of relaying
out everything on the list you just want
to remove the one thing and so what we
do is we walk the list from the start
then we walk the list from the end and
then we eventually find okay we all the
leading ones are the same old trading
ones at the same thing we have the
middle ones and then we like walk down
the list and work out okay so you know
can we skip this one skip this one okay
we you can help the system a lot by
giving each widget a key which I didn't
talk about it all in the talk but every
widget takes a key you could you can
give a key which is basically just an
arbitrary object we just compare
identity you can give you two edge of
the key and that will help us a lot in
figuring out okay these people are all
the same these widgets all the same we
can keep them in sync the other answer
we have is so we have this concept of a
key we also have this comfort of a
global key the global keys are much more
heavyweight key you can only have one
widget in your entire system at a time
that has a particular global key we
track where that widget exists at any
one time and if you reuse the global key
like if you build your tree take out an
object from this place that has a global
key and at the same in the same frame
put it in here with the same global key
we will notice this and we will try and
reuse as much as possible of stuff we've
covered before in the new place I
haven't looked at how much that gains
you from a render object Spector's by I
imagine you could probably skip a lot of
layout I don't know if we've tested this
actually works what we have to say okay
bits so yeah that that yeah answers that
we don't do tree diffing we haven't
actually found we need to we don't you
know we don't look multiple levels that
we did look briefly at doing that and
that gets really complicated really fast
so if you're going to be changing if
you're going to be removing nodes and
then rebuilding everything below it we
just put a global key at the top of the
subtree that gets reused and then your
Evon just wanted to have 15 seconds here
to answer the question about GC the
eventual plan is fully concurrent in GC
currently we've had we partially
concurrent with they stop the world
parallelized alright thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>