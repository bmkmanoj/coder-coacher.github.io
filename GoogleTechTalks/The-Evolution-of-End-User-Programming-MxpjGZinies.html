<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Evolution of End User Programming | Coder Coacher - Coaching Coders</title><meta content="The Evolution of End User Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Evolution of End User Programming</b></h2><h5 class="post__date">2010-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MxpjGZinies" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is jimmy lin i work here at
Google
and I'm happy to introduce Alan cypher
from IBM Research the almond in lab in
San Jose Alan's been working on end user
programming and intelligent agents for
quite a while before at IBM he worked at
Apple and some of the work that he
worked on that Apple he then co-founded
a company called stage cast and so today
Alan is going to talk about end user
programming how the field has evolved
over the years thank you thanks Jimmy so
in this talk I'm going to give an
overview of end user programming but
what I'm particularly interested in
talking about is how the web has really
changed end user programming because
it's overcome some of the big
long-standing obstacles in the field and
so I want to show you some results of
some new research that's being done it's
real interesting in the area so I'm
going to start with a brief history of
end user programming and then I want to
answer the question of why would end
users watch a program and I'm going to
do that by giving five examples of
practical tasks that ought to be
amenable to end user programming and
then I'm going to talk about the two
main approaches that have been used to
end user programming and what the
obstacles have been and how the web is
really removed some of those important
obstacles and then I want to talk about
a couple of the new research systems
that I think are very interesting in the
area
so to start with the origins of end user
programming the first end users appeared
on the earth in 1980 and at the time I
was a graduate student and I had a
friend in comparative literature and she
did her thesis on punch cards now
anybody here who's under 30 probably
doesn't appreciate the fact that if you
use the typewriter and you decided to
add a paragraph to your thesis you might
very well have to retype the rest of
that chapter and this alone was
motivation enough for somebody who loved
literature and had no interest at all in
computers or programming this was enough
probation for her to learn how to use a
computer so that was in 1980 and then in
nineteen eighty-four when the mat came
out the notion of computer literacy came
with it and what that meant was before
that time anybody who used a computer
was a computer programmer but starting
with the Mac there were these people who
when they use a computer their use of it
meant learning how to use the direct
manipulation a patient's that came with
the program so when I talk about end
users what I mean is people whose use of
a computer is constrained by the
standard applications that are available
with that computer so that started off
being things like Word and Excel and
then there were programs like Photoshop
and itunes and skype came along and as
well you now have mail instant messenger
google news programs like that and also
web sites like eBay or Kenneth Cole and
that is what end users do is they use
those standard applications so given
that these are end users why is it that
those people might want to program and
there's really two main reasons for that
the first is that
inevitably you start having these
repetitive activities that are very
boring and you wish the computer would
just help you finish them and also
people have idiosyncratic needs this has
been lately characterized in terms of
the long tail which means there's a few
things that everybody does and so it's
good to have people write a program to
do those things but there's just
billions and billions of things that we
do that are particular to us that nobody
is allowed to write a program for that
the notice situational applications is
similar in that you have a need right
now for something that you need to use
for a week or so and then after that I'm
done and then the final thing is that
even if you have a standard application
to do the kind of task you're doing you
might have these special needs that the
designer hadn't thought of and so you
have to use that tool in some way that
was not intended okay so this comes to
the notion of real why is it that we
have this field of end user programming
and simply stated is that you have these
end users who inevitably get these
idiosyncratic repetitive tasks and they
would be willing to do a certain amount
of additional effort to have the
computer help them automate these tasks
but these people are not willing to
learn how to program and so the goal of
end user programming is to find
easy-to-use tools that will let these
people get some of the power of
programming without having to become
programmers themselves so now i want to
give five examples of tasks that are
sort of things that ought to be amenable
to end user programming and these are
situations that are practical situations
that can come up in everyday computer
use where you is the end user wish that
the computer would help you perform that
task and since these examples really
always do seem to be idiosyncratic I've
picked five actual examples that have
been cases where I wish that I could
have and you
programming so here's the five task i'm
going to talk about saving with version
numbers calculating costs of cable
railing paying my monthly credit card
bill getting hotel information and then
adding calorie information to recipes
and in fact i didn't care about the
calories but i did care about the
saturated fat okay so the first example
is saving with version numbers now
whenever I'm creating a document I like
to save it off with version numbers
because of with experience I find every
so often I do something that's
catastrophic enough that i wish i could
just back up and use an earlier version
so let me give you an example of how i
do that in microsoft word word doesn't
have a safe with version numbers command
so i have to do it by hand i say that
then go to the end of the file name and
increment the number so that's an
activity that's a repetitive activity
that i do all the time now the second
example is that i had to replace the
railing at our house and I'd seen these
cable railings and thought that might be
a nice way to do it but I thought they
might be kind of pricey and I really
didn't know if it was something that I
would think was too expensive or not so
I wanted to get a rough idea of how much
they would cost and part of the problem
when I started looking into this is
there's lots of different fittings and
ways to make a cable railing and they
all have very different costs that they
calculate in different ways so it was
really hard to tell which way would be
appropriate the third example is paying
my monthly credit card bill so every
month I go to the web and look at my
bill and then after I see that the
expenses are okay I schedule an
automated payment and you get to pick
the date when you want the payment to
happen and I always pick three business
days before the due date so what I would
really like to do is press one button
have it show me my bill for the month
then I look over the bill see the
charges okay and then i press one more
button and i'm done why should I have to
do any more work than that it's a very
repetitive activity and it's the same
every time the fourth task was a couple
years ago when Kai was in Florence I
wanted to find a hotel that would be
good and there's quite a few sites out
there that have lists of hotels so I
would go to these different sites and
what I would do is I actually made a
word document and I would copy and paste
information out about these different
hotels you know the name the location
cost maybe one or two of the reviews
from people have been there now this is
a case where you certainly can't get one
button that will automate the entire
task for you but there's so many parts
of it that are repetitive it would be
nice if the computer would help me with
the really repetitive parts of that task
and then the fifth example is adding
calorie information to recipes and these
are situations that are commonly handled
by mashups and the idea is that the
information is readily available I have
all these recipes on the web and there's
sites like calorie king that have all of
the calorie information for every item
in those recipes but I would like to
have it easily combined so that whenever
I look at a recipe I can see the
calories next to the items and see what
the total calorie Cosby so now the
question is given the tools that we have
in end user programming how well can we
do today in solving these end user
programming tasks and what are the
challenges that make this hard to solve
so let's look at the save with version
numbers problem in fact this one is
quite easily solvable pretty much I have
a program called quick keys that I use a
lot on my computers that lets you record
the individual actions that you perform
and make a macro out of them so that
when you press a key it performs those
actions so
I recorded the sequence that I showed
you and you can see here are the steps I
picked the save as menu item and then I
had to add a pause to make it actually
work and then it recorded the next
command which was I typed the right
arrow key that moves to the end of the
line and then I press the Delete key and
well quick keys actually doesn't know
anything about numbers at all those are
just characters there so it doesn't know
that there's a number to be incremented
so I let it delete the last character
and I by hand add 1 and type in the
correct digit and when i get to 19 i
have to do an extra delete to change it
to 20 so this is actually a good example
of what we call mixed initiative
programming which is one of the
solutions and use and end user
programming and that is that a tool can
be helpful to you even if it doesn't
completely automate the activity if it
does most of the activity the mixed
initiative means that you do some of it
in the computer does some of it and so
the two of you together end up getting a
complete solution that's better than not
having the help at all so let me show
you after I've made that quickies macro
here's what happens when I press ctrl s
key that I assigned it to
and then I type the extra did it at the
end
yeah one thing that I wanted to mention
about this example is I talked earlier
that this idiosyncratic use of an
application is one reason for end user
programming and this is a case where
you're the people who designed word they
put a lot of features into it and they
could have had a safe with version
number two and they just don't happen to
have it so when they thought about the
needs of their end users they didn't
consider this one idiosyncratic need
that I have and so I ended up having to
do that myself and it's also a good
example of what Don Norman has referred
to as bridging the Gulf of execution and
the Gulf of execution is there's a task
I want to perform the computer doesn't
perform that task I have to find some
way using the tools available in the
computer to get it to do the tasks that
I want it to and the challenge that we
see here that makes end user programming
hard in this case is we need to know
some semantics in this case just simple
semantics about numbers that our system
doesn't have so now let's get excuse me
to the second problem the cost of
calculating the cost of cable railing
this one has a rather a well-known
solution which is to use a spreadsheet
and in fact that's what I did in this
case that's the spreadsheet that I made
to analyze five of the different ways
that you could go about putting together
a cable railing and find out how much it
costs and in order to do that I put in
some formulas like this so i used floors
and conditional statements i know how to
use the dollar signs to get some of
these equations to work right and then i
do lots of adding and multiplying but
when you look at that solution you have
to say my god what a geek can you
imagine you look at the people in this
audience might be this you know the
entire collection people who'd be
willing to go to that effort to solve
this problem I mean anybody else could
very easy have said well you want to
know roughly if you can afford it so I
have 75 feet of railing there's 10
cables on each one
and then there's in each section is
going to take 20 connectors so you know
in about 15 minutes you could get a
ballpark figure for it so part of what I
want to mention with this example is
there's different classes of end users
and some are willing to be you know do a
lot more geekier things than other one
and in particular with spreadsheets
spreadsheet programming it's one of sort
of the mainstays in end user programming
but I just want to caution people that
it's a very special case it's different
from every other kind of end user
programming so first of all a program
like Excel is actually a development
environment for creating programs you
know you're using the tool actually to
create programs and the other special
thing that's important is people who are
using spreadsheets are doing
mathematical things they're doing
mathematical calculations so a solution
that involves typing in formulas may
very well be appropriate for this end
user audience but what constantly
astonishes and annoys me is that people
in end user programming then think that
this is applicable for other end user
audiences and I think there's really no
other end user audience where it's
appropriate to give them formulas like
that and think that that counts as a
solution for non-programmers ok now the
example of paying my monthly credit card
bill this one I'm currently working on a
system called Co scripter at almaden and
it is pretty good system for solving
this problem so co scripter lets you
record actions like a macro recorder but
its programming by demonstration in that
it's able to abstract the solutions and
do more than just do a literal playback
of what you're doing so when I recorded
one time my process of paying my monthly
credit card bill I was able to make a
script out of that that automates the
entire process except for one of the
steps so I can pretty much press the
button look over the bill press the
button going to be done there's just one
step where I couldn't quite do that and
what I wanted to point out here is how
this differs from a macro recorder in
this particular system for wachovia when
you pick which account you want to use
in the pull down menu they add your
current balance to the name of the menu
item so you have to do things like say
select the item that starts with rather
than selecting exactly that item and
then also we have variable so you can do
things like you can put in an
abstraction of you want to pick the
current month out of the menu and those
are things that typically you can't do
with a macro program and let me show you
the one step that the program isn't able
to do as I told you I like to select the
due date as three business I want to
select the payment date as three
business days before the due date and in
this program it brings up a little
calendar widget like this and there's a
blue square on the due date so i would
like to i would go in by hand now and
click on the 26 in this case and while
I'm here talking about co script i just
want to give a bunch more example of the
sort of tasks that end users might want
to do i have a script for reordering ink
for my printer I have one for sending
email to my representatives in Congress
which is very useful and I've been a lot
more vocal lately and then I have one
that every month I like to download my
amex accounting to quicken and then to
give you some ideas of the kinds of
scripts that are it's nice to share with
other people opting out of a credit card
offer there's a site in a way to do that
now even though I created that script
I'm only going to run at once but it's
nice to make it available to other
people the same way there's a way to get
this IBM flu shot coupon which is
incredibly torturous but once since I
recorded doing it once then it's easy
for other people to do it once i love
using my script for this Southwest
Airlines boarding pass be
because they assign your seat position
based on how when you sign up for it so
I run this like one minute after the
time is available and then I have a
script for forwarding all my phone calls
to home because we have these voice over
IP systems so these are things that are
useful to a lot of people then to get to
the fourth example about gathering the
hotel information this is another case
where there's new work in end user
programming research that really solves
this problem very well mirrored on Shiva
has this program called web summaries
and it's neat because almost like
spreadsheets this is like a whole
different genre of user activity that
came about with the web so the fact that
you need to do information gathering is
are prevalent activity on the web and
she came up with a very neat solution
that that addresses us and I want to
give you a short demo showing how that
system works I think I have to let me
run this by I'm going to run a little
video here and it doesn't have a
soundtrack so I'm going to be the
soundtrack
it's not on your screen let me see if I
can
I once spent too much time tried it
ok
and
okay so you see there's a little toolbar
up here that's the web summaries toolbar
and she first clicks on this button and
now is going through on this sample page
this one example of a hotel and marking
all the different items like this is the
name of the hotel this is the price this
is the address and after she's done that
the system puts together using a little
template that she has of all that
information that she's collected for
this one hotel site but now she's taught
it where the hotel name of the address
are on this hotels com site so now when
she goes to a page and sees a different
hotel that she's interested in she can
just click the button and have it use
that template that it's already formed
sonos get the information and it does
this entire information with that site
all at once and then even better now
that she knows how to handle hotels on
this site she can go to this list and
just click on the links of sites hotels
he's interested in and without even
navigating there herself the system will
go off to all of those pages and grab
the information and put them together so
it really is a very nice solution that
automates the part of the task that can
be automated
and the fifth example that I had was
adding the calorie information so doing
a mash-up and there are lots of tools
out there now to do mashups and they
have different levels of being usable by
end users but to me what's most
interesting about this problem is the
challenge that I've got these different
food items and I want to find them on
another website and there's this
wonderful program by Alex Fabe org he
did these programs called creo and Miro
and he does the rather amazing to me new
part of this task that could never have
been done before which is when he goes
to a web page he'll highlight in red all
the parts of that web page that our food
items and the way he's able to do that
is by using concept net and concept net
is this system that is a semantic
network that people can add to at any
time and it knows things like the
coca-cola is a beverage and it knows
that beverages or food items and so this
opens up a whole new area of working at
use a program that no one was able to do
before although it's very early work
this area really is sort of changed the
whole environment of doing end user
programming ok so with those five
examples in place I now want to talk
about the two main approaches that are
used to end user programming and the
idea here is programming is
fundamentally a hard thing to do and so
there's two ways that typically people
of in research have been going about
trying to solve it one of them is using
scripting languages and the other is
using programming by demonstration so
here's what what is it about programming
that really makes it hard and why is it
that conventional programming languages
that for most end-users they're daunting
and they're unappealing and basically
the answer is that programming is
indirect and it's abstract so if I want
to do something like tell the computer
to click the button all you have to do
in javascript is say
the event dot in it Mouse event and then
supply the correct 15 parameters to that
now that's very indirect and remote from
clicking on a button and it's obscure
it's unforgiving the details are
abstract and its really only indirectly
related to the simple act that I'm
trying to do so in engines are
programming how do you go about dealing
with that problem and there's two main
approaches the first approach of
scripting languages says look the power
of programming comes from this ability
to abstraction and the way you do
abstraction is by using language so
we're going to have to have a language
and we're going to have to just accept
the fact that it's going to be indirect
but given that let's see what we can do
at least to make the languages little
simpler and easier for people to use so
generally this camp of researchers are
people who aren't really overly focused
on end users they just care they just
think programming is hard and they're
trying to find other ways to make
programming easier so this includes
people who work on like kids programming
and also there's just lots of people who
are trying to take standard programming
languages and try to make it a bit
easier to use them here are some
examples in the web domain of scripting
languages greasemonkey is a tool that
doesn't make the programming part any
easier but what it does is it gives it
you as an end user or at least as a user
access to the content of web pages on
your computer so that you can use
javascript to modify the content of
pages that you're looking at then a
considerable improvement over that is
the system called chicken foot out of
MIT and what they do that's very neat is
they make it a bit easier so they have
commands like click and replace which
makes a bit more natural but the real
innovation here is they let you refer to
objects on the screen by using what a
person would call that object so for
instance they'll have a button in the
call it to submit button because that's
what the text on the button is or maybe
it's in at eight
and the label is to the left of it but
they know that a person would use that
label to preferred the button and that
makes it much more usable for end-users
you don't have to know the XPath to that
button for example and then the system
i'm working on co scriptor takes the
idea behind chicken foot farther and
tries to make a scripting language it is
just easily human readable and so both
records that and makes this language
that people can both read and the
computers can execute it so then the
other big camp of solutions for end user
programming is programming by
demonstration and the idea here is that
if you as an end user know how to
perform a task by hand yourself then
that's pretty close to writing a program
for it so what you do is you turn on
this recorder and you demonstrate to the
computer how to do the task and then you
let the computer make the abstraction
for you and infer what your intent was
when you perform those specific actions
so this is much more an artificial
intelligence approach you know it's not
going to work all the time but the idea
is if the computer can guess a solution
and present it to you it's so much
easier for you to just verify say yeah
that's it and it's more it's just a much
easier way for people to create and use
their programs because they are dealing
directly in the interface and they're
not going to this abstract indirect
language the big limitations this isn't
as powerful it can't do as many things
as a scripting language but it really
changes the notion of ease of use very
dramatically so what are some of the
challenges that have kept end user
programming from being really widespread
and successful one of them is that
there's a limited audience so it's
limited for several different reasons
the other is this notion of inferring
the users intent that's just clearly
going to be a hard problem and the third
is that you don't have semantic
information available that you really
need to
make that to be successful doing this
task and here's where I get the part
about what's changed with the web now
the reason the audience was limited for
end user programming systems is it used
to be that anybody who did research in
this area had to use toys systems in
limited domains and that's really
changed because of the web browser in
particular because the Firefox browser
has completely changed that equation a
second notion is that you would used to
have end users who were sort of scared
and timid it was hard to get them to try
any tech technique like this and end
users now are different from the end
users in nineteen eighty or even in 1990
and it also used to be hard to share
your solutions but now that end users
are so used to creating user generated
content and putting on the web it's
overcome this problem so now there's a
lot more motivation for why people would
want to do and use a programming because
other people can use it so let me go
over these steps in a little more detail
back in nineteen eighty eight in witten
wanted to do some end user programming
programming by demonstration and he
wanted to do it in a domain of text
editing well at the time all text
editors were proprietary closed systems
so in order to test out his ideas he had
to write his own text editor that had
recording and script ability in it so
not only does that give you the problem
that you're spending all your time
writing a text editor but it also means
that in order to test out his system he
could bring in two friends who would sit
in the lab and try it for a week and
that's how he would get his results and
after the end of that then it was done
and nobody used that program again
another problem is that even if he had
gotten a great solution in that it
wouldn't work for text editing say in a
chat program or an email program those
are all separate applications that he
hadn't automated so in 1993 researchers
did understand that a group of people
came up with a system for application
independent
environments for doing programming by
demonstration but you had to use their
tool which means you actually had to
write in small talk and again you know
it wasn't a successful solution but it
just shows how you know in 93
researchers were aware of these problems
but they didn't have any way around them
and that all changed with the Firefox
web browser so now you've got an
application that is actually being used
by real people in their daily lives
millions of people and there's many
applications that are on this it's sort
of like an OS now that there's many
different applications that run on this
one platform and the most important
thing is that there's an extension
facility so that people who are doing
research in in this area and other areas
can write their extension and make it
work in the Firefox program and have it
be usable by millions of people the
second thing this changed is end-users
and that's really not a function of the
web it's really just fortunate timing so
what's happened is that the people who
use computers now are very different
people in particular I have a nephew
who's 10 and he does not remember a time
when he didn't know how to use a
computer he would sit down at a computer
and use the mouse and pick items out of
menus before he could read and before he
knew what those menu items met so if he
sees a new application and there's some
menu item that he doesn't know what it
does or a button he doesn't know what it
does he clicks it and sees what happens
and in you know 10 15 years ago and if
you look at people over 40 today they're
afraid to click some button because
something bad might happen and they
don't know what it is and those users if
you work in an area research like this
you might just like not worry about them
anymore because then I could be around
that much longer and there's this whole
new generation that you can appeal to
those to be ready and willing to use
your tools and then the other fact that
people
using computers now are very comfortable
using youtube and wikipedia and other
sites where they put up user-generated
content and there's a site called
userscripts org for grease monkey so if
we do get tools that are easy enough to
use for making scripts it's now trivial
and easy for you to share your script
with other like-minded people and that's
a real additional incentive to why you
might go to the extra effort to make one
of these scripts and bonnie nardi looked
at spreadsheet users many years ago and
show this affect how you get a whole
range of people with different skills
forming a community and there's some
people who are the geeks can do the
really tricky part and then there's
others who mainly just use the tools but
by having a whole community it makes use
of the tool a lot more successful so the
bottom line on this is that the path
really is clear now for large-scale
adoption of end user programming it's
just a matter of making the tools easy
enough to use so I've talked about this
challenge of the limited audience let's
look at the other two challenges
inferring intent and the semantics so
what's changed with that now that we
have the web well the answer the first
one of inferring users intent is that
hasn't changed at all that's the
fundamental challenge in programming by
demonstration and the two tools that
researches in the area used to solve
that are getting contextual information
and using multiple examples those are
sort of the two tricks that can be used
to try to solve this problem and
nothing's changed there but the other
place where the web has really
revolutionized things is this problem of
having missing semantic and
domain-specific knowledge now all of
this semantic information is readily
available and that really is changing
things so again if we go back to Ian
Witten in 1988 when he did his text
editor this is a problem that he wanted
to solve you have a list of addresses
and saying now you want to add
to your online address book well you
don't know the semantics you don't have
any access to the semantics knowing what
people's names are what addresses are in
zip codes so what you have to resort to
is finding some way to use syntax to do
the best job you can to come up with
understanding these semantic concepts
and I particularly like his example
because these are addresses in Canada
and this gives you an idea of what if
the challenge is to a computer because
when I look at these zip codes I go well
you know is that a zip code let's look
at that one that's like L small j4 does
that count it as part of the zip code
you know who knows so the interesting
thing here is that this isn't just the
challenge for end-user programmers this
is a challenge for every programmer if
you were a professional programmer and
you were going to write a professional
program to import address data you would
have to figure out some way to identify
zip codes and you would probably end up
doing the same thing of trying to find
some syntactic rules that would do the
best you could at finding what was the
zip code but what's happened now with
the web is all of a sudden there are
lots of tools out there that solve this
specific problem there's all sorts of
data detectors being built that are
smart programs at detecting addresses at
identifying things as people's names at
knowing what a phone number of looks
like and data mining has all sorts of
techniques for looking at unstructured
data on a web page and figuring out
where in that is a person's name and
where in that is an address and
microformats or another technique that's
being used to make this semantic
information available to us and also
those websites that do semantic work for
you like calculations on dates that you
can add and subtract from dates and you
can also format dates in many of the
many different formats you want so all
these tasks that used to be really
problematic and
you know people doing research and end
user programming 15 years ago they spent
so much of their time trying to make it
easy for a person to write these
programs that would do tasks like
identify a zip codes and that problem
has really just gone away now so let's
get back to the example I gave we're in
my program Co scripter we don't can't
handle this one step of picking three
business days before the due date
suppose we have recording of this widget
well if you don't really know much of
what's going on when you record the user
clicking on that date it might just
recorded at clicking at this mouse
location in that widget and at that
point that's rather useless information
you can't figure out much from that
there's no semantics there the next best
thing is if you were able to record that
as set the payment date to August 26
2009 so it knows that that particular
square corresponds to August 26 and then
what we would like the best thing would
be from a recording to figure out that
that click we inferred the users intent
and set the payment date to three days
before the payment today and that's
really not an impossible thing to do to
go quickly over these tricks I said of
programming by demonstration the way you
do that is if you have this high level
event of click on August 26 you record
with it a bunch of contextual
information and part of the context of
using that calendar was that there was a
Blue Square which we know is
semantically the due date and it was on
august 31st and now if I have
domain-specific knowledge that i can
take august 26 and i can add five days
to it and know what date that is or if i
have a business calculator and i can add
three business days and end up with
august 31 now you're in a position that
if you get a couple examples of the user
doing this task you can make a
reasonable inference that they're
picking three business days before the
due date
now I want to move to another challenge
that's sort of a rising challenge in end
user programming and that is what's
happened now that we're moving away from
HTML now when HTML came out that's
really what made the web successful
because it was this simple declarative
format but in terms of in terms of user
interface design this was the great leap
backwards you know people have been
making these really nice desktop
applications and all of a sudden you get
a web page and you can't drag and drop
you can't select out of a palette you
know all these things are just gone and
sure it was easy to use but it was
really a miserable these are experienced
you change something on the page so then
you redraw the entire page and there's
no dirty reasons or anything like that
so it it really is a very primitive
experience and you know thank God now
we're getting back to making interfaces
that are richer and smoother and a lot
of that has to do with using tools like
Ajax but in the process this is becoming
a challenge for end user programming so
it's very easy in end user programming
to make a recording that recorded
whatever tag was clicked on and if you
know that it was an a tag you know that
it's a link and you know all sorts of
semantics about it and what's happening
now is in particular because of things
like rich toolkits they give you these
richer experiences a lot of that
information that used to be declarative
is now becoming procedural so it's being
hidden inside some JavaScript program
and as a person doing recording and
trying to do end user programming and
further users intent if it's in a
JavaScript program and it's not
declaratively available means that you
would have to read and understand that
program to know what's going on
semantically so this slow crawling back
to getting rich applications than a web
page is presenting a challenge for doing
end-user program
and to give you one example of that
there's this dojo toolkit which is one
that's used a good bit inside IBM and I
decided to add the information I needed
so that we could do good recording &amp;amp; Co
scripter for all the different dojo
widgets now one of those widgets is
called the forum multi select widget and
that's where you want to get a pulldown
menu you want to be able to pick more
than one thing out of that list ok well
when I went to instrument that this if
you look at the text on the left that's
what that widget actually looks like so
this is sort of true of all of dojo
instead of having an a link or some sort
of tag that has semantic meaning to you
everything in dojo is a div so you look
at it you have no idea what it does it
could be a calendar it could be a
pulldown menu it could be a dynamic tree
and it's actually just a div you have no
idea what's going on there so I was
going to get this example to present in
this talk and when I went back to get it
I actually found this text on the right
which is this select tag so it turns out
in the couple of months since I looked
at that the people developing dojo for
reasons I'm not completely sure about
realize that it would be better to be a
semantically meaningful activity like
select and they put in this dojo type
field that tells me exactly what widget
it is so now all you need is to have one
person go in there and markup this
widget and say the digit for multi
select is this kind of widget here's all
the semantics in it and all of a sudden
that problem is solved the end so there
there is hope available and in
particular it's really interesting that
a lot of this hope comes from the
accessibility field so people doing
accessibility in particular people who
concern about making websites available
to people who are blind face exactly the
same issue there's a div tag out
and for a blind person they need to know
that that's actually a calendar and has
the semantics of a calendar they need to
know that that thing that was clicked on
is actually a date so because of this
need there's a good bit of work in
accessibility about making tools
available so that you can mark up a web
page and add semantically meaningful
information to it in particular there's
this Aria spec which is accessibility
for rich Internet applications and it's
specifically designed so that you can
add semantic information about custom
widgets and another interesting thing is
there's this project that IBM now called
social accessibility and it's a toolkit
so that people who need accessibility
information can request it from this
global community and when somebody adds
this information like marking up on
these widgets it becomes universally
available so there really is a mechanism
in place to start making this
information available and useful so this
challenge that we have for end user
programming it turns out that
accessibility may be the motivation and
a reason by in fact we do get a good
solution to this so just to sum up what
are the changes that the web has brought
that has made has gotten rid of some of
these obstacles to end user programming
the first is the web browser the second
is that end-users are no longer afraid
to use computers we have these
communities available to create and
share content and this very important
fact that now semantic information is
readily available and that one was
really the one that was the biggest
obstacle in angies or programming that
was just seemed insurmountable and that
change is really having a dramatic
effect and so it's very neat to say than
the last couple of years because of this
there's a dramatically increased
interest in end user programming there's
much more research going on in the area
and I've already showed you these two
programmers the web summaries and the
creo systems and I want to talk about it
just a couple other of these really
interesting new systems that point the
way for where end-user
is going to go so one of them is called
tutorials by demonstration and this is
out of mini Shangri wallace group at
berkeley and it's very interesting
because as i will tell you how important
semantic information is this is neat
that it goes in the exact opposite
extreme direction which is it looks at
the pixels on the screen and does
processing with the actual bits on a
screen and this work was done back in
like round 1992 by Richard Potter he
built the first and user programming
system that worked on the pixels on the
screen and if it's a amazing the number
of things that you can actually do
effectively this way and one great thing
about it is it's cross-platform and
cross application it just takes those
bits and does something with them so
it's a very interesting different kind
of solution but what's happened now you
know this this area of research has been
dormant for 15 years what's happened now
is that people like Manisha's group and
also there's a product called sikuli out
of MIT in rod miller's group that are
using vision algorithms and so that gets
rid of some of the brittleness of
working with pixels they can actually
identify something that's about the same
even though the screen resolution has
changed for example and so they're
starting to use vision algorithms to
make this approach really quite
effective and it's very interesting to
see the things that they can do now so
let me run this short demo of the
tutorials by demonstration system we
present an approach for automatically
generating step-by-step visual tutorials
for photo manipulations our work is
inspired by professional tutorials for
digital photo editing such as this one
for changing the eye color and this one
for creating night from day scenes we
start by recording all changes in both
interface state and application state as
the user demonstrates the manipulation
technique here the user wants to change
the eye color in this portrait he starts
by zooming in on the eyes since he's not
sure which tool to use next he has to
read several tooltips
he eventually fixed the ellipse
selection tool and selects the eyes but
his selection is too big and he has to
adjust it several times until it just
covers the iris and pupil
to change the color he cooks on the
color menu and looks through the
available options he selects color
balance and starts adjusting the green
slider he clicks ok where then decides
the green is not quite right he opens
the color balanced dialogue again and
adjust the other sliders until he is
satisfied
our recording includes all changes in
both interface state and application
state as well as screenshots of the
application every time the mouse is
clicked we processes data to
automatically generate tutorials
describing the recorded manipulation
technique first we associated changes in
interface state with the corresponding
changes in application state and
eliminate unnecessary steps then we
group together multiple parameter
updates for each operation finally we
group consecutive operations
the remaining sequence of steps is used
to generate tutorials here's the
tutorial we generated from the I
recoloring recording you just saw we use
computer vision algorithms to determine
that the user was manipulating the eyes
which allows us to generate descriptive
text that says to select the pupils and
irises here in step 2 using our system
we have generated tutorials for several
portrait and landscape retouching
techniques including the ones shown here
okay I'm running out of time but just
one last system that I want to quickly
mention is Margaret brunettes work on
surprise explaining reward and what's
interesting about this is it's opening
up a whole new area a different way of
looking at end user programming and they
call it end user software development
and the idea is that you have all these
end users out there producing systems
and they've research shows that end
users are probably like most people are
inordinately impressed with their
ability to create programs and in
particular with spreadsheets they really
think their spreadsheets work right when
in fact they don't so she's interested
in applying some techniques from real
software engineering to help end users
notice that there's problems in their
software and improve them now the idea
is you don't have a captive audience
when you're doing end user programming
so in order to encourage people and get
them interested in looking for bugs she
uses this technique from psychology
called surprise explain reward basically
the idea is if you can show somebody
something unexpected that'll surprise
they get their attention and that causes
them to be interested so her systems the
work in spreadsheets what they'll do is
they'll analyze the formula this behind
us machine and they'll notice you know
what are legal possible solutions to
some of the formulas in there and then
they'll try to present examples that
give values that they expect are
probably incorrect so for instance if
they notice that there's a cell that's
labeled day of the week
and they can have it turn up a value of
negative 4 that's probably something
that will get the end users attention
having captured them with this surprise
you explain and show them exactly why
this wrong name became in there and then
the reward is that they can then fix
that so to finish up here what's next an
end user programming well I'm hopeful
that what's next is that end user
programming will actually become
prevalent and successful on the web and
I just want to mention that the next
area where and use of programming really
is going to a natural fit is with mobile
computing so when you're using mobile
computing first of all you have very
limited screen size so every pixel is
precious on the screen and it's valuable
to be able to create a custom solution
that just shows the information that you
care about second there's these
impoverished input methods so if you can
automate a task and by doing a single
click do but would otherwise take ten
actions to do it's very worthwhile to
you and finally you have limited
attention because you're busy driving
about your texting and so if you can
have automated solutions that will also
help you get done what you want to do so
my summary is that the web has brought
this great new opportunity for end user
programming we have a different class of
users now and we have all this rich
semantic information available there's
still this challenge that as
applications on the web become richer
it's going to oppose a challenge for us
but accessibility may really be the
solution that will resolve that problem
and finally a mobile computing looks
like the next good area for work and
just to conclude I started collecting
the material for this talk when I was
writing an introduction to this book on
end user programming on the web and the
book is now going to come out in time
for Kai and it's already you can it's
listed on amazon and on Morgan
confidence if you want to check it out
you can get information
okay thank you any questions yeah yeah
the issue about what happens when the
system generalizes wrong that's a one of
the things that I notice in my main
personal experience of programming by
demonstration which is Emacs macros
which I'm not recommending as an end
user example our venues of programming
but nevertheless there's an interesting
thing which I notice about it which is
because it has several different ways to
navigate when I'm in macro recording
mode I know what generalization I wanted
to form effectively so what I do is I
navigate to the destination in such a
way that I know that those navigation
actions abstract over the set of cases
that I wanted to apply to in the K a
good example of the same principle
hypothetically is in your calendar
example if the way I select the date
three day three business days before the
due date might be that if the selection
starts off on the due date and then I
somehow go back three days so I'm
wondering first of all how to help guide
the system to make the generalizations
the user wants how to present the user
with interactions which enable the user
to have an intuition about what those
generalizations are and also when the
system does generalize wrong to help the
user understand what to do to correct
those are all really important points
about issues with end user programming a
few comments on it one thing is when I
did this eager system and hypercard many
years ago the issue of navigation was an
important one so if you went from one
card to another in hypercard you could
do it by clicking next buttons you can
do it by going to a picture of all
your small cars and clicking on the one
you wanted and the way that system dealt
with navigation is you could actually
navigate any way you wanted to and it
would still find the correct pattern
because it had this semantic concept of
navigating and card numbers so it knew
about the first car to the stack the
last the number of cars the next card
and so on and what eager did is it took
more than one demonstration so as long
as it had a few examples that's really
the magic that solves the problem of
ambiguous interpretations you know
there's just a combinatorial explosion
in the number of possible inferences you
could make about what one user action
does but after you've seen the user do
that action three times it in most cases
it comes down that there's really only
one or two that are consistent with
those multiple examples so that's the
general approach that's used and that
actually worked very well in HyperCard
that somebody would navigate in
completely different ways and change
their scheme and it would still detect
the pattern anyway but you know it's a
huge it is a huge problem about giving
wrong inferences and in that same
program I had this great example of what
the problem was so we were doing a pilot
study and it was there were cards where
it was this DaVinci the character the
arms go like this and you're supposed to
animate the arms of coming back down ok
so it's copying all the cards in the
reverse order well this guy who is
trying to solve it didn't know how to
use hypercard he didn't even know about
copy and paste really so he wasn't able
to do it but somehow in his floundering
there was some pattern that eager picked
up on so this little character cups that
pops up and says finish the task for you
guys oh sure it clicks foot and then
it's just flying all right in figure
happy and then at the end his comment
was well I just wish it had goat would
go slower so it could teach me how to do
the task so the point is that you know
here's an end user that doesn't know
what's the state of the art in
artificial intelligence and doesn't know
whether the system can figure out from
your actions that here's really what you
wanted to do and here's how to do
so it's a very serious issue about
coming up with the wrong inference and
what you just do you know how does that
could cause huge problems for your end
users so it is a very real issue but the
answer in general is by if you have high
enough level semantics and you get
multiple examples you can do a good job
and the other answer is you need to have
some way that once you come up with an
inference you have to be able to present
it to a user in the way that they can
understand the inference you made and
the way eager would do that is it would
show you any specific example of the
abstraction in the current context so it
would show you a concrete example and
you could validate whether that was
right or not and that helped a lot yeah
can I ask question yes so there's the
inference problem on the part of the
machine there's also the inference
problem on the part of the human so what
I'm curious about what you're thinking
about the humans mental model of the
agent that's making inferences about the
stuff you're doing such that i can
predict what it will do so for example
you showed the drawing the circles on
the eyes and I was blown away I didn't
believe would be able to infer iris is
in general right so the bigger problem
becomes how do I know what this machine
can do mean you know and how do you
portray what it can do can it do
arbitrary multi language translation I
where do i how do I learn the boundaries
exactly and that's you know that's a
huge problem in this field and with
almost any tool because you as an end
user don't know the extent of its
capabilities like when I built this
system for kids programming this stage
cast there were a bunch of other systems
out there like there were logo systems
you could use there was agent sheets and
if you gave me a prop they're all ways
that you can make simulations and then
have you know interesting things happen
because you build a sim discrete-event
simulator if you gave me a problem you
said you know I'd like to be able to do
this I could tell you oh don't use
creating you should use agencies for
that
then for some other problem eyes oh
don't use agencies for that you know
that you want to i use creator for that
one so and how do you tell people the
capabilities your system and you know I
sweat it over the issue for a long time
and I don't know any good answer to that
all i think that's that's a huge issue
and it's also going to be one of the
reasons that makes end user programming
hard to pick up because if you're going
to try a tool it you know the first time
you decide how i hear this tool will
work and help me automate this and you
try it and it doesn't work well you
don't know why but you know you're not
going to use it again you have no idea
if you picked a task that was amenable
to that tool and until we to me i think
the best answer around that is this
social answer that once you get web
sites where people who have learned the
tool and it put in enough of the effort
show you a hundred and fifty examples of
things that can do then you say oh that
you know the tasks that i have to do is
a lot like that and since you can do
that i'll bet they can do mine and i
think that's the best answer is by
having lots of examples and so you know
having the web makes that a much more
feasible solution that it used to be yes
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>