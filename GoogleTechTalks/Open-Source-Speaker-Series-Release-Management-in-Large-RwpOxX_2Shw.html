<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Open Source Speaker Series: Release Management in Large... | Coder Coacher - Coaching Coders</title><meta content="Open Source Speaker Series: Release Management in Large... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Open Source Speaker Series: Release Management in Large...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RwpOxX_2Shw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">next speaker is Martin Michael Meyer
previous debian project leader
contributed to the debian QA effort he's
recently finishing ba he's now finishing
up a research into release management in
large free software projects and today
is going to give a presentation on his
research findings please welcome on ok
thanks Andrew the research of I've been
doing about the last three and a half
years is about quality issues in free
and open source software projects and
specifically I've been focusing on
release management I should say that
that work has kindly been funded by
Google the last three years I'm very
happy about that and I'm really happy to
be here to now present the results of
that work which I think really
interesting for the community also I
have to apologize that my voice is a
little bit strange because I've had a
cold for a few days and yesterday my
voice got lost so I'm sorry about that
I'm just looking at the channel of their
talk first of all I would briefly talk
about the background of the research
where I come from and how I was looking
at things then I will introduce the
projects which have studied doing my
research as Andrew mentioned I've been
involved in in debian for a number of
years and debian is known for its
problems with release management but i
didn't focus specifically on debian i
looked at the number of different
projects and believe me many of them
have problems with release management so
i will look at the ED problems which
those projects have had and what kind of
solutions they implement it for those
problems
specifically what I have studied is is a
relatively new release mechanism and
known as time-based releases in the past
usually you would release when a certain
set of features has been achieved or
implemented but nowadays a couple of
projects most prominent our norm are
releasing according to time so they
don't have any specific features which
determine where the release is done but
they they say we are going to make
release every six months and that's
their release strategy and I think
that's very unique and very new approach
and I've decided to study that
specifically because there's loads of
interest within the community in time
based release management so after
introducing the project and their
problems and solutions I will
specifically look at time-based release
management I will I will say why it
works or why I believe it works and I've
looked at different projects and I have
evidence for that and then I will look
at some implementation some specific
implementation details that projects
need to consider which interested in
moving to time-based releases and then
our wrap-up and and answer questions so
the background I started with the idea
of investigating quality in free
software and free software and open
source is being used everywhere I mean
it has been so successful in the last
few years I'm sure you know that Google
I mean it's being used everywhere and
even though it has been so successful
and people are talking about world
domination and things like that I like
to look at the glass of water and for me
it's usually half empty so even though
it has been successful I see there are
still lots of problems and I'm wondering
what can we as a community do about
those problems how can we still make
open source even more better and my
approach is different too many people I
haven't looked the technical details
like how can you improve quality by I
don't know
aggression testing or things like that
I've looked at more the the process side
so how can you improve the development
process how can you and specifically
with release management of looked at
coordination and management it's really
interesting question how can you with
projects large projects which are
hundreds of people all around the world
they don't even know each other in
person how can they work together and
actually produce something that doesn't
only work but it's of high quality and
and another question which is gaining
importance as free software and open
source is being increasingly used by
enterprise by companies how can a team
of volunteers are ensure that the
quality will be high all the time and
that there will be new releases how can
they make sure that companies feel
comfortable relying on on its software
it's as a very big question so I've
looked at at process improvement how can
you improve the development process and
when I started my PhD I looked at
different areas I talked to various open
source developers to see what kind of
quality problems are there and there are
many problems in the end I found
different problems different areas of
interest and I decided to focus on
release management because that seems to
be one of the the most critical areas
where problems are cure the next thing
open source free software there are so
many projects there are large projects
very small projects that many projects
which don't lead anywhere just need to
look at sourceforge which have over a
hundred thousand projects but you
actually see that ninety percent of them
haven't actually produced any code the
question is what kind of projects do you
want to look at specifically and in my
initial research at the beginning I
looked at all kinds of projects to see
what different problems are there and I
found that small projects phase very
different problems with release
management too large projects so in
small projects the problem is usually a
resource problem
not having enough people whether the
problem is not knowing how to make
releases where is in large project
projects the the problem is much more
about coordination how do you get with
like hundreds or thousands of developers
working on the same code base how can
you get those people to finish all that
work at the same time and to get
something out which which is of high
quality and which is on time so for me
from the the coordination and management
perspective this question is more
interesting so I've decided to look at
large and complex projects I'm looking
at projects which are mainly voluntary
and there is a question where how do you
define a volunteer and I have so you
could simply say someone who is not paid
is a volunteer that's one definition but
I think even paint people are often seen
as voluntary because for me it's a
matter of control if the project can say
you have to work on this then you have
control over someone then during release
preparations you can say well you have
to work on this you have to work on that
but with with many contributors who are
paid by a by companies IBM HP Google
they have their own interests so as a
project you can tell them we need to do
this even though they are paid to work
on a project they have their own
interests so they're their voluntary you
can't you don't have any control and
that's the main issue I'm looking at
projects which are distributed because
that's where you see those those big
coordination problems if you can put all
the people into a room and then say you
will do this task you will do that it's
much easier but how do you coordinate if
it's distributed and then I've as I said
before I've looked at projects which are
currently moving or which have moved to
a time-based release management strategy
so those are the the projects which I
looked at some projects all of the
very large very popular you would think
of high quality and without problems
whereas in fact there are loads of
problems which which each of with each
of them and what I've listed here as
well is the current release strategy
that time based release strategy and
when they decided to move to time-based
releases so what is listed here is the
the ideal view so what they are trying
to do I'm not saying that they're
actually doing this so people can say we
we have a six monthly cycle but in
reality takes 12 months but that's
basically what their strategy is so you
can see that quite a few projects have a
six-month release cycle and then there
is the the Linux kernel which I
classifies time-based because there is a
two-week merge window in which new
features are accepted and the rest is
just two for getting that code the new
code stable and getting the release out
which can can take variable time
sometimes two months free mums but still
it's time based because of that much we
know debian is currently moving to
time-based and all of clone is currently
moving you know extra work is recently
moved to you can see that so now I would
go into detail or give a brief summary
of all of these projects for each I will
show that the past release is to show
how often they actually make releases
how much time there is between releases
and then i will look at their past
problems solutions and outstanding
problems so debian you can see that
early on there were quite a few releases
six months seven months but then things
started to slow down and the big problem
really happened with free that one which
was 35 months which was it was delayed
by over over a year and loads of people
complained because the software was out
of date the previous release it wouldn't
install a modern hardware anymore
so what are the the past problems of
Debian I think a big problem was that
the whole release management wasn't
organized if you look at free dot one
there was an announcement from the
release manager saying oh I think we
should do a release in two months and
that's just crazy because people weren't
prepared for that and obviously that
target was met another thing was the
blockers were found very late in the
release cycle and it's again partly
because people weren't prepared and
partly because the release targets and
and weren't really defined very well
because of those delays we had
out-of-date software and because of
repeated delays the the project really
got a very bad image about being slow
but not being able to release and that's
a big problem because users are moving
away so what are the solutions so in
particular during the the release cycle
of followed zero which was recently
released much better release management
structures could implement it so the
project moved from a single release
manager to having a release manager plus
assistance and now having to release
managers and in assistance there was
better infrastructure like a debian
release meaning list and IRC channels so
you could actually talk to the people
and know what's going on for the first
time ever in Devlin's history for photog
warm air follows 0 a release date was
set well in advance so when freedom one
came out the release people said we will
we want to make a release in december
two thousand and six so the project
didn't meet that target but still i
think the whole release process was much
smoother than in previous releases
another thing is that release updates
were sent much more regularly so people
actually knew what was going on which
again wasn't the case in the past and
the project defined released targets so
and they made a division between things
which really had to be implemented
before the release and things which were
goals which were nice to have but we
wouldn't wait for them there was also a
clarification of responsibilities in the
past it wasn't clear who was responsible
for getting work done I for example
porting Debian two different
architectures if there were problems it
was usually up to the release manager to
fix them or to find people to fix them
but now it's clear that the the porters
of that architecture are responsible I
think the biggest outstanding problem is
to to make a cultural shift and to show
that yes deadlines are real and and that
targets can be met and that the project
can release on time so GCC has had a
couple of releases as well in theory
they should make release every six
months in practice it's slower than that
as you can see there should be a release
that should have been a reset the end of
the last year and there were
preparations for that but it it's still
in preparation even so it's quite late
the problem in the past with cheeses
years what was a long time ago was a
development was very closed so that was
in in the days before the e cheese es s
e-g as a port a fork there was a very
long time between releases and there
weren't any public snapshots so when
when a project forked and then took over
the official development development are
there was lots of speed up with
development but one problem was that
people were committing changes and a
development trevose was broken quite
often which is obviously a problem so
the solution was to that rigid and stale
development a more open development
style having it a steering committee
which can appoint maintain us and do a
very sort of things and then they
divided the development phase into three
different stages in the first stage
you're allowed to make major changes in
the second stage you can still make big
changes but they're smaller and the
third stage is for bug fixing and
documentation changes and patches are
actually reviewed which which means that
the development tree is broken less
often than it used to be some of the
outstanding problems are that the
release manager is very busy so he
hasn't been forcing the release as much
as he should have been which means for
the the next release for the two which
should have happened at the end of last
year it's still it's still not happening
and the momentum has focused on photo
free but but the release manager I
really need to start pushing put 42 42
again and here's started doing that
another thing is the branch criteria for
making a new release might need an
update because it's too strict it's very
hard to actually go into the process of
making releases yeah
GCC is a great example of a very large
project like the colonel or like canola
or any of these things and I see the
same thing happening in the colonel tree
and is that that correct assessment is
that what you also seem so the question
is basically that changes broke the
development and that's you can find that
in different projects and it's like a
normal part of development it's true
that you can find I mean breakage
breakage is normally it happens from
time to time but obviously you you have
to try to avoid it especially if you
want to do a time-based release if you
say we have to release on the date well
if the development tree is broken you
can't do that the other problem is the
development if the development tree is
broken you can't do any testing so
obviously development breaks sometimes
but there is a big difference between
breaking sometimes and being broke all
of the time which which happens in some
projects I think main basically most
large free software projects are pretty
good if something is broken it gets
reverted there are some tests packages
like tinder box to make sure that things
really you know you you can work on the
tree but I think their loads of projects
or I hear lots of stories for commercial
projects where basically the development
tree is broken all the time and it's
something which which need to be avoided
but obviously sometimes it breaks
especially during stage one but it
shouldn't be broken all the time so
going to Nome you can see that in the
past they had some releases and the big
problem was with with two dot zero which
which was delayed and after two dot zero
they moved to time-based releases and
gnome is really the example of a
successful time based project I mean you
just need to look at this they say they
will release every six months and they
do and they are volunteer project
so if you compare that to Debian we're
all we're volunteers we can't meet
deadlines we don't need to define
targets yes it can be done it just needs
to you need to change the whole
development process and your perspective
of development I think gnome is a
wonderful example but again no one had
problems to people don't believe it but
in the past blom had very similar
problems toward Debian had in the last
few years so that version tool at all
the original idea was to basically
change internal interfaces but not make
many changes the problem was it took
much longer than it should have taking
people got really frustrated and the
next problem was because it took so long
developer said well if we ship to the
all now and we only changed internal
interfaces what I use is going to think
of the such a delay so they said well we
obviously need to implement something
which users see and that again leads to
delays it was basically not clear what's
going on no release updates freezes were
announced but then the release never
happened and that's very frustrating if
yeah we are freezing we make her release
nothing happens and then again two
months later let's freeze let's make
release and again nothing happens so
developers really got frustrated it was
a big problem for vendors as well they
wanted to ship gnome but when would the
next words will be out no one really
knew what happened was loads of
fragmentation when does all did their
own thing which means taking development
resources away from making that new
release so gnome moved to time-based
releases very successfully they
introduced very rigorous processes and
policies they had the idea of reverting
if something is not finished where we
take it out again and it's a really good
incentive for people to actually finish
and the project really gained lots of
credibility after those two days when
they actually released on time they
managed to do it and not only once but
several times the outstanding problem I
don't know if it's a real problem but
it's sometimes raised as a concern is
it's interesting to look at it people
say that time based release is making a
raise every six months as is the case in
norm is very good for for upgrades for
updates like incremental updates but
some people are worried that it's it
stops innovation people ask but where is
Nome free at all with that revolutionary
change and anything there are some
counter arguments first of all many of
those changes which have been proposed
for free at all have in fact been
implemented already you don't have to
make a feature already within one
interval you can simply do in a branch
and then take one year and then
integrate it back the other thing is no
one really knows what known freezer door
would actually be so it seems that every
strategy is working pretty well but
there is the question of whether those
frequent regular updates stop stop make
you know those innovation and big
changes I think it's possible just do it
on a branch and and when it's ready
switch to that so the Linux kernel is
well known for having changed its
release strategy completely with all we
don't need stable releases anymore or we
don't need a development tree which
happened after 26 so here you can see
the the stable releases from the past
loading including the new 26 releases
and that was really long time between
releases
so the parts problem because of the long
release cycle there was so many changes
and Linux is such a big project and you
could just imagine how many changes
there are and it's really hard to test
and uses very few users actually test
developing the versions so what happens
is that they were trying to release a
new version after I don't know three
years and there were so many changes and
it was very hard to test and to get that
out another problem was that features
cut out very slowly you would you would
make you would implement a feature and
then you would have to wait three years
to actually make that available to users
again vendors had to backport loads of
features or loads of bug fixes so those
loads of fragmentation going on so the
new release strategy has has reduced
them people can actually work on the
current release and together with the
community you have new versions coming
out every two or three months which
means that there is a steady flow
interpret production so things actually
tested very quickly if something breaks
uses we will see they will report it and
it can be fixed and again features get
out much more quickly you implement
something and and three months later you
can ship it to users it's great but
there are lots of problems there isn't
really a long-term stable tree so I know
Adrian punk has implemented one based on
26 16 but it still needs to be seen how
successful it will really be and it
might be a problem for for companies
that it's basically the effort of one
person and not what really something
that's officially supported by everyone
like Danny n equal to or red hat susake
those are the companies that provide the
commercial stable version whom versus a
open-source stable version and there
were attempts to make stable versions of
the colonel like a 26 81 they have
numbers that surround the enemy but
those really aren't the same as what the
commercial vendors do in really paying
attention with the commercial vendors
hmm that's right so there were two
issues the first is that the long-term
stable release is already provided by
vendors by a linux distribution and yes
that's that's how things work and the
other point was that there are stable
updates to two releases but that's
really only for the current stable and
maybe for the last one but they are not
supported a long time yes so it's true
that but the model is basically that
that the project ships something and
then it's up to the vendors to make a
long-term stable product out of it the
question is whether that's the ideal
solution because again there is some
fragmentation on the other hand there is
no agreement let's say we make a stable
release should we go with 26 18 26 16
because when does have different
schedules different release cycles there
isn't really agreement so maybe that's
just the way it is and has to be but
it's still an interesting question
whether we could do something about it
and there is the more fundamental
question whether so who are the users of
the Linux kernel of like the kernel of
all colonel are the users people will
actually run the colonel like end users
or are the users or customers the vendor
and at the moment it's it's mostly
focused for vendors and and it's a
question whether it's a good thing
because you might lose feedback from
users it always has to go through the
vendor and it slows things down so it's
a question whether it's a good thing but
yes that's way it currently works did a
problem with that fast development so
you get release is more quickly features
get out but there's so many changes and
there are so many regressions so there
are lots of people who are quite unhappy
with that but again yes they can use and
probably should use a vendor Colonel so
open office of office is an interesting
example because it's a very commercial
open source project and it has some
community involvement nowadays but it's
still very much let and financed by some
they pay the release manager and the
release cycle used to be 18 months
because of the commercial product star
office and many open-source vendors like
novela weren't very happy with that they
wanted to see more frequent releases and
in the end the project decided to move
to more frequent releases making a
release every three months so because of
those that long release cycle many many
very little testing or cured many
changes accumulated you can see there
are many very similar problems in those
projects and features cut in very late
because it was such a long time and and
you you realized or we need that feature
in order to I don't know react to
Microsoft Word or some other development
and and again the problem with vendors
well what kind of version should we ship
should we wait when is it going to be
out and now there was a major delay with
with 200 which should have been 18
months but it was actually 26 so that
was a major really delaying so in the
end the project moved to three-month
monthly releases which means that there
was a much better feedback loop with
users it also means that that features
actually get out which which increased
developer motivation and the the better
planning you know every three months
early
is allowed vendors to be involved much
much more in the development and another
thing which which son has done is to
make the release process more or more
transparent so other people can actually
get involved one of the big problems is
that a project found that three months
is actually too quick for them they
found that it's really hard to do
quality assurance if you have a release
every three months and they found that
some of the users didn't actually want
to have new releases with new features
every three months so they're currently
moving to a new schedule with major
releases every six months and in between
every free month they have smaller
updates with bug fixes plone the history
he is very it's still very young you can
see with two dot one that was a major
delay and that really prompted the
change in the release policy so releases
in particular to the one took a long
time to get out because of those many
changes users faced upgrade problems and
many pallone developers actually working
as web developers and for them it was
very hard to make a decision should we
use the current version of clone or
should I wait for the next version is it
going to be ready for my project so the
project decided to move to time-based
releases but I really don't know how
well it's working it they only decided
very recently end so far they have been
delays so I don't know whether they can
pull it off but what they have managed
so far is to implement much better
development structures it's much more
disciplined development process nowadays
which means that they can release on
time and we go back you can see that 25
was released nine months after the the
previous release so obviously there were
improvements in
and and they also say that those
deadlines have motivated developers to
actually work on on the code and finish
their features so extra dog is not
example which which basically forked
from X 386 and they moved to time-based
releases with if there's 70 release
again six months for the first release
they manage to do it in five but then
there was a delay for the next 19 months
so X free was a fork of X 3 X or it was
a fork of X 386 which had lots of
problems that were very infrequent
updates the development process was just
very richest you couldn't do any major
innovation and there wasn't any plan hmm
another problem is or was that but the
code base is huge and it's monolithic
it's like one big thing and it's a very
complicated build system so what they
have decided to do is to to split it up
and make a modular system and also to
change to build system what that split
into the modular system allowed the
project to do is to have two different
release mechanisms so those individual
projects can make their own releases
whenever they want to and then there is
the official a roll-up release of all
those individual components into a
official extra-long release and that's
quite interesting and if you think about
it you see oh that's actually how lots
of projects work like gnome it's not one
project there are so many different
applications debian there are so many
different packages you can see that in
every large project that really there
are sub systems or different components
and ideally if you can can get them to
release independently and then have a
big release for everything and it's good
because that's a fallback mechanism if a
single component is not ready you can
usually simply take the previous one the
interface is in extra dog are pretty
stable so you
actually do that and it's really good
because you don't need to wait for all
those components to be ready out sending
problem they need to clarify the
interfaces so they can update their
drivers more often so those are the the
seven projects and I think what you have
seen is there are very similar problems
delays loads of development or curing
accumulating making it hard to test when
does not being able to work on a main
development because it's so
unpredictable it very similar problems
and those delays lead to loads of
problems and I think the fundamental
problem is that the way open source
works is simply very hard to integrate
with release management because the way
it works is that people to their own
work very independently there hundreds
of people just doing whatever they
interested in and some of them might be
just nearing the completion of a feature
whereas some of them might just be
beginning and it's a problem if you want
to do a release because if you if you
just say today let's release then you
see where some projects are finished but
some of them are very unstable and
that's that basically what happened in
those projects releases were announced
out of the blue there was no plan it was
simply the realist manager well I think
it's time to make a lot of release let's
do it and then people said well but I'm
not ready I need another five months and
there were delays everyone tried to get
their fridge in because of those delays
people weren't sure when the next
release would be might be three years
away so I really need to get my feature
now you've seen that in in debian you've
seen that in the lunas currently
considered everywhere so what's the
solution for that problem how do you get
all of those individual developers to be
ready at the same time automatically and
the answer is time-based releases
instead of of saying we will release
when those features have been
implemented or when everything is ready
I mean that just doesn't work if you
have hundreds of people with different
features they want to get in you just
need so instead of saying we release
when those features already you simply
say we release on this particular date
everything that is finished two months
before that date will be included
everything else you have to wait for the
next release and and that basically
allows people to work on their own
features very independently and then if
they are ready they can simply come back
integrate it in time if they're not
ready they know the next release is only
going to be so far away so there are two
misconceptions about about time-based
releases first of all time based
releases doesn't mean you have to
release on that date no matter what I
mean if the development is broken if
there are security issues please wait
and fix those issues it's just about
what is your guideline for making
releases the other thing is you still
should plan for features planning for
features is good because it means more
work gets done if you just say well
there will be a release so i can i can
sit back and relax nothing will happen
so you should plan for features but just
don't delay the release if those
features are not ready so what kind of
conditions are necessary for project to
implement time-based releases time-based
releases I think it's great but it's
definitely not for for every project in
fact it's only for a minority of
projects I think for example it only
works for large projects and the reason
is the first point here you really need
enough work during one interval if you
have a very small project
nothing gets done in six months well why
should you make you release every six
months there is no reason but if you
have a large project with hundreds of
people there is so much stuff going on
so many new features so many bug fixes
that yes it makes sense to do regular
releases another thing is distribution
has to be cheap because if you if you
release regular releases United you need
to get them to users so if you would
rely on publishing CDs in a shop you
couldn't do a release every six months
fortunately free software we have the
internet distribution is cheap that's
not a problem the other thing is that
releases don't require any specific
functionality which again is true in
most free software projects but it can
be a problem in commercial open source
where you actually promised the customer
that that release will have those
features and the last point is that the
project has to be modular and that's
because if everything is is is tied
together then if you have one problem
you can't release anything but if it's
modular you can simply ignore some
things which are not ready on that
release date or you can revert them back
so basically my argument of why
time-based releases work is that they
act as a coordination mechanism they
have two things which act as
coordination mechanisms regularity and
the use of a schedule so regularity has
free positive aspects it creates a
reference point so essentially what I
said before is you have all those
developers doing their own work very
independently without necessarily having
to talk with each other
and that's good but there are always
changes which are related to your
changes so you need to go back from time
to time and and say okay so here are the
changes I made World War what's going on
in the rest of the project you need to
know what's going on and and having a
regular releases creates that reference
point so you create a reference point
everyone knows that's the official tree
that's where we are and then everyone
else everyone again goes off does her
own little thing and then six months or
nine months or whatever later they come
back and say well what world what has
happened the other thing is that
regularity creates discipline and self
restraint as I said before because of
those long release cycles and those
delays people really wanted to get their
features in if I don't get it in now it
might be three years I need to get it in
and that causes delays but if you have a
regular release cycle people know there
will be a release again if I don't make
this one it's only going to be 6 9 12
months whatever then people can say well
ok I will really get it done properly I
will test it and then just make it for
the next release and the next thing last
thing is familiarity one problem with
doing release is only free every three
years is that people just unfamiliar
with it it's not part of their
development process it's something you
you do sometimes you don't have
experience with maybe you don't like it
but if you do it every six months it's
just a standard practice lie like you
know brushing your teeth before going to
sleep you use simply integrated it's
normal and you get experience with it
the other thing is that the use of a
schedule as i said before allows people
to do that work independently so what
happened before when no one really knew
what was going on there are always
dependencies a translator can only do
their work when the documentation is
done you can only write an application
when the libraries are stable when
interfaces are stable
what happened when no one knew what was
going on is that people always had to
talk to each other and there to talk to
release manager so how long is it going
to take when can I start and and that's
coordination and that's expensive on the
internet but what the schedule allows
you to do it allows you to put that
information into the schedule give
people that schedule they can take it
and work independently and no oh ho on
this date I have to be done and ideally
they will come back on this date and
it's done and then the next person can
can simply do their work so it reduces
that active coordination which is
expensive so what are the incentives for
time-based releases and again that's
beautiful because it's good for everyone
I've listed for different stakeholders
there are organizations what Google if
you have to upgrade 10,000 machines you
really need to know you need to plan you
need to know when the release will be
out and and time-based releases gives
that predictability for users it's great
because they get periodical fixes they
don't have to wait three years for that
the issue to be fixed ideally they will
get it after six months and it means
that the upgrades are much easier you
don't have that big bang release which
changes everything you just have smooth
upgrades every once in a while for
developers it's good because they know
when they have to cut the coding in
order to make the release end the other
thing is that their work actually gets
to people they don't have to wait three
years and for when does it's good
because they can plan and it can
actually work with the community they
can work on one code base instead of
everyone doing their own thing so some
specific advantages for developers and I
think those only some of them so it
creates discipline but not discipline in
like that- bureaucratic way that oh god
I have to fill out ten pages of papers
before I can do anything
it just makes the whole development
process more structured and people know
what's going on it allows better
planning you know when you have to get
your features in it creates better
feedback because you your users you have
a much tighter feedback loop with your
users and that makes users happy they
see oh yes we're getting fixes so they
might send you really good bug report
and the other thing is that it really
increases developer motivation yes you
get your coat out if you look at the sum
of code and if a student is involved in
a project which really is only only
three years and they make something this
summer they contributed and then they
can only tell you know their friends
after three years or and here's the CD
here is my contribution but with with
regular releases they can do it in in
three or six months and say here is what
I did it's cool I won't do it again so
if if projects want to move to
time-based releases you need to decide
what kind of release interval is good
for me should I release every six months
every three months every nine months
every year and there are a couple of
things which should be considered one of
them is regularity and predictability if
you look at time-based the definition
you don't have to have the same interval
all the time you could say now we make
release in six months and then we make
release in nine months and then maybe in
green three months but I think it's very
good to have dead regularity then there
are user requirements and it might
depend on your software is it mostly for
servers is it mostly for desktop users
on servers you might have a slower
release cycle then then desktop software
or maybe not there are some commercial
interests which are really important
like one issue when openoffice moved to
three months was book offers they want
to write books
about amor phase but if there is a new
release every three months your book
will be out of date before it actually
gets to the market and and book or
offers actually reemployed because they
build bridges between the user community
and the development community and that
there are many commercial interests
which really benefit your development
and which you should take into
consideration another thing is that
there are various cost factors with
making releases releases cost time they
cause they they take resources for
example you need to support all the
releases so if you have frequent
releases you have more older releases
which you may have to support I know
open source projects are pretty bad with
doing that and more frequent releases
probably make the situation even worse
and then you have some fixed costs you
need to test your software you need to
actually prepare it you need to write
announcements and things like that there
might be confusion among users oh I just
upgraded to that new version but I see
that I went to the website and I saw
that there is a new version out already
sorry it takes a while to get into
distribution so by the time it reaches
users there might be a new upstream
release already it might cause
fragmentation of users if everyone's
using the same thing is really easy to
track box but if people are using many
different versions it's much harder and
there are upgrade costs as well
upgrading you can't upgrade every day it
takes time you have to download it and
you have to look at it if something
breaks and then a really important
network effects working with other
projects so one reason why soap moved to
six month leases or trying to emplome
sorry the plum project one reason was
because they want to to have the same
release cycle as soap so that they build
upon soap and they said well if we have
the same release cycle we can use all of
those new features from soap in plum
and it's really interesting it's a good
point there are also many dangers
because if soap is delayed and plone
uses all of those new features you can't
ship the new version of clone either so
that's something you have to consider
the other finger distributions open
source projects really benefit from
being in a distro because that's what
users use and if you if you have a
similar release cycle the distro it
means that your latest software gets out
to users much more quickly so when I
show the picture before about the
projects and their release cycles you
saw that many of them are doing six
months and I think there is a good
reason for that first of all it's it's a
reason of regularity if you have seven
months what happens if is that your
schedule own or always slips on the year
sometimes you might have a release
during Christmas and it's bad thing
because your people aren't there to
actually do the work and having six
months means it's always the same it's
always a little march in September you
just know it's always going to be the
same and it makes life so much simpler
the other thing is having all those
projects having the same release cycle
so six months promotes those Network
effects which I mentioned so the
question is where we are a large project
how do I actually move to a new release
strategy it's not easy to do that it's
very hard and and as you can see in the
projects which are discussed not all of
them are successful with the
implementation I still working on it so
there must be there must be really good
incentives to actually change you must
have real problems with your current
release strategy and the projects which
I which I looked at all had those
problems and then it's it's also a
matter of control and Trust in some
projects it's basically the leader says
we will do this and it's okay it will
done there are other projects where you
need agreement from many people to make
those changes and you need to really
introduce policies like I said before
you need you need to make sure that the
that the development is tree stable
because if it's not stable you can't
make time-based releases you you can
implement structures or policies to make
your development more structured like
some projects have feature proposals
where before committing a feature you
have to break it up and have a plan GCC
does that plone does that number of
projects do that and it's not
bureaucratic it's actually many people
see it as good because you know what's
what's going to happen and you have some
some kind of target and yeah defining my
stones and deadlines is a good thing the
other thing is coordination and
collaboration you really need to talk
about the release not sending release
updates is really horrible you need to
send updates you need to be available as
release manager and that's the last
point that you really need to actively
coordinate as a release manager you
can't just say oh let's publish that
that schedule and we will assume
everyone will follow it and which is do
their work you still need to actively
tell people and now the deadline is
approaching please be ready so coming to
the end what are the conclusions of that
work so i think what about i've shown is
that some of those projects have reacted
to those problems and to other changes
mmm so I think what happens in many
projects is they start off very small
and and if you're very small if you have
two people you don't need a big release
process you just talk to each other make
the release but if you suddenly have a
thousand of people the same thing
doesn't happen doesn't work you need you
need a different release strategy and I
think it
it's it's sort of natural s project
become large to move to time-based
releases something they have adapted to
their growth and the other thing is that
they might have adapted to the users
because now open source is used much
more by companies which need that
predictability something time-based
really releases are good solution to to
adapt to grove and and those users as i
argued i believe that time based
releases work because they write rely on
to coordination mechanisms which which
make life so much easier than having to
actively coordinate everything as i said
regularity and the use of schedules and
as i said initially i defined volunteers
as whether you have control over them
and it's that's important because in a
volunteer project you can't tell people
what to do so you can't be sure that any
feature will actually be done on time
the only thing you can do is you can set
a deadline a time a target date and and
include everything that's ready so what
I have shown in that research is that
using time rather than features is a
really good way to coordinate volunteer
project in which you have little control
and the next question is well what kind
of other volunteer projects are there
and do similar things apply to them I I
strongly believe that free software open
source what we are learning here about
the methodology about how to work
together how to to collaborate over the
internet with volunteers is something
which will see which we will see in many
other different areas as well I mean
there are people sharing cooking recipes
and stuff like that but there are lots
of people who want to you know modify
their cars and the only reason they they
can't do that as much as we can do with
free software is because our production
machinery is like a PC it's very very
cheap but with building a car
you need is really expensive you can't
just do that in you know at home but I
think in the future that's going to be
much much more easily available and much
much more cheaper so I think we will see
much more collaboration over the
internet and I think what we're learning
here is really important for them and
release management time-based releases
are is really important so for people
who are interested I I have my whole PhD
theses on the web and I recently started
blogging about some of the results so
you don't have to read the whole 200
pages so that's a way to blow on my
website I can also be contacted and
obviously now I'm happy to answer any
questions you might have yeah so again
using the Venus example and a lot of the
problems i saw that release slipping was
small but very important segments of the
project were delayed and i'm just
wondering if that's a common like if
there are common if it's common to other
projects where there's a small but like
very small but extremely important part
of the project is blocking the entire
the rest of the release mm-hmm and what
kind of things and maybe can be done
about that celebration so the question
is in debian universe release it seemed
that there were very small but very
important areas that were blocking the
release and whether that's the same in
other projects i think it does happen
but i don't think it's such a big
problem in other projects so if you look
at GCC well maybe yes it depends on how
you see it on cheesy see the problem is
that there are a number of pretty I mean
there aren't many but there are a number
of regressions and basically no one does
anything about them I guess the
difference with GCC is that it's not so
clear who should fix those bugs whereas
in debian it was very clear i think who
was responsible for those areas or at
work didn't get done so i i i think that
debian
even though it defined targets it tried
to look at the blockers I think that the
release team wasn't strong enough we're
following up with those people to make
sure that those brokers actually get
resolved so for me it was pretty clear
that we would have to wait for the
colonel but no one did anything about it
I think you could really see it coming
so I think that something an example of
where the the release team has to be
more active where you really need to
tell people you have to be done anything
else
okay thanks for coming and if you do
have any questions I'll be around today
and you can email me my email address is
on my website thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>