<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Rust Programming Language | Coder Coacher - Coaching Coders</title><meta content="The Rust Programming Language - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Rust Programming Language</b></h2><h5 class="post__date">2015-07-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d1uraoHM8Gg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right thanks everybody for coming
today I'm Rick Levine of the Android UI
toolkit team and it is my pleasure to
introduce today Alex Crichton of the
Mozilla research and he is a member of
the rust core team and he is here to
tell us about rust one of the more
exciting and interesting languages I
think in the past few years so Thank You
Ruth so I'm going to kind of give just a
whirlwind tour of what what rust is why
you might feel like using it and kind of
what are the unique aspects of it so the
first thing I that I normally get if I
ever talk about a programming language
is why do we have yet another one so if
you take a look around we have this
whole landscape of programming languages
today they all fill various niches they
solve lots of problems but it turns out
that you can organize these languages
along a spectrum and this spectrum is
this trade-off between control and
safety so on one end of the spectrum we
have C and C++ which give us lots of
control we know exactly what's going to
run on machine we have lots of control
over memory layout but don't have a lot
of safety we have seg faults buffer
overruns right common bugs like that
whereas on the other side we have
JavaScript we have Ruby we have Python
they're very safe languages but you
don't quite know what's going to happen
at runtime so in JavaScript we have jets
behind the script behind the scenes
where you really don't know what's going
to happen because it'll change as the
program is running so what rest is doing
is completely stepping off this line
rust is saying it we are not going to
give you a trade-off between control and
safety but rather we're going to give
you both so rust is a systems
programming language which is kind of
filling this niche that hasn't been
filled by many of the languages today
where you get both the very low level
control of C and C++ along with the high
level safety and constructs that you
would expect from Ruby and JavaScript
and Python
so that might raise a question we have
all these languages what kind of Nicias
will benefit from this safety in this
control so suppose you're building a web
browser for example servo servo is a
project in Mozilla research to write a
parallel parallel layout engine in rust
so it's entirely written in rust today
and it benefits from this control this
very high level of control because
browsers are very competitive and poor
in performance as we
all very much won't know but at the same
time all major browsers today are
written in C++ so they're not getting
this great level of safety they have a
lot of buffer overruns they have a lot
of site faults memory vulnerabilities
but by writing it in rust we're able to
totally eliminate all of these at
compile time
so this this and the other great thing
about server was this parallelism aspect
if you try and retrofit parallelism on
to for example gecko which is millions
of lines of C++ it's just not going to
end well so by using a language which
from the ground up will not allow this
memory on safety we're able to do very
ambitious things like parallelizing
layout and on the other spectrum of
things let's say you're not a C++ a
curve you're not a browser hacker you're
writing a ruby gem skylight is a great
example of this it's a product of tilde
where what they did is they have a
component that runs inside of their
customers rails apps was a kind of
monitor database how long it takes to
talk to the database how long it takes
for the HTTP request general analytics
and monitoring about that but the key
aspect here is that they have very tight
resource constraints they don't want to
they're a component running in the
clients application so they can't use
too much memory or they can't take too
long to run so they were running into
problems and they decided to rewrite
their gem in rust and rust is great for
this use case because with the low level
of control of simple as that you get in
C plus C and C++ they're able to satisfy
these these very tight memory
constraints are very tight run time
constraints but also they were not they
were able to not compromise the safety
that they get from Ruby so this is an
example where they would love to they
would have written their their gem and C
and C++ but they were very hesitant to
do so that there are ruby shop they
haven't done a lot of systems
programming before so it's kind of tough
kind of that first breach in system
systems programming and this is where
rust really helps out so I want to talk
a little bit about what I mean by
control and what I mean by safety so
this is a small example of in C++ where
the first thing we're going to do is
make a vector of strings on the stack
and then we're going to walk through and
take a pointer into that so the first
thing that we'll realize is a lot all of
this is laid out in line on the stack
and on the heap so for example this
vector is comprised of three separate
fields a data length and capacity which
are stored directly in line on the stack
there's no extra indirection here and
then on the heap itself we have some
strings which are themselves
just wrapping a vector so if we take a
look at that we'll see that
itself also has inline data so this
first element in the array on the heap
is just another data length and capacity
which is pointing to more data for the
string so the key the key here is that
there's not these extra layers of
indirection it's only explicitly when we
go onto the heap
we're actually buying into this and then
the second part about control and c++ is
you have these very lightweight
references so this reference into the
vector the first element of the vector
is just this raw pointer straight into
memory there's no extra metadata
tracking it there's no extra fanciness
going on here it's just a value pointing
straight into memory a little dangerous
as we'll see in a minute in a second but
it's this high level of control we know
exactly what's going on and then the
final aspect of this is we have
deterministic destruction or what this
means is that this vector of strings we
know precisely when it's going to be
de-allocated
when this function returns is the exact
moment at which this just destructor
will run and it'll destroy all the
components of the vector itself so this
is where we have very fine-grained
control over the lifetime of the
resources that we have control of on
either on the stack or within other
containers themselves and what this
mostly boils down to is something that
we call zero-cost abstractions where
this basically means that it's something
that at compile time you can have this
very nice interface very easy to use
it's very fluent to use but it all
optimizes away to nothing so once you
push through the compiler it's basically
a shim and it'll go to exactly what you
would have written if you kind of did
the very low-level operations yourself
and on the other side of this let's take
a look at Java so if we take our
previous example of a vector of strings
then what's actually happening here is
the vector on the stack is a pointer to
some data at a length and some capacity
which itself is a pointer to some more
data but in there we have yet another
pointer to the actual string value which
has data length and capacity we kind of
keep going with these extra layers of
indirection and this is something that's
imposed on us by the java language
itself there's no way that we can get
around this these extra layers of
indirection it's something that we just
don't have control over we have to buy
into right upfront
unlike in C++ where we can kind of
eliminate these extra layers and kind of
flatten it all down when I'm talking
about zero cost abstractions it's not
just remember layout it's also static
dispatch if I know that a function call
it's the ability to know that a function
call at runtime is either going to be
statically resolved or dynamically
resolved at runtime itself this is a
very powerful trade-off where you want
to make sure you know what's going on
and the same idea happens with template
expansion which is generics in Java and
C++ where what it boils down to is that
if I have a vector of integers and a
vector of strings those should probably
be optimized very very differently and
it means that every time you instantiate
those type parameters you get very
specialized copies of code so it's as if
you wrote the most specialized vector of
integers for the vector vintages itself
so let's take a look at the safety
aspect that's kind of an example of what
I mean by control but the safety comes
into play especially in C++ so this is a
classical example of where something is
going to go wrong so the first thing
that we do is we we have a previous
example with the vector strings and we
take a pointer into the first element
but then we come along we try and mutate
the vector and some of you familiar with
vectors in C++ you'll know that one
you've exceeded the capacity of a vector
you probably have to reallocate it copy
some data and then push the big data
onto it so let's say in this case we
have to do that we copy our data
elsewhere copy our first element that's
in our vector pushed on some new data
and then the key aspect is we deallocate
the previous contents the previous data
pointer and what this means is that this
pointer our element pointer is now a
dangling pointer into freed memory and
that basically implies that when we come
come around here to print it out to the
standard output we're going to either
get garbage as seg fault or this is what
C++ calls undefined behavior this is
kind of the crux of what we're trying to
avoid this is where the unsafety of
stems from so this is kind of it's it's
good to it examine examples like this
but what we're really interested are
what we're really interested in is kind
of these fundamental ingredients for
what's going wrong here because this
kind of example you can probably pattern
match and figure it out it's very
difficult to find this in a much larger
program among many many function calls
deep so the first thing we'll notice is
there's some aliasing going on here this
data pointer of the vector and the
element pointer on the stack are
pointing to the same memory location
these two alias aliasing is basically
where you have two pointers pointing at
a very similar location but they don't
know anything about one another so then
when we come in and mix in mutation
what we're doing is we're mutating the
data pointer of the vector but we're not
mutating the the alias reference of the
element itself so it's these two
fundamental of ingredients in
combination aliasing and mutation it's
okay to have either end of either of
them independently but when we have them
simultaneously as one this these memory
and safety bugs start to come up
so I'll harp on this a lot more on the
rest of this talking we'll see a little
bit more in detail so you might be
asking what about garbage collection
this sounds like a problem the garbage
collectors are tasked to solve for
bidding daling pointers for bidding
these various references rewriting
things at runtime but it turns out that
garbage collectors don't come without a
downside garbage collectors don't have a
lot of control they don't have this
low-level control of C and C++ you have
these GC pauses you have these variable
runtimes for actual actually allocating
data it's very tough to reason about
what's going to happen and then an offs
not very an aspect of garbage collectors
which is not really cited that often is
they require a runtime and this is a
very strong aspect of C and C++ where
for example if I write a library in C I
can run it basically anywhere because
there's no assumption about the hosts
runtime that are running inside of so if
with a garbage collector it's very
difficult to embed what you're writing
into other languages and we'll see how
it's really beneficial to not have this
this runtime behind the scenes and then
the worst part about this is that it's
insufficient to solve all the problems
that we want to solve garbage collectors
don't automatically gate you get you
away from iterator in validation from
data races these are these concurrency
bugs that are very difficult to to weed
out so it turns out that all of these
problems are very closely interrelated
and we would love to kind of solve them
all at once and garbage collection
doesn't quite fit the bill so what rust
has is a system called ownership and
borrowing this is going to be kind of
the focus the main focus for the rest
the talk I'm going to talk a lot about
ownership and borrowing and some of the
great things we'll get out of it but it
suffice to say for now that other ship
in borrowing doesn't need a runtime it's
totally a static analysis past its zero
cost at runtime it's all static analysis
there's nothing going on under the hood
when you're actually running code it's
totally memory safe this is the crux on
which all of the memory safety of rust
is built is these these concepts of
ownership and borrowing and
finally using these we're able to
prevent all data races which means that
all the concurrent code you write in
rust you will not have a data race which
is an incredibly powerful thing to say
for coming from an example for example C
or C++ where it's very difficult to know
if you ever might have a data race or
ever it won't and we take a look back
again at C++ C++ gets us one of these
things we don't need a runtime with C++
garbage collection also gets us one of
these things it gets us memory safety
but the problem is are the great thing
about ownership and borrowing is this
free abstraction at runtime gets us all
of these simultaneously so I want to
give some credit to the the rust 1.0
community in the sense that we would not
be here at one point out without them
the rust 1 point of the rust community
is very large very active incredibly
helpful incredibly kind incredibly
welcoming and you can see this across
our forums IRC channels our subreddit on
github on issues in poll requests
basically everywhere to be a part of
this and they are absolutely
instrumental to coming across the finish
line for 1.0 both in terms of giving
feedback on our designs proposing their
own designs I would highly encourage
anyone who's interested in rust to kind
of jump in and don't feel afraid to kind
of ask stupid questions or ask any
questions anywhere because it'll be
answered almost instantly by someone
who's super helpful alright so I want to
kind of take the rest of this talk and
talk a lot about what I mean by
ownership and what I mean by borrowing
and some of the great things that we're
going to get out of this and the first
of this is ownership so ownership is
basically the English Turner what it
means by I only research so in this case
let's say I owned a book I can then
decide to send this book to someone else
and I can then decide to go away and we
know that this book because it has an
owner we don't Z allocate it or anything
and it doesn't it's totally independent
of me the previous owner at this point
but as the owner of a book I can then
also decide to go away at which point we
know this book has not moved to anyone
else so we can totally destroy it we can
release all resources associated with
this book so I was talking about these
fundamental ingredients of aliasing and
mutation and we'll see that with
ownership we're totally forbidding the
aliasing aspect we're still going to
allow a free mutation through these but
by forbidding aliasing we're still going
to prevent us from this whole class of
memory unsafe to you
go through an example of what's actually
happening here at run time what's
actually going on under the hood so
here's a small example where we're going
to create a vector on the stack and
you'll notice that like C++ there's no
extra layers of indirection here these
fields are stored directly on the stack
this data length and capacity we're
going to come along and push push some
data onto it so push a 1 push a 2 and
then we'll get to the point that we're
going to call this function take and the
key part about this function is that it
says that it's going to take ownership
of this vector of integers that's this
veca via 32 is taking that bear type
what it means is it's taking ownership
it's consuming ownership so on the give
side of things what's actually going to
happen is we're going to create a
shallow copy at runtime of this vector
now we'll notice that there's some
aliasing going on here so which is what
ownership is preventing so the key
aspect is that we're going to forget
this previous copy this copy that gives
give has the shallow copy is totally
forgotten we can no longer have it we no
longer have access to it so then as the
function take runs it now has ownership
of the vector it has its own shallow
copy and then kind of do whatever it
wants it can read from it it can write
from it can do this is the froma however
it likes and then once we get to the end
of the function take we know that we
have not passed ownership of this vector
anywhere else so this is the precise
time at which we could delegate it we
know that there are no there's no one
else who can have access to it we're the
sole owners of it so as a result of it
falling out of our scope we can free all
the resources associated with the vector
and then once it come back to the
function give it so we don't have to the
the vector has been forgotten so we
don't have to worry about using a
dangling reference and so the compiler
is the one that's enforcing these moves
when the function when we call the
function take we move the vector vector
into the function take and then come if
for example we try to actually use the
vector after we had moved it say for
example we try to push some data onto it
the compiler rejects this saying the
vector has been moved and so we are not
allowed to have access to it and this
primarily prevents use after free so
this is this entire class of bugs
because we're tracking the owner of a
value and who has owner who can access
at any one point in time then we know
that when the owner has gone out of
scope that the resource has now been
freed and there are no known people that
could possibly be referencing it because
the sole owner
as going out of scope so this all sounds
great but it's kind of clunky if we only
had ownership so we need this system
called which we call borrowing which
kind of helps us lend out a value for a
small period of time so I have ownership
I can pass it along someone could pass
me back ownership but it's not very
ergonomic to do that so borrowing is
what comes into play where I as the
owner of a value can then decide to lend
it out for a period of time but I'm
still in control of the lifetime of the
resource you don't know you don't get to
control that you can access it but I'm
the one that's going to decide where to
free it and when to free it so we have
two primary kinds of borrows and rust
the first of which is a shared borrow
and a shared borrow kind of means what
it says where I is the owner of a
resource can send out multiple copies of
my resource just references to it into a
child functions or threads and yes and
then what's actually happening here is
the aliasing a mutation that we're
trying to prevent simultaneously we're
totally forbidding the mutation aspect
of this because there is aliasing
happening via shared borrows we're not
going to allow mutation through the
shared bars themselves and as you might
guess on the flip side we have mutable
borrows we're mutable borrows kin as the
owner can kind of lend out a mutable
borrow to someone else
they can then pass it along to their to
someone else if they like and then it
will implicitly return back on off the
stack once everyone starts returning so
what's going on here is these two
ingredients of aliasing and mutability
aliasing and mutation the Mito borrows
unlike the shared borrows are preventing
aliasing but allowing mutation so these
are kind of two different kinds of
references to get these two aspects of
either aliasing or mutation but we're
going that they're in totally separate
classes because if they were to overlap
then we have them simultaneously and
that's where memories unsafety bugs come
out of so let's take a look back at our
previous example of a shared reference
going on here so we have this the same
idea we have a vector push some data
onto it but there instead of passing
ownership to this function use we're
going to pass a borrow for it so that's
what this ampersand sigil out in front
means this ampersand means that I'm
taking a borrow of this vector
I'm not taking ownership and that's the
same idea on the caller side I have this
ampersand out in front to say I am
loaning out ownership of the resource
that I currently own
and then you're going to be able to
access it for a small period of time so
at runtime what's actually happening is
we're just creating a raw pointer that's
all references are and this vector is
just pointing directly onto the stack
itself and then the function used is
going to use this raw pointer do
whatever read whatever it likes from it
and then once it's returned this
reference has gone out of scope so we
totally forget about the reference so
another thing to have to thought
emphasizes this if this function use
tried to for example mutate the vector
by pushing some more data onto it or for
modifying some various elements of the
array those are all completely
disallowed because mutation through a
shared references only is not allowed in
this case for vectors of integers so
these two are forbidden by the compiler
is saying that you cannot mutate through
a shared reference and this isn't a
hundred percent true there are some
controlled circumstances in which we do
allow mutation through shared references
I'll talk about a few more of them later
on the talk but it suffices to say that
if you see this ampersand of T what it
means is that you cannot mutate it it's
it's essentially immutable so let's take
a look at some mutable references now so
the needle references are denoted by
this ampersand u tag and because we have
a mutable reference the compiler is
going to allow us to do things like push
so in this example one we're just going
to iterate over one vector
push some data onto a new vector and
just create a separate copy of that so
let's I want to walk you through kind of
what's happening here at runtime how
this iteration actually happens and the
first thing that we're going to do is
we're going to create this element
pointer our iterator is going to give us
a pointer into the vector and this
pointer is just pointing directly up to
the first slot this is kind of like the
element pointer we saw earlier in C++
and then when we come around to actually
push some data onto the new vector we're
just going to read that pointer push
some data and then run to the next loop
of the iteration but the key idea here
is that iteration is this zero cost
abstraction kind of as fast as you would
write it in C and C++ this increment
step all that's doing is swinging this
pointer down to the second slot and then
just kind of forgetting about the first
player so some of you might have seen an
example like this before what you might
be wondering what if this from vector
and this to vector are equal what if
we're trying to push on so what
reading from at the same time so if we
walk through and kind of see what's
going on let's say we have that
reallocation reallocation happen like we
saw at the beginning with C++ so we have
our vector of one two three we push the
first element reallocate we now have one
two three one but the the key thing
that's going to go wrong here is as we
go to the next loop of the iteration
we're going to update this element
pointer but now it's pointing into freed
memory it's this dangling pointer just
was hanging out here and this is a this
would be a problem if frost we're going
to allow this but if we actually try to
write this down and rust we can't
actually see what's going on here the
first thing we'll do is we'll take out a
shared reference and the next thing that
we'll do is try to take out this mutable
reference what's actually going to
happen is the compiler will is
forbidding both shared references and
mutable references from happening at the
same time so the compiler has this
notion of kind of when a shared
reference is active and what a mutable
reference is active and these can never
overlap because that would be allowing
simultaneous mutation and aliasing and
this ends up giving us a very nice
property of mutable references and that
a mutable reference is the only way to
access the data that it contains which
is a very strong guarantee to provide
that if I have a mule reference I'm the
only one that can either read or write
to this data at this point in time and
this also applies across many threads as
well so we'll see later how we can
leverage these kinds of guarantees and
leverage these kinds of static
guarantees that Russ gives us to in
various fashions so this might seem a
little unwieldy if you're looking at
okay I can either have a shared
reference or a mutable reference but I
got to make sure they somehow match up
but I don't wanna have to contort code
to make sure that it actually works out
so in this case we're going to take a
pointer into the vector just kind of
ampersand BEC sub i but the compiler
when we come down to this vector push
this needs to be disallowed because this
pointer would could become invalid if we
allow the push so the compiler has this
notion of the lifetime of references so
know that the lifetime of this LM
reference is the scope of this for loop
and we know that because the mutation
happens in the lifetime of the shared
reference it's completely disallowed by
the compiler it prevents these two from
happening at the same time but once
we've gone outside the loop the compiler
knows that the the shared reference has
kind of fallen out of scope there's no
activeshade references so we can allow
mutation and what this basically boils
down to is that in code you can have
regional basic you can kind of chunk up
the time of which a vector is alive for
any resources alive for and it can
either be shared borrowed in a shared
fashion or borrowed in a mutable fashion
and that can happen bunch of times they
just can never overlap so those are kind
of the fundamental concepts of ownership
and borrowing and rest this this whole
idea of I own a resource I can pass it
around to other threads but I cannot
pass around ownership so then you get to
control the lifetime but I can also lend
out a borrow or you can either read it
or you can mutate it but I'm still in
control of the lifetime of the resource
itself so I want to give you a taste of
how using these two concepts baked into
the language which are somewhat simple
we can build up concurrency abstractions
we can build up these great concurrency
libraries and one of the great things
about rust is that there's there's all
these ways to tackle concurrency through
there's message-passing there's shared
memory there's mutexes there's all these
different paradigms but in rust these
are all 100% built into libraries none
of these are actually found in the
language itself because they're all
leveraging ownership and borrowing to
give you a safe interface at compile
time and one of the one of the other
cool things we'll see about this is that
you typically have these standard best
practices whenever you're using these
paradigms and rust is going to
statically enforce that you must follow
these best practices you cannot break
them and I'll show you some examples as
we go through so the fundamental thing
that we're trying to prevent is
something called a data race a data race
is what happens when two threads in an
unsecure honest fashion
access the same memory so where at least
one is a right and in terms of C++ this
is called undefined behavior I did a
race will lead to unbundle find behavior
and basically what's happening here is
because we use LVM as a back-end LLVM
assumes that a data race is undefined
behavior so the optimizer can kind of do
whatever it wants if it detects that
code could have a data race so we need
we need to prevent this to prevent our
optimization passes we're going awry and
kind of doing all crazy all sorts of
crazy stuff I mean if you take a look at
the ingredients for data race like we
were looking at some ingredients for the
memory of safety with salt earlier these
three ingredients of aliasing with more
than one thread with mutation where at
least ones are right and then
unsynchronized it turns out two of these
sound
familiar to it these sound like our
previous system of ownership and
borrowing are going to help us also
forbid data races at the same time so I
want to talk first about messaging
message passing where this is going to
leverage ownership and rust where I have
ownership of a message another thread
comes along I can then send them a
message and then they can also decide to
send me a message and the key idea here
is that we're passing ownership of
messages between threads so typically
whenever you're using message passing
you have this best practice that once
you've sent a message you no longer
access what you just sent but you don't
really have a static guarantee that
you're not accessing what you just sent
across the other thread so what rust is
going to do is because of ownership we
can ensure that once we've put a message
into a channel or into a across the
threads I no longer have access to it so
we're enforcing this these this
isolation of threads at compile time all
all with no overhead and zero cost so to
run you through an example we have two
threads here though the parent thread
takes the receiver end of a channel and
this it's going to spawn a child thread
which is going to take the transmission
under this channel and what we're going
to end up with is these kind of two two
pointers pointing into a shared memories
the shared state of the channel itself
is kind of the queue of messages on the
channel and then as a child starts
running it's going to create a vector on
its stack it's going to push some data
onto it add some new data onto the
vector and then it's going to decide
that it wants to send it along this
channel so like the moves we saw earlier
what's going to happen is this will
create a shallow copy at one time and
it'll transfer ownership of the value
from the child onto the channel itself
and this is it's it's key that this
ownership is not transferring to the end
of the thread but rather to the channel
itself so the owner the owner of this
data is now the channel and no longer
and not the not the threads themselves
so we come back to the parent which
decides that it wants to receive the
message where we're going to stick this
shell a copy of the data from the
channel transfer ownership over to the
parent and I'll a parent can have access
to it and kind of do whatever it wants
to it does some some key things to get
away from this are the child no longer
has access to the vector because we have
moved the data onto the channel there's
no way for the child to continue to
modify it or to mutate it as past
ownership as relinquished ownership
whereas on
parents side we can be guaranteed that
once we received a message that it's we
we contain ownership and there are no
other outstanding aliases or references
we know that we are the only way people
who can access this data at this time
and then the other thing is that I want
emphasize this is all a shallow copy
happening here at one time so the data
inside this vector itself was never
moved around we ever copied it to other
locations it's kind of all we had to do
was move this point around into the same
data so the next paradigm that I want to
talk about is shared read-only access
typically a message passing is great for
a lot of various algorithms and various
ways to set up a system but a lot of
times you want to kind of you don't want
to have to send data around you want to
kind of send it once and then everyone
has access to this large array or large
image or whatever you want and what rust
has for this is something that we call
arc and arc stands for atomically
reference counted and what this means is
that it's a reference count on top and
then we will modify the reference count
atomically and the actual memory
representation for this pointer is we
store the reference count in line with
the rest of the data in the arc itself
so the date the data fields to this
vector are kind of found at the end of
the arc pointer but all we have to do is
tack on this reference count so this is
kind of the whole zero cost aspect of
the arc isn't kind of giving you any
extra layers of indirection than you're
already asking for word but one of the
key aspects about arc is when you create
it it took ownership of the value so
this arc consumed ownership of the
vector when it was created which means
that it under it knows it has a static
guarantee that there are no aliases
there's no references there's no mutable
references there's no one else that
could possibly access this data when it
was created so the arc has complete
control over how it gives you access the
internal data so being a share read-only
a state of primitive we're only going to
allow shared references from this so
from the arc we can get a reference to a
vector of integers and this in a
concurrent context is immutable so we're
totally totally safe from data races in
this case because there's no mutation
going on here we're only allowing
aliasing but we're forbidding the
mutation aspect so the key idea here is
that we can use ownership to understand
that we control access and then using
borrowing we can control what kind of
access we give you in the
so we're not giving you mutable access
you can't mutate which is kind of the
the best practice in shared state
concurrency but it's not necessarily
enforced to compile time and you might
accidentally have some mutation
occasionally but in rust it's totally
forbidden at compile time so the next
thing I wanna talk about is locked
immutable access this is when you have
some mutexes use some extra
synchronization to kind of prevent
threads from running in simultaneously
so we'll take a look at a small example
here where all we do is we take a mutex
we lock it push some more data onto it
and the first thing you'll notice is
this type parameter we have a mutex of a
vector of integers this is kind of uh
it's kind of you don't see this a lot
everywhere else you this is kind of
following the paradigm of you lock data
not code so typically you'll see mutex
is around a certain block of code and
then you'll access some data inside of
it and it's this implicit assumption
that you better access that data only
inside those mutex is because if you
access it outside you might be causing
some data races so in rust with this is
a static guarantee that you're given you
are given a mutex which is explicitly
protecting the data that it is
containing and then like arc we have
complete control over the ownership of
the data when it was created
so the mutex is kind of only allowing
you access once you've actually locked
the mutex so in this case when we lock
the me text itself we're getting a
sentinel we're getting kind of a
placeholder value which serves as a
smart pointer in a sense to the data
that's inside the mutex so through this
we can kind of we can mutate it we can
read it so in this case we're going to
push some data onto it but the key idea
here is that we can only access the data
through this guard and we can only get
this guard if we've locked the mutex so
this is where we are protecting this
data and you can only ever access it if
you card the mutex preventing the data
races that would happen if you access it
outside and the other great thing about
these mutexes and rust is that we know
exactly when this lock is going to be
released so because we have
deterministic destruction like in C++
when this guard goes out of scope it's
going to automatically unlock the mutex
that it was associated with so another
key aspect here is that if I try and
borrow the data from this guard if I
correct try and take a borrow out of the
RUS lifetime system like I was talking
about earlier with these scopes Kent
sent us from having that reference out
living the guard itself so we can make
sure that all references even shared
references which you'll pull out from
this guard are only ever accessible in
while the new text itself is locked so
we can use all these ownership and
borrowing guarantees that Rus gives us
to make sure that because the data is
only have access lock
we totally prevented data races here and
the last thing that rust will give us is
these extra tools to kind of check
weather types our send a bill across
threads for example this is kind of one
example of a trait that rescues so we
have what this function is saying is
that I am a function which can transfer
any type which is send a bill to other
threads and example this is arc like we
saw earlier is indeed send a bill to
another thread but it's sibling RC which
tends to reference counted is not send
able to other threads this is a key
difference where RC the modifications to
the reference count are not done
atomically though they're much much
cheaper so it's much faster to kind of
frob these reference counts over arcs
but if a RC were sent to another thread
because of this non-atomic mutation you
could have a database so at compile time
we're able to say in rust that arcs are
send a ball what these RCS are not and
this is in contrast to C++ C++ is stood
shared pointer if you're familiar with
that they don't actually know whether
they're this class is going to be sent
across threads so you have to
pessimistically assume that it will be
so even if you know for a fact that your
references are not actually escaping the
thread you're using them in you still
have to pay for this atomic reference
column overhead so what this means is
that in rust you can kind of pick and
choose whether your primitives are going
to be thread safe we're not thread safe
and if they're not thread safe you can
be guaranteed a compile time that it's
you're still not going to have any
databases
these are C pointers will never escape
the thread they're using them in and if
you do actually need that then you can
manually then you can yourself opt in to
the atomic reference cutting overhead
which will be necessary so that's kind
of an example of how using ownership and
using borrowing we can kind of prevent
actually can use these tools to give us
all these great concurrency primitives
all these primitives like message
passing shared state concurrency mutexes
they're all built into the standard
library of rust they're not actually in
the language itself which allows us to
iterate on them to make tweaks to them
and basically extend the language kind
of grow it a little bit
so to beyond just the just the concepts
of ownership and borrowing and I want to
kind of go into now how these are
implemented how these what's actually
going on under the hood because Ark is
kind of giving you this this facade of
shared ownership actually there are
multiple references that can access this
data so this strict concept of ownership
or the strict concept of borrowing
doesn't always apply and this is where
unsafe rust comes into play so rust has
this notion of unsafe code it's a block
of code delineated saying that unsafe
operations can happen within this block
and this is grow this is useful for
doing things like talking to other
languages for like CFI bindings because
the compiler has no idea when you call a
function what it's actually gonna do on
the other side so it has to assume
pessimistically that something memory
unsafe is going to happen you have to
opt in to saying no it actually won't
and it's also great for what I was
saying earlier about building art or
building Veck we can use unsafe code it
kind of build up new abstractions in the
language and the key idea here is that
because we have told the compiler trust
me I know what I'm doing within this
unsafe block I will maintain memory
safety myself we can make this safe
abstraction around it this is kind of
the the crux of rust is building these
safe abstractions which might have small
unsafe internals but the safe
abstraction is what everyone relies on
as part of the public interface so the
way this typically works is this safe
abstraction the safe layer will do some
dynamic runtime checks like making sure
that indexes are inbound or making sure
some other dynamic and variant that's
very tough to to reason about at compile
time and then it's going to add on top
of that the guarantees it gets from
ownership and borrowing kind of these
static guarantees if I owned it I'm the
only one shared it or shared references
I can only read from and mutable
references I can either read our mutate
but it's totally unique and using all
the all these static guarantees you can
kind of Bend rust a little bit and the
ways that you like with unsafe code and
so you might be thinking well if we have
unsafe code haven't we just made rust
memory unsafe haven't we just broken
down this whole memory memory this idea
I'm saying rust is a safe language and
it turns out the way this works in
practice is that ownership and borrowing
cover almost all use cases I've ever
seen in terms of how you would
architects this architected system or
how you would design it
this concept of I can either borrow it
in a shared fashion or borrowed a
mutable fashion it encompasses what
maybe with a little tweaks of what
you're already doing today this is
already the best practice a best
practice of how you're accessing data
and this is just codifying it at compile
time and as a testament to this cargo
which is Russ package manager I'll talk
about that in a second and this guy like
I said earlier have zero unsafe blocks
there's no unsafe code in these projects
except for Fi which is kind of assumed
and these are fairly substantial
projects that are doing some pretty
crazy internal things things with
ownership things of borrowing and they
haven't felt the need to fall down to
this unsafe code to kind of to break any
invariants that they've been able to fit
entirely within this this programming
model but the great thing about on a
safe like I was saying with arc is we
can extend the programming model if you
do find yourself needed to drop down to
unsafe or to have a little bit of unsafe
code what it means is you're probably
writing a very small permanent of a very
small thing which you can very easily
reason about and say yeah this is safe
the compiler can't totally reason about
this but it is a safe abstraction and
using that you can kind of add new
primitives like we have these things
called cells or ref cells or mutexes or
arcs all this fun stuff in the standard
library and we can build on top of what
we're given by energy and borrowing by
bending ownership and borrowing just a
little bit to kind of give us these new
set of primitives that we can leverage
and take advantage of so that's kind of
a ownership and borrowing in a nutshell
how we can use it to pull of concurrency
and then kind of how we can use all of
these guarantees to use unsafe code to
build new primitives and I want to talk
a little bit now about using russ
today's just kind of a quick tour of
some of the stuff that we have in kind
of the tools that russ provides one of
the ones are what are the primary ones
is cargo so i said this earlier but
cargo is rusts package manager' where
what it does is it manages all of your
dependencies it's very similar to two
rubies bundler and it'll kind of take
care of building our dependencies
building transitive dependencies making
sure that all your system libraries are
in place it will take care of all this
logic allowing you to get to writing
your application so one of the great
things about this is we can guarantee
reproducible builds so this is a very
important part of bundler if you're
familiar with that with lock files and
we kind of take we took the same concept
to cargo where if I ever build a project
I can then be guaranteed if it's success
the built that later in the future I can
build that project again I don't have to
worry about getting all the same
versions of all the dependencies and
making sure all the transitive
dependencies work out I can kind of I am
a very confident that is the same set of
code will build again and then all the
libraries today for cargo are called
crates and they're all hosted on Christ
on Io
we have a very booming and active
community today and this has been
absolutely critical to rusts kind of
initial surge into the market in kind of
a lot of rusts initial success has been
it's very very easy to put your code up
on crystal Deo and to also use everyone
else's so even now it's quick it's
quickly becoming the case that if you
have some pretty common use case like
gzip or visa for various compression or
XML or parsing JSON it's already there
and Crystal ago when it's very easy to
kind of pull those traits down use them
yourself browse documentation and kind
of go through the whole using everyone
else's R Us code yourself and so a
little bit about rust itself rust itself
recently reached the whole the 1.0
stable status this past May so this is
this was a very large milestone for us
kind of reaching this stable aspect
we're no longer breaking the language
we're no longer breaking the standard
libraries you can kind of guarantee that
rust is not changing into the future and
coming along with this is this release
train idea where we have this pipeline
of channels where we have the stable
beta or the stable channel the beta
channel and the nightly channel where
you can kind of promotes we promote
these at a regular cycle kind of like
web browsers and we'll see that we have
a whole stabilization pipeline for
features where new features we can
iterate on very quickly and nightly in
but you can have access to the basically
immediately as soon as they're
implemented you can give us feedback we
can fix bugs we can iterate on them we
prevent them from leaking into the beta
and the stable channels but then once a
feature is actually stabilized into this
in the nightly Channel it's a very short
amount of time before it actually gets
in the beta gets into stable and
everyone can start using it so the key
aspect here is that is stability without
stagnation when you're using rust you
can we're not done with rust we want to
keep we want to keep her adding on new
features we want to keep adding new
libraries standard library ApS or new
new libraries themselves so over time
we're going to be adding these things
but to rust itself but while at the same
time giving you a very strong stability
guarantee we're not going to be breaking
code willy-nilly we're not going to be
breaking the line
itself all right so some of the the
high-level conclusions of this talk that
I want to make sure you you walk away
with is that rust is combining these
high-level features of C and C++ are
sorry of JavaScript and Ruby with a
low-level control of C and C++ it's kind
of unioning these two together with both
safety and control and rust can give you
very strong safety guarantees beyond
what a garbage collector can give so for
example we have determinist
deterministic destruction we have we
forbid all data races we forbid iterator
invalidation all of these happen for
free at compile time and you can you can
basically pro program very confidently
you can have felis concurrency you don't
have to worry about these kinds of bugs
happening up in your code because rust
is preventing them all at compile time
all right and that's why I have for
today so thank you for coming and are
there any questions yes using standard
library for the standard library assumes
allocation number beds basically so are
you interested in standardizing the
library of cities which current
allocation failures or I am very much
interested in this actually yes so the
question was we have a standard library
today we advocate it we advertise
ourselves as a systems programming
language but the standard library
assumes that allocation succeeds it
assumes it does not fail so it'll kind
of abort the process if it does so it's
wondering whether we have any plans to
kind of expand this where we can have
optional like we can say whether
allocation has failed or not by having
the actual return value and I can decide
what to do with that and the answer is
yes I very much want to be able to do
this so right now we have this
distinction where we have the standard
library underneath it we have a whole
facade of libraries at the core of which
is actually Lib core and blue core is
this library which doesn't actually
assume allocation at all like it can't
even allocate and then once we we
eventually hit a point where we do
assume allocation succeeds we can build
more things on top of that so this will
all start by Lib core itself will be
stabilized
we want to export that to l2 as part of
the stable channel of rust itself and I
will kind of give you access to most of
the language not the collections not the
pointers and then the story there is a
little bit it's a little bit more
marketing the future I very much do want
I want an arc where the only difference
is the new method says whether it failed
to allocate or not we don't have any we
don't have concrete plans and designs
just how to go in that direction because
the way to start off is to get look or
to get the core core aspect worked out
but it's definitely coming in it's
definitely use case that rust very much
once it wants to fill in - yes I was
wondering if you could tell us about
what full programming languages or
academic tagging systems to look at yeah
so the question is there's a lot of type
systems like rust it's kind of linear
affine type systems and kind of what
languages and type systems we've looked
at to kind of influence rust design and
how it's come over over the years and so
I can say I personally have not been
that influential on kind of the design
of the core type system but from what
I've heard it's definitely linear and
affine types were a hue there's lots of
papers on that which are very
influential on rust itself especially
when determining like the linearity of
references and things like that
but I think cyclin might have been one
of the larger languages that we've drawn
from in terms of drawing experience from
and seeing what's happened there but
overall it's actually drawn a lot from
from actually languages like C and C++
like going back to our fundamentals of
seeing what it actually means to having
a runtime kind of in that aspect so
we've drawn things from other places but
those are the big ones that I know of
and I'd have to refer you to others to
kind of go into more detail about like
some of the academic research going on
there yes I'm sorry can you take support
was by combining changing that let me
get about the same but we equally
mentally damage so the question is can
we bolt safety on the C++ can we kind of
tweak the standard library took the
compiler - can I get these
guaranties maybe checkout something
unsafe primitives so we get a safe
language and the key the key thing here
is we've seen like with C eleven and C
for C++ fourteen and these new standards
they have things like unique pointer
they have shared pointer they have lock
guards they have all this great new
stuff but the problem is you can still
misuse it it's still very easy to use
these standard primitives which are
pretty safe but you can use them in
unsafe ways
yes saying that they have limits of
backwards compatibility and if we could
break it we could actually fix a lot of
things and it's kind of an extent at
some point so if you're moving C++ in a
direction where you're kind of stripping
away all the unsafe features stripping
away all this stuff then at what point
do you actually create a new dialect of
the language and from from what I've
seen in C++ and rust is the move
semantics are very radically different
in rust as they are in C++ kind of
there's no move constructors there's no
copy constructors there's no extra stuff
happening there and the other major
thing is references
dealing with lifetimes I think is just
something you fundamentally cannot bolt
onto C++ and still have the same
language and those are very unique to
rust and there's kind of the
underpinnings of the safety itself so
those two aspects tied together I feel
you we could add them to C++ we can kind
of tweak C++ and break it in various
ways but at some point you really have
this created a new language at that
point but definitely today which in
terms of backwards compatibility there's
just no way that we could actually bolt
on safety to C++ you can add all the
static analysis you want we actually
talked to tons and tons of people in
various aspects of industry there they
all have huge amounts of static analysis
but everything everything falls down at
some point everything it catches 90 95
percent of bugs but that 5% leaking
through is still going to have memory
and safety security vulnerabilities and
all that good stuff yes
yeah
so the question is one of the great
things about an existing language is we
already have tons of libraries we have
decades of code decades of experience
writing all this so how is Russ going to
do on this how is rust gonna kind of get
these libraries bootstrap to get this up
and running how's the community running
so what I would say to that is this is
where crates at i/o has been absolutely
critical to having it there for rust 1.0
with krisily oh it's incredibly easy to
share libraries to share our code it
kind of we've reduced the barrier of
entry to writing Russ code and kind of
publishing it getting getting everyone's
access to it to a very very small amount
and this this is kind of coupled with
there are not many other systems
languages or like I mean you'd never
find a package manager for c and c++
like to actually build the cnc of c++
itself which is uniform across all
projects so cargo has been also
absolutely instrumental here in terms of
making it very easy to depend on
everyone else's code so it's kind of
reducing friction as much as possible
and making it easy to jump in there so
we ourselves are trying to lead the like
we've led the way in terms of
stabilization of the standard library
like we have set some common idioms for
the language some kind of common
interfaces but the the libraries
themselves we unfortunately don't have
the manpower to kind of invest in these
very very high quality very large
libraries that one might expect so we
have implementations in existence today
but they're kind of in progress their
works works in progress and they're all
kind of open source so it's definitely a
downside this is something that will
take time to kind of flush out these
common libraries you would expect and
see in C++ in rust itself but the
definitely a lot of the large ones are
either although very much underway
feature complete or they're there on the
other on the way coming that extras
question yes
you have fares like base which has a lot
of these common abstractions really
standard library type stuff that you
know a really big project like browser
so does servo to find those sorts of
abstractions for itself or you intend
the standard library for us to be the
standard library yeah so the question is
kind of where do we see the standard
library going is it going to be very
large standard library with tons and
tons of things for example it's very
heavily influenced by servo in terms of
their needs and how those two are going
to play out whether servo has its own
standard library so what we have taken
the approach we've taken with the
standard library today is a fairly
conservative so it's not a very large
standard library I would not use the
adjective batteries included to describe
it and the reason for this is having
going through the whole stabilization
process there just wasn't enough that we
felt comfortable stabilizing it'll do
something very but I so I suspect so
servo has at this point like a hundred
and fifty crates that it's depending on
like 150 various libraries that are
being built through cargo so they're
kind of taking the same aspect of
they're not probably not going to create
one monolithic standard library but
rather have lots of little components
here and there so the role of the RUS
standard library is going to be to
define the common interface for the
entire language so iterators vectors
hashmaps op the option type the result
type these common abstractions you see
basically 99% of rusts code all over the
place that belongs to the standard
library once you start getting above
that like some various like futures or
various weird concurrency primitives
those might be outside the standard
library but kind of in their standalone
crates but we still kind of officially
support them so I suspect the trajectory
over time is to stay with a relatively
conservative standard library but a
relatively very diverse set of crates
that are very small that just build on
top of the standard library and kind of
work like that yes a lot of the code I
work on are kind of unique in a way that
they're not making Laura interested in
right I mean but there's this core
library in C or C++ usually and
everybody's using and my question is how
are you doing things around interfacing
with our language wrapping stuff and how
would you handle base the safety in such
before
so the question is about how rust
interacts with other languages and kind
of how we deal with the safety around
that in terms of talking to big projects
elsewhere so this is a very important
aspect of rust we know that rust the
world is not going to be written
rewritten in rust overnight we got to
deal with existing libraries so rust has
the FFI boundary of rust allows you this
kind of call on external languages it's
just a call instruction there's no
overhead from this it's good exactly
what you would expect from C so an
example this is a cargo the package
manager uses lib get to which is a
library written C for managing git
repositories and we just call straight
out to that and then the to maintain the
safety of rust itself is where ownership
and borrowing and lifetime comes in two
lifetimes come into play so that's where
you can create a safe abstraction around
calling these unsafe libraries so you
typically have like the C API is
typically have a method of saying like
here's when you create the resource and
then you D allocate it when it goes it
goes out of scope so for example the
destructor for that type would call the
free function and then when you access
an internal value you know you have the
ability to kind of tie the lifetimes
together so I can return something that
says this is only valid while this
struct is valid so you can kind of
construct you can add basically the rust
type system on top of an existing C API
so you can kind of use these static
guarantees of rust this ownership and
borrowing mutable references being
unique all that good stuff to kind of
maintain the safety is you have to be
the one that actually creates that API
and creates the the safe interface to it
at NSU question yes and so the question
is how do I manage the quality and the
safety of the crates and crates that I
own and this is actually very resting
question so the quality itself we have a
small set of crates that we kind of
curate like they're hosted in the
rustling organization itself so we I
would not describe them all as
incredibly high quality but we maintain
them with we fix bugs we push updates we
have a lot of continuous integration for
them but in general you don't actually
have this kind of guarantee of quality
you don't know the tests are running you
don't know that it works on your
platforms this stuff that we would like
to expand to in the future but it's not
something that we're kind of actively
pursuing in kind of we're not going to
give CI to the whole Russ community well
very very strongly encourage you to kind
of use Travis or use that they or
whatever open source solution you want
but you don't have this strong guarantee
coming in you have to
of know that you have to be like Google
around no the libraries that have time
and it's kind of the same thing with
safety you there's not exactly a badge
on Chrysler that says this is this crate
has unsafe you can't use it or if you
use it you might have unsafe code so the
community is very active in terms of
these kind of high profile libraries if
there's unsafe code inside and actually
is legitimately unsafe then bug reports
will be open that'll be fixed very
quickly but overall we don't kind of
have like a we don't actively curate
crates in terms of like auditing them
for security or auditing them for
quality or anything like that yeah oh so
the question is what do we do about
ownership of crates in terms of what if
the original owner just disappears and
we have systems for kind of like we can
transfer ownership of crates here we can
transfer ownership between owners or I
mean if there's just if someone's random
create ends up disappearing then we
probably don't take ownership of it
we're not we're not holding ourselves
responsible for all libraries in
Cristian krisily Oh in the back
question is what is the performance of
rust look like because we're using LOV M
as a back-end kind of relative to clang
and I can say we're basically on par
with C++ where we don't we don't like
disable any optimizations or we don't
have any other fancy trick or you're
going on there but if you use rust
you're going to get basically what you
would get in C++ I don't is there a
remote question or I don't it's which -
I think it promotes huh
yeah you're doing a lot of type checking
to get these guarantees is that
drastically increasing your compile time
and is that scaling significance for
project sizes or point where project
scale tend gets unwieldy especially for
area of development I'm not gonna repeat
this because was online but anyway yes
so this is an interesting question and
the compilation model for rust is fairly
different than C++ so in C++ you kind of
compile one object at a time and you
include all your headers parcel headers
but rust it's actually essentially a
library at a time it's a crate at a time
so when you when you compile a rust
crate you kind of impact compiling
essentially all the C++ files at the
same time kind of in similar models so
in that sense the compile time for for
like the a terminal compile time for one
Russ library is going to be higher than
a C++ library because you have to
recompile the entire library but in
terms of type checking it's
fundamentally a way faster than C++
because we have we use traits through in
our generics we do not need to type
check and after we've instantiated them
so we can type check everything once and
then we don't have to worry about
worried about it ever again and when you
depend on an upstream crate so for
example if I include some header file
from a C++ library I don't have to
retype check that every single time we
run the compiler so compile times are a
little bit of a problem today in terms
of because we're compiling all these big
crates
so we're there's a lot of efforts
underway to like even today and by the
end of the year we're probably going to
have incremental compilation pipeline
compilation and parallel compilation
kind of all these great aspects but on
in terms of kind of just the raw compile
time which you'd expect today if you
start from zero rust code will compile a
little bit faster than C++ if you can
learn an incremental fashion C++ might
be a little faster because we don't have
think repeal aspects and I think there
was one other aspect
your question or did a halyard hit all
your points Oh scalability yes
so scalability I think it definitely
scales quite well today like we haven't
run into lots of problems like a lot of
times we because the compile time for
one crate can be a little high we might
have to break that break that library
into two separate crates but that's kind
of generally a good exercise to do
anyway but servo has not had problems
with compile times of that would not be
solved with an incremental compilation
for example uh just for reference bye hi
I'm Shane where I work on clang no Liam
uh but I want to let you know that the
Kline compiler spends almost no time
type checking C++ it's not really
measurable as part of C++ compile time
for us so type checking is never a
compile time problem that we have run
into interesting um Alex sure are you
aware of any what's the largest rest
codebase you're aware of on the client
and also on the server if any so the
largest of the two largest russ code
bases I know of our servo and rust I
don't know if you would Clara like in
terms of like a server client or like an
HTTP server or an HTTP client I don't
think we have that large code bases like
we don't have it's not quite the niche
that rust is feeling right now so those
would be the two I guess you could
qualify server was a client as opposed
to a server but in terms of like the
largest server I know a crease that IO
is entirely written in rust but that's
kind of that would be the largest one
that I personally know of cute a
question the question is how good is the
debugging support you bucks
in China sure so the story here is if
you can debug C++ you can debug rust so
we use LVM as a back end we have debug
info through that we have dwarf debug
info we have gdb or you have like gdb
integration in terms of like pretty
printers um so if you can debug C++ you
can debug rust so whatever you would
expect to do there you can just use the
same thing because as we're using LLVM
is a back-end it's all just native
object files we're using this
system linker and all that good stuff so
the just the standard C++ tools and this
applies to profiling testing all these
kinds of various analyses will apply to
rust as well one more question
all right thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>