<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AQC 2016 - Max-k-SAT, Multi-Body Frustration, &amp; Multi-Body Sampling on a Two Local Ising System | Coder Coacher - Coaching Coders</title><meta content="AQC 2016 - Max-k-SAT, Multi-Body Frustration, &amp; Multi-Body Sampling on a Two Local Ising System - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AQC 2016 - Max-k-SAT, Multi-Body Frustration, &amp; Multi-Body Sampling on a Two Local Ising System</b></h2><h5 class="post__date">2016-10-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aC-6hg_h3EA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my talk is on max at multibody
frustration and multibody sampling on to
localizing systems um this work was done
with many collaborators in particular
Paul Warburton his in the room here on
the way a lot of this came about was
things that we were first thinking about
for building couplers and then we could
realize realized we could use the same
kinds of ideas for many other
applications which I'll talk about um
first I'll just go over the basic idea
very briefly um it was already gone
through in much more detail in Paul's
presentation and also we have a paper on
the archive that people can look at for
the details um I talked about as
spectral mapping with icing spins and
then briefly go over to applications one
for decoding ad what's turbo code which
is a way of encoding classical
information like for a cell phone or
something or and then another which is
quantum particle simulation which I'll
discuss um so first let's talk about um
what we're not doing which is the
penalty formalism for sat so in this
case you're looking to ask whether a set
of causes can be satisfied um and you
say if the clauses can be satisfied we
wanted energy of zero if they can't be
satisfied we want an energy bigger than
some gap we want it bigger than some gap
so we don't have spurious low energy
states that will confuse our algorithm
but we don't really care how much bigger
it is than that gap we just want it
bigger on the other hand if you penalize
every Clause violation equally then even
if your clauses cannot be all
simultaneously satisfied your solution
will still be the solution that
satisfies the most number of clauses
this method does involve an sylla's so
this is all assuming the in cells reach
the ground state I'll explain very
briefly how that's done another point is
as long as you have a good
spectral separation of your spurious
States you can also use this for to
generate a Boltzmann distribution for
sampling or yeah so very brief
introduction what we did this can be
found in the archive paper which is
listed up there on basically we take
advantage of symmetry on we create a
fully connected graph between the
logical bits um connect those two some
antilla bits by carefully choosing and
then those n celibates if we arrange it
right will effectively count the number
of logical bits that are up using this
we can build on well for one we could
build couplers but we could also create
clauses um and for exactly what fields
and couplings we choose I refer you to
the paper um so a simple example is what
if we can choose those crows in this way
those are the until eval use on that we
would have in the ground state forgiven
logical bit values by applying local
fields on these M sylla's we can make it
so that every state except for the 000
state has an energy of 0 and the 0 0 of
0 state has an energy of G this would be
an or claws on only the state where none
of them are true are done on just as a
brief aside um you don't have to choose
these armed in such a way that you're
actually creating a degeneracy you could
just use and use the same idea for
nonlinear constraint on the number of
logical bits that are up I'm not going
to talk much about this anymore ah for
the rest of the talk but even though
what I focus on is things like sap
problems there's no reason there's no
fundamental reason things have to be
sort of discretized in this way you
could arbitrarily assign energies and
then have a nonlinear constraint on the
number of bits that are up in this in
this gadget arm so one thing that you
can do
with this kind of gadget that was
actually the subject of our recent
archive paper is you can use the Troy
minor embedding plus having some Ansel
is hanging off to put a sap problem on a
max at problem on the Chimera um what
I've shown here is actually an ex or sad
if you look at carefully but you could
do the same thing with the SAT um and
yeah this however has some drawbacks um
first off you need the high connectivity
that makes it relatively inefficient arm
secondly and this is a more subtle thing
is some clauses you actually can't make
very efficiently this way I'm for
example this clauses with alternating
ands and ORS if you try to count the
number of Ansul as you need for that it
grows exponentially with the number of
those parameters on however I'm going to
show some new ideas on how those
problems can be addressed after giving a
brief one side aside about on another
way of implementing these x or type
things which is somewhat similar to our
thing but um but was discovered by a
different group is about the some of the
ideas that Wolfgang lechner and others
recently put up we're on to do a parity
check Clause you create just a chain of
three locals ah in addition to some
ansibles there on there you could use
our gadget to create three locals are
also other gadgets to do this um and I
just want to point out that this does
the same has the same idea where it
reproduces the whole spectrum however on
what happens is if the clauses are
satisfied these an still is in the
middle act like just like a spin chain
if that one if they can't all be if it
the parodies the other direction they
cannot be satisfied it acts like a spin
chain with the domain wall so it creates
a degeneracy which would be bad for an
application like sampling however you
could easily just weak in one of these
on so this could do in the case of X or
this could do the same kind of thing
we're looking at but it can't be
generalized to other clauses so after
that aside let's come back to what we
can do with this to create these
problems more efficiently um so let's
imagine just the two bit version of our
gadget um now this seems like a really
dumb thing to do at first because we
have we already have two local couplers
and fields so why would anyone ever want
to do this you're recreating something
you already have I'm just naturally on
the device however there's something
interesting that happens with this is
these ancilla actually indicate what the
ahhh what the value would be of either
an aunt or an or arm you can stack two
of these gadgets on top of each other is
one way to create something that will
love letter will indicate a value of an
X or between two of them um basically
just apply a gadget to the aunt ilysm
another gadget if you wanted an
indicator of that you could also just
use a gadget for three local um there's
um several of those that have been
proposed that or don't require three
bits like our three and sell like ours
would but only require a single one so
what you can do now that I've already
kind of hinted at is if you take these
and cilla bits and feed them back in to
other gadgets you can actually create
bits we're applying a local field on one
of these bits higher up in this
structure on in this hierarchical
structure will create a effectively a
complicated cause or create a penalty
that corresponds to a complex clause and
you can imagine you can do this
efficiently for any clause that can be
written down efficiently um any closet
you can write down
using and or xor in parenthesis you
could also efficiently create this way
also it doesn't require a fully
connected graph this isn't we haven't
published this yet this is something
that we're currently working on but um
seems pretty exciting I think we should
be able to do some interesting things
with this um and yeah so let's talk
about an example of this arm and let's
talk about an example that just uses the
xor clause or parity checks um which is
a so-called turbo code what a turbo code
is is it what's called an it's what's
known as an interleaved convolutional
code on basically all the odd parity
checks you do on the bits in let's say
one order you assign one two three four
five six in this case it's with six but
you could be with any number in in real
practical applications with very many
then for the even ones you do some other
random permutation and apply these and
this has been shown to be a good way to
decode classical communications to send
so you can embed a decoder for this
using um our idea using basically a
stack of these three local embeddings
one thing to note is that in the case of
XOR this is very similar to an idea that
on the Simon Benjamin group have
recently proposed however they they
don't look at other clauses on and I
give the archive number of their paper
right there for those who are curious um
so now let's talk about a different
application which is what if you wanted
to use these because we can make higher
locality terms in addition to two saat
things um so I'm going to it's another
example of the XOR or higher locality
terms depending what language you like
but let's talk about particle simulation
so what you could imagine doing is you
could imagine creating high low
terms and having your individual spins
which are the red dots there on between
each of them touch exactly two of these
high locality couplers and then on yeah
and you can imagine doing that so then
what happens is if you flip one of these
spins you'll frustrate two of those high
locality couplers and then if you flip a
spin that's already touching one of
these on it will unfree one coupler and
frustrate the next one effect and then
if there are two that are already
frustrated flipping one will unfree so
you can imagine this creates effectively
a particle Hamiltonian that's a higher
dimensional analog of a one dimensional
domain wall on so yeah exactly it will
leave strings behind just like a domain
wall will will there where the spin
behind it will flip on but this yeah
yeah I show here examples for a square
and hexagonal lattice you could imagine
doing it for other things um so the
question is what happens if rather than
doing this with real couplers on we do
this with our gadget well if we do this
with our gadget and look perturbatively
to look at the lowest order of
perturbation theory where something
interesting happens where you can
actually flip a logical spin on some
things go right and some things go wrong
the things that go right is all logical
bit flips occur at three third order of
perturbation theory if all of these
touch exactly two that's good if some
logical bit flips required um flipping
to insula one ancilla and one bit
whereas others required flipping to
until is in a single logical bit that
would immediately be bad because it's
different orders of perturbation theory
for different processes different
particle creation and annihilation or
translation processes and all of these
transitions go through intermediate
state go through the same number of
inner they're the same
number of paths to make these
transitions and they all go through
these intermediate states with the same
energy now you can this is sort of
difficult to believe I'm just presenting
this and haven't given the details of
what the fields are but if you go
through our papers it works and if you
go through and actually calculate
perturbatively what Dolph diagonal
elements of this Hamiltonian are that
works what doesn't work is something
subtle the second-order fluctuations are
not the same for every logical state
we're looking at third order of
perturbation theory so what matters here
are second order fluctuations we're a
bit flips and then flips back and that
will have an effect will create an
effective potential on the perturbative
Hamiltonian we realize so if we just do
this naively with our gadgets on it
almost works all the transition rates at
some order of perturbation theory are
the same and you get a perturbative
simulation of particles however it
doesn't work because you get effectively
these potentials that prefer some states
over others but there's a fixed if you
add an additional ancilla that you
attach to the N sellers with different
strengths you make all those couplers
different strengths you can effectively
tune by how easy it is to flip that on
what it called Sigma F the spin to
control the fluctuations you can
effectively tune how strongly the
fluctuations will be about different
logical states in in the system again
assuming mansilla are in their ground
state on and I looked at this
numerically it does seem to work um
there's also no reason you would have to
only use one in principle if you wanted
needed more to control your fluctuations
or wanted more you could do that you
might be able to do it in different ways
but um it appears that in this way you
can actually perturbatively now um okay
Vic it um perturbatively now create
these um effective
particle hamiltonians are really the
particles that leave strings but they're
effectively particle Hamiltonians the
that you can realize perturbatively um
on using this it's device by the amount
of ah by the fields you apply to the
antilla you can affect you can create
both mass and you can create things like
string tension for the strings they
leave behind it things like that and
string interactions and all kinds of
things like that um so um that being
said we have there's here's our
conclusions as an we have made an
alternative method for mapping problems
based on max at problem formalism
individual we can now with our new
technique we can do any cause that you
can write efficiently you can do
efficiently this way unlike what we have
in our current paper where there's only
some that you can do efficiently some
will be inefficient and then I gave a
couple examples on this classical
message decoding with the turbo code and
talked about some ways you could realize
hamiltonians perturbatively using
basically taking advantage of the fact
that our gadget was built off of
symmetry it has a high degree of
symmetry and that means that the
transitions are just happened to all
work out to be the same on and I believe
that's it I will give a quick plug for
some my other work it's not related to
this but um might be of interest to some
people and I think that's okay
Russians could you say a little bit
about how efficient this this method is
you say that it's efficient but I can
you give some maybe numerical examples
for example if you're trying to encode
them a Mac set problem with a thousand
clauses and three variables per clause I
that's what that actually meant I
haven't looked in a lot of detail all I
meant was that it was efficient compared
to our other method so on our other
method has some clauses that on would
require exponential an exponentially
growing number of antilla to realize on
this new idea does not on so in that
complexity theory sense it's efficient
in is it better than some other things
someone else has come up with we'll have
to see more questions okay let's thank
Nick again
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>