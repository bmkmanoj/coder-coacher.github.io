<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Paradigm Regained: Abstraction Mechanisms for Access Control | Coder Coacher - Coaching Coders</title><meta content="Paradigm Regained: Abstraction Mechanisms for Access Control - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Paradigm Regained: Abstraction Mechanisms for Access Control</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oE3x_gM3YFU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thanks thanks for coming
today before I introduce our guest I'd
like to remind everybody that this is
going to go out on google video to the
public and our speaker has not signed an
NDA so please avoid for both those
reasons to avoid asking him secret
questions with that it's my pleasure to
introduce you Mark Miller mark worked
with mark many years ago and it was from
among other reasons of working with him
it was made that job hard to get a job
especially wonderful for me mark is I
think the most intellectually honest
person I know myself included and so it
makes me very happy that he's doing the
interesting and important research that
he's doing and he's here today to tell
you a bit about that including some
history of authorization based access
control and it so its history and about
how it's progressed since then and
what's happening these days so thank you
very much and here's mark okay so I'm
with the virus safe computing initiative
of HP Labs this is a second talk in the
series by just a poll of the audience
how many people saw Allen's talked last
week just want to know how much context
I should assume okay so for those who
did see excuse a little bit of
repetition there's not going to be much
in a case our approach to virus safety
as Alan mentioned last week is not
conventional the conventional means of
dealing with access control the
conventional paradigm of security that
dominates today's world is identity
based access control access control
based on first asking the question who
are you and this approach after 40 years
has left us vulnerable to viruses
malware phishing attacks as has
basically resulted in
today's massive computer security
failure the approach that we're taking
which we've been calling authorization
based access control where the starts is
based on having the first question be is
this request authorized and this
paradigm also goes back 40 years it
predates the current plague of malware
that's investing us so the world made a
choice between these paradigms and went
down one path well before it was faced
with today's problems so today I'm going
to be examining the history of the path
not taken explaining a little bit about
why it wasn't taken and trying to
explain both how and why we should now
be seeking to get on that path so the
path not taken authorization based
access control has a curious history it
has a history of formal analyses that
were largely negative and practice which
was largely positive it has a repeated
history where the practitioners had
accomplished some particular end and
then often after the practitioners
succeeded at accomplishing that end the
theorists went on to prove that within
this paradigm that end was impossible
could not be achieved what are we to
make of this repeated interleaved
history of impossibility proofs and
existence proofs so just to recap the
history briefly the first authorization
based access control system was Dennison
Van Horn's supervisor was an operating
system design that was
I paper design as of 65 it was
approximately implemented on the PDP one
around 69 271 I believe and it actually
has all of the fundamental elements in
it well before there was any widespread
understanding of what to do with those
elements the interesting thing about
going back and reading their paper is
this paper was written before the
computer field had divided into separate
specialties that did not talk to each
other when you read this paper you find
security hardly mentioned at all as a
separate concern they were seeking one
set of mechanisms to deal with issues of
abstraction modularity naming and access
control they saw the problems as a
single fabric and they they had they
approach these problems from the
perspective that a single unified set of
mechanisms could that were that it could
address abstraction modularity and
security concerns together in 1974 um
Radel showed an abstraction pattern an
abstract abstraction called the
caretaker that showed how to do patterns
of selective revocation of revocable
delegation so that I could hand out a
privilege to several different parties
and then revoke it for some of them
while still having the privilege
outstanding for others despite Radel
showing how to do this with a
abstraction pattern in 74 there was
repeated statements that revocation was
impossible in capability systems
including in many very influential
papers as recently as 2003 the in also
in the early 70s
lampson had many very influential pieces
of work a capability operating system
called Cal TSS and then the papers
protection and confinement protection
created the first formal model of access
control and within that formal model he
had a proposed formal statement of act
of both capabilities and access control
us a capable is I'm sorry I should
clarify capabilities is the primary
means of realizing authorization based
access control ackles are the primary
means of realizing identity based access
control you can you can express either
form of access control in either
framework but i'll be speaking in this
within the context of this talk unless
there's questions i'll be speaking about
capabilities as a means of achieving
authorization based access control and
ackles as a means of achieving identity
based access control on any case so lamp
sins protection introduced a more formal
model for comparing access control
systems and within that expressed the
capability and the Apple model lampson
also created the first really important
challenge problem for evaluating
capability systems and comparing them
which was the confinement problem off
often cited many claims of achieving it
many claims of impossibilities of
achieving it as well make claims that
various systems couldn't achieve it and
in fact one of the important facts is
that the model of capabilities explained
in protection the formal model that was
then used for many formal analyses was a
formal model of capabilities that were
we that was weaker than the actual
system of capabilities in the denison
van horn supervisor and in particular it
was weak in such a way that it could not
solve the confinement problem and the
weakness of the model
compared to what Denison van horn had
actually done is as far as I can tell
previously unnoticed or unnoticed within
that timeframe Keiko's in the 80s showed
how to do a confinement and the star
properties and it did it in the same
style that Radel immunity in which Radel
solved revocation it did it by showing a
pattern showing a set of abstractions
that composed together to solve the
problem the star properties were another
challenge problem that comes from the
military has to do with the flow of
information between security levels
secret top secret was it was military
was putting a lot of money into systems
that were seeking to solve that problem
so it was driving a lot of the attention
so Kiko showed how to do this using
abstraction in 1984 boberg wrote a
famous paper titled on the inability of
a modify of an unmodified capability
system to solve the star properties
which was then cited many times by
including by several award-winning and
and and famous papers over and over
again often this quoted as stating why
capabilities couldn't solve the
confinement problem and many of these
papers were citing it as an
impossibility well after Kiko showed how
to do both confinement and the star
properties and the kikos patterns were
expressible using only the elements
present in denison van horn supervisor
so we have a very weird history here um
what's going on is it just that people
weren't aware of each other I mean this
was before there was a Google before
there was a Wikipedia before there was
an internet but the computer science
field as a whole was also smaller there
were there there there wasn't as much to
pay attention to this is simply a lack
of attention
or is there some deeper source for the
confusion so I've been doing a I've been
going back over the works of people in
the various schools and the attempt to
address each other's objections and what
finally became clear to me is these the
two schools of thought here we're using
the same terminology to try to talk to
each other while using the same terms to
mean different concepts there is an
important distinction that neither side
realized in trying to talk to the other
so we've we've been calling the
distinction the distinction between
permission and authority we've decided
to use the term permission for one side
of this distinction and the term
authority for the other and essentially
what the difference is is the difference
between causes and effects permission is
the issue of what actions are directly
allowed so when you do you know a
chamada and eunuchs and I permit you to
read a file that's permission as far as
the security system itself is concerned
you can say well does dan have
permission to read the file we can look
it up and say aha Dan's on the access
control list or ease or is the owner and
it's whatever and he has permission to
read the thought but let's say that now
do I have permission to read the file
well I'm not on the access list I'm not
in the group I don't have permission to
read the file but that doesn't answer
the question can I read the file if
Dan's running a web server in his
account executing with Dan's permission
and Dan gives me the ability to access
his web server his web server serves
pages from the including that file then
I can read the file so I have authority
to read the file where the authority is
the effect brought about by the allowed
action
by the composition of causes so Dan's
permission to read the file Dan's
permitted a choice to run a web server
serving files that Dan can read and my
permission to talk to Dan and thereby
talk to a web server that he runs the
composition of these individual
permissions and the choices that Dan has
the allowed choices that Dan has made
within the architecture composed to
create the effect that I can read the
file so the problem is causality is very
difficult to reason about formal it's
it's very resistant to formal analysis
so the permission is very well
illuminated by the lamp post of formal
analysis so the the the abstract
theorists attempting to understand what
isn't is impossible in a security
architecture we're looking for the keys
to security in the in the well
illuminated permissions the
practitioners building capability
systems especially you know the
practitioners who surrounding the Kiko's
operating system their intuitions like
the intuitions of any actual programmer
dealing with you know writing programs
to deal with problems our intuitions
about cause and effect intuitions having
to do with causality and they were
seeking to control authority now the
problem is that if you're doing a
permissions analysis the permissions
analysis seems to support various
fantasies of centralized control in
particular regarding delegation for the
permissions analysis support the fantasy
that I can give Dan permission to read a
file
I can not give Marcus permission to read
the file and that I've accomplished
something by preventing dan from
delegating to Marcus the permission to
read the thought with the fantasies of
centralized control with the fat with
various notions of what a security
architecture should be able to do the
capability architectures and more
generally the authorization based access
control architectures obviously did not
support those fantasies so people who
harbored those fantasies um could look
at capabilities and the formal analysis
was supportive of their intuitions that
there's a real weakness there because
it's obviously can't achieve something
we think we should be able to achieve
the permissions based analysis of access
control lists seemed to support the
ability to achieve these things and the
authority based analysis shows that
still shows that those goals are
impossible to achieve but those results
aren't as obvious
so the result is that there is a set of
myths that accumulated regarding
capabilities all the quotes in here are
quotes from a word winning or famous
papers and also various other variants
on the capability paradigm rows that
were weak in very much in the same way
that lamson's model capabilities were
weak so you often hear about
capabilities as rows of the access
matrix capabilities as tickets or keys
you often hear capabilities labels as
discretionary what all these means mean
are variants of the capability model
weaker than the than the actual
capabilities and denison that hardens so
we've done is we've done is we've we've
labeled what Denison phone Warren
implemented as object capabilities the
abstraction and modularity mechanisms
that they proposed are in fact very much
along the lines of the distraction of
modularity mechanisms in object-oriented
programming in the lambda calculus that
have provided computer sciences great
successes of building composable modular
software that has given rise to the
ever-increasing functionality of the
systems that we have the result of these
accumulated myths on access control in
the world taking the I back path is that
we have the SAT we're left today with
the sad result that Allen showed last
week which is whenever you run any
program like solitaire you give the
program all of your authority this
program can delete any file that you can
delete this is insanity this leaves us
open to today's malware which is a very
different kind of threat than the
threats that people were concerned with
when they chin they did that early
choice of hats what's going on here why
why do you give solitaire some so much
of your authority when you run it why
don't you give it just the authority
that it needs um well the choices you
have today is you can run it as an
application
giving it all of your all the all of the
users authority which is dangerous but
has all of the functionality that our
systems are built to support or you can
run it as an applet giving it
essentially no authority in which case
it's safe but it's essentially useless
which is why applets haven't happened
and why the current Ajax path that that
Google is currently on with using
javascript which is similarly sandboxed
in the browser why that leaves the Ajax
path having to compete with the hand
tied behind their back because you can't
incrementally authorize the program the
sandbox program with the authorities
that it needs to function stava has
explored with the java web starts
various kinds of static sandboxing that
our usability disaster is and it will
only allow you to trade off safety for
functionality and unsatisfying way
firewalls are neither safe nor are not
safe but still have a tremendous cost in
integration across organizations and of
course anytime anybody shows a diagram
like this what they're going to then
advocate is in the upper right hand
corner and this talk is no exception so
what's the path to usable least
authority pole is the principle of least
authority how do you provide programs
adequate authority so they can provide
the functionality you need while still
denying them any authority in excess of
that that would enable abuse and how do
you do that in a usable fashion well the
key is what we call dynamic least
authority and the dynamic is the key to
dynamic least authority we saw it at the
user interface level last week which is
to bundle the active designation with
the active authorization
the it's when the dynamically when the
request is made that you when you're
making a request of something that's
when you're providing it the information
about what you wanted to add to to
operate on it's not until then that
there exists enough information to know
what the least authority it is to do
what job is being asked of it because
it's not until then that you know what
objects it needs to operate on in order
to do that job so by having the act of
designating what you want it to operate
on be the act of providing it the
authority that it needs to operate on
that object we end up with no extra
mechanism in the authorization pathway
in order to provide applications the
least authority that they need that's
still adequate to provide all the
functionality we associate with that
with applications what does this mean at
the programming language level or at the
operating system level let's let's now
zoom in from the user interface
so the issue about what's the least
authority something needs to do the job
we would like that authority not to be
excessively brought only if that
authority is narrow do we gain safety
from practicing Paula well it turns out
how narrow that is depends crucially on
issues that are not normally thought to
be even relevant to security the issue
of how of how one names things how one
designates over here we have to unix
shell command lines that do essentially
the same job they both copy the file
food text to the file bar text and both
CP and cap like solitaire run with all
of the uses authority the actual the
actual danger to the user in these two
scenarios is the same which is the user
has turned over all of his interests the
program both CP and cat are actually run
with all the authority needed to destroy
the user's life however these two
examples are help illustrate differences
in what the least authority would be if
you are operating under the right
architecture in the case of CP CP is
provided with the two strings food food
text and bar dot txt and so and and CP
then turns around and does opens to open
food extra reading bar text for writing
in order for CP to do the job that's
being asked of it to do with in this
scenario it has it has to have access to
the st. to the user's name space of
files and it has to already have the
ability to read any file the user might
name to read and it needs the ability to
write any file the user might name to
write so CPS least authority is still
all of the use of authority of the file
system even if we ran CP under released
authority discipline it would still have
all the authority needed to destroy the
users life cat on the other hand the
user on the second command line is still
using names in the users name space to
say what files it wants cat to operate
on but but cats not given the strings
cat doesn't know or care what the names
of the files are those names are
essentially evaluated in the users name
space to opaque references to the
designated resources in this in the in
the case of UNIX file descriptors and
those opaque designators are then passed
to cat providing cat both the
information of what the user wants cat
to operate on and the authority cat
needs to operate on those files cat
needs no prior authority in order to do
the job users asking it to do in this
scenario the authority provided in the
request is all the authority that needs
to be conveyed to cap in order for it to
accomplish its action ok the object
capability paradigm can be applied both
at the operating system level and at the
programming language level as well it
was you know at various other mediums
I'll be speaking in programming language
terms a because it's more intuitive and
B because it means that i can use bits
of code to illustrate abstract points
it's also the centerpiece of my own
research the object capability an object
capability language is actually very
close to simply being an object language
in fact if you just take the normal
notion of an object language and you
remove from it all sources of causality
outside the object param you don't
remove anything inside the object
paradigm you just remove all other
sources of authority you end up
essentially with an object capability
language so the way it works is when
Ellis Ellis Bob and Carol are three
objects and Al
has two variables Bob and Carol that
refer to those two objects and Alice
invokes Bob of passing Bob a reference
to Carol copy of her access to Carol and
this is very much like the cat example
what Bob gets is an opaque reference to
Carol Bob gets something that the the
opaque reference gives Bob both the
information of what Alice wants him to
operate on and also gives Bob access to
so that he can he so that he can make
requests of Carol so he can so he has
access to what it is that Alice
designated the key thing is that by
removing all other sources of causality
Bob's only means I'm sorry Alice's only
means for effecting the world outside of
herself is according to the references
that she has on the she can only affect
the role outside result by sending
messages on those references and those
messages carry references causing
changes in the graph of who has access
to what bringing about acts of
authorization so by simply removing all
other sources of causality a memory safe
object language with encapsulation the
reference graph familiar from the
object-oriented programming literature
becomes identical to the access graph
from the access control literature yes
well I do want above to have a reference
comparable except
operating I don't mind Bob to say that
because my pity mat and optic network
propagating got capabilities until it
just becomes hospital so let me let me
postpone that question and let me give
you the label for where that question
will reappear in the talk the label is
communicating conspirators okay okay so
there's there's actually the notion of
an object capability language actually
goes back all the way to get Duncan in
1970 it's had a rich history most of the
history are is our languages that you've
probably never heard of the exciting
thing is the recent history is Lara is
leveraging the fact that object
languages and object capability
languages are so similar because both of
them leverage the essentially the same
abstraction mechanism the denison Van
Horn were exploring in their their
initial work yeah so Jay Colonel and
Joey are both based on Java emily is
based on o camel etc okay
the diagrams i'm going to use diagrams
and parallel with code and due to limits
of time i'm going to explain only the
diagrams people are quick enough that
picking up code can follow them in
parallel make a point is a function that
makes objects it's an object that makes
other objects so every time you call
make point it creates new points the
nesa the nesting here spatial
containment is lexical nesting the point
is defined within the scope of Meg point
it can see so any variables that are
that are in scope and make point are
visible to point and the stacking is
multiple instantiation within the scope
of make point every time make points
called it makes a new point so each
point has its own x and y variables so
in this case we're showing is that make
point is an object that functions as a
constructor or a class or a maker or a
factory depending on what your
terminology is and points are the
instances of that constructor and just
there a little bit of syntactic sugar he
is a pure object language I'm sure I'm
showing examples in E use per object
language the only thing that goes on
between objects is invocation message
sending but you'll but actual let's go
through it the you'll see what looks
like function definition sometimes
that's really just syntactic the
function definition syntax is just
syntactic sugar for defining an object
with a run method the function call
syntax is really just syntactic sugar
for invoking the run method of an object
and when you see operators like + it's
just syntactic sugar for sending an ADD
method so really all that's going on are
objects and message sets ok now let's
start to address your question ok so
when Alice
sends Bob a reference to Carol in an
object system as well as an object
capability system she's giving bout bob
unruh irrevocable permanent
unconditional access to carol and total
access to carol whatever can be done by
sending messages to Carol Bob can send
any of those messages that's will call
that unattended delegation and a lot of
the security properties that people have
argued about over the years come down to
various different ways of handling
delegation for example riddles pattern
of revocable delegation which we're
going to show here so so if alice wants
to give bob access to carol but only for
what he what she wants Bob no longer to
have access to Carol after some future
point in time um what she does is she
doesn't give Bob direct access to Carol
she interposes an intermediary and the
intermediary Radel called the caretaker
so she instantiates this intermediary
and the intermediary there's an object
called the caretaker what the caretaker
does is every time she gives Bob access
to the caretaker site of the
intermediary holds on to the revoke
aside the caretaker whenever it gets a
message such as a message from Bob it's
going to forward the message on to
whatever the current value of this
target variable is when Alice invokes
the revoke er that's going to set this
target variable to know and that will
prevent further messages from Bob for to
get from getting to Carol so from a
permissions based analysis everyone who
said capabilities cannot revoke access
capabilities in fact cannot revoke
permission
so the permission bob has been given is
permission to invoke the caretaker so if
bob says to the caretaker of Bob's name
for the caretaker let's say is Carol to
Carol to do this the caretaker will
forward that on to Carol if Alice says
to the revoke er revoke that sets the
target variable to null and now this
transitive line through the caretaker
pattern is showing Authority not
permission it's so it's showing based on
the behavior of the intermediary as
composed a composed together with the
permissions through the structure it's
so showing that that while this
structure is live while the caretaker
forwards messages Bob effectively has
authority to invoke operations on Carol
ie Bob can cause actions whose effects
are that the message do this is
delivered to Carol however after Alice
does the revoke the caretakers behavior
changes such that it no longer forwards
messages so when bob says Carol to do
that those messages no longer get
forward so the result is that no
permissions were revoked here so
everybody said capable is cannot revoke
their statement is correct on
permissions Bob still has access to the
caretaker the practice of actual object
capability practitioners which is not
captured by most of the formal theories
is the practice of building access
abstractions that's the paradigm that
we're regaining here by what the the
base level abstractions are references
permissions giving direct access the
abstractions of interposing
intermediaries are like building
smart references that give controlled
access in this case controlled by Alice
according to when she decides to revoke
other kinds of intermediary create
abstractions that that control the what
rights were delegated to Bob in
different ways okay the one of the the
greatest source of criticism of the
object capability model has to do with
the propagation of delegation which is
what we're showing here in this diagram
is that Alice has some some particular
access to some particular object perhaps
Carol that represents some power we who
ever can invoke this object has the
power to do some some particular things
and Alice would like to give this power
to Bob however Alice would this thought
the thought bubbles here are not what
else thinks but what Alice wants Alice
wants mallet not to have the power
mallet wants mallet to have the power
the two question marks here are a way of
developing a taxonomy of issues in
controlling delegation the two question
marks represent the two questions does
Bob want mallet to have the power in
other words our Bob's is Bob coated with
the intention of serving mallets
interests or is Bob coated with the
intention of serving alice's interests
and the other ? is does Bob properly
have access to mallet there Bob and
mallet properly in communication should
they be able to speak to each other
depending on the answers to these two
questions we can divide the remaining
issues in delegation into four sub
which I'll now go through if Bob is on
Alice's side I Bob's intention is to
serve Alice's interests then if Alice
doesn't want mallet to have the power
presumably Bob will act in a supportive
way and if Bob and mallet are not in
communication then the only remaining
question is perimeter security if is can
Bob break in and take it and any access
control architecture has to start by
assuming any security architecture of
any kind as to start by solving
perimeter security and all access
control work has to start from the
assumption that perimeter security has
been solved so we can now go go on to
the remaining problems okay lamson's
confinement problem says what if bob has
been coded to serve mallets interests
Bob and mallar is still not supposed to
be able to talk to each other but both
Bob and mallet would like Bob to wield
this power on in service of mallets
interests can Bob effectively delegate
the power to mallet despite the fact
they're not supposed to be in
communication and our third sub problem
is the confused deputy which Alan
referred to last week which is bob has
been is supposed to serve his clients
interests that I he's supposed to serve
in this scenario Alice's interests but
al but but let's say is separately coded
from app from alice alice is depending
on Bob to serve her interest so so alice
is entrusting the power to Bob Alice Bob
and mallet are properly in contact bob
is supposed to be serving requests from
mallet but without making the power in
question available to mallet I ease
supposed to make use of the power in
some limited way so that mallet doesn't
have all of the authority represented by
that power
now the security question comes down to
Ken mallet confuse Bob into accidentally
using the power on mallets behalf rather
than according to Alice's interests and
the final one final sub problem is
communicating conspirators which is bob
has been coded to serve mallets
interests Bob and mallet are properly in
contact can Bob and mallet beacon can
met Bob be given both given the power
and prevented from delegating the
authority to use the power to mount so
we get so we take the the two questions
each of which have two answers we
probably take the cross product and
we've got the four scenarios the
confused deputy is a talk by itself
which I am NOT I'm not going to talk
about today you can also google search
for it and get plenty of hits on the web
it's well explained on the web but these
are links to further material that are
prepared to answer questions about and
at this point I'm going to turn it over
to questions you can ask me about
anything not just to follow these
lengths but these are there so that
there are opportunity to 24 more
material to answer questions and let me
skip over that and just do some wrap up
slides here this is the the money
example which actually I'm going to say
a little bit about so Alan showed the
money example last week I'm also
prepared to to explain it but the point
I want to make with it is that um the
early computer security work was funded
by by you know was driven by the Express
needs of the military was driven by a
practice within corporations both of
which had
centralized models of control and both
of which saw delegation as the problem
and the propagation of delegation of the
problem and wanted to control delegation
and because that's the history of
challenge problems in terms of
controlling delegation that's the
history that has to be answered to
explain what happened however the modern
would that set of challenges is badly
suited to the modern world modern world
is one of decentralized cooperation
between organisations and among
individuals and for that world the the
issue the primary issue is not limit
delegation we should embrace delegation
delegation is our friend the entire
division of labor of the marketplace
giving rise to to the fact that I can
ask you to do something and you can
subcontract to somebody else etcetera
etc and that I don't even have to know
who it is you're subcontracting to this
decentralized activity we call
civilization is founded on chains of
delegation we should be seeking to
support delegation not to inhibit it but
we should be seen as a sport delegation
we should be seeking to do so in ways
that that work according to least
authority it's the excess authority that
we grant when we delegate anyway within
architectures not built to support least
authority delegation it's that excess
Authority is what has created the world
of massive failure of computer security
of viruses and other malware that is the
disaster of security that we're
currently living in coexisting with the
vast successes of functionality built on
the abstraction mechanisms that are
close kin of the
security mechanisms that I've shown
today okay questions okay yes can you
talk about the communicating
conspirators problem okay so
communicating conspirators is that link
takes us back into our caretaker example
what this is about is the the the answer
to the communicating conspirators
problem is that it cannot be solved the
fantasy that it can be is one of the one
was one of the terribly damaging
fantasies that lead people away from
capabilities because in a capability
architecture it obviously cannot be
solved so here is the demonstration of
why it can't be solved in any
architecture which is let's say that
we're in an access control list
architecture and now we've given Alice
permission to access Carol Carol is a
file we've done a chamada or whatever
we've given it Alice permission to
access Carol and we have not given Bob
or permission to access Carol well if
Alice practice practices least authority
anyway within this access control list
architecture then if she doesn't need
then let's say Alice but doesn't think
to try to give Bob permission because
that would give Bob too much authority
but else wants to give Bob some limited
permission so she imposes an
intermediary like a web server in our
previous example well this intermediary
execute with Alice's authority the the
permission Bob alice is giving to bob is
a permission to access her intermediary
bob no there's no attempt in this
scenario to give Bob permission to
access Carol so the fact that we went
out of our way to construct a security
architecture that could deny Bob a
permission to access Carol did nobody
any good but we could because Alice
interposing intermediary for reasons not
not because she was seeking to work
around the sleep with our prohibition
but for other reasons has inadvertently
thwarted the intent of the prohibition
so what state what let's state what's
being sought here and we can see why
it's impossible what's being sought in
the communicating conspirators problem
phrased in cause and effect terms is
that we want let's go back to the to the
scenario
which is Bob and mallet are stateful
there in communication so Bob can be can
be affected by mallets by Bob state can
be affected by communication with mallet
Bob can make use of the power Bob can
decide how to use the power in ways that
depend on his own state that's what
we're saying we're allowing what we're
disallowing is 44 mallet to use it to
use the power I e4 mallet to be able to
to exert causes that bring about effects
of the power used on mallets behalf the
statement of what we're prohibiting and
the statement of the party the initial
conditions of the problem are in fact
formally identical we've just used
different terms to fit to phrase it in
ways that seem to be in conflict
okay well once I in the absence of
questions i'll just keep speaking so
confinement okay yes so there I guess
it's danger is not put in character
saying Carol myself wonder wonderful yes
yes that's that's exactly that's exactly
right um so sorry oh yes repeat the
question so the the observation is that
this caretaker pattern is fragile this
is a correct observation the caretaker
pattern is only usable when Alice knows
enough about Carol's behavior to know
that Carol will not reveal to her
clients reveal in response to messages
direct authority to her or authority to
other things that Alice would have liked
to revoke so in fact that's exactly
that's correct you use the caretaker
itself only when alice is confident of
that carol behaves in such a limited way
then there is a similar pattern called
the membrane which in the same note in
the same language in e takes only 24
lines of code so it's you know too big
to fit on a slide but what it does is as
each reference comes in as an argument
or comes back as a result it gets
rewrapped essentially in another
caretaker and then the revoke action
revokes all of the transitively wrapped
references that have that have gone back
and forth over that membrane at the same
time so the the the what the membrane if
you surround something we call it a
membrane because as the thing that
that's that you've put it around expands
the membrane sort of expands to continue
to be a barrier between
it and its clients so it doesn't matter
how much it expands if further
references go back and forth across the
barrier just continues to expand is to
contain to stay inter pilots
and came
so
the on language design there is a
curious thing that happened which is
people following the object / lambda
calculus ab no abstraction mechanism
pathway have build for the sake of
abstraction module aryan functionality
languages supporting message passing
encapsulation memory safety garbage
collection etc and that and those
elements take you up to object-oriented
programming the there's now been enough
work on different kinds of secure
languages by the way that we can we can
now show that what the roadmap is in
hindsight we have the benefit of
hindsight for understanding the road map
so scheme had some some additional
elements lexical lexically nested
objects which turns out to be very
synergistic with a lot of object
capability patterns it makes a lot of
object capability patterns like the
caretaker very easy to express and it
has safe loading so you can load code
from other from untrusted sources and
know that the load that the gloated code
are is restricted to making use only of
the elements in the environment in which
the loaded code was evaluated so that's
a safe eval essentially Java and.net had
the misfortune of having gotten those
essentially those elements but some
further elements by the time they ask
themselves what about security so scheme
had the element the original set of
elements by the time a task itself well
how do we address security within the
contents of our language Java
additionally had mutable static
variables it had static native devices
like like file dot open devices I mean
native methods that enabled I owe to the
outside world
and they had this large accumulation of
libraries many of which were not written
to good modularity principles so but so
by the time they asked themselves what
to do about security those additional
elements made the answer very hard and
they kept adding mechanisms to java and
to.net you know dotnet essentially
following Java on this path they kept
adding mechanisms to seek security and
then declaring the result to be a
success and scheme on the other hand
having the earth at those initial set of
elements that in which causality is
still only along references and there's
control of scoping when they ask
themselves about security Jonathan
Reese's PhD thesis shows a variant of
scheme called w7 which is a very small
Delta from scheme essentially he was
able to just step across the barrier
into object capability security because
he was starting from a language that
didn't have those additional elements
what you need beyond that is for a
modern safe object capability system is
libraries written according to the
principle least authority as well as
safe reflection the lesson from this
road map drawn in hindsight is that the
detour on this road the thing that led
aab jaao VII and dot net into needing to
continue to add mechanism seemingly with
no end in sight is the sources of
causality outside the object paradigm to
get back on the road it's not so much
that we have to add things is that we
have to remove
the sources of causal access that took
us off the road this is not a loss of
functionality is just a loss of ability
to express the functionality in certain
non-modular ways yeah programming
language incited
so there's I don't understand
aspect-oriented programming well enough
to to make informed statements about the
the correspondence between the two I'll
state my concern but first of all the
answer the answer to your question about
whether people have looked at it is to
the best of my knowledge none of the
people concerned with achieving security
in this paradigm overlap with the people
who've been deep into the
aspect-oriented programming perspective
I'm not aware of anything in the
intersection of those two Marcus so you
know
David Wagner and Adrian nibbler Adrian
declar that perfectly are the people who
are creating Joey which is the object
capability version job okay so so he
said that they could do it's a good nail
updated and Adrian say
okay so eyes or anything anybody would
like me to expand on and if not we will
wrap up and I'm I'm available for for
further discussions okay well thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>