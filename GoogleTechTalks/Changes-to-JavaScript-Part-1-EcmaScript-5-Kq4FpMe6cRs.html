<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Changes to JavaScript, Part 1: EcmaScript 5 | Coder Coacher - Coaching Coders</title><meta content="Changes to JavaScript, Part 1: EcmaScript 5 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Changes to JavaScript, Part 1: EcmaScript 5</b></h2><h5 class="post__date">2009-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Kq4FpMe6cRs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone it's great to see so many of
you my name is Sahira and I'm
responsible for our standards activities
at Google as part of the research
organization reporting into vint cerf so
very pleased Aziz a good crowd here I'm
just a quick question how many of you
have attended two standards talked in
the past so we've done some on HTML C++
Akuma Naik Masari ATF ok so few hands
great so our role within the standards
group at Google is to really make it
easier for Googlers to participate in
standards and also so that we know who's
doing what within the organization so
that's really important and then also
our product teams to be connected with
people like the gentleman up here today
who are going to speak and the work that
they're doing within the standards
organizations and partly education on
standards as well so we have a website
if you type in go slash standards that's
where you'll find all the information
that you need and if you if there's
anything there that you need to know
please contact me at google.com and
without further ado I'm going to forward
pass on to Mark Miller and Mike Samuel
and well tomorrow it's for their
presentation today which has changes to
JavaScript it's part of part 1 of a
series Thanks
all right so I'm Mark Miller this is
Mike Samuel this is Walt Mohammed and
yeah today we'll be talking about
changes to JavaScript in this first talk
we're going to be talking about the
imminent next version of JavaScript
called ACMA script 5 to place ikema
script 5 in context let's recap a bit of
the history the last official version of
the javascript standard was Ekman script
3 that was published in 1999 since then
there have been several attempts at
feature-rich languages that have gone
under the name Eckman script for many
very good ideas were invented in that
context but none of those ever converged
into general agreement across the
committee then about 2 years ago there
was an divergent effort to create a
simpler successor language called Ekman
script 3-1 and that attempt at
simplification of putting fixing
problems ahead of adding features
eventually got committee wide consensus
to become the next major version of
javascript and in so doing got renamed
ACMA script 5 implementations of this
have been proceeding quickly Internet
Explorer and Mozilla Firefox are about
to release feature complete
implementations as betas there's also
been progress at opera at our own v8 not
yet as far as we know at Safari other
activities in committee are a working
group in committee has been formed to
standardize a secure variant of Ekman
script as a secure subset of ECMO script
5 and this effort is merging ideas from
our own caja project from the ad safe
project at Yahoo from Jacaranda and dojo
secure and what we call the ECMO script
harmony agreement is an agreement across
the committee where we we now have
general agreement on what the future
directions for ECMO script should be
after Ekman script 5 and I'm pleased to
report that
the general sense of that agreement I'm
confident that JavaScript will continue
to get better over time without becoming
overly complicated but today's talk is
on ECMO script 5 specifically to
understand the innovations of ECMO
script 5 we can organize them into three
broad themes the first theme is to
enable JavaScript library authors to be
more on a par with JavaScript platform
providers so right now the platform
provider is in particular the browser is
providing the Dom objects the the these
platform objects can have magical
properties that cannot be emulated in
JavaScript code so JavaScript code
standard JavaScript code cannot
transparently emulate the Dom objects
cannot be interposed between other
JavaScript code and Dom objects we want
to repair that the second theme is to
enable more robust programming
javascript was originally designed as a
language for small scale scripts for
casual programming it's proven to be a
very good language for novice
programmers in fact many people learn
JavaScript as their first language but
it's increasingly being used for very
large-scale serious programs whose
robustness is important and that's a
load that JavaScript was not originally
designed to bear and the strain is
showing so in our second theme were
trying to make JavaScript a better
platform for large-scale serious
programs without losing any of the
friendliness that javascript has
historically had for casual or novice
programmers and the third theme is is in
fact new features new features that
we're adding through new api's there
have been several libraries that have
provided api's that have shown
themselves to be generally useful and
popular in particular the prototype
library in the json library and Ekman
script 5 is promoting some of those well
proven features into becoming an
official part of the javascript library
to be provided
directly by the platform of the things
on the slide there's one interesting
puzzle which is JavaScript has many
inconsistencies many warts and
minefields that that that trip up both
novices and experts and we'll take you
through some of these in the talk the
puzzle is how can we improve the
language how can we remove some of these
inconsistencies while still operating
within the terrible terrible legacy
compatibility constraints that we
necessarily have to operate in so to
answer this question we need to
understand what it what the legacy
constraint really is what is it that we
need to be compatible with it's not the
letter of the Eckman Eckman script three
spec because the letter of the Ekman
script three spec is not what browsers
have actually implemented they've
implemented something close but with
some divergences and the real constraint
on any new spec is that it not break the
web that it be compatible with the
trillions of existing web pages the
corpus of web pages that have been
engineered to work across several of the
major browsers so the annoying
differences between browsers that make
writing cross browser pages so difficult
is ironically the what opened up the
opportunity for the committee to improve
the language what we were able to do is
say only behavior that exists across
browsers is behavior that the cross
browser web is is constrained to be
compatible with so we could choose that
rather than the letter of the ACMA
script three spec as the precedent so we
adopted in committee a rule of thumb
called the three out of four browser
rule and in addition we we tempered that
with experience and common sense
even with this this realization this
still didn't give us enough room to
improve the language to make to create a
space for saner programming for
programming with with with fewer
inconsistencies because these
compatibility constraints still caused
us to include too many things that we
would like to have removed so we
introduced one additional trick which
came from the earlier es4 proposed spec
which historically derives from Perl
which is the notion of an opt in use
strict directive the the point of this
directive is that with it can declare
that a certain body of code the code
within the scope of the directive is to
be considered strict code meaning that
the code should be interpreted according
to the rules of a somewhat simpler and
saner language so the changes from the
overall language to the script to the
strict sub language are mostly
subtractive this doesn't create a
compatibility break because the old
existing corpus of code on the web has
not opted in so none of the changes in
strict mode break that corpus for new
code strict mode is Bybee by having
fewer irregularities is better for both
novices and experts but there's still a
compatibility constraint we made strict
mode sufficiently close to the overall
language the non strict language that
code that's being maintained can port
easily but with some where can port
easily from non strict to strict and
that porting can be done in an
incremental fashion as you make parts of
your program compatible strict mode you
can you can declare it so by putting the
O strict directive on it and in so doing
incrementally gain the advantages of
greater robustness and probably a small
increase in performance okay so
going to our first theme putting
JavaScript programmers more on a par
with platform developers
what are these magical properties this
magical behavior that platform objects
have the JavaScript objects cannot the
first one we show by example with this
assignment to a Dom objects inner HTML
property that assignment in browsers
actually causes IO it changes the Dom
tree which causes a different rendering
to the user within standard JavaScript
code there's no way to create a property
that reacts to assignment by engaging in
activity the second example of a magical
property that the platform has that that
is currently denied to JavaScript
programmers is shown within the my two
string example all existing JavaScript
objects respond to the two string method
and the reason they do so is they
inherit to string the two string
property from object dot prototype so
even though all objects have a two
string property inherited from object
dot prototype if you enumerate the
properties of an object with a for in
loop you won't see the two string
property because it has a magic non
enumerable ax T which is this this
behavior of not showing up in foreign
loops but if you want to Devine your
design your own convenience to live
alongside object to string object
prototype to string which is my two
string
there's no way in existing JavaScript to
define that convenience without having
it show up in all of the foreign loops
that are running on your page to address
this first issue which is having reading
or assigning to properties cause
activity to invoke to to run code
Mozilla created what are called act what
we're now calling access or properties
which are properties that have getter
and setter methods attached to them the
getter is what
run when you read the property the
setter is what's run when you assign to
the property so the the value of the
property in its response to assignment
is design is is now designed
behaviorally according to the activity
of those methods other browsers several
other browsers followed Mozilla's re
lead but with divergence semantics ACMA
script five now codifies a agreed
semantics for getter setter properties
and provides an API for for defining
them the first way that getter setter
properties are defined access to
properties defined is by enhancing the
object literal syntax so over here we
see an object literal for defining Minar
own Dom would object which is an object
intended to act like a Dom object the
first line within the object literal is
the conventional object literal syntax
we're defining a property named foo
whose value is the string bar the second
two lines together show the new syntax
or where these two lines together are
defining a property named inner HTML the
first line here the gate line defines
the getter method so when you read the
property this code is run second line
defines the setter method when you
assign to the property the value
assigned gets bound to this new HTML
variable and this setter code is run you
can also define these by an API that
provides explicit control as we'll get
to later on the magical behaviors of
built-in properties the way the Ekman
script three semantics accounts for that
magical behavior is it describes the
behavior of existing properties in terms
of three boolean attributes which in the
Ekman script three language were called
read-only don t neumann don't delete to
avoid double negatives we've renamed
those writable enumerable and
configurable and configurable as a
slight generalization of deletable as
well
so all V although these are part of the
ACMA script three semantics ACMA script
three doesn't provide any way to control
these properties any new properties
created by Ekman script three code are
necessarily writable enumerable
undeletable ACMA script five provides a
new API for controlling these properties
and this is that new API over here we
see a set of new static methods added to
the object constructor and we're going
to start with the defined property
method so if you say object dot defined
property the first argument is the
object that you're defining a new
property on the next argument is the
name of the property and the third
argument is an attribute description
record it's a record that describes not
just what the value of the property
should be but what the settings are for
its writable enumerable and configurable
attribute this is what the attribute
description looks like for normal data
property later we'll get to what the
attribute description like looks like
for a for an access or property to use
this to solve the my tree yeah please
note that's the these things are defined
on object dot defined property not
object dot prototype that's defined
property which is why you need to pass
the object here defining this thing on
as the first parameter is this is
important for security reasons yes thank
you so over here we're going to use
defined property to solve the my two
string issue so over here we define a
non enumerable my two string method by
saying we're defining it on object that
prototype we're using the name we're
saying name of the properties my two
string the value here would be the
function that serves as the my two
string method and then over here we
provide the the attribute settings where
we provide enumerable false so this for
in loop here doesn't see my two string
in the same way it doesn't see two
string
the same api is used for defining new
access or properties so over here if we
want to add innerhtml
as an access or property to dawood after
the fact we do it by saying object out
defined property but now our attribute
description record rather than having a
value in writable field has a get in a
set field whose value is the R they get
or the getter method in the setter
method respectively so this is in
general what the what the attribute
description record looks like for
defining an accessor property so this
brings up to brings us to the end of our
first theme what we've done to address
this issue of enabling JavaScript code
to provide a practical emulation not
full emulation the practical emulation
of the magical behaviors of built-in
objects is property access control plus
a standard way to create access or
properties allows you for example to in
JavaScript implement the standard Dom
API which is a good litmus test for
solving the practical problem that we're
resolving here our next theme is making
ACMA script a more robust platform
so as mentioned earlier the obvious
problem is simply the the accumulation
of traps and pitfalls of minefields the
trip trip up both novices and experts
and smoothing those over making the
language less irregular is certainly a
major step towards robustness
but the problem is deeper than that
JavaScript was first designed with the
the U the style of usage that of
supporting the style usage of everything
can mess with everything that was sort
of the dominant style of usage that it
was designed for and that's fine for
casual scripting but it makes the kind
of defensive programming that you want
to write for creating large-scale
programs essentially impossible so for
example objects are just mutable maps of
properties
you can't lock down those properties
anybody can mess with with any property
of any object they have access to so the
provider of an abstraction cannot defend
the data invariance of the objects that
they're building to provide the
abstraction and that means the clients
of those objects can whether
accidentally or maliciously disrupt the
invariants that the provider may have
been counting on to provide some service
another problem with defensive coding is
some errors are silent so for example if
you assign to a read-only property that
assignment fails but it failed silently
execution simply proceeds forward on the
controls flow pathways that assumed
success this is impractical to
defensively program against because
imagine trying to write a program or
following every assignment you try to
write code that says did this assignment
really happen no one's ever going to
write code that way they're just going
to to make the optimistic assumption
that well it must have worked and if it
didn't disaster will proceed fortunately
the main tool in the toolbox of any
language for for writing defensive
code is encapsulation and JavaScript
historically has had an almost perfect
encapsulation mechanism which is the
JavaScript functions as a very good
approximation of lambda abstraction so
JavaScript function evaluates to a
lexical closure that encapsulates the
variables that it captures but even this
construct is not quite a perfect
encapsulation mechanism it has some
holes in it as we'll see and those are
holes that we've addressed in Ekman
script five and then finally there is a
particular pernicious form of error
which is toxic leaks of the global
object the certain there's a certain
kind of mistake that it's very easy for
code to in its latest Lee fall into and
the consequence of which is that the
global object accidentally gets smashed
and we've tried to address that as well
so the way we've dressed the robustness
has three elements to it there's being
able to make objects tamper proof so
that the provider of abstraction can
defend their invariance from their
clients so we've introduced this notion
of you can seal or freeze an object in
this talk we'll only be talking about
freeze and and when you freeze an object
you really make it tamper proof in a in
a real sense a style of programming that
I would recommend is that for the
primordial objects objects that are
widely shared like object that prototype
array dot prototype then any changes you
do to those you do in an initialization
phase before your program starts running
and then to freeze those objects before
the body of your program runs so that
your program can now proceed with
confident that those objects are not
changing out from under you the second
element is this inconsistency reduction
and then the third element is the
introduction of strict code so on this
issue of of tamper-proof objects what's
an example of an invariant well over
here we see a very very standard form of
JavaScript constructor function in this
case it constructs a point you invoke
this with new point this dot X means
assigned to the X instance variable of
the newly constructed point the X
parameter as course to a number the
prefix unary plus operator coerces it's
argument to a number and likewise for Y
so the provider of this abstraction
might have had in mind the invariant
that both x and y be numbers and the
other methods on this object may be
counting on that invariant however once
a client of this creates a new point
that client can turn around and
immediately just smash the the X member
with something that that destroys the
invariant
so to address this we go back to our
attribute control API in this case the
freeze method if you freeze an object it
does there's two changes that makes to
thee that makes to the object and then
it returns the object that you frozen
the two changes that it makes is every
property of the object it makes not
writable and not configurable not
writable means that assignments to the
objects value will fail not configurable
means that you can't delete the property
but as I mentioned before it's a
generalization dump don't delete when
object is not configurable it also means
that you can no longer change the Akhter
the objects attributes so once the
object is not writable and not
configurable that prevents the proper
this property of an object is not not
writable or configurable then it's just
locked down
freeze does one additional thing is it
makes the object non extensible so that
you can't add new properties to it yeah
you can do so yeah freeze is just a
convenience method you can iterate
through the properties and walk each of
them down individually and then there's
another API call that I didn't actually
show here called prevent extensions
where the only change it makes is to
prevent new properties from being
defined on the objects if you do both of
those things you've done everything that
freeze does yeah it's not frozen only
one level deep yeah I'm sorry the
question was if you do that manually you
you haven't frozen the values that are
stored in the properties of the object
and does freeze freeze those values as
well or is it only freeze the properties
themselves and the answer is freeze only
freezes the properties themselves it's a
shallow freeze not a deep freeze yes but
there's a subtlety there the subtlety is
that you cannot reverse into the values
captured by closures since they're
encapsulated so what you so so what you
can do is what we call a deep surface
freeze so it's we're mixing it mixes
metaphors terribly but but but it's
basically you can freeze everything that
you can find by traversing properties
and traversing the prototype chain
yeah okay and anytime I don't repeat the
question please remind me okay so in
order to use this to make tamper proof
points here's our first attempt at using
this API to make a tamper proof point
which is we use an object literal to
just create a record with an X property
which is the X parameter covers to a
number and the Y property which is the Y
parameter coerced remember and having
created the record we then make we then
freeze the record to make a tamper proof
this does create a tamper proof point
but it has two problems compared to our
previous piece of code one is that these
points are just records they have no
relationship to the point function and
they don't so they don't inherit
anything from point out prototype the
next problem is is essentially the same
problem in other guys which is the newly
constructed points by virtue of not
having any relationship to the point
function if you ask are the instance of
a point the answer will be false often
for many objects that you're going to
want to create neither of these is
really a problem in practice and when
they're not a problem this is actually
the simplest pattern so I recommend that
you stick with this pattern but when
this is not when this pattern does not
satisfy your needs here's a pattern
that's completely correct and introduces
another element of our new attribute
control API which is object dot create
object dot create takes two parameters
the first one is the parent of the newly
created object the newly created object
will directly inherit from this parent
so you say we want the newly created
object to directly inherit from parent
or prototype and the second argument is
an attribute map a map of attribute
descriptions in this case mapping from
the name X to the attribute description
record that describes what the behavior
we want to we want to be associated with
the X property and likewise for Y and
then having created a new object
freeze the object and we returned the
frozen object so semantically this does
exactly what we want it creates a proper
point that's tamper proof and inherits
from point dot prototype yes yes so over
over here yes so over here in my proper
description records the only attribute
that I list is enumerable true I didn't
list all all three attributes for all
the when you're creating a property for
any attribute that you don't list it
defaults to false if you're modifying a
property then for any attribute you
don't list it defaults to its to its
existing setting it defaults not
changing it from its existing setting so
so so this is semantically completely
correct but but pragmatically it has one
problem which is it's for both boiler
plane we just get very tedious to have
to write this rather than the simple
object constructor when you want to
construct a new object so the way you
can address this just as an example is
the way we always address boiler plate
when we're programming which is we
create an abstraction that abstract out
what's common in the boiler plate and we
parameterize the abstraction with the
parts it's different from one use to the
next so we might for example add to
function dot prototype a build method
that is is the that abstract sout the
boiler plate but like adding my two
string to object our prototype we might
want this new method not to disrupt for
in loops that might be enumerated the
properties of functions so we want to
add this new method effectively to all
functions without showing up in all four
loops so we do exactly what we did with
my two strings we use defined property
so that we can make it non enumerable we
this new method takes an attribute map
as an argument
obtains the prototype of the function
that it's invoked on and passes that and
the attribute map to curry
eight freezes that freezes the result
and returns it using that build method
we can now rewrite our point in so that
it's both semantically correct as well
as reasonably compact and still creates
a tamper proof point if you say point
dot build and then give exactly the same
attribute map then it will use this
attribute map to create an object that
inherits from point dot prototype it
will freeze that object and return it so
point here is a perfectly valid point
but if you vent but because it's frozen
this attempt to assign to its X property
will fail also even though we use this
instead of the original construction
pattern this is not technically what
what javascript considers to be a
constructor function notice that this
does not mention this instead of
initializing it's this it rather just
constructs and returns a new object and
as a result of it having that behavior
the new is harmless but leaving the new
out if you forget to say new here that's
also harmless if the new doesn't have
any effect in this case we'll always
just create and return a new point yeah
so notice that this addresses two out of
three security issues and that's you
know the point you create our instances
of points and nobody can tamper with
them but this does not prevent somebody
else from creating fake points which are
also instance of points now that we'll
have to wait until the next edition of
ACMA script yes exactly there's there's
that problem was there's no mechanism in
ACMA script five to to fix the problem
that Waldemar just pointed out and it
definitely is on the table after Ekman
script five so
so now we're on to the second element
which is the inconsistency reduction so
our or the warp removal the on this
section of the talk I'm actually only
going to talk through in detail one
inconsistency and for the sake of
limited time I'm going to skip over by
the others so over here we have a
function named foo defines an a variable
named X and within that context it
creates a new function named Baz that
returns X passes that bar and let's say
that bar is just some function that
invokes whatever function it's passed as
an argument what X and let's say in the
same program somebody happened to define
an a X property on object dot prototype
and initialized it with foo in this case
what X does this return X refer to well
believe it or not according to the
letter of the Eckman Eckman script 3
spec the proper answer is that it should
return foo because this X refers to that
X however that was not intended by the
authors of the ACMA script 3 spec it was
it was just a typo
not a typo but it was it was an
editorial error in the way the ACMA
scripts spec was phrased however this
error was actually implemented by some
browsers and as a hazard that JavaScript
programmers have to live with today it
actually caused a security halt at one
point in kaha Magma script 5 is
statically scoped where possible so the
answer is 8 so this is a good example of
this issue of finding opportunity and
confusion that when the ACMA script spec
didn't say what it meant to say some
browsers obeyed the letter some obeyed
the saner spirit of the spec the result
is that crops cross-browser web content
is generally compatible with that saner
spirit so the ACMA script committee was
was free to adopt the same as spirit and
codify that into the letter of the ACMA
script 5 spec so I'm going to skip over
the other examples of work removal
however this talk will be online so you
can take a look at all those
apples and I'd say if you're you know
that this is your cup of tea all of
these examples are interesting on to the
subject of strictmode which is the the
the main new tool that we've introduced
here I mentioned earlier that when this
assignment to the X property of point if
point is frozen this assignment fails
but it fails how when I can script three
it fails silently that silent failure is
in for our four browser is existing web
content counts on it so Ekman script
five by default the default ACMA script
five language couldn't change that this
is an example of a legacy problem that
we could not fix in the normal language
but in the opt-in stricter language we
could fix it so encode declared to be
strict code any assignments in that code
that fail throw so that you're more
likely to catch errors during
development and if you even at in
deployment if an error happens it still
takes your code out of the normal
success control flow path on to the
error path so you can use try catch or
whatever to to implement failure
recovery logic friend in the worst case
for example reload the page how do you
declare our strict mode you do it with
this use strict directive which is
simply a string string literal
expression statement at the beginning of
a program by program in the browser
context we mean a script block you can
have multiple script locks on the same
page and some of them can be strict and
some of them can be no strict these can
co-exist together perfectly well on the
page they're operating on common objects
within an on script strict program you
can declare individual functions to be
strict by putting the used strict
directive at the beginning of the
function at the beginning of the body of
the function that declares the function
itself to be a strict function and we
chose the strange syntax so that it
still parses on es 3 so that while
you're making the transition while
there's still existing browsers it used
to be compatible with while you're also
trying to
advantage of the new features you can
write code that works on both because
this use strict directive will simply be
taken by a nut as a no op by the
existing JavaScript language is simply a
use useless expression statement okay
another example of a problem that we fix
with straight away we got that we can
only fix in strict mode ACMA script has
some rules regarding the coercion of
this so returning back to our simple
point constructor that initializes this
if it's written this way it's only
correct to call it with new if you leave
the new off then you haven't provided an
object for to be bound to points this so
what JavaScript does by default is it
binds this to the global object what
that means in the browser context is the
window object so what what what executes
in effect is we we smashed the global x
and y variables on the window object in
the case of x and y it might be harmless
but if we intended to initialize a local
instance variable named location we
would instead be redirecting window dot
location which would redirect the page
if the if the point function here is
Decay's is strict then this is what gets
executed in effect since no object was
provided this gets bound to undefined
just like absent parameters get bound to
undefined and this is safer and in this
case the the assignment to undefined dot
X will throw immediately indicating a
problem
there's another example of this coercion
true and false
both effectively inherit from bullying
that prototype if you add a method to
boolean that prototype like this not
method you can invoke it on both true
and false and with this not method does
is it uses a logical not operator to
return the logical negation of the
object it's invoked on so what would you
expect this to do well in non strict
code true dot not returns false and
false dot not returns false and the
reason is that false is coerced to an
object by coercing to an object that's
coarse to what's called the boolean
wrapper object the not operator coerces
its wrapper to a boolean any object
rather than a primitive value course to
boolean get scores to truth and lot of
true is false
in strict code there there is no magical
coercion of this therefore there's no
magic wrapping that happens behind your
back for you to worry about if all your
code is strict and the result is that
this code does what you expect okay I
mentioned before functions are not
encapsulated not quite encapsulated so
what's the encapsulation violation let's
say we have a function named foo that
has an X and a Y parameter and it calls
the function named bar and the function
bar has the strange piece of code in it
well the strange piece of code actually
is not sanctioned by any of the written
down Atma script 3 specs you're actually
coding outside the spec but once again
with regard to what we need to be
activity to what the legacy
compatibility problem we need to worry
about all of the major browsers
implement these de-facto magical methods
the one at stake here is food arguments
when bars accesses food arguments its
accessing accessing the argument
property associated with the most recent
activation of the foo function above it
on the stack frame that arguments object
has joined the parameters the joining
means that arguments sub-zero remains
the same as the X parameter so in bar
whose arguments object and changes it's
zero - gotcha
then when it returns to foo-foo we'll
proceed with its X parameter now bound
mysteriously - gotcha
if Phu is declared as strict then even
though these things are not sanctioned
by any standard in es5 strict there we
actually mandate that these exist and be
useless as well as mandating that this
standard one exists and be useless and
by useless we mandate further that their
behavior is that they throw on access so
that you can catch porting errors more
easily when porting code to strict match
so the result is that strict functions
are safe even from non strict code
another problem with the language that
we couldn't repair for the for the
language as a whole because existing web
content Council on it is that Ekman
script 5 is still not fully statically
scoped there's four violations of static
scoping the first one is that let's say
you declare a local variable X foo and
then you intend to assign to it but you
just misspell the variable when you
assign to it that misspelling causes a
global variable of that name to be
created the whiff construct was borrowed
from Pascal in Pascal was a very nice
idea where you provide a record and then
all the fields of the record can be
accessed as variable names within the
block but because JavaScript objects
have a dynamic set of properties the
semantics of accessing those properties
from the block the scoping semantics was
bizarre you could delete dynamically
delete a name from your static scope
under some conditions and by using eval
depending on what string is dynamically
calculated to be a valid here if it's if
it declares a top-level variable that
top-level variable declaration is
exported into the scope that the eval
itself is called from causing you to
dynamically add bindings to the caller's
static scope so the first three of these
are rejected by strict mode and the end
the fourth one is repaired by changing
the rules around eval interests in
strict code now throughout the talk I've
been saying that Ekman script 5 is
statically scoped I haven't been using
the term lexical scoping I wish I could
lexical scoping was on the table but it
was late for the train we were not able
to agree on how to specify lexical
scoping within the time table in which
we were finalizing the ACMA script 5
spec so what's the difference why is
this a problem so let's do that by
example and I'll do this and that'll
skip forward to the conclusion slide and
then I'll take questions so over here we
have a function Square Fund Square
functions list which given a list of
numbers returns a corresponding list of
functions and does that by looping
through the the list it was given and
for each element of the list calculating
the square and then storing into the
results list a function that returns
that square so if you say square fin
list of 3 4 5 it get that returns a list
of 3 functions the Sub Zero looks up the
zeroth function which we're now going to
call anybody want to guess what this
expression returns yes somebody said 25
very good this returns 25 the reason is
because of var hoisting this declaration
and an initialization of the SQ variable
is really semantically two completely
separate things the Declaration and the
initialization and the Declaration acts
as if the Declaration was hoisted to the
beginning of the function and the result
is that this assignment here keeps
reassigning to the same SQ variable so
even though we have really created three
separate functions that we're storing in
three separate elements of B they're all
capturing the same SQ variable so when
we invoke that first function it's just
going to return the last very the last
value assigned task queue so we failed
to get any lexical scoping constructs
into es5
that creates a real hazard for writing a
robust code how do you cope well this is
a segue into the last theme of the talk
for which I'll just give this one
example which is so one of the new API
is that we added as these higher-order
array methods which is if instead of
writing a for loop you say a dot map in
es5 all arrays respond to map and the
way they do that is they invoke the
function that you gave it as an argument
to map on each successive element of the
array whatever this function returns is
then accumulated by map into the result
so so each of these new functions now
has a brand new fresh as cue variable to
capture and this returns nine as you'd
expect
so in conclusion
agnus script three JavaScript in general
is you know has always been a very
decent language for for small-scale and
casual programs but even for the
beginners there's too many odd corners
too many inconsistencies that can trip
you up the jewel here is xmas script
five strictmode it's a better language
to teach for new code it's better
language for scripting and the small for
casual and novice programmers it's
especially a better language for writing
serious large robust programs
I recommend strongly than any program
being maintained be ported to strict
mode once it's available I would say in
fact that equi script five strict mode
has crossed the threshold into actually
being good son so now we'll take
questions and I'll leave the the further
readings slide up as I do so then why
don't you guys join me for the questions
so when when they move from Python 2 to
3 part of the that effort critically
dependent on a tool called 2 2 3 which
was an automatic transformation tool
that helped people migrate will there be
a similar tool for let's say 3 to 5 or 2
strictmode that will help people to to
migrate their old code so edition 5 is
meant to be you know pushed into
browsers so pretty much all existing
scripts of any consequence up to work
and changed now for moving to strict
modes we I'm not aware of any such tools
but it should not be difficult to
convert your scripts I just don't have
any automatic way of doing it you really
have to understand what is doing or just
run it in strict mode if you get an
exception fix it and try again I would
also point at to existing tools that
would help not for full ACMA script 5
strict mode doesn't have any recognition
of the new features but for sort of the
strict subset of Ekman script 3 which is
Doug Crockford jslint if you get a clean
bill of health from jeaious lint that's
a good a good step towards being
compatible strict mode and similarly if
your code works on kaha cajas trying to
emulate once again the ACMA script 3
subset of strict mode so in the end so
prior to the browser's rolling this out
which should happen by the way very soon
you can still use Cod to try to debug
your strict mode conformance
so the you know final draft has been
publicly available for a month now the
the ACMA script five will go up for the
final vote of a General Assembly this
December and browser vendors other than
Safari are working on implementing its
now I can say in particular Mozilla has
said that they expect to have a beta of
this available within a month and
Internet Explorer there's internally
we're not sure when they're able to make
it available but they've been demoing it
as the ACMA script meetings and they've
they've been saying that their
implementation internally is already
mostly feature complete in sort any
information about rhinos plan I've
talked to nurse Boyd and Steve Yeager
there's currently no work on that
direction but north I don't know if you
can hear me they're enthusiastic about
wanting to see progress in this
direction there's no current activity oh
I'm sorry the question was what about
Rhino sorry
okay
yeah we have a remote question I could
not we could not hear it could you
please repeat this is we actually have a
google Summer of Code student that's
working on doing echo script five in
Rhino so that work is underway it's like
the Marshall McLuhan scene in Annie Hall
I said I talked about what Norris Boyd
had said and there's Norris Boyd with
object freezing is there a way to
achieve something like a private a
property that my class can modify but
others can't I know there's not the way
you achieve the equivalent of private
properties is by using the one
encapsulation mechanism that JavaScript
has always had it remains the one
encapsulation mechanism that's there in
es5 which is lexical closures so there's
a particular pattern which Doug
Crockford is pioneered called the
objects as closure pattern where in your
constructor function you create methods
per instance that captured where the
methods are simply defined in a scope
where the instance variables are
available as variables not as properties
but ACMA script five has has no ability
to create private properties we've
talked about various forms of private
properties for later versions of echo
script and there's a particular way of
doing that that I expect will be adopted
but that's beyond the scope of this talk
one of the issues were discussing is
whether privates ought to mean privates
to an object or privates to a class and
currently there is not much agreement in
the committee about which one to go with
for a future I am maybe like ten slides
ago you guys were talking about
an object defined property function that
was going to like be a first class
method could we just go back to that
slide I just wanted to ask a question
about it
basically it refers the questions about
compilation of JavaScript or like
minification of JavaScript maybe go back
to the other side that was just about
defined property this one here
okay so the first parameter is the
prototype that you want to modify the
second parameter is a string version of
the method or or what have you I think
this is gonna be difficult to implement
in a compiler I've seen this this
pattern in closure for example in the
testing libraries if you wanted to
dynamically rename my to string to some
small method name like a you have to
special case this function here to also
determine that this is the same function
and rename it appropriate is there and I
think this this pattern is gonna be
duplicated all over the place once EICMA
five hits yes well you have the same
issue if anybody ever uses court
Breakfast in your program you could you
introduce something like a name object
where that way the name object can be
aliased and you could recognize that in
fact it is the name object and since it
if the name object and course to a
string which was the name then you could
pass the name object in and and just let
the let the interpreter course it to a
string as it gets passed to the
underlying you know defined property
okay before seek it before speaking much
more about the compiler technology you
have in mind i just want to remind
everybody this is a public talk right
okay great
so just
crap on the objects is closures pattern
we've there's he how did some work to
determine to prove that if you do have
if you are creating a method per
instance in the constructor it's
possible for interpreters to optimize
that so you're not getting Oh number of
methods per object instantiation hello I
was wondering if there's a document
anywhere that describes what in
particular was borrowed from jslint and
various libraries because it'd be nice
to see before the library's we've been
using which pieces have come in and how
they're interpreted and something like
is there a document like that
it's I mean the evolution of Edition
five is kind of complicated it's it's
has not really evolved from existing
libraries with the exception of JSON
rather it's some problem with what most
of the ideas were just affirmed within
the committee based on our past
experience particular photo type library
the are the generic or the higher-order
array methods and also function dot
prototype dot bind think things like the
getters and setters came from us for
everything has a long and rich history
if you go to www.echristianjob.com by
inserting function literals that are
immediately called that also works
now you can't because then this break
continue and return will not do what you
wants
it's we've discussed this a lot in the
next edition we are thinking of
introducing our LED statement which is a
lexically scoped version of our little
BIA there may be a Latin accost because
cos does not work with heart as a matter
of fact I have a slide here that one of
those that we skipped over which is
these are all of the things that break
if you simply replace a block with a
function surrounding the block that you
then immediately calls a return break
continue this arguments var and function
all break if they appear in here however
when you're aware of this issue you can
generally avoid most of these problems
the only one that really practically
trips up most programmers is the this
problem which is fixed by
function.prototype.bind
any other questions oh thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>