<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC2016: Using Test Run Automation Statistics to Predict Which Tests to Run | Coder Coacher - Coaching Coders</title><meta content="GTAC2016: Using Test Run Automation Statistics to Predict Which Tests to Run - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC2016: Using Test Run Automation Statistics to Predict Which Tests to Run</b></h2><h5 class="post__date">2016-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dfax6sgrjeo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">next up we have Boris prick called ski
jacket right yeah okay Wow on the first
try yeah that's not easy and the clicker
for you somebody stole it oh yeah this
here is still have the clicker we're
looking for a clicker anyway
here comes oh yeah okay no problem no
worries this is a professional
conference let me remind you everybody
but yes boards take it away yeah hi
everyone my name is Boris brickowski and
I'm q infrastructure team lead in Unity
Technologies and today I'm very excited
to share the results of our work of the
two of our teams give infrastructure and
QA frameworks so auditor yeah and the
topic of my talk today is smart test
execution or using automated test
statistics to optimize or predict test
execution their execution yeah it works
yeah it works so what is unity so how
many of you have heard about unity quite
a few and how many of you have ever
created ten offended unity oh that's not
that many but after this talk I think
everybody will use unity yeah let's see
so first of all unity is very popular
and very easy to work with and very easy
to start with the game engine so
basically you can create 2d and 3d games
and augmented reality and virtual
reality applications with unity you can
easily do that as clicker works you can
easily do that as we have an asset store
which already created content and this
is a sample content free content that
you can use it looks pretty amazing and
you can easily create a game as we also
have a lot of awesome yeah services like
unity ads you can put to an edit your
game and our money you can use unity
analytics to like find some most
difficult levels that users games are
not happy with and you can analyze
everything and basically a lot of stuff
but mostly
but the most biggest advantage is that
you can easily create a game and run it
on 25 plus platforms basically a bit of
more numbers if the clicker works ok I
need to push the button so yeah we have
around five million registered game
developers we have around to 200,000
games created with unity and 700 million
people actually playing unity made games
and around a billion and 700 million
mobile devices running unity made games
yeah so this is what we are dealing with
in unity and unity is itself is a pretty
big piece of software and have around 2
million lines of code and which is
evenly split between platforms editor
and runtime three major components of
unity and all of that success and all
that numbers wouldn't have been possible
without the unity test automation
obviously with more numbers we have
around 30,000 test 10,000 unit tests
around 25 thousand integration tests
three thousand runtime graphics tests
and so on and about to a bit more
statistics about the test runs so daily
we have around a million and a half test
runs and 10 million test runs a week and
40 million a month and during the last
year we've having 300 million test runs
so it's pretty good and all of those
tests they obviously run on a good farm
and our build farm doesn't look like
this it has 108 agents and we just
delivered another build forum which is
even more powerful like 400 agents but
still the user experience that it's
pretty slow so what's
let us to become successful basically
with all those numbers and users and
games knows the stuff has become a
bottleneck right so and why is that
let's see so in order to understand that
we need to dig a bit and to how the
development is done in unity and it's
done in branches so when a team needs to
develop some functionality they branch
of the main branch called trunk and
develop the stuff in there and then they
when they have the changes which is
called pull requests we basically I'm
just thinking that it is pretty common
for all of you so you need to get into
the mainland and which is called trunk
right so how do we do that so in order
to pull request to get into trunk you
need to go through a peer reviews then
you need to have green abd abv is an
abuse verification and a is because it
needs to be in the top of the list
basically yeah and this is a statical
subset of tests and the key here the key
point that it is static so basically we
always run some static subset of tests
it's not thirty thousand tests that we
have but some subset and they need to be
green so and that's not all once the abv
is green we add a pull request to queue
and we take some of this pull request by
batches and we run all of the tests that
we have pretty much all tests on that
batches and every if it's green then we
go to chunk if not we start the
bisection process and trying to find out
which actually means video pull request
broke this stuff right so what is the
problem this problem is that abv is slow
it may take from three to six hours for
an abd to get into the oxalate for foav
d to pass depending on the load on the
bill farm and when it happens you just
sit and wait how do you send actually
goes
down and basically pray that everything
actually actually works well that there
are no flaky tests nothing happened but
and so on yeah so in basket question
ourselves if you can speed it up yeah
let's try but before doing that we had
to fix a problem with the ways how to
run tests we used to have a lot of
different kind of scripts for runtime
test for native tests they're all were
different so we created a tool called
unify test runner which is unified which
actually let you run testing unified way
either on your local machine or on a
build farm and as a last step of UT are
basically it sends all of the data to
database we created a also called holder
which actually has the statistics on all
tests so here on the screen you can see
basically the statistics I'm not sure
whether it's visible because of the font
but sighs but basically you can see the
pass rate the medium time and so we know
everything about our tests right now all
the history so once we had that data and
we found out that we have evergreen
tests so if you look at that column
basically you see that we have hundred
percent successful test even though they
have thousands of executions and we
actually came up with a pretty simple
idea simple but yet powerful let's just
not run test how dangerously could sound
but yeah this is the idea let's not run
tests which a hundred percent successful
during last month and we have around
hundred we should have more sorry more
than 100 test runs and on all branches
except the branches which are involved
into merging into the main line trunk
and that's a key point because we do not
just get rid of all tests the
get rid of green test and once they fail
and if they fail during the merge
process we all know and we'll get them
back onto the probation and basically we
will run them for another month this is
our idea so some results so we started
with an hour and 20 minutes and the 1700
tests and basically we went down to 30
minutes and 160 test so this is our
results so this is the most results that
we have like we enabled that for free
test tubes and sorry improvement no it's
okay let's go didn't work so we went
down from an hour from 40 minutes to 38
minutes and a saved 63 minutes but the
biggest the best result is that with an
hour and seven minutes we went down to
23 minutes for mock tests and we saved
44 minutes and sixty-six percent
basically were said I'm not sure whether
i have time but these are actually
graphs on the horizontal line you have
minimum pass rate and on the vertical we
should have actually the number of
actually it took right right right slide
the minutes so this is like we started
with hundred percent minimum pass rate
so if we start playing with numbers and
go down to 99 75 then we can save not 20
minutes but even 10 minutes so this is
still a place space for improvement and
yeah let's keep god don't have time so
the probably next steps next steps find
automatically find which test we exclude
excluded but then which were failed
during the merge process into the trunk
right now it's manual another thing is
so called the Boris mode probably all
became famous my team call it after me
because I a big supporter of it it's
like right now we are looking at the all
branches and for instance two teams
development
two separate branches and if one team
breaks stuff brake tests then it affects
the other team so basically they're
gonna run the same test again and again
so my idea is just to look at the one
branch and basically focus on that but
the most promising part most promising
next step is actually to use coverage to
build a database for instance use an
instrumental build and run into video
test one by one and see which files were
actually which code from which files
executed when that test is run and build
a database so one and then reverse it
when we have a commit we have files will
change it you look at the database and
actually run only those tests that were
actually were there so this is the next
steps results results are we hope like
browser like this developers are going
to be happy because they spend less time
users are going to be happy because we
develop new functionality faster pigs
box first area this is where we are
reaching and there's where the just the
first steps first approach we've been
doing this for just a couple of months
and obviously there is a space for
improvement and I don't know if we have
time for questions and ideas comments I
would really appreciate it thank you
very good thanks Boris this was a
lightning talk so no time for jokes
between so go to the straight stuff okay
it's hard navigating this I think you
need to go down and pick up the next
question yeah we're here Oh so yeah all
right got it will exclude that time from
my time all right so what is a good
balance between excluding tests and risk
of breakage is yeah this is an
interesting question and I think this is
a key approach here so we spend so much
time waiting on the results of the test
so basically that time is not productive
right the developer needs to you know
switch to some other task and we know
that context switching is very cost
costi operations very expensive
operation we let say machines computers
or humans when we switch to between
tasks it's pretty expensive right so we
think in right now that we will take
that risk and then yeah if anyone has a
question in the room I'll yesterday ok I
see you I'll ask this question while I'm
taking the mic over you at the same time
but great concept do you do periodic
runs of evergreen tests or are they ever
dead no this is the key point we do not
exclude them at all because we all we
run all of them on trunk merge q so
basically every time the whole bunch of
the arse run all tests around for them
so basically the they keep being
executed so we do not get rid of
anything so we do know we can we can
kind of do periodical but we do not need
it as long as all the time there's a
constant process of motion into the
mainline trunk I am tossing from
mathworks we actually have a
what we call test selectors kind of goes
exactly what what you're using we have
had like good experiences somewhat but
we have had usually a pretty bad
experience with the fact that they put
so much value on code coverage with new
features coming in and things like that
it's kind of a dangerous ground at the
fee if the code base has changed quite a
bit and then you're using that code
coverage to choose the tests and like I
was wondering what what's your
experience in that area it's very good
that you asked that question and you
shared your experience because we
haven't started doing the code coverage
thing we are just considering this as an
addition to this process so basically we
switched to we're switching from static
execution of tests to dynamic execution
of tests and this is just the first step
of it so basically we will try using the
cost coverage and see how it goes but
it's thank you for sharing your
experience with us we haven't started
yet so you don't know all right very
good another hand for Boris</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>