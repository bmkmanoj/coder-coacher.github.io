<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C++0x Initialization Lists | Coder Coacher - Coaching Coders</title><meta content="C++0x Initialization Lists - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C++0x Initialization Lists</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uEqknlxXJfg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well get started today's speaker is be
honest road trip he's worked on a lot of
different areas including got
distributed programming on very large
systems but of course he is best known
as the inventor of c++ if you've been
attending the various ax advanced
programming languages talks you'll know
that right now the c++ standards
committee is working on the next version
of the language and of course bianna is
heavily involved in that today he's
going to be talking about one of the
major new features that the upcoming
version of C++ is going to have a
revision of initialization lists and
before we begin just a reminder this
talk is going to be on google video so
if you have any confidential questions
please save them until after the talk
thank you so the microphone seemed to
work now I know you have a fair number
of talks on things that could be called
computer science and a lot of talks on
on sort of finished products a lot of
our views and I thought I'd do something
different so this is this is not going
to be computer science it'll be sort of
more like computer mechanics the idea is
what happens when you take your favorite
programming language and sends it to the
shop for a 60,000 miles una you'll get
some of the more serious and scientific
and differ and difficult and computer
science stuff from the concept talk
which i believe is you see that the two
o'clock today which is also something
I've worked on but this was just meant
to be completely different so if we want
to be respectable we can call it a case
study and I hope to convince you that
details matter I don't actually think
this is a major feature so that you
capitalize it it's a little thing that
it would have been nice if it had worked
20 years ago and for some reasons it
didn't
now it's hard to fix but I'll also try
to convince you that the details are
hard I mean anybody can design a better
programming language if it wasn't for
the users if it wasn't for compatibility
constraints if it wasn't for the way
these users have been trained to think
and little things like that so I'm going
to talk about these things and I hope to
come into about that and I hope not to
convince you that this is just a waste
of time and it's too too fiddly it is
fiddly but I I think it's very much
worth your while we have not forgotten
the picture but big picture or the type
system or something but that's another
talk all the talks I'll say a little
word about C++ or X and then our going
into more details and you want to know
basically we're trying to make c++ 0 X
C++ 09 not c plus plus 0 a 0 be other
hexadecimal nonsense and to do that we
actually have to agree on essentially
everything by the end of this year
because the national and international
bureaucracies take an awful long time to
get the ax together and we would rather
that the nations voted yes with with
some nice margin like 20 to 20 like last
time we have a bunch of language
features you have a bunch of library
features and then we have a bunch of
things that combine language and
libraries the major thing about language
features will be the concepts which is a
type system for types and four
combinations of types combinations of
types and integers and other good stuff
dog Gregor will tell us tell you about
our work on that later and then
initialize the lists boring little
things like garbage collection and we
have library features hash tables
regular expressions nothing major but to
a lot of
people don't have it and haven't
understood that there are things you can
do in a language that doesn't come with
your favorite compiler it's good to get
it into the standard and combine
features the memory model the threads
libraries atomic primitives you see some
of the really hard things is is there
it's being done just not what I'm
talking about today initialization is
messy in in C++ you can do it in lots of
ways and there's lots of ways that you
you would like to do but you can't we
would like to have initialized a list
for containers you can use and
initialize the list open curly 1 comma 2
comma 3 comma 4 for an array so why
can't you do it for a pro vector if I
have a tree why can't i initialize it
with let's see name 1 comma phone number
one name two comma phone number one
things like that it seems obvious we
should be able to do that but we can
only use initializer lists for for for
arrays and sprouts arrays they tend to
be homogeneous structs the heterogeneous
just to make life more difficult we'd
also like to have a uniform
initialization syntax and semantics that
is I would like to give one answer to
the question people comment says how do
i initialize my object I don't want to
say what kind of objects are you meaning
a global object or local object oh no it
was a member sorry I don't have to do
something else I want one answer I don't
have it today I have an answer to every
question you can ask provided is
specific enough that's not uniform and
general and you can have things that
looks almost that it looks identical but
had different meaning this is bad so we
need to to generalize this we don't
really want
conversion problems surprises well
there's many ways of getting them and we
don't want surprises with different kind
of constructors if we can help it and so
we want a uniform system that can do
everything oh yeah and don't break my
code it's nobody likes that code broken
doesn't really matter when I come with
how nice it is if it breaks your
existing code you're going to get angry
with me and really people don't like to
type they like to be able to read things
that are tirst but they don't may I
don't know what they like but they don't
want it they're both most of the time
people say one thing and do something
else so it's hard to summarize but it's
tricky let's see let's go back to a
little bit more detail see provided you
will be able to say X of a equals curly
braces Vivi's some kind of list of
arguments or maybe a single element and
you can also initialize X of a x equals
to thee and if X was an integer on V was
seven both of these to work and they
were having to mean the same C++ added a
whole bunch of stuff to support various
notions of programming the new operator
needed to be able to initialize then we
needed to generalize this syntax to that
so that we could initialize an object
that took several values and I use the
functional notation because the notion
was that you you have a function that
creates a value whereas see had the idea
that you have a value which you bung
into a structure it's not that much
difference between the two notions but
enough that we've got some syntactic
problems and you have temporaries
function style costs all the kinds of
stuff and a lot of messy things created
over the years I mean
perfectly good reasons for private copy
constructors but they really are hard to
fit into a general framework now
prancercise lists they look they're
fundamentally heterogeneous but they
look homogeneous there's a heterogeneous
and clear that's homogeneous means
something else but it looks the same
notice then we go for initialization and
generality we would like things to look
the same and mean the same that integer
is different from that integer because
that is the number of elements and that
happens to be a value and the value
happens to be at the same type as
roughly the same type as a number of
elements where messy stuff curly brace
lists can be homogeneous or
heterogeneous depending on the phase of
the moon so here we have an integer and
something that becomes a pointer looks
homogeneous happened to be heterogeneous
and here well it looks homogeneous and
it is so if you think you know the
answer you're wrong that is there are so
many little things that looks natural
and intuitive to people that are natural
intuitive just because you've been doing
it for a while and we have to try and
find something that there is a synthesis
of all of this it's certainly not
science and if it's a heart and art it's
a fairly low art it's like doing a
puzzle when do you know you've done a
puzzle right one the last bit falls into
place and not before that otherwise
somebody might have thrown some pictures
from some pieces from a different puzzle
into the pot and this certainly is the
kind of puzzle we're dealing with some
of the syntactic differences you see
here reflects real semantics most of
them don't they reflect history I I get
seriously beaten up quite often for
pointing out that certain things are
basically
the historical accident doesn't mean
it's stupid doesn't mean that people did
them they're stupid but a lot of things
happen because they are sitting chatting
with dog McIlroy and it seems a good
idea at the time or what a nice Richie
was was arguing with steve johnson and
seemed a good idea at the time may have
Kassim a good idea ten years later and
then the two different conversations
turned out to clash on somebody and
meant something third third we we don't
know everything and the world changes
and so what is a good idea even if
something is a good idea for a decade it
may turn out to be a problem and many of
those ideas were reasonably well thought
out given the environment at the time
the the what was available in the
context and what we knew but it may not
not generalize so we have to deal with
this so this is something I want to work
I want a vector of integers which I can
call sequence and I want a vector of
strings which I can call locations and I
want to initialize my vectors like that
and I want initialization to work for
argument parsing too so if I have a
function that takes an integer that's a
vector of something I wanted to be able
to give my sequence to to that function
and put in a sequence just to go ahead
that makes perfect sense one of the
basic rules of C++ is that argument
parsing and a few other things that just
formed some initialization then you
should be able to do things uniformly
whether we are doing an initializer like
that or an initializer like that or
return value for that matter but but
this is what we would like to do and if
you think a little bit you can see
there's lots of good uses for that
basically there is a fairly hard
underlying reason why I would like to do
this when I wrote out my aims for c++
one of the most fundamental
int'l and one of the few really language
technical rules was we should have the
same and equally good support for user
defines and building types so why on
earth can I do it for my least favorite
type namely arrays and I can't do it for
one of my favorite types which is vector
and furthermore the difference here is
embarrassing it also becomes a real
embarrassing because there is no way we
can uniformly treat initialization of
types as it happens with generic
programming once you start writing a lot
of your code in terms of templates to
have it work on all types that has the
right properties then you want the same
kind of systems you can't say well this
template should work for things that is
initialized this way so I'll use this
initializer but types of a slightly
different wants a different initial you
can't do that you just have to write the
template with the initialization and
should work so these are fairly
fundamental reasons even if the details
are sort of mechanical let me give you
an example here we have four different
ways of initializing something t1 is
initialized by ordinary assignment
looking initialization the next one uses
the functional style next one uses
initialize a list and the last one uses
the trade and object of the type and
then copy it or syntax and look I don't
want four ways of initializing things
four ways of doing things and I have for
a lot of things it's a mess and you can
sort of as an exercise define X and V so
that either zero one two three or four
of these definitions compile all of the
possibilities are possible this is a
this is an exercise I've done you can
also manage to get the very very news or
some of the initializations to change
that's that's a little bit harder
and sometimes we only have one sin sexo
you can't just say oh I like this syntax
so much better than then the curly brace
stuff and the quality let's let's really
standardized on this I won't tell my
students about the other ways this is
the right way no I have not done that i
will not do that but there are people
who have done exactly that but you can't
some syntax is only works in certain
contexts and even if you believe this
you'll be hit by anybody who wrote see
you will get to there so let me very
quickly go through some of the examples
say we have a double D and the typedef
in X so this is really yucky I mean I'm
throwing away information I hate
narrowing conversions but we get them
right there so everything is all right
except that it gives the wrong answer
let's take a container let's take V to
be an ill it be to be an integer a
vector of integers now fortunately this
doesn't work because we know that we
can't assign 72 hour to a vector this is
perfectly obvious unless you use
scripting languages in which case it's
not so obvious here we have t 2 which is
done the proper way for a vector we
gives the parameters to the constructor
in the parameter form and then we know
it's it really is a size we're giving we
only know that if we know it's a vector
this is my point I mean if you're just
looking here you don't really know and
there's no way of taking that list and
banging it into to the vector that would
be nice if you could and here well it's
okay it makes a vector an assigned it
over there that's fine it may or may not
be optimized it usually is optimized so
there's nothing we're done in there it
could take a see Styles drops will get a
bunch of errors and we get an
initialization by 7 and 0 because the
old rule from see is that if you
get to initialize a element it just gets
a value 0 it is assumed that all element
can have the value zero so so that works
and if you are a sea program that is
actually an extremely useful facility in
some contexts and we can't cast to a
strut so that's illegal pointers I mean
fortunately most of it fails if we have
a pointer type and an integer finally
the type system does what it's supposed
to do it stopped me from assigning at
seven to a pointer except the functional
cast has the wrong meaning it somehow
got defined to be any old cast as
opposed to the most restrictive cast as
it should have been I had a bad day it's
the only explanation there we can ask
you about why I had a bad day but in
retrospect that was a bad day if anybody
comes and tells them there are great
language design and they never make
mistakes I let me try sell them a bridge
or something now this is a real problem
yes it is a major source of confusion
it's a major source of bugs so the first
thing that comes to everybody's mind is
why don't you don't we just ban all the
bad things that is if I come and you
have this mess and I invent something
new and says you should use this instead
so instead of having n where ways of
getting in trouble in our n plus 1 ways
of making trouble it's much much better
if we could say cut cut cut cut and
we'll have a much smaller thing don't
invent anything new just ban some of the
things you don't like unfortunately that
cannot be done because you need every
one of those sin taxes for some reason
or other even if there was an old code
that had to work that we can go for the
details of that statement but it's it's
it's close to true
and unfortunately we've managed to have
that the existing syntax don't have the
same semantics nor cases here is a
really sick piece of code it has a
unrestricted the normal constructor that
takes a double and explicit constructor
that takes a inch if you design
something like that you deserve to be in
trouble and your bus should should
should try and stop you now this one is
preferred when you have an expert when
you know the context if you don't do it
so just a sick one there that's not a
direct initialization it looks at all
the constructors and pick the right one
which of course is this one this is good
pick the right one now i'm trying to be
specific I want direct initialization I
want very bisous very specific you know
it picks that one somebody and I think
not me had a bad day what we're on the
previous one here this is a context
where it's direct initialization
therefore it only considers explicit
constructors this is a technique that
will stop you from doing conversions so
for instance that was the thing that
stopped the the assignment of 72 a
vector to work you combine that rule
which is very useful with the rule that
you can have more constructors without
the restriction that they should all be
explicit and you now end up picking the
wrong one this one looks at explicit
this one looks at all of them this is
sick see if I'm wrong that I don't think
it's the other way around if it's all
the way around it or to make some sense
we can check up on that but it's it's
bad either way I chose the worst one but
I did do some looking to make sure that
that I think I'm right okay so here is
something we have initialized a list in
c and c++ and it's a nice feature when
it works so let's say we could use it as
an initiative why don't we generalize
this let's use it as initializes but for
all typed that lose it for argument
lists let's use it for return values
let's use it for initializers for new
let's use it for initializers for
members and such that's the fundamental
idea so can we do that why do I have two
slides there
yes this just shows both what I would
like to do and what I can and cannot do
and so we just want it to work and how
do we get initializer list since objects
I mean if you have a plain aggregate in
the c-style you know what the elements
are you know what the values are you
just pawned them in easy that's what
initialize the lists are for in C++ you
have some members you have some values
and you go through a constructor so we
invent a constructor that takes
initialize the lists simple we call that
a sequence constructor and i'll give you
the syntax in a business the basic rule
is if there's a constructor then you
look to for a sequence constructor and
if it works and if you have one you use
it otherwise you use an ordinary
constructor with the elements in the
curly list in the initializer list
otherwise we do it the traditional way
that's that's the basic rule and and it
seems to work let me give you examples
now when you design anything in in a
language you'll get a wire debate about
what it should look like not quite sure
maybe because fewer people can
understand the semantics then the syntax
or at least think they have opinions
about it but it is absolutely certain if
you invent a new language feature you
will get a wild debate about whether
there should be a keyword whether that
keyword should look one way or another
whether there should be some syntactic
mumbo-jumbo what it should look like
what it should be roughly comparable
with so went through a huge list of
suggestions of what it should look like
it being a constructor for a type
container see with element type II that
you initialized with initializer list of
elements
okay that really took a long time and
the answer is this we picked on having a
type in standard library that's known to
the compiler cord and initialize a list
of some element type is and so if you
want to deal with initializers then here
vector can take and initialize a list of
it element type and what would you do
with it maybe reserve enough side enough
space and then copy them in something
like that but anyway the way you say you
are interested in initializer list is
this and now you can write that the
semantic is obvious you simply lay down
an array with the right values converted
into the right type and then you what
are we doing
I make an initialize a list that refers
to that and then I initialized with
initialize the list basically is
something that looks at a piece of
memory it knows where the beginning is
it knows where the end is so we take the
elements put them in the right form the
right type and give it to the
constructor so the implementation model
is trivial you might be able to optimize
this in some cases but not very often
not as often as you'd like so basically
the question is can we initialize this
initialization syntax and semantics to
cover all cases and I think the answer
is yes and this is where the trouble
starts because now we get to the details
this is where compatibility gets in the
way even worse than the sense of
aesthetics from the previous slides
there is a paper about it which you can
find on the WG 20 once our site if you
can't find that you shouldn't work for
Google and the revision 3 will come
pretty soon and we're dealing with
ambiguity syntax narrowing conversion
c99 head upload more it's 50 pages of
dense considerations of trouble it's
like you take your kind to the garage
and it's been doing 60,000 miles there's
a lot of cleaning to be done a lot of
scrubbing and not much science but
there's lots of details you have to get
right you only have to get one thing
wrong and you'll be unhappy so I'll talk
a little bit about this syntax so the
first thing is that every form of
nationalization in the language can take
the curly kind of of initialization so
that's fine that solves by the way a
very old problem about every half year
somebody asked me I had
and array member how do i initialize it
in the member list the answer is well
you can't well here you can just give it
the initializer list falls out
aesthetics I don't know if you like this
stuff you can argue it either way look
just at the aesthetics for now think
about if you like it why do you like it
I mean maybe it's ugly and you just like
something new maybe maybe you don't like
it is it for fundamental reason or is it
just that you haven't seen it before
people's reactions vary dramatically
from while this need is to all my dead
body the reasons for that there is from
deep psychological reasons to type
theory to passing strategies for old
compilers and things like that so give
it a chance think about it if you're
really interested see the the next
revision that will be available in a
month or see the current one that's now
but it hasn't solved all the problems
yes
sorry I I think there's a typo here for
starters there's the type of there so
what are you let me get the question
again there are so the question is is
that comments or constructors basically
what it is it's simply in all cases says
there's an object of type x and i would
like to initialize it will initialize
the list 1 comma 2 how x receives that
initialize the list depends on how x is
defined the fundamental rule upstairs is
the first thing i do is to look for to
see if there's a sequence constructor if
it's a sequence constructor it's given
to the sequence constructor if there's
not a sequence constructor it says is
there a constructor if there's a
constructor it gives those two as the
arguments to the constructor if there's
no constructor it sees if it by
old-style aggregate initialization can
do the job can the sequence constructors
hate any other arguments no but you can
define a function that takes an argument
of type say int and the sequence to an
end initialize the list
okay so a raisin sprouts so we have
already the case that initializer list
does double duty I mean the main
observation you could say is why don't
we just separate initialize a list for
constructor arguments which is roughly
what's done now and that you know we
can't because we are already doing WG
with initializer list they work for
structs they work for a raise we can't
change that this will come back to haunt
us here is integer with one element
initialized to two and there's an
integer which vector of integers with
elements one and two it's this this gets
a little bit subtle at times and we just
think we have the best use of the of the
syntax okay so we have to allow the curl
is both for ordinary constructors and
for sequence constructors the way it's
allowed for both structs on arrays and
it also happens to be allowed for
scalars already so you can initialize
double with the initializer list with
one element now enables do that for
decades on the other hand you cannot do
the same for for something that not a
scalar and you can do things again when
you define as a pair that doesn't have a
constructor the only real difference
between this and that is that this one
has a constructor that takes an argument
and this one doesn't so again there's
something you can do for building types
in this particular case is struct that
you cannot do with a class where you
have carefully specified what you can do
so the idea is that will allow this as
an alternative syntax so if you want to
initialize the double with real and
imaginary one and two fine you can do it
exactly like that it means the same
couldn't possibly mean something else
there's no sequence construct of a
complex and this uniformity happens to
solve an old problem like if you have a
complex that takes nothing more takes
nothing that's fine we can try and be
explicit about it taking nothing lots of
people get caught in this one this is a
function Z Z for that returns a complex
non-uniform syntax creates problems
right here we have been explicitly
executed about 0 and and it works it
means the same as that so people get
into the habit of writing things like
that they will not fall in that trap
anywhere near ZZ disambiguation this is
probably the worst problem we have how
do we choose I'm not sure how deep I'll
go into this but the rule is that if it
looks like and initialize the list it is
if there's a sequence constructor if
there is not a sequin constructor will
consider the other arguments so this
means that if I have something with no
element 1 element to element 3 elements
it looks like a initializer list and
there's a sequence constructor so it is
an initializer list all of these do the
same thing I tried to say can we be
safer by doing all old resolution that
is we just throw the sequence
constructor into the set of all the
constructors and then we pick the best
match now this one becomes ambiguous
because either it was the MTA
eliezer or it was initialized I will an
empty initialize a list which happens to
be the same thing but is still ambiguous
because it's two different constructors
that one is ambiguous that one is
ambiguous and it's all right you have a
long list so it will not have a problem
for more fun pick another argument type
and what is ambiguous and what's not
ambiguous changes so that I have a
simpler rule and the symbol rule is that
the initializer list takes advantage
takes priority I mean and so here if you
have functions that can all be
initialized you can all try this and you
do normal whole load resolution you pick
the right one if there's the right one
if there's not a right one well say
which one you want it just falls out
this is this is sort of where the puzzle
gets hairy and to really appreciate the
puzzle you have to sit and puzzle with
it a bit i just gave you our solution
there are more ways of thinking your way
out of this and i don't think they work
but you have to look at it there's a
couple of things we didn't try out in
relation to that will be in revision 3
but there's enough in relation to give
you a headache why don't we just take si
style then I called initializer list
this one here is a see style that takes
and initialize the list gives it a type
it's sort of like what we were doing the
only problem is that it's weird what
what's what's the proper name for
remember oh yeah this is a compound
literal this is not an initializer list
and it is not a cast the standard says
so it just looks like it it is however
still an lvalue so you can take it to
address and start mutating it
fortunately the C standard says that
if you mutate it in a loop with a normal
control structure it is actually
undefined what is result of here whether
you initialize this one with a new value
every time or you take the one that got
modified if you go and do GGC for a
moment you will find that it's modified
and you get a sequence of values this is
not portable because it's undefined you
want to make this defined so that it's
guaranteed to print out one two three I
mean so next time you get through this
integer 1 means to next time through
these integer 1 means 3 we're back to
fortran right 14 in one for any
sufficiently high value of one will be
larger than 10 I can do this now it's
unspecified now we don't like on
specifies things so let's make it
definite so we'll change this loop by
writing it with a go tool and it's now
well defined and we'll write one two
three four so we decided we're not going
there and it's better not to allow this
then to have it almost compatible almost
compatible is what the sea trout does
the C++ not what the C++ proud to do to
see in my opinion so we're staying away
from that so we have the rule that
initialization here is going to be
direct initialization that is it'll work
even for explicit constructors the point
we had there before so we can really
write strings here and get the STD
strings initialized we don't have to
write this that's direct initialization
where we know the target and can use it
this you go into the OBO low resolution
mechanism and you have to disambiguate
we don't want to do that we want to
direct the problem is that this stuff
doesn't narrow very well so what we are
going to get this way is we're going to
have that this will
this will fail because if we don't do
narrowing conversions which we would
like to do this will not work I think
this is a really nice idea I would like
this code to break so like in a lot of
extension situations repair situations
you can get almost compatible but you
end up breaking something this is what I
would like to break this is what I would
not like to break one of the reasons is
that this is actually done fairly reason
every object okay here the character
array ABC and the integer 0 now a lot of
compilers today already detect these
kinds of narrowings and warn you so in
case of a literal what we need to do is
to say that it's only an error if the
literal really requires narrowing so
that's what proposed that is a
subsidiary proposal first we vote the
big thing in and then we go for this
which is a different issue what we'll
see so why do we actually mess with
narrowing not really for this thing here
because you can say well this is strange
we're not going to go there that is a
fundamental reason why we want to mess
with it look at this pchar p of each
other that's that's fine except that
this is what sort of turns and integer
into a into a pointer you don't want
that to be happening by accident you
will say well this is not an accident
there's no problem fine I'll believe you
thousands wouldn't but now write a piece
of code you have this function here that
takes a couple of parameters and it
needs a temporary of type T based on a
value of type v this is not uncommon
code in template metaprogramming in
particular
that's the disguised version of that one
as usual we cannot change what this
means this is bad it's going to bite you
but we can go and look for an
alternative and the alternative is to
use this syntax the problem is that if
we don't define this as a more stringent
about conversions then the brackets will
get the problem back again if we have
this a special case we have lost
uniformity so for that reason I'm
proposing that this does not narrow and
it's direct initialization we will get
the same value of type T in all the
cases and notice you can actually only
do that if you well it has to be uniform
now
having got that far we went back and
looked a bit on the syntax by the way
who were we we is primarily me and Gabi
does raise to sit there in the front and
then it is secondarily a lot of members
of the evolution working group at the
standards committee and then various
people who sent me emails telling me
what I really should be doing but anyway
do we allow a of the X of a without the
assignment I mean currently you can
initialize a variable will initialize
list but you have to have an equal sign
if you think in terms of grammars
there's no reason not to accept that is
this is non-trivial there is a fairly
common compiler heck that does the
following it looks for the return type
then it scans ahead see if there's a
curly coming if there's a curly coming
before an assignment it must be a
function and then it does special magic
to pet you to do the declarative in this
case a in other words very ad hoc
mechanism for passing look ahead for a
curly and then pass differently if you
found it if you think in terms of lrk
this is not the way you do it but so
this is the problem I would like to
allow this but we have to look seriously
into the problem of existing passes and
whether we break something we shouldn't
this is not the language we're talking
about this is some people's compiler
should we allow v equals this one it's
obvious what it means assign an
initializer you just sing assign an
initializer to a variable that's an
assignment we know what it means but but
do we allow it if we don't allow it you
get the interesting situation where you
can initialize something we'll
initialize a list
you cannot assign to it so you have to
write the assignment in terms of the
operator assignment rather than the
assignment operator
the better
no we can't there's a specific rule that
says if X is a function type that's
illegal that's actually already special
rules built in to maintain this kind of
stuff really horrid yes let's see this
is in this case yet operator
or fall back
so the question is do you have to define
operator equals the answer is I'm not
assuming any magic here this is what you
can write if you have defined it you
cannot write it for a see a building
type
p
if there was an operator equals that
took a type that was not a V but could
be initialized with 1 comma 2 yes you to
make a temporary but you see that's also
the case for here that is exactly the
immunization semantics so the point is
do we allow the syntax and most people
says obviously yes if I can initialize
v2 1 comma 2 why can't I assign 1 comma
2 to it okay yes that sounds good do you
also want to do this V equals V 2 plus 1
comma 2 let me think of V as a complex
number hey of course I want to assign
the 1 comma to torture the complex
number and of course i want to add 1 to
1 comma 2 to it if these are numbers I
can have my coordinate system and i can
get my translations and Sarge yes of
course I want that no problem as a
matter of fact there is no problem here
comes trouble if I can do that why can't
I do that so I want this one to the
problem is that there is one expression
grammar for both the left hand side on
the right-hand side of an assignment the
grammar for the left hand side of the
assignment comes at the same point as
statements it's beginning of a statement
right so it could be a block so we just
see this we do not know will its and
initialize a list that has somehow
uniquely crept or to the left hand side
of an assignment or a block and there's
an arbitrary look ahead because I can
make these arbitrarily complex including
more curly as and such ouch there's an
easy solution just facts on the grammar
completely for expressions I'm not sure
if people are willing to do that so but
this is a question you have to answer
these questions the the point is not
whether this is what you want
I can assure you some people wanted I
can also but it's a popular or can you
fit this into an existing language with
an existing term technology for passing
it and analyzing it and you can't escape
the questions and finally to want to do
this we want to do with a initialization
with indexing with with tuples why not I
know people want to do this there is no
technical problem with this it's just a
decision and you have to go through and
find all the places in the grammar that
can create problems and see what you are
what you can do or not do by the way I
can see Gaby's head sort of nodding off
he has implemented most of this this is
not science fiction not this one but I
believe that one is implemented yes and
the others are and that one is
implemented but we do have some problems
here boom boom boom that was the wrong
way stander and then you have to
integrate into the standard library so
otherwise maybe this was why we wanted
this right so you go on and give its
vector so I'm going to stop here and
take questions yes
matrix can I take the initializer list
type initializer list okay Kendall is
committee and that I had one more slide
that's your answer you can take a vector
and of course the elements of
initializer list can be initialized
lists and really adore goes down so if
you want a three-day D vector matrix you
can do that too no problem yeah what
what is the type of an initializer list
that's a real tricky question and you'll
have to do for revision 3 to get the
exact right answer ideally you want
everything to have a bottom-up type and
if you did that the type of initializer
list would be a union type of product
type of all its member types and it'll
create havoc throughout the type system
so the rule is that we don't ask what
the type of initializer list is unless
until we have found what it's being
initialized to and then we say okay this
element knows what if this dis
initializer knows what it wants and
we'll see if we can convert all the
elements into the right thing that takes
care of a raised it tears each sequence
initializers it take care of
constructors take care of everything now
the only place where you have to ask the
question what is the type of initializer
list this if you want to deduce some
type I you have a template say say you
have a vector of tea and you have it
initialized with an initializer list
then you want to deduce tea and there
are certain forms of all over a solution
to where you have to make some deduction
if you have to do any form of deduction
say we have two choices we can say we
don't know what the type is
forgot about the product types that that
does that doesn't work what we actually
say is that if any deduction is needed
the list has to be completely
homogeneous no conversions of any form
in which case it becomes the initializer
list of its element type I really don't
want to be in the situation of how to
decide whether they initialize a list 1
comma 1 comma 1 comma 1 comma 1 comma 10
comma 1 comma 1 comma 1 comma 1 this
initialize the list of doubles because
you can promote all the introduced
doubles or initialize the list of
integers because there's only one little
double out there if i get time I
developed a little type system based on
metrics for this and if i get time
before april the first i'll write it up
but-but-but-but know the rule is what
about it is here it has a type that you
can use introduction situations if and
only if is completely emotions
how the medical sector who stays up to
I mean for instance the map he I will
have a sequence initializer that takes
that that takes pairs let's still
homogeneous and pairs will take a nun
they'll take an ordinary constructor
that takes a string and an integer
that's not homogeneous so it just falls
out yeah a sequence constructor will
take homogeneous ones provided they can
all be converted to the same type
ordinary come structures will take
non-homogeneous I have several questions
in the back so i switched through those
curlies to me neither homogeneous or
heterogeneous initializers yeah but it
it seems to be that you don't you don't
ever really want one to be substitutable
for the other if it wasn't for the
historical reasons I would really like
to make that distinction explicit
there's nowhere that i want to write to
initialize are listed I want to be
interpreted either OGD ously or
heterogeneous Lee I don't believe you
okay I mean I could I could be very
polite and I decided it would be the
exact opposite I have never met anybody
that when they actually started writing
code could maintain that purity it's
people do mix things up and people do
want conversions so my guess is that
even if I decided to do this today you
could could say initializer list is just
initialize a list and the other since x
is for the rest I will definitely try
this again but this head this is a
slightly different problem so and it has
different problems associated with it in
particular you immediately say well it's
non homogeneous but then you say well we
can sorry it's non uniform where you say
oh it's not it's uniform because it's
uniform and the way we initialize it's
just as these party
killa initializes that i initialize our
lists the problem is the many people
then start to want both homogeneous and
heterogeneous initialize the lists we
get problems with where we can deduce
things which was the tension I went out
on him and we get a whole new set of
problems so maybe there are two
solutions one wear their uniform in
terms of the syntax and one where the
syntax is uniform but there's
heterogeneity in the way we use the list
but but the problem will come up the one
way or the other the one thing that
makes me feel slightly uncomfortable is
that is the is the sort of fall back of
either matching an initialization list
constructor or matching an orchestra
structure and it feels like let's say if
a ski had some sort of extra brace types
in it and you had like you know extra
curve you know you have that curly one
curly too if you had the option that I
could say have a curly with a subscript
on it that says this curly really means
an initializer look like a initializer
list this were a homogeneous versus
header if you slip in there with in
there I'll get back to you right away
here so first of all the lists turns out
to be homogeneous heterogeneous whatever
and people want them in and if you
really really want to say this is a list
you actually have two ways of doing it
you can simply say initialize a list of
tea and then it is a particular
initializer list of tea and then
somebody observed I think of me that
this problem only appears for very short
lists for big lists they'll never match
anything but they initialize the list so
the problem happens almost invariably we
list with one or two elements cero takes
care of itself also so you won't really
want to be able to distinguish saying
this is an initializer list of two
elements you can write initialize a list
but that's
long well the actually is an escape
clause that's been the language for 30
years so you're right open curly 1 comma
2 comma close curly how much rather have
had prefix and suffix but since the
problem only appears for one or two
elements put that comma at the end and
it will never be interpreted as anything
but initialize a list as I said this is
a low art it's a very complicated puzzle
with many many dimensions but I do think
that if I it had been unconstrained it
will still have been a hard puzzle
because people's needs of initializers
are amazingly varied anytime people
think of a great idea they will put it
down into their code as some kind of
object or class or something and then it
will start initializing it therefore you
get just about anything people can think
of as an initializer list that's that's
where the fundamental problem comes yes
and initialize a list will be an r-value
oh I have to repeat the question are
they a first class thing that you can
name a pin and manipulate in some sense
no they are not the idea for an
initializer list of say the element one
is the integer 1 they are Valley News
not objects and so you can create and so
you cannot have a variable of type
initializer list and and and do all
kinds of things with the model is one
not the integer a I this is the problem
I had with the with the see example I
really don't want one to have any more
values than one so this kind of
first-class idea is definitely
compromised right there but I think in
in order for another and even more
fundamental ideal which is at valid user
values
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>