<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2011: Lightning Talks II (Web Testing) | Coder Coacher - Coaching Coders</title><meta content="GTAC 2011: Lightning Talks II (Web Testing) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2011: Lightning Talks II (Web Testing)</b></h2><h5 class="post__date">2011-11-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bU5lb32EY8s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">fire alarms schmeyer alarm I bet they
had all the fire test cases and they
forgot the water one one of those edge
cases the only a tester would have found
all right you all ready for lightning
talks day too what about what about Tony
and Simon but how do we do this morning
right all right all right now later i'm
going to make Tony and Simon leave the
room and I'm going to ask you again what
you thought about good morning okay here
we are we have kind of a mozilla Google
sandwich going on here it's going to be
google mozilla google mozilla google
don't get the idea that we like each
other particularly much don't get the
idea that we dislike each other
particularly much either i think they
have a browser you have a browser right
mozilla yeah Netscape is that what it's
called no something very foxy and very
on fire okay so same rules as yesterday
dunia burrata from google you're up
hello everyone my name is dunya and I'm
an engineer at Google I work in the
initial seems so today I'll be talking
about Android testing and especially
native and web of testing and then I'll
say a couple words about very basic
setup in the clouds so let's take a look
at native apps testing android when you
build an Android application there are
three main aspects you want to look at
one is functional performance and then
the responsiveness of your application
when you look at functional testing
android has two great AP is which
actually their instrumentation framework
which is the Android instrumentation
framework and the accessibility
instrumentation framework and they
provide a set of hooks into the
operating system that allow you to
actually interact with your web
application like a user would do some of
you may be more familiar with robotium
which is
a wrapper around those instrumentation
framework and delegates call to to those
api's then if you want to do performance
testing there there is the performance
test case class which allows you to
collect a great latency data about your
application there is DDMS which lets you
look at for example how much he hit me
maria thread is using at a particular
point in time and there is something
called traceview which is a great tool
to know when a tread our method starts
and stops so you kind of can monitor the
entire set of your application
throughout the execution of your test
for responsiveness there is an api
called strict mode and this is a great
API to actually detect any illegal
behavior especially when you want to
ensure that your application is always
responsive so for example it's free
signal when the UI thread is too busy
doing some network or D success for web
application we have we use selenium
webdriver which has an android
implementation and the nice thing about
it is that we also support native event
when we interact with the Dom so this
means that any user interaction like any
touch action that you send to to
interact with your web application is
going to use native key and touch events
so we do we don't substitute that with
JavaScript to interact with the web
application we also have html5 support
let's quickly take a look at what the
code would look like so for example here
we're gonna we have a google image right
and we're going to flick an image across
the screen we're going to make sure that
the next image is displayed and then
we're going to rotate the device so we
can do that with webdriver ap is just
like you can see first we have we look
up an image by its HTML ID and then
we're going to create a freak action x
400 pixel horizontally across the x-axis
and then we're going to look at the
second image make sure it's displayed
and then called rotates on the driver to
were to rotate the screen and make sure
that the image has been resized so this
is this is giving you a taste of what's
possible for Android webdriver we
actually give you this in two possible
flavors one is you can run the test
remotely the other one is running the
test on the device directly which means
that so when do you choose what running
the test remotely is great because it
allows you to use any of the selenium
webdriver bindings meaning that you can
write your tests in Java Python Ruby and
any other language binding stadium
webdriver supports running the test on
the device directly is a lot faster but
at the same time you can only write the
test in Java so if you're okay with that
choose the second one so let's a quick
word about the cloud Android is android
emulator is nothing but a virtual
machine and which can run on most
operating systems so if you have a cloud
setup you can fire an android vm on
those machines typically you want to
have one day at a time / emulator and
you want to fire an emulator when a test
request comes up so you can also start
up multiple emulator per machine as
Simon mentioned earlier in his talk so
because android emulator is trying is is
an emulator so it emulates the entire
virtual machine including the virtual
CPU mm you it's actually can be really
slow especially when compared to the iOS
simulator for example which doesn't try
to emulate I need anything so it runs on
your Mac at full speed so there are
things we can do actually to make the
android emulator a bit faster on your
cloud setup especially you can disable
all the cosmetics and you can start the
imager from snapshot image this
drastically improve the performance I
think an emulator starting two to three
minutes with the snapshot it can start
in two seconds thank you very much
well done duniya next up we have someone
from Zilla not Zilla Mozilla David
Clarke you're up okay can you hear me
okay you can hear me great okay so I am
David Clarke I work at Mozilla I'm in
automation services and the project that
I've been working on is jas test net the
purpose of the project is to be able to
test javascript integration tests in the
cloud so let's move it along okay so the
first thing is JavaScript integration
tests are difficult there's problems in
how you execute JavaScript tests how
what language you're going to write in
and how you're going to report those
results so this is not an itch it's
going to show up in a lot of new web
apps that you're creating it's going to
show up in a lot of web at web services
that you're creating you're going to
want to be able to test JavaScript
because javascript is doing more now
that it's been doing in the past so and
sometimes jstestdriver is not enough we
want to be able to test javascript in
more invasive ways and it is enough but
sometimes you have to change the tool
for what you're trying to accomplish and
so regressions are not typically have
been a problem in web services you just
push code to your web services restart
your web services and the client side is
usually fine that is not always the case
right now so what we've been looking for
is a framework that supports a few
different things we are interested in a
continuous integration we want to be
able to report our results we are
interested in we'll just let that keep
running we won't even bother with that
anymore so interested in continuous
integration we're interested in a simple
framework that allows that's extendable
we were interested in
finding an environment that was
deployable and we could run over Jenkins
continuous innovation so this is the
architecture that we had that we that we
set up in our lab environment so Jenkins
continuous situation speaks suggest test
at lib jss net lib speaks over our JSON
wire protocol to our just jss net server
which attached to that is many different
browsers so I've listed a pretty much
all the important browsers that I could
I could think about if you can think of
any that I forgot just send me a tweet
or something so but the interesting
thing about this architecture is that
allows us to change out different pieces
that we find are interesting so rjs test
net lib is actually powered by nose
tests is anybody familiar with Python
test environments sonos test it allows
you to completely rewrite how you want
to report your results so you can report
them in a J unit manner you can report
them to whatever kind of environment
that that's interesting for you so once
again we'll forget what's going on out
there so that's very nice and then
there's also another capability which is
extending the JS test net server to do
more interesting things on the browser
end and we'll talk about that so so I
guess one of our problems with running
our continuous integration was our tests
required hidden iframes so we have many
different I frames and they're all
talking to each other and that was
actually quite difficult to do in in
jstestdriver so we went around and we
started looking for other test
frameworks that would enable that so so
I guess framework extension came Billy
is there but only along certain accesses
that we care about and one was reporting
and the other was allowing us to write
our tests in different languages
so we wanted to so opportunity so the
opportunity was this project was to
improve our integration testing
capabilities we wanted very html5 ish
kind of capabilities we wanted to be
able to inspect the Dom we wanted to be
able to wow that's quick okay well I
guess my time itself thank you okay love
it you might get an extra couple seconds
of his last slide so this is matt Devore
native driver from google hi my name is
Matt Devore and i'll be talking about my
project native driver native driver is
an open source library for testing the
UI of native applications for android
and iOS at Google we have had many pain
points with existing test tools and I'll
explain what those are and how they lead
to the idea for native driver then I'll
tell you what NATO driver is and how it
fixes those problems so then we'll look
at native drivers architecture and I'll
show you how you can try out native
driver yourself then share with you the
current state of the project so what is
wrong with current test tools and common
use first each platform test you want to
test requires use of a different API if
you test an app for both web and iPhone
clients for instance you'll probably be
using webdriver and then UI automation
for iOS so a recent trend is also to use
image based test tools and image-based
test their images embedded in the code
and the test driver performs operations
based on where those images are located
on the screen but then when you try to
support new languages are platforms a
number of images skyrockets and you have
to update images all the time so also
the language used to write the test and
the application are often different
which which makes up more knowledge
necessary and we also have a a trend to
embed web content inside the native app
and we want to also handle that in a in
a nice way so so one thing so to sum up
the
the difficulties is that you need a lot
of extra knowledge because of all the
api's and languages and there's a recent
trend that we want to handle native and
web content in the same map and also the
large number of languages needed to you
need to know so native driver is is an
attempt to just all these issues it is a
multi-platform solution for testing
native apps in each platform it's an
extended blood driver API which is
served between all platforms so here is
a sample tested native driver and you
can see we start out with start activity
which is a lot like going to a URL in
the browser and then we do a common
pattern in web in webdriver test which
is fine an element buy some property and
then perform an operation on it these
are all normal webdriver API calls and
the other thing that this test does in
the next slide it rotates the screen
which lets you test in landscape mode
this is another common Android API call
so so far we've only seen one new API
call that we've had to make that's for
antenna wit webdriver so next I'd like
to show you the architecture of native
driver ants to show you how it does a
upon existing test tools so test
execution is comprised of a server and a
client and the server is the app and the
Android device and the client is a test
the server and client communicate
through two channels the Android debug
bridge and the webdriver wire protocol
which is based on HTTP and JSON and the
Android debug bridge is a common Android
testing utility which is allows you to
inject events into the device but it's
not easy to get you I information either
device and the instrumentation is driven
by the wire protocol and that that can
get in for more info out of the device
but it has some security limitations so
instrumentation is generally very low
level and it requires knowledge of the
absolutes white box testing Android
debug bridge is not a full testing
solution but it's a utility to
communicate with a device or an emulator
by the command line and it's useful
injecting events and it doesn't have the
same security problems as instrument
limitations of instrumentation so if you
compare these two side-by-side you
you can dry many platforms in native
application tests with a single API and
it's totally black box and using
existing webdriver language by isn't
bindings it's easy to support any
language that you want so then because
all you test unify with a single API in
language then you have more opportunity
to share tests but to share code between
several different tests so you can try
out need to drive yourself by going to
need driver googlecode com and it's
downloaded from there there's also
getting started tutorials and demo
videos and for both platforms that it
supports iOS and Android you can also
communicate with other people on the
mailing list there are links that from
the native from the google cloud site
there and please ignore the slider
didn't have time to talk about it and so
our next steps for this project for iOS
version we want to create objective-c
client bindings and implement advanced
gesture support and screenshot support
and for android we're working on plugins
support to support custom UI controls
and OpenGL abuse for instance and also
web web view support to to make the
connection between web and client
testing and that's that's everything so
thank
great job Matt all right next david
burns from mozilla so my name is david
burns i'm a lead software engineer and
tester mozilla and today i'm going to be
talking about how we could possibly
generate heat maps while I test our
webdriver tests are running and it's
kind of come around from number of
managers going all I've seen these
webdriver test running can you tell me
what coverage they have and normally as
an automator developer or tester the
answers always always the same I can't
but how about you take my word for it
this doesn't always fly with managers
they like shiny things they like images
mean you know we have to solve these
problems so what we'd like to show when
you know when we run our tests is
something like this this has just taken
from usage stats from Firefox but it
kind of shows where people are clicking
around the browser things like that in
theory it should be fairly simple to do
with webdriver because we we should know
where all these things are ok so the the
problem is is that like with webdriver
week or it's not a problem web drives
great because it can tell us everything
that we need to know about what's
happening on the page we have full
access to the Dom we know where all the
elements are on the page which is great
so we can just go I need this element
bring it back to me webdriver also knows
the size of elements on the page so you
you've already told your test that you
need this element you then go can I have
the size and because like it knows the
DOM and everything it's pretty pin point
where it can say
we're on the page this is where its
location is and because web drive is
great it can take screenshots so now we
need to kind of mash all of this
together to get the product that we want
so what are the things that we need to
put together so we need to kind of
override the web element objects because
we have web drivers split into two main
objects so you have your driver your web
element or your elements and so when we
get it we need to get all this
information but as we like like use the
elements we need to take a screenshot
get it sized get its location and we
need to store all of this information
there is one downside to this taking
screenshots is quite heavy it uses a lot
of disk space and to get all of it so we
also need to now solve the problem of
moving collecting all this information
and making it useful so we like a good
example as I click a button a there's a
reflow or a render on the page a div
comes up so that we can like interact
with that do we need to create a carry
on with it and then so we need to solve
that problem well so because tests are
running we don't want to impact how
quickly the tests are running we want
our test to still run as fast as
possible so we need a separate pricing
certain processing system so that we can
collect like once the test is finished
we then have though all of it and then
process it and have our test today I
have a proof of concept kind of working
so if you have any questions please come
find me cool and get faster than
lightning next up Jerome Muller from
google Zurich so I tried to speak slow
but I make no promises okay
so my name is Jerome Miller I work on
google calendar and today I'd like to
tell you about how we write our tests in
plain English and why we do it and how
we automate those tests about a year ago
calendar development moved to our team
and my job was to look at the automated
tests so I looked at them and the very
first question I had is what exactly do
those tests actually cover so I looked
at them a little bit closer and the
tests the selenium tests are very
fine-grained it's click here enter some
text there and it's a lot like looking
at the picture from very close and it
looks all pixely and you can't see the
full picture of it so we decided to
separate the what is being tested from
the how it is being tested and we wanted
to use plain English for the what is
being tested and use java and web driver
for how it's being tested so we turned
to behavior driven development to rescue
us and PDD tells us to write usage
scenarios essentially saying the what
needs to be tested without worrying
about how it's going to be tested it
also suggests to use the words given van
and then to start your sentences so you
end up with tests like given an event
when I delete it then I do not see it
anymore it's a very simple case so we
wrote a few scenarios and we try to keep
them very high-level very easy to
understand and the syntax you see here
is actually taken from cucumber so we
heavily relied on that then we started
implementation of those sentences that
we just wrote off those scenarios and
the way it works is that we have Java
methods which get annotated with regular
expressions here and the group gets then
mapped into the method as a parameter
the methods themselves are very very
small that you
contained actions that are needed to
execute that one sentence so we delegate
to page objects really quick after about
60 scenarios we had a little milestone
reached we were able to submit a test
script without actually touching any of
the Java code or Java testing code at
that point we wanted to also involve the
manual testers and our engineers in
writing the tests for the engineers we
actually had to add a little ruled that
they can't release a feature without
adding an end-to-end test we found out
that this whole approach has quite a few
advantages for us and for example it's
very easy to understand why a test fails
it's easy to see where it fails and it's
very easy to manually click through and
see what actually happens because I have
all the steps there now it's also very
easy to find out what the overlap is
between our manual test cases and our
automated test cases because they're
both in English it I can delegate that
task to anybody it's easy to understand
we ended up with well-structured codes
we have the English what is being done
on top you have to sentence
implementation the actions that every
sentence needs to have and the bottom
part is to page objects when they
contain the test script reviewing a
coherent set of code changes to be
submitted in an atomic operation also
known as change list is easier to
understand than this sentence and the
reason for that is that the test script
contains a summary so we had some
problems too refactoring the sentences
is kind of hard because we don't have ID
support and we don't use the sentences
in any of our API tests so in the future
I want to take this whole thing a little
bit further we're not there quite yet
but I want to free our manual testers
they shouldn't do any regression testing
anymore they should be more involved in
automating tests and have more time for
exploratory tests then I also like to
think a little bit bigger I'd like to
have sentences that can be used across
it's a lot of projects have to think
about the same things like security
accessibility and other things so I
would like to have sentences that say
then the contrast is good or then the
page looks good in for that
bi-directional languages as we have
heard yesterday and and I would like to
take it even one step further and help
make cross projects integration tests by
having sentences like then I plus 1 days
or when I plus 1 this then XY set gets
shared on my stream my five minutes are
up thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>