<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2013: Appium: Automation for Mobile Apps | Coder Coacher - Coaching Coders</title><meta content="GTAC 2013: Appium: Automation for Mobile Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2013: Appium: Automation for Mobile Apps</b></h2><h5 class="post__date">2013-04-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1J0aXDbjiUE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and so not only enter into the afternoon
we're going to have Jonathan lips from
sauce labs come and he's going to speak
about
appium and automation for mobile apps
I'm an interesting fact about Jonathan
he actually has a degree in philosophy
so he's actually pondering why all of
you are here and he also said he wrote
automated tests before he even knew what
a unit test was so maybe you could ask
him about that later and so with that
I'm going to hand it off to Jonathan so
thank you thanks a lot it's really fun
to be here with you guys and I've
learned a lot as well so I'm here to
talk about appium um it's a pretty broad
and big title and I think you'll see why
that's the case in a little bit I work
for sauce labs and many of you are
probably familiar with sauce and that
sauce we care a lot about the maturity
of the automation ecosystem in general
and we've been paying a lot of tension
to mobile automation and really wanted
to be a part of this kind of new new
phase of mobile development where
automation is finally starting to have
its day so I've had the opportunity to
work pretty much full-time on this open
source project called appium during my
day at sauce for most of this year and
together with a community of people who
don't work at sauce and I'm really
excited to show you guys what we've been
up to Mobile is taking over the world or
so I keep hearing people say and I guess
it's true
the statistics show it to be true but if
it's taking over the world where is all
of our awesome test tools stuff whereas
really awesome mobile automation
frameworks where as painless mobile CI
that doesn't require the PhD to figure
out how to get your certificates on to
your app in your app on your device yeah
it's just the beginning of making these
tools really available and
I think the appium is going to be a part
of that one thing that we haven't
touched on as much at this conference is
the multi-platform nature of the mobile
revolution if you want your mobile app
to be used by many many people you
probably have to have an iPhone version
and an android version at least and
there are new entrants to the mobile OS
world all the time of course these
different versions mean that it's
complex for development and complex for
testing as you know Android and iOS or
very different user experiences very
different user interfaces and most
importantly for us they have different
SDKs so you actually have to write your
apps in Java for Android and get to see
for iOS that's a real big pain of course
you could write a hybrid app which is a
thin native wrapper around a webview and
your app is basically a web application
and that's a pretty successful approach
to this challenge but as certain large
companies have publicly admitted the
performance of hybrid apps is not always
what we want it to be not always what
users expect and so for the time being
at least we're stuck with these two
large platforms that we want to support
with our native apps and that means that
we want to support with our QA and with
our testing with our automation so I
want to try and tell you guys why I
think that appium is a cross-platform
solution for this problem notice the
slide says native and hybrid so appium
cares deeply about native automation it
aims to be a great testing framework for
iOS native apps and Android native apps
more than that it aims to be a
cross-platform testing framework by
which I mean writing one test and having
it run and pass hopefully on
platforms we also care about hybrid apps
so there are some really interesting
hybrid apps that kind of blur the line
between mobile apps and web apps and
they need good testing and QA and that
means testing the native wrapper however
thick or thin that is and testing the
the web component and we want to be able
to do that from the same test script
very easily appium also supports pure
web testing so if you just want to test
how your web app runs in Mobile Safari
or Chrome on Android you can also do
that on a p.m. and finally a p.m. aims
to support both simulators emulators as
well as real devices so whether you want
to run it in your on your white board of
mobile phones that are glued there or
whether you want to run it in a nice way
that we also saw in that presentation
where you have a bunch of emulators
running on your desktop you can do both
so in these early days of mobile
automation I really think and maybe it's
just because I studied philosophy but I
really think that philosophy is very
important and will determine the
trajectory of a lot of these projects
that are rising up right now like appium
and so in this section I want to tell
you guys a little bit about what a PM's
philosophy is why we felt it needed to
exist in the first place when of course
there were other tools and I think you
will come to see that this philosophy is
definitely a bit opinionated and it may
not be the only right way to do things
but I hope to convince you that some of
these are good ideas at least so you can
think about a Coombes philosophy in the
form of four rules or principles the
first rule is that you want to test the
same app that you submit to your app
store you shouldn't have to compile in
third-party libraries or frameworks in
order to test your app I think we can
all understand
the reason for this if you test one
version of your app and you submit
another version of your app to the App
Store what if this version actually has
bugs and I think we've all been bit one
time or another by issues like this so
if you can submit an app binary which
has actually passed tests that instills
a great sense of confidence in your code
and in your applications behavior
secondly we live in a world where people
code in all kinds of languages
increasingly multiple languages in a
given day so why should your test
framework tell you which language you
have to use and why should your test
framework tell you which other framework
tools you can use or not use in which
API is you can use and not use we think
that the mobile automation framework
should be as agnostic and as general and
inclusive as possible
so that as I believe as Igor said
yesterday you could have a team of
competent Java developers or expert Java
developers who decide that actually our
test suite should be in Ruby because it
just makes more sense for it to be
interpreter based and to hook in better
with Jenkins or whatever it is just
because you write your application code
in Java or Objective C doesn't mean that
you should write your functional tests
in the same way I think this rule is
very important use a standard automation
specification and API we've been through
standards Wars in many different testing
arenas in the past notably web testing
and I don't think there's any reason to
go through that again
and as Malini mentioned yesterday there
is a whole ecosystem of tools that
already exist for these other
specifications that we could I think her
word was uplift and and reused in the
context of mobile automation
I think that's really important for
getting people from no mobile tests to a
lot of mobile tests very quickly when
they're using a specification that
they're already familiar with and I'm
going to talk a little more about this
in a bit another very important aspect
of building a mobile automation
framework is building a great community
around it we strongly believe that this
community should be open source and it
shouldn't just be open source in name
but it should be open source in spirit
and in the energy and collaboration
efforts that exist around the project it
seems to me that these projects are the
ones that actually tend to win in terms
of technology to just having that
groundswell of user support filing bugs
on github and contributor support by
submitting patches and really making the
project better I think this is what
ultimately will win win developers over
to to using your project and so we think
this is very important and are trying to
make appium as open and as friendly and
is easy to hack on for everybody as
possible and just recently we resolved
our four hundred and sixtieth ticket on
github I think that's not all issues
that includes pull requests of course
but to me it's been really awesome to
see a lot of people contributing and
participating so we think that's
important okay now in this section I
want to talk about how appium was
accepted to be the mobile automation
framework for the u.s. space program
actually that's not true I'm going to
talk about how appium exists in the
space of other mobile automation
frameworks and I want to talk about how
it exists in comparison with these other
frameworks on the level of philosophy of
the points that I just brought up not
necessarily on the level of specific
features at this point
so here's a view of what's kind of out
there right now for iOS automation you
got calabash Frank you can use raw UI
automation JavaScript and instruments
can use UIs driver or kif and Android
again calabash and you've heard of all
these I expect and we learned a lot
about UI Automator today so you know how
how that works it's also a project
called Solyndra which is based on
instruments and there's a little
asterisk by that one because it's
actually available from within IBM now
too so it may or may not be a separate
framework but anyway you can see that
I'm trying to make a point with this
slide in terms of where I placed a p.m.
none of these other frameworks really
try to do cross-platform
or if they do they do so in a way that
doesn't keep the same API so appium is
trying to sit right in this middle spot
and say hey let's let's automate our
cross-platform apps using one one
platform one set of tests here's a
little comparison chart and again this
is not comparison based on features but
on how well I see these projects
following the rules that I mentioned and
ultimately it was this kind of
perspective that led us to want to build
something like appium because we felt
that there was a spot for a project that
followed these rules and would
ultimately lead to a mature automation
ecosystem for mobile now this is my
subjective take and you guys might
disagree with some of this and I hope to
hear about it over beers tonight so or
during the Q&amp;amp;A I suppose now another
word about selenium webdriver and this
goes back to rule 3 which I was used as
standard automation specification and
API the stuff I have here on these
slides repeats a lot of what we've
already learned in the last couple days
if you weren't familiar with selenium
webdriver
now know quite a bit about it from what
other people who said the basic point is
that there are a lot of Automator as
testers developers people who write
tests that are already familiar with
this model of automation so we don't
think that there's any reason to go back
to the drawing board and come up with an
entirely new model for mobile of course
the model can't be exactly the same
because there are some differences
between the way people interact with the
web then the ways that they use our
mobile devices but with a few properly
situated extensions we think that the
webdriver spec is relatively mature and
a good place to start for mobile
automation not only that all of these
tools already exist around webdriver you
have client libraries in every language
including languages like Haskell and go
and closure I don't think there is any
in Pascal or maybe even C but you know
that will probably change someday it's
also somewhat official one of the chief
conspirators behind this situation is
here and I think it's a great thing that
there is momentum behind this this one
standard you guys all know the xkcd
about standards and what we're trying to
avoid is exactly what that cartoon
depicts so we want sort of standards
deep proliferation if you will so
hopefully I've convinced you that using
webdriver as your automation protocol
and mobile is somewhat of a good idea
now I want to talk a little bit about
what appium looks like under the hood so
what does a mobile automation framework
that adheres to this philosophy actually
look like how does it work well it's
basically a web server that creates and
handles specifically webdriver sessions
so at this point it's basically exactly
like a selenium server it receives
requests from client libraries which
speak JSON over HTTP and
and it handles those requests in
different ways depending on the platform
that you're looking at for both iOS and
Android appium starts a test case on the
device or in the simulator that spawns a
server of some kind and listens for
commands from the main appium process so
I have test case in quotes here because
each of the vendors supply a way to run
test cases on the emulator on the
devices and a p.m. sort of hijacks these
and stick something in there that can
they can lie around forever and we can
send commands to and get results from
that's kind of the hack that makes all
this work specifically for iOS appium
proxies these commands to a UI
automation script running in the
instruments context
so Apple provides this application
called instruments and it's a it's a
graphical application that lets you do a
lot of things with your app so lets you
profile them and find memory leaks and
all kinds of stuff that's irrelevant to
automation but it also has an automation
component actually a little box where
you can type in JavaScript and this
javascript has access to an API called
UI automation and you can click a button
and it will run in the contacts of your
application so we sort of take this and
abuse it in order to fit our needs so
let's camp on this diagram for a little
bit if you take a look at the right hand
side with the picture of the shiny
iPhone there's a little box in it which
has bootstrap j/s so it turns out that
you can actually launch instruments from
the command line and instead of typing
your javascript in a in a box you can
provide instruments with a JavaScript
file to be executed on the device
once your application is loaded so we've
taken
this javascript file and put an infinite
loop inside of it and each time you go
through this loop we call out to the
command line because this is one of the
things that Apple has conveniently and
inexplicably included in its UI
automation framework as a way to call
out to the shell and to run arbitrary
shell commands so we use this power to
launch a UNIX socket client it's
actually written in node and this client
wakes up and looks for a UNIX socket
server that I'm calling the instruments
command server which is part of the main
appium process and this command server
can then say oh yeah I have a command
here we go gives it to the command
client this command client writes out
the command to standard out just picked
up by bootstrap J s and that's executed
in the context of instruments and thus
in the context of your application so
how does a command lifecycle go
starting at the the left with your
webdriver script let's say you have a
command like I don't know click click on
an element so your webdriver script will
create a HTTP request to the main appium
server it will send that request in the
form of JSON over and appium will since
it already knows that we're doing iOS
automation in this case we'll pass it on
to the instruments command server and it
will sit there and wait until the
command client on its next pole wakes up
and asks for a command we get at the
command the command goes all the way
back to bootstrap J s and as executed
the result is retrieved the command
client wakes up again talks to the
server says hey I've got a result from
the last command that you sent me the
command server says great thank you very
much
by the way here is the next command that
I've been holding on to while you've
been slacking off working really slow
and it sends the result all the way back
to your script so you can evaluate
whether the results is is appropriate in
your test so a situation is similar with
Android and instead we proxy commands to
a UI Automator test case so we now know
everything about UI Automator and we
know that it runs in these special test
cases J unit test cases on on the device
so the picture here is a little a little
simpler because Google has decided to
give us tools that make a little more
sense you can actually run UI Automator
scripts from the command line very
easily presumably they could be part of
your CI of course they have to be in
Java and that's one of the things we're
trying to get away from no offense to
the UI Automator team has done an
excellent job so here we have instead of
bootstrap GS we have bootstrap char and
this is our UI Automator test case and
compiled in java and it gets launched on
the device and as soon as it is launched
it actually spins up a TCP server so in
this diagram the server is on the device
and the client is in the appian process
so it's a little mirror image of what
was going on with the iOS so the
lifecycle of a command here looks like
your command comes from your script
again goes to the main appium server we
know that you want Android this time and
so the command goes to a TCP client that
a PM brings up connects to the TCP
server on the Android device gives it
the command and again the command is
process result is passed back all the
way to your test so you can evaluate how
it's going so that's what happens under
the hood that's how we can provide one
kind of front-end API to these two
completely different mobile automation
backends let's see what it actually does
in action before I run the demo I just
want to point out that
I think it's really cool that appium
opens the door to true cross-platform
mobile testing in other words one test
in two mobile platforms we've been used
to this for a while with web browsers
you can write one selenium test that
runs on all the different web browsers
and so you can uncover cross-platform
issues but so far this hasn't really
been possible or easy with mobile
devices I happen to have a app that was
developed for iPhone and Android with
the same kind of UI and layout on
everything there's a company called
woven that has this photo aggregation
app brings in photos from all your
different media sources around the web
and shows them in one place and the
woven team has been involved in helping
appium development for a long time and
they were kind enough to give me a
couple builds of their application
let's look at some of the code that is
going to be involved in a demo so in
this slide I have a couple sets of
desired capabilities and by the way
we're in JavaScript for this demo if
you're not familiar with selenium
desired capabilities our ways of telling
the server what sort of thing you want
to automate so in this case we have
desired capabilities for iOS and we're
saying that we want the iPhone simulator
device and for Android we want Android
then we have to say what app we want to
automate so we can literally just pass a
path to the pre compiled application for
Android we need a little bit more
information because of the way that we
start the app we don't want to go
through the whole process of clicking on
the apps button swiping screens and
finding the app we just want to launch
it immediately so we use certain
commands that require the app package
and activity that you want to launch
and I have a configuration section which
encapsulates the few differences that do
exist between the iPhone and Android
version of this app these are selenium
selectors that because of the difference
in the equivalent of tag names I guess
or or UI element names because of the
differences that exist on these two
platforms
I need different selectors now this is
something that could obviously be fixed
with certain tag name conventions in the
future but for now I just have these few
few discrepancies so this is what my
test code looks like I'm looping through
each of the configurations so I'm going
to run the test in series in succession
first I'll run the Android test then the
iOS test and for each of these
configurations I'm initializing a
webdriver session that's what happens in
the the described block here it has
custom code that I've written that
launches a webdriver session and shuts
it down after each test and the actual
test logic looks like this or this is
the beginning part of the tests that
you're going to see driver series is
again something I wrote so that I could
have all of these methods appear one
after the other on different lines
rather than having a big JavaScript
callback pyramid that looks really
horrible on slides so what's going on
here is that we're finding an element by
its name which in the case of Android is
the content description that we learned
about we're clicking on the element
we're finding the email field typing in
my email address
finding the password field and typing in
my password and then we're sending a new
line which is the signal to the app that
we want to hit the Go button
on the keyboard and this is just for fun
in case JavaScript isn't your thing
here's how I would have written the last
bit in Python so you can see it's very
similar you can do this in any any
language that has a webdriver library so
I was planning on doing a live demo but
I have learned from the woven team that
the builds I have are rather unstable
and indeed I noticed that a few times
when I was preparing this and we all
think it's probably a better idea to
avoid embarrassment all around and not
have the app or the demo crash right in
the middle of it so I have a video that
I'd like to show on oh I think you guys
have the video so go ahead and run that
it's quite long as you can see it's kind
of a basic smoke test to the application
exercises a lot of different aspects so
I've launched the appium server and now
I'm running the test the Android
emulator is in front and the iPhone
Chrome was behind it so don't get
confused here's the flow that we saw
typing in the email address password
clicking the sign button and now we're
going to find a photo album and flip
through some of the photos find one and
tap on it and let the controls fade away
and do a tap to get them to come back
navigate back up swipe over and we're
going to try and find our account pane
the Android version of this app doesn't
have a sign out button which is what the
test is looking for so it's going to go
ahead and and end and we're going to
switch to the iPhone version so this is
the exact same code you saw the loop
that I had we're just running the exact
same test code inside of the loop the
iPhone tends to be pretty snappy because
it's
simulator rather than a true emulator
and we're doing the same things
now in the iPhone version of the app as
I said the account pane does have a sign
out button so we're going to attempt to
sign out of the app we don't really need
to since the app state is reset
automatically between each of the tests
but there we go we've got the alert
handled it and as you can see on the top
both tests pass which since it's a video
I would hope that they did so that's the
demo I think it's pretty cool that you
can actually have the same test running
on two mobile devices a word about how
you can actually kind of get started
with a p.m. if you're interested you can
run it from the command line as I was
doing you can get it from NPM if you
like node or you can actually download a
PM app which is a project to wrap a p.m.
in a graphical user interface by Dan
Cuellar and it's really awesome so you
can configure the server tell it which
app you want to automate do all these
things from a nice graphical interface
and you still have the same log output
for debugging but the coolest thing is
the appium inspector so this is a part
of a p.m. app once you've got your app
launched you can click the inspector
button and this window pops up and it
gives you a view of the hierarchy of the
application a little bit like the UI
Automator viewer that we just learned
about which is the tool that I've been
using for my Android test writing but
this inspector works great on iOS and
will soon work as well on Android lets
you introspect the app get element names
and features so that you can find
elements and interact with them from
your tests it even has a simple record
and playback tool so you can hit record
and then perform a few actions and hit
stop and then you can play those actions
back earlier
time so it's the equivalent of selenium
IDE for fur appium for mobile automation
and I think this was pretty awesome
there's an example of how you could set
up your desktop if you're using this
with your iPad simulator on the right
and your inspector and the appium server
and so on
so I just demonstrated appium in a local
context but there are some limitations
if I wanted to scale up this kind of
test running to use in a builder to use
in my continuous integration one of the
obvious limitations is that you can only
have one iPhone device or simulator
running and instruments for every copy
of Mac OS that you have so it's a
technical limitation that we haven't yet
figured a way around that any time you
want to run an iOS test on a p.m. it's
going to take a whole Mac computer so
it'd be very expensive proposition to
get an entire closet full of Mac minis
or whatever to run a bunch of these
tests in serial or in parallel Android
isn't quite as limited you can have
multiple devices connected and talk to
each of them
but either way there are some some
computational and other limitations so
the company I work for sauce labs has
been hard at work putting appium in the
cloud so that if you don't want to
install a paean if you don't want to get
all your emulators and simulators and
SDKs and devices set up and Xcode to the
perfect version you can just run it on
sauce instead and you can do it in
parallel which will greatly reduce the
time that your build takes so if you're
interested we're releasing this for
general consumption very very soon you
can check out that URL I'm not going to
take questions quite yet actually have a
surprise demo
which I will try and do live I was
really inspired by the Firefox OS talk
yesterday I thought it was really cool
that a team would build automation in
from the very ground level of working on
the operating system and given that they
also chose selenium webdriver
as the protocol choice I got Malini
yesterday and asked her to share with me
some of the details of how they
implemented that and I've actually got
Firefox OS support working in appium I
want to show you guys example of that so
let's switch to the computer please so
here's their little simulator that I got
and this is the test script that I'm
going to be running so I decided to
write it in CoffeeScript just for just
for kicks mmm basically where our device
is now Firefox OS and the app that we
want to automate is the contacts app
that comes with the device first thing
we do with the test is get our URL check
whether it's the right app that's loaded
check that my name isn't anywhere in the
app currently because the point of this
test is to add add myself as a contact
we click the Add button type in my
details hit save assert that the name
appears correctly and we click the edit
edit pane as well so let's try and run
this so here's a PM launched and trying
to run the CoffeeScript low contacts
launched
okay and everything was verified yeah
and I think you know at least 80% of
that applause should go to the Firefox
OS team for doing something so awesome
anyway I just thought it was a it was a
really cool kind of proof of concept of
how when you have the right protocol and
the right tools you can you can make
things happen really quickly so that's
it ready for questions yeah thank you
Jonathan what we're on
just waiting when two other ago thank
you yes saying take you Jonathan that
was awesome and thank you for for
striving so hard to put that out into
you know open source and giving up the
buddy LT ability to do this
cross-platform there are a lot of
questions I got earlier and I need your
talk was coming up and so it's great to
see like all these different devices
sort of having a place to to get this
automation um one thing I took away is
machines are a lot faster at typing on
these phones and we are it's beautiful
I'm sure you guys got something else but
that's that's what I got okay with that
I'll just aside we'll go to some of the
questions here so first one up please
your name where you're from and your
question please
hi I'm Basel I'm a test engineer at
Google mobile search so it was a neat
trick to reuse webdriver protocol to
enable testing on native applications
but can you also test webview
applications with with appium yes you
can I did not demonstrate that but
basically what happens is when you so
let's say for iOS you load an app that
has a webview in it you call the
webdriver window handles command and it
gives you a list of ID's usually one
because there's usually just one webview
open and then you can set that to be
your window and appium takes that to be
a signal that you actually want to
automate that webview from now on and so
at that point you're just writing a
regular web selenium test so all the
commands that happen are executed in the
context of that webview and then there
is a special command that lets you sort
of escape back out of that and automate
your native layer again so it's possible
to automate applications that take you
to webview and back to native so that's
a different question I haven't found any
way on on iOS on Android the answer is
yes because UI Automator lets you
control the entire device which is
brilliant on iOS as soon as your app
switches your your test is over because
the the instruments context only exists
in that app so there may be a way around
this but right now it appears like a
technical limitation thank you yes great
thank you
we have another question up over here on
the right please I Steve again from
Google so maybe I just didn't understand
I'm used to doing browser automation
writing X paths you said that this will
also work on native applications but
that you only need what write one test
across platforms how do i express
element locators if I know that the
implementation may be a native app or
maybe a browser so I may not totally
understand your question are you asking
what if I have a web app and a native
app can I test them both with the same
script yeah I'm trying to did you make
that claim that you can I made the claim
that you can test a native Android app
and a native iPhone app with the same
script because the the structure is
probably very similar I suppose if you
had a web app whose structure was
identical in terms of the hierarchy
because you can use an XPath sort of
bastardized XPath syntax to traverse the
hierarchy so if it's general enough I
suppose that would work I haven't I
haven't tried that but you can the one
thing that would work across all native
platforms and web is get element by name
so that's kind of what we chose as the
equivalent of ID in native land because
Android has content description iOS has
has name which is there like
accessibility label but neither of these
things are enforced to be unique so we
didn't want to use ID but you can also
use get element by name in HTML
obviously so if the name match on all
these three platforms you would reliably
find the element on all platforms thank
you
and one more question over here please
so Kevin Kevin Jean with Google so I
have a question about a how is it
different from native driver so native
driver is an unfortunately abandoned
project which since when we started
working on appium we knew it was sort of
abandoned didn't didn't get a whole lot
of a lot of attention
but this could be thought of as sort of
the spiritual successor to native driver
thank you yeah and so I'll take a
question from the moderator up here it
says for Android those appium support OS
is earlier than jelly bean yes recently
it does so you heard that UI Automator
which is the default mobile automation
back-end for Android is only supported
API levels 16 and up however there is a
separate project by a guy named Dominic
Gary called selendroid and it uses
instrumentation which is you know
available on much earlier API levels and
so what we've done is enabled selendroid
as sort of an appium add-on so that if
you run the solenoid configuration you
just ask for a solenoid as a device and
you'll be using that back end instead of
UI Automator so that's how we can get
webview support on android because as we
heard UI Automator doesn't really
support web views either great thank you
we have time for one more question and
you were up first
please hi this is deepali again from the
new york times my first question is how
do you validate your test results and
the following question is how the script
handled the crashes for example if you
open the app from the visit on Android
how the script handled the crashes think
no pressure you get 45 seconds okay so
in reverse order scripts handle crashes
by ending the session so usually it
knows when something is crashed and it
just ends a session you get an error in
your in your code that you're probably
not expecting and the server is waiting
for new commands how you validate your
code is the same way that you would with
a regular selenium script for the web
you can introspect
or I should say interrogate on different
parts of your application so if I like
what I did with Firefox OS I asked for
the text that was in a certain place and
check to make sure that it was equal to
my name and so that's where the
assertions come in and my test so what
about the images that display on the
device and for that follow-up I invite
you both to to talk as much as you like
out there great on with that Thank You
Johnson said yes yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>