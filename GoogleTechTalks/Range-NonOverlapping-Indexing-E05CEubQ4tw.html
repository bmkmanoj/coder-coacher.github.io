<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Range Non-Overlapping Indexing | Coder Coacher - Coaching Coders</title><meta content="Range Non-Overlapping Indexing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Range Non-Overlapping Indexing</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/E05CEubQ4tw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">maybe there is one of you who needs an
introduction to any farhat so just to be
on the safe side Ellie pirat started the
computer programming and hacking at the
age where most children they played
marbles and things like that and he's
done a lot of work since he's 0 to talk
now about something he did a year ago
which as far as i know is of no
immediate application but you never know
with things and they this is very
interesting so and ok i'm going to talk
about reg non-overlapping a in the clink
ok excite doesn't move the bat ok then i
start of the definition of indexing a
given text yep yeah ok it's tictac given
text i want to play process the text
judge that given a pattern I want the
fast enough to find all the location of
the pattern but in my application we
want to find all the non overlapping
location for example yeah you see that
you have your five location of the
patterns but the number of
non-overlapping location are honestly
and I will use this slide to say that
the text length is ends the patterning
sees em and oak I is the number of
occurrence of the pattern ill we counted
about four columns of the pattern of
non-overlapping that's a motivation but
most of them we're only for a for
selling the paper and not they actually
work let's exhibit a what time I what I
will show you you is a quick overview on
suffix lee after it oh I serving
non-overlapping index in and after it
our serving great query of
non-overlapping industry okay then
suffix tree I will start by writing all
the suffixes of the text or the Texas
banana well suffixes is banana I ed use
the dollar sign then it's banana and
Anna and so on and I will start by a
shooting at us for the world banana and
then adding you for it a pass for the
world and nana and so on as you can see
is that the distant past used by a 2a
suffixes but overall this tree can cost
of a n square space then we can compress
it by when we add you a pass a long pass
which a was only one child to each node
we can compress it by only one edge and
this thing will be off in space and
there are several construction construct
algorithm to go suck it in oven time now
what we are doing with this kind of with
this traffic see why we done it then
then as you see each red nose view of
the dollar sign is one of the suffix and
now let's seek for the pattern Anana and
click then the pattern Anna I go in here
XE ay ay ay ay and I come here and now
all the all the red nodes that are in
this subtree are the places that the
patent on ax a either then the time to
do it is off aim to get on the pass it
take me off em time plus oak to get all
the leaf in this subtree it's take a of
okhta a time because to traverse a
a sub tree which each node F at least a
two-child its take all of the number of
the lift the number of inside node is
bounded by the number of leaf okay now I
describe what is period and up and up
reverb then period sequence is a
sequence that repeated itself at least a
at least a three time you know I I wrote
more than twice for example a be a be a
be it's a bit a three times its evolved
rapidly time I period a string it's a
stream that can match but it can't
overlap more than a a more than twice
then this is an example of Appeals in
think now i will talk about how to do
all these things on a period button then
appear pattern click we we went 0 on the
past like in suffolk sling and get ear
and now we get you all the lives here in
off lives a time I think but we know
that the number of comments is a at
least as of the number of the live
because it might be the case that sells
several overlapping but there are no
more than twice the number of the lift
can't be more than twice the number of a
concert without seeking because pattern
can't overlap itself a lot of time then
we can actually report all the leaves
and now we need to somehow managed to
see which live to saw this all away
click to see which lifts away we
actually need to sort these things and
to see which intersects with which but
there is a problem to solve this thing
it will take
occurrence time logo for comments and we
want it to take only over comments then
what you can do then the solution is
renaming we start by a by just giving
each node is the location in the text
it's take log and bit now in this
subtree of the size it doesn't need to
be the subtree exactly of a of the
searching as before a but this is
substrate is is a smaller sub tree of
sight square root of n a size a modern
squad of n i put i put another another
day or during which which will cost me a
the thing is i have scott of any element
in this subtree then to order these
sleeves i will use only log of that and
it's alf log n bit and i will do it in a
caution you to squat of a the fourth
root of n and then i will get for each
live i get a name of logan bit the order
in the string I'll flow and bit the
order in the area of square root of n of
it one verse o log n bit the area in the
of of the forefoot of N and so and so on
all of this is to n log n bit and in if
we count all this off in space okay now
now we have here we get let assume that
we get some somewhere here then we get
here to a subtree that f of 0 comments
leaves and if I will go backward and
we'll see the renaming for Dan subtree I
will get a domain of size of a Cohen's
to the power of talk now to sort thing
in a domain is the salt n variable in
domain of n to the power of 2 we can do
in buckets or something like this and
it will be in linear time then we RP we
can do it in all four Cohen Stein okay
now how we deal with sporadic string
this is more complicated but it's more
it's nicer then the first fact is if if
we will a period world this is no
disappeared network now this period
world it can be the case that one of the
tool son of it I'll period only one of
the sons of the period world is period
this a ba ba be bee what we period but a
ba ba ba will be period it might be the
case that it doesn't have any son who is
period it might be the case it would be
a son of beers and of coz alpha D and so
on and not a son of a ok then I actually
prove to you by the fact one that that's
a period pass that we have you a pure
passer they are known as the they are
not connected a now I will prove to you
that the period pass I'll really fell
apart while they are far apart this is
the main trick of this algorithm then
let's start with this a ba ba be this is
period this let's say that this world is
here now I want to go to ear this is the
next period pass then to go to go to you
then start by going here it will be seen
a be a be three but now in order to get
to pure pass I need to do a ba ba bc and
now again this thing and a starting of
this to get at least three times lately
then it means that if this is was size m
this is 2m plus three then it means that
we double the size of the pattern but by
w side by doubling the size of
you can see that the if I go in from a
pass from the root to a leaf it can't be
that there are more than log in a period
passes because each pass that I get in
here let's say that it was a links to
then ill it must be at least fall and
here it must be at least eight and so
and so on it will be that if there are
mods and log na a passes it need to be
more than links in but we say that the
Texas length n then it can be that way
that thing this is actually the proof
that I just yeah now what we are doing
to a period pass this I call it a period
pass decomposition what we are doing we
will save a data structure for each such
pass will be like this a for example
this is the text i mark you the start of
let's say that this period past is a
period of a Bab then I mark or all these
places there are places that the pattern
can appear then for this for this string
I'm I mark it doesn't know I start by
marking this a ba ba which will be for
you because a ba ba want a match for
this pattern which would be a ba ba be
then for this node I have a pointer for
this record and from this record it
might be the case that I'm seeking only
a ba I can actually calculate all the
non overlap a places inside this or this
string now after after it I'm given a
pointer so this path set at this period
passed to be able to take all the
the places that that match from here
under this path because all the places
that may cheer are surely matching you
and then after it for this I light a DC
sequence I'll click and again this is a
I give a pointer to the next period
class right click and for this i can
write this sequence and now when I want
to query it say I just what are you
doing I I'm getting to the node that I
want to query I'm getting to this list
it's here i calculate it i calculate how
many time it's a puro or where it
superior and i can output it and now i
go into here and use this pass the
dispatch that are actual in order to
find all the locations that in this sub
tree and then going back and taking from
this the all the places that the better
up here okay then although all its take
off in space because each each leave
actually copied it only 21 a period pass
and click and overall we can see that
this algorithm walk in off in space of m
plus 0 Cowen's time for query now we are
going to deal with range query which
will be more difficult okay then let it
out with the field pass decomposition
what i will do you either click as
before i'm mark your s1e1 s 2 e 2 and so
on but now i will put a number which
this number is the difference between a
one and s 1 there is nine letter use and
use our seven and use our five in order
to be able to see
really fast if a pattern if i'm looking
for a ba ba be which is six I know
really fast that this thing doesn't
contain my pattern then if I for each
say for each period pass if I save a
this data structure you can see that now
it will cost us n log n time because
each leaf is copy now for each period
pass who is containing before before
that we we add you a pointer that we use
this this period passes well now for
each period pass I f is on data
structure which will be this array then
it's the spaces of n log n now what we
are we will do with that the this is
sorted here by the index by s 1 is less
than s2 and actually you can see easily
that a 1 is less than s2 as well and
what we will do we will just a when we
get to this node we will just seek for
IJ which we want to find all the
currents in the text that non overlap
between I to J and now what will this
disk and is done by of log log n time oh
I click off lagdi time if we ever if we
are around I it will take log of the
distance between i and where we are and
now what we want we want to find for
example ill we say that this is a be a
be a be which the length is 6 then we
don't want to say this thing because
this thing is less than six but we don't
want to go over all the places and see
that there are lot of places that they
are that they are lesson a lesson 6 we
want some how to get all the
big players before then what we are
doing we are doing what we call rangemax
the data structures that report it
called a landmarks it reports the
maximum given I and J in oven in of one
time and this will report us or this
nine for example and we know that our
pattern nine is less is more than six
and we know that our power occur you and
we can calculate where it occur and now
we will learn it again or rangemax on
this on disable a and disable a and we
report and so we report and we will stop
only when we get something that less
then in our example stick less than our
pattern length then in in of one per
occurrence we will get on your coins
then overall it's take a for period a
pattern will take off n plus dog log n
plus 0 comments but actually we can we
will a show up this log log n a in the
next few slides now what we will do for
appeared then the basic thing what we
can do for a period string we can save
so each node you we can save a sorted
list of all the occurrence of this
pattern in the text but these things can
can cost
you can click this thing you can cause
off n to the power of 2 space we want it
to be less then what we will do we will
save only ok we will save only several
places ugly I think another clicker nah
Tek a we will save these red nodes which
the rule of the net red nodes it's a
node with size this node this is the
root of the tree this ebb n element Adam
if you eat this node for example this
will have n over six this ain over 6 and
this to anniversary then we will save
only nodes that less than half of a
father less than less or equal to out of
the father then for example this node we
didn't save and this node is well we
didn't save rightly then you can easily
see that each red node each node can
have only one blue note blue not its
blues is a note that we didn't save and
you can easily see that each a little
click a each each as I said each red
node will keep away of the list of its
leave sorted and you can easily see by
that that we have we distinct will cost
only off n log n space because each node
will appeal only on only on I only on
log n at most log n we F F path from the
root to a leaf contain only low at most
log n red node because it always adds
the size now we add for this you this
blue thing is the list of the node that
are underneath this a underneath
this node in a list of leafs attorneys
of this node sorted but now we add you
this three and two we had you for each
leaf here we add when it live this blue
node for example this five you see that
it's live after one two three nodes then
the five-year FC and this leaves seven
it's live after 12 no then I right here
too I for each for each level that is
all for this red node I will I will even
humble as well for where the the Leave
leave this pass then as i said before
each leaf copy log n time then it's off
n log n space now click now what we are
doing with that we have this data
structure and now we query you it might
be the case that yields a fall and so on
but we query you and you see this is 1
this is 2 and this is 3 now malchik we
have this red node with the father of
this node but we don't want to report a
places that are went this way we want to
put the places that only beneath these
three then it's again we want to report
only things that you more than sleep
then again we can do for range query we
get we can find I and J in log log n
time i'll click or log D and we do again
rangemax nothing and we will get all the
places that a via something that are
more than three okay then it's off one
purl occurrence again and all of that
and a click it's off n plus WN + 0
comments and again we can reduce this
log log n
and a click ok now i will reduce this
log log log log log n i know that is a
tiny portion then first of all if m is
greater than log log n we don't need to
do nothing then we talk about some in a
place that m is less than log log n then
for EM less than double again what we
will be is a persistent suffolk say what
is the process is perfectly then first
we will we will be the suffix tree this
is suffix tree of the text now we will
go over the text and I click form the
end to the start actually it can be the
opposite I just choose this way and now
for each place i will i will copy then
the path of the affair of this suffix i
will i will have another copy of these
topics now this copy of the suffix click
i will cut it after log log n step
because i said that if the pattern is
more than Logan step it more than size
of log log n we we actually know what to
do it's say we're willing to spare this
logo game but if it's less than log log
n we want to do something then this 3 I
know that this path is off log log n
actually you need for the four copy a
node you need to copy the pointer for
this for these nodes then to copy a
pointer for this node it cost ok will
cause n Sigma log log n space because
each node will Sigma pointers and
actually click for binary alphabet it
can be done in off n space I don't get
into details but it can be reduced this
log of n but now i want to show you how
to reduce this Sigma because I disini
that I want to have a pointer only saw
things that were before not things that
were after and really
then what we can do what we will do we
will we want to save the pointer for the
a we won't save the pointer outside of
the discuss we will save it only once in
Sigma letters that this will give us the
earth and space but now in order to find
if I going now on this path I'm going I
want to start from here this is I and I
will go in that this person I want to go
here I don't have this point at what I
will do I will go Sigma copy box and in
this in the Sigma copy back I will air
at what Sigma copy back i will add a
structure of why firstly or some other
faster data structure for so for
financing and i will ask which is the
predecessor of the I position for the
letter A or something like this to go to
ear and this will cut off log log Sigma
then it will take off n log log n space
and we take so each edge going like this
it could take the global Sigma then take
M log Sigma plus 0 comments software
time and pick now I want to reduce it
then I reduce it by renaming on each log
Sigma letter to be one letter and now it
will cost me m'lord Sigma over log log
Sigma then it will be of m and actually
to do that I need to have a log log
Sigma tree then it would be this amount
of a lot of long no its log log n time
log log Sigma but actually it can be
reduced as well mother click no its
local in time log Sigma ya then actually
it or it can be done in off NW n space
and query actually we still have a
problem when the pattern is less than
log log Sigma then it will be empty
slow log Sigma plus 0 comments then for
family we know to do new develop in
unison in off in space of m plus
occurrence query time this click
involved only a renaming for sorting Z a
pre-order the UH p of the pattern we we
want to sort fast appeared and
the in the period past decomposition and
for the engine on overlocking indexing
we head off n log n space n plus log
Sigma plus occurrence a query time this
involved a to trick the first take was
with the alleged maximum the second take
was with the a persistent suffix tree
and the renaming and actually this
didn't involves the renaming insane but
if Sigma is small then we actually if
Sigma is a binary it will be without
this at all it will be plus n then we
can do it in off n plus 0 points okay
then when is Amy smaller than you again
when you are seeking like in the DNA and
we want to seek a tiny tiny thing like
like one how many time one you know for
new cleat other decoding things and how
many this portion you have when when n
is really big and m is really small no
nobody no log n when it's bigger than
him when it's bigger than M yeah M is
the size of the pattern and in the size
of the tech in most of the cases this is
not the case for sure okay
okay yeah yeah do you know approx with
the size of the constants out in front
oh I can say that they are big because
it's a way to reduce I use in here range
maximal and sing like this the way to
reduce the constants of flange maximum
actually actually is are not so big as
all the thing you are against the worst
case in average case it can be really
small it can be a I don't know about for
this the small enough she practically
useful I think that in normal case you
will index all the places and you will
sort them and then you get off there the
places that there you will do things
there that will take more time but will
be a with less bugs
ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>