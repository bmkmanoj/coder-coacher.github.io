<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2016: Directed Test Generation to Detect Loop Inefficiencies | Coder Coacher - Coaching Coders</title><meta content="GTAC 2016: Directed Test Generation to Detect Loop Inefficiencies - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2016: Directed Test Generation to Detect Loop Inefficiencies</b></h2><h5 class="post__date">2016-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9-w_Y1oLcm0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right next up we have a couple
lightning talks starting with mo nica
okay hello on I'm Monica doke I'm a PhD
student in Indian Institute of Science
Bangalore and I am here to present one
of my recent work on detecting loop
inefficiencies automatically this is a
joint work with my advisor Moodle
Krishna ramanathan moving on so software
efficiency is very important one cannot
afford to lose customers because of
performance issues in the program so but
the problem is performance issues are
very hard to detect during testing and
therefore the escape testing and gets
into production now obviously this is
going to degrade application
responsiveness and affect the user
experience so such kind of performance
issues are termed as performance bugs in
recent literature and we will see how do
you deal with such performance issues so
performance bugs are nothing but the
implementation mistake that will not
necessarily break your functionality but
it is going to affect the performance
and their book therefore will affect the
efficiency of the program now the
problem is this performance buffs are
very difficult to catch during compiler
optimizations as well because compiler
optimizations are generally in place and
do not look at the program overall so
this performance bugs are really very
crucial and we need to fix them the
fixing them is going to give us large
speed ups and will improve the program
efficiency as well so let us start
looking at this performance issues there
are various kinds of performance issues
in the program's especially in Java
programs there are memory issues there
are issues with garbage collections and
there can be cash issues with text test
or the caching techniques as well so in
this talk of a focus is on a certain
specific kind of performance bursts
which are also termed as redundant
traversal bugs so let us try to
understand what this bugs are
for moving on so redundant reversal bugs
i define that so these exist when
program I traits over a certain data
structure again and again when actually
it is being it is not being modified in
the program so to have a better
understanding let's have a let's have a
look at simple example so this is a code
there is a class a it has a method
called contents in this method is taking
to type to collections c1 and c2 as
input and the method is aight rating
over collections even at line two and
three and four every element that is
traversed from collection see when we
are going to check if it is present in
collection c2 at line number four so
basically checks if the element is
present in situ if it is present it's
just going to return true if it is not
present it is going to return false this
is just some pseudocode that we are
going to look at now the problem here is
that if the contains operation at line
number four is linear the overall
complexity of the contents any method is
going to be quadratic so the reason
being there is outer loop which is I
trading on c1 and for every element you
are going to write it on c2 now how do
you prevent this the problem is if type
of c2 is an array list then this
contains operation at line number 4 will
be linear now we have to prevent this
redundant reversal from happening in
this program so ideally the complexity
of this program is a quadratic in the
size of c1 and c2 now the way to improve
this complexity would be to get rid of
linear operation happening at line
number four so what one can do is the
collection c2 can be restricted to a
type where the contains operation is not
linear rather it is constant time and
thereby we can get an efficiency
improved efficiency thereby improving
the complexity so basically the ideal
way to fix this program will be to
typecast connection see to do something
like hash set which has constant time
contains operation and then the the
complexity of the program is much better
than quadratic so now let's have a look
at what happens so this is a very basic
model
of testing technique developed by
develops a program the program is
shipped to a test engineer now it's test
engineers responsibility to write tests
to check various functionalities in the
program and then these steps are
generated and given to the bug detector
now bug detector is going to look at the
program execution and check if there are
any issues like assertion violations and
then those are again pass back to the
developer developer takes care of those
issues go use the modified version of
the code to the test engineer and then
the cycle goes on now the problem here
is that in case of functionality works
bug detection is kind of better kind of
easier so what I'm trying to say here is
that if you have assertions in your
program and if you have tests return
then you can just come whenever you come
across a session violation that
essentially means that your program is
not behaving as expected and therefore
you have come across some issue which is
which developer is supposed to take care
of now how do you detect bugs in
performance in the case of performance
issues you don't you know that the pub
the performance issue is present unless
you can give me a better version of the
code which is running faster pretty
straightforward right but how do you do
it so recently in the arc in the
literature there is a work called as
toddler which is proposed in 2013 that
basically takes a set of tests as input
analyzes its execution and while it is
executing it will try to figure out if
there is a repetitive execution
happening in the program as we saw in
the earlier example so this toddler it
is going to take a set of tests and
going to report if there are redundant
reversal bucks in the program now if you
notice carefully this toddler is going
to analyze the execution therefore its
tendency to detect repetative execution
is completely based on the input set of
tests the set of tests should actually
expose the program location and also it
should perform repetitive iteration at
that particular program location if that
doesn't happen toddler is not going to
detect any bugs in the program so
basically the responsibility to write
meaning
full test is on the test engineer who is
supposed to analyze the program
understand the semantics and then ensure
that the input test exposes such issues
or rather we need a technique that will
automatically give you a set of tests
which will expose such issues
highlighting the repetitive operations
so so let us see what is the alternative
option so whatever we talked about so
far was dynamic analysis where we
analyze the execution and we are
completely relied on the test input but
now there are static analysis technique
which will just take a Java class as an
input go over the code and try to figure
out what possible performance issues can
be present there are such techniques but
they have multiple challenges now let us
go over the challenges one by one the
first challenges given a bug how do you
confirm the validity of the bug in case
of functionality testing you have a
assertion failure in the program which
clearly gives your proof that something
is wrong with your program but in case
of a performance bug how do you what
what is the proof of its presence right
now the second problem is how do you
expose the root cause now given a bug
given a program location when you are
saying that there is a performance issue
at this particular location how do you
fix it what is the root cause of the of
the bug and why is it happening after
all now if you notice carefully
execution trace will be really helpful
here for the developer to pinpoint what
is the problem and thereby to fix it now
the third probe the third challenge is
how do you detect that the performance
bug is fixed now in case of
functionality testing developer fixes
the program and then when he runs the
test failing test once again the
assertion doesn't fail and that
basically means that the program is
fixed to take care of that bug but now
when it is a performance issue how do
you know if it is fixed or not so rather
if you have an execution trace you can
run it on the original version of the
program P which is going to take X
minutes now you are going to run the
same execution or same input on the
modified version of the program which
should take time much less than X
minutes and that is what going to give
you
prove that the performance bug is
actually fixed now this again motivates
the problem of having a technique that
will give you a set of tests to expose
certain kind of performance issues now
let us have a look at what are the
possible ways to fix the existing
techniques now you have toddler which is
going to take a test or set of tests and
analyze its execution but can you fix it
without having a technique that will
generate directed set of tests so there
are multiple techniques like he was
sweet brand new jpf CLE that you might
have heard of these techniques analyze
program and they try to generate test
which are few high coverage so these are
basically based so dry loop is basically
a random test generator that is going to
look at the various aspects of the
program and going to give me a set of
tests now you can ask me why do you need
a technique that is going to
specifically generate test focusing on
performance issues you can rather use
these techniques which is giving me test
anyway but the question is the question
once again is that we need very specific
techniques for toddler to the effective
we need them to expose performance
issues in the program and ensure that
the execution repeat repeat certain kind
of operation so now given the stage that
we need some technique that is going to
generate performance tests for us
automatically let us have a look at
challenges involved in writing such
performance tests so to start with so
first challenge is virtual call
resolution as all of us know real well
Chavez Java libraries use lot of
inheritance and there are a Trank time
there are multiple possibilities for a
virtual call resolution so what I am
trying to say here is that generating
test for all the possible resolutions of
a method call is practically not
possible I am just going to give out a
test for every possible call resolution
and that is not what I want to do my
purpose here is to generate test
specifically for certain kind of issues
without giving a huge set of such tests
so basically I am going to look at a
particular call resolution only when I
see that there is a problem with the
code
the second challenge is that generating
appropriate context so even though a
particular program location has a
performance issue we need to execute it
our execution needs to be reachable
there and there might be multiple
conditions that can affect the execution
of that the program location with the
issue so basically we are realizing the
defect can be dependent on certain
conditions that affect the reach ability
of the inefficient loop so we need to
take care of such conditions the third
one is okay so third one is arrangement
of elements now the problem so we
figured out that there might be some
collections that are being traversed
again and again in the program so you
might say why not just make sure that
this input collections are huge and
execute such methods but that is not
going to be good enough because it's not
just about populating the input
collection with large number of elements
but what elements you are inserting into
the collection that also matters so so
we proposed approach called as glider
this is a this is a scalable approach
which will take a set of Java's java
classes as input and it is going to give
me a set of tests in the output so it is
basically to generate s4 exposing loop
inefficiencies this is the underlying
architecture for our approach it
basically takes Java library as an input
uses some random test generators that we
discussed before like JP of clear and 0
and it is going to give me random tests
now I will analyze this random tests to
figure out what are the program
locations which might be having
inefficient loops now with the help of
this random place and Java libraries I
am going to generate method summaries
which is the second phase of the
approach and this is going to flag every
method with the potential information of
loops what are the methods being invoked
and what are the parameters being passed
to these methods now in the third phase
once with the method summaries I'm going
to flag certain methods as inefficient
methods which will possibly have a
potential inefficient loop and some
other methods like popular term methods
which can be used in synthesizing at
that is going to expose this loop and
efficiency so with the help of all this
information that is derived in the last
phase that is test generation we output
a certain bunch of tests that is going
to highlight the performance issues in
the program so so glad this is a I'm not
going to get into the discussion the
discussion of the design in detail
because of time constraint but our tool
is available online you can download it
and run run it with your Java classes
it's very simple to use all you have to
give it is a set of Java classes and it
is going to give you the setup bunch of
s exposing performance issues in your
Java classes okay so so I just wanted to
show you one of the performance bug that
we caught so this is a Jeffrey Jeffrey
chat library that basically displays
quality charts in your applications many
applications use this library and when
we gave this library as an input to
glider it detected a bug for us which
was basically the redundant traversal
bug we reported this bug to the
developers they acknowledge the presence
of the bug and has incorporated the
changes that we have suggested this was
really important because if your
application is using this library the
application is going to incur a huge
slow down so after the performance fixes
that we suggested there was a 314 x
speed up for this program ok so overall
just wanted to highlight the reasons so
we have implemented our approach on suit
bytecode framework which is basically a
program analysis tool our approval and
we evaluated our implementation on 7
real voice Java libraries and we
detected 4046 bucks and out of which sub
34 bucks were previously unknown we have
reported some of this bus to the Java
developers and they have most of the
bugs have been acknowledged by Java
developers lastly this test we figured
out that this test generated using
glider significantly outperformed the
randomly generated test that's all I am
due to take any questions thank you
excellent thanks Monica I can't wait to
run this on some of the Java classes
I've seen we yes we had one that you've
already answered I think we only have
time for one question since we're
lightning talks but my TRO micro
benchmarks are notoriously difficult to
get right EG judah jit how does toddler
and sure it measures real-world
performance so right now we are just
looking at the simple we are looking at
a java classes we have not considered a
jit kind of stuff but yeah i think i'm
ready to take it offline and discuss
more on it ok well thank you ok very
good to excellent talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>