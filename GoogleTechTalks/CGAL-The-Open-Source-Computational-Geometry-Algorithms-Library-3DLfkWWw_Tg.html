<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CGAL: The Open Source Computational Geometry Algorithms Library | Coder Coacher - Coaching Coders</title><meta content="CGAL: The Open Source Computational Geometry Algorithms Library - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CGAL: The Open Source Computational Geometry Algorithms Library</b></h2><h5 class="post__date">2008-03-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3DLfkWWw_Tg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you Lawrence and this is a
great opportunity for us we are very
happy to be able to to give this talk at
Google so the the talk will be organized
by different parts which we will
alternately present so I will first give
you another view of how the project
works and then undress will give you
some corridor tour of what is in CR and
then I will go into more technical
details concerning the generic
programming aspects as well as the exact
geometric computing that we use overall
in cigar and unrest will finally
conclude so the Siegel project is now 12
years old it was originally originally
guided by this mission statement which
is to make a large body of geometric
algorithms developed in the field the
research field of computational geometry
available for industrial applications
what it is now is a an open-source
project there are a few institutional
members which make long-term commitments
and which are supported by sequent
subsequent European research project
these are in ariya in France the Max
Planck Institute in Germany Tel Aviv
University uterus University and a few
others in particular geometry Factory
which is a spin-off company of our
project which started in 2003 and which
was funded by unrest I would say that
like for any open-source project we have
some development infrastructures so an
SVN repository bug tractors etc and some
nightly distributed test suite to check
that our C++ code is portable on various
compilers and we also tried to make to
developer meetings a year in Europe
mostly
the typical workflow of the product of
the project is that we receive some new
contributions in the form of submission
of specifications and these are reviewed
by an editorial board of about 12% now
and this board decides and checked for
uniformity of the specifications with
the rest of the library now the value
for the contributors is that while they
get integrated into this larger seagull
community they gain visibility in this
material project and we also try to push
for model where accepted contributions
have a value equivalent to a publication
which is important for the research
domain now some commercial users which
have both parts of sigil for various
applications they come from lots of
different application domains so like
GIS VLSI medical imaging and this are
all in needs of geometric computing so
we provide fundamental geometric
building blocks let's say now let me
give some numbers to summarize this the
project as of the current public release
three point three so this is a pretty
large C++ project now so about six
hundred thousand lines of code it gets
downloaded ten thousand times a year
plus it is also part of some major Linux
distributions the manual is also pretty
extensive so three thousand and five
hundred pages and there are also a few
thousands of subscribers to the the
announcement and discussion mailing
lists which are directive the library
itself is not really monolithic it's
more collection of classes of functions
for individual data structures which
Andris will detail later and we count
them as roughly 100 there are now 60
commercial customers of Siegen
and currently about 20 active developers
part-time so and we try to issue when we
use a year more or less that is what we
are heading for and as far as licenses
concern so sigil is open-source there is
an open-source license which is split
between the LGPL and the qpl depending
on the parts and additionally to that
there are some commercial licenses which
are available through a geometry
factoring okay so I will know that one
dress gives you a to our CG on from the
manual pages squeezing that in twenty
minutes will kind of be difficult so
what I will do instead is I give you a
Taurus Eagle picking out of some of the
data structures we have and giving a
kind of highlight of what's special
about this particular data structure so
in the Siegel manual they are kinda they
are kind of chapters so we regrouped all
these packages we have in say
triangulations boolean operation six
like that
okay when we say a package is over when
we say your software components of
building box itself it's C++ classes
with very rich API so right I mean the
manual pages are about the API okay
don't be afraid about 3,500 manual pages
there are 100 packages so in average
it's a 30 manual pages per package so
it's not a huge thing that you have to
study first in order to get started okay
so these data structures what they based
on what they were the kind of foundation
what they run run on is in The Seagull
kernel and we will speak about that next
so the kernel it kind of wraps up the
elementary types like points segments
are so elementary geometric entities
okay then next and you have predicates
and so predicates are things like a an
orientation test so as a Mauser so we
have three points P Q R they perform a
left turn when you are from P to Q to R
it's a left on those 3 are collinear
okay or things like an incircle
predicate so you have three points
you are you have which define a triangle
which defines the circumcircle and you
want to know four point s does it lie
inside the circumcircle of the triangle
does it like outside or is it Co
circular is it on the is it on the
circle okay then the third category of
things you find in the kernel its
constructions constructions means that
you take you take several geometric
object and you compute new entities like
an intersection point or given three
points you compute the center of the
circumcircle okay these are predicate
constructions called random those things
are they're a little bit tricky to deal
with with floating-point arithmetic and
so then later we'll speak about how to
how to get that stuff stuff down so now
let's let's start with this guided tour
through Siegel so there's one big
chapters triangulations so triangulation
so you have these people you have the s
input these blue points there are points
in the plane and you hook them up with
triangles so that's the the that it's
all covered with triangles
okay that you have the decomposition in
triangles anthem so there are many
possible triangles and one which is
which is interesting it's the dual only
triangulation which has the property
data for all triangles for all triangles
of the triangulation if you draw the
circum circle around and what we just
defined before there is no other of
these blue points which lies inside the
circle so which makes the triangles kind
of nicely shaped on so they are not
elongated because let's have a look if
you if you flipped this edge so we
replace this one by that one this one is
not the lonely because if you take this
triangle you draw on the circumcircle
this this point this vertex of the
triangulation lies lies inside it okay
that's not that's not a lonely okay
the data structures we provide they are
they are fully dynamic that means you
can insert remove a vertices oh and the
data structure gets updated on the fly
so they are decently fast there are can
kinetic versions which means that the
points they can fly along trajectories
and at discrete time steps the data
structure gets
data okay then there are versions of
triangulations which can incorporate
constraints so say a brake line sir in
brake lines in maps or road networks or
things like that and the 2d
triangulations they can use for terrain
so terrains are not really 3d date they
are two and a half D so they're in the
plane and it's at each XY coordinate you
have elevation okay which which defines
right the terrain okay let's have a look
at some some application of one of our
users who provided us screenshots what
they do is on a train modeling and they
do watershed analysis so what you see
here is the mouth as a it's a hill in a
mind you know enter you see the ramp so
where the lorries go up or to to deposit
material okay and so what they have as
input is very regular a very regular
grid plus elevation so yeah digital
elevation model plus constraints so
these are the kind of the road networks
on this on this hill and what they do
with them they use our dallona
triangulation to to kind of re measure
this quad mesh to a triangular measure
which has which has less faces okay
because of the watershed analysis needs
a spouse as possible model which is
still good enough to represent her the
real terrain I mentioned constraints so
when you have a triangulation like this
one which is rather regular and if you
insert constraints now in red so these
constraints have to be respect that you
cannot have triangles that that that
cross or constraint so in red you have
to constraint when the constraints are
rather large compared to the average
triangle the average edge of the
triangulation you end up with nasty
triangles so if you run simulations so
so these are not these flattish
triangles are not very good so therefore
for numr well for numerical reasons okay
so what what one user of us what of the
secret software what he did he used our
conforming algorithm so which which has
the freedom to add additional
on the constraint to make the triangles
looking nice okay but still if you look
here for example you have you still have
elongated triangles so what you also
have in sigil is deal only meshes now
the additional degree of freedom is ER
the algorithm is allowed to to add more
points so not only on the constraints
but also inside the triangles okay enter
now
now all the triangles have this deal
only property so which which makes the
triangles nicely shaped okay now let's
zoom you can end up with many points
because it can be necessary to to add
many points to enforce this tool only
property so just assume shows because
the constraint was was very close to one
of these grid points you end up with
many small triangles but I mean it's
unavoidable that so it's kind of
intrinsic to to that okay another
example so of of a measure so doing odd
on North America in the chapter
triangulations we have the same thing in
3d in 3d
well again it's fully dynamic it's it's
very fast and enter in 3d you don't hook
up triangles but you hook up a
tetrahedron okay the the tetrahedron
that they what they do they decompose
space okay you you have a space with
cetra Hydra that that are connected so
you have neighboring tetrahedra and
neighboring tetrahedra they somehow
sandwich in between triangles okay and
so that's very nice the thing is what
what met what some several uses of 3d
triangulations do they want to model
surfaces embedded in space okay then
what they want to do is they want to
construct surfaces that are not self
intersecting because well that does not
really exist self intersecting surfaces
at least when we speak about something
that is material okay that that you want
to avoid so the fact that the triangles
are sandwiched between tetrahedra makes
that when for the surface you construct
you take those two a subset of those
triangles but by construction they
cannot intersect ER so they have a nice
at least you have a nice soft surface ER
with with with this respecter okay
let's see at some examples
in Seagal you find them something that
computes surface meshes here you see a
part of Cologne : input medical data
so just voxels or 3d images output the D
mesh for an ISO value in the image okay
and this thing competes with marching
hoops only that it's nicer because it's
not that you you you you generate many
many triangles and then you run
simplification algorithms where you have
almost no chance to get them
topologically topological erected so
this one kind of starts with a small
mesh and refines where it's necessary to
refine it okay so it's a that's very
nice property and well it's important
for getting this a topological
correctness center in an example from
one of our commercial users also while
State University what they do they don't
have as they also want to produce a
surface mesh as input they don't have
voxel data but they have a surface mesh
they have for this very yeah I mean if
you it's a very dense it's a very dense
surface mesh okay enter here you see
kind of the superposition offer the
three did the 3d triangulation of the
space of so in gray you see all these
edges of the tetrahedra ization and
these lie like facets these violet
facets they are they are just embedded
they are they are just sandwiched
between between tetrahedra enter now
they use this decomposition of space
also to navigate around because the
composition allows you just to to to to
to explore neighborhoods or things like
that
okay enter so they produce so things
like that so it's a rematching algorithm
innocence in the chapter Voronoi
diagrams so Voronoi diagrams are data
structures for for encoding distances
and for for for encoding proximity okay
what you have here in the in red is the
input it's a utility say a u.s. post
office okay and now you it decomposes
the plane in a kind of cells and so all
those people who live in this cell
should go to that that's the closest
post office for them okay everybody
living in this cell that's the closest
post office okay that's that's what
Voronoi for no diagrams about we have
four points well we have it in 2d and 3d
I mean on the on slide - you have a new
today we have it we have it for circles
four circles the kind of the the the
arcs which which Express equidistance
between two objects okay they become
arcs of hyperbolas not straight segments
so and we have it for four segments so
when the inputs you have points or or
segments on it again in blue it's a the
I mean in in blue you see the boundaries
the the edges of the runner diagram and
so what a Voronoi edge is it's the the
separate the boundary of two of two
neighboring of two neighboring areas so
when you are here so you're equally far
away from this guy and from from this
line okay that's and yeah remember basic
math so parabola is defined by by a
point and by by by this by this
supporting line okay and the thing in
siga what's nice about it is that this
parabola it's um it's thought in a
symbolic way so we do not discretize
things and say okay well it's a parabola
but let's let's polygon eyes it lets on
the screen is polygons eyes because okay
ultimately it's a that's but in memory
and the data structure itself it's a
it's an exact parabola okay and it's
compact because it's just described by a
defining line plus a plus this one point
or a plus a start and an end pointer so
it's a it's a it's a compact
representation which is important if you
want to treat big models and then then
it must be compact you cannot describe
the the Voronoi diagrams for segments
they are also interesting because when
you when you have segments that form up
a polygon then the Voronoi diagram is a
medial axis okay which is a well-known
structure of morphology image and
morphology things like that okay so the
medial axis well it has it has this
parabola arcs and for many people they
don't like parabola arcs so much because
well when you run see when you try to
control CNC machines or so then well
parabola access somehow they are not
built into
how you can move move tools so what what
many people I mean we're several users
which use an alternative to medial axis
it's called straight skeleton so it's
also a skeleton of an input object okay
but the other thing is that here are no
parabola axial so which yeah which makes
it which makes it interesting as I said
before for CNC for milling machines
printing machines okay and people use it
for computing offsets and they need
offsets because they want to move a
machine around to to mill okay to to
produce something which has this given
this different shape in the chapter
bounding volume so the fundamental
course on computer geometry starts with
convex hull what's a convex hull you are
given an object and you want to know
what's the smallest polyhedron
containing it which is something
important because when you when you want
to say you you have collision detection
so before figuring out do I hit this
bunny in the game with my with my hands
if you better first test do I hit the
bounding box of the bunny or do I hit
the convex hull of the bunny because
that's computationally much cheaper okay
and so then we have things like the
bounding sphere it's a smallest sphere
containing a point set or we have things
like a bounding sphere of spheres you
have a collection of input sphere center
okay and you want to know what's the
smallest sphere so there yeah in the
chapter boolean operation so we have we
have an eighth Pole etre they are also
it's a professor in Switzerland called
some professor nayfeh so it's it's a
it's a very sound mathematical
definition of how how objects how
objects should be should be represented
it's sounds which makes that it's closed
on the boolean operations which has
implication that you can have you can
have an object within a 1d antenna
sticking out things that that usually
modeling tools are kind of regular eyes
away they just throw it away because if
you want to manufacture
so well something which is
one-dimensional it makes no sense right
you cannot you can open factor it but
there are applications where you want to
you want to maintain a one dimensional
features or two or to the L or two
dimensional features so we don't enforce
this this regular read a curation and
well boolean operations is you have that
object and you want to subtract this
object and you obtain that object okay
that's that's what will your operations
about so I should have shown that before
I progress the thing is because we use
the exact computing paradigm so when we
speak later bout deter these operations
so that they are kind of you can give
whatever Ness the input it will it will
not crash and it will produce a result
okay that's all it's kind of well that's
what it's supposed to let's switch to
another thing our boolean operations
what we see here is a printed circuit
board ok enter but given given as a
given as CAD file let's so let's let's
zoom in on enter what we see is that
what looked like a little black daughter
is in reality I mean that was a little
black dot we saw in the the contact that
we saw in the very beginning so when you
zoom in then you see that the little
black dot consists of lots of little
cigars which are again tooling parser so
it's a sense it's a tool moving around
like that stopping here and the tool has
a round cap and that's why whites round
at the end ok now this this printed
circuit board was kind of constructed by
moving this pen with which has a certain
weight around and covering the thing in
term what we offer is boolean operations
on polygons where where the the edges of
the polygon can be arbitrary curves
well it can be can be colleagues okay so
it can be a arcs of circles for example
and again the important thing is we
don't do it with discretization the
thing is that when you start
discretizing or the model you saw
initially or well you need to you need
not you need a lot of memory okay and so
you also you have no guarantee that that
I mean you have to pay attention that
you use sample you
you approximate the circular arc dense
enough for so that you guarantee that
the output is is corrected
parameterization parameterization is
about flattening cows it's a if you want
to put it in front of your chimney or if
you want to put texture mapping on an
object now here what we did is we you
there's the there's a cup there's a cut
line cut line under the cow enter so
flattened it looks like that here are
the eyes because the things when you
flatten something out there's there is
distortion okay you cannot I mean take a
half of an orange so you cannot if you
press it down it just yeah just it
doesn't stay here that doesn't keep as
this so the same here so if you if you
flatten objects are you
you have to distort so color coded you
see how big this distortion is so it's
very it was very big cutter at the icer
okay so now in Siegel you find her the
major we find implementations for the
major methods of surface
parameterization then mesh
simplification you have an input mesh on
your on the left and if you only want to
to put texture on it
then this is an overkill you don't need
that fine triangles so simplification
algorithms what they do is they can't
they they construct a new surface
measure which has far less triangles but
which maintains the the essential
features okay I mean you see that this
I'd say this this V color of it kind of
you you you find it again or the nose
remains you know so the wing you have
elongated edges at the at this at this
card at this part of the wing so here
maybe two two highlights as well now the
highlight here is that the way it was
implemented so we were inspired when we
did it we were inspired by the boost
graph library which which very nicely
separates algorithms running on graphs
are from data structures representing
graphs so we applied the same thing to
physical I mean if just if you know if
you know what
if you know a little bit about bgl then
this speaks to you otherwise that you
want in the section detection the things
when you simplify then you have a high
chance that you end up with triangles
that intersect so what you have and what
you have and see so let's so let's look
at this model let's zoom in color-coded
here you see an area which is which is
red so let's zoom in again you see that
what happens there that the
simplification algorithm somehow it
mists the surface up and so the surface
became self intersecting by by the
simplification so in Syria what you have
is an intersection detection algorithm
which is rather generic in the sense
that the user provides a provides the
bounding box for the object so you want
her to interested to to detect the
intersection of the user provides a
callback that the algorithm calls for
for any pair of objects entities like I
mean in this case two triangles who over
Yahoo overlapping and so it comes in two
flavors one for just the set of objects
and you get all pairwise intersections
or you have a flavor webcam so you have
you have two sets a and B and you get
you get all objects from one set and
from the other set which are kind of in
conflict enter the callback gets gets
applied and this is the single sir it's
tuned for spittin so it's so it's yeah
it's tuned for speed things we have
integral things like estimation of
curvatures so I mean here you see a well
on the model we saw before the maximum
curvature here you see it on the lip so
if you see if it goes it goes around the
lips and min curvature goes along the
lips on the same here on the wing so you
see it goes it goes around to this the
cylindrical part and this goes along the
cylinder the pocket part so what what
these kind of estimators are used for is
for rich detection when you when you
have a you have models so you have
scanned them with a scanning device you
have a polyhedral model of that and now
you want to figure out where is the rich
where's the sharp edge huh so as rich of
a table things like that
okay yeah the the last example natural
neighbor interpolation so some so what
you see here on the right is a it's
weather data it's a every red dot is a
city in Japan enter the L enter it's a
little bit higher if it's a little bit
warmer enter what weather news wanted
you to do is they wanted to interpolate
weather data on a regular grater so on
this on this white pointer and they used
natural neighbor interpolation from from
seagull for data so again here you have
your you have your points which define
temperatures and what you do if you want
to interpolate for this guy the
temperature at this point so you take in
account those who are who are neighbors
in the vernal diagram you first compute
the Voronoi diagram here in black of of
only the red guys and you see this guy
influences this zone so that that's city
influences this zone and so on and now
you kind of virtually are you simulator
inserting this this black this black
daughter this new well the point for
which you want to interpolate it claims
this it claims influencing this zone or
so it's Voronoi zone and now with the
fraction offer of the area yeah the
fraction of area contributed by by this
city kind of info welders and says how
how we have we waiter the temperature
here to computer the the temperature at
that point okay now to at least see some
code in the beginning I said it's a C++
class library so where's the C++ here we
go hello world and Siegel as in any
c-plus program you first includes some
header files I told you that our day I
mean you you include the Denali
triangulation so the data structures you
are interested in I told you that all
our data structures need kernels or some
providing points or orientation tests
and such so we also have to include a
kernel yeah we we make the longer name a
little bit shorter using a type
therefore so in the car the kernel
provides us a point type there's the
Delauney triangulation which is
parameterize by by you colonel
enter the Delauney triangulation it has
vertices faces so it needs the entities
to to refer to an T to two vertices and
faces now the main routine comes and we
allocated the lonely triangulation we
insert points coming from standard in so
this builds up the triangulation we saw
on this very first slide now for the
erection point 0 0 we determine the
nearest vertex the closest vertex to the
origin ok and we print that out I mean
it's a stupid example you wouldn't run n
log n algorithm for linear time problem
it's only to illustrator to think so one
thing is a templates all over the place
so C will speak about templates and then
this thing I said they are kernels so
enter then the kernels come in different
flavors for exact predicates in exact
constructions and well Silvan will shed
more light on that aspect
thank you ok so now let me show you
exactly how we use generic programming
in Siegen and what is specific to sigil
in generic programming so let me
highlight the differences in overall
general design between the STL and cigar
in the STL you have algorithms you have
some free-standing algorithms like STD
sort for example and so this is this
orange box here and these free-standing
algorithms are completely decoupled from
the underlying data structure sequence
on which they run the interface with
that through the iterator concept and so
the iterator is representing a sequence
which is usually stored in a container
for example and this container store
stores values the algorithm can query
some properties on the values like an
order
for example through some factors which
is also a concept this way you also have
another set of algorithms which are more
tightly coupled to the containers there
are less generic I refer here to for
example the sought member function of a
standard list or the insert function of
a standard set now with this picture in
mind the reference the differences that
we have in sigil is that the objects
that we that we manipulate are not only
sequences we have more complicated
graphs and the geometry is also the
geometry of points or curves in the
plane or space is more complicated than
just an ordering so the first main
change is that we have to query the
properties of the objects the points
through several functors predicates when
we have an algorithm usually one is not
enough so we have some bundles of front
rows typically which we gather in what
we called the geometric traits class
concept which is property of each
algorithm another difference as I
mentioned is that we do not only many
great sequences so for example a convex
all into these on your sequence but if
you think of it in 3d it's already more
complicated or triangulation in 2d is
also more complicated so for some
algorithms we have a graph interface
which we have tried to base on the boost
graph library concepts for graphs this
allows to run the boost graph library
algorithms on The Seagull data
structures and we also have some let's
say algorithms which are tightly coupled
to data structures like the insert
function of triangulations
for example another refinement which we
have just like in the BGA is that some
algorithms provide visitors that are
some code backs which are available to
users to be to be called at specific
events within the execution of each
algorithm so this is the overall picture
so we try to stick to something familiar
which is the STL and extended it to our
specific needs so now let me show you
some some code so this is what we have
in the STL so the class set which is
parameterized by the key type and the
comparison functor or less which provide
the the ordering so you you internally
store an object of this function type
here and you call it since it's a
function object on the the key types so
the one that you want to insert in the
in the set so in sigil we have something
very similar to that so as I said the
geometric trait class here is gathering
the point types and the values functors
specifying the predicates so in this
example here for the Dylan a
triangulation we use two functors the
orientation factor and the incircle test
which undress showed at the beginning
and when you insert a point in this
triangulation
you will need somewhere in the code
calls to this orientation functor and
interval test so this is very similar in
design to the STA let me now give more
details on this geometric traits last
parameter the idea of having this as a
template parameter is that you can
easily change it and you want to do that
because you would like to change the
point type let's say you want to use a
cigarette item within your application
which already has a point type for
example and you are now able to use
cigarette UM's on your point types
because of this flexibility you can also
exchange the
the predicates that run on these point
types so computing the orientation of
three points for example Siegel itself
provides several models for this
geometric trades class actually we call
them kernels they are some kind of
superset of the needs of geometric
traits classes of many algorithms in
Siegel so they are gathering basic
functionality on on point segments etc
and the models that we provide are
parameterised themselves by the
arithmetic that is you can change you
can use for example doubles as
coordinates or floats or inch or more
involve number types like multiplication
integers which I will describe later
there is here some kind of speed
precision trade-off and some
adaptability reasons to give you a
practical example of another thing that
it is useful for Andres described the
application of terrains which is made
using the Siegel 2d Dylan a
triangulation and this is simply
achieved by using some kind of implicit
projection trade class which takes three
points and applies to D predicates to
them so it's it's very easy to plug in a
specific trade class implementing this
within the 2d Dylan a triangulation ok
now let me give more detail on the exact
geometric computing paradigm that we use
in many places in signal to achieve your
business so there are some issues which
are especially important in geometric
computations if you naively use
floating-point arithmetic in geometric
algorithms then you may have some
unexpected consequences you may for
example produce some wrong output or
slightly wrong output let's say convex
hull is not really convex that may or
may not be a problem for your
application worse you could have a crush
because your algorithm or data structure
is going to encounter
an invariant variation or even worse you
could also have an infinite loop in the
algorithm due to this this this can
happen very easily and the thing is that
fundamentally there is a gap between the
geometry which is used in theory which
is the one that you use to build your
algorithm in the in the literature and
the geometry which is actually provided
when you use for the in point arithmetic
so let me give more insight on this
typically algorithms are proved at least
a contest is proved based on some basic
theorems of geometry here I have an
example if you take 4 points in the
plane P Q R and s and you have the I
pathogens that the three small triangles
are oriented the counter clockwise so
that that's what the CCW means so the
three small triangles sqr p sr and PQ s
then you have a theorem that says that
the larger triangle PQR is also oriented
contact law wise so it's a theorem that
is used to prove the correctness of some
algorithms now what happens with with
doubles this counter clockwise test is
the orientation test or three points PQ
R and this is actually the sine of a two
dimensional determinant when you refer
to the Cartesian coordinates of the
points so pxrx etc you have the formula
here now if we pick a particular example
you pick the point P and Q on the main
diagonal with these coordinates so
one-half one-half for p and 24 24 for Q
and you pick a third point R which is a
very close to P and we actually zoom in
on this area and we paint the color of
the result of this orientation test that
we get with doubles so R is actually
very close to P very close being that
the zoom square here corresponds to 256
consecutive values of floating-point
numbers so this is very close to the
point P and you see that the computed
orientation value using floating points
is actually very far from where it
should be with the exact theoretical
geometry which should be only one main
diagonal of yellow squares so here you
have some kind of random area along the
diagonal which means that here you have
some values you which you hardly can
predict you will you even have some
inversions if you look at some specific
cases here so this means that with such
an orientation test you absolutely
cannot rely on some theorems to prove to
prove your correctness of the algorithms
and you actually run into into trouble
in practice as well so the solution that
we try to advocate in Seigle because
it's general is the exact geometric
computation it means that we do not
strictly rely on exact arithmetic which
means costly computation but it is a
refined scheme of this the idea is that
you can guarantee the robustness of your
algorithms if your predicates are exact
because your algorithms are going to
take decisions during the execution
based on the results of these predicates
and as soon as you guarantee the
exactness of the predicates as a whole
then it is it is okay you are going to
you are going to have robust algorithms
sometimes you observes that construction
geometric constructions can have more
approximation and it may not be a
problem so for example in meshing
algorithms if you construct a new point
it need not be exactly let's say the
circumcenter of or three or three other
points it may have a little bit of error
we use for this some arithmetic tools
Milty precision integer and rational
numbers multiplication floating-point
numbers so there are libraries like GMP
and PFR which provide this and also some
more involve the algebraic numbers of
low degree interval arithmetic is also
used to control in an efficient way the
round off error of floating point
numbers fourteen point operations and in
some places we even use some static
analysis of the round off error
propagation within the predicates code
so let me give just a review of what how
you use this in practice in seagull so
typically we have generic functor
adaptors so there is this example of the
filtered pretty predicate class which is
actually producing a predicate based on
two instantiations of a given predicate
code so if you have the orientation
predicate instantiate it with interval
arithmetic you can run it first and the
interval arithmetic is going to tell you
if the sine computation inside is
certain or not if it's not certain then
you can instantiate the orientation
predicate again with some more precise
arithmetic like rationals the idea is
that the the average speed the expedite
speed is going to be the one of
intervals rather than the multi
precision but you still always have the
exact result so as I said before there
are some refinements of this which are
faster than just interval arithmetic
using some static error propagation
analysis and also some more progressive
precision increase than just switching
to fully rational numbers now a typical
benchmark that illustrates exactly what
what kind of speed we we get with that
if you compute a 3d DNA translations of
1 million random points if you use
doubles
you can do it in 13 seconds if you use
naive multi precision then this is much
much slower so 800 seconds if you use
the the filtering scheme based on
interval arithmetic and then rational
numbers then you go down to 63 seconds
which is already much more interesting
so it's only four or five times slower
than doubles and with more refinements
you can use these static filters which
are approximately 20% slower than
doubles overall so which is very good
for an exact granted result on
non-random data sets then this can be a
little bit slower but you have
guarantees so this was for geometric
predicate but we also have some scheme
to have exact constructions in case you
need them this is what we call filtered
constructions that is when you compute
for example this figure you start from
four points P Q R and s their form each
two segments T and u and then you
compute the intersection I between these
two segments we provide actually a
mechanism to compute this exactly but in
a lazy way that is we first computed
with interval coordinates for example
for the intersection points and we
remember in a directed at cyclic graph
the way that it was constructed in case
we need me later more precision
now this scheme of exact geometric
computation is a not bullet proof there
are some cases that it cannot handle
there is some work still on going on
topology preserving random there are
some issues with algorithms that use
cascaded constructions so repeated
constructions because then the size of
your DAGs
is growing and finally there are there
is work ongoing on improving the
efficiency of exact computation with
algebraic numbers
that you encounter when you manipulate
curves for example so intersections of
Seattle's that unrest should previously
okay I will let unrest conclude so we
let me just report on what are we
currently working on what what you what
can you expect in the future
so one thing is a parallelization so
there are multi core processes outer so
it's kind of obvious to look at how to
get triangle eight well to get data
structures and algorithms
well algorithms faster by by using
things like open MP there are things
like other language bindings so for the
python language and things like making
toolbox for scilab which is a an
environment comparable to 2 metal happen
and there are plugins for for drawing
tools and more algorithms and data
structure Center well the man with
screenshots is Beckham here what we see
is not generation of surface measures
out of voxel input data of medical data
but a generation of volume measures so
what you want to do is you have octal
data the tissue so the different tissues
are marked and for example for for
simulating of how does radiation go
through the body and how do cells
receive energy so people that do these
kind of simulations they need
decompositions of the tissues in in
measure so what is particularly is that
the entire thing is computed in one shot
it's not that
marching cube is running on one tissue
after the other and then you try to to
glue the tissues together with with with
problem setter at the boundary so all
the thing is constructed in one single
shorter if you are of my age you maybe
know as through eaten so it was an a
card game you have a little space
tripper and when you fly to the left it
just wraps around
and your IV again the same for these
asteroids they flow out on the top so it
comes back then the thing is a it's
called periodic spaces and what we do is
there's work underway on offering
geometric algorithms and pie or attic
spaces so that's interesting for for
people who who don't like who don't like
boundary conditions so the things that
that's kind of the equivalent to the
screen we saw before what we do in this
in this area we have points in there and
we triangulate them and instead of
triangulating the convex hull what we do
is so we connect the triangles outer to
the right coming in back the edge coming
coming back on the left okay so if you
look at this triangle here it's it's the
same triangle then this triangle here
okay that they are connected it's it's
the same triangle in memory in the data
structure yourself okay and now this
allows so now we just if we follow our
pointer would move in such a
triangulation now we see it enters a
triangle and it kind of wraps around so
it jumps to the other side enter the
work and the triangulation can kind of
continues so here you saw it in 3d in 2d
it's in it's under development for in in
3d enter there people like cosmologists
which which are interested in this kind
of kind of applications
another thing is a geometry on the
sphere so it's not geometry in the plane
but on the sphere so here you see an
arrangement so yeah a planar graph and
the edges here they they are straight
there they are
arcs of great circles okay so they are
round but they are not round to say a
like like a half circle but they around
on this on this on this run surface okay
then there are algorithms like a Voronoi
diagram so on the sphere and things like
and map overlay so let's take the two
the two planar maps we saw before the
overlay would computer the the new
intersection points and decompose it
further in in faces on
okay - to sum it up so what we try to do
yeah what we try to tell you so sigil
it's a it's a large collection of data
structures and algorithms so with a very
uniform design because well there's a
that's the there's kind of process of
you silver mentioned that to this
reviewing process where we pay very
careful attention to that things are
very uniform enter that it's kind of
your homogeneous for for the users huh
another important point is a it's a dual
licensing scheme so it's not a purely
religious open-source it must be open
source so for those who cannot we cannot
respect such license there are there
alternatives in the project we folk we
focus on geometry so we don't try to
have a general purpose library what we
do instead we try to interface to make
it as easy as possible to interface with
existing stuff like post graph library
the STL I mean you saw examples for that
there are two paradigms we adhere to
generate programming the main purpose
for adhering to it is make it easy for
users to integrate stuff it's rich
generic programming is really about
adaptability about make it easy to
integrate and the other paradigm the
exact genetic computing make it robust
make it really that it doesn't crash I
mean if there's a bug then it crashes
but it will not crash for problems with
floating-point arithmetic things like
that and this filtering to have it fast
at the same time robust and faster and
so we end here thanks a lot for your
attention any questions so Silvan mia
are ready to take your questions they'll
take we'll take questions now this talk
is being broadcast the public so keep
that in mind and if anybody's interested
in lunch with the speakers will be
having lunch as soon as we're done with
the questions thank you
I had a question
so I had a question about the exact
computation the when do you decide to
move from one computational domain to
the other like from rational arithmetic
to the algebraic so the the need is
actually triggered because when you use
for example interval arithmetic to to to
compute your predicates inside your
predicate you have this sine function or
comparisons and when you compare two
intervals you may not always have a
certain result output so if two interval
overlaps then what is done is that so it
may trigger an exception a C++ exception
or you may also report this through
another mechanism by your special return
type we actually use both methods for
efficiency and in this case then we
actually call the same the same
algebraic code so when you saw the
expression for the orientation predicate
sine of BX so this is encoded in a
templated function so you you had this
instantiated with the rational number
type for example and you call this again
and in in this case in it cannot fail so
you have the finally the exact result
did I answer your question</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>