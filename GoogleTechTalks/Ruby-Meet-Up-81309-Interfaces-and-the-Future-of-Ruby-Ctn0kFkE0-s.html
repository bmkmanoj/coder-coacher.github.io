<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ruby Meet Up 8/13/09: Interfaces and the Future of Ruby | Coder Coacher - Coaching Coders</title><meta content="Ruby Meet Up 8/13/09: Interfaces and the Future of Ruby - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ruby Meet Up 8/13/09: Interfaces and the Future of Ruby</b></h2><h5 class="post__date">2009-08-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ctn0kFkE0-s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so next up you guys all know who this is
is you who two cats of engine yard and
rails core fame and Murr fame there's no
more I can say is uh so that's it I'm
gonna leave it up to you who to take it
away okay can you guys hear me all right
sweets ah power okay just getting
comfortable here okay so my talk today
is called interfaces in the future of
Ruby which is I guess a highfalutin
topic here to talk about rails three but
I'm gonna focus on how we're making
better interfaces in rails three and how
that might affect Ruby beyond rail so
that's the reason for my topic could
easily have been called you know what's
new in rails 3 or here learn about rails
3 i'm focusing heavily on sort of the
extension API the part of the API that
you would dig into if you were doing
beyond just the top-level view of rails
there's of course a lot of stuff that
we're working on on the top-level view
you'll hear more about that in a couple
of months to come but I'm focusing today
on the internals and how you could
leverage the fact that we've improved
the situation there to build better apps
so first of all who am i I'll skip this
you to cat slide whoa all my images
appear to have vanished okay I'll just
I'll just skip all that and I'll tell
you what I would have said if I had
images job I'm Yehuda I work for a
company called Engine Yard engine yard
is really great they basically fund all
the work I do they funded all the work
I've done for about two years now that
includes a year work on mer band nine or
so months on rails they also fund Carl
Ertz who used to work on merb in his
spare time got hired to work on ey cloud
and eventually moved on to work on Rails
so me and him pair every single day and
if anybody's skeptical about pairing
Carl and I do work that we would not be
able to do without pairing and so a lot
of people think that pairing is mostly a
training thing and I think that's
definitely one possible use case for it
it's also very useful if you have really
hard
so maybe there's like some medium-sized
problem where it might not be
appropriate I guess but training and
really hard problems are really good use
case repairing I have one little paring
anecdote before I move on to the rail
stuff which is I was sitting on a plane
a couple weeks ago and I do that a lot
these days and I was sitting next to a
pilot and I was tasked me what he did
and he had like made some PHP site for
his little the for his daughter so we
had something in common i guess and he
was asking me you know what do you do so
i told telling about rails a little bit
and I was talking about pairing and he
said to me he need to say anything else
he said that makes perfect sense to me I
couldn't do the job I did if I wasn't
pairing he he has a co-pilot he said it
doesn't really matter to me if if I need
the copilot there at any particular
point in time you know most of the time
it's just there as a backup but when you
really need the copilot you really need
the copilot and I feel the same way
about pairing you know a lot of times I
could probably do the work I do myself
but when I get into a dangerous area or
you know start working on something
really hard I'm glad someone sitting
next to me that can actually do the work
so just if people are skeptical about it
i know i won't one point in my life i
was skeptical about pairing because i'm
a pretty good programmer and can pull it
off usually pretty well and we're more
than twice as productive with two people
then the two people would suggest so
anyway so who are you since you're here
I assume you're all rubyists the most
obvious you're rubios this application
developer application developer is you
know the left side when you start
working on rails you're just a
application developer and over time you
move on you become a power user
definitely missing some images again
here which is fantastic so
they're supposed to bits pointing at
actual things something obviously got
messed up but I can improvise so when
you start off as an application
developer you move on life to you become
a power user and that a lot of people
think you know that's sort of some apps
or application e some apps or power user
e and that there's definitely aspect of
it that that's that there's also an
aspect of it that's as you grow as a
developer you go from being a simple
application developer you know you go to
a pio ruby-on-rails org that's your life
you never look at the rail source code
use plugins don't really look into how
they work that's sort of the beginner
style and then as you move on you spend
more and more time inside the real
source you definitely you know look at
the plugins that you use before you use
them make sure that they work correctly
aren't going to interfere with what
you're doing really understand how rails
works internally know how to sort of
bust in and make some changes if you
have to and there are applications that
work that way there are people that work
that way but over the lifetime of both
an application and a person working on
rails it becomes more and more likely
that you move over the over into power
user territory just skip these non
images historically rails has been very
good at the application developer mer
was created mostly to take care of the
power user end so you know rails is
great if you're starting off but once
you start having to dig in people felt a
lot of pain so we moved off and
basically made a framework for that for
that hacker group but the point of rails
3 is to sort is to integrate that so
that as you move up from application
developer to power user you get that
smooth slope of goodness just the same
way that the API was great when you
started working on rails as you start
needing to do different things swapping
out functionality adding new adding
hooks anything like that it's the same
pleasant gradient as it was when you
started so that's sort of the point of
rails 3 gonna take a little detour here
into programming so what is what is
programming the very simplest type of
programming is procedural programming so
back in the when programming got started
programming was basically just a way of
handling control flow so this is even
more complex in the early programming
but it's
sort of you have an if statement you can
have loops in assembler this is handled
by like jumping and compare if equal and
and whatever but you basically have a
big glob this is very very small thing
but you basically have a huge amount of
this all wired and together and that's
how you procedural programming works you
can get some good good syntax for
procedural programming but in the end
it's just a big ball of code with no
obvious and entry and exit points just a
big ball of code and that works fine
until you start to notice that hey a lot
of this code looks the same where I'm
reusing code and in the assembler
procedural style you use go to you jump
back to where you have to go and you get
cute about calling conventions you know
i'm going to put something on the stack
here and then when i go here it's going
to know to pull it off the stack and you
end up basically inventing all this all
this ceremony to handle what is your
handle repeatable code so the solution
is basically to have some kind of
subroutine subroutine takes that
procedural code and wraps it up into a
box and you start with you have an entry
point then some stuff happens in there
and then you get some output out right
and the real benefit of this is that you
have a black box you have you don't
really have to know what goes on in
there although you might want to you
have a black box that you can wire up
with other black boxes right so now you
have you can create programs that are of
higher complexity because when you're
developing at that higher level you
don't have to worry about what's going
on inside each of the black boxes so
what do you get out of this you get
number one you get a better interface so
you can get something like you know Ruby
H which is just a list of interfaces you
have our bestir new takes in a car star
and along and spits out an object rb2 ID
takes an object spits out a symbol car
star barbie global error will get takes
the car start spits out an object right
so you can now say clearly to your users
not you have to go to align whatever or
this label or and you have to handle
these conventions right you have a clear
here's a bunch of interfaces that you
can use if you want to interact with me
you can build a contract on that right
Ruby that H is a contract Rubinius is
able to take ruby h and
have the same contract apply to its
internals even though it's completely
different inside those little boxes work
differently inside right and finally
conventional you don't have to worry
about the fact that you know I'm going
to write a function and I'm going to
have to worry about what the calling
convention is to call the function how I
get the return value back or how I show
that there's arguments right when I'm
writing code how do i specify an
argument and basically you get a
standard way of doing this because now
the language has functions there's a
standard way of putting things on the
stack and getting it back and all this
right so it basically means that this
sort of thing is effectively identical
to this and so programmers can treat it
like just box like I said a minute ago
it also means that it's changeable you
can take my sequel H and replace it with
your sequel th and that works just fine
and there are people out there who have
made my sequel work alikes basically all
they have to do is take the contract
that my sequel that H provides do the
same thing different internals
everything works okay so we have
effectively something good with
procedural programming but eventually
start to do a lot of this you notice
that there are states state that gets
passed around that's the little green
dot I'm not sure if you can see it back
there but you you end up chaining bunch
of the stuff together and you end up
seeing that there are state that gets
passed around maybe even functions that
start with the same name right and if
you see that a lot and you can you even
see that in Ruby code where obviously
which is where I'm getting to you start
to see patterns where a lot of the same
thing is getting passed around a lot
right the solution is to go up another
level of abstraction to create an object
that encapsulates that state and has a
small number of inputs and outputs which
are similarly to the way that each
function at an input and output now you
have a class which has inputs and
outputs and we get basically the same
wins out of this now we have a contract
for the entire class we have conventions
you know how to instantiate you know how
to pass things in there's something
instance variables usually you know how
to specify methods in non insane
languages self does not have to be
provided all the time and it's very easy
to change out one implementation of a
class for another implementation of a
class basically that
what this means is that you can take a
class that is supposed to handle one
thing and replace it with another with
the class that handles another thing now
some languages are better or worse than
this than others in Java you have to do
a lot of stuff up front to make sure
that this change ability is possible
right you need some dependency injection
thing to make sure it's possible but
bottom line is that if you do the right
thing you have a contract that you can
easily replace out with another
identical piece of functionality as long
as it obeys the method names and what
they're expected to return and all that
there's actually yet another level of
abstraction here which is you start to
notice that you're actually writing the
same function methods over and over but
they work on different classes they work
on different selves so you have a piece
of functionality which is procedural it
has the notion of a self maybe use some
instance variables but it's not
obviously belonging to any specific
class it belongs to any bunch of classes
that happens to do something the same
kind of thing and that is basically a
module or a trait right so Scala calls
our streets Ruby calls it module it's
not exactly the same thing but
functionally what this allows you to do
is create a bunch of method somewhere
which are adjectives right you can think
of classes as nouns I am a person and
you can think of of modules or traits as
adjectives and Ruby we have innumerable
comparable right these are adjectives
these are effectively the same thing a
bucket of methods with self and possibly
instance variables but they they get
attached onto classes and effectively at
runtime the module evaporates and you
have the same thing right and you get
the same app the same win here you get a
contract innumerable behaves a certain
way as long as you provide each you get
these other methods for free it's a
convention here is how you include a
bunch of methods in Ruby you make a
module you call it a module name you add
a bunch of methods you can know that
self behaves a certain way it's going to
be super is going to be evaluated at
runtime to point to the next module
right get a bunch of conventions and it
can also be changed out so if i have a
class active control action controller
base and i pull in the rendering module
i'll get to all this in a minute it's
very easy for you to replace
out that set of functionality because it
also uses a certain contract that uses a
certain set of methods that take input
and output and behave a certain way and
as long as you obey the same contract
you can know you it's not only that you
can replace out the entire class I want
a different controller you can replace
out specific parts so what does this
mean for rails 3 now that I discuss that
a little bit rails 2.3 looks like this
there are definite components we have
active record action controller action
view they're in different directories
but when you really start to look at it
action controller assumes a lot of
things about action view it's not easy
to take action view replace it with
something else because you have to
implement a lot of interconnectedness
and that interconnectedness is not
documented right so and nor is it
considered supported so if you decide
that you want to monkey patch something
you're basically always working against
internals and that's how it works to
extend things in rails 2.3 rails 02 2.3
right in that it looks like there's some
components but everything's kind of
coupled without any obvious separation
rails 3.0 works differently so we have
we still have something which is
actually controller but instead of a
thing called action view that action
controller cares about we have an API
which is action view compliant and
action controller cares about that and
if you replace it with something else
that works the same way everything's
fine similarly instead of dealing with
active record we found we figured out
what action control cares about in terms
of active record documented it and now
you can use any active model compliant
library together with rails so what do I
mean by this exactly for actually you
comply you might think that there is you
know probably a lot of things because
action controller action view in rails
2.3 if you've ever looked at the
internals it's very complicated is a lot
of things going on there's million paths
from action control attraction view but
we actually got it down to a few things
and actually this is even a little out
to date it's even simpler than this
first of all you have to implement your
action view dot 4 controller and this is
out of date it used to take paths and
assigns now it just takes controller so
for controller takes a controller it's
required to return an instance of the
action view object and that action view
object is required to have three methods
on it render template which takes a
bunch of options options is an options
have so I'm kind of hiding the fact that
there's a bunch of things that has to do
but you can decide which features you
want to implement so there's a bunch of
options that you have you would support
if you were a complete implementation
but because it's an option tash it's
very easy for you to support you know I
only care about partials I don't care
about collections of objects that would
be very easy to implement and do
integration in cases where you didn't
want to support the whole API render
partial similarly it expects to get back
string both of these cases and that's
actually it so as long as you have an
object that takes 4 controller returns a
view object that has around your
template and render partial that takes
an option sash that's it action
controller is happy there are some
specifics of what the options hash is
but that's basically just the API that's
the method call of what for template for
template render template and render
partial do act a model template again
you might think that there's a whole
bunch of stuff it seems like active
record is pretty tightly bound to action
controller there might be a lot of
things you have to implement in order to
make it work correctly turns out that
when we really dug in and documented
exactly what parts of a cure record
being used there were only a few of them
there's new record ? which is just
basically whether or not this thing was
persisted a lot of people lobbied to use
a different name other than new record ?
and I think I pedantically agree with
them that there's some better terms for
persistence maybe like persisted ? but
the fact is that the right the best way
to do this was to say instead of going
through all of our integration code and
changing all the method names we're just
going to say that the API is whatever
active records API is right now and I'll
get into it there's only a few more
methods and then we'll just I'll show
you soon will make it so that anything
can implement that so new record ? is
effectively the saying not persisted
valid ? is assuming that you have the
ability for a record to be invalid and
have errors on it you can respond to Val
? with false to say this is not valid
should not be saved
errors is an object that is effectively
a hash so it's it's an object that you
can pass in a key represent a hash key
representing the name of the attribute
and it will tell you a string which is
like here's the actual error and then it
also has a full messages method on the
era's object that returns an array of
all the of all the errors so that it can
be printed out in error messages for and
finally there's a object or model name
which sits on the actual class and model
name handles the fact that when you
redirect to something it has to go to
the model and figure out what the right
path for that is or if you say render
partial some object that some object is
converted into a partial name how does
do that well there's a method on the
model name object that does the right
thing you can either use the model name
module that comes with rails now and
that will do the right sorts of
manipulations that you would expect on
on a on a ruby objects odel you know can
it'll convert it to underscores and then
it will convert colon colon 2 / right
the sorts of things you would expect out
of a rails object or if you have a more
complex model and you want to be you
want to simplify for instance right now
Jay Ruby's java objects are like java
colon colon java.lang colon colon crazy
you probably don't want to actually have
it convert you don't have to put your
templates in java / java.lang / whatever
else so you can implement this model
named object however you want and
that'll specify how your path should be
converted in all that is I think five
methods on it singular plural partial
name I think so there's a few methods
that basically you can either take the
default which is what you want to do in
most cases like data mapper would just
take the default because it's just a
regular Ruby object or if you're dealing
with something weird you can implement
it yourself activemodel so what I just
said is active model compliant there are
basically two pieces to active model I
talked a little bit about a little bit
about the API acta model also comes with
a bunch of pre-baked components so what
happened in a lot in rails 2.3 is that
you would you say I want to build a
couch TV adapter I want to build a
MongoDB adapter I want to build a big
table adapter right
and basically you just want validations
to work exactly the same you want naming
to work exactly the same you want
everything except for the persistence
part of it to work exactly the same so a
lot of people like copied and pasted
code or rip things out or try to include
modules there's a few CouchDB adapters I
try to be like active record but the
bottom line is that there's no reason
why that we couldn't extract that out
put in a separate library use that
library in active record and then you
could just use that same library
yourself so the most obvious candidate
to start with is validations and i'll
show you how validations work in rails 3
so here we have just a regular class
person class and the first thing we're
going to want to do is include active
model validations so we just include our
validations module and now because we
included the validations module we have
access to validates presence of which is
exactly the same validation that exists
in active record and you'll notice that
we're not doing anything special with
our initializer we're just making an
adder accessor which is how active model
thinks about attribute access and then
defining an initializer to say you know
take the name set the name if we make a
new person we of course do it using
regular Ruby mechanisms and we can say
is the person valid and in this case the
person is not valid the person is
invalid because the default initializer
takes an ill name and we said validates
presence of name if we ask it for the
errors it'll return name cannot be blank
this is actually just a default English
one their active model comes with a
locales so you can either use the
default look the locale versions that
are out there or you can make your own
for your own language but the error you
basically get low Khaled errors for all
the default validations for free as part
of active model and now if we make a new
person we let's say person got new mats
and we ask if the person is valid we get
back true so that's active model
validations the second part of it is the
API like I talked about so if you want
to take a ma a regular plain old Ruby
object like this person and have it work
fine in rails you have to implement the
API and let's look at you know what does
that look like exactly my benchmark for
a lot of stuff is can it fit on the
slide by the way so
so here we have our person object again
and like I said we have to implement new
record in this case I have a persist
method which just does at persisted
equals true doesn't really matter how
you handle this in this case I just said
that new record is persisted in real
life you'd want to actually persist
things finally a to model I didn't talk
about that very much but so we could
just say you have to be compliant you
have to make your object be exactly the
same as the actor model API it's
actually pretty small we could have said
that but what we realized was that
people out there might already have
objects that have an errors method on it
right or a valid ? method that doesn't
exactly conform to what rails and
expectations are and so what we've done
is we've created a new method called to
model that sits on that sits on your
object could return self if you're happy
if you're compliant if you do the right
thing or could return another proxy
object that implements the right stuff
so we call to model on whatever object
you pass into form for redirect to or
all that to convert you into the
canonical rails friendly form in most
cases that's going to be self in a few
cases sequel is the case that comes to
mind seq Yale library they already have
an errors object that's not compliant so
they're forced to make a proxy object
that implements error is the way we
expect in the vast majority of cases
you're just going to implement
everything cool there sweet on the vast
majority of cases just gonna make your
model compliant and that's just gonna
work okay I talked a little bit about
naming before you need to do this as
well you need to pull an active model
naming and that gives you you know that
means that it knows how to get the
singular plural partial form of all this
stuff also recommended but not required
is that if you create an initialize
method you take attributes rails doesn't
care about this at all but when you make
go and make your controller you probably
want it to look kind of like regular
controllers and do kind of the regular
nice things that rails does in
controllers so taking a hash of
attributes for your initialize is
probably the right way to do it again
this is just a recommendation it's not
required by active model but it's
probably the way you want to do it okay
so now let's look at the
roller so we have a regular people
control our hair it's from action
controller base nothing special here and
in our new method we just say person
equals person that new params person and
this is why I recommend putting in a
hash so that it looks kind of exactly
the same as everybody else right so
you've now made a new person with params
person created a little bit more
complicated I did person that persist
there which is the method i added but
the interesting thing here is that you
can redirect to person path at person
and that just works that does the right
thing all the crazy rails magic just
works ok what about views so error
messages for person obviously is going
to work just fine because we implemented
all those errors stuff you can do form
for person remember this is this doesn't
hair from anything all it does is be a
regular Ruby object that includes
validations and extends naming and you
can also do at that text field which
will pull a thing out of the right
attribute ok so Ruby awesome so Ruby is
uh is 1.5 megabytes of RAM when you
split it up and you might expect that
all the stuff I just showed you probably
pulls in like the whole act of support
and like the entire Ruby standard
library and obviously all of rack and
all this stuff so probably you you might
think oh I'll probably using some rails
but I would never use this outside of
rails that doesn't make any sense at all
probably pulls into all kinds of stuff
in reality everything I just showed you
getting all the validations stuff
working that just adds an extra one
point five megabytes so that partially
that's because we use a small amount of
features but that's actually a pretty
big deal means that you could use a
small amount of features and not worry
about pulling in all kinds of stuff so
in R if you have a project that wants to
have validations that maybe isn't a
rails project and you just want the
rails validations to work you can do
that and they're basically no memory
action pack so rails 2.2 I think added
this concept of metal and the idea was
rails has all this overhead there's a
whole bunch of rails overhead what if
you just want something bear on the
metal on rack I just want it I don't
want to have to worry about rendering
all this extra stuff that happens in
controller and so there was this thing
called metal which is basically a
glorified rack handler and if you then
wanted to take that and move up to a
full controller you moved up to a full
control and you got all that extra over
right back rails 3 point 0 says why
can't we just build the actual real
controller on top of what we call metal
right so let's build make metal the base
of the entire controller system and
we'll add in the features that we want
to build a full action controller base
which means that you can then add in the
features that you want on top of metal
so let's say you sit you realize you
need rendering on top of your bare metal
you just have to pull and rendering
alright so that's how metal works I have
some repeated slides from earlier this
week when I was in Brazil so constant
names are affirmed then so step one you
know you inherit from action control of
metal in real life you would probably
never do this you would use action
controller base but if you want if you
needed performance and you were going to
use bare rock handlers this is actually
pretty good this is pretty performant so
you in hair over max controller metal
and you the API is just set the response
body directly self that response body
equals hello world now you could use the
router but if you don't want to if you
just want how to get how rails works
without the router you can set up a new
rack builder and you can map any path
onto the controller name that action the
action name and that gives you back a
rack object that you can run just like
any other rack objects so again you
probably would use the router in real
life the router and rails three is gonna
be very fast but this goes to show that
there's no magic in the router there's
nothing special in the router that makes
rails work you can just get a hold of a
rack object that's the action and give
it in it'll work with all the features
that you need okay so one of those
features is call back so I just made a
very simple thing that the self dot
response body equals whatever what if i
want callbacks that's a very common
request very similar to what we did
before with action activemodel you just
pull in abstract controller callbacks
abstract controller is is a controller
that works that doesn't know anything
about HTTP so action mailer is going to
be built on top of the same API you be
able to use the same callbacks layout
rendering code
action mailers you use an action
controller so we include the callback
system and now we get before filter
which is what we expect when we get
callbacks and we can define set name we
call private basically works exactly the
same so we've just added in callbacks
adds base i forgot to say the first
slide actually renders in eight
microseconds which is basically no time
at all this adds a little bit of time
maybe a few microseconds but not a ton
of time at all to render callbacks and
we now have a callback API that's
basically identical to the rails
callback API without having to suddenly
jump up to the full action controller
base another common request is rendering
so I want to actually render template so
the first thing we're going to do is
we're going to include the rendering
module and as you as I continue to work
through this you should notice that
that's really the pattern rails three
you could use the full active record you
could use the full action controller
that'll work fine that includes all the
modules or you could use a stripped-down
version a simpler version your own
object and you could pull in just the
modules that you need so because we're
not running the full rails we rails
doesn't know where to look for the view
path so we'll give it will tell us that
the view path is rails that route / app
/ views and you can obviously set that
to be anything you want that works in
regular rails controllers as well and
then the normal renderer works fine
render template index works great and in
show we can set an instance variable and
say render template show and just like
in rails where instance variables are
going to be available it works just fine
and again because my metric is how can I
fit it on a slide and I didn't want to
add a router I just added another line
that points the show action to the show
action so actually this this slide runs
there's requires missing on the top so
you need to require a few things
obviously but this code runs by itself
as a rails app rack app whatever you
want layouts
so I want to go beyond rendering I want
to add rendering layouts layouts
actually are expensive even if not used
simply because you have to check to see
if you mean to use it every time for a
variety of reasons it's very difficult
to cash I never want to lay out ever so
we allow you to opt out of that you know
you could just use writing room without
layouts but you might want two layouts
you pull it in and that gives you the
standard up that gives you the standard
layout default well it's going on
okay that gives you the standard I'll
just walk through it I'm not gives you
the standard layout default and you can
now it adds the layout option to the
render method oh I see sweet
another no picture that was a picture of
dog food at some point um okay so the
big the big thing here is that you could
think that we're just gonna expose a
bunch of api's hooks that you could use
that work fine you know you can include
callbacks you know hooray it's gonna be
pretty but you know who knows if that'll
work right maybe it'll suddenly break in
some future version of rails and the
reason we know that that's not true is
that the entire rails 3 is actually
built on top of the same stuff so rails
3 action controller base is just
class-based inherits from apps action
trailer metal include a whole bunch of
crap and so we include all the modules
into ask a controller base so you can be
sure that those same modules will work
exactly as expected if you decide to
write a stripped-down version we
actually go as far as to make sure that
pretty much everything we want to do in
rails uses hooks and api's make sure
that the hooks are really fleshed out so
one example is rails to compatibility
instead of putting all the deprecation
warnings directly inside the code we
want you to be able to say i know i'm
good i don't actually have any
deprecated code i just want to eliminate
the overhead of having to deal with
those special code paths because
deprecated code slots to say like if the
thing i used to do still works then do
it otherwise do the new behavior so we
want you to be able to say like i'm good
i don't need the deprecated behavior i
don't want to pay for it we also want to
have a single place where that code is
so we know that like after rails through
point O comes out we could delete that
file in rails 3 p-11 it'll still work so
we have a module called rails to
compatibility it has a bunch of stuff in
it here's one example so in rails you
might think that figuring out what the
action is forgiven given method to call
forgiven action is pretty easy right if
its index is index done right but
actually there's a lot of special cases
first of all there's hidden actions if
you hide the index action using hide
action you don't call it if its private
you don't call it if if there's no
action but there is a template with the
same name it's valid right so there's
whether or not something is in action is
actually kind of complicated so what we
did was we made a method
method for action that by default just
says it's the name of the method and
then gets extended as you go down the
chain to add support for things like you
know if you're in if you have a template
with the same name as the action that
should work and I'll show you kind of
how that's handled so here's here we
have a different case which is in rails
32.3 method missing was the catch-all
action the problem is that method
missing is actually used for other
things and produce all kinds of weird
effects like especially when you add a
bug in which you called the wrong method
all of a sudden your catch-all actions
getting called and very weird behavior
resulted possibly at runtime so not very
good so what we want to do is instead is
say we'll just make a new method called
action missing that is the way that you
handle that's the catch-all action and
you can you go back using method missing
for what method missing does in Ruby
which is the method wasn't found but we
still need to support method missing in
three point 0 because with support in
2.3 and we're trying to be pretty good
about backwards compatibility so the
first thing we do is we call super which
just says all the other code out there
that handles method for action try to do
it if there's no method fraction and in
this case it's because you have a method
missing but there is no actual action
called that in any of the parents
there's no template called method
missing there's no the action name is
not method missing so the normal rails
to the rails 3 code paths don't know how
to handle it if there's no return value
check to see if you respond to method
missing if you respond to myth method
missing call return the method handle
method missing so basically what this
says is if there's no actual method but
method missing is found on the object
then the action is a handle method
missing and the handle method missing
method simply just calls method missing
action aimed to sent right so
effectively what we've done here is
we've removed the need to say in our act
in rails we don't have to ever say if
you're in if you have method missing
then raise deprecation warning or like
you know active support deprecation new
etc stuff and all that has to be checked
every single time even though you know
you're not using that
okay to code now we can see like here's
the actual stuff we're deprecating okay
act to support in rails 23 you say
require access port pulls in the whole
act of support that's the end of the
story in rails 30 the equivalent is act
require export / all this is probably
fine for your own application where you
don't want to have to care about it
maybe if you want to tune it that's fine
this is never going to be okay for
plugins if I ever see this in a plug-in
not going to be happy the rails core
team is pretty much on board with this
we want people to be able to write rails
applications in which they just pull
into parts back to support they need
which means that if you write a plug-in
that requires export / all in Brielle's
three-point Oh everybody who uses your
plugin is not forced to use the entire
active support just because you were
lazy and didn't figure out which parts
of export you actually need that's
actually pretty high burden for regular
app developers we don't want regular app
developers to have to know all the
little piece of actors for what they do
so for regular app developers the
default is going to be all but when you
write a plug-in there's a higher bar you
should figure out well functionality you
need and require it that way arbitrary
things like r XML which in we need to
require XML so we can apply a security
vulnerability patch if you don't
actually require XML you should not be
getting Rex ml pulled in because it's
pretty huge so that's one example time
and date libraries are another example
you want people to be able to use your
plug-in in a very tuned environment
something that will be included by
default no matter what that rails
requires so this is something rails is
going to require is active support Ruby
shim and this is basically pop things
that are in ruby 1.9 that are not in one
point eight point six that we want to
use right now anyway and here's a list
of them so we have stuff like date next
year next month which RM 19 we have date
time we have stuff like innumerable
group by this is stuff that was added to
access more first and pulled back into
core object that app is used a lot then
we have processed at daymar xml security
fix like i said wrexham l security fix
will not be pulled in if you have ruby
1.8 7 or higher because it will already
have been applied so you probably want
to be doing that and then string toward
symbol to proc those are all part of
those are all part of rails by default
no matter what
so basically the idea behind ruby shim
is why can't we have from future import
star right to ruby is very flexible
language you should be able to implement
a lot of 1.9 features that are not
partial features in 1.8 if we want them
frequently rails does want these
features so let's just do that let's
just give them to you require export
ruby gem done another aspect of what
we're doing with active support is
trying to reduce the amount of pollution
so again by default it's very convenient
to have stuff like camel I so we're not
going to eliminate camel eyes from your
default app that would probably break
everybody's app right but what we are
going to do is we're going to internally
use access for colon colon and flecked
your doc analyze and therefore it will
be possible to not include the parts
that pollute the the namespace a classic
example this is JSON so a lot of people
have had a lot of complaints about
active support overriding to JSON well I
think a lot of people didn't realize or
in their complaints like ignored was the
fact that the problem was actually that
two people were doing it the problem was
that the JSON gem did it and active
support did it so a lot of people said
oh my god I can't believe how bad access
port is they're breaking the JSON jump
no access port and the JSON John we're
both doing the same bad thing it's just
that rails actually cared about the
results of two JSON and the JSON gem
itself didn't but you people should not
be writing code that relies upon the
actual value of a core library extension
so if you extend object to have some foo
method on it you should not in your code
in the code that you written rely on
object out foo existing you should have
some modular eyes method like active
support object dot foo that you use
internally and then maybe expose the da
foo for convenience to your users that's
what we're starting to do in rails
there's definitely a lot of think places
where that is not done in rails and I
actually doubt it will be done entirely
for rails 3 which is why this slide the
previous slide said less pollution and
not no pollution but the goal is to
start moving to in a direction where
we're not relying on core class
extensions especially ones like to JSON
which could happily be made by somebody
else what we're also doing is we're
allowing you to specify what the back
end is so we're defaulting to our really
bad yamo thing that like kim takes json
regex is a 10-cm
then uses the built-in llamo parser I
don't know if you know that but that's
how JSON parsing happens in rails by
default right now which means you
probably have the JSON gem installed
because then it will do that it's
probably right way so acts as a poor
JSON back end Jason gem is one way then
there's yeah L rails which is another
JSON library that is a stream parser
which is not really what we use it it's
pretty fast so basically we're allowing
people to make their own JSON part
backends that conform to a certain API
and then we'll just use that if you tell
us to so we default to JSON gem if you
have if we have JSON gem really bad
llamo parser if you don't have JSON gem
and then just some other ones available
like yeah jewel bottom line is that you
should think about actors for like an
extended standard library nobody wants
to do that because just like if the
standard library was require standard
library I don't think anybody would have
ever used it all right that would be
crazy you're not going to pull in every
single part of the standard library just
to use time Darby right so now so the
standard library allows you to require
time are be active support in rails 3
point 0 allows you to require active
support corex time that are be so you
can now start actually requiring just
the pieces you want so you can treat
actress for like an extender standard
library and everyone can stop rebuilding
active support right this is actually
bad if there's a bug in active support
please help us fix the bug it's actually
really problematic to have multiple
entire core extension libraries loaded
in people's processes just because you
didn't think you liked active support so
you built an entire replacement I can't
really complain because I'm one of the
people that built a replacement so i
think i think that's fine i can't it's
not something i get to complain about
except to say that from here on out that
should stop being the way it is data
mapper is going to be using active
support in future versions obviously
requiring just the pieces that it needs
and that's how that's what you should do
and you should just it's ok to have
access board installed in your system
and it's okay to say require active
support core xed time RV that's an okay
thing to do now we're also being very
careful about cross pollution like time
RB does not require arbitrary random
insanity some more just some interesting
things before i close performance I just
worked for the past couple of weeks on
performance and here is basically the
results
these are index action rendering a
template rendering a partial rendering
ten partials rendering ten collection a
collection of ten partials the little
blue square is rails 3 microseconds and
the green one is rails 2.3 microseconds
the rails 23 is the full bar including
the blue part so yeah we were a lot
faster now this many times faster that's
overhead of course it doesn't mean your
app will be five times faster means that
the overhead of going and calling a
template is pretty cheap compared
compare of Lee the thing is that it
actually matters so a lot of people say
like oh that's over at once you pull in
like your real app that's not going to
really matter anymore if you look at
stuff like rendering a collection of 100
partials you start to see that like
rails three rails 2.3 takes a nine
millisecond surrender a collection of
andhra partials compared to two
milliseconds to render 100 partials in
rails 38.3 milliseconds to render a
collection of 100 or 0.8 so you start to
get into actual real time once you start
rendering big collections and so II I
know some people on the rails core team
don't like you to say like we're like 10
times faster they're like 10 times what
is that like 10 microseconds instead of
one and to some degree that's what's
going on here but to another degree it
makes it actually viable to use
collections one of the things that I've
worked on is in rails 2.3 renting a
collection of 100 items is basically
like random 100 partials but actually
you don't need to do that because
there's a lot of information that's the
same like the actual template is the
same every time you'll have to go look
it up every time you already know what
the name of the variable is that you
should be setting it's the same one it's
the partial name every single time so we
don't in rails 2.3 all that stuff is
looked up every single time you go get
the partial name again you go reset it
into the hash this is stuff that gets
cash and now the actual loop of a
collection is very small so it's just
actually rendering the template a lot of
times instead of a whole bunch of other
overhead so we can actually do this
stuff from rails 3 in part because of
much simplified code paths but the
bottom line is that if you're doing a
lot of rendering do that overhead you
probably may have you may have already
noticed actually starts to kill you I
know people have actually pulled things
out of partials and
them back into the regular part of their
template because the overhead was just
too high again a lot of people dispute
that they're like well it's what are we
talking about here a few microseconds
the truth is that there is a lot of
overhead in rails 3 l's 23 that is now
eliminated rubygems people don't
understand this problem so I'm going to
explain it so that you can all go home
and tell your friends what the problem
is we're also fixing it but nobody
understands it so I'm just going to show
you a picture of it so here i have an
app it has two requirements rails 2.3
and activemerchant okay i have in my
system act to support 2.3 and active
sport 3-point oh I go and recall an
activate active active merchant
activemerchant says I want active
support greater equal to 2.3 I have
access for three-point oh hooray gets
activated then I go and activate rails
2.3 that requires access port two point
three tries to require it big boom you
get this exception which you probably
have seen in real life more than once
can activate whatever already activated
something else so the problem here is
that we're doing it linearly and the
order that you do it actually matters
one workaround just to do it in a
different order figure out what the
right order is doing in that order that
works the right solution is to have
another thing that all the dependencies
feed into that go and figure out ah you
actually want to export 2.3 right then
you require it works this doesn't solve
general conflicts you actually have
conflicting gems we can't solve this
problem for you but if you have multiple
gems that just have sort of vague ranges
and there is a subset of those ranges
that actually works we are we can
provide that little circle that you feed
the gems into and we've written some
code that does that and that will be in
rails to trails three second of all
bundling right now there's some there's
freezing code it's pretty naive works
well for a lot of people one of the
biggest problems with it is that it
requires you to actually boot up rails
to go collect the dependencies that
basically means that you may have a
require line in there and it actually
expects the dependency to be there but
we're just in collecting phase so out of
luck but there's a lot of other problems
like you have network dependencies on
actually Ruby forage at deploy time
doesn't matter most of the time but when
it
matters because Ruby forges down that
really sucks so the solution is to do
what a lot of other languages do which
is just to actually stick the gems in
your application so just like in Java
you stick a lot of jars in there what we
don't want you to have to do is actually
copy the gems manually like you have to
do in Java like I'm gonna put the jar in
here we want you to be able to specify
your dependencies and we handle that for
you but what we want is we want you to
be able to take have an application that
has everything in it what do you gain
from this you gain the fact that you
have no deployment dependencies you have
the actual dependencies gems in your
application you can't accidentally have
a situation where your dependency was a
little loose and somebody released a new
version to Ruby for it since the last
time we checked suddenly you have a
newer version that gets that gets
deployed even though you just checked it
on staging like oh my god what just
happened here consistent environment
that means consistent environment in
staging and production but also
consistent environment between your
application on my machine and somebody
else's application on their machine
right there's a dot gem file that has
the right stuff in it and native gems
because now basically what we've got is
we store the gem in your system but when
you go to deploy an application or
installing our new system we can then
expand out the gems into their full non
freeze dried form so native gems work
fine you just run a task and that task
expands out the gems that are in your
system there are gems this will not work
for like if you have a route JRuby app
that has our magic for java and on your
you know developing on MRI where you use
our magic for see obviously we can't do
anything about that but that's really
not a common case right the common case
is you just have i'm using OS X here and
i'm using linux there and i cant bundle
the dot bundle file cuz doesn't mean
anything on linux i have to actually go
and have to go and expand it so this sis
solution handles native gems just fine
and it also allows for seamless upgrade
so you have a bunch of gems that you say
you want let's say you say i want any
version of active merchant so you can
just basically run a task that will
check if there's a new version of active
merchant go get go download it it'll
also resolve all the dependencies so
it'll make sure that if there's
dependencies that don't work anymore
with a new version it all works so what
I talked about a few slides ago the
result
that allows you to give a bunch of
dependencies and give you back a set
this also works throne upgrades and
that's pretty much so that that feature
the having actually good gem bundling is
going to be there in rails 3 it's
already available right now under why
cats / bundler on github and it's a
bundler gem that you can install from
Ruby Forge right now I think it's called
gem bundler maybe just bundler I'm not a
hundred percent sure but it'll run it's
basically you create a gem file which
specifies what what gems you want and
then you run gem space bundle I don't
remember the the readme has a lot of
details but it works fine in regular
applications that are not necessarily
rails applications so it's a project
that exists that allows you to bundle
things into your application deploy them
expand dated gems and all this stuff yes
it doesn't it works on reels works
similar real it would it will work on
rails 23 but it required Carl and I had
to write a bunch of hacks into it
because rails 2.3 actually overrides
rubygems pretty extensively so we had to
pretend harder to be regimes than we had
previously pretended so it will work
fine Arielle's 2.3 and Carlton Carl's
coming back from vacation on Monday and
we should be having like a blog post
that explains how you'd want to use it
it also means that the framework like
rails when it's bundled into your
application which you should do for the
same reasons and network dependencies
and consistent environment that you do
if you bundle rails it's just another
bundle gem which means it can happily
enlist in the dependency resolution
stuff so now you have act as support
acts towards just another bundle gem
activemerchant will know about it it's
not like a separate place and we're
adding over the next couple of weeks the
ability to use like a git repo with a
directory and tell it this game repo
this directory should put like you
should think it's this gem so you can
specify get repo'd directory it'll
download it check it out put it in the
same place as the normal bundle inside
your application and then it'll
correctly during like your other gems
that depend on that gem that you told it
to pretend to be will do the right thing
well know that it's already installed
okay core principles of rails 3 number
one is granularity so rails 2.3 for
instance people you know people used to
complain like I can't use data mapper
and the rails core team said it's Ruby
what's the problem just like required
data mapper that's fine but the problem
is that requiring data mapper throwing
out active record men throwing out a lot
so pretty much everything I showed is
about allowing you to selectively opt-in
if you have a very performance intensive
application or weird application opting
into just the features you want without
having to opt in and out of the whole
rails basically or entire huge chunks of
it instead of making instead of making
the default opt out so in rails 2.3 you
can say like you figure that frameworks
minus equals active record that API will
still exist but there's no real obvious
way to say i want to start from zero and
start building up rails-to-trails 3 is
built on top of an opt-in approach so
it's still the API still works exactly
the same Israel's 23 but it's built
internally in terms of opt-in which
means that if you want to build your own
slightly different version of rails it's
very easy to you know opt into something
or not opt into something else so it's
it flips around the paradigm for how
rails is built internally dogfooding we
don't want to provide api's that are
just like here's an API you should
probably use and we'll try to maintain
it over time probably the biggest
problem with action mailer is that it
got forked off of action trailer and a
long time ago and then we constantly
have to throw in you know here's a
layouts we'll just copy and paste it
like layouts and written layouts and
helpers stuff are actually copied and
pasted into action mailer and then
slightly modify it because basically a
fork so getting to the point where we're
actually using all the extension points
that we're expecting you to use is
pretty huge and prevents that sort of
thing from happening in the future
because we're building up the same way
that we extensions will build up and
finally you make step away from this
thing oh my god the rails I know and
love is gone because now you have to
make all these decisions and often we
have as strong if not a stronger focus
on conventionality the only difference
is that conventionality extends from the
user experience you can still do gem
install rails generated rails app
everything works fine exactly the same
as a working rails 2.3 that
conventionality extends into the
so there is a convention for how a model
should behave in order to get rails to
work that convention doesn't care if
your active record most people will use
active record that will work fine that
will continue to work fine everything
will be great but it's not just active
record is the convention it's active
record is the convention because it
implements the act of model API so
basically combination of dogfooding and
getting the conventions into the
internals means that you are actually
able to build your own applications in a
way that respects what we love about
rails which is that it really focuses on
conventionality and not you know get not
lose all of it so thank you and I'll
take any questions people have yes sir
ma'am
so I think the question was does this
also mean you can use like router the
router and migrations separately I can't
speak for migrations although if it's
not true and rails 3 it'll be true in 31
but a lot of the parts of rails that
people would want to use separately are
actually being spun off a separate
project so the router is probably going
to be you can go to get up right now
there's a project called rackmount which
is under josh peak and that's going to
be basically vendor din rail so there's
going to be a bunch of projects that
actually like the bundler that are
designed to be used separately and
happen to be used in rails and so to the
extent that a prop that something
doesn't need to be part of rails and in
order to be you separately we're doing
that there's a little bit of scare of
what if like what if josh releases a new
version of rackmount and some other
thing depends on it that wants to be
inside of rails and that's subtle
because it could happen like
accidentally could happen where like I
depend on a new thing and someone's
still using an old version of rails so I
thought that I would be able to use the
new version of rackmount but it I
actually can't so because one of the
problems of the new week with an
ecosystem where there's a lot of gems
out there is that you could end up with
you could things are not synced right
we're not releasing every single gem
that is used in rails together so you
could end up with conflicts that are not
not thought of in events part of what
we're gonna be doing is to the extent
that something like spun out of rails
like rackmount we're going to be sinking
them actual relation is going to be
synced but there's definitely going to
be issues with that and we're gonna have
to work through it I think we're going
to try really really hard to make sure
that there are known versions of all
these things that work with rails and we
work with the community to not be
depending on weird versions so don't
depend on a newer version of the bundler
if you expect it to work on rails 2.3
right just don't do it but the answer is
yes in general the point is to be able
to use any piece of rails that you want
that make sense using isolation in
isolation the dispatcher the router
pieces the controller rendering
subsystem templates all that should be
able to be used separately I personally
consider it a bug if you can't so if you
want to use something isolation and it's
impossible I would think that there
would be I would consider that a bug
yes sir who uses a specific version of
rails and so I migrated to rails 3 in
stolen relics two not three I assume
that means my so I don't know but maybe
the guys in the back of the room on ey
cloud can tell me I think they probably
allow you to use any version of rails
yeah so I in general though this is a
problem Ryu rails 3-pointer works
differently than rails 2.3 so it's a
similar to upgrading any version I don't
think there's any reputable rails
hosting provider that requires you to be
on a specific version of rails though
that's it's simply a matter of getting
your app and shape is that incorrect and
anyone know of a reputable hosting
provider that requires you to be on a
specific version of rails I don't think
so maybe any other questions yes sir no
okay that was intentionally super close
are you thinking that there are no but
I'll find out tonight all right sir so
real right now rails three edge and
JRuby are not in the CI we're working on
that and it's certainly possible um I
know that I run benchmarks against jruby
so I had like I have some stuff I
tweeted recently so at least like rails
boots and simple things happen I just
don't know there may be parts of its own
and we're actually working on CI so yes
a little number about memory usage I'm
wondering if you have any other numbers
that you can share with you benchmark
sure so one of the problems that i had i
wanted i did those numbers a few months
in a few weeks ago rather and i wanted
to show memory usage for the controller
the problem is that once controllers are
only useful in the context of servers
and once you once you boot it put in
mongrel or thin or something it's
completed so you get to 15 megabytes or
something like that which is actually
better than reals 2.3 but it stops being
particularly cool for us like 15
megabytes doesn't sound as cool as three
and it's it's not our overhead and it's
very hard for me to measure our over it
because our overhead is you have to
remove longer oh I could try to boot up
a rails app like spin up a rails app
without the server and see what it looks
like but I felt like that would be
disingenuous so I it was just hard for
me to come up with numbers that would be
useful I can tell you that once if you
boot up mongrel with a simple rails app
it's like 15 megabytes of RAM and should
be better on like passenger or something
which doesn't require you having HTTP
server in your process other questions
yes so it runs on right now runs fine on
every version we used to support i think
which used to be 1.2 1.4 1.5 1.6 and
then whatever came after that pretty
sure we're deprecating 1.2 1.4 11.8
point to one point eight point four one
point eight point five i'm still very
curious if anyone to tell me what was
wrong with one point eight point three i
would love to know but i wasn't really
around at the time so i don't know but
at the very least you're going to
require 186 we're thinking about whether
or not we should specifically say we
don't want to support 187 part of that
is just that there are things we use
that are backward from 19 and 187 that
are just very slow in 1 186 and the
other thing is whether we want to handle
bugs that are basically 186 bugs so
there are some like the wrexham l
security fix we kind of want to delete
it it's fixing 187 we want to just tell
people like you actually need 187 be it
would be somewhat controversial to do
that though so
we're talking we're not sure and we
certainly the numbers that I showed you
there were 19 numbers the performance
numbers 18 doesn't do as well 18 is like
twice as fast for those numbers instead
of like four or five times and a lot of
that has to do with garbage collection
like the techniques i'm using generate
more garbage for caching and hashes and
instance variables which are basically
cash primitives don't work as well 186
so we probably will recommend to people
that they should use 19 just because
it's much like that it handles
optimization better so jruby has similar
properties like JRuby and 19 have good
optimized ability properties where like
if I actually cash something into a hash
it's um it's actually faster in 186 it's
sometimes not and depending on like how
expensive the underlying operation was
so at least I will personally recommend
that people use 19 if possible and I
posted a while back on my blog like why
are people not on 19 and got a lot of
good answers I think we as a community
should push harder simply because of
performance performance characteristics
just so much better that we're actually
hurting ourselves I mean we're lit it's
literally like a couple times faster and
so rails to is like twice as fast rails
3 is gonna be like a few times faster on
19 and be going out there and having to
deal with people saying like oh my god
rails are so slow because they're
running on 18 is kind of bad so I would
like to be able to compare rails against
like groovy and grails or whatever on
fast versions and so I would like people
to use 19 and I for your own good you
should probably be using it because it's
fast and has better memory
characteristics yes
you can run 23 on 19 right now there are
some a few known issues with the
underlying drivers so I think my seat
that my sequel driver is fixed out and
the postgres driver but there were some
encoding problems in it and I think
memcache may have had similar problems
that are fixed Ruby debug for a while
didn't work on 19 I think something was
released recently so there's the story
for actually getting on 19 until like a
month ago was really murky I think a lot
of that is better now I think I think my
post actually spur people on to like
figure out whether or not what was
broken was actually broken and a lot of
it wasn't and getting the story straight
what happened so if you find that 19 is
difficult it's probably the right thing
to do is be very public about it like I
try to use 19 and encoding didn't work
that's like the most common problem is
you ask e+ utf-8 explode so if there's
still something returning a ski wear if
rails is still getting a ski from some
driver that's expecting utf-8 that
shouldn't happen anymore like we've
heart we've said unknown encoding equals
utf-8 inside of rails now and most of
the drivers return something useful but
it could happen and so the best thing
for 19 is not I think a lot of people in
the passive try to use 19 fellow didn't
work and instead of like being yelling
about it they just said I'm giving off
from we're back 26 I think that's valid
was valid now the right thing to do is
to write a angry blog post about what
didn't work so that the person is
maintaining the thing that doesn't work
and get it working there's also is it 19
calm which tells you whether a gem is
supposed like known to work on 100 on so
I don't know the odd thing is that a two
months ago I was very skeptical about 19
and a combination of performance and
things seeming to come together makes me
really optimistic about 19 and I I just
what I don't like is having to deal with
objections to Ruby that are based on
like 10 year old technology right we
actually have better technology like
people say like you can't compile Ruby
right but yah Rev actually is byte code
compiled Ruby people say a lot of things
about Ruby that's
true about 19 or JRuby so I would like
to put the 10 year old technology behind
us so I could stop having to deal with
people arguing about the actual way that
the old technology worked
I'm glad that wasn't the first question
I'm glad that wasn't the first question
but I'll try to answer it so the
question is is there a good time line
for one rails three is gonna be released
answer is no but I'll try to give you a
good as good of an answer as I can we're
actually making very good progress I
think what there's a few small agenda
items left before we can cut a release I
think to some degree we want to have a
release that has stable api's because
we're kind of telling people that that's
going to work so we don't want to have a
release where some of the api's are
rough edges and we have to do it again
in 31 that would be bad so we're getting
to the point where we can really start
making that our highest priority focus
right now our highest priority focus is
finishing 30 soon our highest priority
focus is going to be locking down with
the 30 API actually looks like most of
the google Summer of Code projects that
have been worked on are merged in so
specifically the generators for a big
project emerged in we'll know pretty
soon whether the active record work will
be able to be merged in that's a pretty
big deal so yes or no will happen soon
action mailer still needs to be rebuilt
on top of action controller the new
abstract controller stuff but the bottom
line is that we're actually getting
pretty close to the point where we're
just working on getting plugins working
and there will be a beta period where
plugins are going to be encouraged to
get themselves onto rails 3 and once we
feel like enough plugins are working on
rails 3 will have an RC so I don't want
I don't want to give a timeline because
though there are contingent facts
they're continuing things that have to
happen in order for us to go comfortable
with it but there I can tell you that
the things that are in our control which
are rails 3 having a pretty stable API
and being both basically done is closed
and the things that are not in our
control like plugins actually working on
30 are things you can help with so if
it's not like you're writing code it's
just like harassing the people who have
the plugins we want to make sure like
the top 30 popular plugins work on rails
3 before we pull the trigger for the RC
so either help yourself or harass people
but
that's the timeline um we're talking
like months not years so other questions
ok I think there aren't any so that
means I'm done thank you very much
everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>