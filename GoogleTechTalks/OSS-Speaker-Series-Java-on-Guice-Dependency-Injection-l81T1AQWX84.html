<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OSS Speaker Series - Java on Guice: Dependency Injection,... | Coder Coacher - Coaching Coders</title><meta content="OSS Speaker Series - Java on Guice: Dependency Injection,... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>OSS Speaker Series - Java on Guice: Dependency Injection,...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l81T1AQWX84" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone welcome to the open source
developers at Google speaker series my
name is Kevin Burrell ian and bob lee
and i built this framework called juice
by which I mean Bob did most of it and I
helped and so it's my pleasure to
introduce Bob to you who's going to talk
about the Jews dependency injection
framework and that's about it lovely is
this thing on can everybody hear me ok
ok I started it but Kevin made it what
it is today so today I'm going to tell
you about juice I'm gonna start off
telling you about dependency injection
in general and we're going to get into
how you can use juice to make dependency
injection even easier why are we here
why are we even interested in dependency
injection and juice specifically the
main reason is to make unit testing easy
easier so makes a unit test easier to
write less friction kind of a secondary
reason is you can use this to get some
more decoupling in your code if you want
to break down your code into compile
time independent modules juice not
necessarily dependency injection in
general juice can help you write less
boilerplate code which I personally love
I mean a lot of times we write this same
code over and over again we re implement
these same design patterns without even
realizing we're doing it our eyes it's
kind of glazed over and we don't see the
code anymore and then I guess kind of
the overarching theme here is going to
be getting better maintainability so
juice was built for what I consider a
huge project millions of lines hundreds
of mott developers code going back as
long as and longer than five years so
maintain abilities of the utmost concern
I mean you write the code once people
read it thousands of times the way I
like to explain dependency injection and
pretty much any programming topic is
through code examples so we're gonna I'm
going to start off with a very simple
example unbelievably simple but just
enough to kind of illustrate the
concepts this is going to be a
high-level designed for our example
we're going to have these are this is
just kind of like a class diagram
we have the kind of central concept that
central thing we're going to be worrying
about through this example is a class
will call client could be anything and
we're going to be testing client as you
can see by we have our client test over
here and clients going to have a
dependency on an interface will call
service and we'll have one
implementation of service which will
call service simple pretty simple we
don't really care what these things do
we just care that about the fact that we
have a dependency I'm going to take
three approaches whenever we're three
approaches to solving this problem the
first one I'm going to start off with
it's something where I'm sure
everybody's familiar with the factory
pattern the second one i'm going to show
you is dependency injection by hand
dependency injection is this kind of a
variation of the factory pattern the way
i look at it you don't necessarily need
a framework and the third example is
going to be dependency injection with
juice i'm going to show you how juice
benefits you over doing dependency
injection by hand and for those of you
that don't know what dependency
injection is you're going to find out
and for those of you that do i promise
you won't be too bored because it's kind
of fun to take a step back and examine
what we know and identify exactly where
and how and how much dependency
injection helps your code so throughout
this example well as we go down these
three paths we're going to have one
variable and that's going to be one
thing that's going to change that's
going to be how client gets access to an
instance of service and then a couple
things are going to stay the same we're
going to have like I said we have this
service interface we're going to have a
single implementation of service we
don't really care what this interface
looks like or what the implementation
does for the purposes of this purpose is
of this example but let's just assume
that it's something expensive or
something we don't want to do during
tests right like it could be like
charging a credit card we don't want to
charge a credit card or send off emails
during our unit tests right so within
that respect we're going to have a mock
implementation of service that we can
swap in for unit tests and that's pretty
much what we're going to do so the first
approach we're going to take a look at
is using the factory pattern so here's
our implementation a client like I said
this is stupid simple and the way client
gets access to a fat
service using this approach is via a
service factory and in this case we're
just kinda like a static we're just
going to call out to a static method and
we'll call that our factory method and
then client does what it needs to do
with service and to support this we need
to write this service factory and this
is kind of what I was talking about when
I mentioned boilerplate code we all
right this same factory code over and
over again we have to make this upfront
decision whether we just want to new up
an instance of service and defend
directly on the concrete class or
whether we want to go through the pain
of the coupling client from service
using factory in this case I just wrote
the code to implement a singleton I mean
I'm sure we all follows pattern hundreds
of times you know you might write some
lazy loading code or you know if this
wasn't a singleton you this code might
be a little more complex and so as you
can see here we have this is the client
that this is the method that the client
used we have this kid instance method
this is what clients used to get access
to our service and I guess the main
point of this is that client doesn't
depend directly on the service
implementation anymore at least he
doesn't seem too so all client knows
about his service it doesn't know about
the actual concrete implementation and
then if we want to be able to test this
thing or test things that run against
sir this service factory we need to be
able to swap in an alternate
implementation so that's what this final
method this set instance method down
here allows us to do so this is the
thing we're going to be most interested
in throughout these examples and that's
the unit test so as you can see in this
unit test we so let's look at the middle
part first we're creating a mock
instance of service and we're passing
that into the factory then we're running
client and then we're testing that
client did what we expected it to do and
this kind of like outside stuff up here
is us kind of saving off the previous
state of the factory and then restoring
it at the end and does anybody know why
we do that why we have to restore the
factory to its previous state at the end
of our test
there you go so you don't break other
tests and by that we mean many of us
have run into that situation where you
run your tests in one order and they all
pass or you run your tests in a
different order and they fail because
maybe a test that rain after this picks
up our mock implementation well that's
not the case since we're cleaning up in
a finally block I'm sorry so you just
made another great point what if we have
a test running concurrently on another
thread yes these two tests would step on
each other that's another reason the
factory pattern sex um so I already
pointed out that so what are the
consequences or the observations that we
can make about using the factory pattern
here I already pointed out that we have
to kind of set up and make sure we clean
up at the end and if we forget to clean
up once then we can get mysterious test
failures and those are really hard to
track down one of the things that kind
of strikes me is that when we're setting
out to test client well in this case
it's simple then it's it's easy to know
that we need to swap in an
implementation of service because the
client implementations so simple but
it's not always that simple right you
know it's our dependency on service
might have been nested like ten levels
deep at our implementation and we'd have
no way of really knowing that we needed
to swap that in and I guess kind of the
consequence of that is you end up having
slow unit tests because you have random
code out accessing remote servers and
slowing things down hitting databases
and that sort of thing and it's really
hard to track those things down and so I
guess the crux of that is the only way
we can know from our test that client
depends on service is by digging through
the implementation reusing client
different contexts is difficult so as
someone pointed out using it from
different threads we can't we can't use
different service implementations from
two different threats or if we want to
just put that if we want to pass in a
different service implementation to
client and one part of our application
and different one into the other one
it's really tricky we have to
I already pointed out that we have to
write that same factory code for every
dependency and that's a huge pain it
forces us to make this upfront decision
whether we want to be tightly coupled or
loosely coupled and a lot of times the
thing i don't like about that is that we
make that we make the decision based on
the wrong reasons you know we make it
based on effort when we should make it
based on whether we want this to be
tightly coupled or loosely coupled and
finally we decoupled client from service
in pull directly but the way this is set
up is client still depends on service
simple at compile time because client
depends on service factory and service
factory depends on service simple so we
need to compile everything together and
we could kind of alleviate that using
the service locator pattern or something
like that but the service locator
pattern has its own problems like for
example if we were specifying the
implementation service and a properties
file or in an XML file well with a lot
of service locator implementations we
wouldn't know whether we configured that
service that implementation properly
until we want to actually use it and
that's too late for most times
considering you have to have like one
hundred percent covered test coverage so
now let's look at how things change when
we follow dependency injection by hand
so if you remember in the last example
client just called out to service
factory well in this example instead of
calling out somewhere to get its
dependency client is going to have its
dependency provided to it and in this
case we're going to provide service to
the client through its constructor and
then client just hold on to that
dependency and use it as needed and this
is what we call dependency injection
that's all that's it it's as simple as
this a lot of people refer to it as
don't call me I'll call you so what does
this do for us well this is the same
unit test we just looked at a couple
minutes ago based on the factory design
pattern and as you can see we have to
set up we have to save off the previous
implementation and do all this setup and
teardown which really sucks well if we
have this implementation a client where
we can just pass any service to the
constructor we can simplify our test
considerably we can get rid of all that
code
we can get rid of this kind of
dependency on a third party our tests no
longer worries about about service
factory it doesn't have to this makes
the dependency explicit from our test to
you can't even create a client without
providing a service right so we're not
going to pass enough slow service in our
unit test we're gonna pass on a mac
version so really this cuts the test
down to like the minimal amount possible
the minimal amount necessary and this
reduces the amount of the amount of
friction to writing unit tests so people
are going to do it more often people
going to have less problems tests are
more readable so now in the production
code how does client get a an instance
of service and the answer to that is
like I said in the beginning of the talk
I see the dependency injection pattern
is just kind of a variation of the
factory pattern so as we'll see here as
we can see here we just introduced this
client factory so now we have that we
already have the service factory but now
we have the client factory and instead
of creating client directly in our
production code we go through the client
factory and now just it's really simple
instead of client depending directly on
the factory we just move the dependency
on the factory up into our factory des a
factory enough times so the idea here is
that we can have all these nice
dependency injected business objects
that are easy to test and then on a
layer above that we can have all these
factories and the factories depend on
each other and they depend on our nice
business objects but the important thing
is our business objects are easy to test
and that's what dependency injection
does for you so compared to the factory
pattern the test is a lot simpler we
don't have to deal with middlemen in
this case service factory anymore we
it's painfully clear that client depends
on service it's it's kind of a we can
tell that information directly from the
API now we don't have to deal God crawl
down into the implementation anymore we
can use client in multiple different
contexts somebody mentioned using client
with different service implementations
and multiple threats that's trivial to
do now right I mean we could just new up
a client pet so that its own service
instance or service implementation
instance this is a really big one this
was one of the reasons i originally
created juice client no longer depends
on service in pull at compile time so we
can actually have compile or client in a
separate compile time unit from server
simple so if i wanted to just check out
client and compile it and run some unit
tests against it I could do do that
right so I could take like a big
monolithic multi-million line app and
break it down into separate compile time
units just kind of and then just run
these faster unit tests on those and
then when it comes time to like later on
in the development process I can do
those bigger slower integration tests
but the important part is i get this
quick development turnaround time
upfront a kind of the downside to do in
dependency injection by hand is we have
to write even more factories as you saw
here we had to even introduce a factory
where we didn't need one before and that
means we have to write even more
boilerplate code even though it's not
quite very much so this final approach
we're going to look at is how we can
take this dependency injection example
and implement it using juice so why
would we want to do this as I already
said writing factories is tedious with
these simple Singleton's that we've been
writing I mean it doesn't seem so bad
but it's I mean it's still pretty bad
you could generate that code right but
as you get into dealing with scoping and
that sort of thing you know it's like
okay I don't want this to be a singleton
anymore I want to return a new instance
every time or I want to return the
instance from the HD HTTP session or I
want to return an instance from a
threadlocal you know it's like you got
to write that same boilerplate code over
and over again we want more upfront type
checking so when our application boots
up if we forget to kind of configure a
dependency we want to know about that
right away as soon as possible which you
don't get if you're trying to use
something like the service locator
pattern we want more flexibility so
part we want to be able to I guess how
do I say do more stuff kind of like
analogous to be able to do reflection in
Java we want to be able to define
dependencies automatically and that sort
of thing so we can cut down coat and do
some more dynamic things and this is
kind of this last point is one of the
biggest things for me is we want to make
it easy to do the right thing I mean we
can't we could see the benefits of doing
dependency injection by hand but the
truth is if your developers don't really
kind of get or buy into dependency
injection I mean it's kind of hard to
stick with you know the easier thing to
do is just to kind of hard code the
dependency in your code right it's not
easy to remember to limit your
dependencies to the factory level it's
it's not it's hard to remember to
abstract that stuff out well with using
a framework one of the things you'll see
is it's easiest to have things injected
it's almost just as easy to have things
injected as it is to just knew it up in
your code so instead of having these
factory classes in juice and service
factory and client factory all that
boilerplate code in juice you configure
things declaratively so instead of
having service factory and juice I just
have this I implement this interface
called module and this is how i
configure juice and I I can use this
what we call a domain-specific language
to communicate with juice and all that
basically means is that we have this
kind of like nice little English spoken
language sort of thing the that's that's
very readable and so in this case we
want to tell juice that whenever you see
somebody that needs service we want to
give them a service simple and we want
it to be a singleton so the way you do
that is you say bind service to service
imple in scopes that singleton so we're
saying bye into the service interface to
service simple and make it a singleton
and this replaces all the factory code
we just had so client changes just a
little bit from our previous approach we
have to tell juice where we want things
to be injected and
that when we were doing this stuff by
hand we knew and we call we did the
injection manually but now we have to be
able to tell juice where to inject
things so in the way you do that is you
use a net inject a notation and you can
place that on constructors methods or
fields in this case we're injecting
constructor so this inject annotation
tells juice okay when you knew me up an
instance a client when you create an
instance a client pass me and
implementation of service and juice got
juice looks at our module that we
configure and it says oh hey client
needs a service well I'm going to go get
him a service simple and I'm going to
reuse this same instance every time yes
he asked if juice only supports one
argument or multiple arguments and the
answer is juice support supports
multiple arguments so an ordering
doesn't matter because it matches things
based on type it looks at service it
doesn't care work whether it's the first
argument or the third argument it's
always going to bind to the same thing
so our test looks exactly the same as
when we're doing dependency injection by
hand and this was kind of our end goal
we want to make unit testing easy I
guess kind of the one thing to notice
here is that we don't use juice in the
units we don't need to we don't need
that complexity the simplest possible
thing is just create our mock can pass
it directly to client right so
conclusions based on this simple
unrealistic example even in this little
example juice melted away like twenty
percent of the boilerplate code and
that's over the initial example with a
more concise example because we didn't
have to write all that factory code and
one of the really nice things about
juice especially compared to other
frameworks and this approach to using of
using annotations for dependency
injection is that we already saved that
twenty percent in this little example
but we're juice really shines is the
more you use your dependencies so you're
not going to go to all this effort just
to use a dependency once right I mean
some dependencies we use hundreds and
hundreds of times so but each of those
times now the only thing you have to do
is put at inject on your
and take service so you don't have to go
and set up the module anymore or
anything like that so a lot of times
you're dependent if in a application
your dependencies are already set up so
you don't have to worry about it so much
we get more startup checks over using a
service locator so one of the things
that's really nice about juice in
particular is kind of the quality of its
error messages so if you're missing if
you're missing a dependency like for
example if we didn't bind something to
service juice would fail right away it
start up before running any of your code
and it would tell you that client
depends on service and it would even
give you the line number so your IDE can
link it in your log and you can click
and jump right to it jus supports this
notion of declarative scopes and what I
mean by that is remember in our binding
we said okay this is in singleton scope
we only want one instance of this for
our application and you can implement
your own scopes using juice it already
comes with scopes for handling servlet
code which will we'll get into that a
little more we have a lot of flexibility
here so you could imagine that I mean
we're this is just a Java API so you can
write special code to create your
bindings however you want right you
could loop through a list of interfaces
and automatically create bindings for
all those right imagine like your data
access objects if you're able to if you
just had data access object interfaces
and you're able to generate hibernating
implementations for those some people do
this sort of thing and I guess like my
favorite part is just this makes that
gives us makes for easier up front
design decisions whereas before we had
to decide whether we wanted to new up
the class directly and have this
concrete concrete dependency or if we
wanted to write all this factory code
well now it's just as easy to just have
the concrete class injected to begin
with so it's like so client depends on
service we could start off with service
just being a concrete class to begin
with and client doesn't care right it
doesn't care if it's an interface or
concrete class then when we come by
later and decide to abstract out an
interface from service well we just do
that and client doesn't have to change
so we changed we make our change in one
place and none of the clients have to
change so that's it makes it easy to do
the right thing so now that we're all oh
we have another question feel free to
interrupt me at any time please um so
we'll actually we'll get into that right
now he he asked a question about a
inject so you're wondering how juice
knows to inject that or okay so this is
a I'm sorry about that I kind of jumped
ahead a little too much so he's asking
about this at inject here so one of the
main reasons i created juice when I did
I started a little over a year ago was
because Java five was had been around
and none of the other frameworks really
took advantage of that one of the things
that were introduced in Java five were
annotations and that's what this is this
is basically just kind of type safe
metadata that you can attach two methods
fields classes whatever you want and so
at runtime juice can look at this client
class and see that there's an inject a
notation on here and no to inject that
yes it's actually so he asked how this
compares to seen juice is actually
similar and a lot of ways to seem we're
going to see some ways where it's really
different seem is a great framework to
and I'm actually on a ASR called web
beans with Gavin king who created the
scene project and we're combining juice
and scene for web beans so we're gonna
it's actually there's happens to be very
little overlap between the two but you
need both the way we look at it so if
you're interested in this stuff and
you're interested in the future you
don't want to depend on a proprietary
framework right now then introduced you
to or I encourage you to keep an eye on
the web beans API but there's definitely
a lot of synergy between semen juice
right now I'm sorry about that I jumped
ahead too far so now that we're sold on
the virtues of dependency injection
going to show you how to get started
with juice and sold on juice so what is
a basic juice application look like we
looked at that simple example but we
kind of we left a little bit out it's
like how does juice create an incense a
client for us right well so that's what
we're going to look at right here I
guess kind of the central object in
juice it's called the injector this
other frameworks might call this like a
container or something like that but the
injector is what creates our objects and
so if we wanted to use juice to create
an instance of client we just ask juice
to create the injector we pass at our
module this is the same module from our
example you know the modulus says buying
service to serve a simple so we pass
juice the module and then it gives us
back an injector and you can pass it any
number of modules you want and the
modules can all be independent then we
take that injector and we ask juice we
say get instance of client class and
juice will give us an instance a client
it'll call that constructor inject
whatever client needs and give it back
to us in this case we didn't need an
explicit binding for client because
clients a concrete class and juice knows
how to create it if client was an inner
week also passed you said interface here
but we need to tell it what's bound to
that interface somewhere and then we can
just call in this case we just call
client go in a real world application
say this was like the command line
application this would be kind of like
our this would be our main method look
very much like this this was a web
application and you like to have a
direct control of your servlet container
you might have juice create your servlet
container and then call start on your
servlet container here there's also ways
to wire web applications that a little
more you just kind of drop them in and
use them so one thing I want to kind of
point out here is that what kind of
situation would we have if we always ask
the injector for our objects
we wouldn't have dependency injection
we'd have a service locator right which
is what we're trying to avoid so that's
where this idea of like to call this
bootstrapping so this is really the only
time that we're gonna ideally this is
the only time that we're going to deal
directly with injector is in this kind
of bootstrapping code right here and
this is kind of one of the things that
are really cool about dependency
injection and this was kind of like an
aha moment for me whenever I started
using it was so we used juice to create
in a sense a client and then juice
creates objects to inject into client
and then it juice has to create those
objects too and then so juice creates
objects to inject into those you kind of
have this recursive object graph that
juice can create well we only depend on
injector here we only ask it to create
client but from that root object juice
can construct our entire object graph
and then from our perspective all of our
code is nice clean and unit testable
right we have these nice you know
testable business objects that just
depend on interfaces and whatnot and
then we have these really simple modules
where we just kind of describe the
dependencies so juice gets rid of all
that boilerplate code makes things
easier to test and that's how it does it
so we asked if this means that our
entire object graph is created at
startup and the answer to that is no
juice does provide ways to delay object
creation and I'll definitely get into
that so you kind of lazily create
objects as you want to so Kevin be kind
of so the idea here is one thing I kind
of want you to note is that for an
object to be injected juice has to
create it right Kevin be calls us into
Club the objects have to be in the club
and so if you see new in your code
that's kind of bad so let's say we want
to introduce a new dependency based on
kind of like this idea is talking about
bootstrapping well let's say service we
want to add some emailing capabilities
to our server simple all we have to do
there is
first we have we have to create our
emailer and this could be in this case
we're just going to make email our
concrete class and in serve a simple we
can create a field for email or in this
case we're going to use field because
he's method or constructor injection and
we put at inject on that field so now
whenever juice goes to create an
instance a service simple so that it can
jected into client it's going to create
an instance of emailer and then inject
it into service simple so notice we
didn't have to deal with the injector at
all directly here so then service simple
at the end it's going to its so it's
going to do whatever it was doing before
and then is going to send a confirmation
at the end using the email or that we
injected so there's some situations
where so far what we've seen we've had
one implementation / type there's going
to be other situations where our
applications a little more complex we're
going to have multiple implementations
of the same type so hypothetically we
might have our regular email or and we
might have a transactional emailer and
why the heck would we want to
transactional you Miller well let's say
we're processing orders you don't want
your order to go through if you didn't
send the client or receipt right if you
know if you didn't validate the email
address and that sort of thing and you
don't want the receipt to go out if you
didn't actually process the order so
we're going to we're going to need a
transactional email or in this case this
is kind of one of the big innovations
juice dust compared to seem and some
other frameworks a lot of frameworks you
might have seen rely on string tokens to
identify the dependencies juice uses
this idea of binding annotations and so
in addition to saying at jecht emailer
well now we're going to say at inject at
transactional email and juice is going
to look at this and say oh you know you
need a transactional emailer and it's
the idea here is that the eat the thing
that's going to identify this dependency
is it's an emailer and it's
transactional so the way we can figure
this in our module is we say bind
emailer annotated with transactional to
transactional email or transactional
emailers our implementation everybody
follow that
so the transactional so yes if
transactional comes with juice and the
answer is no juice does come with some
by Nady annotations but you can just
define these things on your own you
don't have to create one every time you
have two implementations of something
your annotation your binding annotations
can be kind of general and reusable like
this is transactional we can use
transactional with an email or we can
use it with a service we can use it with
a database connection whatever right and
that's from our experience we find that
that's all from the case yep this is a
yes that this is an empty annotation and
yes this is like a marker annotation it
doesn't really in this case it's a mark
or annotation but in reality juice also
supports you can have attribute values
on these annotations to so that saves
you from having to create new
annotations all the time also like you
can have one a notation and you can kind
of get have like a string value and pass
it to it or that sort of thing so you
can reuse it that way so and this is
actually an example of that so in
addition to having multiple
implementations of the things sometimes
we need to get another question
does the name of the annotation does it
match the annotation class name um no so
he asked if the annotation class name
has to be the same as the implementation
class name Oh pointed out that i forgot
to see right here sorry about that so
yes this would have to be the same as
that okay and you'll get that's one of
the nice things about you so you'll get
a compile-time error actually you
wouldn't make that mistake because
you're a tu an autocomplete keynote
doesn't auto complete so sometimes so we
just looked at the example where you
have multiple concrete implementations
of a single interface well sometimes
you're dealing with third-party code
where you can't apply at inject or you
know you just have some code where it
wouldn't make sense and you need to
create these out or maybe you can't let
juice create the objects maybe they're
already created you don't have control
of that so you need to have some way of
you still want to be able to inject
these things into other classes right so
here's an example of that let's say we
couldn't that we couldn't let juice
create an instance of emailer and we
wanted to create it ourselves so that's
where juice provides this interface
called provider and all provider is a
simple interface with a get method that
returns an object it's as simple as that
and to tell juice that you want to write
a custom provider in this case we're
going to provide an instance of emailer
you just say bind emailer to provider
and you give it a provider of emailer
and kind of the nice thing about this is
that even though we can't inject email
or directly we can inject our provider
so we can inject our provider and in
this case we're going to inject the name
of the email host like the email server
name and then we can take those values
and pass them on to the class so the
interesting thing here is that service
info wouldn't have to change it doesn't
care whether juice is creating emailer
or whether
we are creating it manually in our
custom provider it doesn't matter it's
completely decoupled a couple things to
note here one more here's one thing that
scopes can still apply to your custom
providers so even though I want a email
or to be a singleton I still don't have
to write that boy i'll create plate code
in my custom factory right i can apply i
can still apply this same scope to my
cusin provider and then this gentleman
here asked about whether binding
annotations always had to be up mark or
interpretations and this is an example
of when it doesn't have to be juice
comes with this annotation called at
named and this is an annotation you can
use if you don't want to create a custom
annotation all the time if you just want
to kind of refer back and use string
names to identify your things and so you
can kind of see here will you add named
and then we just have emailed that host
so i kind of i touched on scopes i'm
just kind of go into a little more
detail on that the definition of a scope
is it's a policy for reusing objects by
default juice uses no scope for your
objects and that basically means that it
creates a new instance every time passes
in a new instance every time which makes
things very kind of keeps your object
separate and makes it next in object
oriented there's two ways to specify a
scope for a given binding kind of the my
preferred way is to use an annotation
that's this example down here so if we
wanted to tell juice that emailer is
always a singleton you can just put at
singleton on email and you can define
your own annotations like this for your
custom scope so if you were using juices
serve up module you could say at each
request scoped and that would tell juice
that you want it to be stored on the
request and just we just automatically
do that for you sometimes it doesn't
work like i said in cases where you have
like a custom provider and juice can't
doesn't create your classes or if it in
those cases you can specify the scope in
the module so even if email is a
concrete class like it is here you can
just say bind email or in session scope
and juice will do that for you
alright so somebody asks a little
earlier in the talk whether whenever we
do that initial bootstrapping is just
going to create all my objects and
construct my entire object graph and the
answer to that is no and it's for this
reason right here you can for any type
foo you can also inject a provider of
foo and this is just the same interface
just reused here the same interface we
used to provide objects to juice juice
is going to use to provide objects to us
so in this example I'm just instead of
injecting money directly injecting a
provider of money and as you can see
here we can call get and get two
instances from that provider instead of
heaven you know normally juice would
only inject one instance well in this
case we can get two instances out so
there's a few cases for using injecting
a provider instead of the object
directly and those cases are one if you
want to get multiple instances like this
you know normally juice only would
inject one instance directly a second
one is if you don't necessarily want to
create an object maybe you have multiple
dependencies that you may or may not
need and you don't want juice to be
creating all these objects that you're
not going to use so you can inject the
provider and then kind of like lazily
ask juice for that object only whip if
you need it and then the third reason is
a what what I kind of call transcending
scopes so you know sometimes you might
want to be able to access a request
scoped object from a session scoped
object right but session scope is bigger
so if you just injected a request scoped
object into a session scoped object well
you wouldn't you would hold on to that
object from the first request the entire
time right and you'd be out of scope of
the original request well so instead of
doing that you can inject a provider of
that object and then the session scoped
object can just ask it what it needs it
so and then a juice will behind the
scenes so we can just ask for it says it
can say provider get me this give me
this request scoped object and juice
will just dynamically in the background
look up the object from the current
request
I mentioned that juice supports
constructor method and field injection
let's kind of talk about the pros and
cons of beef my personal favorite is
constructor injection and it's because I
like to make everything immutable that
makes thread safety easy makes your code
nice and maintainable because you can
see right away that this field can't
change so you don't have to worry about
it anymore you know exactly what it's
going to what what its value is going to
be but there sometimes when constructor
injection won't work and that's when
method injection is a good is a good
option sometimes I've run into cases
where I don't want us where somebody
maybe extends my class and I don't want
them to know about might have to worry
about my dependencies and the reason for
that is as you know if you extend
somebody's class you have to call their
constructor right well if if they have
to call my constructor I think my
dependencies in the constructor well
that means my sub class has to be
responsible for past Mueller's
dependencies right and if I add a new
dependency I'm going to have to go
through and change all my sub classes
which is kind of contrary to what we're
trying to accomplish here we want to
kind of isolate changes so that's where
method injection is a good option juice
will just call like your setter method
or whatever you want your method can be
named whatever you want without the
subclass happen to be the wiser another
case where method injection is good are
these cases where juice can't create
your objects so maybe the object already
exists or it's a third-party object
something like that or what I guess this
one work in the third party situation
but if your object already exists and
you don't want juice to call your
constructor you can still ask juice to
inject your methods and fields obviously
can't inject the constructor after the
fact cuz it's already run and the final
case we have is a field field injection
and I find that that's good for custom
providers we saw that BEC here I used
field injection right here I mean we're
not really going to unit test this code
this code will get covered in our
integration test but we're not gonna
bother unit testing us so it's ok to use
field injection here and then the other
cases slides for your talk because it's
the most concise and takes a plus we
space
alright so I'm just going to talk about
some more features that we didn't get
too deeply into that you might want to
check out after the talk the first one
is type conversion for constants and so
this is where you might ask ok I'm hard
coding all this in Java you know I want
some of the configuration information to
be externalized you know like something
like spring or something like that it
would be like an XML file right and
you'll be able to change it without
recompiling well jus support step 2 and
a slightly different way we think you
should only externalize which what
should be externalized you should only
externalize the stuff that can actually
change right you know it makes things a
little more readable and keeps from
people from breaking your application
makes it more usable so juice has some
support for doing things like you can
slurp in an entire properties file and
juice will create bindings for every
property and the way does it is it
creates bindings to type string and it
uses that ain't at named annotation that
we saw already and it uses the property
name with that named annotation and so
this is then this is where the type
conversion comes in for these types of
values you don't necessarily just have
to inject string into your classes juice
can take that string from your
properties file and convert it to an int
convert it to a class convert it to an a
new moon in teresting one and what's
really interesting about this is that
juice does this all at startup because
you know juice can look at all your
classes and know that it depends on
these constants right and it converts
that value once its startup and if that
conversion fails juice blows up you know
and it says hey you know you this value
forgot to fail or failed to failed to
convert another feature that juice has
is I've been a big fan of aop in the
past but the truth is I even wrote an
AOP framework which was even one of the
simpler ones at the time the truth is
what do most people use aop for applying
transactions right you know so you just
put a transactional on your method and
it tells the framework that you want
that method to be run in a transaction
well juice has support for this sort of
thing and it uses the aop alliance api
which means you can take like Springs
transaction interceptor and use it
directly with juice so and you can just
apply at transactional your method and
just like spring just like ejb that map
that will be run in a transaction juice
introduces a new concept for I guess
kind of this class of framework it's
what we call development stages and so
one of things I noticed about other
frameworks were they make you specified
code in the configuration file whether
you wanted your objects to be your
single tends to be lazy loaded or not
right well to me it depends it's during
development I want all my Singleton's to
be lazy or as many of my Singleton's as
possible to be lazy loaded so that I'm
only initializing parts of the
application that I care about the parts
that I'm working on the parts that I
want to test so my server starts up as
fast as possible and I can do my testing
you know make some changes start it
again make some changes started again
whereas in production I want the exact
opposite I want all my Singleton's to be
eagerly initialized its start up so that
I know that whether there's any errors
whether I missing anything or whether
you know a single that's going to fail
to instantiate and so that client my
first clients that hit my server don't
pay the performance penalty right so you
get consistent performance so juice lets
you specify right now letís specified
development and production stages and it
does it has that behavior for
Singleton's like I just explained but it
also makes this information available if
it available to your modules so you can
write custom code based on whether
you're running in development production
so I'm going to kind of glaze over
optional injection we're not really that
worried about it's not something to use
that often but let's just say that a
juice will fail fast if you're missing a
dependency so that's one of the things I
kind of really like that makes it really
maintainable if you forget to define a
dependency you know juice is going to
tell you it's gonna make it very clear
juice also comes with integration out of
the box that comes with integration with
JD I pretty good integration with spring
the Java management extensions jmx and
struts to stretch to is kind of one of
the main reasons it that I created juice
I was working on stretch too whenever I
kind of came up with a lot of these
ideas
decided on what I want so juice comes
with a great struts to plug in you just
drop in your classpath and everybody
remembers or you might remember when I
was talking about bootstrapping before
well the struts two equivalent of
bootstrapping is that juice injects all
your actions so instead of whereas with
struts or web work or struts 2 instead
of your actions just having these no
argument constructors well now you can
take all your dependencies in your
constructors and actually make use of
your actions it makes your struts 2
applications a lot nicer he has someone
asked if if juice depends on all these
things and the answer is no so juice is
broken down into separate modules so you
can kind of take what you need the jndi
one is in the core juice because JD isin
the core jdk already but the spring one
is just a separate jar that you conclude
what if you want to use that same with
the struts to JM x is and the cords are
else's that's that's one of the kind of
philosophies and one of the things I'm
trying to do with juice I want to keep
it really simple and stick to for the
most part to pure dependency injection
and I want to provide the hooks and the
capability so that other people can
build third-party frameworks on top of
juice which people are already doing a
lot I mean there's already people
working on hibernate integration dynamic
web remoting integration you can if you
join the mailing list you'll see that
there's a lot of traffic a lot of people
working on different things give you a
little taste of some upcoming features
Kevin and I should be pushing another
release probably in the next couple
months one of the things that's kind of
annoyed me is we looked at that custom
provider even using an anonymous inner
class it's kind of a pain right it's
it's more code than we want to write you
don't really have to write that code all
the time that's probably like the maybe
less than five percent case where you
have to manually configure your objects
but in the next release we're going to
make that even easier you're gonna be
able to have one class with multiple and
where you can just have a bunch of
factory methods we call those provider
methods and you'll those methods will
take in their dependencies as parameters
and then they'll return the thing to be
injected as a result and
so that'll definitely they'll cut down
on a lot of boilerplate there and give
you really nice nice kind of a nice way
to configure your objects that sort of
thing the next one is mixed to automatic
and cost mixed automatic and custom
injections so right now in juice you
have to make this decision you either
have to let you create your object and
inject it or you have to configure it
100% manually well in the next version
of juice you're going to be able to kind
of do a little bit of both juice is
going to be you're going to be able to
say hey juice inject server simple for
me and then let me do some kind of like
post-injection initialization on it
we're gonna make that really easy in the
third thing that's going to be really
important is this idea of construction
listeners so juice is going to provide a
hook for you which and you can also do
your own checking its start up with this
where you can listen to the creation of
any objects you want and what that means
is that if anybody's familiar with like
ejb3 well you'll be able to implement
ejb3 on top of juice now because you'll
be able to write a custom construction
listener that looks at the objects and
says oh hey I see aunt resource a
notation here well I can get my
dependency out of juice and then pass
that into that method with that resource
sanitation and you'll be able to write
like custom code for like registering
your objects with listeners and doing
pretty much whatever you want I mean you
have your own hook in deck construction
and it's going to be a general thing too
so you'll have to repeat that code over
and over you does anybody have any
questions or actually I think Michael
had an announcement right grounded
so I wrote one of the jump user groups
meet sear on the 13th any luck I'm going
to have been here for the Japanese a
group meeting okay well rest of you want
to find out about it which is one real
easy way we have a gallon at project and
join our manual list or if you want to
be really easy you can just subscribe to
the RSS feed you know constellations up
here and hopefully we'll see you in two
weeks we actually don't have an
announcement up yet turn this week this
month we are cool thank you very much
two weeks please do week same time same
place two weeks chubbies distributed
um so he asked if we have any more
integration efforts upcoming like I said
there's some people working on the
mailing list on various things like
specifically JPA hibernate integration
was one of them that I noticed I'm not
personally working on any integration
things my goal right now is to implement
like construction listeners because
that's going to open the door to a lot
more integration things like I said
you're able to implement age 83 on top
of juice and pretty much anything
anybody else wants so yes he has how
many people are using juice our
downloads are we released it just like
two months ago now something like that
our downloads are well over 30,000
downloads already so we're really
excited there's a lot of interest the
mailing list gets regular traffic every
day so I think it's just going to get
better like when we released the next
one will release the next version I'm
sorry oh yeah yeah we that's the primary
reason that we develop the juice was for
unit testing and that that's kind of
like the main driver behind it is it
makes your code EG the unit test there's
any reason to use it that's the reason
so he said that ejb3 heads dependency
injection and why would you want to use
juice well ejb3 has kind of a
domain-specific version of dependency
injection with that resource annotation
and juice implements a more general and
type safe approach to dependency
injection and you can actually build
ejb3 and support its domain specific
version on top of juice so and actually
i mentioned web beans really you're on
and that's an effort where we're kind of
standardizing on this stuff we're
pulling in like the best of juice and
the best of seem and so like from the
juice world you're going to get like
these binding annotations and stuff
which ejb3 doesn't have an equivalent to
with ejb3 still use like string
identifier in that sort of thing and
you're going to have the string
identifier approach like seeing many jb3
and that sort of thing and then the idea
is hopefully with a web beans that web
means is going to be kind of a generic
component model it's called web beans
but it's kind of a missing
we're going to be more general ejb3
you'll be able to use web beans as its
component model and jsf will be able to
use web beans is its component model so
you're going to have like these two
disparate ways of configuring objects
and creating objects between two
different specs anymore you can have
some more it's gonna be a little more
cohesive yes I'm actually I don't know
that much about ejb3 but Paul pointed
out that ejb3 doesn't support
constructor dependency injection normal
ejb 3.1 and like I said so there that's
a great point right there I'm a huge fan
of constructor injection it's the one
that I use probably ninety percent of
the time just because you know such a
big fan of immutability it's a great
it's a great way to yes so yes if juice
is part of Google's codebase it was born
in Google's code base but then I open
sourced it and now I host it on google
code which anybody can use its kind of
you can host your own source on there
just go on and create your project
injected
so he asked where I draw the line
between calling new constructing objects
manually and between injecting the
answer was it used to be my answer used
to be that I would use dependency
injection with juice a little more often
than I would have used factors before
because there's less friction and it's
easier to use but now I would almost
always have everything injected because
it's not just the fact that I want that
I want to decouple myself like maybe I
don't necessarily wanted a couple client
from service but maybe I want service to
still be injected and by having service
injected juice has the opportunity to
inject it and inject dependencies in the
service and client doesn't have to know
about those so a lot it makes sense to
use this stuff a lot I mean even now
somebody released an intelligible ugh
and I haven't had that much some time to
check it out but even now even though
that the tools reducer immature it's
still it's it's very maintainable still
right because look in your IDE when you
depend on an interfacer class you can
just jump right to it well what you see
can still do that so so is the decision
as to which version of the service it's
going to be objective is that decision
need at compile time to run time so II
asked if the win the decision for which
service to inject is made whether it's
made at compile time ur run time it's
made it early run time so we didn't we
kind of some wanted to do this stuff at
runtime but we wanted to know right away
right you could theoretically do this
stuff at compile time once we get like
Java 6 in the annotation processing API
and stuff but I I still think you kind
of want some more dinama City and so the
idea is that we saw these module classes
and you pass those to the injector or
you pass those to juice to create the
injector where you can include different
sets of modules whenever you're in your
main method whenever you start up your
application that's how you make the
decision so as soon as that starts it's
very fast juice is very fast about
validating everything and running
through your modules you'll find out
right away if you're missing any
institute or whatnot and one of the also
the interesting things that juice does
is kind of blurs the line between
compile time in the runtime a little bit
and respect that normally run time if
you run into a problem you blow up and
you have an exception well juice doesn't
blow up at the first thing it does it
feels early but not too early right it's
so what it does is it goes through your
entire configuration and it doesn't just
stop at the first air it goes through
and collects all the airs and keeps
track of all the line numbers for these
airs it gives you line numbers into your
module gives you line numbers into your
classes where you're missing
dependencies and that sort of thing and
it presents them very nicely the same
way a compiler would so you don't have
to keep restarting your application
fixing every little air you can get the
whole list them fix them all on your
application will hopefully right so yes
how mature juice is whether it's safe to
use right now and the answer is
emphatically yes no no yeah no no how
much so now is actually it's a great
time one point I was very stable we had
a lot of experience with it I mean we're
using this stuff in production for
months before we even released it we've
been using it since I started developing
it well over a year ago and one point
out pretty much has everything that
you're going to need and there's little
workarounds for the couple edge cases
that you might run into the next version
is really just kind of nice to have and
enhancements maybe making the code a
little more concise like I said we're
making the custom providers a little
more concise but even even though you
write those maybe less than five percent
at a time so it's like you know it's
nice it's nice savings but you got it's
not the end of the world yes
so yes if it's going to be compatible
with web beans it's still too early to
tell but web beans is going to look very
much like like juice and like I said
it's gonna look like juice and seen
combined and it's really interesting
because juice and seeing had two very
different injection approaches so it'll
be interesting to see how those fit
together but juice will implement web
beans okay and I'll continue to
implement its current API we care a
whole lot about backward compatibility
I would also give me anything is fine
basically I want to see what God
rejected ah yes so yes you have
so he asked one weather what kind of
reporting juice give you one
everything's fine and that's when
there's errors and two how the IDE
integration is so to answer your first
question that's kind of where the jmx
integration comes in right now juice has
an API where you can kind of introspect
on your bindings and one example of
using that API is a jmx integration for
those of you that don't know jmx is a
standard management interface where you
can have multiple clients that i'll kind
of speak this that know about the same
API and like a look so and Java even
comes with a little jmx client so you
can connect to your application if
you're using the jmx integration you can
connect to your application that's using
juice and in your day in your console
your jmx console you can kind of see
like a nice little gooey that shows you
all your different bindings and you know
you can drill down based on type or
based on finding annotation and find
everything that way then he asked about
IDE integration like I said about a week
after juice came out somebody came out
with an intelligent plug-in for juice I
haven't tried it myself very much you
don't really I mean I love IDs don't get
me wrong i use the heck out of my use
every feature of IntelliJ but the way
juice is set up is it set up to be
maintainable even without an IDE so a
lot of cases the harder cases whenever
my whenever you depend on an interface
right and that's already hard with or
without juice right it's like how do I
know what implementation of that
interface am I didn't well most time in
your ideas I just use the feature where
you can kind of a you can go to the
implementation you can heard the
interface and then you can it can show
you all the implementations that
interface usually it's pretty clear
which one you get but I also think it
would be nice if we had an IDE plugin
where you could say okay I'm going to
use this set of modules to configure my
application and then based on that tell
me what implementation is service i'm
going to get and that's totally
plausible that's one of things were
working on to make even easier in the
next version
he asked if the constructors and methods
have to be public and the answer is no
and the reason I made that design
decision they could even be private the
reason I made that design design
decision is so you still want to control
access you can tell by looking at the
juice API that I only expose what needs
to be exposed to clients and the reasons
for that is one to make your API simpler
and two so that you can feasibly
maintain backward compatibility and then
so based on that and the fact that you
have you have to have that inject
annotation so even though it's private
you still see that inject a notation and
know that it's going to be injected the
situation so this is so yes if there's
ever a situation where you have like two
services that are codependent and yes
that's another great reason that I did
mention to use a framework like juice is
that it automatically handles circular
dependencies so this is the idea when
you have two implementations that depend
on each other and with juice it actually
even does some fancy stuff it's I don't
like to encourage it necessarily but
even if you have two constructors that
depend on each other just can handle
that case and the way it does that is
it'll inject a proxy into one for you
automatically and swap in an
implementation of that proxy after
construct the other object so you can
make everything final yes
yep
so we asked how you can handle a remote
services that aren't implemented in Java
with juice God can I assume that well I
would assume that you're using a Java
API to communicate with those services
and not the XML directly so the idea is
that so that's one of the things that I
really like about the way you can figure
modules in juice too is you can easily
make these little utility methods and
stuff in your modules so that I could
say I could create a method called bind
web service and I would give it the
interface that I wanted to use like the
Java interface and then I would give it
may be kind of like the URL to the Wiz
dolor something like that or to the B
URL to the remote service and then which
is automatically just put that one
method call it would create a binding
for that service for me
oh can you repeat the question I'm sorry
so he he asked about testing of a larger
application so in the great that's a
great question right
so he's asking them so I think you're
asking about how you implement kinda
like medium sized tests maybe so on the
one into the spectrum you have these
unit tests where you don't use juice at
all we showed that and use pass and mock
implementation on the other end of the
spectrum you have full-blown integration
tests where your test against your
production configuration which you want
definitely still need to do but then in
the middle there's kind of this middle
ground where it's still hard to
construct your objects and then juice is
great for that I mean you saw kind of
the bootstrapping code and Jews how
simple it was right it's just a couple
lines of code to kind of bootstrapping
juice configuration right there in your
test and in a medium-sized test you know
like say I wanted to swap in a fake
billing service or something I guess I'm
not actually charging credit cards but I
still want to test like a bunch of
objects together like four or five
objects that all interact well juice is
great for that so and the idea is where
as in my production configuration I used
one set of modules well in this test
configuration i can use kind of some of
the same modules but i can also swap in
like a fake billing module which will
install all the fake billing services
and that's what it so yeah juice is very
good
inviting configuration do you mean like
the properties file if you wanted to use
that or so he asked if juice kind of
mandates where your properties file has
to be and the answer's no it's the
utility method that lets you kind of
generate the bindings off your
properties file all I think it just
takes like a breeder or something like
that so you can get the URL using like a
file reader if you wanted to get off the
file system or a URL reader if you
wanted to get it out of the jar whatever
or if you want to get off the remote
servers you could do that right so and
you could even float you could even kind
of switch it based on whether you're in
development from production mode too
that's what I'm gonna give the juice
pattern stock I think I'm gonna leave
that one to Kevin because he's a better
speaker than I oh yeah yep example which
ensured you had the bindings were like
in the code so you said fine service not
class to servicing finger yep how would
I can be cases where my uncle would not
be known okay that's a great question so
he's asking what if he doesn't know a
coding time then he wants to use service
simple maybe he wants the client to be
able to specify that class in a
properties file or something like that
well that's why I specifically mentioned
that Jews could configure well no I mean
I didn't mention it enough that you
might be able to figure it out but I
mentioned that with the constant type
conversion juice can also convert to
classes so you can specify a class name
in your properties file and then have
that injected as a class somewhere like
in a custom provider or something like
that and then s juice for an instance of
that class and then juice will blow up
at startup if it can't inject that class
instance so you can specify you can
specify and it let your clients specify
an implementation dynamically
um many of the frameworks I look at that
you instruct for example they have like
one start start our Commons language or
they star that event is like 10-20 jars
by the time I the way development
environment be working right now these
things have to be checked in senior
right I don't know I cannot control how
many dependents is do you get yeah so
he's a skiing how we deal with kind of
like this dependency explosion whereas
all these frameworks depend on 15 jars
she doesn't help you there okay it's a
you know it's if you depend on a lot of
things you're gonna have a lot of which
are dependencies how many does juice be
none well you have the aop Alliance API
juice is very self-contained it's very
small and it has no external
dependencies that you need to worry
about besides aop lanes API so as two
jars as the juice jar and the alp
Alliance truck so because I hate all
those dependencies too yes
I'm so really version one of Aoki lights
really only specifies method
interception anyway so it was just like
a couple interfaces in there so but that
is the only interface to supports anyway
oh yeah it's really small yeah there's
like maybe one or two interfaces in
there oh so yep you could eject what
when you do in the unit testing can you
inject data yeah you can do yeah you can
do whatever you want I mean it's like I
said it's kind of a nice thing about
having this programmatic API figuring
bindings you know you can build whatever
you want on top of like you could have a
utility method that reads in an XML file
it makes you can inject it like inject
the Dom right he asked on a big
application how complicated your modules
get um and you know it really depends
you only have to explicitly define
bindings whenever you have an interface
whenever you're depending on an
interface so it depends how many
interfaces and implementations you use
right so but compared to other
frameworks it's a lot less than you
typically have slow yes from our
experience Kevin knows better than I do
the edges that we've been developing in
Edwards don't really get more
complicated you just get more of them so
we are now you know we have maybe 50
and when they one starts to get too big
then we usually chop it up and that
makes that makes it usually like the
unit of granularity for module is like
the set of things that you would
typically want to test together as a
unit in like sort of a functional test
so if you'd say like I want to test how
the these pages work but I want to mock
out the entire building subsystem with
the building subsystem in one module and
the UI for this section it's great
advice oh yes
uh no see if there's any cases of it GS
if there's any cases where you would
discourage you seduce and well it
doesn't work on a mobile phone yet
outside of that I mean it's just really
so simple it's not you know it's it's
not really dead there's not a lot of
risk to it you know so and it's always
good to write unit tests so and juice
helps you do that measurements on the
performance if not using diction versus
not he asked how's the performance we
care very much about performance and
it's the difference between doing this
stuff by hand and using juice to do it
is litter it's very it's negligible like
you could like you really couldn't tell
I mean it's it's so close you're talking
like nano seconds apart so you can
create millions of objects in a loop
with juice and it'll still be fast
cool oh it's are there any listeners
that you can apply to this case I'd be
on the customs
um he asked if there's any listeners for
whenever the scope get stared down and
we do get that request a lot but we
don't support it yet so I'm not quite
sure exactly how that's going to work
it's part of the reason right so
actually we could use like more use
cases for that too so where you'd like
say exactly what you want he asked about
the fact that we named the provider
interface provider that is kind of a
strange name right we named it that's
Kevin no that's good it was good it was
a good rename Kevin is great at coming
up with names for the api's and the
juice API looks very much like it does
because of Kevin's influence and
provider is one of those things and it's
it I think it makes sense i think
there's kind of this connotation with
factories that it creates a new object
every time whereas that's not
necessarily the case with providers
right but it could be returning the same
object every time in case of single
train or whatever we wanted to be a
little more generic
bunch of Marvel the gist context is
burning Margot
so he asked if there's any relationship
between modules and hopefully no Kevin
do you ever have any situation with so
you can structure your modules in a tree
structure oh yeah that's just a
convenient way if you have 100 of them
and 50 of them tend to go together you
can make another module that includes
all those and actually in juice 1.1 we
fixed it so it doesn't even have to be a
tree if the same module wants to get
included twice it will just realize that
it's already been installed in move on
but I would encourage you to think of
these structure like your J unit test
cases and your test Suites where you
either have something that contains
other things or you have something
that's a leaf because if you go too far
with like having modules that both
define bindings to implementations and
include other modules then you're
creating compile-time dependencies
between modules which is exactly what
juice is trying to help you basically so
um when you say put together can you be
a little worse maybe maybe like with an
example great so this module has
yes so you're saying like you're asking
so we have module a and module B module
a has classes that depend on interfaces
bound by module B and module B might
have classes which depend on interface
is defined by module a and yet juices
that think it brings these models
together and makes all that possible
without module a and mods will be having
to depend on each other so the idea is
you could take module a and reuse it
with an alternate like a fake
implementation philosophy if you wanted
one other thing I wanted to talk about
there well first Kevin needs to give a
talk on design patterns related to juice
but second so module is a really generic
interface and one of the things that I
had in mind whenever I defined it was
being able to kind of write these
utility methods that you can use in your
configuration too so you can write Q
tility methods that return providers and
they just can create those but you can
also write utility methods that are
implemented as modules and then call
those from your other modules so like
you could you could provide like for the
web service thing like so you had to
create a couple bindings to make that
happen well you could give me you can
give a factory method where I give you
interface and the URL and then you give
me back a module that creates those 33
bindings well let me having to know
about it
cool ok this is on all right cool I just
wanted to make sure that we plug we're
how to find the project page and get on
the mailing list because I always forget
to do that when I've done these talks
and bob was forgetting to do it too I
did forget I told myself I wouldn't so
all you have to do is is type in juice g
u IC e to your favorite search engine on
the internet whatever that may be and on
the one that I use our project page
comes up first it's hosted on code
google com and fright from that page
there's a link to the downloads to the
javadocs and to mailing lists there's
the regular mailing list and the
developers mailing list the developers
mailing list is very chatty you'll get
email every time we update the wiki it's
really silly but the the main user list
has a couple hundred subscribers and we
have lots of good traffic users helping
users so I recommend getting on there
and giving us your feature requests and
stuff and if you speak Chinese we have a
chinese translation of the user guide to
and portuguese and portuguese maybe not
if the users guide it's like the
somebody wrote a tutorial in portuguese
call we linked it cool never realize all
right thank you very much for everybody
for having me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>