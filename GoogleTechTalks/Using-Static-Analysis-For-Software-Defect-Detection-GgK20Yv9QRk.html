<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Static Analysis For Software Defect Detection | Coder Coacher - Coaching Coders</title><meta content="Using Static Analysis For Software Defect Detection - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Static Analysis For Software Defect Detection</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GgK20Yv9QRk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'd like to now introduce professor bill
puke from University of Maryland who
works on the fine bugs project among
several others he has been a consultant
at Google before and visited us several
times and given a talk on the find bugs
project before but now he would like to
update us on what's going on with fine
bugs now okay thank you okay so I'm
going to be talking a lot about static
analysis in general well I'm actually
got me talking a lot about this
specifically in terms of fine bugs one
of the things I think people are just
starting to really get a broad
appreciation for is the fact that static
analysis really can help you improve the
quality of your code i mean i think
three years ago if you'd asked a lot of
developers you know our static analysis
helpful and say oh there's lint I hate
lint or like Oh halting problem you guys
can't really do anything but now I think
a lot of people are beginning to
appreciate appreciate that static
analysis usefully applied useful tools
can actually do things help you improve
quality code lots of improvements are
still needed we're getting to the point
now where it's good enough that
developers will talk to the people doing
static analysis and we can get feedback
and we can start improving three or four
years ago developers just like AI don't
care um I'm going to be talking about
fine bugs which is a java tool for which
is a tool for doing static analysis of
java but there are lots of other static
analyzers out there and a lot of what
i'm going to talk about applies more
generally okay so fine bugs an open
source static analysis tool it's used
within google it actually analyzes class
files rather than source code this is
partially a historical accident but it
turned out to be fortuitous in a number
of ways we can generate either XML or
text output we can run it in netbeans
swing eclipse and at the moment we have
well you know actually this is out of
data as of yesterday but 225,000
downloads from sourceforge used by
oracle wells fargo bank of america bunch
of companies okay
so it is we really try to look for
software defects there are also a lot of
style checkers and actually one of the
things you have to sort of overcome when
we tell people oh I've got a static
analysis tool there one just like oh
I've used style checkers before I hate
them right there are style detectors and
they're useful in some context but
that's different than actually defect
detection we're actually trying to find
mistakes of people made in code and we
can find hundreds of defects in each of
several large apps that we've looked at
real defects things that should be fixed
okay now this is the common wisdom I
think that a lot of people have about
bugs I think this was certainly the
common wisdom in the academic research
community and I think it might been the
common wisdom in a lot of the developer
land is that programmers are smart smart
people don't make dumb mistakes
therefore if there are any defects in
and we also have good techniques unit
testing pair programming code
inspections for finding bugs and so if
there are any defects in my code they
must be really subtle stuff that would
require really sophisticated analysis in
order to be able to find but then when
you actually look at code you find code
that looks like this right if n is equal
to null then try closing in right and
this is of course guaranteed to result
in a null pointer exception if that
close method is ever invoked right this
was from eclipse and this is one of the
things that we find in this is partially
because with fine buds we've been
looking for the easy bugs we haven't
been you know spending six months doing
context-sensitive path sensitive planar
alias analysis and scheming or defying
subtle bugs we've been looking for
stupid bugs and we have found more
stupid bugs and I would have suspected
existed
okay so nobody's perfect they're a bunch
of common types of errors misunderstood
language features misunderstood api's my
boat right there are a lot of typos some
of them got cut get caught as a syntax
error right other typos don't get cod as
a syntax error instead simply well you
meant to use equal and said you type not
equal have an error misunderstood class
or method invariance so everybody makes
syntax errors they rely upon the
compiler to catch those but what about
bugs one step removed from a syntax
error okay so interaction time
programming puzzlers I'm going to put up
some code and I want to see who can
shout out first what's the bug with this
code now in a couple of cases you might
need to ask a question about the code
and if you if you want to ask a question
feel free to shout out a code these are
all real code so you shout it out equals
go
um right so if column name were actually
null you'd get a nullpointerexception
and said that will never work also
comparing to be equal with not with
equal equal is probably a mistake okay
here's another one infinite recursive
loop here is a method that if invoked is
guaranteed to take the string that was
passed to it append monitor action to
the front of it and then call itself
again over and over again building up a
longer and longer string until either
you run out of heap or stack and don't
know which one would happen first ok so
if name is not equal to null or name dot
length is greater than zero shut it out
sorry what no you will evaluate right so
actually so if name is actually null
then the first part will evaluate to
false and since this is an or you only
evaluate the second part in the first
part evaluates false so if name is equal
to null you'll get a
nullpointerexception we see a number of
variants on that this one's a little
tricky so we have you know if some
string is equal to the result of calling
gay plucking feel so there's a trick
there's a little bit of a trick here
need some context
the problem is here is get like and
field return to class and we're
comparing it to a string and said this
will always return false you see some
weird code okay so here's this one
int chase like so what it does here
because end is int it's going to take
int and / to using integer division then
math dot ceiling takes a double so it's
going to translate the result that
integer division into a double pass it
to math dot ceiling which rounds it up
except it was converted from an integer
and then it converts it back down to an
end right okay so these were some of the
examples of things we find in real code
now one of the things that we try to do
is rather than just finding like four
different things that we look for we
actually try to identify bug patterns
and we try to identify a lot we have
over 100 maybe 200 different types of
bug patterns that we look for let me
just talk about a couple of them so this
is actually my favorite Bud pattern the
infinite recursive loop and this
actually arose out of office hours a
student came to me and saying I'm having
trouble with my constructor I'm getting
a stack overflow error and I don't
understand what that means right and so
here was the code he had a web spider
and I'd actually given them it was
partially my fault I'd given them a
javadoc comment that said construct a
web spider for this method and so that's
what the student proceeded to do in this
method he constructed a web spider of
course this was the constructor for web
spider I should have javadoc chef said
initialize a web spider okay so and
after a second student came in with the
same bug I said okay well you know this
would never happen in production code
but students are making this mistake so
our students use fine bug so let me
write this for find bugs so I can give
the students feedback okay found three
other students with the same bug now
before I actually added this to the find
bugs codebase I wouldn't make sure that
I didn't do something stupid I'd make
stupid mistakes too and want to make
sure I didn't do something stupid
that would produce a lot of false
positives so i ran across the jdk
because there wouldn't be any of these
in the JD King hmm and I found for
infant recursive loops in the JDK
including one written by Joshua Bloch a
one-line method that there's nothing
except research return the result of I'm
invoking itself now what actually
happened here is there was a variable
called fam type a field and the method
was supposed to return the value of the
field and this is on the back of my
shirt and josh has one of these shirts
that he proudly wears right and one of
the lessons that I think everybody has
to understand smart people makes them
make dumb mistakes right you can't get
embarrassed or uptight about the fact
that a tool found a dumb mistake in your
coat everybody makes us if josh makes a
dumb mistake you are allowed to make a
dumb mistake right so what you need to
do it you need to embrace your dumb
mistakes and fix them okay so this is
actually I've got something I'll talk a
little bit more where we can actually
look at stuff across time and what this
shows this is across all the JDK
versions that I have a copy of the blue
line shows how many infinite recursive
loops are in that version of the JDK and
the red are how many were in a previous
version that but have now been fixed so
Reds guaranteed to be monotonic when you
fix something it turns from blue to red
I mean you see you know earlier I didn't
have a whole lot of versions back in the
early days or actually probably would
have found more and was right about here
the first builds of 1.6 when I wrote
this and I sent to email the Sun saying
hey I found infinite recursive loops
near code and real quickly they fixed
all the ones that I found there's
actually one that they didn't fix by
didn't find it right away as I actually
had to improve the tool to find
additional infinite recursive loops and
I thought wow that was great now I fixed
infinite recursive loops then about six
months later they started adding more
it's like hey guys are adding more why
aren't you using fine bugs and I found
bug reports and they eventually fix them
and then like a couple months ago they
added another one actually this one got
in the latest build there is still one
infant recursive loop that was
introduced in Java 1.3 that I've not
been able to get them to fix and like I
need to sit down like I mean some code
which is actually hard to test cuz it's
in the crypto stuff but i need to
actually write a test case to get them
to fix the damn thing it is my goal I
don't I don't think I've all conscious
to get 1.6 to ship with no infant
recursive loops okay this is actually
something else we can get Albert old so
this is for each infant recursive loop
this serve shows when the bug appeared
and when it disappeared so you can see
that there's one bug that's basically
persisted for the entire duration and
these are you know when they born when
they died and so forth so this is some
of the information we can get out of
looking at these tools so there before
anybody feels too good about things
there was one infant recursive loop in
Google web toolkit version 1.0 point 20
it was fixed in version 21 in tab panel
there was a get windex get widget index
method which returned the result of
invoking itself and basically what's
happening here you actually see for
infant recursive loop there a couple of
different ways this mistake comes up and
one of the way it comes up is you have a
decorator pattern and one case and you
have a method where you forget to say
who you want to delegate the method to
in which case you end up delegating to
yourself and you get an instrument
recursive loop and there were also two
infinite recursive loops that are still
in the current version on but they're
not google code they're just code that's
shipped with it okay so let me talk
about a couple of other bugs we did see
I want give you a little bit of a feel
for some of the scope of things we look
for so hashcode equals so in Java
there's a general rule of thumb that if
you want to have an object that can
serve be properly put in a hash table or
a hashmap then if you define and you've
defined an equals method on it so that
two different objects could be equal and
you need to find a hash code mad because
otherwise you get the default hashcode
method and there's really this invariant
you're supposed to have that if
two objects compare is equal excuse me
then they need to have the same hash
code right I mean so if you override
equals but you haven't provided any
hashcode method we signal a warning and
you know their number of bugs like this
still in the JDK you know a couple of
examples now sometimes when I'll talk to
people I could talk to the AWP people
about this one they said well you know
we don't think anybody's going to put it
in a hash table and besides it would
actually be pretty hard to calculate a
good hash code function right um and so
actually sometimes I mean actually in
their case to actually come up with what
they were thinking if we're good and
actually took me a while to figure out
well what is really a good hashcode
method if you don't think your object
will ever be put in hash table hmm and
so here's the good hashcode method right
so you put in the cert false in case you
run it with a search and debug enabled
to generate an error in otherwise you
just returned 42 right that satisfies
the invariant that if two objects
compare is equal they have the same hash
code right and if it turns out you put a
bunch of these guys in a hash table it
won't be efficient but not being
efficient is better than not working and
so one of the things we try to do is we
you know it's not sufficient to just
identify bugs you also have to help
programmers understand the bug and
understand how to fix it and I think one
of the reasons this people weren't
fixing this so much is you know this is
oh well but I don't know how to create a
good hash table and just sort of didn't
occur to us we recently rewrote our
stuff to say you know just returned 42
that works okay null pointer
dereferences now you can do very
sophisticated analysis to try to find
null pointer do interprocedural stuff we
do very simple stuff we don't do
interprocedural and basically what we
look for our statements or branches that
if executed guarantee that a
nullpointerexception will occur so if
you've got this that means either your
code can throw a nullpointerexception or
you've got a branch or statement which
is dead and either those are a little
questionable I mean so here's a case
where you know if c is equal to null and
invoking a method on see returns true
then returning that the end should have
been or i mean this is a pattern that we
see over and over again if sig is not
equal to null or invoking something on
sig you know same thing in the jdk a lot
of stuff just occurs over and over again
i mean in this case what happens is
confusion between a variable name and a
field that are named the same right and
so there's a field which is passed in
which could be null and as a result of
this if statement it always initialize
the variable could be null it always
initializes the field to be non-null but
then here they're using the variable
which could be null and so that could
get a nullpointerexception one of the
ones which is a little bit harder to
figure out what to do is a redundant
null comparison I mean so you see a case
where you see a dereference of a
variable and then after you see the
dereference of the variable you see a
check to see where they met the
variables no problem is it's generally
not specified any way that a static
analyzer can easily get at it whether or
not this method parameter is allowed to
be null here at this point there's some
confusion on the code writer about
whether or not this method parameters
allowed to be null right so that's you
know it's not as sort of obvious a
problem as the other one but it's
definitely something to be concerned
about confusing bad names I mean I don't
you know yeah method name should start
with a lowercase letter hmm yeah but you
can get into worse problems even get
into places where you have a method
which has the exact name and signature
as a method in a superclass except the
names are capitalized differently right
so for example here
there's a method called get ok button in
the subclass there's a method called get
ok button except ok is capitalized
differently I mean you also see things
like here's a place where somebody wrote
a hashcode method where hash code is all
lowercase right so actually now in Java
5 there's this overrides annotation that
you can put on the method says I intend
to override a method in the superclass
and if for some reason I don't signal an
error which is a little bit useful in
terms of indicating intention here but
yeah you know as I go through these
things some of the things that we find
your things like yeah this is probably a
bug but it's sort of so fuzzy that I'm
not sure it should actually be part of
the language spec I actually think that
overriding a method what will almost
overriding a method with a different
capitalization should probably actually
be a compiler book maybe even against
the language spec ok another thing we
look for our methods that if you invoke
them you ought to be looking at the
value returned by the method so that for
example in Java there's a method that
reads into an array of bytes and it may
not fill up that array because if you're
like reading from a network and it'll
just say well ok let me read from what's
available from this packet and rather
than waiting for the next packet to
arrive I'll do a short read you ask for
a thousand bytes I'll give you 417
you'll have to come back and ask for
more bites and if you don't look at and
the number of bytes actually returned is
the return value of this method now and
see this is a big problem with where
they don't have exceptions and people
return error codes but people don't
always check the error codes java we
have exception so you don't have that
problem but there are a number of
methods like this that you have to watch
out for but they're actually turns out
they're a bunch of these so for example
in Java there are a number of classes
that are a mute
things like string big integer
bigdecimal like the replace method
returns a new string because strings
immutable you can't change it and so if
you see a call to like name dot replace
and it's not using the return value and
somebody we're pretty sure is thinking
that this is going to modify name but it
doesn't as no effect you know another
example they're calling replace you know
plate this happens with replace a fair
bit this one was slightly interesting
here so they need to create a thread to
read from the error stream because
otherwise something gets clogged up in
the works so they actually create a
thread but they don't start it one of
the other ones I don't think I actually
have one of the examples is where
somebody will say like you know if such
and such new illegalargumentexception so
they create the exception object but
they forget to throw it here's a
substring okay so like I said there are
a lot of these places where there's some
method that if you invoke this it
basically it doesn't make sense to
invoke this method as a procedure only
as a function okay synchronization in
currency these are hard errors right our
ability to correctly identify
synchronization deadlock issues is not
as good as I would like it to be and
it's because it's a hard problem and
it's also an incredibly gnarly problem
as far as testing as I'm sure miss you
air because these concurrency problems
don't reoccur reliably so one other
thing but it still turns out there are
some problems that you can find using
simple techniques and so one of the
things we look for is okay if you have a
field and almost every time you access
this field you're holding a lock but
there's just like one method where
you're accessing this field and you're
not holding a lock
right then it's quite possibly an error
so this is inconsistent synchronization
something where you're holding a lock
most of the time where you're accessing
it so for example here there's four
vector this was from New classpath
there's a field element count and almost
all the time when you access element
count you're holding a lock except for
the last index of method where you're
not and as a result the last index of
method can throw an index out of bounds
exception so once again one of the
problems and this comes back to one of
the things which is tricky with a lot of
these tools so we actually don't have
the design of the code we don't know you
know is this class intended to be
thread-safe right but we can luck and we
say oh gee you know it sure looks like
you've got almost all your methods
synchronizing you've got all these
fields that you're protecting using
synchronization maybe you actually
intend for this class to be thread-safe
if we actually had annotations and some
people have proposed some that would
give us some of the design of the class
then this stuff would be a lot easier to
do and of course the question is is how
much annotation burden can you put on
developers before they start saying and
not for me they're a bunch of other
gotchas with synchronization so here's
something that comes up from time to
time this was an example in jboss so we
check a condition and if the condition
isn't set then we grab a lock and we
wait for the condition to be set and
what can happen is another thread can
set the condition in between the time
when we check it and when we grab the
lock and so it will actually set it and
do the notification and then after that
we get to lock and so we will have
missed the notification and so there
couple things here one of the things is
a call to wait should generally be in a
loop and you should be checking some
sort of condition on it in order to make
sure that you will catch the appropriate
changes
okay so those are just a couple of the
bug pad and some you show you some
overviews of some of the things we found
on a couple different tools so this is
glass fish which is sons appserver 29
return ignored returns values that
should not be ignored 59 classes that
have an equals but not a hash code nine
calls two equals that will always return
false because they're like comparing a
string and a string buffer for equality
18 statements and 98 branches that if
ever executed or guaranteed to throw a
nullpointerexception 10 methods that if
ever called will invoke themselves again
in an infant recursive loop and a check
cashed that is guaranteed to always
throw a check a classcastexception
here's some stuff from weblogic 1166
ignored return values i'll come back to
that 245 classes that find equals but
not hashcode 45 calls to equals that
always return false statements 35
statements that are guaranteed to throw
nullpointerexception 21 infant recursive
loops for impossible casts the ignored
return values there were like a thousand
calls to substring and it turns out that
this was automatically generated code
and actually one of the things which is
interesting because where we run is if
you have some process that takes
something from your database schema and
uses that to compile down the bike code
or something like that we can actually
check that so something in their process
for automatically generating calls was
actually generating a called substring
where they were ignoring the return
value calls to bigdecimal dots at scale
exception creations where they were
saying like new runtime exception but
not throwing it called big integer add
okay um and one of the things we do like
I said we don't just look at a handful
of things we try to come up with lots of
little things every time we find some
interesting bug actually it turns out
students are great at generating bugs
right but the developers to so here's a
case where somebody is trying to
take an array of bytes and turn it into
long and actually that's just bad code
in general but there's a very specific
bug here is that an array of bytes is an
array of signed bytes and so here we're
taking the result shifting it by eight
bits and then pouring in a signed bite
and that's just not going to work I mean
and you know you have to do a lot of
these cases you have to do tuning in
order to mean just checking places where
you're doing an oar with assigned to
bite that gives too many false positives
and there is actually a fair bit of
skill in terms of you know well what
sort of heuristics do I use to try to
get as many real bugs as possible and
not too many false positives okay so
that's the bug there okay so let me just
talk real briefly about some newish
features so behavioral annotations
actually I think that's not the name
we're using now annotations for static
analysis so one of the things hopefully
we're going to propose as a JSR we've
actually got some of these features done
is you can use annotations in your Java
code to indicate things that the Java
libraries will check so for example you
can mark a method parameter as being non
null and saying this method should never
this parameter should never be null or
that the returning value from this
method might be null so if you invoke me
you better check it check return value
that says if you invoke this method you
better not ignore the return value these
are things like for example for string
all these methods on extreme right now
we've sort of hard coded it but if
somebody doing a third party library
wants to be able to do that like they'll
do those annotations one of things we
haven't done this yet but for security
purposes one of the big issues that
comes up is going between untrusted data
like data you would get from a Java form
from a web form versus things are
passing into the database things that
you expect to be checked it can't be
just arbitrary strings and so it'd be
nice to be able to mark things as being
tainted untainted deep marking something
as detain today something
you can write anything into but what you
pull out of it is untainted and that's
how you would mark like the methods that
you know do your blacklist or white
listing and so forth and you might think
well you know I could do some of this
with static analysis I could do
interprocedural analysis to figure out
which method parameters are nominal but
one of the you could and it's hard but
these are really great because they're a
way of assigning blame right so say you
do static analysis and you find out that
this method in class a is calling a
method in class b and this method could
pass a null which could cause a null
pointer dereferencing class b these
classes were developed by different
teams on different sides of the
continent right whose fault is it who
has to go fix their code right it's not
clear right whereas if the person
writing this method said hey this
parameter better be non-null then that
absolves them from any involvement in
fixing this bug because you're passing
in something that violates the contract
right and a lot of these things are you
know things that I think will really
help people doing like infrastructure
libraries you put in these annotations
and will help so you know flashback to a
story when I was a grad student I was
working at Cornell worked on the
synthesizer generator which was a
program a tool that would generate
programming environments and I actually
did the logic to display the abstract
syntax tree and long with all the
attributes and so forth and it turned
out that if somebody in an upstream pass
for me had done something that corrupted
the tree right it typically blow up in
my coat and I'd get called in all the
time because hey it's blown up in your
code right so I quickly wrote something
that would do a whole bunch of integrity
checks right so that like I could run
the antennas up not my fault somebody's
passing me a corrupted tree and that's
one of the things you can do with these
annotations is that you can serve wall
off your code from having to deal with
the warnings being reported by the
static nestles yeah
oh and then blow up this away
well so uh um well actually sit I mean
there are some questions about right so
if you did static analysis and you found
out that there's a specific assertion or
a specific check for something being
null and if something's null then it
throws an illegal argument exception or
something like that then yes I think
then you could say that's the equivalent
is marking something not another
question is how does this work with
inheritance right right and one like
another thing you can do we've actually
got some mechanisms that allow you to
say like within this package all method
arguments should be non-null unless I
say otherwise explicitly for that method
argument they know that I think whether
or not people believe that method
arguments should be null is like a great
religious debate and like the fact that
Java collections that a map can allow
you to have null as a key you know
people have very strong opinions as to
whether or not that was a good idea but
it does but you know some people you say
yeah I don't like no I'm just going to
declare my packages saying no null
unless I say you're allowed to yeah
proposing this orientation process or
Holly or how they're also going to be
some static Jackson okay so um so Lexi
we've got some of these IntelliJ has
also has some of these right nobody is
really eager to put in both the
annotations from fine bugs and from
intelligent right so what we really need
to do is first off we need to get a
standard we need to have this part of
the Java process so that we can come up
with standard names and actually really
agree on what you know could be null
ming's or nullable or whatever it is
what what exactly that means um and then
it's really I mean it's part of the
documentation but in a way that could be
checked by tools so for example you
could use it in a static analyzer but
you could also
in doing 70 okay we're going to do some
rewriting of the class files so that if
you've mark something as nominal an
assertion will be thrown if any of these
things are no right so I mean the
problem is javadoc sometimes described
stuff well do humans but it's really
hard to get good stuff out of that for
automatic tools and so its documentation
that can be used by tools for either
static or dynamic analysis yeah so will
some of these features into the
languages such as if you do some 545
right-handed antenna and enforce the API
sometimes some ppl much diversity and
I mean so the question is actually
improving the language to fix this the
hurdles involved in actually changing
the Java language are substantial
they're not completely impossible but
their substantial I think the one thing
that we may see is that there's a
proposal afoot to also expand the number
of places an annotation can occur right
to basically allow you to do some custom
typing and so forth so like right now
you can't say that this is an array of
non null strings or a array list of non
null strings because you can't put an
annotation there can't put it on a type
parameter one of the things to do would
be expand where the annotations can go
and the other thing is is that if you
make it part of the language then you're
really serve saying that okay whatever
list of things we come up with that's it
period right whereas if you do make it
serve like well it's a common set of
annotations and then sort of like well
and then like next version maybe we add
two more annotations mmm a couple more
annotations you have a couple more so
are you familiar with guy steals talk on
growing a language it's a great talk but
basically guy said you know you should
rather than putting a lot of features in
the language what you should try to do
is you should try to make the language
so that it's possible for you know for
users of the language to extend it I
mean I think what we should be thinking
about how do we change the Java language
so that these annotations are useful and
can be applied to all the places where
you'd want to do them but trying to hard
code into the Java language what are the
set of annotations you'd want to need
yeah that would be limiting there could
i think people have thought about you
know do we really want to put like read
only or non null into the language you
might come up with two or three but
there's certainly other things like
check return value that's not going to
be part of the language and tainted
not in Java maybe the next language okay
so another thing we've got it's one of
the least known features of fine books
those who have actually used it help you
or talk to herself I didn't know you had
that is we can keep track of a
historical record of bugs so you run
fine bugs on one version of the code and
now the next night you do another
builder your software you run fine bugs
and you can actually combine those
results and do this every night or every
build so you get a history and you can
say okay now let me see what are the
fine bugs warnings that were not that
have been introduced into my code since
the last time we did a release and those
are the ones that you want to perhaps
give greater attention to because it's
often the case that you know you run
fine bugs over logic is come you get a
lot of warns like oh I don't want to
deal with these right but i think that
saying well let me just look at what's
been introduced since the last time we
released this to users and i'll
hopefully be a pretty small list it
might be something worth looking at okay
so i've talked a little bit about what
I've done let me talk about some of the
things I'm trying to figure out what is
the fruit distribution fine bugs I've
always describe people find bugs Lux for
low hanging fruit may I show the
detectors we look for they're all simple
right but I want more fruit where do I
go to get it do we write more
sophisticated analysis to do
interprocedural stuff that understands
fields and so forth we go higher up in
the tree or do we write more shallow but
general bug detectors or do we write
application-specific bug detectors right
you know it's really quite some you know
where are the useful bugs that can be
found with static analysis you know if I
knew that's that having somebody slave
for 12 months over doing a very fancy
context-sensitive pointer elias now sis
scheme would allow me to find 10 times
as many important
then I might decide whole yeah that
would be a good investment of time but
it may turn out that doing all that
sophistication only gives you 20 percent
more real bugs no in which case that's
not a good investment of time what kinds
of budget can be found by static nozzles
I would never have thought to look for
infinite recursive loops unless some
student came to me in office hours and
had that problem I mean this is true for
a lot of the things the thing about take
you know doing an integer division
converting the result to a double
passing result to math not silly I
didn't just think oh that would be a
good buck right I actually saw that in
code right so it's relatively easy to
measure to do something about false
positives you can run your code run your
analyzer over a bunch of code look at
all the reports go through and say which
of these are real errors right when it's
hard to get a handle on our what are the
types of errors that could be detected
by static analysis but aren't and it's
often the case as you look at these you
can say oh I you know I understand what
it would take to catch this and then you
you try it you find out who you know a
gazillion false positives and then you
say oh I gotta tune it right and
sometimes you successfully tune it down
to a good detector sometimes you don't
and part of this is trying to turn bug
instances into bug patterns and one of
the things I think we need to do as far
as software testing and so forth is we
need to change our development process
that we learn from our mistakes I mean
we need to evaluate bugs and see if they
can be turned into a general bug pattern
a lot of the bugs that occur will occur
elsewhere in a large code base right so
for example the flaw that Josh
identified in binary search how many
people know about this issue Joshua
found in binary search okay so a lot
this binary search implementation in
Java and in a lot of text books
including the
textbook Joshua spot from and he was it
seem you have a bad implementation of
binary search because it takes the lower
bound and the upper bound which are of
type int adds them together divides the
result by two right if you get an
integer overflow when doing that
addition you get a negative result it
turns out like in Java what'd you just
do is you add them to get the needle ooh
unsigned right shift now it works just
fine and somebody maybe somebody at
Google was doing a binary search an
array with more than 2 to the 30th
elements and got hit by this but I now
took that and turned it into a bug
detector in find bugs and we now look
for example of trying to do this one of
the things I do is I get every bill to
the JDK and they have a list of what
bugs were fixed and I look through them
and say okay are any of these things and
like a lot more like Oh cleaned up
javadoc I don't care but I like to to
say okay is this something that could be
part of a bug pattern that i could try
to fix I mean and shouldn't build 89
they fixed a serialization bug in array
blocking queue and basically took me
five hours of work from start to finish
to write in tune a bug detector to find
that problem and actually found 17 other
erroneous classes in the JDK that all
had the same problem so I'm problem it
was a class that was serializable but it
had a transient field so a transient
field is one that is not saved by the
serialization mechanism and it wasn't
being reset when you DC realized an
object by either a real object or read
resolve method and so you first do that
if I know it's giving too many false
positive there's this whole tweaking
process so for example it turned out
this was a field like in some of them
was a field that was said 2-1 in the
constructor but was transient and so
when was DC realized it was set to 0 and
that gave you know the wrong semantics
it was was a cached hash coding for some
reason they decided to have the value to
represent an uninitialized uncompleted
hash code to be minus 1 and so for
example I if
the transient field is set to a non
default value in the constructor then I
have to elevate the priority and this
was able to give us those bugs and that
was 17 defective classes and i think was
49 classes where we got the warning so
more than one-third bill errors how can
we make it easy to write bug detectors
right now this was something that when
we were certainly did this research we
said well why don't we start by figuring
out a nice high level pattern but I was
like you know I don't really know this
scope of what are the types of bugs fine
let's just write bugs and you know we
can use Java its turing-complete right
tried our bug detectors now I think
we've got enough of a scope that we can
start trying to figure out looks like i
said you know I I can do this for the
JDK I don't really want to be doing it
for the data k I want Martin or somebody
else to be doing it for the JDK and I
don't want to be doing it for Google and
if all you know we get lots of
developers doing this and some of them
maybe company specific practices some of
them may be general right I think this
will be very helpful ok so I think we
have enough example start thinking about
this ok how can we make static analysis
pervasive so state-of-the-art static
analysis has a lot to offer more than I
think many people suspected what are the
practical and cultural issues that need
to be surmounted to make it pervasive
now I am quite aware that there are
things about find bugs that probably
suck right things that make it really
hard for people to use and one of the
things I'm hoping do is like figure out
what are the points of pain in trying to
use this you know I haven't unlike
companies that have field engineers I
haven't done as many trips to companies
to see how that works one of the things
I'm doing here this summer right I'm one
of them is false positive suppression
and people worry about with these tools
false positives like well if you deliver
no more than fifty percent false
positives sound too bad but thing is
nobody wants to look at the same false
positive more than once it's one thing
to look it at once people will tolerate
that you don't have too high of false
positive rate but if you run a tool can
you fix all the real bug
then all you have left our home and the
next time you run the tool maybe you've
introduced one error but you still have
500 false positives that weren't fixed
from the last time and now nobody wants
to use the tool I mean what are the
other points of pain okay so a couple
quick announcements so I'm here all
summer mmm I'm taking refuge from the
heat and humidity in Washington DC and I
hope to develop some substantial
collaborations at Google trying to get
everything set up so I'll be able to
work with people like a google code base
sit down with people on this is parsley
meddling to understand find bugs and so
forth but also as an academic I tell
students how to develop code how you
know how to get prepared you know I
really feel like I need to take some
time primer Simon immerse myself in the
real world that I'm not just talking out
of the ivory tower um so I'll be here I
want to really understand how software
development software quality works at
Google I'm sending me email and we'll be
here and we'll set up visits yeah i'm i
am living in palo alto and I hopefully
will be visiting Google about three days
a week for the next six weeks we're
working that out but hopefully I will be
under an NDA that will allow me to look
at google code hopefully we will get
that all figured out today okay and then
let me just briefly tell you about one
other cool project and hopefully I make
it to do a tech talk on this later
during my visit um this is the marmoset
project so the marmoset project is a
total rethinking of how student
programming projects are submitted and
tested so it's designed to provide
students instructors and research with
lots of feedback including feedback
before the submission deadline we're
also collecting large data sets of
student efforts and we're starting to
earning lots of things about how
students from your program and I don't
have a slide on this but I've got a
couple of extra minutes so let me tell
you that the really cool feature about
how marmoset works so traditional
the way programming projects get
assessed for correctness is that you
know the instructor publishes here's the
project description here are three
sample test cases go work on it and
students work on it and they submitted
electronically somehow and then there's
a deadline and you give a tarball to the
TA who runs the whole thing against a
bunch of secret instructor test cases
and you know a week later maybe he comes
back with the results and it's emailed
to the students right and you know the
students don't get feedback from how
they did on the project too laughter
they're already working on the next
project the instructors only really get
feedback in terms of questions in office
hours and in lecture so what happens
with marmoset instead work the same you
post the project description you post a
couple of sample test cases easy the
public test cases students go to work on
the project they can submit whenever
they want it after they submit they can
go to a web server where they can see
the results of compiling their program
and running it against the public test
cases okay shouldn't be a surprise
because they've got these but sometimes
it turns up platform dependencies and
then if a student submission passes all
of the public test cases I mean the
students get an optional would you like
to release test your submission and if
the student says yes I want to perform a
release test maybe this is the poker
game project say okay we ran the release
tests against your coat um you fit there
were nine tests you failed four of them
the names of the first to test you
failed our test full house and test four
of a kind plus two more tests where the
QA team couldn't be bothered to write
down the details now students can think
about this Oh full house oh yeah I think
I know I did wrong then go make a quick
change resubmit they can resubmit a
softness day one but performing a
release test requires a token students
are given some limited number of tokens
like two or three and they regenerate 24
hours after they're used so students
within a 24-hour period they only have a
limited number of times to get feedback
from the release tests so this
encourages students start programming
early which is a good thing
um it gets them into that mode of like
okay it's the last day I've only got one
more release token left have I done
everything I can do to ensure the
quality of my code before I'm willing to
burn up my last token right so it's both
sort of a throwback to the idea of you
know releasing your code either putting
on the website or handing it over to the
q18 I really want to do sort of your own
stuff or for us old timers and I'm
barely an old timer it's turning your
card deck over to the computer operator
knowing that it's going to take like
three hours to get your answer back and
you really want to like desk check your
code because if it's really embarrassing
to turn in a deck with a stupid error
and have to wait for that long
turnaround so and the other thing is
instructors get feedback we run all the
tests ooh this stuff is submitted so
instructors can see at any time how many
students are passing each test case and
get all sorts of feedback from that but
we also collect snapshots of student
code from every time they save their
files and here are some of the data so
from force I know Google people like
data so this is reasonably large data
right from four semesters of a cs2
course we had 145 147,000 snapshots of
student effort he's like you know all
the files for one student working on
project we take each one of those
snapshots and we run them against all
the test cases so we have over two
million runs of student code and then we
can do like static we can run our static
analyzer over one hundred and
forty-seven thousand things and we can
actually look at what exceptions
occurred so it turned out that out of
those two million runs right actually i
think that i think these exceptions are
per snapshot not per run so if a
snapshot got a nullpointerexception
multiple test runs it's only counted
once here so the most common runtime
exception was a nullpointerexception
surprisingly the second most common was
a classcastexception index out of bounds
array index out of bounds stack
overflows right stack overflows
you know typically recursive loops and
actually so one of the things we were
actually able to do with findbugs Israel
to check where are we predicting an
infant recursive loop where our students
encountering a stack overflow right what
are the places where the students are
getting a stack overflow but we're not
predicting an infinite recursive loop
and you can just eyeball them and in
some case you can say oh well this is
mutual recursion and our analysis
doesn't detect that but in a couple
cases we were able to use that to
improve the analysis and actually
improving the analysis catch more the
student errors is what led us to improve
it to find more info recursive loops in
the JDK okay so that's marmoset okay and
I'm done yeah yeah I mean it's certainly
the case that a lot of the errors we
find indicate code that has not been
tested and when you find a method that
if invoked is guaranteed to throw a
stack overflow obviously something was
lacking in the coverage in acting some
ways that there's serve an interesting
trade-off the nice thing about static
analysis is you don't need to have test
cases right and you can find you know
generally the stuff which has been
tested well you're not going to find a
lot of the things that we look for right
one of the things which gets tricky
sometimes it's like library code you
know what happens when you write a
library and you know can you anticipate
all the different uses of it so yeah I
mean I think um testing versus static
analysis are very complimentary yeah
it seems like an on-set project right so
I mean with fine buds with bunnell do
lots of stuff in terms of looking at
open source projects but generally what
we don't have for open source projects
is well what are actually the errors in
this stuff we don't you know e to the
extent they actually have test cases you
find that if you want to pull like a
different bunch of different versions of
Apache officer size and actually run
them all it's really hard because they
all have all sorts of dependencies
whereas here we have something that
allows us to say oh we've got all these
versions we've got these test cases that
are designed to be exhaustive tests of
the functionality of the code and you
know we can look well yeah okay they
made this two-line change and it caused
a warning to go away and at the same
time three test cases started working
right maybe there's a correlation there
all right so yes I think that is very
helpful it is student code the projects
are smaller we found more connection
than we would have thought between bug
students make and bugs we can find in
production code but yes that it's one
reason swear we're very yeah I mean you
know so a lot of what fine bugs findings
are you know really coding errors that
what the person had in their mind didn't
get translated correctly into the paper
or that they just misunderstood some API
whereas if you've got something like you
know one of the projects was Sudoku and
if they simply didn't understand the
logic of how to do Sudoku well they're
doing some different game right it's not
to do code something else right and
we're not going to find that with fine
books as we don't understand the domain
so I'd say that you know a majority of
errors probably not a huge majority but
i'm guessing majority are
domain-specific if you look at all the
sort of errors ago I don't really know
wild ass guess no somewhere between half
and two thirds of all errors are
required domain knowledge
I mean total wild ass guess maybe
something else has a different opinion
and you're not gonna be able to find
that where the tool like fine bugs but
you know the stuff that you can easily
find yep yeah
who also blind that's starting to change
and you said that most of the stuff that
you do changing the light went just
making fresh choice the problem with
putting something into the compiler is
you've really got to have an insanely
low false positive rate right people
really get cranky if the compiler won't
compile something that they know to be
perfectly correct code right so I think
there are a couple of cases like the you
know overriding a method except you miss
capitalized the name that's something
that even if you think it should work it
shouldn't because it's going to confuse
the hell out of the person comes after
you right and so there are a number of
these that should do I mean like should
for example the JDK refused to compile
code where there's a statement that if
executed this guaranteed to throw a
nullpointerexception I don't know I
don't know right well and you know like
so you know one of the things we look
for is a check cashed that's guaranteed
to throw an error and so I look for that
and I found a piece of code I said hey
you're going to get when these ere same
look and says you know okay cast us to
that and there's a comment force a check
cashed exception here right so yeah some
I think some of this stuff could be
moved in in some ways gives me more
freedom to innovate to not be part of
gava see right but certainly I think
they're there are a number of things
that would be worthwhile moving in it's
not where I'm probably going to be
spending my energy though probably more
thinking for the next language and part
of it is you know Java now I I beat my
head against changing Java in a few
areas and I do it when there's a good
payoff and I don't think it's good pale
next language I think modern language
hard language and people are going to
make stupid mistakes right i mean that's
this thing I don't think you I don't
think it is either it's not possible or
if it was possible it wouldn't be
desirable to have a programming language
in what you couldn't make stupid
mistakes so you know I mean one of the
things that job is done is it's limited
the impact of errors and this is one of
the things and like C and C++ when you
make a stupid memory error you can
corrupt your memory in subtle ways that
can't be detected until you know far
away and it's very hard where is in Java
a lot of stupid mistakes turn into
runtime exceptions and those are easier
to catch easier to deduce actually so I
think that I'd say that the biggest
problem as far as where we find bugs
needs to better where software calling
the tube better is going to be
concurrency right suddenly everybody is
going to be running on two and four and
eight and sixteen way processors and all
this code that worked fine when you were
running it on a single processor machine
is going to start falling down talk with
cliff click who works at azul systems
and he says you know every time they
have some customer that comes in and
they say well let's see how our software
scales on your system and they run it on
their 384 processor system and the
software immediately falls over and say
hello you've got a crappy machine and
like no you know it's just like okay
let's turn on a couple of switches to
like over synchronize everything
everyone's just fine ah you have a
synchronization problem in your code
right so I think trying to deal with the
fact that within 10 years 8-way and 16
way laptops might be headed our way I
think that trying to figure out that and
figure out like the right way to teach
concurrency and so forth and right
frameworks for concurrency that's a big
problem and a lot of these other things
I mean I haven't talked about all the
problems with web frameworks and so
forth and all the types of errors and so
forth you can make their other questions
okay so i'll be here for lunch anybody
wants to join us for lunch come on up to
the front thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>