<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ZuriHac 2016 - Low-level Haskell: An Interactive Tour Through the STG | Coder Coacher - Coaching Coders</title><meta content="ZuriHac 2016 - Low-level Haskell: An Interactive Tour Through the STG - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ZuriHac 2016 - Low-level Haskell: An Interactive Tour Through the STG</b></h2><h5 class="post__date">2016-09-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-MFk7PIKYsg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello again I'm David and some people
know me from the IRC I'm known as
Coulomb or sometimes pronounced
escutcheon that's why I put this
pronunciation on the slide and today I'm
going to talk about a an immediate
language that is used by Jesse to
compile Haskell programs and the history
of this is basically is some guy on the
internet said again like yeah functional
languages are not what computers run
they like imperative languages and as
functional stuff it's kind of black
magic and you know it maps to something
and now it's not really computer eats so
yeah I didn't like that but I also
didn't have a good counter-argument so I
set out to once again pick up some Titan
Jones paper from 1992 which gives the
the details of the STG which is there a
spineless tagless G machine which is the
low level representation in JC via which
assembly is created yeah so I read this
paper and I thought well this is pretty
well written and I could probably
implement this and like an afternoon and
it turned out it's not so fast it's
still well written well I just
underestimated the task and the
bookkeeping necessary to do all this
thing all these things but for the last
couple of months so I wrote a
implementation of the SVG and
interpreter not a back-end or compiler
just something so as a human reader it's
nice to step through a program and
basically watch the low level version of
Haskell execute and learn a lot about
the laziness and you know why things
land on the heap how what what is a
stacks like sometimes people say well JC
doesn't have a call stack and everybody
goes like glue compile it with other
stack no it's a different kind of stack
and yeah and all these things are kind
of nice to visualize and yeah and what
we're gonna do is first of all and
introduce the the language and give a
couple of translations and Haskell
snippets and another guns and scg and
after that we're going to step through a
couple of beginner programs such as a
boolean operation for example which is
like a 20 step operation until you reach
like a boolean result and watch what
happens on the stack on the heap and
depending on the time we can escalate it
a little bit and do like things like
fold L plus of a list and see whether
it's a heap or the stack that overflows
and how and maybe we'll also see the
naive quicksort inspired algorithm to
sort lists and see how inefficient
quicksort can be yeah so I'm gonna start
out with just a little program we've got
the main function and two innocent
little integers and a plus B's are built
in and we compile this and yeah the
question is what's going to happen and
I'm giving it going to give a short
overview over there the compilation
pipeline just to like pin our location
for this talk down so maybe you can't
quite read this but it's not the point
to read this it's just like to give a
general idea about where we are so up
above here we have the source code and
we parse the source code we rename it
and at this point you may have heard of
the intermediate language called core
which is what people usually write blog
posts about core is like a distribute
haskell so you don't have du notation
anymore it's distributive binds you
don't have nested pattern matching so if
you have a case of just off an
alternative just of a tuple that's the
sugar to a case or the case that points
down into the the cases and all the nice
things are basically already gone but
it's still a typed a very minimal
functional language and you can do a lot
of useful things and there for example
the simplifier is this loop here so you
know that code goes in and it's loops
and improves it then it gets tidied up
we generate an interface file to
like the type signatures for linking and
you know for in-library different
library uses and the actual code is here
it's converted to scg and well I think
the rest we cannot see right now because
of let me see what that works it's not
better not really okay anyway so down
here after we've done all the things
that most people care about in asker
which is like checking safety and all
these things we convert to scg and STG
is still a clearly functional language
but it's a speciality that it also has a
very precise mapping onto real hardware
so we were going to be talking about
stack and the heap and memory addresses
and you know loading stuff whereas in
Haskell I'm not sure whether the report
actually mentions a heap so strictly
speaking I think Haskell doesn't really
have a heap I mean if you find a way to
use a goat to implement your Haskell and
compiler you're allowed to do this but
usually people tend to not do that yeah
and then below this is the code
generation after that we get basically C
- - and then assembly so we're gonna be
at the top level of this scg part here
which is we're not gonna generate code
but we're going to generate SVG code and
from that or interpret that Oh full
screen again this is not supposed to
happen okay better so that's like
problem with the projector resolution so
the bottom is cut off that's why the
isometric yeah so the example I gave
before is this print X plus y which is
obviously three but let's pretend we
don't know that and this translates to
something that you may still be able to
read but it's much more verbose it sees
here a couple of new syntactic forms
here this acts for example here it's a
top level it's called a closure because
all the functions and closures they're
all represented like so we don't
distinguish between
lambda and closure it's just all the
closures just a lambda is sometimes a
closure that doesn't have any free
arguments what you see here is a lambda
parameter like lambda sine just like in
Haskell and after that the list of
parameters and since acts up here
doesn't have any this list it's just
empty and this maps to the Box end of
one if you've heard about boxing that's
like this constructor thing and below
here we have the addition function which
is a verbose way of unpacking the axe
and you get an inch hash of X Prime and
this X prime is not a primitive nth and
you can add them up again and yeah you
can roughly see like where the addition
comes from but there are simpler
examples that are easy to explain for
example if you take the repeat function
which probably everybody knows from this
done preload it takes an element that
gives you the infinite list of that
element just over and over again an SVG
you'd write it like like this so that's
I guess still readable if you're used to
a skill but it's a little bit more
verbose so we see it still takes an
argument but we can't write it on the
left side of the equal sign because
that's basically convenience for the
programmer we map the axe to let rec
which is the same thing as a letter so
it introduces a new binding in Haskell
it's called Lautrec because there's also
let which is non recursive for the
people who know SML maybe but it's not
really important right now and this
excess is defined to be again a lambda
or a closure that map's to contacts to
itself so this kind of ties and not so
you get the infinite infinity but what
you'll notice as you have is these two
arguments here in parentheses and what
this is is actually the list of three
variables in the closure so it's not
like in Haskell like you automatically
have everything in scope from your
parent scopes in STG this is explicit
for different technical reasons for
example is much easier to decide what is
actually in scope because all that is in
scope is what you have in your free
argument list and top-level closures and
it's much easier to implement for
example garbage collection if you have
that kind of information
well and the in part is really the same
thing and I'll give you a couple of more
more comparisons so here you have the
standard implementation of the NAP
function and again slightly more the
both version of that below here so
you're taking a half in a list you see
up here you have to match on the list
and you can't do pattern matching on
balance directly but what you do is you
scrutinize them which means you put them
into a case and case is the thing that
actually does funky evaluation in the
STG so this case forces the list to weak
at normal form by the way this is
different from Haskell where case is not
not necessarily strict so if you case
something and then never demand the
result you're never going to force the
case where the the scrutiny whereas an
STG case unconditionally forces its
argument to weaken normal form and then
continues yeah and then we do pattern
matching as you asked you're familiar
with it's just that the empty list is
called nil and cons because I didn't put
in any you know operator handling and
also the real scg's on all prefix
notation okay and then we have this call
which translates to that block below
here that's a lot more verbose and why
is that well the thing is functions
ironically in SVG cannot take functions
as arguments so you cannot nest
functions what you can do is functions
always take as arguments take atoms and
an atom is either a variable which is
somehow a pointer to the heap or a
primitive value like an unboxing and the
reason for this is that up here you see
um this doesn't really get cold but by
map what this creates is a new thunk on
the heap which is you know do f of X and
when you finally demand the value of F
net f of X then it's going to force that
thunk and update the the value in place
and this is all made explicit down here
so we allocate F X which is the value F
applied to X what we don't force it we
just put it down here in the console
and likewise for the recursive call to
map and one other thing you may notice
we have this double arrow here this is
known as the I used this to represent
the update flag and what this does is
you can mark a closure that evaluates
your value as updatable or non updatable
and updatable means that once you have
forced this closure to week at normal
form for example if you found out the
int value the actual int value and the
closure is sufficiently hard to
calculate it may be useful to not
recalculate it again but just overwrite
the former closure with the result that
it evaluates to so this is how laziness
is implemented you basically say yeah I
don't want to do this twice I already
know the answer we're immutable so might
as well secretly
update memory so yeah we're now mutable
but not observable immutable from the
outside program because we only
substitute things with their normal form
so we can't normal forms yeah and the
final result here example here is our
favorite quicksort a function which uses
quite a lot of syntax sugar so we see
here we pattern match on a tuple in the
let in SVG you can't put a match on
Inlet
all you can do is introduce bindings
pattern matching is purely what case
does let there's only new bindings on
the heap then you have a section here we
don't have sections we don't have infix
operator in the first place so all this
gets expanded and already gets more
complicated in the translation to a core
and then to STG it's another step and
this becomes this slightly involved mess
down here that I'm not going to go
through but you can see kind of like a
correspondence you know and we have this
less or equal than pivot here which is
this function so you can see this leaked
pivot closes over the pivot or takes in
the free variable pivot and takes
another argument which is the anonymous
thing we don't see over here
and it goes on like this it's called
partition and pattern matches on the
result of the petition and recursively
cause you know when go through the stack
and this is just all to introduce you a
little bit to like the way these
programs look like and but maybe it's
not a good good idea to write this
yourself so only I got good thing that
it's only an intermediate language worst
thing to be honest is that its untyped
so I wrote all of these programs by hand
and like a prelude and stuff and the
type errors are just nasty it was kind
of a little bit like JavaScript with
strange syntax and I don't have any
bugger so my debugger is literally
running the program until my machine
tells me nope not going on so yeah
careful reading is the main debugging
tool anyway but all you've seen so far
is probably it so the SVG language is
even smaller than core and up to the
update flag it doesn't offer much new
information so what you have is function
application like F map applied to FX s
you have evaluation and branching put
together in case our case does evaluate
to week at normal form and then react on
the result that you got picking the
right alternative you have what I call
definition as in the slides or let us
responsible for heap allocations and
introducing new bindings lambdas are
lambdas and primitive operations on not
closures but primitive entities and the
only primitives we have our integers yes
that is s e-g yes well there's no other
thing that can do this function
application cannot be nested
but case takes a real expression and the
evaluation rule for case is well jump to
the evaluation of this expression and
remember where the alternatives are
stored and so you can jump back
so yeah case can take arbitrary
expressions but arbitrary expressions
are kind of obviously
on the slide so I mean this is the
expression language we have so yes so
here's a list of things that are not an
S eg just to motivates why you would not
want to do this in production so types
it's really terrible and like I've had
so many singleton lists called Y and I
should have matched and cons y nil but I
couldn't I didn't and machine just halts
and says no because there there's no
rule that applies you don't have nested
patterns so you have to manually and
I'll split up the case and nest of
things which is especially bad if you
want to code fall through patterns but
you may you know branch to a much higher
pattern matching case up again you don't
have guards you have instead you have if
except for instead of if you have
pattern matching on billions you don't
where where it's kind of the same thing
is let's so there's that classes are you
know type thing so you don't have them
they all get resolved to explicit
dictionary cause if the nails are there
already its case matching on boolean x'
instances are for classes which are
types so we don't have that deriving
well when you derive classes don't have
classes don't derive list comprehensions
are also just sugar for I usually fold
build expressions and probably a lot
more basically think of something
convenient it's not that
so yeah it's strictly an intermediate
language with some practice you can
actually write it without many mistakes
but it's tedious and you wouldn't want
to actually like write web framework in
it okay so that's the introduction I'm
now I'm gonna pick a couple of really
small programs and we're gonna step by
step talk about the evaluation of the
programs because until now I only talked
about well the syntax and how the
program looks like which doesn't really
help understanding to be honest is just
to give you a gut feeling like this
could looks a little bit like Haskell
and I I could probably read this
so here I prepare a number of programs
that we can just step through and well
this is a cut-off again this slide is
luckily not oh oh that's just what I
wanted let's see okay so this is the
program prepared and what the Stars
calculates the function P implies Q
which is here implemented as not P or
cube so you see the the main closure is
updatable so it's gonna be overwritten
by the the end result it gives me a
closure or not P which calculates well
not P but I have to name every thunk
explicitly and below that we have the
actual computation that we want to do
which is or two which is the binary or
saw the pipe pipe you know from ASCO and
then not P Q and not for example is
implemented as lambda X 2 case X we
don't have lambda case obviously because
well it's convenient so it matches on
the true and if the true case is reached
we return false and the other way around
on the other branch and the binary or
pattern matches on the first argument if
it's true we can decide you at the end
result is going to be true otherwise we
turn the the second argument well P and
Q are just constants set to true and
false
so we're computing true false implies
true no true implies false and the end
result should be false and we're gonna
do this 17 steps because it's a little
bit boats but yeah we're going to load
this into our machine and now we see a
couple of things that are explicit that
you've probably never seen in Haskell so
up here we have the the code segment
which is kind of the the current
instruction we're evaluating so if you
think in terms of a c debugger or
compiler or interpreter that will be
like the the pointer to the current line
so to speak
like this is the thing we're gonna
evaluate next and in this case we're
going to evaluate the main closure which
is the starting point of a program and
basically the idea behind the program is
reduce the main closure to we cut normal
form and that's your result the stack is
empty and we're going to fill this up in
a couple of steps and then you have the
heap which is a mapping from memory
addresses to milk closures and in front
here you have these markers and they're
not used for evaluation but they are
just for your human guidance like this
tells you it's a function where a
function is a thunk that takes an
argument a closure that takes an
argument a thunk is basically the the
rubbish bin everything that's not a
function or a constructor is a thunk and
in this case we have an updatable thunk
and as you can see this zero address is
the main closure as you seen can see
below here in the global value list so
main points to this value and this value
says calculate or not P and Q and when
you done update me with the resulting
value and down here we are V the other
function so this is not this is our the
or and these are the Global's that we're
implying implying each other employee
fine some nothing okay and so what the
SDG paper basically gives us is a list
of seventeen to nineteen transition
rules that tells us how to react in such
a stage and perform a single step and
right now what we have is a function
application of main - well no arguments
so it's a primitive example of
functional application and the rule says
well if you want to apply the name main
you should look up what main means you
know so what it's gonna do is it's gonna
look in the local variable list your
domain and locals say nope empty but
they're a global variable list luckily
has a main closure here and it points to
this address so we're gonna say well go
to that address basically and that's the
FIR
step so we're going to transition into
the interstate so nothing else happens
if I jump back and forth of bitches are
really just loading the memory address
and now we enter that which means we're
gonna load this sound here into the code
segment so it's gonna move up and we're
gonna start evaluating the main closure
so now we're we're in this state and
we're evaluating a left so we need a new
rule that tells us you know what what do
we do with the left let's work as well
first of all introduce a new binding for
all the things that we're mentioning and
also well you have to put the binding
somewhere which is a new heap closure
that you allocate so in the next step
you're gonna see we're gonna get a local
entry here which is the not P it gets a
new address on the heap and the heap is
gonna get a new new allocation for this
not P closure and now we have it it's
not P now points to this heap address
and that heap address is a thunk that
says not P okay that's next step we have
the or to apply to something and we've
seen this already this is a function
application and previously we didn't
have any arguments so we would just you
know go to the address of or to which in
this case is or to down here a global
variable issed it's gonna be the address
Oh - so next thing we're gonna do is
we're gonna enter Bo to address but we
also have the two arguments and we have
to remember them somehow and it's the
same thing as in other languages we just
put them on the stack but our stack has
different entries so we put them on the
stack as what's called an argument frame
and these are gonna be the two arguments
here so enter is now all do to which was
the or and we have the oh five and oh
four on the stack and O 5 + o4 we can
see down here are the Q from before and
the O 5 is the thunk of not P that we've
created before as you can see we've lost
a couple of names and replaced them with
memory addresses
so this is a common scheme like if you
don't need the name anymore it's it's
gonna be gone somehow which makes it a
little tedious to follow at times yeah
it's a low-level thing so I guess it's
the price you have to pay if you're
looking at this but still you can see
the traditional steps you have to take
anyway now we're entering the o2a2 say
it says I am a function on you two
arguments so if you want to load in you
but I give me two and luckily we have
two arguments here so what's gonna
happen is we load this function here
into the code segment or the functions
body and we're gonna create bindings for
x and y based on these argument frames
so that's what we get x and y I get down
to those two memory addresses and we
load the content of the lambda now the
closure and yeah now it's the first time
we have a case evaluation so the case
rule is first of all next thing you're
gonna do is evaluate the scrutiny and
also in order to know where to jump back
for to continue once you've done
evaluating we're gonna have to push a
new kind of frame onto the stack which
is called a return frame which holds two
things on the list of alternatives and
also the local environment to restore it
later so next thing is gonna be evil X
and a new return frame so there we go
and yeah so the return frame lists the
alternatives and the form a local
environment and you can see we had the
ax in the local environment before but
it was dropped here because it doesn't
appear at all in this and the body of
the lambda and the body of the young
alternatives so we can just discarded
that garbage collection can may be
cleaned up earlier actually this was a
bug in the interpreter and yeah no it's
not anymore okay
evil acts access the address oh five as
you can see here oh five is not peace so
now we're jumping into the naughty part
of the not P or Q that we we try to
evaluate initially
and it's a function application again so
we enter the o5 we have entered O five
and it turns out is another function so
we have to enter again push the P into
the stack oh yeah garbage collection
sorry so well now we lost all references
to this oh five thing if I jump back and
forth or five just doesn't appear
anymore so garbage collection can just
discard it I basically put GC and just
if I had longer programs what he would
just grow and it was unreadable it's not
necessarily performance thing here but
okay now we have function application
again so we're trying to evaluate the
knot we load a case match on the
argument of the knot here evaluating the
scrutiny we're entering the scrutiny and
we found out finally we have something
in weaker normal form so we can find the
return from a case and if we evaluate a
data constructor that just puts us into
the return state state return common
state which is what's going to happen
next and it's applied to no arguments
and I should have deleted those
parentheses but I forgot so it's true
with no constructor arguments and when
you evaluate a return con next thing is
you're going to try to pop a return
frame and based on that to decide where
to continue and it's maybe a little
misleading to call it a return frame
because it sounds like C's return a
little bit but it's not that you're
actually jumping back where you came
from but you're jumping to where you're
gonna continue so you don't do this jump
back and then maybe branch off again
we're gonna do a direct jump and I've
seen examples where this is really
beneficial to to performance I think
somebody you know I see posted a I'm a
really simple sieve of our fasteners and
compared a naive or semi naive low-level
haskell implementation with a c
implementation and because this jump is
missing it had really really nice
performance that's
foundin okay so we return true the true
branch gives us a false so we're gonna
load the false appear evil forces will
transition into the return cone state we
turn concise oh I need to return better
pick a branch and see though I'm in the
fourth branch so I'm gonna load why here
so it's gonna take this branch and
evaluate the why the why as you may
remember was the second argument of the
young of the or that we are initially
trying to calculate so we're entering
the for for is false because we're
trying to compute true lies false so
that's this false we return false and
now what you'll notice is we're trying
to return but we don't have a return
frame so the machine doesn't know where
to return but what it doesn't know that
is that there is an update frame in the
way and I skipped over this in the
beginning but the main closure was
updatable in the beginning that's what
happens when you enter an updatable
closure is first of all you erase it
from the heap and you overwrite it with
a black hole so there are no references
left garbage collection can just ignore
whatever was that and a black hole says
I'm currently in the evaluation but the
program is going to update me later
which is precisely what happens here
birth is false and we have this update
frame here pointing to this address and
this tells the machine to take this
false and just override that part in
memory with the false so yeah this is
where we finally see see license in
action maybe you've seen black holes in
jhc when you got this era that used to
be called loop it was looping non in
brackets angle brackets which is when
you enter a black hole again because
that means a thunk that is currently
being evaluated and is trying to enter
itself again which means you have a
definite infinitely
and the compiler can detect that sort of
non termination and well abort okay so
in this step we see the black hole is
overwritten by a constructor that takes
no arguments and this is just the false
and now we don't have anything more to
do and we transition to a terminal state
because this nothing else to do and
since the stack is empty we probably
finished correctly if the stack wasn't
empty that would have meant yeah we
forgot doing something and the Machine
halted prematurely so yeah this is
probably the the simplest example you
can you can give a simple simplest but
does something but you can already see
most of the rules like there are a
couple of more like how to update a
closure like a function I mean and how
to deal with primitives but other than
that this is basically it and there are
not that many prim ups in this
implementation here GHC has a huge
amount of remarks for you know IO and
array handling and what-have-you but the
main logic like the main haskell thing
you is all there is what you've seen
here like you've really just pattern
matching allocation garbage collection
cleans up we pop you push and that's it
so this could basically like if you
compile your sword and your website this
is at some point looks like that and I
found that pretty amazing if you can
really reduce this to such a small
language and then have it compile
efficiently I'm not going to talk about
cogeneration but yeah so this is what
the C back-end would then evaluate kind
of okay one thing I could mention is all
the cases need to have a default case
because we run type we don't know about
constructors we don't know that true and
false are exhaustive so the STG forces
us or could insert I fall through
pattern that just says I you know
pattern match failed why did this in
this way and all my definitions is
give me a Pullman stacktrace so in case
I'm not a natural not just here for
example it's gonna give me a error not
applied to this bad boot which is adjust
and if you get some really weird errors
you can like follow the heap to where
the error occurred I could also just you
know reach one like a constructor called
error here or something like that the
machine would just say I don't know what
to do with an error I'm gonna halt okay
so we've seen all the types of frames um
yeah I think we can venture onto some
more interesting examples so let's
calculate the length of a list of three
elements spoiler it's gonna be three let
me just check the marshaling okay cool
here's our program again this is our
length function we're delegating to a
primitive loop over a primitive in so
it's sufficiently fast it's kind of what
the standard library does I think we
again have the main closure that is
updatable because of the double arrow it
calculates the length of X's we have the
nil which is the main closure that does
nothing but say on the empty list and
this can be shared among all the
implications of of Lists which is a nice
feature of the hcg because it's untyped
you can share all the middle closures in
core you can't because you have an empty
list of type int and you have an empty
list of type you know char or what have
you and an SVG because you erase all the
types you can just have one nothing for
the entire program and one nil yeah but
you have to be really careful not to
mess up otherwise and this is access and
it's it looks horrid so what it is is
the list of true false and true and well
it looks awful it's probably good that
it does because it makes you realize how
how bad of an array or collection data
structure a list in Haskell actually is
it's a singly linked list of pointers to
pointers to pointers and it's not really
something you want to have as a random
access array or even as something to
loop over if you have fusion it's
alright
without fusion it's it's not really a
suitable data structure it's more of a
control control structure so what does
the list look like well we have the
zeros value which is true and we have
the the cons cell which is the beginning
of the list which is the zero value like
never mind it's a pointer it's gonna be
a pointer to the zero of the value which
is gonna be true and a pointer to the
first cell and the first cell is gonna
be this abomination here which takes two
closed-in arguments like an has two free
variables namely the first value which
is false as you can see here and a
pointer to this second part of the list
so you can explicitly see like how this
is kind of distributed and if we look at
the initial state and run it for a
couple of steps until we actually
evaluate this on this list here and put
it on the heap then we're gonna see like
what the heap layout of Lists actually
is so with your business as usual we
enter we evaluate the length of
cushioned
bunch of bookkeeping until we finally
get far enough so we can see okay now we
know we're gonna leave the list so this
also teaches you about laziness because
we always thought laziness yeah it's
kind of like differing computations no
laziness is brutal it's it's much much
lazier than I would have ever imagined
it's so reluctant to do any work it's
ridiculous like following the sword
example it's just you realize like wow
this is laziness yeah you should try it
out it's I did not expect that to happen
but anyway so now we have a nicely
polluted heap here so we have up here is
our beginning of the list the one cons
points to the O six memory address the o
six memory address is a concern which
points to the one value and the two of
second cons and basically this entire
thing if you stare at it long enough
you're gonna see like no this oh five is
what the upper zeros
here was so this is the other first
entry oh six tells me where to continue
and this goes on to the next part of the
list which is this constructor which is
the two value and then a mill and the
mill is up here and then finally the
list is kind of done so lists are
distributed all over the heap and it
also means that every time you follow a
list in Haskell you basically get a
giant cache miss and you have to look up
and it's not really good for performance
so that's why people often say like
don't use lists even if you ever iterate
through it like step by step you're
always gonna chase pointers and then
chase other pointers to get the actual
values of the list like the contents not
only the continuing yeah and we could
step through this in detail again but I
guess we've seen most things happen so
here we have another case of an update
we return a console but we don't have
anything to return to because we are the
oh three which is the original list
because when I go up a bit you see this
thunk that used to be the list was
updatable here so now that we know what
the first element of the list is we're
gonna overwrite the where is it all
right we're gonna override the oh three
black hole here with this constructor
basically in a little more verbose way
so these are generated variables but
they point to oh five and oh six and if
I go back to the previous step you can
see a five and oh six for these
arguments here actually they're still
there here and then we branch and we cut
case a primitive to find the final
result and here you can see this is case
doing a strict evaluation so this is a
prim up we do the primitive plus of n
which is well the n is zero plus one so
we're now calculating zero length of the
empty list plus one for we found one
element and this continues and continues
until at some point we're gonna
we're kind of looping around again right
so now we're adding 1 to n and then it's
not 1 and we continue basically pattern
matching on the rest of the list until
we find but nil
now we access is still a cons enter and
a relaxes again and this time
access is nil so now we terminate the
recursion of the young F the length
function we branch out and take our
unboxed n which is down here and put it
into a box so we get a proper into out
we return it and now sometimes as
Alliance just nice so nothing moves and
you can see the update so here you have
that case here we have the the update
frame and we write into the a1 address
we write in - of that variable and that
variable is defined to be 3 just as a
side note we don't write in tache of 3
hash in here because that would well the
short story is that would require
cogeneration at runtime we can't do this
so we pre compile this closure that has
an hole open and we fill it with a
number but basically you could imagine
like this is in hash three hash ins kind
of the same thing and we terminate again
so we've successfully calculated that
the length of true false true is 3 which
is great and just 42 steps yeah oh by
the way this is my slide that tells me
not to push a for and I gonna usually do
because I'm used to the workflow on the
presenter yeah oh and we can even see
like in the end down here that's a
computed value which is the 3 which is a
small hack I just put in for that
presentation because otherwise you would
have to like look up uh what did I want
to compute okay it's the main function
main function points to o 1 and O 1 is
this and this is an int of something and
it's three ok see so it's much easier to
just print like the value taken out
yellow this is three don't worry about
it yeah
so other examples basically what I did
is just try out really small programs
and people on the RC you serve problems
with and they wanted like why why is my
heap growing like have this top-level
closure I'm walking over it once like
the Fibonacci series for example I'm
printing each element why is it why is
it not garbage collected and the reason
is the garbage collector just doesn't
track top level closures because you
know they may at some point be needed
again and all these things are answered
if you just write a very small STG
program carefully and then you can just
step through and see see all the
nitty-gritty details as if you had sort
of a debugger and it also teaches you
that all these steps are really really
simple baby steps and it's not magic at
all like you can see each rule and
there's 17 of them rule 18 and 19 are
optimizations and you know that's kind
of what you would have in C&amp;amp;C you have
well I have a function with arguments
what do I do well if you Elliott the
arguments push them onto the stack and
to the function and it's just a little
bit the other way around so basically on
what you've also seen is the difference
between laziness and strictness there's
some really really small design decision
because what we do here in SVG is when
we have a function application we just
push the arguments as they are as you
know point us to somewhere onto the
stack and don't look at them and then we
enter the function which makes us
evaluate the function first until the
function says okay now I'm going to need
two arguments
whereas in C we'll just do it the other
way around you would just look at the
arguments first evaluate them and once
you know the value you enter the actual
function that you did want to call so
it's kind of like when you read the
paper you realize like whoa this is not
a natural at all it's like just an
arbitrary decision to you know do the
the strict evaluation is really just
this tiny small step that that gives you
laziness which is pretty impressive
reading
okay so we have ten minutes left I think
I'm gonna show you the on the folding
examples and because those are probably
the canonical mistakes people do so this
is gonna calculate the sum via fold L
which is a favored overflowing on a
fascicle probably it's not gonna fit on
the screen because it's gonna load but
we're gonna gonna be able to see um like
a couple of things so we step through
until we have the list
I have marshaling just because it's
really tedious to write a list yourself
basically you have to write this
horrible indirection thing by hand in
order to put a value in or provide like
a syntax tree or so I wrote a type class
that tells me to STG a which is
something you can automatically
translate into s e-g definitions so what
happens here actually is this is still
Haskell that expands this and then
Haskell realizes oh I need to use the
two scg implementation for lists so
that's basically a small cogeneration
feature so yeah mrs. Haskell and this is
a something that takes it Haskell lists
and generates me and STG program that I
can then load into the machine and
evaluate so this is purely convenience I
didn't have this in the beginning it's
really worth spending the time on on
marshalling likewise for the taking
values out because if you have a sorted
list the heap is brutal and it's really
nice if you have some some automatic but
that just goes through and tells you
like yeah that's the list okay um I
promise you an awful list which is nice
for you know summing up so we have this
thing and scrolling down the heap is
kind of alright
next step we're gonna allocate a lot of
things and this is our list on the heap
so it's pointers a console pointing to
awake so a and to see and to e and so
it's like this chain of little
interactions that goes all the way down
here until we finally have a concept and
zip nil yeah and we're gonna fold over
this somewhat fast I'm just gonna step
over it but as you may know I've I have
this on a slide actually fold L what's
gonna happen is we zoom in a little bit
what's gonna happen is we're gonna build
a up a thunk in the accumulator
basically walk over the entire list
building up the computation well
eventually you know here is your some
computation but until then we're just
gonna do like record that it's going to
have to be done and thunks lived on the
heap so what this does is just pollute
the heap with in directions of this kind
of sum here when fold L terminates we
get this huge thunk out and then we can
worry about evaluating it so yeah what's
worth noting is that fold out kind of
actually overflow like fidelia's just
calls itself I mean it's it's a tail
recursive function it doesn't build up
anything except for a huge thunk
elsewhere so it's not fold L that
actually overflows it's like the thunk
that we allocate and that thunk is on
the heap so we know the heap and mm a
rumor correctly like step 90 is kind of
the one of the worst offenders right so
we're we have our initial list and down
here we have a lot of thunks that say
evaluate F of the accumulator applied to
Y and if you follow these things F is
going to be the addition function
accumulator is a pointer to a previous
funk so this is the second son which
points to the first sum which is here
and it's again a long list of things and
we're gonna do this 10 times or 11 times
for adding
ten numbers and then the final zero and
when we're done the fold L is gonna here
we have a return of nil so the fold L is
going to terminate because it's well
it's done and now we're gonna evaluate
the accumulator accumulator is the very
last thing we see down here which is a
function application of a function
application of a function application so
what's gonna happen now is we're gonna
stepwise go through all the heap
closures and for each of them we're
gonna allocate something on the stack so
instead of the heap we're gonna blow up
the stack now and you see the return
frames are going to pile up because
they're like this return to this other
Sun when you're done and you know
continue continue continue I don't
remember how far this goes but so we
have 31 stack frames for summing up ten
numbers it's pretty good okay I think
we're done now and shrinking again okay
now it's finally reached the innermost
computation knows how to add the two
numbers so that would be the young o
plus one here calculates that returns
calculators parentheses adds parentheses
that's added to two and just shrink the
stack again and we see the numbers are
shrinking so now we have 15 stack frames
10 9 8 7 6 5 and we're already 300 steps
in so it's not terribly efficient oh
yeah and we can already see like here we
have the final result 55 already
somewhere and we're going to update to
thunks with that because I don't
remember why one of them is the main the
other one is I don't know what probably
the result of the fold L was somehow
updatable I don't remember
anyway constructor application update
garbage collector all the rest update
and further rules apply and we finally
reach our final result 55 and a huge
stack and 55 stacks no 32 stack frames
okay now for comparison we could do the
same thing for fold our
which is a little more efficient in a
way because it only overflows the stack
I think so doesn't do the whole thing
yeah I'm gonna do a heap overflow and
then a stack overflow it's just gonna go
in and one thing I guess that counts as
efficient or more efficient so this is
fold L prime now which is the proper way
of summing up the list and we picture
this what this does is just once you
reach an intermediate result here this
is au plus 1 it says well I promise I'm
going to need this later please evaluate
it right away and don't do all the
bookkeeping because that's the
inefficient part and same thing we load
everything onto memory we go to step 90
which is where the stack pollution
started in the other example we continue
a little bit and we see the stack stays
and like a height of three maybe four or
five I think this may be the maximum
it's three arguments on the stack and
then continues down a bit but we're
never going to blow the stack and
because of the missing updates we're
gonna be a tiny little bit quicker than
the the other case so now we're not 300
something steps but 258 but we're also
reaching 55 and the heap is well it's
was also garbage collected in the other
case I guess but we never had a long
list of thunks down here because we
wouldn't ever allocate like this F X Y
yeah I mean I have a lot of other
examples but they're in their example
modules I didn't intend to show all of
this can give you like just to show you
the result if you do the naive sort of
am like this quicksort II like function
of some randomly permuted list and we
just jump to the end and see
as a marshaling error which is because I
forgot a takes a little bit so we took a
thousand three hundred and fifty-one
steps to sort this list and he pers just
so this is the result of our computation
here and which is stored on the heap and
if you try to follow this this is like
the original list but pointed
differently and you just can't see so
this is why I offers this extraction
thing there and the program is also a
lot longer so this is our final heap
here of all these things like primitive
addition primitive greater than the
partition function and all these things
okay so we're roughly out of time so I'm
gonna shamelessly advertise the project
a little bit more so the goal of this
project was really to have this as
something you can use yourself and also
use for teaching so it's probably a
little condensed in a single talk but I
try to make it in such a way that
basically the the primary design goal is
a good bad error message is a bug so I
have a more verbose mode that explains
like the steps to you if I do like
verbose to here then I get like yeah you
know I enter an updatable closure so I
enter at that address and we extend the
local environment and gives little help
text and there is also a lot of
documentation and a dock and basically
it's it's something you can use to learn
about the haskell evaluation model and
there's also a number of other example
programs like if this implies thing here
and the length and we also have our
friend fibonacci zip with solution which
is an infinitely running program and
because of lazy i/o you can actually
load this into and step through and in a
pager and lots of other programs
and yeah a lot of things that you may
recognize from a compiler such as
garbage collection and marshalling and
stuff like that wrong slide okay so
that's it it's nothing else to continue
and it's on the on hackage as the STG i
project STG interpreter and it's on
cooling /s CGI on github yeah if you
want to try it out I'm around please ask
me about things if you manage to break
it and it's unhelpful please tell me
about it because I I know of what it's
like to not be able to write programs in
this because I would just make Centrex
arrows all the time now I don't anymore
so I can't really judge what what are
typical errors people make but I really
want to have good good messages if you
do that so you can really use it to
teach yourself and maybe to teach
beginners like hey look this is way less
or inefficient this is what happens if
you do fold L prime over fold L stuff
like that okay well thank you
yes how they get STG presentation
looking this cool you're gonna have to
do it manually there is a way to get in
your own code generator generator for
GFC but since I'm so limited I don't
have any i/o handling for example no
primitives for that I don't have strings
of any sorts and a lot of things would
be missing well I just didn't implement
it what you can do is of course
translate it yourself and you're gonna
learn a lot about you know the quirks of
scg for example a common mistake is you
expect things to be in scope when they
aren't because you forgot to put them
into the explicit 3 argument list and
then the Machine would just fault with
them
well this is not in scope and not in
scope usually means you forgot adding
something like that there is a pre load
module hierarchy which implements like
dated of list a lot of data that list
boolean's function composition stuff
like that tuples you can read those
sources and they're basically gonna be
all you all you need to implement your
own programs
so oops you can have a look at those so
freely list this is you know fold our as
at this source which uses a quasi coder
but packaged zoom in a little bit
fold L is this thing and basically you
can't just you know try to imitate the
code and the past is written using try
factor so the error messages should be
somewhat decent at least they they give
you a nice pointer to the error location
and most things that you're gonna need
are already in the pre nude basically
everything I've ever needed is in there
so if you need something else please
implement it send a pull request if you
can't do it ask for help if you don't
want to do it ask me to do it and I may
want to write something like that
yeah so I can't see the preload nodules
but they're a bunch a bunch of them
questions yes boss threads have you had
no trouble following all the jumps can
you imagine doing this with two
evaluated simultaneous I don't think it
would be difficult to do to be honest
you would have to have two to code
segments and just through kind of two
steps at once I don't see any teaching
values coming out of that other than
it's a horrible mess and I'm hoping to
the concept like we might try doing
something like that but so far I've seen
things that I'd rather work on for
making presentation nicer for example a
web front-end would be really nice so
you can see you stuck and heap next to
each other and on transitions you see
like a blink blinking thing so you see a
this changed because I mean the console
is I guess it works but it's not the
best user experience really
and I'm piggybacking on less to like
search for equal equal equals to have a
end button to get to the next step yeah
so I'm open to it but I haven't done it
yet yes yes that's what I mentioned to
grab you can write your own back-end or
your own interpreter there's even a
project I think it's called mini SPG
which is somewhat similar to this that's
a small SOG interpreter and they do have
a back-end for for their thing yeah but
as I mentioned I I have so little so so
little support for primitives that it's
basically I don't think there's much to
gain from this except problems and
throwing lots of error messages like
I don't know how to print please do it
differently yeah what you can do for
inspiration is you can compile a normal
hospital program with - dee-dum SVG I
believe which is going to give you the
actual su G output off gh see that it's
going to use to generate it's full of
annotations so it's really like this is
a nice way to show an intermediate
language for a compiler or G is going to
give you is the full-blown thing that it
uses to compile stuff you can follow
this it's well it's it's a slow process
but it's definitely doable and you can
also have a nice look at what JC does
for optimizations so you can see the
difference between the optimizer
non-optimized thing but what I have here
is completely independent of PHC other
than you know being compiled with it
sorry please D suppress all yeah it
drops a lot but yeah I think I've used
this together with core I dropped a lot
of annotations right you get sanitized
output it's it's certainly going to help
I think yeah I don't really know the SVG
syntax that HD uses to dump so I
designed this myself
because the paper kind of has a little
more noisy syntax with lots of curly
braces and stuff like that so you won't
be able to copy/paste anything out of
THC into here yeah
and juicy obviously has a little
expanded scg for example juicy has three
update flags yeah we could talk about
this later I'm out of time
as I'm told yeah yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>