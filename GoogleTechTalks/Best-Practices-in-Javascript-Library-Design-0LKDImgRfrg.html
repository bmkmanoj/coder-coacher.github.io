<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Best Practices in Javascript Library Design | Coder Coacher - Coaching Coders</title><meta content="Best Practices in Javascript Library Design - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Best Practices in Javascript Library Design</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0LKDImgRfrg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to building a
JavaScript library we're very happy to
have John Resig here with us today
John is a JavaScript evangelist and he
works for Mozilla Corporation and he is
the author of the book Pro JavaScript
techniques he's also the creator and
lead developer of the jQuery JavaScript
library and he is the co-designer of the
fuel JavaScript library which we
included in Firefox 3 is included in
Firefox 3 and he's currently looking in
Cambridge Massachusetts so thank you all
for coming today and here's John I want
to thank everyone for coming out today I
really appreciate it so this little
background of myself
I am believe developer of jQuery I work
for Mozilla so I do I still do jQuery in
the evenings so to speak and Mozilla I'm
right now I'm promoting a JavaScript -
I'm really excited about that but today
I'm here to talk about specifically the
two libraries that have experience in
building and maintaining and how to how
to how to apply what I learned into
building your own JavaScript library so
the first library that became something
that I built was called jQuery released
this early last year and it explicitly
focused on Dom traversal the Dom
traversal was the absolute core of the
library and then there was a bunch of
extra things are in so events and Ajax
animations and the primary focus of the
library it was in having being able to
write really succinct code while and
having a small file size while still
being extensible of via a plug-in
architecture if you've never seen jQuery
script this is some brief examples
jQuery is focused on you can break it
down into two parts the first part is
where you find something the second part
is where you perform an action again
in and so in jQuery are you always
finding something I use CSS selectors
and it finds a set of elements and then
you perform an action against them
so in the top one there you find all
divs that are inside the element that
has an ID of main and you're adding a
class of them or you perform an
animation or binding an event or loading
a document in through Ajax and
personally I'd like to think that we've
that I did something at least decent
with jQuery currently that we have about
25 people working on jQuery and all
various aspects of it looking about a
quarter million visitors per month and
this is on Google Trends here you can
probably guess which one is jQuery and
these are the other popular JavaScript
libraries like prototype and dojo so I
think I think we're doing pretty well
for ourselves at the moment the other
library that I have experience with is
called fuel this is gonna be in Firefox
3 and it's designed for extension
developers currently you can use
JavaScript to develop an extension
interacting with something called xpcom
and I don't know if you who here's had
experience writing an extension it isn't
the most fun thing in the world and it
could be a lot better so fuel is
designed for that it's designed to help
web developers get into writing
extensions so there's all sorts of
helpers for bookmarks events preferences
it's written in pure JavaScript and it's
designed to be extensible here's some
quick examples so here we're going
through all all the Preferences and
finding all the Preferences that are
that have been modified by the user
looking for when the application we're
looking for when Firefox is quitting
when the years of quitting Firefox
opening a new tab and activating it and
then removing all google bookmarks from
your from your bookmark cache
so identity distill JavaScript library
authoring into these topics and I'm
gonna frantically try to cover them all
today
so all the way from your initial design
of when you're designing the API that
you want to implement all the way down
to maintaining the code that you've
written so there's a lot here the first
part of writing a solid API is that I
find to be incredibly important is that
your code should be orthogonal and what
I mean by that is that whenever you
perform an action on an object it should
always be performed everywhere and I
like to use the analogy of you know the
crud and that you in in crud you you can
you know and you know add remove modify
delete and so I'd like to use that when
designing a new API so in fuel every
single object has this same methods and
properties so for every object so for
all bookmarks take to get all bookmarks
you do bookmarks at all to get all
preferences its preferences not all in
order to get to add a new preferences
perhaps stop add or bookmarks that add
it's the same thing
for every single API and using the same
method names in the same conventions so
that way if you know how to do
preferences for example and you want to
do bookmarks there's no learning curve
because since you already know it it's
the same and what I think this is
perfectly important is that for example
in jQuery
when I first implemented it I forgot to
add a remove attribute function and it
was missing literally for months and and
simply because it wasn't as popular as
adding an attribute value but if I had
taken time when I first started to map
out okay if I'm adding it at to
somewhere I should be you know removing
it as well then I probably would've
caught that granted it's in now so
that's not really an issue so it
specifically with fuel I made a grid is
such that it you would have literally
the columns were add remove modified
delete first our every move modify and
you know the rogues were each piece of
functionality so you know our preference
or whatever and then and I can you
literally just fill in the blanks and
say okay have we have we figured this
not yet have we done this one and make
sure that we have complete coverage of
the API
another point when writing a an API is
that you should fear adding new items
into your API you need to keep it as
small as possible because every single
method that you add you're going to have
to support so that means you know that
somewhat indefinitely if you if you add
in a single method you need to be able
to sort of pre cognitively you know
anticipate what users gonna be doing
with that so I think wherever possible
if you can get away with not adding in a
method you should and so in jQuery I at
one point I added in some methods for
CSS helpers so like that top that left
that background and they weren't used a
whole lot but they provided a next I
would I consider to be blow on top of
the API since there was already a CSS
method for manipulating CSS properties
so I added them in and then people are
using them and we had to support them
and then when it came yeah when I
decided that it just weren't necessary
and removed and decided to remove them
it was it was a hassle so I I considered
that you should just seriously think
about anything that goes in and now I'm
very very stingy whenever anything goes
into jQuery you should embrace removing
code wherever possible if there's if
there's and again going back to
supporting that you can see if you're
writing a library you have to support
everything that's in it so you should
whatever possible remove code that could
be handled elsewhere by reduce by
reducing the size your API you make it
easier to learn you decrease your file
size which is especially important in
JavaScript and it makes it generally
makes your code more maintainable
there's less code there it's gonna be
easier to maintain so a long time ago
and jQuery I had implemented a full css3
selector syntax and there's a I don't
know if any of you have ever used css3
selectors it's
really stupid specification and yeah
that there's there's a lot of really bad
stuff in there for example you can
select all children but you can't select
your parent you can select an adjacent
sibling next adjacent sibling but you
can't inject a previous adjacent sibling
it's just like really like they like
they said they did not think orthogonal
they they were like oh let's just select
next and lesson who cares about previous
and it's really frustrating to deal with
so I actually ran a poll where I had
people check off each selector item that
they actually have used and and then at
the end there was a whole bunch that
nobody checked and and there was one
that was lovely and of type I don't know
if anyone's ever heard that one but it
selects the the enth child of a specific
specific type and some people I checked
that and we found out that they could
actually just use and child so we were
able to remove a large chunk of the css3
specification which is good and bad and
that we're no longer completely
compliant but the same time no one was
using them to begin with
so we do start our total API and made
things easier maintained and so in 1.1
additionally this is a separate in
jquery 1.1 we reduced the size of the
api by 47% just removing methods and
stuff that didn't need to be there so so
the metric here was each api item we had
the document so if we had to document
something so we moved 44 47 percent of
what we had the document as well which
is great cuz that means they have to
write less yes
all right so how do you not break think
okay provide an upgrade path the
important point is that you can't just
willy-nilly remove stuff otherwise it's
not not feasible so there's two ways to
do it in with jQuery what we do is if we
change the API so like from 1.0 to 1.1
we change the API and provided a plug-in
on top of 1.1 that gave one 1.0 0.0
users an api that felt like 1.0 another
way to do it is to give 1.0 users an api
that feels like the 1.1 maybe I so I
mean you can point decide which
direction you want to point personally I
think pointing backwards is easier since
the generally the more modern API you
don't wanna be duplicating functionality
and so the by providing a plugin so they
would just use the new api that
directive Beneatha include a backwards
compatibility api and all their old
plugins and all the o code would just
work it nothing like it nothing had
changed at all
yep you probably ate and defined your
versions episode of our Mossad you know
did you identify your verses cleanly and
and obviously and map does maps with
identifying versions so yeah it's pretty
important that you do cleanly identified
so that users know at which point
they're upgrading from or - yeah
so the that's a good point because so
the question was over you know that the
version to the this the minor release is
a version to keep breaking things so it
and that's something we tried to stop
and jQuery a while ago and that anything
so one point one may break something one
point one point one won't break anything
I mean obviously that's a much of a kind
of issue that is other than to say that
maybe in whatever filed that users
directly hotlink - should be something
that's not API changing but give them an
option to to link to the bleeding edge
you know so differentiate between the
stable versus a bleeding edge with API
you should always and this goes back
again to simplifying your api reduce
your api to its most common root and
then what because when you do that you
can have a core function that you can
build on top of so right now in jQuery
1.2 I'm actually removing these three
methods here and so that you could get
for example the first element the first
three element are sorry everything after
the first three elements and everything
before the first two and these were kind
of their kind of clergy
and when I was looking at this I
realized that there's already an awesome
method for this and whose usage is
already known called slice the Jake if
you're not familiar with the jQuery
object it behaves like an array and so
if by implementing a slice method you
can now have a huge amount of power
being able to do things that you
couldn't even do with this and we
reduced our API by 67% consistency you
when writing your API you should be
consistent everywhere obviously this is
easiest if you're if it's one person
writing the API if it's not you should
write up your guidelines ahead of time
so that everyone knows what is expected
and I and I briefed on consistency into
three areas the most obvious is naming
if you're gonna pick a naming convention
you know if you're using camelcase or
not or you know if you like for events
if you want to do dot on click versus
click so in jQuery we do click for no
particular reason other than that's the
convention that we adopted so by doing
that that is what users should expect
going forward argument position so when
someone calls when your methods they
should know and wit in which order to
expect to be able to pass things in so
specifically being passing in an options
object so just an in JavaScript just a
native object that has key value pairs
but no properties and values in jQuery
we always pass it in first always
everywhere in the API and if we ever
have a callback function that's always
the last item in a method so by having
that at least a little bit of convention
users can expect that if they want to
have a callback to something it's always
going to be the last item and they can
expect that and within a callback you
should always make sure that the the
context is the same everywhere so
because if the content is constantly
changing sometimes if it's an object
sometimes if it's an element no one will
know how to interact
so jQuery the context is always refers
to the Dom element with its that is
reference to so implementation so this
is the what I consider to be the
progressed the evolution of a JavaScript
coder so when so it goes something like
when someone's just starting out they at
least a programmer coming into
JavaScript it's something like oh man
everything is a reference this is great
you know it's it's objects I can
understand this you know I understand
how this works and then then they
realize that they can do object-oriented
code and you know just it's sort of
quirky kind understanding it and then
suddenly it clicks how to do object
prototypes and then you know there's you
can see this you can usually tell how
someone's advanced through JavaScript
whether you hit some point in there like
prototypes I understand and then they
tried and they do everything with object
prototypes and then I think the the
final progression of a JavaScript coder
is when they realize that although their
stuffs good but it's all about closures
and that there's net their code
distantly becomes this this giant
closure minefield of different scopes
and contexts and so there's there's a
couple quite a few coders who I really
aspire who have you know fantastic use
of closures in their code and it's just
really a thing of beauty i well so
teaching them list first that would
probably break their soul but but I do
cuz they're functional programming to be
an absolutely an imperative concept and
that yeah and is it
but the saving that one alright so the
so for especially for functional
programming that understanding closures
I not only doesn't make you a better
programmer it especially makes you a
better JavaScript programmer and so this
snippet here having an anonymous
function wrapped and executed is one of
the most powerful constructs that you
can use in JavaScript it gives you just
an anonymous scope that you can interact
in and you can define local local
variables within this scope that isn't
accessible outside and you will see this
used again and again and in encode and
in different variations but it's really
important and it sort of transfers down
to other concepts so like being able to
write you know essentially macros of up
to some degree so having you know
generating custom functions on the fly
so here we are generating three new
jQuery methods dynamically that
encapsulate another piece of
functionality and this is all using
closures because this name here is
within this scope and here's another
snippet I like this one a lot it's just
is similar to the last one with this
difference so you can call functions in
JavaScript within a different context
and what happens is is that whenever you
call an anonymous function in JavaScript
it's default context is the window
object the global object which doesn't
really help you so if you call it with
the call method and you said its context
to this you now have a context that's
equal to the current scope and you can
have local variables so I think I
consider this being deceptively powerful
and until at least until JavaScript 2
comes along we're at least now with a
JavaScript 1.7 you can have all let
statements and you can have locally
defined variables
I think this is a neat little self
that'll hold you over
singham yeah you mean a meaning to like
a block yeah yep and so you can exactly
do so so in JavaScript 1.7 is there so
there's a normal let you know a
statement and then you can also do let
and then it'll be within this block so
it within this within this within this
block here this variable will be equal
to 100 and supports to this one which
will be equal to it within the whole the
whole block encapsulation this is a
really important point for developing
reusable and embeddable jobs you know
the JavaScript libraries so if you want
to want your library to be able to live
with other libraries and another random
pieces of code you really need to do
this because you don't want your code
escaping and potentially harming other
people's code so I'll be getting more
into this in a second but you you you
just want to make sure that nothing of
yours no variables that you define leak
out and affect how other people write
since since of JavaScript you really can
you can just blow away anyone else's
code and the so a nice part of this is
that so if you wrap this construct again
it comes up again you wrap your entire
library in it and then you define
variables within that scope compressors
can make optimizations so for example
dojo is compressor it looks at variables
within a scope that don't ago and they
can do rewriting of them so that the
variable names can change from you know
my long variable name into you know a
and then so within that scope you can
use an optimized variable name that
compresses
really nicely into a minified code name
spacing this name spacing has the
potential to become very verbose and
it's really easy to get lost some
libraries do this better than others and
but the but the goal of name spacing is
that you want to use as few global
variables as possible the less global
variables that you use and the less that
you modify global objects the better
because your code will would just be a
better citizen of the page that you're
currently in right now there's a couple
libraries that do one namespace fairly
well dojo yahoo UI jquery mochi kit is a
little bit I seen that they have a one
global name space but they automatically
introduce everything into the global
namespace and then you have to like
retracted again it's a little bit weird
but dojo UI and jQuery at least do
pretty cleanly and these are some
questions that I like to ask and that it
says can my code codes this with other
random code on this site this is usually
the easiest one to obtain and that you
want to make sure that none of your code
blows away anyone else's code or affects
anyone else's code and you also want to
make sure that no one else is random
code no matter how badly it's written
will affect your code so if they extend
the object prototype and you you need to
still work I mean you can tell people
not to do it but it's gonna happen and
you just need to you need to be safe the
other question okay these are some
questions now that I'm starting to look
at because I think they're particularly
interesting so chemic Oh coexist with
other copies of my own library so if you
include jQuery and then you include your
jQuery 1.1 include jQuery 1.2 can you
use them together on the same page will
they blow you know will they overwrite
each other's methods that's a harder
problem to tackle it's definitely
feasible and so that's something I'm
looking at and I want to get that
inference jQuery one point to the other
question is can my co be embedded inside
another namespace so for example could
it could I take the jQuery namespace
and copy into let's say dojos namespace
so I could do now do dojo jQuery and no
library can handle that because it you
they depend on special contexts as being
set and special you know naming beings
available it's it's it's also a hard
problem and again I'm a little this
perform but you should never extend
native objects ever and this is it's
almost a philosophical point right now
is that you know the prototype library
it's fantastic library absolutely
fantastic the developers are really
stand-up and they but they enjoy
extending native objects that's just how
how they roll so but I I don't like it
in that it's it's you know they used to
have Audrey prototype they remove that
pretty early and that extending all
objects in JavaScript it's incredibly
dangerous that you can you can no longer
iterate through an object's keys without
getting these random other chunks of
code in but they're hitting problems now
but I think it's absolutely imperative
that in a JavaScript library that it
should first work across browser first
second it should have functionality
meaning that if your library to nothing
but find elements by class name but it
worked in every browser that would be a
perfect library in that it achieves the
goal perfectly for all people but if you
can never if there's some piece of
functionality that you've implemented
where you're just like it doesn't work
in Safari sorry you know I don't think
it's valid to claim that that is a valid
piece of functionality of your library
if you just you know if it's not
supported and in that case so a
prototype they extend native HTML
elements so the extent are the the HTML
element prototype to add additional
methods
whether that doesn't work and Internet
Explorer so they have these crazy
shenanigans so you have to you know yet
to perform in order to you have to like
double wrap your objects in order to
traverse around and it's very in elegant
and I don't think that's a valid
solution because it's just yeah so and
and additionally another issue that's
coming up now is in adding methods to
global objects so specifically there's a
new get elements by class name that's
part of html5 and we implemented it in
Firefox 3 so the uh we Mozilla Firefox 3
and the problem is is that prototype
also implements that method and and so
they both first they were blowing away
the native method which is like a
hundred times faster
yeah it just completely blows him away
so what they did what they then started
to do was is they check to see if the
method existed or not and if it did it
if it already existed they didn't touch
it which is good but the problem was is
that people then wrote code that relied
on the return value of what prototype
did so prototype returned a modified
object that you could call a dot each
method on and because that dot each
method no longer worked it was breaking
code again is this crazy world and this
is why I don't like extending native
objects at all because you just have the
potential for these weird mishaps to
occur that you don't expect and at the
same time you know I think another
another one was that I think probably
used to implement a raid out for each
and so when it came in and there's a
native for each and Firefox too and the
native forage is very fast it's
lightning fast but the thing is is that
if you wanted to take advantage of that
and someone else had already included
prototype on the page you would end up
using prototypes one because it existed
which was so slow you don't want to use
that slow one because you can do better
so it again it doesn't just fall back to
piece missing pieces of functionality it
also falls back
to speed issues so perform type checking
I say I say this one but I do it very
sparingly and jQuery a little bit more
so in fuel well in fuel you have
everything's implemented through an IDL
interface and I don't know if anyone's
had to deal with IDL or specially the
IBL with JavaScript it is horrible
because you use essentially you can only
have specific types come in and you
essentially lose all the beautiful
you know variable length arguments that
you come to love in JavaScript so anyway
by having type checking
you can make your API very fault
resistant so if a user sends in a null
or an undefined by accident you can
handle that gracefully and hopefully
give them an error message at least
point them in the right direction
another case is where a user passes in
something that they expect to work for
example passing a number into the CSS
function so patio setting of you know
the left or the height to a number
browsers behave a little bit differently
with that so you can turn that into a
string and add a pixel value now the
point at which I I sometimes disagree
with other people is around error
messages they are obviously immensely
useful for people to debug with but
they're also very byte costly you know
they oh you could be transferring many
many K of just error messages down the
pipe and I think that that sort of
functionality is better left to a
debugging extension so providing your
library and you get throw in a debugging
extension and suddenly you get all these
wonderful error messages
exactly so the question was why wanted
to pull the air messages in with a XML
HTTP request that's valid too I mean I
definitely considered that to be an
option that you would turn on when
you're in a debugging mode or something
yeah yeah so there's no I don't really
consider to be any reason to pass along
error messages another tip that I like
so tweaking your object constructor I
use this one in jQuery so jQuery itself
is is an object and you can instantiate
it but if you throw this here on the top
so window is the global object and you
check to see if the context is equal to
the global object it that is the case
when you call jquery like this so what
that does now is that instead of just
trying to run jquery like a normal
function it goes back and instantiates
itself and returns that result so now so
now this statement and jquery becomes
equivalent to instantiating it and that
it makes for shorter code you know users
don't have to worry about that but as a
developer you still get all the benefits
of having this you know this fast
ascension another quick tip for error
messages you should never gobble air
messages so if a user causes an error to
occur in their code especially in a
callback
so an ajax call back or you know a loop
and a function in a loop never gobble
the user's error messages
it seems really tempting in that you
don't want there to be bad things
happening on the page or whatever but
you should just ignore that and be able
to let things pass through and I
considered I think you should even do
this with your code with the library
code and that if an error occurs in the
library
don't don't consume it you just let it
go free unless you're including error
messages of some sort you should just
let it pass through and at least give
people the hope of debugging your code
so complex applications
I guess that are there's excited to be a
couple solutions to complex applications
the most important of which is
extensibility and I think that if you
want to write good code you should keep
a light score of functionality and allow
users to add in additional pieces of
functionality easily and we do that and
know just about every aspect of jQuery
because jQuery is you know just want to
keep it small and light and let other
people add in what they want you know if
they want crazy bouncing animation with
some accordion widget you know that's
fine they can include that but we don't
we won't include that natively so just
as an example here's three different
ways to extend jQuery the top one is the
most common one this is a typical jQuery
plug-in you're adding a new method into
the jQuery object your own function and
you can now users can use it like any
other jQuery method you can add in
custom selectors so that users can now
use your own custom selector and you can
add in your own easing animations so if
you want to have it bounce and bounce
animation you can do that and another
really important side effect of this is
that it fosters a community so if you
know if users you know can release their
own code and get recognition for it you
know that's fantastic you know you saw a
lot of that happen in the Perl community
around Sipan being able to release code
and maintain it and so we're doing that
now with jQuery we have a couple hundred
plugins of users just contributing out
so a lot of people consider
object-oriented code to be the solution
for writing complex applications I get
this time and time again people will
look at jQuery coming from typically the
Java world and they'll look and they're
like oh what's this it's like a
one-liner and you know why why not have
an object to you know to use that here
I know object-oriented code it is an
answer I don't think it's the answer
especially within the world of
JavaScript it's because you have such
powerful constructs you know functional
language constructs
that it's McKee started to be you know a
perfect solution by any stretch at least
not until JavaScript to when there's
packages and classes and all sorts of
nice things what I consider to be a
better solution is the use of first
plugins but second secondary having
custom events message passing
so between one object to another is
absolutely fundamental to having a
library that is usable in a complex
situation and I can't really stress that
enough other than to say that that all
these libraries now dojo was a pretty
big pioneer in this and that all their
their library and all the things that
snap into their library use custom
events to communicate it's pretty
elegant jQuery we use this and where
we've had custom event for a long time
but we're getting better at
understanding them and how to apply them
yahoo UI has them in prototype just
added them the new 1.6 release and so
this way you can now for example your
component can listen for a drag event
something that Norden doesn't normally
exist and you can now trigger a refresh
event on a table or something so dealing
with browser bugs so quirks mode quirks
mode the cooks mode the website written
by PPK fantastic resource i mean to help
me so much back in the you know the when
i was first learning javascript but the
fundamental problem with it is that it
explains where a problem exists a
specific browser buggy says so it'll say
that the offset top method doesn't wait
quite work quite properly in this
browser and
it's good to know but it doesn't tell
you how to solve a general-purpose
problem for example how do you get the
computed style of an element in a
cross-browser manner it doesn't explain
that it explains a particular method of
an API and I what I think is much more
interesting and much harder is
understanding these meta problems these
things that encompass multiple api's so
specifically looking at wind how to
solve a problem set there's a couple
problem sets that are already solved
what I consider to be solved and that is
in the area of Dom events and Dom
traversal those are pretty well
thought-out and you can find a lot of
good documentation on that but there's a
lot of them that still require just a
tremendous amount of hard work so the
problem of getting an attribute value
out of an element that ones being very
close to being solved I think the
prototype guys are making good progress
we're making some good progress right
now and the one that I haven't seen
anyone tackle yet but we're starting to
now is getting a computed style so
figuring out what how an element
currently looks and it is just a
fantastically hard problem because no
browser has even attempted to
standardize on anything since there is
nothing to standardize on and so what
I've what I've done in these cases is to
well is to in your test suite permute
just hundreds of possible values so it
tests against and so I'm tackling this
problem now getting a computer style and
looking at you know a dozen different
types of elements are they are they
display:none are they visible or you
know are they you know are they a block
you know are they within another hidden
element is you know is they you know are
they normally supposed to be in line is
just using so using that set of values I
think comparing you know the color
attribute the background color the you
know height the width and and in you
permute all these out you have you know
such a couple hundred test cases to work
with so do expect if you had to work in
presence window size changes render time
so Amita so at the at the time at which
you call it yes absolutely yep yep and
so I mean there's a lot of them that are
that the most mind-boggling one is in
Safari two and three and so it's a party
to if you call the get computed style
element or sorry a function you can't
it's null and you're like why is it null
it's supposed to be there and that's
because when you call it on an element
that is either displayed on or within an
element that is displayed on it just
it's known for whatever reason so Safari
three came out and I was all excited I'm
like oh great they're fixing this
problem because I know they're gonna fix
this problem because it's so annoying
and so I go and I call get get computer
style it exists I'm so happy and so I go
to get the value and it's undefined and
they so they implemented the interface
but they just made it return undefined
now and the problem is is that
attributes can return undefined normally
and so now there's no way to
differentiate between it between when it
should be returning undefined and when
it shouldn't be returning undefined so
the only way so my horrible abomination
was to get the computed style of color
since there'll always be a color and
check to see if it exists and if it does
then that means that we're outside of an
element that is display:none I could go
on and talk about horrible hacks I could
do many presentations on that but so
yeah
the at least this is getting closer to
being solved but again that's the case
where I think you just need to have an
immense test case one that you can't
write by hand
one that you have to literally permute
out and then the problem comes up of
when you do find a fix how do you know
when defined or you'll win to run that
fix this is the progression that I see
users when they start they always check
user agent it's the easiest thing oh you
know is msie no one else could ever
report msie and then then you know the
the common secondary solution that's
proposed by people like PPK is to check
to see but with a specific method exists
which is great it works for get element
ID things like that then if then you
start to think well maybe look at them
because there aren't quite some problems
that fit into that nice method mole like
well maybe I'll think of an elegant
solution and then you just realize that
you should probably just be checking the
user agent anyway because you know
especially when you're trying to tackle
issues like rendering errors it's you
you just can't you can't check that with
an object there is no way to say you
know are you quirky when you render this
thing you know you you have to do checks
like that and the issue is is that you
can't rely you can't say oh well oh just
others check to see if a specific method
exists that only exists Internet
Explorer 7 what if another browser comes
along and implements that object
well what if how about what if a library
comes along and implements that object
because that is bound to happen and
it'll drive you insane
user agent isn't perfect I'm not saying
it is but it'll get you close
so documentation
I mean it goes without saying that
documentation is essential but what I
think is really important is something
that we've explored is specifically
structured documentation so providing a
solid format for how your documentation
to be written either you have some sort
of you know Java doc or in the and in
the case of jQuery we use something akin
to something called a script doc but
we've since migrated and where we had an
XML format but what's nice about this is
when you have a structured format you
can change it into other structure
formats XML JSON and you can give it to
your users because you're not gonna
write the best API browser I don't think
anyone has a perfect API browser because
everyone wants to look at api's in a
different way so what we did what I did
with jQuery is is I built an XML format
that I pumped the API out and and people
took that and they made their own
browsers so now there's literally a
proliferation of other API browsers
cheat sheets that are automatically
computed you made with XSLT people made
desktop widgets doing translations and
all of this is because it's just as a
structured format to work with and these
people can literally just pull down the
latest XML file and update their widget
or their cheat sheet instantly because
then you know that they don't have to
call through the documentation and copy
and paste and so it's literally an API
for your API giving people the ability
to you know expand how the API is shown
is immensely powerful what H is XML not
ideal IDL isn't expressive enough to
express what I want in JavaScript that's
the short answer
yep
yeah the XML form we currently have this
and standardize on anything something
because I don't know one has looked at
the just because javascript is not Java
and you can't you know you can't
document JavaScript using Java doc no
matter how hard you try what you unless
you write really I when I could serve in
elegant JavaScript so yeah that's a
whole other issue but when we've been
trying to tackle and the other issue so
the issue with script dr. J s doc is
that you can't okay so let's say you
want to document what the context is of
a callback function
what if you want to document the
arguments of a callback function that
gets passed to a method but if you want
to document properties that get passed
into an object I mean and these are all
immensely common cases for JavaScript
libraries and it's just it's people just
ignore it
so yeah the and even people who are at
the wickedest considered to be like the
forefront so like the aptana
ide you know that they they're only part
of the way there it's just it's a large
issue so the other issue is you know if
you're gonna have your documentation
that structure format and you want
people to help you want people you'll
get you're gonna make spelling mistakes
you're gonna make code mistakes you and
but people can come in and help you out
so I guess there's the current solution
I have for this is to put it in a wiki
and then you have yeah the saying is is
now you have two problems but if we get
the at least with a wiki my current
tactic is to use structured templating
and as an aside if you've ever done
media wiki templating that'll that'll do
something to you so anyway so do you
structure templating and use that to
generate structured documentation I'm
running out of time so I got hurting so
leverage only specifically write the
documentation that will help your users
than
and that'll help the library the most
because your time is limited so you
should focus on this the best stuff
first this is a rough order that has so
start with the user API that's
definitely most important and then and
then eventually you start to getting
writing documentation on how to write
documentation so that other people can
come in and know how to do it and it'll
self-perpetuate and finally it finally
for documentation you need there's no
documentation you really just have to
buckle down and do it yourself
there's really no other way so I mean
it's self-explanatory you just have to
do it
testing testing is absolutely essential
and I say don't trust any library that
doesn't have a test suite any JavaScript
library especially because of all the
fantastically weird browser bugs that
exist I just I can't do it knowing how
many bugs I've caught with the jQuery
test we it puts fear into my heart what
I see ones that don't have it you know
so currently put a typo in catch a query
Yahoo just got one right now and sweet
they're pretty easy make sure it passes
and all browsers handle asynchronous
tests test-driven development is
incredibly important we use it in jQuery
all the time we write our tests first so
they start failing and then we read it
we then encourage us to make a not fail
so we write the implementation and and
it would be great if there was a way to
have a pre-commit hook in google code
because then we could check to see if
we're passing still before we come in
just saying
Oh guess I recently wrote a pure
JavaScript Dom that runs in Rhino so
that you can end it run and it can run
the full jQuery library there's some
more information about that on my blog
won't go to it detail here
oh so the future testing is I sort of be
some multi browser testing so that you
can take a patch push it to the code
base and it will distribute out into
everyone's browser
everyone who's logged in and it'll come
back with all the test results and to
come back to you so you can essentially
distribute your load and your test cases
and I consider this to be as the future
and we're starting to explore that now
we'll see what it leads to so
maintenance make it easy to tackle new
bugs you should interact with community
a lot and most importantly they this is
absolutely important is that you need to
maintain the focus of your library and
even if it's nothing more than one semi
benevolent dictator standing over the
project saying no that shouldn't go in
or no that has to be named that way you
have to do it otherwise you're gonna get
I mean just a garbled mess of I don't
know factory generators or something I
mean you just you need to you need to
have oversight and you need to maintain
focus and so that's why double jQuery
I've you know every time someone tries
to commit I put them through this
horrible gauntlet and but I think it
maintains the focus of the library
pretty well so I want to open up the
questions in like the couple minutes
that have left so we have a mic here for
questions
well see your library like seems very
nice but is it more or less targeted to
the firefox and wouldn't actually be
well reasonable to use it say on a cell
phone
jQuery yeah no no Jake where's cross
browser complete a fuel is Firefox on
yes jQuery is is into Safari two three I
six seven Firefox one five two opera
yeah and my cell phones supports ie 4
sorry I'm not going there
yes how do you filter the noise in the
community is that something you guys
trouble with like just loud vocal
minority or stuff like that um you just
saw it it's hard you have to use your
discretion and I mean in that that's
really the advantage of you having a
plug-in architecture is that you can say
go make it a plug-in if your plugin
becomes popular then we'll bring it back
in you know you tell them to prove
themselves first and you know if think
because there's a lot of people who are
like oh man you know the I wish I had
these crazy advanced animations of
jQuery no we're not even wish they're
saying that it's a yeah they must be in
jQuery and you just have to say no you
know because even you know especially
for file size concerns but I mean say
you can say here to go use this plugin
so the question regarding the dojo route
and having multiple build sets getting
just a build set you need you can do
that right now in the jquery build
system yeah there's a make file you can
tailor it but we definitely want
something more advanced and we're
working on it right now so that you can
pick and choose what parts of jQuery not
that jQuery is here just 20k but at
least pick and choose what plugins you
want to include into your custom build
but yeah that's definitely definitely
concerned okay do you think that there
will ever be a time when library
development like this sort of isn't
necessary anymore or do you actually
think that the ecosystem of libraries is
a good way for advancing state of the
art so will it ever change no not in any
future that I foresee that there's
there's no incentive for certain
browsers to implement standardization it
isn't it simply isn't market beneficial
for them so why should they become
standards compliant because then people
can go elsewhere and and so there's
always many differences no matter what
and even if there is in differences
people will implement their own special
methods let's say like get elements by
class name which maybe maybe only a
couple browsers will implement but you
want a special case to you know to see
if that exists and if it does to use
that fast method if it doesn't use this
other method you know it's just it's not
going away and and doesn't help the
ecosystem definitely I mean I've been
doing css3 I've been using css3 now for
about two years which is about two years
more than anyone who's ever written the
css3 specification it's it's yeah so I
can better yes
so how my parents something like jQuery
does something like Google web toolkit
completely different ballgame so jQuery
is pure JavaScript client-side only and
you know they have some Ajax Eid bits to
communicate but there isn't any you know
object persistence you know modify an
object in the server go to the client
it's yeah it's significantly different
in a lot of ways no questions oh wait
yeah just out of curiosity do you have
any information on what's the largest
size project that jQuery is being used
in in terms of size of development team
and size of codebase roughly development
team and codebase I guess to rephrase
the question is jQuery designed more for
small one-off projects or do you think
it would be useful for a project that is
like 100 developers working on some
massive system I don't know I mean it
it's definitely I don't know of any
hundred developer teams that are using
jQuery but it is used the C MSNBC Digg
IBM Oracle Cisco there's there's a
massive list on the website but the most
of those teams
I'd say largest maybe a dozen
I don't yeah I don't know of any massive
teams like that otherwise I think we
would have been seeing contributions
coming back from them say so the thought
of a 100% JavaScript project is
threatening and I don't know I it's very
different definitely but yeah I like it
and it it provides a different level of
freedom and especially it brings in
people from all backgrounds we saw on
jQuery we have
people coming from ColdFusion PHP Ruby
pearl I mean literally they all write
different languages in the day to day
job and but they all come in and there
and they but that javascript is this
common playground for developers and the
you know it's you know it's like no
man's land you know where they are gonna
you know parlay and its III I like it I
like the language a lot and I think it
and I think we have time for one more
question
okay okay so distributed testing so what
we're looking at with that right now is
so the users would be essentially
sitting on a page that auto refresh is
or you know or pose an AJAX chunk of
tests and just runs you know those that
batch of tests you know with that
specific version of let's say jQuery and
then reports back how many tests passed
or failed
you know just the results so we do this
a little bit right now in Mozilla we
have a we we imported the the mochi kit
test week we call it mochi test and one
of the things that it is I brought in
all the JavaScript library test Suites
and I had them running in these little
mini web server on mochi tests so the
test suite runs and then Ajax back the
the results and that is aggregated into
the full Mozilla build system so every
time you now when you do a commit to
make a change the Firefox it's you're
running against mochi kit prototype
Script oculus jQuery they're all their
test beats so I mean it's it's still
pretty experimental but I think we at
least had the foundation well what I
ultimately want to get to is where any
layperson can be running this in their
browser
so then they can load up random old
version of conqueror you know and they
can take a test but
that means something to them thanks John</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>