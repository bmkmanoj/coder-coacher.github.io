<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Aspect-Oriented Modeling - what it is and what it's good for | Coder Coacher - Coaching Coders</title><meta content="Aspect-Oriented Modeling - what it is and what it's good for - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Aspect-Oriented Modeling - what it is and what it's good for</b></h2><h5 class="post__date">2008-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tzjRr3usV6I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">next we have John Whittle and he's going
to talk about aspect-oriented modeling
ok thanks John and so just before we
start I just want to say that this is
work that we've been doing over the last
couple of years now and some credits to
the following people a lot of the
tooling obviously was done by some very
good students and so forth so this is
what I'm going to talk about today so
I'm gonna try this is kind of a talk in
multiple parts in a sense and it's going
to be you know not delving too much into
the technical detail but feel free to
ask any technical questions and so I'm
gonna start off by just giving a very
brief introduction to what
aspect-oriented modeling is and that
specifically aspect-oriented modeling as
opposed to aspect oriented programming
and then gonna talk about what my kind
of evaluation of the current state of
the art is in a om and then present our
particular approach which is called
matter for modeling aspects using
transformations which of course I'm
going to claim overcomes the drawbacks
of the current state of the art and then
I'm going to talk about some more recent
work that we've been doing to model some
security concerns and using
aspect-oriented modeling as a key
component of that ok so what is
aspect-oriented modeling well we all
know that you know nowadays we're
building much larger much more complex
much more distributed systems and these
very very large systems have lots of
concerns that kind of compete with each
other you know you've got pervasiveness
you've got security you've got
persistence you've got you know auditing
and tracking and all the all these kinds
of concerns that you know these very
very large systems have to deal with and
so aspect oriented software development
is essentially an attempt to modularize
those concerns that we can't modularize
very well with traditional
object-oriented languages and these are
called cross-cutting concerns so you
know security is a good example because
if you want to implement you know
security you might have an effect on
multiple different modules and it's and
it's not easy with you know traditional
techniques to have them that
represented in one place so
traditionally when we talk about
aspect-oriented software development we
note that there's really two fundamental
problems that these cross-cutting
concerns can cause if they're not
handled properly and one is concerned
scattering and one is concerned tangling
so concern scattering is where you've
got one property or one concern that
ends up being represented in many
different places you know in many
different modules or in many different
objects or in many different UML
diagrams depending on what your
representation is and of course that's
not good because you know it leads to
problems with maintaining and reusing
that particular concern and the other
one that's perhaps not as obvious but
it's just as important is concerned
tangling and that's where you've got one
one unit of decomposition that really
contains multiple things it's really
doing multiple things and and so if you
just look at it it's kind of hard to see
exactly what it's doing because it's
doing a whole bunch of stuff so a OSD is
it's really an attempt to try and avoid
these problems of scattering and
tangling bye-bye you know representing
cross-cutting concerns as their own kind
of decompositional unit and now of
course aspect-oriented program is
programming is quite well understood now
it's it's you know it's it's getting to
the point of maturity and it's it's it's
used in industry but this talk is not
about programming this talk is about
modeling and so I want to make the point
that you know aspects are important not
only at the coding level but also at
other stages of the software lifecycle
as well and so by my modeling here I
really you know you'll see from my
examples later I'll really be talking
about your male models but you can you
know you can interpret that word much
more generally to mean you know
requirements and architecture and
analysis and design and there's actually
been a whole bunch of work over the last
few years and they're in the academic
community on how do you best deal with
these aspects at the modeling level and
some colleagues of mine Lancaster for
example of very much focused on
requirements I have tended to me down
down in this space here okay so lots of
work and if I miss anybody's name there
it's not a personal
front it's just my kind of
stream-of-consciousness of you know
picking out the key players okay
so my kind of general argument in the in
this talk is that this there's really
been two kinds of approaches to doing
aspect oriented modeling and I'll call
them the aspectj like approach and the
hyper j like approach which has
analogies for those of you who know with
AOP languages so in the aspect j like
approach what people essentially try to
do is to say well you know aspect j is a
very well-known aspect to our into
programming language it has these this
notion of point cuts and it has these
notion of before/after and around
advices and you know everybody seems to
like it and it's very popular so why
don't we try and take those concepts and
do the same thing that was done for java
code at the modeling level and your male
models for example so if you were doing
this for state charts for example you
might say well what are my point cuts in
state charts and they might be
transitions in a state chart and so
that's where I'm allowed to you know
insert or modify behavior and what would
my aspects be well in a kind of similar
aspect J like where you'd say well every
time a transition fires I can insert
something before after and around that
transition so that's that's kind of one
broad class of approaches the other
broad class of approaches is more is
more multi-dimensional in a sense
so here what people have done is to say
well it's really a broader problem of
how you compose multiple models you know
let's suppose that you have to mod two
models and you you know possibly develop
by different teams and you just want to
bring them together and what's the best
way to do that and and typically the way
these approaches go is that they have
some kind of merge algorithm that will
look at the two models and will try to
have some kind of a similarity metric to
say well you know this state over here
is really the same status as that state
in that model over there and so when I
merge these things together what I need
to do is to make those two states the
same thing and so they have some
criteria for for saying what it means to
be the same so for example again with
state charts you might merge states that
have the same name okay so the question
becomes if you
if you look at this fairly large body of
work that you know you can broadly
categorize into these two categories
does it doesn't really work in practice
and so to try and answer this question I
had to I had two options I could sit
down in my in my ivory tower and you
know prophesize that of course this
doesn't work and of course you know I
will sit and come up with the the
wonderful best solution ever or I could
actually look at some real examples and
you know although as an academic it was
very tempting to follow the first path I
decided to follow the second path there
and actually look at some real examples
so what we did if we just really looked
at one example when we looked at some
some real models these were models that
were developed by students and not you
know people working in companies but we
try to look at the types of aspect
composition that you would need in
practice and then we tried to answer the
question of whether existing methods are
really sufficient or not it was a study
that was specifically focusing on
aspect-oriented state charts but that's
not too important for the purposes of
this talk what what is important is the
results and the results as you see on
the next slide are based on four
categories of compositions that we
identified so these categories of
compositions are identified according to
how complex the composition is so in the
first category which is called
one-to-one state matching it's where you
have to state charts and it turns out
that you can just apply a simple
one-to-one matching algorithm on the
name of the states and compose them and
you get the result that you want and a
little bit more complicated than that is
where for example one state in one model
actually corresponds to multiple states
and the other model and so you've got a
kind of many to many matching between
states and third example is way you know
that the two models are kind of somehow
fundamentally inconsistent with each
other and if you really want to merge
them together you kind of have to
refactor them in some non-trivial way
and you might have to kind of pull one
piece apart and stick it in a particular
place in another model and then put the
other feel of piece in some other place
and the fourth category here is what we
say that
composition required new things so you
had two models that were developed
independently but when you bring them
together you actually need new behavior
or new model elements to make the
composition work correctly so a good
example of this is where you've got two
models that both access the same piece
of data and if you're just looking at
each model in isolation you don't need
any synchronization mechanisms but once
you bring them together you've got you
can you've then got you know access
control and synchronization that you
need so you need something new and so
what we try to answer in this study is
you know how how common are each of
these four types of compositions and as
you'll see the reason why we have these
four is because the existing methods for
aspect-oriented modeling and tend to
handle certain of these categories
better than others okay so the results
look something like this so for the
simplest type of of match here they're
the kinds of that kind of composition
occurred about you know 13 percent of
the overall compositions that you had
the slightly more complicated
many-to-many it occurred about 40
percent of the time this kind of more
refactoring idea occurred about 45
percent of the time but what's what's to
note here is really the last two columns
on this slide so what we tried to answer
here and this is really not very
scientific is you know the hyper j style
or the aspectj style does that support
that particular kind of composition or
does it not now the hyper J style
supports the first type of composition
very well because that's really what it
was designed for you know just some
matching criterion and put the two
models together it could potentially be
extended to the second category in a
kind of fairly natural intuitive way so
that's what that's going to may be but
it certainly doesn't it doesn't support
the last two categories very well
because it doesn't support any type of
refactoring of the models in a different
way the kind of them want aspectj style
you know although you can do the first
categories it's not necessarily easy or
very natural whereas the third third
category you you can do it but my
argument here is that if you follow this
aspect J star you tend to
with very fragmented models because
you'll get an aspect oriented model
where you say well this bit gets
inserted here this bit gets inserted
there that bit gets inserted there and
these each of these bits are kind of
represented as separate models and so
you end up with an aspect model that's
kind of a very fragmented thing which is
it's really kind of against the grain of
modeling because modeling is supposed to
be intuitive you know these graphical
model is just supposed to be able to
just look at them and see what's going
on whereas you ain't you end up with
some kind of fragmentation there and
it's no longer easy to see what's going
on okay so so the argument here is that
neither of these two approaches are
quite enough you know they don't quite
fit the aspectj like approach is only
tend to match against single events in
the base and also they only really
support sequential weaving because you
only just pick up the advices from
aspectj so you just have before after
and around you they don't really support
things like merging models together in
parallel or merging one model model as a
sub model of another model for example
and in hyper j like what tends to happen
is that this default merge algorithm
doesn't always work exactly the way you
want it to do and so you have to kind of
look at the the merge model then you
have to go in and kind of tweak it
around a bit and that tweaking can be
highly non-trivial so so the claim
therefore is that neither of these are
really sufficient for aspect oriented
modeling and so once you kind of get to
that point the next natural question to
ask is well what what are really the
requirements on on aspect oriented
modeling and I think there's there's
really kind of four very broad
requirements on on a model composition
language for a OSD so the first
requirement is it should be very
expressive and and I would claim that
some of the existing approached it's
like the hyper J like approach and I'm
not expressive enough they should of
course be scalable that's a kind of
standard requirement they should also be
intuitive which means that here that if
you're going to produce a model
composition language for UML you
shouldn't invent a completely new
language
do things in a completely different way
because no one's going to use it you
should try and match the underlying
modeling language as much as you
possibly can and the final part is that
it would be nice if there was some
underlying formality to the language
that you're developing so that you can
kind of you know apply existing analysis
techniques and you know detect things
like interactions between aspects
automatically okay so the conclusion
that we came to was that you know
aspects are really just aspect
composition is really just another type
of model transformation and so why not
use existing technologies that have been
developed for model transformation and
so at a very kind of simple level what
we we just view aspect composition as as
a kind of layer on top of graph
transformations so and in graph
transformations you typically specify a
pattern that captures points in a base
artifact where you want to that you want
to modify and then you write a rule the
you know adds new elements or deletes
elements from from that base and so this
is this is just a graph rule so for us
as I say you know an aspect is a graph
rule and in aspect terms what you
normally would think of as the as the
point cut is the pattern on the
left-hand side of the rule and then the
stuff that you introduce on the
right-hand side of the rule is what you
would normally think of as the aspect
and the advice you know what this the
reason this is quite nice is because it
allows you any composition strategy
you're not limited to the usual aspectj
like strategies of before after an
around you can compose things in
parallel you can compose sub states as
sub States or as sub-models it's also a
unified approach because you don't have
to design a new aspect composition
language for each modeling language you
know the current implementation of this
that we have supports class diagrams
sequence diagrams and state charts but
you can do it for any language as long
as you've got a well-defined metamodel
it works in exactly the same way
and the third advantage of this is that
you can you can leverage existing
techniques for analysis and as you'll
see that the one that we've started with
here there's this technique called
critical Peron alysus that's that's been
around in transformation languages for a
long time and and we've used this to
automatically detect conflicts between
aspects of the modeling level you know
which is a it's a real problem when you
have multiple aspects and they might
overlap or interact in undesired ways
okay so so our approach is called matter
it's modeling aspects using a
transformation approach it's it's it's a
little bit more than just simply using
graph transformations for the following
reasons one reason is that it only uses
the the concrete UML syntax so as I said
we've done this so far for UML sequence
diagrams state charts and class diagrams
most of the approaches if you look at
the graph transformation literature
write rules at the abstract syntax level
which is not very intuitive for you know
real developers so we've limited
ourselves to concrete UML syntax which
means it's not a general-purpose
transformation language but it's it's
very well suited for aspects it also
supports a thing called sequence point
cuts which essentially means that
instead of just matching against a
single event in the base you can match
against context and you can say well I'm
interested in the whole sequence of
events and then to do something and it
also supports automatic lightweight
analysis of interactions between aspects
via this critical pair analysis
technique there's a real tool to support
this it's currently built on top of the
commercial tool IBM rational software
modeler okay so let me just rather than
going into you know lots of nitty-gritty
technical details let me just try to
give you a motivating example so this is
an example where we were developing a
system when we have a set of use cases
and we're going to view each use case as
an aspect and this is an idea taken from
a book by Jacobson and Eng and and why
do we want to do this well because in
traditional object
oriented analysis and design you start
with some use cases which is a very kind
of customer oriented decomposition and
then you go to a object oriented
decomposition and in fact you could you
could argue that one of the the hardest
parts of developing software in this way
is to come up with this kind of
transformation from the customer
oriented view to the object oriented
view what you end up with is you end up
with you know each single module kind of
implementing multiple concerns from
multiple use cases and so it's not very
easy you know you can't look at the code
and say oh yeah that's theirs my use
case in one in one decomposed point and
what jackets demand Eng say well they
say well maintain the composition of the
of the use cases when you go down to the
code and they call them use case slices
so you would develop you know a a set of
modules for each particular use case and
then you'd have some kind of
relationships that specify how those
things go together so this is a very
particular instance of aspect oriented
software development if you like where
Jackie Epson and Eng stop is to provide
a language for actually doing the
composition and that's where we come in
because we have this language matter so
you can you can specify the the
relationships between the various use
case slices both at the behavioral level
and at the structural level ok and what
would it look like well let's take a
simple example of a cell phone that has
three use cases so it has one use case
for receiving the call somebody calls
you and what happens it's going to have
another use case for for voicemail you
know taking a message if you don't
answer within a certain period of time
and it's going to have a another one
four four four call call forwarding okay
so this is this is what we're going to
consider is the base use case so
following this approach you would you
know you have these three use cases and
you develop a set of models for each of
the use cases okay so and in this case
we're using class sequence diagram is
statecharts so you know a call comes in
you display some information you ring
and then you pick up and then you later
hang up or you can disconnect and you
have a state chart that does a similar
in the idle state if an incoming call
comes in you ring and you go to the
waiting State and so forth okay so
that's just regular old UML nothing new
about that and it gets more interesting
when you want to implement the the
aspects or the other use cases so each
of the other use case slices and we see
two here one in the top and one in the
bottom of this diagram each use case
slice is implemented as an increment on
that base use case slice so what was on
the previous slide so in the top case
this is where if you don't answer within
a certain period of time in other words
there's a timeout then you're going to
take a message and notice the special
notation where it says create anything
that doesn't say create is basically
matched against in the base and anything
that does say create is going to be
something new that's introduced so the
create is basically the aspect what is
not marked with Creators that is the
point cut if you're talking about aspect
terms so in the top right hand corner
there you're essentially saying you know
match against any two states that have a
transition between them with incoming
call as the name of that trigger on the
transition and if you find that then you
add a new transition that says you know
if if there's a timeout in other words
if the calls not answered within a
certain period of time then you forward
it to voicemail so we've what we've done
there is to simply add a new transition
to that state machine okay that's what
we've done the doing it for a sequence
diagram it's very similar except that we
have this special any operator which is
a UML interaction fragment but there's
any is new and this will just match
against any sequence of messages and so
that's what I mean when I say that you
know it's a sequence point code you
can't you're not limited to just
matching against one event you can match
against the whole sequence of events so
what you're saying in the sequence
diagram case is the ring here is the
point cut if you can find ring in the
base then you create an alternative and
Alt box and you add the timeout and the
forward to voicemail if the timeout
doesn't occur however you need to do
whatever you were going to do anyway and
so that's where the any box comes in
because that's mat
against all of the previous messages
that we had in other words it would
match against anything below here and
that would just get that would just get
put in so you get you get the right
behavior with that and the second aspect
here is notify call waiting aspect so
this is if you're already on the phone
and somebody tries to call in and you
want a message that you know says you
know somebody's calling do you want to
put them on hold and this works in the
same way for the state machine on the
right and what you're matching against
here is the state on call in other words
you're in the middle of a call and you
create a new state waiting for hold
prompt and you're also going to create
two new transitions one that says if
there's an incoming call when you're
already on the coil then you display
some information and the other one that
gets you back because you put the you
put the new caller on hold so just to
say here that this create applies to the
state that's created and to these two
transitions because they're connected to
it so that's just just a minor point and
you would do a similar thing with the
sequence diagram here it's this whole
loop here that's been created and what
you're matching against is two events
pick up and hang up so here you're
saying I'm only interested in anything
that happens in between me picking up
and putting the phone down in other
words and you're interested in when
you're actually taking a call and if
you're taking a call and another call
comes and then you do the same thing as
before
so these these are aspects but they're
really just they're really just a way of
representing graph flows okay
but you know I would hope you would
agree that you know this is the idea
here is to use the underlying modeling
language as much as you possibly can and
not introduce a whole new bunch of
notations talking about point cuts and
advices and all of that stuff you can
you can pretty much use this out of the
box if you understand UML and one
additional advantage of using graph
transformations here is that there's
this technique called critical Paran
alysus now for those of you don't know
critical Paran alysus is in the old
technique where you look at sets of
rules and you look at pair of rules and
you try and figure out the way that the
rules overlap
if they overlap in some way it means you
may get a different result depending on
which one you apply first so in in the
aspect world that becomes a real issue
because you might have two aspects so
take a message and notify call-waiting
in this case that if you apply one
aspect before the other you get a
different model than if you apply than
the other way around and in fact if you
are the two results you get from either
applying take a message first or
applying notify call waiting first and
you get a different result because one
of them introduces a new incoming call
the notified call waiting introduces a
new incoming call and the taker message
matches against that incoming call so
obviously if you apply take a message
first then you're not going to match
against this because it hasn't been
introduced yet so what essentially ends
up happening is that you don't get this
extra transition here and so you can end
up designing a phone that says that any
call received during an existing cold
won't be sent to voicemail so obviously
it's not the result you want so we've
used this critical Perrin alysus to
automatically analyze these aspects as
you write them and so the way you use
this is you develop your aspects and
then you you you you you ask the system
to compose the aspects and before it
does it it will apply the critical
Perrin alysus and if there's no problem
it'll go ahead and compose if there's a
problem it'll come back and say well
there's some dependencies or there's
some conflicts between the aspects you
may need to go back and revisit your
models and you end up getting either as
I said either dependencies or conflicts
so dependency is where one aspect is
dependent on another one and this you
can just solve by ordering in them in a
particular way but the the critical
power analysis will essentially tell you
which order you're supposed to apply
them in and conflicts you get these can
be more serious these are when one
aspect will modify the base model in
such a way that another aspect can't
apply so it might delete something that
another aspect relies on for example and
this you can sometimes solve using
ordering but in the worst case you know
it means the
something fundament fundamentally wrong
with your design and you basically need
to go back and change your design okay
so that's I'm gonna skip those actually
that that's basically a quick overview
of what matter is just to say that as I
said there's a tool it uses this system
called a GG which is a graph rewriting
system as a back-end the other thing it
can do is it can generate
aspect-oriented code from these models
and it does this in an aspect oriented
way so it doesn't compose everything
together and then generate code it will
take each of the individual model
aspects and generate AOP code from those
there are actually some interesting
research questions in doing that because
the language that we use for modeling
the aspects is much more expressive than
is available in existing AOP languages
and so there's a question of how you map
that down but I'm not going to go into
that today and what I want to finish off
though with them in the last 10 minutes
or so is to just give you a very quick
flavor of one of the particular
application areas where we've applied
this and as you can see we've applied
this in a number of areas but most
recently we've been looking at how do
you model security concerns very you
know very early stages of the lifecycle
and as you know I've mentioned security
a couple of times as a kind of obvious
place where you might use aspects and
we've done some work on applying this
mattr tool to modeling and weaving
together these different security
concerns so this this particular
technique it's called executable misuse
cases so misuse cases are like use cases
except they're things that you don't
want to happen so they're they're a very
good way of modeling you know attacks on
a system for example because you can
model a use case and then you can model
a misuse case that threatens the
successful achievement of that use case
and then you can model a mitigation that
will allow that original use case to in
fact take place despite the attack okay
so these these are a technique that were
developed early 2000s like use cases
though they're basically just you know
very high-level diagrams they the only
real way that they differ from use cases
is that you have two new relationships
one called threatens and one called
mitigates and instead of actors you have
male actors or attackers and and if
you're using these misuse cases you know
you would do very similar things than
you do with use cases you'd come up with
templates where you write the text and
you know they're a nice technique people
find them very easy to use but there's
no there's no automation to them at all
you know so what we did was we came up
with a way where you can model these
misuse cases in an executable way okay
so we model the set of use cases as a
big set of scenarios and which happens
to be done in a UML but UML with the
formal semantics so it's actually
executable UML and the aspects are used
to manage the the aspect-oriented part
of it so what what we do is that the the
attacks themselves or the potential
attacks that your system might come
under are modeled as aspects and then
the mitigations of the attacks are
modeled as aspects as well and this
allows you to keep the attacks and the
mitigations very much separately from
the rest of the application
another thing it allows you to do and it
you know it allows you to follow this
process where you come up with a use
case model which is executable and then
you brainstorm sets of attacks on that
use case model and then you can you can
apply those attacks and in the same way
that you would apply a set of regression
tests so each time you brainstorm a new
attack you run it on the executable
model to see if it will succeed or not
if it succeeds then you say okay I need
a new mitigation so you design an aspect
which is your new mitigation you then
run the attack again to make sure that
the mitigation works and in addition you
run all of the attacks that you had
previously in the same way that you do
regression testing to make sure that you
haven't broken anything you know any of
the previous mitigations or anything
like that so that's that's the way it
works and to give you a just a quick
flavor of this
this is an example of a kind of the
ubiquitous electronic voting system
example it's a very nice example for
using in security it's based on a real
system there's a very nice paper by kono
in 2004 where they look at a real
electronic voting system and they study
it for potential attacks and what we did
we just went through this this paper and
said well you know could you have
modeled these attacks using this
executable misuse technique and there's
two overall goals of this system one
obviously is to maintain voter anonymity
and the other one is to make sure that
you actually capture the votes correctly
so if you were doing this using our
technique that'd be three use cases that
you first have all set up first of all
you have to set up the voting procedure
by sending out details of the candidates
to all the polling stations you then
have a use case for doing voting and
then you finally have a use case for you
know wrapping things up and sending the
results where they need to go and the
voting is all done using smart cards
okay and so the voting use cases
actually might expect the voter goes to
the polling station and they show some
show some ID they get a smart card and a
pin number and then they go to the
electronic voting machine they enter
their smart card in the pin and then
they can vote okay so you can you could
mod that that you can model these
particular use cases easily using UML
and using these things called
interaction overview diagrams okay so
this is what they would look like using
our tool here you've got three levels of
sorry two levels of interaction overview
diagrams so that the top one shows the
use case is connected by an interaction
overview diagram and then each of the
nodes in that top one is refined by a
second interaction overview diagram so
voting you first have to get a smart
card then you have to cast your vote
then you have to return the smart card
and then each of the votes each of the
nodes at the second level are given a
sequence diagram and I'm not going to go
into the details here but just to show
you this is the kind of level of detail
you would specify in this example
there's just one sequence diagram here
for each of the nodes and this is the
main one this is for casting votes and
I'll just talk about this one a little
bit because we're going to see an aspect
on top of this
so here you know you insert your smart
car it gets checked you better
authenticated and then you submit your
vote and then at the end the card gets
disabled so it can't be used again and
so if you look at the the original Kona
paper on this kind of example they
detail eleven different attacks that
could take place on this system so one
of them is that the attacker could vote
multiple times and the way that they can
do this is they can just manufacture
their own smart cards and they could
bring a stack of smart cards to the
polling station and go in and just vote
for you know Hillary Clinton multiple
times which none of us would want of
course so and you MIT you could mitigate
this by storing IDs on the smart card so
that you would know that the same card
hasn't been hasn't been in used again
know that you're not jeopardizing the
vote anonymity there because you're not
storing the votes you're just storing
some ID so using our technique we've
already got the executable set of use
cases that captures the behavior of the
system now we would brainstorm new
attacks and model mitigations to those
attacks so here is the attack that we
would model and you you model not the
actual manufacturing of the smart card
you model the the undesired result of
the attack which in this case is to vote
multiple times and you can easily do
that
using sequence diagrams you can just
refer to the voting scenario and say you
know this shouldn't happen more this
shouldn't happen two times or more okay
so if I was to you know put this into my
tool I could I could run that attack
scenario on the executable use case and
it would work which would mean that the
attack succeed which would mean that
there's a problem so what you would then
do is to say well I'm going to design
some mitigation scenarios so that the
attack will no longer succeed and you're
going to use this you can see you're
going to do this using aspects the
mitigation as I said is to store IDs on
the smart card so you didn't you need to
introduce two aspects in fact the first
one is that when you know in the
scenario where the
vote has given us a smart card you need
to actually create new messages to store
the ID on there and the second one is
that when you actually vote you need to
store new messages to actually check if
that idea has been used before or not so
here you can see everything in red and
stuff that's part of the aspect and it
basically gets the idea ID off the smart
card it checks it if it's an existing
idea will notify the poll official that
it's been used before otherwise it will
allow everything else you know all the
voting messages to take place as normal
and again you see this use of the
sequence point cut this any there okay
so that was a kind of very quick
overview of what we've we've done here
that's the kind of summary of it and
just to kind of wrap up by saying that I
think now this this matter tool it's
it's it's it's a nice unified way of
doing this aspect oriented modeling
we've applied it to multiple different
situations but I think there's still a
lot of work to be done on the kind of
bigger question of you know for real
development scenarios is it a good idea
to kind of separate out all these
different concerns and then put these
concerns back together you know does
that really work in practice I think is
still you know one of the the
interesting questions still to be looked
at and I'll stop there and take any
questions
these misuse cases don't seem to be
particularly honored to security do you
think you could use them for like
specifying safety properties in general
like something that you don't want to
happen in the in the system and when
when misuse cases were first invented
they weren't invented specifically for
security it's just they have a very
natural interpretation in that world and
so that's where they've tended to be
used more but yeah they're more general
than that I'll jump in sorry what we do
with concerns or aspects which don't
readily lend themselves to to be
functional aspect so like performance
for example right and they help to go
out design process and but there are
important aspects right yeah we the
short answer is we would we wouldn't
directly handle something like that you
know you would have to operationalize it
first so I mean most most of these
things that we normally consider is
non-functional requirements though when
you actually come to do a design you'd
end up operationalizing them you know
performance not as Sarah or though even
with performance you might do so by you
know having some optimization algorithms
or something so so we're assuming that
you know whatever it is you want to
model you're going to operationalize it
first yeah
so you you showed that sometimes
multiple of these graph transformations
may conflict and you say you could do a
critical panelist I would wonder whether
you would like to have control
structures that say apply these one
first and then apply those do you
support that already yes well we do but
not as well as we would like so right
now we just have a simple attribute
within the models where you can specify
you know an integer that says the order
and you could get much more fancy and
you know for example having an activity
diagram where you have you know full
control flow but no we don't we don't
have that level of support yet okay
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>