<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Faith, Evolution, and Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Faith, Evolution, and Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Faith, Evolution, and Programming Languages</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2t9q-936yxw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we're going to have a very special
speaker Philip wad ler from the
University of Edinburgh he's a very
distinguished speaker known josh is
telling me to speak up more loudly so I
will he's known worldwide for his work
on functional programming the developer
of monads he's worked on haskell he is
one of the people who developed generics
for Java which many many people use and
he's here to talk to us today about
faith evolution and programming
languages Phillip water layers panel
it's a great pleasure to be speaking
here thank you very much for inviting me
this is a variant of a talk that I first
gave it oopsla and I think this is a
good environment for it as well so I
spent a lot of my life trying to do what
I call getting out of the functional
programming ghetto but for the purpose
of this talk I want to talk very much as
a representative of the functional
programming community trying to address
a much broader community so the purpose
of this talk is going to need to say a
little bit about different kinds of
programming languages and how they might
relate and what functional programming
might have to offer to the rest of the
world now so the title this is faith
evolution and programming languages and
faith and evolution been together in the
news some people see a belief in
evolution and faith as opposed many of
us might take a different view and say
well they're just two different worlds
completely right i want my faith to know
what to do when my mother dies and i
need a ceremony or when my children are
born and I need a ceremony and that has
nothing to do with whether or not I
believe in evolution some people think
differently my guess is that in this
audience the number of people who think
differently and believe that faith and
evolution or a poke the if faith and
evolution or opposed its evolution that
has to go that the number of such people
would be small in a contest between
faith and evolution evolution would win
but now let's look at the design of
programming languages and when it comes
to how we go about designing our
programming languages or choosing our
programming languages in a contest
between faith and science i would say
that more often faith wins and one of
the reasons for this may be one of the
reasons that faith triumphs over science
many thousands of years ago which is
that there wasn't much science around
and when it comes to the design of our
programming languages we don't have as
much science as we might wish to draw
upon so that's my introductory feel and
then part of this is multiculturalism in
Britain this is very looked upon you
should support many different faiths and
often in the programming community you
will find people that support
multiculturalism that says say many
different paradigms should go together
and then you find people who are more
fundamentalist for whatever their brand
of fundamentalism is one particular
divide that you find is that between
static and dynamic typing and I've
actually illustrated this with Alonzo
Church on the left and Haskell curry on
the right because many years ago before
there were even programming languages
they were already having this debate
where Church said you cannot talk about
the semantics of a typed programming
language unless you have the types and
curry with saying no no no you can give
it a semantics untyped and then layer
the types on top later so it's a very
old debate so I'm going to have four
parts of this talk it's actually quite a
lot to cram in so i will speak fast but
please do slow me down with questions if
there are bits that you don't understand
I'm much more interested in
communicating than in getting through at
all so I'm going to begin by talking
about the origins of my own faith in
functional programming why I believe in
functional programming and in types
and then I'll talk tell you a little bit
about two pieces of work that I've done
type classes in Haskell and generics in
Java these of course we're both very
large projects I was one of the people
who contributed to them and then finally
I'll tell you about some work that I'm
doing now and actually maybe I said this
was based on the talk i gave the duplo
but the last part of this actually came
because after the Upolu talk i thought
you know there should have been some
relevant new work in there that fit with
everything else and after that I did the
work so I'm going to tell you about that
today so where does my faith come from
well I'm going to tell you a story about
two men the first is God Jensen I guess
an interesting overlap with faith here's
that I happen to be Jewish and Guerra
hodkinson happened to be a stormtrooper
now so that leaves me at issue with him
personally but logically his logic was
impeccable he made many remarkable
contributions so he introduced to not
one but the two main systems of logic
that we use today one of which is
natural deduction so here it is from the
original paper written in 1935 and here
it is the way that we use it now and as
you can see they're identical except
that he wrote his letters in German but
apart from that they look exactly the
same and his great insight was that
logical rules should come in pairs
introduction and elimination pairs so
here we have on the assumption a you can
prove be and that tells you that a
implies B and here we have if you know
that a implies B and you know a then you
can conclude be something which has been
called modus ponens for about well
somewhat more than a thousand years the
actual principle is closer to 2,000
years old and similarly if you can prove
a and you could prove be then you've
proved a and B if you can prove a and B
then you can conclude a so the
these are in pairs is that this rule has
a implies B in the conclusion this has a
implies B as one of the hypotheses below
the line above the line similarly here
below the line introduction rule above
the line elimination rule so here is a
very roundabout proof of a and B from
the assumptions be and a so from B and a
I can prove beyond a and then here
you've got a proof that be and a implies
a and B so I combine those and I get a
and B because this is a very roundabout
proof I might want to simplify this
proof Jensen was very interested in
simplifying proofs because by showing
you could simplify proofs he could show
that a proof only involved that thing
and it's sub formulas and then by
knowing that a proof of a thing only
about that thing and it's sub formulas
he could show that there was no proof of
false giving a kind of consistency for
his system this was easy to do because
false does not have many sub formulas
it's sort of like what part of no don't
you understand so it was very easy to
show consistency of his system once he
had shown that you could simplify proofs
so that something only dependent on sub
formulas so here we have a formula B and
a implies a and B which is not a sub
formula of the conclusion so we would
need to simplify to get rid of that and
in fact we can simplify and the
important point to note here is that
whenever you have an introduction rule
next to an elimination rule instead of
introducing the thing and then
eliminating it you can just do things in
a more direct style so remember the
introduction rule said we will have some
hypotheses of the form whatever it is to
the left of the implies on so in this
case of the four bna and then over here
we're going to have some proof of DNA so
to simplify this you just take this
proof and copy it in place of each of
the two occurrences of the assumption is
there some point or I could use to point
directly at the screen
see how well this works thank you very
much oh I hate people time to knotts can
people see that okay oh thank you neil
there we go oh yes good right so now
people have to be polite or else I can
zap you right so we take this assumption
here in this assumption here we will
place them by this proof here giving
this simplified thing now notice that
simple here means we've gotten rid of
this intermediate formula but the
simpler proof may actually be much
bigger because this could be very big
and we might be copying it many times
nonetheless in some sense things are
getting simpler and notice that once
we've done the simplification this and I
has moved on top of this Andy so if and
I followed by Andy so this as well fine
OB and I know a then I know bna and if i
know b na i know a well we could
simplify that of course and just say
right I know a and now we've got a
simplified proof that from assumptions a
and B you can conclude a and B so in
fact you can do this with any proof and
you can always get rid of all the sub
formulas in the proof by following this
technique part of knowing that this
works is to show that this process must
terminate and that in fact follows in
this case by simple inductive argument
okay so that's why I want to tell you
about Garrett Hodkinson now let me tell
you about Alonzo Church who was among
other things the supervisor of Turing's
PhD thesis so many of you will have
heard of lambda calculus architect hands
up if you've heard of lambda calculus
right that is most of you good hands up
if you haven't heard of lambda calculus
i can use this on you right ok and there
it is the world's first lambda naught
lambda is a Greek letter but land is the
binding of an abstraction operator
and we really like our lambdas right so
for instance here's a journal that I
helped to found which has lots of
lambdas on the front and that's a
picture of the tie that I'm wearing
right now so Church want to use this as
a metal language for writing down
logical formula and he originally did
this in 1932 with an untyped lambda
calculus and turned out since you have
fixed point operators you could write
down the equivalent of an infinitely
long formula and using this using
Korea's paradox you could prove false
which makes your logic very powerful but
perhaps not very useful so he needed to
make his logic consistent and to do this
he used the same trick that Bertrand
Russell had first used to get rid of
Russell's paradox which was to introduce
types so in 1940 he wrote down his typed
lambda calculus and this says for
instance that if X has type a that's a
free variable and here's you some term
that contains the free variable X if
that has type B then lambda X dot u is a
function that takes an argument of type
a and returns a result of type B if s is
a function from A to B and T is a term
of type a of course if you apply s to T
the result is a term of type B if TST
paying us type B we can form the pair of
a TNA which has type a and B and if s is
nay and B term I can select the left
component which will have type A
similarly for the right so here's a
program it says here's a function that
takes Z which we can see up here is a
pair of a BN dinnae and what we do is we
select the a from that and we select the
be from that and we pair them up so that
means lambda Z Zed ones that knot is a
function that takes a be a pair and
returns an a/b pair and here is a be a
pair so if I apply this function to this
pair I get an ad pair so how would I
execute this program what I'm going to
do is I want to take YX here and
substitute it for Z so that gives me
this program and here's the thing
showing that this program is well typed
and now I've got a YX pair from which I
select the right component and similarly
the left component and that simplifies
down to this so you may have noticed a
slight similarity between what I showed
you here and what I showed you in the
previous thing involving Jensen now I
told you that gentan did all this
because he was interested in simplifying
proofs which is true what I neglected to
tell you is he didn't see it in that
form I mentioned he invented two
well-known styles of proof and the other
sequent calculus he invented to show
this simplification property he did not
manage to show it for natural deduction
but as you've seen the way that you show
for natural deduction is very simple and
Jensen was a very clever guy but in fact
he didn't he never saw it he died at an
early age I feel like quoting tom lair
he once said it what it's embarrassing
to realize that when Jensen was my age
he'd been dead for more than a decade
so Jensen never saw this a fella named
profits finally saw it in 1965 even
though this style of simplification for
typed lambda calculus was already known
in 1940 in churches original paper so
the way I've shown it to you the
relationship between these things is
completely obvious how could you
possibly miss it but these two clever
guys church against and did miss it it
wasn't until nineteen sixty-five that
prophets saw how to do the proof and
then not until nineteen sixty-nine that
william howard actually wrote out the
exact correspondence i've just shown to
you and this was just circulated
informally as many a note it wasn't
published until nineteen eighty so 1935
to nineteen sixty-five and then to
nineteen eighty almost 50 years before
you have published this obvious and in
fact very very important correspondence
and i think particularly for an Internet
company like Google where things go very
fast it's worth reminding people that
sometimes ideas take a long time to come
to fruition as an academic I always like
to remind the funding agencies of that
as well
so something very similar to i showed
you have been notified noticed by on
haskell curry i've mentioned a few times
before so this correspondence that told
you about is called the curry howard
correspondents nice double-barreled name
because two people refined it in
different forms now the interesting
thing about this double-barreled name is
it predicts the existence of other
double-barrelled names it says that when
you have a nice programming language
there should be a nice logic that
corresponds to it and vice versa now i
showed you this just for one case the
simply typed lambda calculus but in fact
this crops up again and again and again
and again it's a very robust
correspondence so for instance the
logician roger Hindley and the computer
scientist Robin Milner both discovered
independently what's now called the
Hindley Milner type system which is the
basis of the ML programming language in
the Haskell programming language among
others and the logician Johnny jihad and
the computer scientist John Reynolds
both discovered what sometimes called
the polymorphic lambda calculus or the
Gerard Reynolds lambda calculus and
again it again you will find that
there's a logic and a programming
language that correspond and new ones
are being discovered all the time so for
instance tim griffin in 1990 worked out
how so you know there was no law of the
excluded middle here turns out that you
add the law of excluded middle that's
equivalent to various other laws like
purses law and in 1990 tim Griffin
published this last paper saying oh look
Pierce's law is exactly the same as the
type of call Cece and in fact you can
give it a semantics there's exactly like
call Cece so you had this correspondence
between classical logic and the logic
with and a programming language with
continuation such as scheme and these
sorts of things chopped up all the time
in 2003 i managed to publish a paper
giving a correspondence with sequin
calculus so it's a very deep
correspondence very robust and the way i
like to think
about this is say we managed to
communicate with aliens and some time
and we want to send them a program say
we sent them a program written in Java
right what you might have seen the film
independence day so in the film
independence day they kill the alien
computer with a virus if you look at
this virus in the moment it flashes up
on the screen it has lots of curly
braces in it at the time I just moved to
Bell Labs I thought cool i work next to
a guy Ken Thompson who's gotten his
programming language into a popular film
this was back in nineteen ninety-six
like it was before java had spread
through the known universe so i figured
this was see but you know if you send
seed aliens or java to aliens they might
be able to decode it but it's very
unlikely that it's something that they
were discovered independently on their
own that might be a problem as well ok
but now say that you set them something
in lambda calculus if you set them
something in lambda calculus well they
would probably already know natural
deduction and they must therefore have
discovered lambda calculus if you just
wait long enough right it took us two
thousand years to get from the Greeks
discovering logic to get to lambda
calculus but we got there in the end and
I predict if you talked to aliens they
would get there in the end too so why
would like to say is that lambda
calculus is the universal programming
language now I'd like to say that but
that would be wrong it would be wrong
because it is too limiting because
imagine a different universe in a
different universe will say a different
gravitational constant I could imagine
that I could not imagine a universe in
which modus ponens does not hold I can't
imagine a universe without the logics
that we know and therefore I cannot
imagine a universe without lambda
calculus so Universal is the wrong name
it should be more general there's this
old question on for a hard Oxford exam
define universe give three examples
and it's a bit like that so I've been
trying to search for the right word I've
never come up with it so if anybody
could suggest the proper word i'll pause
here for a moment I'd be very grateful
to you maybe somebody will come up with
it before they enter the talk so three
necessary in the modal sense not quite
the same ring as universal is it you
need something at least as catchy as
universal okay that's what I was going
to tell you about the basis for my faith
and while I think that there is
something really inherent and
interesting about functional programming
languages so I'll just pause there for a
moment to ask it there it so they want
to ask a question about that part before
I move on to a different part always a
bad sign if you got no questions
everybody saving them up for the end all
right
will do okay so now let me tell you
about a different piece of work so this
was done at the time we were creating
the Haskell programming language which
to my surprise is 20 years ago we are
presenting a paper on it at the history
of programming languages conference in
June and we had to deal with this
problem of overloading and we ended up
by dealing with it by coming up with
something called type classes so there
are places where you want to do
overloading in places where you don't I
claim the Haskell does a pretty good job
of capturing the kind of over loadings
you want so for instance plus can be
defined on int and float but not on
string right because defining plus on
string is something very different so
here's an example of this where you want
less than defined on many different
types so you want less than to find on
int and you want less than to find on
character so here's the definition of
less than on integers and characters but
we want to use the same symbol for both
so the way we do this is we say I have a
type class called Ord of a and basically
Ord of a hold whenever there's an
operation less than whose type is take 2
a's and return a boolean and so int
belongs to the type class award and care
belongs to the high class org and now i
can define a function max which says if
x is smaller than y return why otherwise
return X and using our good old Hindley
Milner type system just slightly
enhanced we derive that the type of this
is take 2 a's and returned an a in the
case that a belongs to the type class
Ord a must belong to the type class Ord
because we've used this operation less
than on two ways that's only valid
because a belongs to the type class
sword and I can say find the maximum of
a list so they'll take a list of a and
returned an a it's a list with just one
thing in it return it because the list
whose head is X and whose tail is excess
then find the maximum of excess and take
the max of that with X since max has
ordained its type maximum must have
ordered a constraining its type as well
and then for instance I can take the
maximum of a list of integers or the
maximum of a list of characters which is
written as a string in house
is that clear enough sort of nod your
head please if that was clear and ask a
question if it wasn't
now the nice thing about this is we can
give a translation and the translation
is very very similar to what i showed
you before so remember that why i showed
you before if you have an implication it
turns into a function of course in
haskell we already have functions but if
you look at this it's a sort of
implication it says if a belongs to the
class or then max has this type so that
implication also turns into a function
when we want to implement these things
what we say is that will introduce a new
data type or duvet which is just a
record containing one feel less which is
a function that takes 2 a's and returns
a bool and so if you you can of course
have more than one operator in your type
class and then we'd have more than one
field in this record you have as many
operators as you like and now to say
that it belongs to the class Ord what we
do is we give an instance of this
dictionary where less is bound to the
right function similarly for characters
and then when we define max notice that
this has now turned into an ordinary
function argument so we pass in this
extraordinary for dictionary and then
when we need to work out is X less than
Y we extract the less than operator from
the dictionary and then apply that to x
and y similarly we pass a dictionary
into maximum and when we want to call
max we pass that dictionary into max and
now I can call so now when the
translation of maximum applied to a list
of integers takes an extra argument
which is inferred which is this
appropriate dictionary and similarly for
a list of characters a way to think
about this is that in an object-oriented
programming you called max that would
have two arguments each of which is an
integer which points to the appropriate
dictionary of operations on integers and
of course this is often referred to
something like less than is referred to
as the binary method problem in
object-oriented languages because in
general it can be difficult to make
something object
oriented that varies in the behavior of
two arguments rather than one can be
hard to get that right in the
object-oriented world and that's because
you have two different pointers to the
dictionary here and you need them to
agree for this to be sensible it's not
usually an easy way in the
object-oriented world to be sure that
these both agree so the way to think of
Haskell's it's just the same thing but
the dictionary has been detached from
these things and passed in as an extra
operator which guarantees that you have
just the one dictionary for both that
matches and then this extends this
extends to saying let's say I've got
orderings defined for a Type A then
ordering can also be defined for the
type list of a so this would just be the
lexical ordering so here's lexical
ordering defined in the usual way and
now this means that since less than is
defined on characters it's also defined
on list of characters since less has
defined on integers it's defined on list
of integers and since it's defined on
list of integers it's defined on lists
of lists of integers and so on ad
infinitum if you choose and the
implementation of this is very similar
and basically it just says we'll have a
function that given the implementation
of ordering of less than on taipei gives
you the implementation on type list of a
and then in order to compute maximum of
a list of lists of integers we take this
function and apply it to less than on
integers and then apply it again ok
straightforward any questions about that
ok so that's how it works in haskell and
i'll tell you about different piece of
work i was involved in
which was defining generics for java so
in fact I've just finished writing and
all right there's my name in tiny print
on the cover but I've just finished with
the colleague writing a book describing
how generics work in Java very
well-reviewed I'm pleased to say so
you're all probably familiar by now with
the problem that generic solve but just
to motivate this briefly how would you
represent an integer list in Java before
there were generics well that's easy
you'd give it the type list let's say I
had a list of strings instead what type
would I give that oh that's easy it's a
list and if I had a list of list of
strings that's all so easy it's a list
so that's nice and simple but possibly
it's too simple and what we'd really
like to do is this and write out
specifically declare in the type that
this is in fact a list of lists of
string and so generics and Java let you
do that and there of course two
important relationships with C++ to be
noted here the first is syntax we have
exactly the same syntax and the second
is semantics we have a completely
different semantics in particular we
have a semantics
so here's how this works and the design
of generics and Java is based upon this
principle called erasure and the
motivation behind erasure is evolution
in this case the evolution from legacy
code to generic code the reason that
it's done with erasure is to promote
evolution so here's the classic example
here's a stack implemented in terms of
list push just add something to the list
and pop remove something from list of
course the way you would define
something in this in Java before
generics is just as all the elements of
the list would have type object if you
want to have a stack that could be a
stack of any type you would say that the
elements were objects so when you push
you push an object and you pop you pop
an object here we have object appearing
in the middle of the code and if I want
to be a stack of integers then might
just say have a new staff my push I put
an integer in there and then wipe up I
would have to cast back to integer of
course so I've always thought that the
object was well named because object
always shows up in your code when
because you don't have generics you'd
have to say object is the type of your
elements I thought was well named when
you see it you should object so what you
would want to do of course is say I have
a stack of E and that's implemented as a
list of E and I push something I push
the element of typing my pop I get out
and E and now when I declare us back I
say it's a stack of integer and I can
just push 42 on it and most importantly
when I pop I do not need to cast that
cast is inserted for me automatically by
the compiler now I mentioned that
generics are implemented by erasure and
what that means is that the
implementation of this where I say stack
of E is to erase that avi and implement
it this way and that means that when I
pop something off the stack that's
actually
by inserting into the compiled code the
necessary cast the reason that is
important is it says if you write the
code in legacy form or if you write the
code in generic form you get exactly the
same byte code and that means we can mix
and match so in particular it works
perfectly well whoops it works perfectly
well to use weight went missing one yes
it works perfectly well to have a
generic library but a legacy client and
indeed this was very very important when
generics were first introduced in Java
it meant for things like the collection
library which I know is during dear
Josh's heart that you could generalize
the whole thing and it would not break
any existing clients so that was really
the killer argument for implementing
generics in this way you're smiling is
there's something
yep I'll get into that and also it means
that you could go the other way around
and genera sighs haha see where it says
legacy library with generic client the
two small spelling errors there that
should read generic library with legacy
client so if you have the source of your
library and you want to update it no
wait a minute I'm confused generic
library of legacy client correct legacy
library of generic client sorry this is
correct sorry so here we've genericized
our client right it's got the stack of
integer here we've got an old library
that we want to make minimal changes to
we've got the source and what we do is
we just change the declarations here but
notice I've left the code alone of
course here the code is one line who
cares but the code was hundreds of lines
it might be important to you that you
just change the type signatures and
nothing else and then when I'm done I
have to cast it and of course it can't
check that this cast is correct so it
gives you a warning when it compiles the
code but in this way you can now use the
code from here and it will type check
that everything works out properly as
long as you've assigned the correct
types here but that only works if you
have the source code but even if you
don't have the source code you can do
this you just write the new signatures
you give completely empty bodies you
write the client as you want you compile
the client against these signatures you
compile the client against the newly
genericized code but then when you run
it you run it against the legacy code so
you can update even if you don't have
the source for the library okay so
that's the good news and that's why we
did it this way and both Neil and Josh
who are well aware of the limitations
know that although this works very well
there are other aspects that don't work
well in particular trying to create a
new array doesn't work well because
we've erased all the type information
but because of the way that arrays work
in Java in order to make them types
eight you need
information to check so creating new
arrays is a bit tricky you have to pass
around some token or existing array with
the type information to make that work
well and again please buy my book
because it explains it in great detail
how to do that right and how not to
violate things like the principle of
truth in advertising lots okay now I
told you a bit about type classes in
Haskell and in fact you find exactly the
same idea now cropping up in Java so I
mentioned that binary methods are
difficult but in fact of a little trick
that was learned by looking at type
classes binary methods become easy you
just add a little type parameter and
when you want to compare things so this
is a type belongs to comparable of tea
if you know how to compare it to a tea
and then you declare integers belonging
to comparable of integer and characters
belonging to string is belonging to
comparable a string and so on but none
for instance you cannot compare to
arbitrary numbers so numb does not
belong to a comparable number so you can
make this be a compile-time error but
both of these work out fun and then if
you want to find the maximum of list
that's again very easy the only tricky
bit is in the type where you say okay
maximum takes a list of tea and returns
a tea for any T such that t extends
comparable of T so this is the
equivalent to in haskell saying ORD of
tea with a the double arrow and then
many people they first see this idiom or
mystified by it but that's where it
comes from
and then I mentioned that this would
extend to list of lists and so on and so
in Haskell we implicitly would create an
operator that given less than on type a
would give you less than on type list of
a here it's written out explicitly in
Java so something that takes an
implementation of less than on type II
and gives you an implementation of type
less than on list of e written using
lexical comparison and then if you want
to compare a list of lists of these you
just apply twice as before and you
remember I gave you this nice example of
forming a list of lists of integers and
finding the maximum of the list of lists
of lists of integers using this
implicitly created dictionary right
that's the translated code right here's
the original Haskell code just this one
line it's very very easy to do the same
thing in Java let me just show you what
it looks like in Java very simple and
easy there it is
just slightly more verbose okay so
that's what I want to say about Haskell
and Java and how some ideas from Haskell
escaped into Java where real people
would use them any questions yes please
is there a reason we don't have tied a
footjob is there a reason that we don't
have type deaths in Java Gil abraca who
is in charge of it just said he wanted
to keep things as simple as possible I
in fact argued in favor of type deaths
okay so let me go on now and tell you
about some new work that I've done which
of course I'm very excited about because
it's new work and with this is drawn
from these three pieces of work and
basically looking at them i saw that
there's a common theme running through
all three so the same idea see these are
all been done in the last five years or
so so here's the idea i mentioned
evolution i'm going to return to that
theme and i also mentioned
multiculturalism and the notion here is
you have some dynamically typed
languages likes a small talk or Python
or Ruby and you have statically typed
languages like Java and the question is
could you make the two play together in
a friendly way and we already saw this
sort of thing cropping up with using
erasure to define generics in Java so
that you could have the old legacy type
list which is in fact was untyped or
dynamically typed with regard to the
element type of list and the new type
list of e so again you had typed and
untie playing well together could we do
the same thing for our language say such
as scheme and Haskell get them to play
well together scheme being dynamically
typed in Haskell being statically typed
so here is a untyped version of a simple
program to indicate that it's untyped
since course i'm a typed kind of guy so
I'm going to make untyped be the
exceptional case so indicates
exceptional I write these little
brackets around it so this is an untyped
program and just say x is 2 f is the
increment function and h is higher order
it takes a function G and applies it
twice to X
so H of F if F is the increment function
and X is 2 is of course going to be 4
and here's the same thing typed now
thanks to him Lee Miller type inference
we don't in fact meet to ride out lambda
wife type int this could be inferred for
us and similarly it wouldn't fur that G
is a function from integers to integers
but just to keep things nice and simple
I you'll use simply typed lambda
calculus and write out all my types but
in practice we'd want to use Hindley
Milner so here's the same program typed
now evolution would mean we'd want to
mix and match the two and have some bit
that's typed and some bit that's untyped
living together so for instance here's
some legacy code to do increment and
here's some modern code to bind x22 and
then to h which takes it into n function
and applies it twice of course this will
evaluate to four again and then the
question is how do we make sure that
this is type safe and reports an error
in the proper way if something goes
wrong and notice these little
superscripts pnn I'll say more about
those shortly then here's another
example of a program oh sorry this is
the same program but I've changed one
bit of it it's that what this being the
increment function it's the constant b
function so no matter what what it takes
it would return the character being now
in this case things will go wrong
because if we try to apply g2x here
we're not going to get out an integer
like we're supposed to do we'll get out
a character so something goes wrong and
there's something that went wrong is
with this function here and these labels
here tell you who to blame if things go
wrong this idea comes from contracts by
Finn learn for licen and the important
thing is that there are two places you
might blame if things go wrong it's
either with the term in here or with the
environment so this is an example where
what's wrong is with the term in here
it's not returning an integer like it's
supposed to do it's returning a
character so what went wrong here is
with this term it's not in fact of type
integer dandridge er now let's look at
this example the other way around so
here I have some untyped code with some
type code buried inside it and now this
is the increment function and I pass it
into here and so again this returns for
as you'd expect if I changed it so that
X instead of being an integer is a
character something will go wrong now
what's going wrong casting an integer
into an integer to a dynamic this is an
integer to integer you can't fault this
this is perfectly right what you have to
fold is the environment which is passed
in a character rather than an integer so
in this case the fault belongs to the
environment and we say blame n so these
are called positive and negative blame
positive means it's the fault of the
thing in here negative means it's the
fault of the context of the environment
now I've talked about untyped programs
but what I mean by untyped is unit typed
we just add a little I in there this is
a slogan due to Bob Harper and the
notions everything has the same type
which you've already seen written down a
few times din robbie Findley had another
nice paper where he actually wrote out
the type rules for scheme and everywhere
in these titles you see TST then you
read the paper carefully and you
discovered TS d stands for the scheme
type right there's just the one so I'm
calling that didn't short for dynamic so
in fact when I write these untie
programs with brackets around it it just
means inserting all the necessary
coercion so if I have a land expression
here it's going to take an argument
that's dynamic and then the expression
within it will of course be dynamic so I
need to cast a dynamic to dynamic
function to a dynamic similarly to apply
you take this dynamic cast it to a
function and then apply to the argument
so just adding these casts is all we
need and that's all that these brackets
mean it's is adding in the suitable
casts
right and then if I cast an integer to a
dynamic and then back again that works
fine if I cast an integer to dynamic and
try to cast it back to some other type
that does not work fine and it raises
blame that's always going to be positive
play because it's this thing in here
that was wrong this is not a character
it's it's fault all right so where does
negative blame come from it comes from
functions and this is the key trick this
is the contract trick due to thinner and
full Eisen so let's have got function
from dynamic to dynamic I cast it to a
function from integer to integer so
here's the function take a dynamic why
add one to it on types to give a dynamic
and then apply that to two okay so what
we do is we break this cast into two
smaller casts one on the argument which
will cast it from integer to dynamic and
one on the result which casts the result
which is dynamic back to an integer so 2
goes to the untyped to you add one to it
to get a nun type 3 we cast that back to
a type 3
so notice that the particular caste
we're doing here is narrowing these are
wide types right dynamics very general
integers an arrow type so we're making
the type much more specific note that
when you do that this cast here must
always succeed but this cast could fail
right an example is oops ah missing
example all right
if this had been the constant b function
then when we tried to cast that to an
integer it would fail oh dear help
yeah much better
okay so notice that this cast here must
always succeed Oh notice also that when
we do this reversal right here it's then
to end but here it goes the other way
around int to den so when we reverse
notice that the negative and positive
trade places so here's an example going
the other way where we're making things
wider into int goes too didn't it in and
again we just break it up both ways
again we reverse it here so now we
convert din dynamic to integer add one
and then convert the integer back to
dynamic now whoops Oh both examples are
missing interesting okay we could
replace this say by a character instead
right Celeste if that was bracket
character a bracket that be an untyped
in so you could do it it'd be well typed
but now if we try to coerce the letter A
to an integer this will fail and we will
get negative blame so if you're widening
you can get negative blame but you would
never get positive blame because integer
to dynamic will always succeed so just
to review if you're narrowing things
that can never give rise to neg negative
blame but could give rise to positive
play if you're widening it can give rise
to negative blame but can never give
rise to positive play yes
why you all find
it corresponds to a positive negative
positions in covariance and
contravariance thank you for the
question is there anything else I want
to say about that
right okay a related issue here is
contracts so this is the idea that
occurs in them again in the original
work of findlay relies and that's this
particular type system is due to Cormac
Flanagan but that is now I declare type
NAT and say NAT is all integers that are
greater than or equal to 0 and I have
coercion Slyke into int goes to nap to
nap I'm scences bit before I talk about
an untyped world in a typed world here i
have a typed world and a very strongly
typed world and one reason that i'm
interested in bringing together the
typed and untyped worlds is because i'm
also very interested in bringing
together a typed world with a very
strongly typed world where the types are
really telling me along now general i
might not always be able to prove that
something is an at so general i might
have to test at runtime but nonetheless
i could get a lot of value out of such a
type system notice that we do a dynamic
test here that too is really greater
than 0 and here we'll test the argument
and then test the result but notice that
here it statically typed we're
guaranteed that if X is an that and G
takes nap to knotts the result will be
an at no dynamic tests needed here at
all the static type system is proving a
great deal for us even though we have no
theorem prover or anything here so I
think this could be very useful second
line function what y minus 1
where does the failure have it will
happen at runtime and it will be this
will break up into a contract check on
the argument and a contract check on the
result the contract check on the result
will fail yes sorry the question was
could you repeat the question there's y
minus one if it was Y minus one where
everything to go wrong and the answer is
that checking the contract that it can
be converted to a nap would fail on the
result so the way to understand this is
in terms of subtyping so the normal
notion of subtyping has this
contravariant rule a function from st t
is smaller than a function from s prime
DT prime if s prime is smaller than s
and T prime T a smaller than T Prime so
you have this sort of inversion going on
very much like the flipping of the blame
that I showed you this is sort of where
it comes from now if s is really a
subtype of T by these rules so for sub
for set types it would mean that the
condition ass on this set implies the
condition T on this set and notice very
importantly that for dynamic the only
thing that dynamic is a subtype of is
dynamic this is surprising in Cormac
Flanagan's original formulation it
looked exactly like this except he had
any type of smaller than dynamic which
is what you might expect but if you do
blame will go wrong he was lacking the
notion of blame blame is very important
right it's important in a software
engineering sense right I've showed
these cast on individual tiny functions
that are one line but the point is if
you have several large modules written
by different people one type than one
untyped where does the blame go
so if something is truly a proper
subtype then the answer is that this
cast will always succeed and it will
never result in any blame positive or
negative now the technical contribution
of the work that I'm showing you is that
we can break that subtyping down into
two parts positive subtyping which only
looks at the covariant or positive
positions in the type that is everything
that is to the left of an even number of
arrows and negative which are things to
the left of an odd number of arrows so
what we do is we break it down into
positive and negative again we have this
flipping of things but notice that in
the argument position the contravariant
position we've now used the negative
subtyping instead so and then this is
just as you'd expect and notice that now
positively anything is a subtype of
dynamic and the other way around
negatively anything is a subtype oak
that should be a subtype minus their
missing minus and notice that there's no
condition that we check here at all in
the argument positions we just won't
bother to check this subtyping and this
ends up giving you a definition where
something is a negative subtype if you
take a broad concept and give a more
precise concept if a broad concept and a
more precise concept so the cast here
going from broad to more precise is a
narrowing and remember narrowing never
casts negative blame widening never cast
positive blame so what does this tell us
says if we've mixed typed and untyped
programs here's an example of such a mix
it's a positive subtype so it never
casks positive flame
so when we go from dynamic to the typed
world the fault is the right way around
theorem gives us that the fault is
always inside here and the other way
around never cuts right it can cast and
here the other way around right dynamic
we're getting narrower never cast a
negative light sonos here right when we
get went from dynamic to int to int if
we pass something in other oh that's
right this is going from into into
dynamic which would let us pass in
something like a character which could
cast negative leg this is precisely why
negatively it's okay for any type to be
a subtype of dynamic but not positively
and why you need if you have both
negative and positive thing you never
cast any blame at all and it's like this
so the important thing to learn here is
okay in this case if we're making if
we're going from if we're going into the
dynamic world into the untyped world
then it can cast negative flame but it
won't cast positively so the full always
belongs negatively outside if we cast
into the dynamic world The Fault belongs
in the dynamic world here if we have a
negative subtype we're casting from the
dynamic world out to the typed world any
fault that happens must be positive it
can't be negative so it belongs in here
in the untyped world so this theorem
proves for us just what you'd expect
that if things go wrong it's not in the
type checked bit it's in the untyped
checked bed and furthermore this
generalizes to tell us that something
goes wrong it's not the more
specifically typed bit where we know
these things are naturals it's in the
less typed bit
so this gives us a new slogan for type
safety right Milner slogan was that well
type programs can't go wrong Harper and
also flies in and right it's a different
way of proving this theorem which said
well type programs don't get stuck and
you today have seen yet another way of
doing this which gives us the slogan
well typed programs can't be blamed and
I'll finish up there thank you very much
it was indeed I ran out of time to show
you about is links oh right so the
question was about what is links
basically i mentioned links in these
slide titles but i didn't show to you in
the talk as i ran out of time but links
is something that we're working on which
is about the following idea right you
all know about three-tier applications
and you'll have your server written code
written in Java or Python perhaps and
then your browser will have javascript
in it and your database will have SQL or
perhaps xquery and what we do in links
is we write everything in links and we
compile to JavaScript for the browser
and compile into SQL for the database so
this fits very similar to what GWT does
but we're trying to do more so we
actually have it the case that the
server can make calls to the browser and
back the other way and in particular we
take charge of everything that you need
so that when something is in the browser
it doesn't need to be on the server all
the parameters you need are stored in
the browser and sent back to the server
so this common style of doing things
like in Seaside where it's a store
closures on the server we don't need to
do that we put all the information out
into the browser and send it back to the
server when we need it so you can
bookmark your pages and you never
clutter up the server and we have that
all running now yes
with the work by andrew leung stains
group at Indiana University on concepts
and if so do you think they've just
reinvented Haskell type classes or do
you think that there are any important
differences
okay the question was about concepts
which are an idea for C++ and whether
they're just reinventing Haskell type
classes and the answer is yes they are
and they know they are they cite the
type class work so this is looks like to
me hopefully another chance for ideas
from Haskell to get out in two languages
used by a different group of people so
yes tell everybody loud and why yes
concepts are good and yes they are type
classes from Haskell yes the fact that
you're developing a new language and the
colorful that language is like so use in
campbell does that Mueller you losing
faith in cassville ah right so in fact
links is implemented in o camel rather
than in Haskell that was really largely
a matter of wanting to learn something
new and also it was because we felt that
there would be places where we would
need side effects such as writing to the
database and so oak hamill seemed to
better match and mainly I did it to
learn more about o camel and having done
it I'm now happy to do for future work
in Haskell
but o camel still a very impressive
language I would not run it down at all
yes engineered by a class of a pipe or
maybe two or three
is there any idea actually
okay so the question is when you genera
Phi a class you could have one type
parameter or two type parameters or
three could you genera Phi over a
variant number of type parameters and
that's not supported and even trying to
think of such a thing makes my brain
hurt I know very few languages where you
can do that and where it's useful do you
have an example where you want to do
that sort of thing
Wow identicals or conscience
oh right well of course the real
solution to that is to have two pools or
functions in the type system it's the
other way around right tuples come from
and functions come from implies those
are really basic that is my faith to
emulate that this pattern of type c
slides for that later
okay so maybe there could be a nice
discussion offline which I'd like to be
involved in about this to learn how that
works but let me answer your question in
a different way I'm you're saying but I
had this type system here if I was
untied to be easy to do all this right
and have general tuples and or general
functions but since I'm typed it's
harder this is precisely why I want to
put the type to none type worlds
together so you could do that in an
untyped way and then cast it to be tight
everywhere outside the core
implementation so that's why I'm
interested in bringing these two worlds
together and a further answer to your
question I see now because you come up
with some good examples as being a bit
too facetious saying why would you ever
want to do this there are dependently
type systems that would let you get at
this sort of thing and maybe an offline
discussion I could say a bit about that
thank you for the question yes we're
going to go with do you think this this
kind of portions with positive and
negative blame can extend to dependent
type systems yes we can mix dependent
and non-dependent roles yes there's
already been some work by that by on
walker and others and that that's why
i'm going at and in fact i'm looking now
doing the same sort of thing for
polymorphism to which looks like a lot
of fun and I'm trying to be usefully
integrated ticker-type system
and that constraints be usefully
integrated into a type system probably
I'm no absolutely because that's exactly
what we do with monads and Haskell so
monads capture notions of side effect
and you can use the type class system
that I've shown you here a nice
generalization of it due to mark jones
to capture generalizing over an
arbitrary monad which essentially
captures generalizing over effects so I
can tell you more about that offline if
you were interested yes are you going to
pass dynamic results to monett so would
you folks you you can't you didn't cast
the IO monad and dynamic function it
doesn't they upload world okay so they
just said the word monad I hope people
don't all run screaming from the room
and the question was trying to protect
printing to eat with it we help because
it should be higher
you it depends on how you handle side
effects own links in fact we just have
side effects we're planning on in fact
as this other person suggested adding a
effect full type system that captures
what side effects occur but essentially
you need to have the right type so if
your type system involved effects you'd
have to have the appropriate effect type
in there yes so so that system ah isn't
is about green together long time and
type systems but in large software
systems and I see that there are like
many type systems trying to talk to each
other and this is fine if we have like
the same portion of software the same
product but sometimes we need some slack
so strong typing me
what so the question was what you're
talking about bringing together typed
and untyped in fact let me be more
specific about that what I'm talking
about bringing together is less typed
and more typed or vice versa of course
so that the contracts for instance
something like natural is getting very
precisely typed and that's what's
interesting me but you're talking about
well what if they're differently typed
which is also a good question and I
don't really know the answer to that one
that's partly comes out of my faith
again where I'm particularly interested
in the type systems that arise from
natural deduction and so that's a
particular type system that I think is
it the right one but in fact in reality
you do get lots of other type systems
and how to integrate them is an
interesting question but not one that I
would claim to address yet except to the
extent that maybe if you factor it by
going through a completely untied system
that might be useful
oh thank you for your attention in your
questions oh I forgot to tell you one
last thing sorry about this but it is
very important that you know right when
you bump into a hard problem you should
think this is a job with lambda copy</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>