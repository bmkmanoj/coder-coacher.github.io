<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DocEng 2011: Timesheets - When SMIL Meets HTML5 and CSS3 | Coder Coacher - Coaching Coders</title><meta content="DocEng 2011: Timesheets - When SMIL Meets HTML5 and CSS3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DocEng 2011: Timesheets - When SMIL Meets HTML5 and CSS3</b></h2><h5 class="post__date">2011-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VKxDB4NHWdQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to present you our work on our
timesheets are joyous projects which is
basically an attempt to use most of the
interesting things in smile in modern
when developments html5 and css3 so
here's a typical use case this is what
we wanted to implement so this is a web
radio archive so you have a media player
you have a some HTML content here that
is synchronized with the media like if
you change if you advance in time
specific sections are displayed on the
screen on some sections we have bonus
elements which can be activated by the
user and this activated we wanted also
to have content based navigation so here
you see the timeline is segmented so we
can jump from one section to another
either sequentially or directly using a
table of contents so this is a rather
typical multimedia document but oops
sorry we could have been doing it with
pure smile relying on a real player or
ambulance plugin we could have been
doing it with fresh but we didn't want
to rely on plugins mostly because we
wanted to benefit from modern browsers
native rendering we also wanted these
applications to be supported by mobile
devices we're even wanted to have one
single document to be displayed on both
desktop devices laptops and mobile
devices smartphones tablets and we still
wanted to have a declarative description
of these files to ease the authoring
wealth work
lo so this is how we did it we wanted to
keep the declarative aspecto smile but
reusing HTML and CSS as much as possible
so obviously the content structure and
multimedia handling audio video streams
are perfectly handled with html5 file
the presentation of course is done in
css3 which allows us to use transitions
animations and this leaves us with the
question of how do we handle the time
structure of the document which is both
the synchronization of the HTML content
with the media streamed and the handling
of the user interactions we could have
been doing this in pure JavaScript but
we wanted instead to have a declarative
file gathering all these time
informations and to pass these
informations with a single generate
JavaScript library this is what our
timesheets that jazz project is about
so of course this data we're not
reinventing the wheel so we're storing
this temporal data in small timing so
small timing for those of you who
haven't heard it yet it's a declarative
standard it's a rather old standard now
it's a w3c recommendation it's one of
the 12 small modules it's probably the
only small module that it's worth saving
if you ask and small time sheets is well
small time sheets a temporal counterpart
of CSS stylesheets so this allows us to
take small timing data and use it in a
separate file like we would do with CSS
stylesheets smile timing in time sheets
are designed to synchronize structured
contents in our case this is web content
mostly HTML and SVG there's been a lot
of work that has already been published
on this subject our friends from the sea
level you are there no sure sure know a
lot about that my predecessor at inria
have worked a lot in it too I'm very
pleased to see that Patrick Schmidt is
with us today because my colleague at
inria is has been terming about his work
for quite a few hours but we still
couldn't use the oldest work from
scratch as is because this work was done
before the recent improvements on html5
and css3 for handling multimedia
contents and all the nice features of
CSS transitions and animations there is
no javascript implementation of such
such time sheets there's been one that's
been done in 206 if I remember correctly
02 05 by Petra rima in Finland but this
was of course way before html5 audio and
video so we had to write our own
so this is what our contribution is
about first it is to design a timesheet
engine we needed to have another timing
model that is both compatible with
continuous media such as multimedia
streams and transitions animations and
we also needed this time model to be
even friendly to be even driven one
needed we're also proposing a few
extensions to the current spec to be
able to benefit from the new cool stuff
in HTML and CSS 3 and we're also trying
to propose this time sheets Jas not only
as a parser and then interpreter of
small timing data but also as an
extensible framework in order to build
generate components for multimedia
documents and to expose an API and
events so applications can be built on
top of this time model so here's a very
basic example that is used in our demo
this is how HTML contents can be synced
with with an audio stream so as you can
see here this is pure small timesheets
market mmm for every item we have a
select attribute which which has which
is a target let's GSS select the target
so we are getting here the element that
has the ID section 1 and while telling
it to start at the very beginning of the
media stream since we're in a Mexico
time container follows smart semantics
the second item will start at one minute
and 12 seconds and when it starts it
will hide the first item and so on until
the the media stream is over so this
allows us to
to keep the HTML content in sync with
the the other track but it also allows
us to use temporal navigation like in
this link here if I'm asking for to
display section 3 it will jump to the
third section so this allows to give
temporal links well this ensures that
special links also have a are handled
under the time dimension this begin n
attributes may contain non numerical
values this is what we call even values
so people who design SVG animations are
should be aware of that it's element ID
dot dominant type so this is what we use
here to display our bonus sections when
we click on this button we display the
the bonus when we click here we hide it
so this is what is described here the
second but the bonus of the second
section starts when we click on the
button that has the ID open to and it
ends when we click on the button that
has the ID close to as we also wanted
these bonus to be hidden when we jump to
another section we're adding this
section to that end this is an
interesting case simple but every time
that an element that an HTML element is
activated or deactivated by smile it
fires a big in an end even through
spectively so this can be used in your
own JavaScript so you can set even
listeners and start your own bunch of
code when this all that element begins
our ends but you can also use these
events in a time structure in a time
sheet to synchronize the
another time tree with the activation of
this activation of any element as
mentioned a bit earlier we wanted this
library to be extensible we we have
multimedia documents we want them to be
hackable like any other HTML plus
whatever documents so we have these big
in n events that can be listened to you
also can set on begin on a attributes
should the completely equivalent we also
expose an HTML media elements API so
this API is the one that you have to
control audio and video tracks so it's
rather well-known now but my most web
developers and we found that it was
relevant to expose a significant part of
this API to our time containers because
our time containers even if they're even
driven can be seen as a media player at
least at some point on this HTML media
element like API you can build a set of
user interface components that can
benefit from this time informations and
from this smile way to activate and this
activate HTML elements this is for
instance the case of this timeline here
the the timeline itself the segments
here are created in positions according
to the temporal data that is being
gathered from the main time container
these a button first to get to the first
section the to get to the next section
and the last one are also using smile
stuff too
all the control the media and even the
table of content here the way that it
that it works that it interacts with a
with the documents is relying on smile
stuff yeah and we also in our library we
provide a parser which is very flexible
so you can even decide to add your own
custom attributes to your time sheets
this is this can be useful if you want
to address this very specific need that
is not generate enough to be part of the
specification but it's also very useful
if you want to test a new attribute that
you would like to submit to the to the
spec so it's a good way to test
non-standard behaviors or non-standard
features on on a well-known small basis
so I would like to thank her they go for
giving me the conclusion of this
presentation yesterday this was his
conclusion at yesterday's html5
multimedia workshop there's a huge value
in the flexibility and readability of a
higher level timing and synchronization
model there are model alternatives to
smile Rodrigo is working with the
popcorn at jay's for an example there
are possibly other all the time model
this is how I think that the key
benefits are using small time sheets the
first and most important one for me it's
a bit old school now that's separating
the contents the presentation and the
timing still make sense for a lot of
users the content in HTML presentation
in CSS and timing in smile allowed to
have clearly separate the tasks you can
reuse some HTML contents give the
presentation task to a web designer and
leave an author play with us with smile
to write a scenario compared to flash or
pure smile solution the fact that we're
using the browser's native rendering is
a significant plus we're relying on a
very lightweight JavaScript library I
think it's a little under 8 kilobytes at
the moment it's completely cross browser
there is no jquery or whatever
dependency to an existing JavaScript
framework though it's compatible with
most javascript frameworks it works a
lot of browsers including mobile device
even including ie6 because we're using a
few fallbacks when necessary so a single
file can be served to almost any browser
from ie6 to the android stock browser
going with Oprah
Firefox Chrome whatever it should work
in all cases if not please ping me it's
a stable syntax when designing your own
data format choosing the syntax is not
an easy task you especially if you want
to interoperate with other people who
are providing content for your
application so relying on the w3c
recommendation even if it's not built-in
in browsers does make sense in this in
this purpose there are still a lot of
user who are still quite familiar with
smile who can reuse their skills using
this library which they and they could
not do spend enough time to be
proficient with JavaScript to implement
a similar behavior on your own there
multimedia documents so this is why a
declarative management of all these user
interactions all the time
synchronization with the HTML content of
the media can make sense the other
points of having a declarative syntax
for that is that it paves the way for
authoring in validation tools you can
consider at some point that the
implementation is tested and that it's
testable and then you can have your own
tools to validate to be sure there's no
inconsistency in your scenarios that is
scrubbing Spile as i mentioned it's
usable by non-developers i suggest if
you have some time to try this URL those
guys have been doing like 20 or 30 or
maybe more smile based slideshows mixing
reusing old PDF slideshows and
synchronizing them with either video or
audio tracks and it's extensible web
developers
you want to build an application a
multimedia based application you can put
much of the temporal behavior in a small
file and build your application on top
of that this is what I'm trying to
represent with this with little schema
this is the typical web based approach
content in html5 presentation css3 and a
good bunch of JavaScript to synchronize
everything with the with a multimedia
tracks handle the user interactions and
this is what we're proposing it's very
similar but the difference is that were
proposing a document approach all the
all of a scenario all the timing
synchronization and even handling is
done in document small timing of course
which is interpreted by James crib but
it's a document and you can still use
JavaScript to enhance this document to
make it more interactive or to be part
of a bigger more generic app and that
sits I we have a few use cases on our
website feel free to try this URL and
you'll see a few a few other use cases
this is not only dedicated to multimedia
like this slideshow here is a pure
timesheet stuff it's there is no
specific JavaScript code it's entirely
described in the timesheets feel free to
contact us if we care if you're
interested in this technology or want to
implement it for specific tubes and
thank you for attention
yes
hi is the song this partnership the work
is very nice we've been following it for
a long time there are some general
questions I think that one of which I
posed yesterday but I'd like to repos
today if we look at integrating smile
timing with HTML using HTML as the host
language then there are two general
approaches one is and both of these were
proposed initially at about the same
time one is to have out of line timing
in timesheets the way you do it and the
other is to have in line timing which is
the approach that was developed by HTML
plus time as I understand it your
library allows for both that you could
have great both in line timing and out
of line timing for the applications that
you chosen why do you think you've
stressed the the out of line timing why
do you think see is that a better
approach if so why do you think that's a
better approach because that's more of
the timesheets model than the time
integration model that has been around
for for a while it would have been
possible to do it with inline timing but
it wouldn't have been as hand in there
are two things the first thing is we
wanted to be able to to give the
presentation task to a web designer and
leave the scenario the synchronization
with the media to the real author the
content author so this allows us to more
flexibility just for the offering
workflow but there's also a technical
reason for that which is mainly these
bonus boxes if we used in line timing we
would have had to it to design the Dom
structure to take this time instructor
into account so we had to keep both
trees somehow parallel the the special
tree the Dom tree and the timing
should have been consistent together
with the timesheet approach we can think
of the Dom structure completely freely
and then targets specific elements of
this Dom structure with the timesheets
playing with the CSS selectors so this
offers more flexibility it's not a
matter of reusing the the timesheet in
other radio archives because this is
very specific to each archive but it's
just a matter of not having to cope with
the Dom structure when thinking of the
scenario of the time scenario although I
would think that with native audio and
video elements by separating that
structure out you'd actually increase
the maintenance burden because people
could have non-identified pieces of
audio and video that that may conflict
so that you're you're not all of the
temporal control some of the tempo
control is implicit as part of the Dom
structure of the sort of basic html5
presentation and others of it are
controlled by the timesheets do you see
that as a maintenance issue in so that
it's a sort of a problem of separating
out part of the timing structure from
all of the timing structure if you
understand what I'm saying yes yes I
think there is a great area in the spec
because if I followed you if if you have
both in line timing and external timing
one dumb element can be the target of
several time nodes and one several when
one time nodes sighs this element has to
be activated and when another one say
this element has to be this activated
what should we do so should we consider
that the last rule wins like we do in
CSS should we consider that it's kind of
a Schrodinger box where every element
can be activated of this activated by
several times trees my personal opinion
is that we should keep the CSS approach
like the last one who speaks when and so
the inline timing could be used to
define exceptions to the rules that are
defined in the in an external timesheet
that's my guess I've tried to use the
other approach and it quickly became a
nightmare okay but I guess the point I'm
trying to make is that some of the
inline timing is implicit because some
you can always toss in a video tag that
plays a piece of video and if it doesn't
have a class attribute or another
control attribute that refers it to the
JavaScript timing to the timesheet
timing then you have and yeah you
haven't applied the video that we have
an html5 or SVG one dot 2 is not the
video that we have in smile there is no
implicit timing of audio and video at
least in our approach unless you're
explicitly defined media sync attribute
to say this time container is synced to
this media and then you're defining
explicitly a time behavior to a media
but we're considering that the by
default this should be the time
structure of an HTML page which means no
time behavior by default ok I've won one
question then you can you can go and the
other is the support for this within the
just helping you out here support of
this approach within Mozilla Mozilla who
has some proponents in their
organization that that take a sort of a
different view that is a more you know
any concept worth having is a concept
worth reinventing and you know that kind
of goes against the the reuse issue do
you is there you know I know this broad
support for this within inria of course
where people have been looking at this
for a long time but have you have you
found broader support for example within
Mozilla for this approach not much this
is a discussion we had yesterday with
nothing this is team basically bringing
a JavaScript implementation is like
shooting in oneself in the food because
then people will ask why would you want
this to be a part of the browser if you
can do it in JavaScript so there are at
least two reasons to include this in a
in a browser the first one is that we
need a more fine-grained control of the
synchronization of the continuous media
currently the html5 API gives us 250
milliseconds time rates which is way too
low for lots of applications and there's
also an accessibility concern which is
very difficult to address with a pure
JavaScript approach so I'm in contact
with Silvia Pfeiffer for the
accessibility at Mozilla and other guys
and the content team at Mozilla for the
Seder the more classical content
approach should this be part of browser
or not and mmm it's it's not taking good
shape because the mostly the fact that
Microsoft's has a Benden HTML plus time
exactly at the time that they're
enabling audio and video and at some
point SVG in ie9 and now CSS transitions
and animations with I 10 hasn't been
well accepted by well has been a strong
argument of not doing it in the browser
the other thing is that for most people
when they hear smile there are thinking
of SVG animation and they're saying why
on earth would we use smiles since we
already have css3 animations so there's
also a work to be done to explain what
can be done with timing with small
timing to having a decent editor of
small timing would help a lot too and I
feel guilty about that because that was
another part of my contract that i had
with inria and which i have some kind of
a beginning of an editor but not the
kind of editor
I couldn't put in everyone's hand so I
think there's a lot of evangelism to be
done and probably the best approach in
my opinion would be to forget html5 for
a moment to focus on SVG too because
they already have audio and video tags
they already had a bit of smile because
they implement a significant part of the
basic animation module and most people
who have tried to do a CG animation are
very frustrated by the fact that they
can't add any time structure to the
animation so I think we should start
proposing this timing or timesheet
approach to SVG and see how it goes then
with a html5 okay just one question and
one comment also as a member of the SDG
working group we can talk about as we do
too but I think we will have also big
debates but ok the the question is
rather short smile timing module is
quite a big beast and in particular it
has nested time containers yes this is I
think one of the major arguments against
smiley within the html5 community that
it's too big to implement in your
scenarios have you experimented with
nested time containers yes sure well not
in this demo because I looked at the
website for example you this ens Lyon
website and most of them follow this
yeah template most of these at the NS
Yoong it's a bit like that it's one
hundred percent are almost immediate
driven so it's just one big time
container and begin dates to synchronize
every HTML fragments with a little media
but
oops maybe some Wi-Fi would help okay
maybe but uh you can have on the very
front page of the timesheets website
here Oh again you have nested time
containers and if you go to the
slideshow sections you'll see that we
are nesting time containers for many use
cases but it's rather in an even driven
approach that we're investing time
containers for instance in this
slideshow I've implemented the slidy
microformats with pure time sheets so
it's only a 20 line time sheet which
implements the hole slightly microphone
at and in this time sheet who are
already nesting time containers okay I
think that's the major argument for
smile at the moment nesting time
containers because that's what's missing
in all other you know each animation
true</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>