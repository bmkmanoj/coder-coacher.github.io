<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Revolutionizing optimization and search using quantum computers accessed via... | Coder Coacher - Coaching Coders</title><meta content="Revolutionizing optimization and search using quantum computers accessed via... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Revolutionizing optimization and search using quantum computers accessed via...</b></h2><h5 class="post__date">2007-12-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7bWi9tAn6xc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thanks everybody for coming my name
is Jordi rose I'm the founder and
currently the chief technology officer
of d-wave we are trying to build a
quantum computer and today I'm going to
talk to you about where we're at the
system that we've built and what it's
for and particular reason I'm here today
is that the system is mature enough to
start to use and so I'm looking for
people who would want to participate in
using the preliminary versions of this
and to that end what I'm going to try to
do is be as precise as I can about the
type of problem that this thing is
designed to solve what might be a good
fit and whatnot what's not and try to
stimulate your thinking a little bit as
to whether or not you may have some
problems of this sort that are buried in
the the types of things you do from day
to day at Google so I'd like to thank
Dennis crew penticoff back there for
setting all of this up thanks very much
so this is going to have three parts to
it the first is a description of what
the system is and what it does and this
is more on the side of the what the user
sees so when you when you actually
access the system what do you see and
what can you expect the system to do
then I'm going to talk about the
processor itself which is the heart of
the system and explain to you to the
extent that i can how it works and then
i'm going to talk a little bit about
what we might expect for performance for
the system just as a as a teaser
building special-purpose hardware for
computing has a spotted history and a
lot of times people have tried to build
special purpose machines for certain
types of problems and more often than
not those things eventually fail because
commodity hardware catches up and passes
it so the reason why you might want to
do it this way with this particular
hardware is there's a chance that by
building processors in this new way that
I'm going to describe you may gain a
scaling advantage that you can't compete
with classically so what that means in
in practice is you may put yourself on a
trajectory which is faster than Moore's
Law and potentially much faster than it
so that commodity Hardware can't catch
you in fact it falls behind you as as
the technology advances so the the
system that we've built has as its
design philosophy building a computing
system that allows you to pose and solve
arbitrary problems of a certain type
which those of you who have theoretical
computer science in your background will
recognize the words if you don't don't
worry I'm going to describe what these
things mean therefore a set of decision
and optimization problems which are
called respectively NP complete and
np-hard so the these types of problems
are very hard in a sense that I'm going
to describe their intractable also in a
sense that I'll describe but they're
also ubiquitous they happen all over the
place in all sorts of industries and
people have to find ways to deal with
them so this is going to be an alternate
way to deal with these types of problems
that shares many of the drawbacks of
current methods but it potentially has
an upside which is greater than all of
them the system itself has been
architected with a constraint in mind
the system itself is big it's ornery it
has a fridge attached to it the chips
need to be cooled almost absolute zero
and therefore you have to have a model
for use that doesn't require that the
machine be sitting right next to you
when you use it and because of that
we've tried to architect the system in a
way that's modular so that the user can
interact with the system via Web
Services approach so that there is some
kind of an API that you is very well
document and understood and all you do
is your program to that API and what
we're trying to do is to make it so that
the system can integrate seamlessly into
whatever you're doing so if you happen
to be solving one of these problems
using a conventional classical approach
you can yank the solver that you're
using out and stick this thing in and
nothing will happen to your existing
application you don't have to change the
language you programming or anything
like that
so just a brief digression before I go
on because this is kind of a central
point to all of this and I apologize to
those of you who know all of this
there's a branch of computer science
called computational complexity and the
idea is to categorize problems into into
groups that all share similar features
and one of the most important things you
might want to know is that as you feed
an algorithm bigger and bigger problems
how does the resource requirements scale
so if you double the size of the problem
how long does what is the additional
time consumption as you do that and good
algorithms tend to be linear or a little
bit worse bad algorithms are exponential
in which case you know you get to a
point where you just can't solve a
bigger problem so the NP category means
this that may or may not mean something
to you I'm going to next slide I'm going
to talk about the way I think about this
and they're all decision problems so the
category of NP means the problems that
resolve to a yes or no answer so as an
example of this I might ask is there a
path between San Francisco and Vancouver
that costs me less than five dollars and
I'm flying on a plane so there's a
there's a question which is he has a
yes/no answer and in order to answer
that question might be trivial but it
might be very hard if you have to search
through many different possible
instances so here's an example of an NP
problem and it gives you a kind of a
flavor for understanding the way these
things work so this is a simple
tic-tac-toe game and you're given some
initial position and the decision
question that you're asked is can all
win from this position so X goes next
and then oh and the next so each of
these trajectories along this direction
our particular game instances you can
think of this as moves in chess moves in
tic-tac-toe decisions that are made that
are binary along along this chain so all
NP problems have
have the following characteristic that
for any particular sequence of moves
it's very easy to check whether or not
in that particular instance the question
is is yes or no so the question can Oh
win if you track through one of these
paths in this case you can look at the
answer and say no oh did not win this
particular instance so one another way
to think about that is that given a
particular answer it's very easy to
check whether or not that particular
answer satisfies your yes or no question
so that's the first thing the second
thing is that there's a possibility that
there is an exponential number of these
so if you can imagine every time you
have to make a move like say for example
in chess a total game may only be a
hundred moves it's very easy to check
who won a game all you do is you give
the moves and you can say okay well
black one or it was a draw whereas a the
total number of possible chess games is
enormous so these problems also have
this feature that the total number of
possibilities can be exponentially large
and the frustrating part of these
problems is it's not clear whether or
not this exponential ends up being a
cost that you have to pay in principle
no matter what or if there's a smart way
to reduce this and this is a very tricky
and slippery question that people have
been thinking about for 40 years and
they're still unresolved issues as to
the nature of this type of thing now
this particular example is not a hard NP
problem but all NP problems have this
kind of nature so a little bit more
jargon NP complete are the hardest
problems of the sort that I just
mentioned there are things for which the
canonical version is something called
satisfiability but they have this
feature that all problems in this
category are mappable to each other with
that most polynomial cost so what this
means is that if you can solve one of
them with polynomial resources you can
always map to another one and solve that
in polynomial resources so if you solve
one of them they'll fall there are
literally thousands of them the best
text book that I've ever seen on this is
by a book by gary and johnson which is
kind of a the bible of the field another
important thing about these things is
that there's at there's no known
algorithm even with quantum computers
that can efficiently solve these in the
sense that you can solve them only using
polynomial resources always there are
algorithms that can solve them
efficiently but they don't obey the laws
of physics as we currently know them so
is lift corner mechanics is right in the
way that we understand it there's no
efficient algorithm known that doesn't
mean there isn't one but we just don't
know one of them np-hard are the
optimization versions of these decision
problems so the one I gave before is is
there a path between Vancouver and San
Francisco that cost less than five
dollars that's the decision version the
optimization version would be find me
the minimum cost for a flight between
Vancouver and in San Francisco so
they're they're almost identical in the
way you posed them in cept except you're
not asking is there you're asking what
is the minimum and they're there they're
very strongly related but there's a
little bit of complexity hidden here in
the difference between the two that's
not important for this talk so when you
think about np-hard all you can think
about is it's just the decision problem
but you're asking for a minimum or a
maximum okay so given this vast sea of
problems that are of this sort NP
complete and np-hard which are literally
everywhere they underlie a lot of
quantitative business in all sorts of
different sectors not only just the
obvious ones question is how do you
create a computing system that will
allow you to pose all of this myriad of
questions in a reasonably effective way
that eventually will be solved on a
piece of hardware that we're building so
the way that we've tried to do this is
that the the hardware itself solves one
particular one of these np-hard problems
and I'll talk at length about which one
and how it works but you have to be able
to be flexible enough to use this in all
sorts of different other ones that
aren't natively that so the way that
we've architected the system there are
web services like
ap is at several levels of abstraction
so as a user you can come in at any one
of these levels and the most primitive
of which is that you can say okay well I
have a problem and I know how to
formulate it as an integer program or a
satisfy or something else so you can go
right in and say solve satisfiability
problem and then just state what it is
and the thing will compile down to the
the hardware the hardware will solve it
and kick your thing back up if you don't
want to state the problem as is that in
that primitive form or if your
particular problem does not have one of
those primitive api's yet developed what
you can do is go up a level and program
in something which is a more commonly
used language for interfacing with
optimization problems and decision
problems something like ampl or
constraint satisfaction programming
techniques the one that I'm going to
talk about a little bit is sequel
standard query language which we've
developed a an addition to which allows
you to pose any NP problem and then
above that you can then consider
accessing just applications where all of
the underlying stuff is being worked out
and now you're actually using that
capability to solve some real-world
problem like a scheduling problem or a
an optimization problem of some sort
that you care about so there's three
ways that this can work it's architected
to be able to be used in in all three
ways the first is that you consider that
the customer and the data are the data
is proprietary the customer they don't
want to share with you of course so you
have some high level software that is on
that side and all they need is a browser
to access everything that's behind it
which is all residing at the facility
where the quantum computer is all this
stuff is on conventional servers running
some pre-processing and post-processing
and then there's the hardware at the
back end so that's the first way that
you can do this another way which is
probably the way that will be done in
the short term is that there will be
quite a quite a lot of crunching
happening on the user end so you can
download some of the computation on to
the user
side for getting the problem ready to be
poured it on to the hardware and the
third one is of course everything in one
box so this is the sort of thing that is
not going to be available in the short
term because this is quite unwieldy I'll
show you some pictures but ultimately
that's excuse me where we want to take
it so that you can just buy a box will
sit in the corner all the software comes
with it and you can use it for whatever
you like okay so I want to say a few
words about my favorite way to program
this thing it's very simple to use and I
think very it clarifies a lot of the
issues here so let's say that you were
starting from scratch and you wanted to
build a quantum computer and you're
faced with this issue that how do you
get the average person on the street to
be able to use it because what's going
on under the hood is all this quantum
mechanics stuff and a lot of people
don't really understand quantum
mechanics are all so the the question is
how do you abstract the quantum
mechanics away from the user and I think
that you're forced to use a declarative
programming language so what you have to
be able to do is provide the user with
the ability to declare state what the
problem solution looks like without
having to give a prescription for how
the machine actually functions step by
step by step so that step-by-step
functioning of course is required but
you can hide it so what we looked for
were known existing declarative
languages that a lot of people knew how
to use and the one that you know came up
as number one on the list with sequel
standard query language which is
declarative in the way that we need and
it's very easily flexible xed to the
requirements for programming one of
these things so all we did was add a
single keyword to the standard lexicon
of words you use in sequel find find is
very much like select what you do is you
state in the fine statement a logical
sequence of operators ands ORS not
swears all these sorts of things that
define what your problem means and
there's a very interesting thing that
has only recently become
practical which is this understanding
that the logic captures NP which means
that there are all NP problems can be
posed as logic problems which is not at
all obvious I mean that's a very deep
thing and you can use this then to build
an interface which is very flexible and
easy to use which we've done and
deployed so going back to the original
interface picture if you come into this
and your particular problem is not on
this list which it probably won't be you
can go into sequel program what you mean
develop an API and all of a sudden
there's a new box here that you created
using sequel and then anybody who comes
along can then use that box directly
without having to re reinvent the wheel
so here's just a short example to
illustrate how it works so let's say you
wanted to find an independent set of a
graph so graph is just a collection of
edges and n nodes simple graph right
there an independent set is a set of
nodes no two of which are connected by
an edge so the way that it works in the
sequel idea is everything is in database
language so you start out with two
tables one of them as a table of
vertices one of them is table of edges
and what you want to do is fill in a
third table which is a list of vertices
that's the solution to your problem so
when you code this up in the fine
statement type syntax you see something
like this so if your database programmer
this will basically just read like
English the idea is very simple you're
defining a thing that you want and you
said have a set of logical statements
that defines what it means to be an
independent set and when you enter this
it will automatically be compiled down
to some canonical logic which is then
compiled down to the hardware so this is
what an answer looks like you get a list
of vertices 135 no two of them are
connected by edge and you get an
independent set so what are we going to
do with this thing the first thing we're
going to do is deploy it in the wild
because there are there are problems in
us actually going out and finding
problems like this or self we can make
a lot more sense for people to come to
us because it turns out that it's very
hard to find these things taking a rifle
approach you know as much as I like to
think that these problems are like i was
saying ubiquitous it turns out that in
practice usually people avoid these
things you know they'll have they'll
have an application or an end goal in
mind and when you look at it in first
principles there's one of these things
there but for some reason it's
intractable so you kind of forget all
about it and you go around it and you
build something else works fairly well
so what we have to do is find ways to
make people think deeply about the types
of problems that they're solving an if
they had a really effective solver of
this sort would it really matter and I
think that the right way to do that is
to provide access to it you know 24-7
let people think about it come back to
you use it hammer away at it and see if
something comes with it so what we're
planning on doing is providing access to
all of this API stuff that I showed and
sponsor collaborative applications
development in kind of sourceforge kind
of model and from our perspective the
main thing we want to do is understand
why people would want to use this
machine if in fact they do want to use
it which is still kind of an open
question so if in fact people really
want to use something like this what are
they going to do with it or is it going
to be image recognition is it going to
be some kind of pattern matching is it
going to be a biotechnology application
is it going to be all of them none of
them something we didn't think of and we
want to be able to architect the system
to be able to scale to literally
millions of users because I think that
if this catches on there will be
applications for which there are going
to be millions of users so you can
imagine generic scheduling problems of
buses and cities of things like this we
want to be able to capture those
opportunities if they come up so here's
the roll out next week the first release
of this will happen in the wild very
excited it's been a long time since I we
started the company and it's it's it's
basically ready to go which is very
exciting for me and then over the next
year we're going to add more features
and scale the thing up eventually
co-locate the machines with these
servers that are running the front
stuff and then about a year from now
release what is probably going to be the
first machine that will be able to
consistently beat conventional
approaches at least for certain types of
problems and that thing is going to have
about a thousand cubits and I'll talk
about what that means so just to
summarize the main features of the front
end is that the system is architected to
be really easy to use it really is you
know this is the easiest thing I've ever
dealt with to program it doesn't have a
lot of the hard problems that
conventional supercomputer approaches
have parallelization and you know having
to vectorize everything and thinking
very hard about the details of your code
because it matters so much this is very
flexible and easy you know all you do is
you basically stayed in logic what you
want to have done and the the
interaction with the machine is very
straightforward it's about to be
released and it's going to be a very
limited release if anybody wants access
to it let me know and the thing is
designed to solve this particular type
of optimization and decision problem
okay so that was the first part so now
the second part i'm going to talk about
the actual processor itself so i have
one here this was the generation before
the one that we we ran the demo on in
February so this is a circa January chip
if anybody wants to see it you can see
it later I think the one of the most
amazing things to most people when they
see this is that the qubits are actually
quite big so the way that we build these
things using these superconducting
metals the qubits end up being visible
with the naked eye and that goes counter
to what you may think or have a
prejudice towards with quantum computing
you think electrons and photons and all
that the approach that we've tried to
take is to stick as close as we can to
conventional semiconductor fab because
fabrication of hardware is one of the
big bottle next to this field so you can
have lots of really crazy ideas about
how you might build a quantum computer
that end very suddenly when you realize
that there's no way to build what you've
just invented so this particular
approach has the advantage that you
don't need to reinvent the wheel and why
superconductors support large structures
that behave quantum mechanically is
probably outside of the scope of this
talk but they do and that's well known
so the there's there's a core concept
that underlies the processor design
which is kind of the driving philosophy
behind all all d-wave which is that the
what we're trying to do is build a piece
of matter that through its natural
physical evolution solves a hard math
problem so the idea is that you're
building an analog computer at kind of
the fundamental limits of what nature
allows the way that it works in practice
is that the native language of the
hardware is what's called an integer
program and the integer program is also
known as the Ising model in physics and
this particular problem has this dual
feature that you can look at it in two
different ways so integer programming at
least the optimization version of it is
np-hard the decision version is
np-complete these types of problems have
serious ramifications if you can solve
them efficiently and i'ma say you can I
don't think you can but if you could a
lot of things about the way that
computers assist us in our everyday
lives would change dramatically things
that are now intractable or considered
to be out of the scope of what you could
ever do might become easy depending on
how fast the algorithm scale polynomial
if it was linear for example the world
would change dramatically basically
overnight so there's a very clear
conception to people who study these
problems from the computer science side
that they're hard they're important
they're not simply of theoretical
interest they're also practical interest
and being able to solve them efficiently
would mean significant breakthroughs in
all sorts of sectors now if you're a
physicist the model which is exactly the
same thing so all I'm doing is changing
the words the actual math is identical
this thing is the Ising model the Ising
model is probably the well it's a pillar
of statistical mechanics it underlies a
large amount of the work that's done in
modern physics and basically it's a
model for describing anything where you
have interacting components and this
leads me to the one slide that you
should remember if you remember none
other about the processor is that the
cork on
is very simply to build a machine that
uses this fund fundamental laws of
physics to solve a math problem in what
you can think of as an analog computing
manner so you're building a piece of
matter through which just naturally
cranking along the way that nature's
equations work is attempting to solve a
problem which is very fundamentally hard
so when I say building an analog
computer sometimes people have a very
strong of adverse reaction to that
because they're thinking of classical
analog computers that have serious
deficits the most commonly noted of
which are the variables that you're
using are continuous and errors are very
hard to get rid of they're not you can't
get rid of errors because they're not
naturally digital errors are also analog
but what I me really mean by analog
computer is this which is really the
fundamental definition of what an analog
computer is and in a quantum system you
have natural discreetness that arises
from the laws of physics so when you
build a qubit</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>