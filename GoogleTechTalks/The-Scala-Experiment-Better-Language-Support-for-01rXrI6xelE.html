<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Scala Experiment:  Better Language Support for... | Coder Coacher - Coaching Coders</title><meta content="The Scala Experiment:  Better Language Support for... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Scala Experiment:  Better Language Support for...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/01rXrI6xelE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming I'd like to
introduce Martin odor ski from EPFL
Martin was one of the people responsible
for the addition of generics to java and
he's been doing a lot of interesting
work with programming languages and he's
going to tell us about his work with
skele thank you barely ok I put it I put
it up with a better yes ok thank you ok
so thanks for the nice introduction and
the invitation to give a talk here I'm
going to talk about what we worked on
over the last but five years and what we
have released over the last two and a
half years it is a very big experiment
in language design and also in language
adoption and the language is called
scala or scalar in the American
pronunciation and so the the original
question was can be designed better
languages for component systems and I'm
going to start my talk that way but
really scholar now is probably more than
that guy I believe it's a language which
is really not very nice to use in a lot
of contexts component systems and other
systems as well but for component
systems that's what we try to do first
and so so we're going to talk about that
so if you look at the state of the art
in component systems then it's actually
pretty miserable so in principle our
principles are clear software should be
constructed from reusable parts markets
for component systems have been
postulated ten years now that you would
have a market like for hardware parts
where we have suppliers of components
and customers of components and all that
in practice very little of that has come
true so most software still written from
scratch more really like a craft than an
industry and because I'm a programming
language persons I have to look at
programming languages and I have to have
to see the programming languages oops
shouldn't talk to her no it's not my
voice right so programming languages
shared is part of the blame I believe
because ma
existing languages offer only very
limited support of components and
ironically this holds in particular for
the languages that they have been pushed
hardest as component languages and we
statically typed languages such as Java
or C sharks things that tend to be a bit
better in dynamically typed languages
such as small talk Python or Ruby they
actually have more flexibility to do
components and in static languages so
we'll see why there it is in a min in in
a minute oops so question is how to do
better how to improve on the state of
the art and we started our work on two
hypotheses the first one is that
language is used for components
obviously need to be scalable that means
you should have a common set of concepts
in which it can describe small parts as
well as very very large parts the
question is why why do i do I think that
and I think the answer is simply because
the pads vary so much in size a useful
component could be a 10 line object or a
10 line function it can also be a
hundred thousand or a million line thing
so once you start saying well we have a
language for small things in the
language for large things well maybe
small things are up to 10 lines large
things are up two thousand lines then
you will need to introduce another
abstraction for things up to 10,000
lines and another for things up 200,000
points so it's clearly self-defeating
that way you get a lot of different
constructs which which don't really play
well together so the second question was
how do we achieve the scalability and
there our hypothesis was let's try to
generalize and unify functional and
object-oriented programming and we'll
see in the end how it worked out it's an
experiment after all so but we must have
had some reasons to you unify FP and orp
what were the reasons well I think the
two areas really have quite
complementary strengths for composition
functional programming it makes it very
easy to build interesting things quickly
from simple parts using things like high
order functions algebraic types and
pattern matching parametric polymorphism
so you can quickly get something off the
ground there object-oriented programming
the other hand makes it very easy to
adapt and extend complex systems using
subtyping and inheritance dynamic
configurations because objects the basic
components can be rewired as you want at
runtime and also often overlooked in the
functional community classes are really
incredibly useful this partial this idea
of partial obstruction that you just
define something and you implement what
you can and what you can't implement you
just leave abstracted you delegate two
subclasses this is very very nice
actually so in summary functional
programming is very nice to get
something quickly from simple parts
object-oriented programming is very good
to adapt and extend the existing systems
so the question is if we combine the two
what do we get well that's sort of the
theory but there in reality my reason
for reaching to combine function and
object-oriented programming was that
didn't want to sit anymore between two
chairs because what happened in almost
all of my professional career before was
that everybody says no no this guy
doesn't belong to us for the part for
the function programmers I was this guy
doing objects a bit weird but yeah not
dangerous and for the object-oriented
guys about it was this functional
programmer is as well this is this
theoretical guy we can ignore him it
sykes to ignore him so I I was tired of
sitting between the chairs so now I want
to show that really object-oriented
programming function programming they do
indeed go very well together maybe so
well that at the end you don't even want
to distinguish in them anymore you want
to talk about I think the distinction
between objects and functions this is
really by now fairly mode so to come to
scala skaara is an object oriented and
functional language and its other
characteristic is that it's completely
interoperable with Java there's also a
dotnet version which is currently under
reconstruction that means that it lags
behind in division in the latest version
currently exists only on the JVM so what
we did is we removed first some of the
more arcane constructs of these
languages such as I believe static
members of classes that something pretty
arcane and we added instead from the
object-oriented side
the idea of a uniform object model
that's being well proven in in a lot of
languages starting with small talk from
the functional side we added pattern
matching and high order functions that
sort of your standard constructs that
you see there and what we we did not
only take things that were known from
bit before what we also found out in the
course of the products new way to
abstract and compose programs and I'm
going to talk more about this so we have
an open source distribution of Scala out
since january 2004 version 2 is out
since i think january this year and we
currently have about a thousand
downloads per month so it's reasonably
popular and the community is currently
in trying off be of building so people
are starting to do big projects in Scala
some big British government websites
running this gala people are starting to
do tools so for instance we didn't make
clips plug-in but people had NetBeans
are actually doing a plug in for muscala
p-plate IntelliJ also doing a plug-in so
that shows that actually there is
interested people the important thing is
that people get so far that they're
willing to invest some of their time
because otherwise you just push it push
and push and push and people said no no
no we want more and more and more in it
self defeating okay so in the following
I'll show you three I can't show you the
whole language that way that that way I
probably would need two hours and you
would get grow tired so I just pick
three examples where formerly separate
concepts of functional object oriented
programming are now identified and this
fusion leads to something new and
interesting so what we are going to look
at is how we unify the idea of algebraic
data types and pattern matching in
functional languages with the class
hierarchies of object-oriented languages
we're going to look at functions
identified with objects functions are
objects that's very close to the
proposal on closures that meal is
currently working on and finally we're
going to look at programming in the
large how modules go with objects and
well actually how modules and objects
are just two coins of the same to two
sides of the same coin so first
unification
idts algebraic data types are class
hierarchies that's actually the most
controversial one so if I talk to
object-oriented programmers and it said
well we add high order functions we add
parametric polymorphism and the ad
pattern matching as a higher-order
functions show we have them in small
talk well sort of and parametric
polymorphism is also no problem we have
them with you have that in Eifel but
pattern matching ok but pattern matching
go away that's that's just not so not
object oriented so the common objection
our pattern matching are not extensible
pattern matching are impure because you
they break the purity of the object
oriented model and finally pattern
matching breaks encapsulation let me go
back so that's the objections no
extensibility violation of the purity of
the overall model breaking and
capsulation and that's why capital
matching is universally rejected by
object oriented programs so i have to
show you how we do that in skala so
here's a very simple example of how we
do it we have here a definition of a
binary tree of an arbitrary element type
so oh sorry that was a type of it should
this should read abstract class tree of
t where t is a type parameter we so we
write type parameters in brackets rather
than angle brackets as in Java and C
sharp then we have two cases the first
is a simple object empty which is just a
singleton thing which is an extension of
tree and the other is a class binary of
an element and the left tree in the
right tree and that's another extension
of tree and the case modifier that
special that actually means that these
are classes I want to pattern match on
later on so that's the only thing you
need to add to be able to do pattern
matching so here you have a standard
function over these things that would be
an in order traversal function
so it takes an arbitrary tree of
arbitrary element type T and it gives
you back a list of tea and then you have
a match statement that says that matches
the given treaty with a bunch of
patterns here we have to the first would
say well in the case where the tree is
the empty tree return the empty list and
the second says indicates where the
trees are binary tree with an element e
a left 3 l and then write three are so
the choice of these variables is of
course completely arbitrary respond with
inorder traversal of L followed by the e
node seen as a list and the inorder
traversal of our so these triple Collins
they are just list concatenation
operations standard methods in our list
class okay so so far so good so yes I
think there's mostly historic match used
to be a method in the object class and
actually you still can see it like that
sort of because this in fix thing any in
figs operator is seen as a method is a
method call of usually its left operand
some in figs operators are method calls
of the right operands but they are
syntactically different
yeah sure so there's a slightly
syntactic different please if their
questions asked ask where we go it's
probably better that way okay otherwise
everybody can read that that's good so
you can argue that this design really
keep security because all cases are
classes or objects and that's all we're
dealing with here it keeps extensibility
because where we've seen two cases here
but you're completely free to define
let's say a third case called ternary
for a ternary node somewhere else in a
different compilation unit nobody it
requires you to list all the cases
together with the tree so extensibility
is maintained and also you get you
maintain encapsulation because the
pattern matching only reveals the
constructor parameter if any of these
classes had fields they could of course
have fields and these fields which
actually not form part of the patterns
so you can still have private fields and
pattern matching does not reveal those
fields all it does it tells you how this
thing was constructed so pattern
matching is just the reverse of object
construction that's that's all it is and
the other argument would be well if you
don't want to reveal the constructor
parameters because maybe for safety
reasons or because it's too expensive
because of course revealing them means
we have to keep them around somewhere
then just don't use case in front of a
class yes yeah so if you had like cherry
tree and we don't have a case it in
order and we run it on that then we get
an exception called a match error yeah
oh yeah right equals greater than yes
yeah that's my all these things are I
have this preprocessor which types at
scholar syntax and it does that
automatically yeah you can also use
right arrow as a unicode character so
that's very limited unicode support in
there but you can use the right arrow
unicode for the same thing so it's legal
to write it that way yes yes yes but you
have to wrap them up so that's a class
of parent triple and 2 / 4 and 2 / 5
which gives you just like a peasant
triples and so and you you so if you
want to match against two values you say
pair of a b match and then you say PK's
pair of pattern one pattern to pair of
pattern all these patterns have to be
past patterns can be nested freely so
here we see only pattern one level of
pattern nesting but you can have
patterns inside patterns yes generic
method on the time for energy yes
okay yeah so if you only mention to
construct arguments
the start I are always beautiful but if
you change the object object after is
constructed international original
that's right yeah we are actually
currently looking at a way to get make
it even more general and then you could
do things the things you want it also
but that's not done yet yeah are you
mapping on that argument to the
constructor are the types of the island
so the e would stand for anyway when we
build up tree and the e would stand for
the actual argument here but well here
you could say the e in a sense you can
see the can see this also as a type case
with definition with the automatic
definition of these elements of these
constructions yes is there way specify
type in hospital
we're way too
yes yes get to write a sealed abstract
class tree that means all the cases have
to be given in the same compilation unit
yeah okay a very lively discussion let's
see what I get to the end of this dark
should try okay let's go to the first
second unification they the second
unification is that we say funk
functions are objects so in Scala is a
functional language not in the sense
that we don't have immutable data we
that we don't have mutable data we do
have variables that you can change with
your fields at all this but it's a
functional language in the sense that
functions are very important they are
first-class citizens in particular every
function is a value and the second
edition is we have the usual syntactic
conveniences of functional languages
that we say we give you anonymous
functions sometimes closures we can have
curried functions and we can have nested
functions we can nest functions inside
other functions just like we can declare
values of other types inside functions
and family familiar higher-order
functions we can i implement it as
methods of standard scholar classes for
instance here's the array class which is
actually a java array class but we do
some magic to enrich it with more things
so our array class also has functions
exists and for all which are just the
existing forward medicaid's so these can
be used in things like this to find out
whether you are given matrix has a row
consisting only of 0 elements so let's
dissect this statement here it says
metrics dot exists so call the exists
method of metrics see whether something
exists in metrics and then you pass in
and on our anonymous function which says
is there a row such that for all
elements of the row the element is equal
to 0 so what you have here is an
anonymous function or closure that's the
parameter of the closure Scala has
fairly aggressive type inference so that
you don't need to give a parameter type
of this closure and hear you say road
out for all 0 equals that means all
elements in the row are equal to 0 so
partially applied functions so that's
just the equals method applied to a
number zero even primitive operations
like equals our methods in Scala are not
implemented as such in fact scholars a
scholar program would be implemented
almost the same way as a Java program
and it would have about the same
efficiency but for their for the high
level for the type system in compiler
equals is seen as a method so this is
the application of the zero method of of
the equals method 20 with a missing
parameter so it means it's a function
which takes annex and returns 0 equals
equals x bind to die sector so it's all
this dissection you one gets used to it
very quickly and i think the the bottom
line is it lets you write very very
concise code yes so I see one on the
power sorry if you wanna call them as
all zeros I think you right but it would
it would be quite possible to have a
transpose method on the metrics so would
say magic star transpose that exists and
transferred you could even arrange
things that the transpose is then lazily
that you won't do all the transpose at
once and then do it okay so now if
functions are values and we've seen the
scale as an object-oriented peer
object-oriented languages so values all
varies are objects then it must follow
that functions themselves are objects
and in fact they are the function type s
arrow T functions from s to T is just a
shorthand for a standard Skyler class
which is called scalar function one with
parameters s and T and here's the
definition of that class it's abstract
class function one of two type
parameters smt and all this class has is
an applying method and the apply takes a
mix of type s and returns at an element
of type T and of course at this level
there's no implementation of the apply
method because we're talking about the
type of all functions so you might write
so these things are so-called
declaration based variants that's that's
a way to express that functions are
covariant in their result type and
a variant in their argument type if you
don't know what this is don't worry it's
not essential for the rest of the clock
it's just the standard convention that
people want to have four functions okay
so the bottom line is functions are
interpreted as objects with applying
methods and here's a standard
implementation so that would be the
successor function that takes an X off
let's say type int and returns an X plus
1 so that would be expanded to new
function one of domain and range in def
apply it int int equals x plus 1 so
that's what the compiler essentially
does with this so that's what you get
and that's what currently you'd have to
write in Java if you want it to have
something which is equivalent to add two
to two functions so you can write these
things in Java but it's more cumbersome
okay so you might say okay good so all
this is a one yes means you would have
an infinite sitel right methods are
objects and then they have an apply
method so methods are in fact not
objects methods are primitive but there
is an automatic conversion that whenever
you want to use a method name as a value
it gets converted to a function but a
method is just the same as a java method
only whenever you want to treat it
independently not just apply to the
arguments the the Scala compiler will
make it into a function object I have an
object now just a class act for the
object food
and food do it is that is that
essentially a closure there is a pointer
to its object okay so good you might say
well that's maybe a consequence of this
design that if scholars post function
and object-oriented is there any use of
that why should I care about that well
one nice consequence of it since the
function arrow is a class it can be
subclassed so it means that now function
can actually actually be a root of a
complete class hierarchy of
specializations and one of the
specializations would be for instance
the array class you standard java array
class which we treat but in java it's
actually not a class we make it we make
it into a class by reinterpreting some
things so an array would just be a
particular function arrays are functions
from integer ranges to whatever the
element type of the array is and they do
have an apply method so we can that's
just a grey sub scripting but they also
have a method to return the length of
the array you have a method to change an
element in the array an update method
they have a method to give you back an
iterator that we are iterates over all
elements of the array and they would
also have things like exists and for all
that we have seen in the matric magmatic
matrix example so exists would take a
predicate p as a function from the
element type a to boolean and it will
just tell you whether there is an
element in the array for which this
predicate is true so one more bit of
syntactic sugar that we do is that week
you can write things like that a of I
equals a of I times too and that really
means a dot update of a eight of the ply
of I times two because the convention is
whenever you have an object a and you
use it as a function you apply to an
argument then the compiler will insert
and apply method in here I will do that
anywhere in expression position if you
have the same thing at the left hand
side of an assignment like this a of I
the compiler will insert an update for
you so that's some bit of syntactic
wizardry that lets you write the almost
usual array syntax
only with parents instead of brackets
and still reduce it to method cause one
thing that you gain with that is that he
can do exactly the same things for your
own sort of collections you can do this
with hash table so you can do with
Buddhist live with what whatever you can
use just this syntax for selection and
the syntax for update which is quite
quite nice so we completely abstract
from the concrete primitive type yes you
should invent in what ways right not
completely general so we don't we don't
have an language which says well you can
do whatever but there are a lot of hooks
in there like for instance this this
hook here like I said it works for class
array but also for other things you
might want to do for other collections
or other types that support similar
interfaces okay another useful
abstraction are in less well-known a
partial functions so a partial function
is a function that's defined only in
some part of its domain and what's more
we can inquire whether this function is
defined for a given value or not so the
definition of partial function would be
something that extends the function type
A to B and it would inherit the apply
method from this function type but it
would also add and method called is
defined at which says it takes an int of
type a and gives you back a boolean
which says says tells you whether the
function is defined at this thing or not
and one thing which is interesting is
that sky retreats blocks of pattern
matching cases like this one and if you
want to see well what actually does this
expand to the answer is it expands to a
partial function so the compiler will
take this pattern matching thing and
will say well on if I do not look at the
T match just this thing inside inside
the Curry's what is this well you might
say it's a function you give it an
argument if the argument is empty it
returns that if the argument is a binary
it returns that you can treat it as a
function and what's more you can also
find out whether it's defined or not we
just run the pattern matches without
computing anything
if you say well if it's that pattern or
that pattern you get back a true
otherwise you get back and forth so a
compiler will actually translate this
into one of these partial function
thingies and let that opens up a whole
new world of very interesting control
structures that you can define which are
really not easily accessible otherwise
so here's one which is something we have
been played playing with quite quite a
lot recently that involves concurrency
where one of the nice particularly nice
obstructions in concurrency I believe
our actors in the style of airline not
sure whether people here know ere long
it's been used for some pretty big
telecommunications which is it's one of
the very very few success stories we're
really concurrent programming has made
it into big applications and seems to
work reliably and seems to be usable by
ordinary people so what does a long have
well essentially it has these actors
which are processes and you have a
message passing system you send messages
directly to a process and that's done
with syntax like this actor Bank message
sends message to actor and then you have
a selective rate which is called receive
which is just a bunch of patterns you
say we sieve so the many message gets
sent it's an asynchronous end so it just
gets queued in a mailbox of the actor
and the actors can then do a receive
would say say well if I have in my
mailbox a message which matches one of
these patterns then execute the
corresponding action and that's sort of
all to get started with so easy on the
other hand if no pattern matches them
the receive will just block until their
further messages that it can inspect so
here's an example of an actor written in
that style so it's an order manager and
you say that's an actor which loops and
continue repeatedly does a receive and
if it receives an order then the order
would have a sender and an item and you
would handle it and you would send and
acknowledge to back to the sender and
there would be similar things for the
cancer thing and finally we would say
well we actually want to treat our
messages we don't want to leave them
in the message in the mailbox forever so
there's a third catch-all case X where X
is just a variable name so that matches
any pattern where you just say well in
any other case i append the message to
my junk fire here would be a customer
that interacts with this order manager
by sending it an order message and then
receiving back from the order message if
there's an acknowledgement and things
would be okay otherwise in this case it
would you reactor wouldn't expect
anything else and you would get a match
error that's just an example of what you
a typical programming style to do with
this yes if you care so the v2 to
disambiguate constants from variables
there's the there's the convention that
variable start with lowercase names and
constant should start with uppercase
names and the compiler goes to some
lengths to actually give you nice error
messages when it suspects that you have
done things wrong and yet you want to
use a constant but you you use the
lowercase mates okay so they of course
send it's fairly easy to how to do that
while you would just send it to an actor
and actor would have a mailbox
implemented as a queue or something it
would you would just include the message
in a shared memory system that's how you
would do the send how would you do the
receive but we've seen now that they
receive it takes one of these case
things and these case things they are
partial functions we've seen that so
what they receive actually would take
here will take a partial function from
some type of messages actually message
can be can be the same thing as object
can be anything and I is just an
polymorphic result type of the receive
so it's a partial function of message to
an arbitrary result type a and what do
we need to do while we need to look at
our own mailbox self it's a global
variable that gives us a the currently
running actor so we do self dot mailbox
extract first that's a standard method
in queues in this color collection
libraries and extract first extracts the
first method
that matches a given predicate what
predicates do we have to pass well we
have to pass a predicate that our
partial function is actually defined for
that message which is just F dot is
defined at F is defined that means for
arbitrary X return f is defined at X so
that's exactly what we need so what this
thing would do is it would extract the
first thing that matches that for for
which the function is defined and then
the extract first is actually it
constructed it gives you back another
thing on which you pattern match which
is a so-called option type so if it
found something it will give you back
some of some message and that's then the
message you run the f of if it hasn't
found anything it will give you back a
nun which says undefined and in that
case the receive would have to wait for
another message to be sent yes right so
yeah I would have to be an a so so
there's something missing you would have
to them afterwards ram the sense run the
same we see very perceptive things yeah
so that's that's missing indeed ok so
one possible objection to that is well
you've sort of just duplicated what
people did in Ellen so why do that when
actors are already in a pure more
optimized form in LA and I think one
good reason is that libraries are much
easier to change then languages so by
doing being able to do these things in a
library it's much much easier to
experiment with things to change things
to optimize things to to to react to new
developments so one example for that is
that both element a scholar library the
original scholar library i should say
attached one thread to each actor so
every actor is a thread and that's can
be a big problem for java because
threads are expensive so it means you
can't scale this over beyond a couple
thousand actress and some applications
want more than that elling is much much
better than handling and handling many
threads because it has a run time system
which is optimized for that but even it
can be overwhelmed by really huge
numbers of actress and what do you do is
thread
are too expensive well you want to go
diva event based right so the threads
are too expensive you do event based
programming and normally that means
inversion of control so you which means
you have to completely rewrite your
program turn it inside out that's not
good but if we actually implement actors
the way we do in the library it's quite
easy to implement a violation of receive
which we call react which liberates the
running thread when it blocks for a
message the only restriction fall for
the react is that when you liberate the
running thread then all that you will do
when the message then finally comes has
to be in this partial function
afterwards you can't do really do
anything useful because you have given
away the thread and we can express this
in the type in Scala so the nothing type
ism means that you will actually not
return from this function nothing is
ever returned from the function another
type another function that has typed
nothing would be a function that always
throws an exception so that also would
have typed nothing yes box for
synchronize clocks which somehow have to
exit 1 this is there
because I actually raising an exception
when when when this thing is so
therefore so there is an exception
raised so the giant code is virtually
unchanged between market rate and
event-based actors and what you gain you
can see here we did some performance
tests so the it's a simple benchmark you
have a number of processes which you
vary on this axis and they just pass
tokens around in a ring and you measure
the number of token passes per second in
approach in relation to the number of
processes that you have so Sansa is the
current standard library for actors it's
em we're done down here it's not very
optimized you can see the original
thread based actors are here so they're
not very good they go down the native
java implementation is here and the
event based actors are up here so with
bye-bye going to to to to this event
thing you can have virtually the same
program but get much better performance
and much much better scalability so you
see that this is virtually unchanged a
member of processes whereas even the
native thread based implementation goes
down steeply after you push the
processes beyond two thousand or so over
this on this on this machine I think of
je viens there's a lot of things that we
have really trouble to explain yeah ok
how much more time do you have so it's
20 minutes so i have to go bit fast on
that so the third unification now so so
far we have talked about programming
mostly in the small what do how can we
play with functions pattern matching
things like that the the next the last
thing i want to talk about is
programming in the large where Scylla
actually has a quite clean and powerful
type system which gives you new ways to
abstract and compose component so what's
a component well this is just a program
part that you want to combine with other
parts in bigger applications or in
bigger components that's we want to see
it we don't want to apply it down
further and
and the requirement is that the
component should be reusable that means
that you should be able to employ a
component in a context different for the
context in which it was for which it was
designed so to be reusable a component
needs interfaces that's clear and it
needs interfaces to describe what it
provides but also to describe what it
requires because if you don't do that
then all you have is an API is one some
big mass of software sitting at the
bottom and you can build on it but you
can't take something out of it and put
it in a new context and tie it to new
foundations that's not possible so true
components need interfaces for provided
as well as required services and most
current components actually are not very
reusable that basically just we we just
have api is not two components and i
think that has to do with the fact that
most current languages can specify are
pretty good at specifying provided
services think Java interfaces but
they're not really good at specifying
required services in Java how will how
you how would you do it do that well you
just use it sorry yeah but how do you
say well I need that to run
i mean i understand it
me silly for doing I acknowledge thanks
great language but it's not okay good
well I I get pretty hard looking at the
experiences we had let's let's go
through the slides and then dempsey see
but what you have to say it okay so one
other way to see this is that a
component should refer to other
components not by hard links but only by
the required interfaces and if you push
it to the extreme than you say then you
would say you wouldn't have any statics
whatsoever no statics because static
data is a hard link you refer to statics
you can't change it afterwards even
static classes are troublesome because
they are also hard links global
references to it that principle is not
new but in fact if you push it to the
extreme it's surprisingly difficult to
achieve in particular when you extend it
to types and classes so one language it
has pushed it to the extreme is ml 0
with the functor obstruction and I who
is familiar with functors and ml who's
comfortable with functors in ml 1 okay
that's good so functors I I think you to
be fair there are a bit clunky they are
really great heavy-duty program
abstractions but you have to get your
head wrapped around them so what's the
functor idea the funked idea is a
component is structure which is just a
male's way of saying a module and but if
it depends on other components then it
would be a functor which is essentially
a function from modules to modules an
interface of a component DML people have
also they call just call it a signature
a required component then is a parameter
to that functor and composition is
application of the functor to some
arguments so that's what they do and
then you need a problem with this with
the usual diamond problems that you you
have a funky funky here it takes two
things and they take another thing and
you want to make sure that the other
thing is the same and that's done by is
fairly esoteric things called sharing
constraints so there's some shortcomings
with the story that one thing you can't
do is have recursive references
components because a functor can of
course inspect its parameters but the
parameter cannot access the functor and
the problem is all big systems I know of
want to have some recursive references
reference in there so not having them is
a severe limitation there's no
inheritance with overriding zuv none of
the object oriented stuff and structures
are not first class so you can't rewire
them at runtime based on things that you
know only at runtime it's completely
static the the layout of a module system
in Scala it's different so in Scala we
say a component is a class and interface
is an abstract class or a trait a
required component would be an abstract
type member or we can also do it with
explicit self types we're going to see
how that goes and composition is mixing
composition so we have a generalization
of the single inheritance plus
interfaces in Java where we say instead
of interfaces we can have so-called
traits that can also have method
implementations that can even have state
and we have mixing compositions to do
that so the advantages of the model is
that now components is denser to objects
and these are first-class values we can
support recursive references we can be a
inheritance and we have very very
concise wiring because sub components
are identified by name we'll see an
example in a couple of slides okay so if
we look at how to express components or
two how to abstract our components and I
think for any in any programming
languages I think that two fundamental
ways to abstract other things one is
functional the other is object-oriented
so the functional way to do it would be
para user parameter you don't know what
it depends on user parameterize it the
object-oriented way would be to say use
an abstract member just postulated as a
member in the class if you look at Java
then it's actually quite interesting it
supports both but for different things
so why does it use parameters well it
uses it for non functional values so for
playing values you use parameters you
can't abstract over a value as you can
only appear
you can't have an abstract value in a
class you can only have an abstract
method in a class so in our terminology
if you go to functional values then you
can't use parameterization anymore
because values are not objects but you
need to use an abstract method if you
look at types then four types with the
juice generics well it's
parameterization again no abstract
members so in skala we try to be
complete in that sense that we give you
everything for all sorts of values so
for every four values functions and
types you have parameterization and you
have abstract members you can choose
anything you want you might say well
doesn't that make for a very complex
language well in a sense yes we try to
be on the other end we try to be very
orthogonal and conceptually rather know
because we really play with this
functional object oriented duality that
we can say we can express all sorts of
parameterization as abstract members so
to be able to say to arrive at typing
rules for parameters we can actually say
well what's the corresponding object
oriented abstraction room then go back
ok so one here's a very simple program
that uses that it's the program the
class gives you a a class of cells which
have just a single value of type T and
the Gator in the center and usually you
would say well we write this as a
parameterised class you can do that of
course but let's use object-oriented
abstraction because that's that's less
familiar here so what we do for in
object-oriented obstruction we would say
well this class actually has a type
member T so T is a member of this class
and it has an initial value also of this
type T so these two guys they are
abstract we don't have an abstract
keyboard in skaara you know that their
abstract just because there's an
implementation that's missing for these
things and the other three guys are
concrete so they get Isetta and the
variable so now let's do something with
it so when we can create a new abstract
cell then we have to just fill in the
abstract things as usual with an
anonymous class and because type is
abstract we also
have to fill it in so we say type T
equals end for this thing and the
initial value is 1 and that works
because the types are compatible and
then you can write cell dot set so that
get x 2 and the compiler will figure out
that this is all correct because it
knows that cell has the type AB cell
where type T equals int this is a
essentially a notion of a type
refinement where you can say you can
type can be a class name and you can
have further identities of types or or
signatures for four members in these
things okay let's do something more
interesting so far we have only
duplicated the parameter ization thing
what we actually can do we can also
access app cell without knowing the type
of its element so here's one example to
do to that uses that a reset method so
it would take a nap cell and would set
set C to its initial value and no we
don't even refer to the element type of
this abstract cell so why does this work
well if you look at the type of c dot in
it and that type is actually what should
it be now here we say in it is of type T
but of course p makes no sense because t
is local to this class here so it's not
even visible globally as a type every
class every cell might have a different
type t so what we have to do is we have
to use members so the type of T is the
type of c dot in it would be c dot T so
you can have types that have a prefix
which is a reference to an object and
the method c dot set then analogously
has type 0 t to unit unit is our notion
of void and right we will get there yeah
yeah thank you so the formal parameter
type in the argument type coincide and
everything is type correct so generally
they can actually be more than one level
of selection in here but the type the
prefix here must be an immutable value
followed by possibly some immutable
field references and at the end you have
a type T so these things we call
path-dependent types
so they're essentially the central
innovation in the type system of scholar
that's essentially what what the whole
thing rests on okay so why can't my
campaign can we not allow these things
to change I probably don't have time to
go into it so ask me after the talk if
you doubt it if you think why why why
can't we have types that change so
there's a there's a slight which tells
you why this would be to type
unsoundness so but let's look at an
example where we use these things and
the example is a very real one because
when I wrote the Java C compiler
originally it wasn't very componentized
it was essentially had a lot of hard
links in there and when I wrote the
Scala compiler I used the same ideas so
it was essentially the same the same
layout so in a compiler in particular
you need to model symbols and pipes and
each aspect depends on the other a
symbol has a type a type might be a
class which contains symbols so there's
a there's a recursive cycle and both
aspects require substantial pieces of
code so the first attempt of writing a
scholar compiler in Scala define to
global objects one for each aspect so it
would be an object symbols and an object
types and that defines a class symbol
and that defines a class type and they
refer to each other here and they might
also even have static data okay so that
was the initial design and we had
several problems and shortcomings the
first one is they contain hard
references to each other symbols and
types so it's impossible to adapt one
while keeping the other but actually I
idealized a bit the original version of
the Scala compiler was written in Java
and these things would have been static
data in the class symbol but of to
translate into a scholar context we did
it that way the second problem is some
symbols and types contain static data
and some of this data was even mutable
so the compiler is not re-entrant
multiple copies of a drug cannot run in
the same OS context in same OS process
and I think for the Java compiler it was
the same thing when I dropped it into me
or slap it was still have had the same
flower design a new hat
do something about it to make it
reentrant so because why does a compiler
need to be reentrant well if you want to
run it as say as a plug-in for eclipse
or another I de NetBeans or things like
that then it wants to run multiple
instances of your compiler ones for a
syntax check one for a background build
site so what do you do to make it
reentrant well the the usual approach
would be to say let's well I think that
the thing that happened in the Java C
compiler is that you say well let's just
collect all this data the static data
and put it into an so-called context
object and let's parameterize everyone
with this context object and then we're
done the one big problem with all this
is that it totally breaks
object-oriented encapsulation because in
this complex object actually everything
everything is accessible to everyone so
functional program is what rejoice
because they would say well I knew it
object-oriented program objected
encapsulation is a fluke from the
beginning it's not real right you can't
really do real real reentrant systems
that way but I don't think that's the
end of the story I think one can do
better than that so how can one do
better than that well the second attempt
would be let's just look at the
reentrant see problem first and of
course if you have nesting arbitrary
nesting of things which we have in Scala
and we can put these symbols objects and
types with a nested symbol class and
types inside an enclosing class symbol
table and symbols so because this thing
is a class it can be instantiated
multiple times every compiler would have
their symbol table with separate static
data so it would solve the reentrant see
problem but it actually worsens the
component reuse problems because first
symbols and types still have hard
references to each other and second they
can't even be compiled separately
anymore they're in one big huge file so
that's not really what you want so the
question is how you can we get more or
less that but still maintain separate
compilation in different source files so
the third attempt is a component based
solution where the problem is well how
can you expect
the required services of a repellent in
that case we'd have two symbols and
types and symbols requires a type
abstraction and types requires a symbol
abstraction and the ants these implants
as well abstract over them and what we
have for abstraction you have
parameterization and the abstract
members but because these things are
recursive there's only abstract members
that remain because with both parameters
we know no recursive references so let's
try abstract members let's put an
abstract type type in symbols and
abstract type symbols in types so now
their classes and each abstracts over
the identity of the other type so how do
you combine them well here's how write a
simple table and say extend symbols with
types so that's the mixing composition
we have in SCADA you can just take
arbitrary classes that you define as
strikes and you mix them in together and
what happens when you mix them in is
that anything which is concrete will
replace anything that's abstracting all
the other participants so if you go back
because there's an abstract member of
type type but there's a concrete one
here the mixing composition will have
this member so there will be a relinking
so this reference will now go directly
to this type and four symbols if we go
the other way because there's an
abstract member of symbol here that will
plug into the concrete member type here
so because this net we have this name
based identification scheme it's very
very concise we don't need an explicit
wiring to say this this this wire goes
here and that wire goes here so it's all
done by name okay so that's nice and
that would work but actually i lied a
little bit because in fact what really
happens here you don't just want to
postulate an abstract class type in the
class symbols there would be a lot of
operations on types so you would say
this type has to be implement at least a
bunch of interfaces that you specify for
types and symbols is saying so once
you're done with specifying all these
interfaces then actually that's a quite
a big specification to that's cumbersome
to write all that down so the question
is is there a more concise way to do it
and the answer is yes there is so what
we do is we
have something called required
interfaces or self types what we're
actually right in the Scala compiler we
say class symbols requires well actually
you can you can you can leave that out
you can write require symbols with types
or you just write requires types and
class types requires symbols and then
symbol table extend symbols with types
so the question is you sort of know what
it means it sort of means well I need
any any the class types or a subclass
they're off to be mixed in with me when
I'm instantiated and four types it means
the same thing but the question is well
can we give a more precise definition of
what it means and the answer quite
surprising is yes we can when you write
a Class C requires T then we call
yourself type and the only thing that
really means is that the type of this
inside Class C is now T so you might say
well isn't the class type of this the
class itself that's what what its usual
but if you think about it there's no
reason why this needs to be so the type
of this can be whatever you want it to
be it does not have it there there's not
another thing a good reason why it has
to be the type of the enclosing chest
yes
but you can you can change T later on
Yeah right okay but okay so the initial
version has to be compiled together but
then they can evolve independently yeah
right good question Thanks okay so
without an explicit requires annotation
the type of this and Scylla is just the
type of thing closing class as usual but
you can do say requires tea and then in
that case the type of this would just be
T so let's see why this works now let's
in this thing now the type of this year
would be symbols myth types and the
theater type of this would be types of
symbols it's actually it doesn't matter
you can write symbols with types types
with symbols in this context it's the
same thing so then when you right here
type where to say where does it resolve
the identifier type well as usual when
you have a member access its it's
resolved to this dot member so in the in
the identity of the current object the
current object is assembled with types
so it's a mixing composition of the two
so you say in this mixing composition I
have an implementation of type here so
the type of the type will resolve to
this and the symbol in the same way so
that's why it works ok so and actually
you can push this thing 20 ml kind
thingies and have a required thing but
probably I skip that because time is
running out so the benefits of this
scheme is its first it's very very
general so you can take any combination
of static modules and lift it to an
assembly of components you get
documented interfaces for required as
well it's provided services in this
requires clause you list exactly what
you require you can get for free
multiply instantiation of components so
you don't have a problem with three
entrances and you can give be very
flexible in extending and adapting
components so there are a couple of
slides that I skipped it show you how
you could do that by adding a login
service to a compiler and essentially it
all comes down just to in the end mixing
composition and and that's all you need
to do so you so the bottom line is that
a lot of the things that you people
think they need a op4 aspect
programming now actually can be can be
done much much simpler using just mixing
composition if you take it seriously
that you say no static data and
everything is an object yes this
standard stock is it true that mixing
our position is essentially like using
interfaces to express the fantasies plus
the ability of constructors of objects
of these interfaces
no it's more because you mix your good
your compose classes that actually have
concrete methods implementations and
might even have fields and variables so
it's more it's there's a subtle
difference between it and multiple
inheritance so it's closer to multiple
inheritance really the difference is
that super calls work correctly for
mixing composition that means for mixing
composition a super cold chain would
just read through bears but for multiple
inheritance it would not do the right
thing yes
but I so quickly okay point noted so
here's some summing up here some counts
of compilers I've been involved with so
that's the that's the original that the
Java Sea pre wildcards 1.5 Java Sea a
version which was sort of the thing when
i gave it to sun and didn't work on it
anymore so that's what work was like the
last code the count count of lines of
code so i guess it probably is slightly
bigger now i don't know how much bigger
then we rewrote the thing mostly in java
actually using some pattern matching
with it that already shrunk it a bit and
that was the first scholarship compiler
and then we rewrote the thing in Scala
in Scala and we got that overall it's
true it was the second version of the
compiler but overall in the compiler
history that was like the 5th compiler
I've written that was like the fourth so
I didn't get much better between the
fourth and the fifth I don't think so so
I think I think I don't think I learned
a lot how to do it better I think a lot
of it was really that scala really gives
you ways to express yourself extremely
concisely and sure i mean you have to
learn it and it there is a learning
curve to it but I my mic lioness and I
have nothing to prove this claim but my
claim is that experienced programmers
can become about twice as productive use
half as many lines and be twice as
productive as with Java today that's
just a claim that we can debate
endlessly nada
absolutely correct no no I don't
unfortunately don't have three numbers
of big big other projects because we we
are in the compiler thing and there some
companies using it for big project but
they don't give us their source code so
we don't really know so okay so in in
the experience I think the combination
of FP and Opie has worked exceptionally
well better than the first suspected
that it would work it's can i really
lets you write quite pleasingly concise
and expressive code it's one thing which
we didn't do it's really great to do as
house hosted domain specific languages
so for instance I have an implementation
of prologue in Scala which looks to you
and ninety-five percent prologue so it
just looks like prologue but it's it's
nothing but a bunch of library calls for
a java library for a scholar library
which is itself just of a hundred lines
or something like that so it's it's it's
very very malleable syntactically and it
has a very very strong abstractions
underneath so that's why it really works
very well for domain-specific languages
and we made some discoveries mostly on
the object-oriented side not on the
functional side so we've seen some of
them in particular the mixing
composition cell types and the type
abstraction that was new yes there's
another talk scheduled in this room so I
come to the community
so to conclude we have shown you a
blender function and object-oriented
programming overall I think programming
in Scala for me at least it has a
similar field and programming in a
modern scripting language but without
giving up the static typing and you can
try it out on this URL it's very
user-friendly such lots of documentation
very quick installs and all that and
that also like to thank the members of
the team the who who worked pretty hard
on this thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>